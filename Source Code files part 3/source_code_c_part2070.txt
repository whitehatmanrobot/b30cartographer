 to tell OACR that a buffer has a certain readable extent at this point of execution
// it can be used to silent noisy espX INCORRECT_ANNOTATION warnings
#if( defined(OACR) && OACR && defined(_Post_bytecount_) )
__extern_c void __OACRAssumeByteCount( _Post_bytecount_(cb) const void* pv, size_t cb );
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __OACRAssumeByteCount( pv, cb )

#else
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __oacr_noop

#endif


// new intrinsinc functions in Whidbey compiler
#if( defined(_PREFAST2_) && _PREFAST2_ )
__extern_c void* _AddressOfReturnAddress();
#endif

// OACR custom plugin specific extensions

//=======================================================================

#define _Callback_                         __oacr_callback

#undef __override
#define __override                         __oacr_override

//======================================================================
// OACR custom attributes

// OACR custom plugin specific extensions

#if( _USE_ATTRIBUTES_FOR_SAL || OACR_FOREGROUND_ATTRIBUTES )

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#if defined(__cplusplus)
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

enum OACRFunctionFlag
{
   eOACRCallback          = 0x0001,
   eOACRRpc               = 0x0002,
   eOACROverride          = 0x0004,
   eOACRSealed            = 0x0008,
   eOACRMemberInitializer = 0x0010,
   eOACRUnsafeStringApi   = 0x0020,
   eOACRNeedsReview       = 0x0040,
   eOACRIntlDeprecated    = 0x0080,
   eOACRNoInferrence      = 0x0100,
   //eOACRMinFunction     = 0x0200,
   //eOACRMaxFunction     = 0x0400,
   //eOACRCompilerGen     = 0x0800,
   eOACRCanThrow          = 0x1000,
   eOACRBindReturn        = 0x2000,
};

REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionFlagsAttribute
{
#if defined(__cplusplus)
	OACRFunctionFlagsAttribute();
#endif
	int Flags;
};

enum OACRFunctionProp
{
   eOACRDeprecated     = 0,
   eOACROleoDeprecated = 1,
};

typedef enum OACRFunctionProp OACRFunctionProp;

#pragma warning( push )
#pragma warning( disable:4820 )
REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionPropAttribute
{
#if defined(__cplusplus)
	OACRFunctionPropAttribute();
#endif
	OACRFunctionProp Type;
   const char*      SzVal;
};
#pragma warning( pop )

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

typedef struct OACRFunctionFlagsAttribute SA_OACRFunctionFlags;
typedef struct OACRFunctionPropAttribute  SA_OACRFunctionProp;

//--------------------------------------------------

#if defined(_PREFAST_)
// use __declspecs until Whidbey-PREfast bug VS:479840 is fixed
#define __oacr_callback          __declspec("_Callback_")
#define __oacr_override          __declspec("_Override_")
#else  // _PREFAST_
#define __oacr_callback
#define __oacr_override
#endif  // _PREFAST_
//#define __oacr_callback          [method:SA_OACRFunctionFlags(Flags=eOACRCallback         )]
//#define __oacr_override          [method:SA_OACRFunctionFlags(Flags=eOACROverride         )]
#define __oacr_rpc               [method:SA_OACRFunctionFlags(Flags=eOACRRpc)]
#define __oacr_sealed_method     [method:SA_OACRFunctionFlags(Flags=eOACRSealed)]
#define __oacr_memberinitializer [method:SA_OACRFunctionFlags(Flags=eOACRMemberInitializer)]
#define __oacr_unsafe_string_api [method:SA_OACRFunctionFlags(Flags=eOACRUnsafeStringApi)]
#define __oacr_needsreview       [method:SA_OACRFunctionFlags(Flags=eOACRNeedsReview)]
#define __oacr_intl_deprecated   [method:SA_OACRFunctionFlags(Flags=eOACRIntlDeprecated)]
#define __oacr_noinference       [method:SA_OACRFunctionFlags(Flags=eOACRNoInferrence)]
#define __oacr_canthrow          [method:SA_OACRFunctionFlags(Flags=eOACRCanThrow)]
#define __oacr_bindReturn        [method:SA_OACRFunctionFlags(Flags=eOACRBindReturn)]

#define __oacr_sa_deprecated( NewFunctionName )   [method:SA_OACRFunctionProp(Type=eOACRDeprecated,    SzVal=#NewFunctionName)]
#define __oacr_oleo_deprecated( NewFunctionName ) [method:SA_OACRFunctionProp(Type=eOACROleoDeprecated,SzVal=#NewFunctionName)]

#if defined(_PREFAST_)
#define __oacr_genericfunctype  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype  __declspec("_Nothrowfunctype_")
#define __oacr_noheap           __declspec("_Noheap_" )
#define __oacr_notrunccast      __declspec("_Notrunccast_" )
#define __oacr_sealed_class     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();
#else  // _PREFAST_
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow
#endif  // _PREFAST_

#elif( _USE_DECLSPECS_FOR_SAL )

#define __oacr_callback                         __declspec("_Callback_")
#define __oacr_override                         __declspec("_Override_")
#define __oacr_rpc                              __declspec("_Rpc_")
#define __oacr_sealed_method                    __declspec("_Sealed_")
#define __oacr_memberinitializer                __declspec("_Memberinitializer_")
#define __oacr_unsafe_string_api                __declspec("_Unsafe_string_api_")
#define __oacr_needsreview                      __declspec("_Needsreview_")
#define __oacr_intl_deprecated                  __declspec("_Intl_deprecated_")
#define __oacr_noinference                      __declspec("_Noinference_")
#define __oacr_canthrow                         __declspec("_Canthrow_")
#define __oacr_bindReturn                       __declspec("_BindReturn_")
#define __oacr_sa_deprecated(NewFunctionName)   __declspec("_SA_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_oleo_deprecated(NewFunctionName) __declspec("_Oleo_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_genericfunctype                  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype                  __declspec("__nothrowfunctype") // TODO: change to _Nothrowfunctype_
#define __oacr_noheap                           __declspec("_Noheap_")
#define __oacr_notrunccast                      __declspec("_Notrunccast_")
#define __oacr_sealed_class                     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();

#else // neither [attributes] not __declspecs

#define __oacr_callback
#define __oacr_override
#define __oacr_rpc
#define __oacr_sealed_method
#define __oacr_memberinitializer
#define __oacr_unsafe_string_api
#define __oacr_needsreview
#define __oacr_intl_deprecated
#define __oacr_noinference
#define __oacr_canthrow
#define __oacr_bindReturn
#define __oacr_sa_deprecated(NewFunctionName)
#define __oacr_oleo_deprecated(NewFunctionName)
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\amd64\inc\pftwarnings.h ===
#pragma once
/*****************************************************************************

DO NOT EDIT - Generated file

PREfast Warning Ids

PREfast(x86)      : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   espcxxdrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   goldpft        : 9.0.21022.40216
   integeroverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.41211
   oacrexc        : 9.0.21022.41211
   oacrmodel      : 9.0.21022.41211
   salcheck       : 9.0.21022.30208

PREfast(amd64)    : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   espcxxdrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   goldpft        : 9.0.21022.40216
   integeroverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.41211
   oacrexc        : 9.0.21022.41211
   oacrmodel      : 9.0.21022.41211
   salcheck       : 9.0.21022.30208

Esp               : 1.2.30415.30908
Defect modules
   cfgpersist     : 1.2.30415.30908
   espbldchk      : 1.2.30415.30908
   espopal        : 1.2.30415.30908
   nullptr        : 1.2.30415.30908
   sqleye.tsql    : 1.2.30415.30516
   in             : <no version>
   sqleye.managed.escapinganddelimiting: <no version>
   sqleye.native.escapinganddelimiting: <no version>
   sqleye.native.missingcommandsal: <no version>
   sqleye.native.missingconnectionstringsal: <no version>
   sqleye.native.truncation: <no version>
   sqleye.tsql.escapinganddelimiting: <no version>

Generated on 03/29/10 at 15:29:04

*****************************************************************************/


#ifdef OACR

/* MSPFT */

#define __WARNING_6001 6001
#define __WARNING_USING_UNINIT_VAR 6001
#define __WARNING_6011 6011
#define __WARNING_DEREF_NULL_PTR 6011
#define __WARNING_6029 6029
#define __WARNING_USING_TAINTED_DATA 6029
#define __WARNING_6031 6031
#define __WARNING_RETVAL_IGNORED_FUNC_COULD_FAIL 6031
#define __WARNING_6053 6053
#define __WARNING_MISSING_ZERO_TERMINATION1 6053
#define __WARNING_6054 6054
#define __WARNING_MISSING_ZERO_TERMINATION2 6054
#define __WARNING_6057 6057
#define __WARNING_CHAR_BYTE_SIZE_MISMATCH 6057
#define __WARNING_6059 6059
#define __WARNING_BAD_CONCATENATION 6059
#define __WARNING_6063 6063
#define __WARNING_MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6063
#define __WARNING_6064 6064
#define __WARNING_MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6064
#define __WARNING_6066 6066
#define __WARNING_NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION 6066
#define __WARNING_6067 6067
#define __WARNING_NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6067
#define __WARNING_6200 6200
#define __WARNING_INDEX_EXCEEDS_MAX_NONSTACK 6200
#define __WARNING_6201 6201
#define __WARNING_INDEX_EXCEEDS_MAX 6201
#define __WARNING_6202 6202
#define __WARNING_BUFFER_OVERRUN 6202
#define __WARNING_6203 6203
#define __WARNING_BUFFER_OVERRUN_NONSTACK 6203
#define __WARNING_6204 6204
#define __WARNING_UNVALIDATED_PARAM 6204
#define __WARNING_6209 6209
#define __WARNING_SIZEOF_CHAR_BYTE_SIZE_MISMATCH 6209
#define __WARNING_6211 6211
#define __WARNING_MEMORY_LEAK_EXCEPTION 6211
#define __WARNING_6214 6214
#define __WARNING_CAST_HRESULT_TO_BOOL 6214
#define __WARNING_6215 6215
#define __WARNING_CAST_BOOL_TO_HRESULT 6215
#define __WARNING_6216 6216
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_HRESULT 6216
#define __WARNING_6217 6217
#define __WARNING_TESTING_HRESULT_WITH_NOT 6217
#define __WARNING_6219 6219
#define __WARNING_COMPARING_HRESULT_TO_ONE 6219
#define __WARNING_6220 6220
#define __WARNING_COMPARING_HRESULT_TO_MINUS_ONE 6220
#define __WARNING_6221 6221
#define __WARNING_COMPARING_HRESULT_TO_INT 6221
#define __WARNING_6225 6225
#define __WARNING_ASSIGNING_ONE_TO_HRESULT 6225
#define __WARNING_6226 6226
#define __WARNING_ASSIGNING_MINUS_ONE_TO_HRESULT 6226
#define __WARNING_6230 6230
#define __WARNING_USING_HRESULT_IN_BOOLEAN_CONTEXT 6230
#define __WARNING_6235 6235
#define __WARNING_NONZEROLOGICALOR 6235
#define __WARNING_6236 6236
#define __WARNING_LOGICALORNONZERO 6236
#define __WARNING_6237 6237
#define __WARNING_ZEROLOGICALANDLOSINGSIDEEFFECTS 6237
#define __WARNING_6239 6239
#define __WARNING_NONZEROLOGICALAND 6239
#define __WARNING_6240 6240
#define __WARNING_LOGICALANDNONZERO 6240
#define __WARNING_6242 6242
#define __WARNING_LOCALUNWINDFORCED 6242
#define __WARNING_6244 6244
#define __WARNING_LOCALDECLHIDESGLOBAL 6244
#define __WARNING_6246 6246
#define __WARNING_LOCALDECLHIDESLOCAL 6246
#define __WARNING_6248 6248
#define __WARNING_CREATINGNULLDACL 6248
#define __WARNING_6250 6250
#define __WARNING_WIN32UNRELEASEDVADS 6250
#define __WARNING_6255 6255
#define __WARNING_UNPROTECTEDUSEOFALLOCA 6255
#define __WARNING_6258 6258
#define __WARNING_USINGTERMINATETHREAD 6258
#define __WARNING_6259 6259
#define __WARNING_DEADCODEINBITORLIMITEDSWITCH 6259
#define __WARNING_6260 6260
#define __WARNING_USEOFBYTEAREA 6260
#define __WARNING_6262 6262
#define __WARNING_EXCESSIVESTACKUSAGE 6262
#define __WARNING_6263 6263
#define __WARNING_USINGALLOCAINLOOP 6263
#define __WARNING_6268 6268
#define __WARNING_MISPARENTHESIZED_CASTS 6268
#define __WARNING_6269 6269
#define __WARNING_POINTER_DEREF_DISCARDED 6269
#define __WARNING_6270 6270
#define __WARNING_MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6270
#define __WARNING_6271 6271
#define __WARNING_EXTRA_ARGUMENT_TO_FORMAT_FUNCTION 6271
#define __WARNING_6272 6272
#define __WARNING_NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6272
#define __WARNING_6273 6273
#define __WARNING_NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6273
#define __WARNING_6274 6274
#define __WARNING_NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6274
#define __WARNING_6276 6276
#define __WARNING_CHAR_TO_WCHAR_CAST 6276
#define __WARNING_6277 6277
#define __WARNING_CREATEPROCESS_ESCAPE 6277
#define __WARNING_6278 6278
#define __WARNING_ARRAY_NEW_DELETE_MISMATCH 6278
#define __WARNING_6279 6279
#define __WARNING_NEW_ARRAY_DELETE_MISMATCH 6279
#define __WARNING_6280 6280
#define __WARNING_MEMORY_ALLOCATION_MISMATCH 6280
#define __WARNING_6281 6281
#define __WARNING_BITWISERELATIONPRECEDENCEERROR 6281
#define __WARNING_6282 6282
#define __WARNING_ASSIGNMENTREPLACESTEST 6282
#define __WARNING_6283 6283
#define __WARNING_PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH 6283
#define __WARNING_6284 6284
#define __WARNING_OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6284
#define __WARNING_6285 6285
#define __WARNING_LOGICALOROFCONSTANTS 6285
#define __WARNING_6286 6286
#define __WARNING_NONZEROLOGICALORLOSINGSIDEEFFECTS 6286
#define __WARNING_6287 6287
#define __WARNING_REDUNDANTTEST 6287
#define __WARNING_6288 6288
#define __WARNING_MUTUALINCLUSIONOVERANDISFALSE 6288
#define __WARNING_6289 6289
#define __WARNING_MUTUALEXCLUSIONOVERORISTRUE 6289
#define __WARNING_6290 6290
#define __WARNING_LOGICALNOTBITWISEAND 6290
#define __WARNING_6291 6291
#define __WARNING_LOGICALNOTBITWISEOR 6291
#define __WARNING_6292 6292
#define __WARNING_LOOP_COUNTS_UP_FROM_MAX 6292
#define __WARNING_6293 6293
#define __WARNING_LOOP_INDEX_GOES_NEGATIVE 6293
#define __WARNING_6294 6294
#define __WARNING_LOOP_BODY_NEVER_EXECUTED 6294
#define __WARNING_6295 6295
#define __WARNING_INFINITE_LOOP 6295
#define __WARNING_6296 6296
#define __WARNING_LOOP_ONLY_EXECUTED_ONCE 6296
#define __WARNING_6297 6297
#define __WARNING_RESULTOFSHIFTCASTTOLARGERSIZE 6297
#define __WARNING_6298 6298
#define __WARNING_CONST_STRING_TO_WRITABLE_STRING 6298
#define __WARNING_6299 6299
#define __WARNING_BITFIELD_TO_BOOL_COMPARISON 6299
#define __WARNING_6302 6302
#define __WARNING_CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION 6302
#define __WARNING_6303 6303
#define __WARNING_WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6303
#define __WARNING_6305 6305
#define __WARNING_SIZEOF_COUNTOF_MISMATCH 6305
#define __WARNING_6306 6306
#define __WARNING_INCORRECT_VARARG_FUNCTIONCALL 6306
#define __WARNING_6308 6308
#define __WARNING_REALLOCLEAK 6308
#define __WARNING_6309 6309
#define __WARNING_PASSING_FUNCTION_UNEXPECTED_NULL 6309
#define __WARNING_6310 6310
#define __WARNING_ILLEGALEXCEPTEXPRCONST 6310
#define __WARNING_6312 6312
#define __WARNING_EXCEPTIONCONTINUEEXECUTION 6312
#define __WARNING_6313 6313
#define __WARNING_BITANDVSZEROVALUEDFLAG 6313
#define __WARNING_6314 6314
#define __WARNING_BITORVSQUESTION 6314
#define __WARNING_6315 6315
#define __WARNING_BITORVSBITAND 6315
#define __WARNING_6316 6316
#define __WARNING_INAPPROPRIATEUSEOFBITOR 6316
#define __WARNING_6317 6317
#define __WARNING_NOTNOTCOMPLEMENT 6317
#define __WARNING_6318 6318
#define __WARNING_EXCEPTIONCONTINUESEARCH 6318
#define __WARNING_6319 6319
#define __WARNING_IGNOREDBYCOMMA 6319
#define __WARNING_6320 6320
#define __WARNING_EXCEPTIONEXECUTEHANDLER 6320
#define __WARNING_6322 6322
#define __WARNING_EXCEPT_BLOCK_EMPTY 6322
#define __WARNING_6323 6323
#define __WARNING_ARITH_OP_ON_BOOL 6323
#define __WARNING_6324 6324
#define __WARNING_STRCPY_INSTEAD_OF_STRCMP 6324
#define __WARNING_6326 6326
#define __WARNING_CONST_CONST_COMP 6326
#define __WARNING_6327 6327
#define __WARNING_DEST_BUFFER_INSUFFICIENT 6327
#define __WARNING_6328 6328
#define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH 6328
#define __WARNING_6329 6329
#define __WARNING_POTENTIAL_INCORRECT_RETVAL_CHECK 6329
#define __WARNING_6331 6331
#define __WARNING_VIRTUALFREEINVALIDPARAM1 6331
#define __WARNING_6332 6332
#define __WARNING_VIRTUALFREEINVALIDPARAM2 6332
#define __WARNING_6333 6333
#define __WARNING_VIRTUALFREEINVALIDPARAM3 6333
#define __WARNING_6334 6334
#define __WARNING_SIZEOFEXPR 6334
#define __WARNING_6335 6335
#define __WARNING_LEAKING_PROCESS_HANDLE 6335
#define __WARNING_6336 6336
#define __WARNING_QUESTIONPRECEDENCE 6336
#define __WARNING_6381 6381
#define __WARNING_SHUTDOWN_API 6381
#define __WARNING_6383 6383
#define __WARNING_ELEMENTS_TO_BYTES 6383
#define __WARNING_6384 6384
#define __WARNING_DIVIDING_SIZEOF_POINTER 6384
#define __WARNING_6385 6385
#define __WARNING_READ_OVERRUN 6385
#define __WARNING_6386 6386
#define __WARNING_WRITE_OVERRUN 6386
#define __WARNING_6387 6387
#define __WARNING_INVALID_PARAM_VALUE_1 6387
#define __WARNING_6388 6388
#define __WARNING_INVALID_PARAM_VALUE_2 6388
#define __WARNING_6400 6400
#define __WARNING_LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON 6400
#define __WARNING_6401 6401
#define __WARNING_DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON 6401
#define __WARNING_6500 6500
#define __WARNING_INVALID_ATTRIBUTE_PROPERTY 6500
#define __WARNING_6501 6501
#define __WARNING_CONFLICTING_ATTRIBUTE_PROPERTY_VALUES 6501
#define __WARNING_6503 6503
#define __WARNING_REFERENCES_CANT_BE_NULL 6503
#define __WARNING_6504 6504
#define __WARNING_NULL_ON_NON_POINTER 6504
#define __WARNING_6505 6505
#define __WARNING_MUSTCHECK_ON_VOID 6505
#define __WARNING_6506 6506
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER_OR_ARRAY 6506
#define __WARNING_6507 6507
#define __WARNING_NULL_MISMATCH_AT_DEREF_0 6507
#define __WARNING_6508 6508
#define __WARNING_WRITE_ACCESS_ON_CONST 6508
#define __WARNING_6509 6509
#define __WARNING_RETURN_USED_ON_PRECONDITION 6509
#define __WARNING_6510 6510
#define __WARNING_NULLTERMINATED_ON_NON_POINTER 6510
#define __WARNING_6511 6511
#define __WARNING_MUSTCHECK_MAYBE 6511
#define __WARNING_6512 6512
#define __WARNING_NULL_CONFLICTS_WITH_NOT_VALID 6512
#define __WARNING_6513 6513
#define __WARNING_ELEMENT_SIZE_WITHOUT_BUFFER_SIZE 6513
#define __WARNING_6514 6514
#define __WARNING_BUFFER_SIZE_EXCEEDS_ARRAY_SIZE 6514
#define __WARNING_6515 6515
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER 6515
#define __WARNING_6516 6516
#define __WARNING_NO_PROPERTIES_ON_ATTRIBUTE 6516
#define __WARNING_6517 6517
#define __WARNING_VALID_SIZE_ON_NON_READABLE_BUFFER 6517
#define __WARNING_6518 6518
#define __WARNING_WRITABLE_SIZE_ON_NON_WRITABLE_BUFFER 6518
#define __WARNING_6521 6521
#define __WARNING_INVALID_SIZE_STRING_DEREF 6521
#define __WARNING_6522 6522
#define __WARNING_INVALID_SIZE_STRING_TYPE 6522
#define __WARNING_6523 6523
#define __WARNING_INVALID_SIZE_STRING_PARAM 6523
#define __WARNING_6525 6525
#define __WARNING_INVALID_SIZE_STRING_UNREACHABLE_LOCATION 6525
#define __WARNING_6526 6526
#define __WARNING_INVALID_SIZE_STRING_BUFFER_TYPE 6526
#define __WARNING_6530 6530
#define __WARNING_UNRECOGNIZED_FORMAT_STRING_STYLE 6530
#define __WARNING_6535 6535
#define __WARNING_BUFFERSIZE_INFEASIBLE 6535
#define __WARNING_6540 6540
#define __WARNING_OVERRIDING_OLD_MODEL 6540
#define __WARNING_6990 6990
#define __WARNING_MANAGEDCODENOTSUPPORTED 6990
#define __WARNING_6991 6991
#define __WARNING_ATTRIBUTESNOTSUPPORTED 6991
#define __WARNING_6992 6992
#define __WARNING_NATIVEEVENTSYNTAXNOTSUPPORTED 6992
#define __WARNING_6993 6993
#define __WARNING_OMPNOTSUPPORTED 6993
#define __WARNING_6994 6994
#define __WARNING_PCHNOTFOUND 6994
#define __WARNING_6995 6995
#define __WARNING_SAVETOXMLFAILED 6995

/* IntegerOverflow */

#define __WARNING_22010 22010
#define __WARNING_DUMMY_IO_WARNING1 22010
#define __WARNING_22011 22011
#define __WARNING_ALLOC_SIZE_OVERFLOW 22011
#define __WARNING_22012 22012
#define __WARNING_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22012
#define __WARNING_22013 22013
#define __WARNING_INDEX_WRONG_OVERFLOW_CHECK 22013
#define __WARNING_22014 22014
#define __WARNING_ALLOC_SIZE_NEGATIVE 22014
#define __WARNING_22015 22015
#define __WARNING_INDEX_NEGATIVE 22015
#define __WARNING_22016 22016
#define __WARNING_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22016
#define __WARNING_22017 22017
#define __WARNING_ALLOC_SIZE_UNDERFLOW 22017
#define __WARNING_22018 22018
#define __WARNING_INDEX_UNDERFLOW 22018
#define __WARNING_22019 22019
#define __WARNING_LOOP_INDEX_UNDERFLOW 22019
#define __WARNING_22020 22020
#define __WARNING_SIGNED_UNSIGNED_COMPARISON 22020
#define __WARNING_22021 22021
#define __WARNING_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22021
#define __WARNING_22022 22022
#define __WARNING_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22022
#define __WARNING_22023 22023
#define __WARNING_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22023
#define __WARNING_22024 22024
#define __WARNING_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22024
#define __WARNING_22025 22025
#define __WARNING_RETVAL_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22025
#define __WARNING_22026 22026
#define __WARNING_REFARG_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22026
#define __WARNING_22027 22027
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22027
#define __WARNING_22028 22028
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22028
#define __WARNING_22029 22029
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22029
#define __WARNING_22030 22030
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22030
#define __WARNING_22051 22051
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW 22051
#define __WARNING_22052 22052
#define __WARNING_UNTRUSTED_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22052
#define __WARNING_22053 22053
#define __WARNING_UNTRUSTED_INDEX_WRONG_OVERFLOW_CHECK 22053
#define __WARNING_22054 22054
#define __WARNING_UNTRUSTED_ALLOC_SIZE_NEGATIVE 22054
#define __WARNING_22055 22055
#define __WARNING_UNTRUSTED_INDEX_NEGATIVE 22055
#define __WARNING_22056 22056
#define __WARNING_UNTRUSTED_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22056
#define __WARNING_22057 22057
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW 22057
#define __WARNING_22058 22058
#define __WARNING_UNTRUSTED_INDEX_UNDERFLOW 22058
#define __WARNING_22059 22059
#define __WARNING_UNTRUSTED_LOOP_INDEX_UNDERFLOW 22059
#define __WARNING_22060 22060
#define __WARNING_UNTRUSTED_SIGNED_UNSIGNED_COMPARISON 22060
#define __WARNING_22061 22061
#define __WARNING_UNTRUSTED_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22061
#define __WARNING_22062 22062
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22062
#define __WARNING_22063 22063
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22063
#define __WARNING_22064 22064
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22064
#define __WARNING_22067 22067
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22067
#define __WARNING_22068 22068
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22068
#define __WARNING_22069 22069
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22069
#define __WARNING_22070 22070
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22070
#define __WARNING_22081 22081
#define __WARNING_UNTRUSTED_ALLOC_SIZE 22081
#define __WARNING_22082 22082
#define __WARNING_UNTRUSTED_INDEX 22082
#define __WARNING_22083 22083
#define __WARNING_UNTRUSTED_LOOP_INDEX 22083
#define __WARNING_22084 22084
#define __WARNING_UNTRUSTED_OVERFLOWN_EXPR 22084
#define __WARNING_22085 22085
#define __WARNING_UNTRUSTED_UNDERFLOWN_EXPR 22085

/* OACRCPLUS */

#define __WARNING_25000 25000
#define __WARNING_BIG_FORMAL_PARAM 25000
#define __WARNING_25001 25001
#define __WARNING_IMPLICIT_CTOR 25001
#define __WARNING_25002 25002
#define __WARNING_UPCAST_CTOR 25002
#define __WARNING_25003 25003
#define __WARNING_NONCONST_LOCAL 25003
#define __WARNING_25004 25004
#define __WARNING_NONCONST_PARAM 25004
#define __WARNING_25005 25005
#define __WARNING_NONCONST_FUNCTION 25005
#define __WARNING_25006 25006
#define __WARNING_UNUSED_PARAM 25006
#define __WARNING_25007 25007
#define __WARNING_STATIC_FUNCTION 25007
#define __WARNING_25008 25008
#define __WARNING_FREE_CONSTRUCTOR_CALL 25008
#define __WARNING_25009 25009
#define __WARNING_IDENTITY_ASSIGNMENT 25009
#define __WARNING_25010 25010
#define __WARNING_VIRTUAL_CALL_IN_CTOR 25010
#define __WARNING_25011 25011
#define __WARNING_CASE_FALLTHRU 25011
#define __WARNING_25012 25012
#define __WARNING_SMARTPOINTER_DELETE 25012
#define __WARNING_25013 25013
#define __WARNING_RETURN_FROM_GOTO_CONTEXT 25013
#define __WARNING_25014 25014
#define __WARNING_MISSING_OVERRIDE 25014
#define __WARNING_25015 25015
#define __WARNING_DOESNT_OVERRIDE 25015
#define __WARNING_25016 25016
#define __WARNING_OVERRIDE_CONST_MISMATCH 25016
#define __WARNING_25017 25017
#define __WARNING_OVERRIDING_NONVIRTUAL 25017
#define __WARNING_25018 25018
#define __WARNING_DIFFERENT_CALLING_CONVENTION 25018
#define __WARNING_25019 25019
#define __WARNING_VERYBIG_FORMAL_PARAM 25019
#define __WARNING_25020 25020
#define __WARNING_SAMENAME_DATAMEMBER 25020
#define __WARNING_25021 25021
#define __WARNING_POOR_DATAALIGNMENT 25021
#define __WARNING_25022 25022
#define __WARNING_REMOVERETURNCONST_FUNCTIONCAST 25022
#define __WARNING_25023 25023
#define __WARNING_BOGUS_BSTRCONST 25023
#define __WARNING_25024 25024
#define __WARNING_DANGEROUS_POINTERCAST 25024
#define __WARNING_25025 25025
#define __WARNING_UNSAFE_STRING_FUNCTION 25025
#define __WARNING_25026 25026
#define __WARNING_OBSOLETE_INI_ACCESSOR 25026
#define __WARNING_25027 25027
#define __WARNING_BANNED_FUNCTION 25027
#define __WARNING_25028 25028
#define __WARNING_FUNCTION_NEEDS_REVIEW 25028
#define __WARNING_25029 25029
#define __WARNING_OBSOLETE_ACL_FUNCTION 25029
#define __WARNING_25030 25030
#define __WARNING_BOGUS_EXPRESSION_LIST 25030
#define __WARNING_25031 25031
#define __WARNING_HRESULT_NOT_CHECKED 25031
#define __WARNING_25032 25032
#define __WARNING_NONCONST_LOCAL_BUFFERPTR 25032
#define __WARNING_25033 25033
#define __WARNING_NONCONST_BUFFER_PARAM 25033
#define __WARNING_25035 25035
#define __WARNING_SIZEOF_POINTER_IN_DIVISION 25035
#define __WARNING_25036 25036
#define __WARNING_STATIC_MASKING_VIRTUAL 25036
#define __WARNING_25037 25037
#define __WARNING_TRUE_CONSTANT_EXPR_IN_AND 25037
#define __WARNING_25038 25038
#define __WARNING_FALSE_CONSTANT_EXPR_IN_AND 25038
#define __WARNING_25039 25039
#define __WARNING_TRUE_CONSTANT_EXPR_IN_OR 25039
#define __WARNING_25040 25040
#define __WARNING_FALSE_CONSTANT_EXPR_IN_OR 25040
#define __WARNING_25041 25041
#define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE 25041
#define __WARNING_25042 25042
#define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE 25042
#define __WARNING_25043 25043
#define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR 25043
#define __WARNING_25044 25044
#define __WARNING_BSTR_PARAM_SHOULD_BE_CONST_WCHAR_PTR 25044
#define __WARNING_25045 25045
#define __WARNING_ISBADPTR_FUNCTION 25045
#define __WARNING_25046 25046
#define __WARNING_SPECIFY_SELECTANY 25046
#define __WARNING_25047 25047
#define __WARNING_INCORRECT_SELECTANY 25047
#define __WARNING_25048 25048
#define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST 25048
#define __WARNING_25049 25049
#define __WARNING_FREESTANDING_CONSTANT 25049
#define __WARNING_25050 25050
#define __WARNING_LOCAL_FUNCDECL 25050
#define __WARNING_25051 25051
#define __WARNING_DIFFERENT_RETURN_TYPE_SIZE 25051
#define __WARNING_25052 25052
#define __WARNING_DIFFERENT_RETURN_TYPE_KIND 25052
#define __WARNING_25053 25053
#define __WARNING_DIFFERENT_PARAM_COUNT 25053
#define __WARNING_25054 25054
#define __WARNING_DIFFERENT_PARAM_TYPE_SIZE 25054
#define __WARNING_25055 25055
#define __WARNING_DIFFERENT_PARAM_TYPE_KIND 25055
#define __WARNING_25056 25056
#define __WARNING_REMOVEPARAMCONST_FUNCTIONCAST 25056
#define __WARNING_25057 25057
#define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER 25057
#define __WARNING_25058 25058
#define __WARNING_CAST_CAN_BE_CONST 25058
#define __WARNING_25059 25059
#define __WARNING_SUPERFLUOUS_CAST 25059
#define __WARNING_25060 25060
#define __WARNING_SUPERFLUOUS_NOTNOT 25060
#define __WARNING_25061 25061
#define __WARNING_BACKWARD_JUMP 25061
#define __WARNING_25062 25062
#define __WARNING_BACKWARD_JUMP_IN_MACRO 25062
#define __WARNING_25063 25063
#define __WARNING_FILEMAPPING_WITH_GLOBAL_NAME 25063
#define __WARNING_25064 25064
#define __WARNING_FUNCTION_CALLED_TWICE_IN_MACRO 25064
#define __WARNING_25065 25065
#define __WARNING_UNSIGNED_SHORT_NEGATIVE_INT_COMPARISON 25065
#define __WARNING_25066 25066
#define __WARNING_OUTOFRANGE_SHORT_LONG_COMPARISON 25066
#define __WARNING_25067 25067
#define __WARNING_UNREACHABLE_CASE_LABEL 25067
#define __WARNING_25068 25068
#define __WARNING_USE_WIDE_API 25068
#define __WARNING_25069 25069
#define __WARNING_GOTO 25069
#define __WARNING_25070 25070
#define __WARNING_UNINITIALIZED_DATAMEMBER 25070
#define __WARNING_25071 25071
#define __WARNING_NO_MEMBERINIT 25071
#define __WARNING_25073 25073
#define __WARNING_WRONG_MEMBERINIT_ORDER 25073
#define __WARNING_25075 25075
#define __WARNING_NOHEAP_MEMBER 25075
#define __WARNING_25076 25076
#define __WARNING_NOHEAP_BASECLASS 25076
#define __WARNING_25077 25077
#define __WARNING_NEW_ON_NOHEAP 25077
#define __WARNING_25078 25078
#define __WARNING_CONDITIONAL_WITH_FALSE_TRUE 25078
#define __WARNING_25079 25079
#define __WARNING_CONDITIONAL_WITH_TRUE_FALSE 25079
#define __WARNING_25080 25080
#define __WARNING_CONDITIONAL_WITH_SAME_ALTERNATIVES 25080
#define __WARNING_25084 25084
#define __WARNING_DANGEROUS_ALL_ACCESS_ACL 25084
#define __WARNING_25085 25085
#define __WARNING_URL_NEEDS_TO_BE_REVIEWED 25085
#define __WARNING_25086 25086
#define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT 25086
#define __WARNING_25087 25087
#define __WARNING_UNSPECIFIED_ACCESSRIGHTS 25087
#define __WARNING_25089 25089
#define __WARNING_DEPRECATED_WIN16_FUNCTION 25089
#define __WARNING_25090 25090
#define __WARNING_USE_CPLUSPLUS_BOOL_CONST 25090
#define __WARNING_25091 25091
#define __WARNING_RETURNTYPE_CAN_BE_BOOL 25091
#define __WARNING_25092 25092
#define __WARNING_LOCAL_CAN_BE_BOOL 25092
#define __WARNING_25093 25093
#define __WARNING_FORMAL_CAN_BE_BOOL 25093
#define __WARNING_25094 25094
#define __WARNING_BASECLASS_SHOULDHAVE_PROTECTED_OR_VIRTUAL_DTOR 25094
#define __WARNING_25096 25096
#define __WARNING_ENUM_TYPEDEF 25096
#define __WARNING_25098 25098
#define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE 25098
#define __WARNING_25099 25099
#define __WARNING_USE_PREFIX_OPERATOR 25099
#define __WARNING_25100 25100
#define __WARNING_LHS_TEMP_OBJECT 25100
#define __WARNING_25101 25101
#define __WARNING_RHS_TEMP_OBJECT 25101
#define __WARNING_25102 25102
#define __WARNING_EXC_NOT_CAUGHT_BY_REFERENCE 25102
#define __WARNING_25103 25103
#define __WARNING_EXC_NOT_THROWN_BY_VALUE 25103
#define __WARNING_25104 25104
#define __WARNING_INCONSISTENT_DECLSPECS 25104
#define __WARNING_25105 25105
#define __WARNING_SEALED_BASE_CLASS 25105
#define __WARNING_25106 25106
#define __WARNING_SEALED_BASE_METHOD 25106
#define __WARNING_25107 25107
#define __WARNING_NOTRUNCCAST_PARAM 25107
#define __WARNING_25108 25108
#define __WARNING_UNBOUND_RETURN 25108
#define __WARNING_25109 25109
#define __WARNING_MISSING_BINDRETURN 25109
#define __WARNING_25110 25110
#define __WARNING_CLARYFY_PRECEDENCE_FOR_QUESTIONOPERATOR 25110
#define __WARNING_25112 25112
#define __WARNING_DEPRECATED_FUNCTION 25112
#define __WARNING_25113 25113
#define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED 25113
#define __WARNING_25114 25114
#define __WARNING_UNMARKED_INTL_DEPRECATED_FUNCTION 25114
#define __WARNING_25115 25115
#define __WARNING_DEPRECATED_INTL_FUNCTION_CALL 25115
#define __WARNING_25119 25119
#define __WARNING_OLEO_DEPRECATED_FUNCTION 25119
#define __WARNING_25120 25120
#define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER 25120
#define __WARNING_25124 25124
#define __WARNING_RETURNING_TEMP_OBJECT 25124
#define __WARNING_25125 25125
#define __WARNING_STRCPY_LOOP 25125
#define __WARNING_25126 25126
#define __WARNING_POSSIBLE_STRCPY_LOOP 25126
#define __WARNING_25127 25127
#define __WARNING_BOOLEAN_BITWISE_OPERATOR_MIX 25127
#define __WARNING_25128 25128
#define __WARNING_DIFFERENT_COMPARE_ON_64BIT 25128
#define __WARNING_25129 25129
#define __WARNING_POSSIBLE_64BIT_TRUNCATION 25129
#define __WARNING_25130 25130
#define __WARNING_NONCONST_CLSID 25130
#define __WARNING_25131 25131
#define __WARNING_EMPTY_DTOR 25131
#define __WARNING_25132 25132
#define __WARNING_BY_VALUE_FORMAL_WITH_DTOR 25132
#define __WARNING_25133 25133
#define __WARNING_BY_VALUE_TEMPLATEFORMAL_WITH_DTOR 25133
#define __WARNING_25134 25134
#define __WARNING_IMPLICIT_TEMPLATECTOR 25134
#define __WARNING_25135 25135
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_STATIC 25135
#define __WARNING_25136 25136
#define __WARNING_NONCONST_LOCAL_ARRAY 25136
#define __WARNING_25137 25137
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_PTR 25137
#define __WARNING_25138 25138
#define __WARNING_STATIC_ARRAY_SHOULD_BE_LOCAL_PTR 25138
#define __WARNING_25139 25139
#define __WARNING_EMPTY_NONPUBLIC_DTOR 25139
#define __WARNING_25140 25140
#define __WARNING_DANGEROUS_INTTOPTR_CAST 25140
#define __WARNING_25141 25141
#define __WARNING_PRINTF_FORMAT_STRING_PARAM_NEEDS_REVIEW 25141
#define __WARNING_25142 25142
#define __WARNING_OBSOLETE_OACR_REVIEWED_CALL_MACRO 25142
#define __WARNING_25143 25143
#define __WARNING_WRITABLE_GLOBAL_FUNCTION_POINTER 25143
#define __WARNING_25144 25144
#define __WARNING_MISALIGNED_DATAMEMBER 25144
#define __WARNING_25145 25145
#define __WARNING_UNSAFE_EXPRESSION_AS_SAFEINT_ARGUMENT 25145
#define __WARNING_25146 25146
#define __WARNING_MISSING_DATAMEMBER_SWAP 25146
#define __WARNING_25147 25147
#define __WARNING_SIZEOF_WITHOUT_PARENS 25147
#define __WARNING_25148 25148
#define __WARNING_OACRCPLUS_REQUIRES_OACRMODEL 25148
#define __WARNING_25149 25149
#define __WARNING_ARRAY_COMPAREDWITH_NULL 25149

/* OACRExc */

#define __WARNING_25301 25301
#define __WARNING_DTOR_SHOULD_BE_NOTHROW 25301
#define __WARNING_25302 25302
#define __WARNING_OPERATOR_DELETE_SHOULD_BE_NOTHROW 25302
#define __WARNING_25303 25303
#define __WARNING_SWAP_FUNC_SHOULD_BE_NOTHROW 25303
#define __WARNING_25304 25304
#define __WARNING_CALLBACK_FUNC_SHOULD_BE_NOTHROW 25304
#define __WARNING_25305 25305
#define __WARNING_CLEANUP_FUNC_SHOULD_BE_NOTHROW 25305
#define __WARNING_25306 25306
#define __WARNING_NOTHROW_FUNC_THROWS 25306
#define __WARNING_25307 25307
#define __WARNING_FUNC_COULD_BE_NOTHROW 25307
#define __WARNING_25308 25308
#define __WARNING_UNNECESSARY_TRY_CATCH 25308
#define __WARNING_25309 25309
#define __WARNING_NOTHROW_BLOCK_THROWS 25309
#define __WARNING_25310 25310
#define __WARNING_COM_METHOD_THROWS 25310
#define __WARNING_25311 25311
#define __WARNING_GENERATED_FUNC_THROWS 25311
#define __WARNING_25312 25312
#define __WARNING_NO_EHSC_SWITCH 25312
#define __WARNING_25313 25313
#define __WARNING_OACREXC_REQUIRES_OACRMODEL 25313

/* OACRMODEL */

#define __WARNING_25351 25351
#define __WARNING_HUNGARIAN_INFERRED 25351
#define __WARNING_25352 25352
#define __WARNING_MISSING_ANNOTATION 25352
#define __WARNING_25353 25353
#define __WARNING_OVERRIDE_AT_NON_VIRTUAL 25353
#define __WARNING_25354 25354
#define __WARNING_OVERRIDE_AT_STATIC 25354
#define __WARNING_25355 25355
#define __WARNING_OVERRIDE_AT_BASECLASS 25355
#define __WARNING_25356 25356
#define __WARNING_UNSUPPORTED_DEREF_VALUE 25356
#define __WARNING_25357 25357
#define __WARNING_PRE_ANNOTATION_AT_RETURNVALUE 25357
#define __WARNING_25358 25358
#define __WARNING_MISSING_NOTHROW_AT_DECL 25358
#define __WARNING_25359 25359
#define __WARNING_DEPRECATED_OVERRIDE 25359
#define __WARNING_25360 25360
#define __WARNING_OBSOLETE_OVERRIDE 25360
#define __WARNING_25361 25361
#define __WARNING_ILLEGAL_BOUND_AT_PARAM 25361
#define __WARNING_25362 25362
#define __WARNING_ILLEGAL_BOUND_AT_RETURN 25362
#define __WARNING_25363 25363
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_PARAM 25363
#define __WARNING_25364 25364
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_RETURN 25364
#define __WARNING_25365 25365
#define __WARNING_ILLEGAL_RANGE_AT_PARAM 25365
#define __WARNING_25366 25366
#define __WARNING_ILLEGAL_RANGE_AT_RETURN 25366
#define __WARNING_25367 25367
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_PARAM 25367
#define __WARNING_25368 25368
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_RETURN 25368
#define __WARNING_25369 25369
#define __WARNING_PARAM_UPPERBOUND_LT_LOWERBOUND 25369
#define __WARNING_25370 25370
#define __WARNING_RETURN_UPPERBOUND_LT_LOWERBOUND 25370
#define __WARNING_25371 25371
#define __WARNING_NO_ANNOTATIONS_AT_DECLARATION 25371
#define __WARNING_25372 25372
#define __WARNING_DECLSPEC_SAL_ANNOTATION 25372

/* espX */

#define __WARNING_26000 26000
#define __WARNING_BUFFER_OVERFLOW 26000
#define __WARNING_26001 26001
#define __WARNING_BUFFER_UNDERFLOW 26001
#define __WARNING_26002 26002
#define __WARNING_READ_UNTRACKED_BUFFER 26002
#define __WARNING_26003 26003
#define __WARNING_UNTRACKED_BUFFER 26003
#define __WARNING_26004 26004
#define __WARNING_UNINITIALIZED_POINTER 26004
#define __WARNING_26005 26005
#define __WARNING_ZEROLENGTHARRAY 26005
#define __WARNING_26006 26006
#define __WARNING_INCORRECT_ANNOTATION_STRING 26006
#define __WARNING_26007 26007
#define __WARNING_INCORRECT_ANNOTATION 26007
#define __WARNING_26009 26009
#define __WARNING_BUFFERACCESS 26009
#define __WARNING_26010 26010
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW 26010
#define __WARNING_26011 26011
#define __WARNING_POTENTIAL_BUFFER_UNDERFLOW 26011
#define __WARNING_26012 26012
#define __WARNING_UNTRACKED_BUFFER_BUT_UNANNOTATABLE 26012
#define __WARNING_26013 26013
#define __WARNING_COMPLEX_EXPR 26013
#define __WARNING_26014 26014
#define __WARNING_INCORRECT_VALIDATION 26014
#define __WARNING_26015 26015
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY 26015
#define __WARNING_26016 26016
#define __WARNING_BUFFER_OVERFLOW_NULL_TERMINATED 26016
#define __WARNING_26017 26017
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_MISC 26017
#define __WARNING_26018 26018
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED 26018
#define __WARNING_26019 26019
#define __WARNING_INCORRECT_VALIDATION2 26019

/* SALCheck */

#define __WARNING_26020 26020
#define __WARNING_INSANE_ANNOTATION 26020
#define __WARNING_26021 26021
#define __WARNING_ANNOTATION_MISMATCH_MISSING_FIRST 26021
#define __WARNING_26022 26022
#define __WARNING_ANNOTATION_MISMATCH_MISSING_SECOND 26022
#define __WARNING_26023 26023
#define __WARNING_ANNOTATION_MISMATCH 26023

/* espX */

#define __WARNING_26030 26030
#define __WARNING_POSTCONDITION_BUFFER_OVERFLOW 26030
#define __WARNING_26031 26031
#define __WARNING_POSTCONDITION_BUFFER_UNDERFLOW 26031
#define __WARNING_26035 26035
#define __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION 26035
#define __WARNING_26036 26036
#define __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION 26036
#define __WARNING_26037 26037
#define __WARNING_POTENTIAL_NULLTERMINATION_VIOLATION 26037
#define __WARNING_26040 26040
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW 26040
#define __WARNING_26041 26041
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_UNDERFLOW 26041
#define __WARNING_26044 26044
#define __WARNING_INCORRECT_VALIDATION_POSTCONDITION 26044
#define __WARNING_26045 26045
#define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION 26045
#define __WARNING_26050 26050
#define __WARNING_CHECKER_ASSERTION_FAILURE 26050
#define __WARNING_26051 26051
#define __WARNING_IRREDUCIBLE_CFG 26051
#define __WARNING_26052 26052
#define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL 26052
#define __WARNING_26053 26053
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_LOOP_DEPENDENT 26053
#define __WARNING_26060 26060
#define __WARNING_RANGE_PRECONDITION_VIOLATION 26060
#define __WARNING_26061 26061
#define __WARNING_RANGE_POSTCONDITION_VIOLATION 26061
#define __WARNING_26070 26070
#define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION 26070
#define __WARNING_26071 26071
#define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION 26071
#define __WARNING_26080 26080
#define __WARNING_VALIDATED_ACCESS 26080
#define __WARNING_26081 26081
#define __WARNING_USING_STRUCT_ANNOTATION 26081
#define __WARNING_26090 26090
#define __WARNING_SUSPICIOUS_FUNCTION_POINTER_CAST 26090

/* NullPtr */

#define __WARNING_26500 26500
#define __WARNING_NULL_DEREFERENCE 26500
#define __WARNING_26501 26501
#define __WARNING_NULL_DEREFERENCE_THIS 26501
#define __WARNING_26505 26505
#define __WARNING_NULL_DEREFERENCE_API 26505
#define __WARNING_26506 26506
#define __WARNING_NULL_DEREFERENCE_THIS_API 26506
#define __WARNING_26510 26510
#define __WARNING_INTERFACE_PRE_NULL 26510
#define __WARNING_26511 26511
#define __WARNING_INTERFACE_PRE_NOTNULL 26511
#define __WARNING_26512 26512
#define __WARNING_INTERFACE_PRE_NOTNULL_VAL 26512
#define __WARNING_26515 26515
#define __WARNING_INTERFACE_POST_NULL 26515
#define __WARNING_26516 26516
#define __WARNING_INTERFACE_POST_NULL_CTOR 26516
#define __WARNING_26517 26517
#define __WARNING_INTERFACE_POST_NOTNULL 26517
#define __WARNING_26518 26518
#define __WARNING_INTERFACE_POST_NOTNULL_CTOR 26518
#define __WARNING_26520 26520
#define __WARNING_TRUNCATED_PTR 26520

/* in */

#define __WARNING_26550 26550
#define __WARNING_ASSIGNMENT_TO_IN_PARAMETER 26550

/* EspOpal */

#define __WARNING_26599 26599
#define __WARNING_GENERIC_OPAL_DEFECT 26599

/* sqleye.native.escapinganddelimiting */

#define __WARNING_26600 26600
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND 26600
#define __WARNING_26601 26601
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND 26601
#define __WARNING_26602 26602
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND 26602
#define __WARNING_26604 26604
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_PRECONDITION 26604
#define __WARNING_26610 26610
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING 26610
#define __WARNING_26611 26611
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING 26611
#define __WARNING_26612 26612
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING 26612

/* sqleye.native.missingcommandsal */

#define __WARNING_26620 26620
#define __WARNING_SQLINJECTION_CXX_MISSING_COMMAND_SAL 26620

/* sqleye.native.missingconnectionstringsal */

#define __WARNING_26625 26625
#define __WARNING_SQLINJECTION_CXX_MISSING_CONNECTION_STRING_SAL 26625

/* sqleye.native.truncation */

#define __WARNING_26630 26630
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_COMMAND 26630
#define __WARNING_26635 26635
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_CONNECTION_STRING 26635

/* sqleye.native.escapinganddelimiting */

#define __WARNING_26660 26660
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_LOWER_CONFIDENCE 26660
#define __WARNING_26661 26661
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND_LOWER_CONFIDENCE 26661
#define __WARNING_26662 26662
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND_LOWER_CONFIDENCE 26662
#define __WARNING_26670 26670
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING_LOWER_CONFIDENCE 26670
#define __WARNING_26671 26671
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26671
#define __WARNING_26672 26672
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26672

/* Goldpft */

#define __WARNING_38001 38001
#define __WARNING_LOCALE_SENSITIVE_STRCMP 38001
#define __WARNING_38002 38002
#define __WARNING_LOCALE_SENSITIVE_COMPARESTRING 38002
#define __WARNING_38003 38003
#define __WARNING_SYSTEM_LOCALE_MISUSE 38003
#define __WARNING_38004 38004
#define __WARNING_DEPRECATED_LIBRARY 38004
#define __WARNING_38010 38010
#define __WARNING_CALLING_SETTHREADLOCALE 38010
#define __WARNING_38011 38011
#define __WARNING_OVERRIDING_LOCALE_SETTINGS_WITH_SETLOCALEINFO 38011
#define __WARNING_38020 38020
#define __WARNING_ANSI_APICALL 38020
#define __WARNING_38021 38021
#define __WARNING_W2A_BEST_FIT 38021
#define __WARNING_38022 38022
#define __WARNING_CLIPBOARD_ANSI 38022
#define __WARNING_38023 38023
#define __WARNING_ANSI_DATAFILE 38023
#define __WARNING_38030 38030
#define __WARNING_HARD_CODED_STRING_TO_UI_FN 38030
#define __WARNING_38031 38031
#define __WARNING_HARDCODED_FONT_INFO 38031
#define __WARNING_38032 38032
#define __WARNING_CONSOLE_OUTPUT_ISSUE 38032
#define __WARNING_38033 38033
#define __WARNING_FORMAT_MESSAGE_LANG 38033
#define __WARNING_38034 38034
#define __WARNING_CONCATENATED_RESOURCE_STRING 38034
#define __WARNING_38035 38035
#define __WARNING_LOCALIZABLE_STRING_FORMAT_ISSUE 38035
#define __WARNING_38036 38036
#define __WARNING_MESSAGEBOX_RTL 38036
#define __WARNING_38037 38037
#define __WARNING_BITMAP_OR_ANSI_FONT 38037
#define __WARNING_38038 38038
#define __WARNING_COMMANDLINK_SETNOTE 38038
#define __WARNING_38039 38039
#define __WARNING_SCREEN_COORDINATES_CONVERSION 38039
#define __WARNING_38041 38041
#define __WARNING_GETDATEFORMAT_WRAPPER 38041
#define __WARNING_38042 38042
#define __WARNING_GETDATEFORMAT_AUTOLAYOUT 38042
#define __WARNING_38043 38043
#define __WARNING_LAYOUT_BITMAPORIENTATIONPRESERVED 38043
#define __WARNING_38044 38044
#define __WARNING_LOC_METADATA_GENERATED_GOLDPFT 38044
#define __WARNING_38045 38045
#define __WARNING_NON_LOCFRIENDLY_STRING_FORMATTING 38045

/* sqleye.tsql.escapinganddelimiting */

#define __WARNING_80100 80100
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND 80100
#define __WARNING_80101 80101
#define __WARNING_SQLINJECTION_TSQL_DELIMITING_COMMAND 80101
#define __WARNING_80102 80102
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_AND_DELIMITING_COMMAND 80102
#define __WARNING_80103 80103
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER 80103
#define __WARNING_80104 80104
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_PRECONDITION 80104
#define __WARNING_80105 80105
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER_PRECONDITION 80105

/* sqleye.tsql */

#define __WARNING_80130 80130
#define __WARNING_SQLINJECTION_TSQL_TRUNCATION_COMMAND 80130
#define __WARNING_80131 80131
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_COMMAND_EXECUTION 80131
#define __WARNING_80140 80140
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_PASSED_TO_SP 80140
#define __WARNING_80141 80141
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_CALL_TO_SP 80141
#define __WARNING_80142 80142
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_ASSIGNED_TO_OUTPUT 80142
#define __WARNING_80143 80143
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_OUTPUT_ASSIGNMENT 80143

/* sqleye.managed.escapinganddelimiting */

#define __WARNING_80200 80200
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_COMMAND 80200
#define __WARNING_80201 80201
#define __WARNING_SQLINJECTION_MSIL_DELIMITING_COMMAND 80201
#define __WARNING_80202 80202
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_AND_DELIMITING_COMMAND 80202

#endif // OACR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\x86\etc\esp\SqlEye.Native.Annotations.h ===
#if !defined(__midl) && defined(_PREFAST_)

// Data Sink (a parameter scontaining a sql command or connection string to be executed by the API)
//
#define __sql_command  __declspec("SAL_SqlCommand")

#define __sql_connection_string __declspec("SAL_SqlConnectionString")

#define __sql_command_fragment  __declspec("SAL_SqlCommand")

#define __sql_connection_string_fragment __declspec("SAL_SqlConnectionString")

// Data Source (parameter or return value that may contain untrusted data upon return of the API)
//
// Example 1: __sql_untrusted CHAR* GetRegistryValue(CHAR* key)
// Example 2: void GetRegistryValue(CHAR* key, __sqluntrusted __out_ecount_z(cchValue) CHAR* value, size_t cchValue)
//
#define __sql_untrusted  __declspec("SAL_SqlUnTrusted")

// Escaped annotations

// Escaped '
//
#define __sql_escaped_single_quote __declspec("SAL_SqlEscaped")

// Escaped "
//
#define __sql_escaped_double_quote __declspec("SAL_SqlEscaped")

// Escaped ]
//
#define __sql_escaped_right_bracket __declspec("SAL_SqlEscaped")

// Currently escaped-and-delimited annotations expand to the same as __sql_command,
// since the requirement we currently check is that all inputs to such variable
// be escaped and delimited.
//

// Escaped and delimited '
//
#define __sql_escaped_and_delimited_single_quote __declspec("SAL_SqlCommand")

// Escaped and delimited "
//
#define __sql_escaped_and_delimited_double_quote __declspec("SAL_SqlCommand")

// Escaped and delimited ]
//
#define __sql_escaped_and_delimited_right_bracket __declspec("SAL_SqlCommand")

// Trusted: A parameter for which we know safe values are passed at all call sites. 
// One should always avoid using this one, as this annotation results in no checking at the call site.
// Instead use __sql_command, __sql_escaped_* or __sql_escaped_and_delimited_* annotations,
// This is only provided in case of an unmanageable amount of noise occuring due to a large number
// of known-safe callsites.
//
#define __sql_trusted  __declspec("SAL_SqlTrusted")

#else

#define __sql_command 
#define __sql_connection_string  
#define __sql_command_fragment
#define __sql_connection_string_fragment  

#define __sql_untrusted

#define __sql_escaped_single_quote
#define __sql_escaped_double_quote
#define __sql_escaped_right_bracket

#define __sql_escaped_and_delimited_single_quote
#define __sql_escaped_and_delimited_double_quote
#define __sql_escaped_and_delimited_right_bracket

#define __sql_trusted

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\x86\inc\oacrdll.h ===
#pragma once
/*****************************************************************************

   Module  : OACRDll
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  APIs exported by oacr.dll.
  
  oacr.dll is part of the Microsoft Auto Code Review (OACR) system. 
  It provides the same functionality as oacr.exe. It is intended for build
  integration from build environments using their own executable.

*****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

// Typedefs for dynamic loading via LoadLibrary and GetProcAddress
typedef int (__stdcall* OACRCMDWPROC)( const wchar_t* );
typedef int (__stdcall* OACRCMDAPROC)( const char* );


// Run an OACR command. Same command line syntax as the oacr.exe command line tool.
int __stdcall OACRCmdW( const wchar_t* wzCmd );
int __stdcall OACRCmdA( const char* szCmd );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\x86\inc\oacr.h ===
#pragma once
/*****************************************************************************

   Module  : OACR
   Owner   : HannesR

******************************************************************************

   Definitions and #defines for OACR support

*****************************************************************************/

// SAL annotations are #defined in this file
#include <sal.h>
#include <specstrings.h>
//#include "oacrsal.h"
#include "pftwarnings.h"

// TODO: remove the _PREFAST2_ and _PREFAST8_ defines
#if( defined(_PREFAST_)&& _PREFAST_ )
#if( _MSC_VER < 1400 )
#define _PREFAST2_ 1
#else
#define _PREFAST8_ 1
#endif
#endif

// Support attribute annotations for regular foreground build to catch misplaced annotations
#undef OACR_FOREGROUND_ATTRIBUTES
#if !_USE_ATTRIBUTES_FOR_SAL && !_USE_DECLSPECS_FOR_SAL && defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) && _MSC_VER >= 1400 
#define OACR_FOREGROUND_ATTRIBUTES 1
#else
#define OACR_FOREGROUND_ATTRIBUTES 0
#endif

// Allow deprecated Pre Orcas style annotations by default
#if !defined(OACR_DEPRECATED)
#define OACR_DEPRECATED 1
#endif

#if !defined(ARM)
#define __oacr_noop __noop
#else
#define __oacr_noop
#endif

#if defined(__cplusplus)
#define __extern_c     extern "C"
#define __extern_cplus extern "C++"
#else
#define __extern_c
#define __extern_cplus
#endif

#define __noreturn __declspec( noreturn )

// size_t is used in some OACR macros
#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if !defined(_SIZE_T_DEFINED)
#if defined(_WIN64)
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

// OACR keywords:
// annotations undertstood by PREfast plugins

#if !defined(_Sealed_method_)
// use _Sealed_method_ to specify C# style 'sealed' behavior for methods
#define _Sealed_method_ __oacr_sealed_method
#endif // _Sealed_method_


#if !defined(_Sealed_class_)
// use _Sealed_class_ to specify C# style 'sealed' behavior for classes
#define _Sealed_class_ __oacr_sealed_class
#endif // _Sealed_class_


#if !defined(_SA_deprecated_)
// use _SA_deprecated_ to mark functions that should not be called any more
// pass the replacement function as argument to the macro
#define _SA_deprecated_(NewFunctionName) __oacr_sa_deprecated(NewFunctionName)
#endif // _SA_deprecated_


#if !defined(_Intl_deprecated_)
// annotation used by warning UNMARKED_INTL_DEPRECATED_FUNCTION (25114)
// to mark deprecated functions using LCID parameters
// The annotation is used by Office to cleanup the use of LCIDs
#define _Intl_deprecated_ __oacr_intl_deprecated
#endif // _Intl_deprecated_


#if !defined(_Oleo_deprecated_)
// Office specifix annotation used by the OLEO effort
#define _Oleo_deprecated_( NewFunctionName ) __oacr_oleo_deprecated(NewFunctionName)
#endif // _Oleo_deprecated_


#if !defined(_Rpc_)
// use _Rpc_ for functions that used as remote procedure calls, the keyword will silence
// various OACR checks on formal parameters of the marked functions
#define _Rpc_ __oacr_rpc
#endif // _Rpc_


#if !defined(_RequireNoThrow_)
// use _RequireNoThrow_ inside a compound statement to indicate that the rest of the block
// should not emit exceptions.
#define _RequireNoThrow_ __oacr_requireNoThrow
#endif // _RequireNoThrow_


#if !defined(_Canthrow_)
// use _Canthrow_ for method declarations of template classes that have throwing and non-throwing
// specializations to suppress warning FUNC_COULD_BE_NOTHROW (25307).
#define _Canthrow_ __oacr_canthrow
#endif // __requireNoThrow


#if !defined(_Genericfunctype_)
// use _Genericfunctype_ for function typedefs used for arrays of functions of different function types.
// if the typedef is marked as _Genericfunctype_, OACR will not generate DIFFERENT_CALLING_CONVENTION (25018) warnings
// e.g. typedef _Genericfunctype_ void (*FUNCPTR)();
#if( defined(OACR) && OACR )
#define _Genericfunctype_ __oacr_genericfunctype
#else
#define _Genericfunctype_
#endif
#endif // _Genericfunctype_


#if !defined(_Nothrowfunctype_)
// use _Nothrowfunctype_ for function typedefs of non exception throwing function pointers
// e.g. typedef _Nothrowfunctype_ void (*FUNCPTR)();
// only assign non throwing functions to typedefs so marked
#define _Nothrowfunctype_ __oacr_nothrowfunctype
#endif // _Nothrowfunctype_


#if !defined(_BindReturn_)
// stronger than __checkReturn, typically used by functions that return
// a pointer to an allocated object
// e.g _BindReturn_ void* malloc( size_t size );
// void Bar()
// {
//    void* pv;
//    if( ( pv == malloc( 20 ) ) == NULL )      <<<< typo !!
//    ...
// }
#define _BindReturn_ __oacr_bindReturn
#endif // _BindReturn_


#if !defined(_Memberinitializer_)
// use _Memberinitializer_ for init functions that initialize all members of a class
// e.g.:
// class X
// {
//    int m_i:
//    int m_j:
//    _Memberinitializer_ void Init(){ m_i = m_j = 0; }
// public:
//    X(){ Init(); }
// };
#define _Memberinitializer_ __oacr_memberinitializer
#endif // _Memberinitializer_


#if !defined(_Noheap_)
// use _Noheap_ classes that should not be instantiated on the heap
// e.g.:
// _Noheap_ class CriticalSection
// {
// public:
//    CriticalSection();
//    ~CriticalSection();
// };
#define _Noheap_ __oacr_noheap
#endif // _Noheap_


#if !defined(_Unsafe_string_api_)
// use _Unsafe_string_api_ to phase out functions that pass unbound writable buffers
// e.g.
// _Unsafe_string_api_ void MyStrCpy( char* szTo, const char* szFrom );
#define _Unsafe_string_api_ __oacr_unsafe_string_api
#endif // _Unsafe_string_api_


#if !defined(_Needsreview_)
// use _Needsreview_ to mark functions whose calls need to be reviewed for a
// special reason.
// e.g. a wrapper function to another function that needs to be reviewed
//_Needsreview_ __inline BOOL MsoGetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
//{
//   return OACR_REVIEWED_CALL("hannesr", GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType));
//}
// use the OACR_REVIEWED_CALL macro to silent the warning after making sure that the function is used properly
#define _Needsreview_ __oacr_needsreview
#endif // _Needsreview_


#if !defined(_Notrunccast_)
// use _Notrunccast_ to find unsafe truncating cast on allocating functions taking
// a 16 bit size parameter
// e.g.
// void* MyMalloc( _Notrunccast_ ushort size );
#define _Notrunccast_ __oacr_notrunccast
#endif // _Notrunccast_


#if !defined(_Noinference_)
// keyword to disable (wrong) Hungarian inference of __count annotations
// inference is disabled for the all formals of the function
// e.g. _Noinference_ void FreePv( void* pv, size_t cb );
#define _Noinference_     __oacr_noinference
#endif // _Noinference_


// Pre Orcas style annotations are deprecated
#if( OACR_DEPRECATED )

#if !defined(__sealed_method)
#define __sealed_method                      _Sealed_method_
#endif
#if !defined(__sealed_class)
#define __sealed_class                       _Sealed_class_
#endif
#if !defined(__sa_deprecated)
#define __sa_deprecated(NewFunctionName)     _SA_deprecated_(NewFunctionName)
#endif
#if !defined(__intl_deprecated)
#define __intl_deprecated                    _Intl_deprecated_
#endif
#if !defined(__oleo_deprecated)
#define __oleo_deprecated( NewFunctionName ) _Oleo_deprecated_(NewFunctionName)
#endif
#if !defined(__rpc)
#define __rpc                                _Rpc_
#endif
#if !defined(__requireNoThrow)
#define __requireNoThrow                     _RequireNoThrow_
#endif
#if !defined(__canthrow)
#define __canthrow                           _Canthrow_
#endif
#if !defined(__genericfunctype)
#define __genericfunctype                    _Genericfunctype_
#endif
#if !defined(__nothrowfunctype)
#define __nothrowfunctype                    _Nothrowfunctype_
#endif
#if !defined(__bindReturn)
#define __bindReturn                         _BindReturn_
#endif
#if !defined(__memberinitializer)
#define __memberinitializer                  _Memberinitializer_
#endif
#if !defined(__noheap)
#define __noheap                             _Noheap_
#endif
#if !defined(__nostack)
#define __nostack                            // not supported
#endif
#if !defined(__unsafe_string_api)
#define __unsafe_string_api                  _Unsafe_string_api_
#endif
#if !defined(__needsreview)
#define __needsreview                        _Needsreview_
#endif
#if !defined(__notrunccast)
#define __notrunccast                        _Notrunccast_
#endif
#if !defined(__noinference)
#define __noinference                        _Noinference_
#endif
#if !defined(__min_function)
#define __min_function                       // deprecated, use range annotations
#endif
#if !defined(__max_function)
#define __max_function                       // deprecated, use range annotations
#endif
#if !defined(__printf_format_string)
#define __printf_format_string               _Printf_format_string_
#endif

#undef __callback
#define __callback                           _Callback_

#if !defined(__sa_sealed) // use __sealed_method and __sealed_class instead
#if( defined(OACR) && OACR )
#define __sa_sealed __declspec("_Sealed_")
#else
#define __sa_sealed
#endif
#endif // __sa_sealed

#endif // OACR_DEPRECATED

//-----------------

// OACR helper macros to suppress particular warnings

#if !defined(OACR_USE_PTR)
// use to suppress constness and related warnings:
// NONCONST_LOCAL (25003), NONCONST_PARAM( 25004), NONCONST_FUNCTION (25005), 
// NONCONST_LOCAL_BUFFERPTR (25032), NONCONST_BUFFER_PARAM (25033)
#if( defined(OACR) && OACR )
__extern_c void OACRUsePtr( void* p );
#define OACR_USE_PTR( p ) OACRUsePtr( p )
#else
#define OACR_USE_PTR( p ) __oacr_noop
#endif
#endif // OACR_USE_PTR

#if !defined(OACR_MEMBER_IS_INITIALIZED_IN_CTOR)
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a _Memberinitializer_)
// for data members which are correctly initialized in the ctor.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER.
#define OACR_MEMBER_IS_INITIALIZED_IN_CTOR( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_CTOR

#if !defined(OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER)
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a ctor)
// for data members which are correctly initialized in the _Memberinitializer_ method.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally equivalent to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_CTOR.
#define OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER

#if !defined(OACR_POSSIBLE_THROW)
// use to suppress __nothrow related warnings NOTHROW_FUNC_THROWS (25306) and FUNC_COULD_BE_NOTHROW (25307)
#if( defined(OACR) && OACR )
__extern_cplus void OACRPossibleThrow();
#define OACR_POSSIBLE_THROW OACRPossibleThrow()
#else
#define OACR_POSSIBLE_THROW __oacr_noop
#endif
#endif // OACR_POSSIBLE_THROW

#if !defined(OACR_ASSUME_NOTHROW_BEGIN)
// use with OACR_ASSUME_NOTHROW_END to suppress NOTHROW_FUNC_THROWS warnings around functions that don't throw in this context
// macro pair needs to be on the same scope
#if( defined(OACR) && OACR )
#define OACR_ASSUME_NOTHROW_BEGIN try{
#define OACR_ASSUME_NOTHROW_END }catch(...){}
#else
#define OACR_ASSUME_NOTHROW_BEGIN
#define OACR_ASSUME_NOTHROW_END
#endif
#endif // OACR_POSSIBLE_THROW

#if !defined(UNREFERENCED_OACR)
// use to function staticness and related warnings: STATIC_FUNCTION (25007)
#if( defined(OACR) && OACR )
#define UNREFERENCED_OACR( p ) __assume( p == p )
#else
#define UNREFERENCED_OACR( p )
#endif
#endif // UNREFERENCED_OACR


#if !defined(OACR_OWN_PTR)
// can be used for objects that attach themselves to an owner
// in their constructors
#if( defined(OACR) && OACR )
__extern_c void OACROwnPtr( const void* p );
#define OACR_OWN_PTR( p ) OACROwnPtr( p )
#else
#define OACR_OWN_PTR( p ) __oacr_noop
#endif
#endif // OACR_OWN_PTR


#if !defined(OACR_PTR_NOT_NULL)
// tells OACR that a pointer is not null at this point
#if( defined(OACR) && OACR )
#define OACR_PTR_NOT_NULL( p ) OACR_ASSUME( 0 != p )
#else
#define OACR_PTR_NOT_NULL( p ) __oacr_noop
#endif
#endif // OACR_PTR_NOT_NULL


#if !defined(OACR_NOT_IMPLEMENTED_MEMBER)
#if( defined(OACR) && OACR )
#define OACR_NOT_IMPLEMENTED_MEMBER OACR_USE_PTR( (void*)this )
#else
#define OACR_NOT_IMPLEMENTED_MEMBER
#endif
#endif // OACR_NOT_IMPLEMENTED_MEMBER


#if !defined(OACR_DECLARE_FILLER)
#if( defined(OACR) && OACR )
#define OACR_DECLARE_FILLER( type, inst ) type __filler##inst;
#else
#define OACR_DECLARE_FILLER( type, inst )
#endif
#endif // OACR_DECLARE_FILLER


// use this macro once you have inspected warnings FUNCTION_NEEDS_REVIEW (25028)
#if !defined(OACR_REVIEWED_CALL)
#if( defined(OACR) && OACR )
__extern_c void __OACRReviewedCall();
#define OACR_REVIEWED_CALL( reviewer, functionCall ) ( __OACRReviewedCall(), functionCall )
#else
#define OACR_REVIEWED_CALL( reviewer, functionCall ) functionCall
#endif
#endif // OACR_REVIEWED_CALL


// use this macro once you have inspected warnings URL_NEEDS_TO_BE_REVIEWED (25085)
#if !defined(OACR_REVIEWED_URL)
#if( defined(OACR) && OACR )
__extern_c void __OACRReviewedUrl();
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) ( __OACRReviewedUrl(), reviewedUrl )
#else
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) reviewedUrl
#endif
#endif // OACR_REVIEWED_URL

#if !defined(OACR_DONT_SWAP)
// use to suppress warnings MISSING_MEMBER_SWAP (25146) for nonswappable data members like refcounts, critical sections, etc.
#if( defined(OACR) && OACR )
__extern_c void OACRDontSwap( void* p );
#define OACR_DONT_SWAP( m ) OACRDontSwap( &( m ) )
#else
#define OACR_DONT_SWAP( m ) __oacr_noop
#endif
#endif // OACR_DONT_SWAP

#if( defined(OACR) && OACR && defined(_WINDEF_) && 0 )

// redefine FALSE & TRUE for better HRESULT<->BOOL conversion detection
#if defined(FALSE)
#undef FALSE
#define FALSE ((BOOL)0)
#endif

#if defined(TRUE)
#undef TRUE
#define TRUE ((BOOL)1)
#endif

#endif

// Use the following macros to suppress and disable OACR warnings in the code
// Using the macros allows us to have the same source code being compiled with
// PREfast 2.x and Whidbey PREfast

// macro to tell OACR to not issue a specific warning for the following line of code
// use to suppress false positives from OACR
// e.g.
// if( fPointerNotNull )
//    OACR_WARNING_SUPRESS( DEREF_NULL_PTR, "pointer access is guarded by 'fPointerNotNull'" )
//    p->Foo();

#if !defined(OACR_WARNING_PUSH)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_PUSH __pragma ( warning( push ) )
#else
#define OACR_WARNING_PUSH __pragma ( prefast( push ) )
#endif
#else
#define OACR_WARNING_PUSH
#endif
#endif

#if !defined(OACR_WARNING_POP)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_POP __pragma ( warning( pop ) )
#else
#define OACR_WARNING_POP __pragma ( prefast( pop ) )
#endif
#else
#define OACR_WARNING_POP
#endif
#endif

#if !defined(OACR_WARNING_ENABLE)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_ENABLE( cWarning, comment ) __pragma ( warning( enable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#endif

#if !defined(OACR_WARNING_DISABLE)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( warning( disable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( prefast( disable: __WARNING_##cWarning, comment ) )
#endif
#else
#define OACR_WARNING_DISABLE( cWarning, comment )
#endif
#endif

#if !defined(OACR_WARNING_SUPPRESS)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( warning( suppress: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( prefast( suppress: __WARNING_##cWarning, comment) )
#endif
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment )
#endif
#endif

// macro to tell OACR about conditions that are true.
// Use OACR_ASSUME instead of #pragma prefast(suppress,...) if possible
// e.g.:
// if( g_pRoot == NULL ) // global variable g_pRoot
// {
//    InitRoot();
//    OACR_ASSUME( NULL != g_pRoot ); 
// }
// g_pRoot->Traverse();    // without OACR_ASSUME this would cause warning 11
#if( defined(OACR) && OACR )
#define OACR_ASSUME( fCondition ) __assume( fCondition )

#elif defined(Assert)
#define OACR_ASSUME( fCondition ) Assert( fCondition )

#else
#define OACR_ASSUME( fCondition ) __oacr_noop

#endif

// macro to tell OACR that a string is null terminated at this point of execution
#if( defined(OACR) && OACR && defined(_Post_z_) )
__extern_c void __OACRAssumeNullterminated( _Post_z_ const char* sz );
#define OACR_ASSUME_NULLTERMINATED( string ) __OACRAssumeNullterminated( (const char*)string )

#else
#define OACR_ASSUME_NULLTERMINATED( string ) __oacr_noop

#endif

// macro to tell OACR that a pointer is null valid at this point of execution
#if( defined(OACR) && OACR && defined(_Post_valid_) )
__extern_c void __OACRAssumeValid( _Post_valid_ const void* pv );
#define OACR_ASSUME_VALID( ptr ) __OACRAssumeValid( ptr )

#else
#define OACR_ASSUME_VALID( ptr ) __oacr_noop

#endif


// macro to tell OACR that a buffer has a certain readable extent at this point of execution
// it can be used to silent noisy espX INCORRECT_ANNOTATION warnings
#if( defined(OACR) && OACR && defined(_Post_bytecount_) )
__extern_c void __OACRAssumeByteCount( _Post_bytecount_(cb) const void* pv, size_t cb );
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __OACRAssumeByteCount( pv, cb )

#else
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __oacr_noop

#endif


// new intrinsinc functions in Whidbey compiler
#if( defined(_PREFAST2_) && _PREFAST2_ )
__extern_c void* _AddressOfReturnAddress();
#endif

// OACR custom plugin specific extensions

//=======================================================================

#define _Callback_                         __oacr_callback

#undef __override
#define __override                         __oacr_override

//======================================================================
// OACR custom attributes

// OACR custom plugin specific extensions

#if( _USE_ATTRIBUTES_FOR_SAL || OACR_FOREGROUND_ATTRIBUTES )

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#if defined(__cplusplus)
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

enum OACRFunctionFlag
{
   eOACRCallback          = 0x0001,
   eOACRRpc               = 0x0002,
   eOACROverride          = 0x0004,
   eOACRSealed            = 0x0008,
   eOACRMemberInitializer = 0x0010,
   eOACRUnsafeStringApi   = 0x0020,
   eOACRNeedsReview       = 0x0040,
   eOACRIntlDeprecated    = 0x0080,
   eOACRNoInferrence      = 0x0100,
   //eOACRMinFunction     = 0x0200,
   //eOACRMaxFunction     = 0x0400,
   //eOACRCompilerGen     = 0x0800,
   eOACRCanThrow          = 0x1000,
   eOACRBindReturn        = 0x2000,
};

REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionFlagsAttribute
{
#if defined(__cplusplus)
	OACRFunctionFlagsAttribute();
#endif
	int Flags;
};

enum OACRFunctionProp
{
   eOACRDeprecated     = 0,
   eOACROleoDeprecated = 1,
};

typedef enum OACRFunctionProp OACRFunctionProp;

#pragma warning( push )
#pragma warning( disable:4820 )
REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionPropAttribute
{
#if defined(__cplusplus)
	OACRFunctionPropAttribute();
#endif
	OACRFunctionProp Type;
   const char*      SzVal;
};
#pragma warning( pop )

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

typedef struct OACRFunctionFlagsAttribute SA_OACRFunctionFlags;
typedef struct OACRFunctionPropAttribute  SA_OACRFunctionProp;

//--------------------------------------------------

#if defined(_PREFAST_)
// use __declspecs until Whidbey-PREfast bug VS:479840 is fixed
#define __oacr_callback          __declspec("_Callback_")
#define __oacr_override          __declspec("_Override_")
#else  // _PREFAST_
#define __oacr_callback
#define __oacr_override
#endif  // _PREFAST_
//#define __oacr_callback          [method:SA_OACRFunctionFlags(Flags=eOACRCallback         )]
//#define __oacr_override          [method:SA_OACRFunctionFlags(Flags=eOACROverride         )]
#define __oacr_rpc               [method:SA_OACRFunctionFlags(Flags=eOACRRpc)]
#define __oacr_sealed_method     [method:SA_OACRFunctionFlags(Flags=eOACRSealed)]
#define __oacr_memberinitializer [method:SA_OACRFunctionFlags(Flags=eOACRMemberInitializer)]
#define __oacr_unsafe_string_api [method:SA_OACRFunctionFlags(Flags=eOACRUnsafeStringApi)]
#define __oacr_needsreview       [method:SA_OACRFunctionFlags(Flags=eOACRNeedsReview)]
#define __oacr_intl_deprecated   [method:SA_OACRFunctionFlags(Flags=eOACRIntlDeprecated)]
#define __oacr_noinference       [method:SA_OACRFunctionFlags(Flags=eOACRNoInferrence)]
#define __oacr_canthrow          [method:SA_OACRFunctionFlags(Flags=eOACRCanThrow)]
#define __oacr_bindReturn        [method:SA_OACRFunctionFlags(Flags=eOACRBindReturn)]

#define __oacr_sa_deprecated( NewFunctionName )   [method:SA_OACRFunctionProp(Type=eOACRDeprecated,    SzVal=#NewFunctionName)]
#define __oacr_oleo_deprecated( NewFunctionName ) [method:SA_OACRFunctionProp(Type=eOACROleoDeprecated,SzVal=#NewFunctionName)]

#if defined(_PREFAST_)
#define __oacr_genericfunctype  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype  __declspec("_Nothrowfunctype_")
#define __oacr_noheap           __declspec("_Noheap_" )
#define __oacr_notrunccast      __declspec("_Notrunccast_" )
#define __oacr_sealed_class     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();
#else  // _PREFAST_
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow
#endif  // _PREFAST_

#elif( _USE_DECLSPECS_FOR_SAL )

#define __oacr_callback                         __declspec("_Callback_")
#define __oacr_override                         __declspec("_Override_")
#define __oacr_rpc                              __declspec("_Rpc_")
#define __oacr_sealed_method                    __declspec("_Sealed_")
#define __oacr_memberinitializer                __declspec("_Memberinitializer_")
#define __oacr_unsafe_string_api                __declspec("_Unsafe_string_api_")
#define __oacr_needsreview                      __declspec("_Needsreview_")
#define __oacr_intl_deprecated                  __declspec("_Intl_deprecated_")
#define __oacr_noinference                      __declspec("_Noinference_")
#define __oacr_canthrow                         __declspec("_Canthrow_")
#define __oacr_bindReturn                       __declspec("_BindReturn_")
#define __oacr_sa_deprecated(NewFunctionName)   __declspec("_SA_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_oleo_deprecated(NewFunctionName) __declspec("_Oleo_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_genericfunctype                  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype                  __declspec("__nothrowfunctype") // TODO: change to _Nothrowfunctype_
#define __oacr_noheap                           __declspec("_Noheap_")
#define __oacr_notrunccast                      __declspec("_Notrunccast_")
#define __oacr_sealed_class                     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();

#else // neither [attributes] not __declspecs

#define __oacr_callback
#define __oacr_override
#define __oacr_rpc
#define __oacr_sealed_method
#define __oacr_memberinitializer
#define __oacr_unsafe_string_api
#define __oacr_needsreview
#define __oacr_intl_deprecated
#define __oacr_noinference
#define __oacr_canthrow
#define __oacr_bindReturn
#define __oacr_sa_deprecated(NewFunctionName)
#define __oacr_oleo_deprecated(NewFunctionName)
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\x86\inc\oacrhook.h ===
#pragma once
/*****************************************************************************

   Module  : OACRHook
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  Part of the Microsoft Auto Code Review (OACR) system.
  
  OACR supports hooking into the calls to build tools (cl.exe, link.exe, etc.),
  in order to perform custom operations as part of the build. The user can 
  provide a DLL, which is then loaded and called by OACR at the appropriate
  time. This header file declares the callback function that needs to be
  implemented by the DLL.

*****************************************************************************/

#ifdef __cplusplus

// Callback to process build tool output (stdout,stderr) line by line.
// 'pClientData' is the client data passed to FReadStdOutFile() or FReadStdErrFile().
// Must return true to get next line, or false to abort reading.
typedef bool ( __stdcall *PFNFPROCESSLINE )( const WCHAR* wzLine, void* pClientData );


// The interface passed with each notification.
interface IBuildToolRunInfo
{
   // NOTE: All APIs returning a string, return the number of characters
   //       copied to the output string (not including the NULL termination). 
   //       If the string to be returned is too long, it is truncated, and
   //       the buffer size is returned.
   //       If 0 is passed for the buffer size, the minimum required buffer
   //       size (including the NULL termination) is returned.
   //       In the error case, 0 is returned.

   // Build tools that can be hooked into
   enum Tool
   {
      NONE = 0,

      CL,   // C/C++ compiler (cl.exe)
      CSC,  // C# compiler (csc.exe)
      LINK, // Linker (link.exe)
      LIB,  // Library manager (lib.exe)
      MIDL, // MIDL compiler (midl.exe)
   };

   // Notifications sent
   enum Notification
   {
      BEFORE_RUN,   // Sent before the build tool is called
      AFTER_RUN,    // Sent after the build tools has been run
      AFTER_RETRY,  // Sent after a retry of a build tool run
   };

   //-------------------------------------------------------------------------
   // Client data
   //
   // Can be used to maintain state between notifications for the same build
   // tool run.
   //-------------------------------------------------------------------------

   virtual void  SetClientData( void* pData ) = 0;
   virtual void* GetClientData() const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Any notification
   //-------------------------------------------------------------------------

   // Return the current notification.
   virtual Notification GetNotification() const = 0;

   // Return the build tool that triggered the notification.
   virtual Tool GetTool() const = 0;

   // Return the name of the OACR project under which the build tool has been called.
   virtual DWORD GetOACRProjectName( WCHAR* wzProjectName, DWORD cchProjectName ) const = 0;

   // Return the command line, as passed to the build tool.
   virtual DWORD GetCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the fully expanded command line. Reponse files (e.g. '@c:\temp\foo.tmp'),
   // and environment variables (e.g. %CL%) are folded into the command line.
   virtual DWORD GetExpandedCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the full path name of the build tool executable.
   virtual DWORD GetToolFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the primary output file generated by the build tool run.
   //    CL  : .obj file
   //    CSC : .exe or .dll (specified in the first /out switch)
   //    LINK: .exe or .dll
   //    LIB : .lib
   //    MIDL: .h file
   // The call fails for CL with multiple source files (batch runs). Use the batch run
   // APIs to get information about batch runs.
   virtual DWORD GetOutputFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true for a batch CL run (i.e. multiple source files)
   virtual bool FBatchRun() const = 0;

   // Return the number of source files in the batch run. Returns 0, for non batch runs.
   virtual DWORD CBatchItems() const = 0;

   // Return the full path name of the output file (.obj) for the source file with the
   // specified index. Returns 0 for non batch runs.
   virtual DWORD GetBatchItemOutputFileName( DWORD whichItem, WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Return the result code for the build tool run.
   virtual int GetResult() const = 0;

   // Return the full path name of the file to which stdout output of the build tool run
   // has been redirected. Returns 0, if stdout redirection is turned off.
   virtual DWORD GetStdOutFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the file to which stderr output of the build tool run
   // has been redirected. Returns 0, if stderr redirection is turned off.
   virtual DWORD GetStdErrFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Read the redirected stdout output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stdout redirection is turned off.
   virtual bool FReadStdOutFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   // Read the redirected stderr output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stderr redirection is turned off.
   virtual bool FReadStdErrFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true, if the source file with the specified index was compiled successfully.
   // Returns fals for non batch runs.
   virtual bool FBatchItemSuccess( DWORD whichItem ) const = 0;

   //-------------------------------------------------------------------------
   // Generate stdout & stderr output - Any notification
   //-------------------------------------------------------------------------

   // Write to stdout.
   virtual void WriteStdOut( const WCHAR* wzMessage ) const = 0;

   // Write to stderr.
   virtual void WriteStdErr( const WCHAR* wzMessage ) const = 0;

   // Write the content of the specified text file to stdout.
   virtual bool FWriteStdOutFromFile( const WCHAR* wzFileName ) const = 0;

   // Write the content of the specified text file to stderr.
   virtual bool FWriteStdErrFromFile( const WCHAR* wzFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Any notification
   //-------------------------------------------------------------------------

   // Enable or disable further notifications for this build tool run. 
   // Notifications are enabled by default.
   virtual void SetNotify( bool fNotify ) = 0;

   // Override the result code for the build tool run.
   virtual void SetResult( int result ) = 0;

   // Set the command line to be passed to the build tool.
   virtual void SetCommandLine( const WCHAR* wzCommandLine ) = 0;

   // Set the file name of the build tool executable to be called.
   virtual void SetToolFileName( const WCHAR* wzFileName ) = 0;

   // Enable or disable redirection of stdout output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdOut( bool fCapture ) = 0;

   // Enable or disable redirection of stderr output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdErr( bool fCapture ) = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notification 'BEFORE_RUN'
   //-------------------------------------------------------------------------

   // Cancel the build tool run. Use the SetResult() API to set the result code.
   // This is a noop, if called during the AFTER_RUN or AFTER_RETRY notification.
   virtual void CancelRun() = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Force a retry of the build tool run.
   // This is a noop, if called during the BEFORE_RUN notification.
   virtual void RetryRun() = 0;

}; // IBuildToolRunInfo


// The callback that is called by OACR.
// This method needs to be implemented in the user provided DLL, so that OACR 
// can call it through LoadLibrary()/GetProcAddress()
extern "C" _Callback_ void __stdcall OnBuildToolRun( _In_ IBuildToolRunInfo& toolRunInfo );

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\x86\inc\pftwarnings.h ===
#pragma once
/*****************************************************************************

DO NOT EDIT - Generated file

PREfast Warning Ids

PREfast(x86)      : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   espcxxdrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   goldpft        : 9.0.21022.40216
   integeroverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.41211
   oacrexc        : 9.0.21022.41211
   oacrmodel      : 9.0.21022.41211
   salcheck       : 9.0.21022.30208

PREfast(amd64)    : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   espcxxdrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   goldpft        : 9.0.21022.40216
   integeroverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.41211
   oacrexc        : 9.0.21022.41211
   oacrmodel      : 9.0.21022.41211
   salcheck       : 9.0.21022.30208

Esp               : 1.2.30415.30908
Defect modules
   cfgpersist     : 1.2.30415.30908
   espbldchk      : 1.2.30415.30908
   espopal        : 1.2.30415.30908
   goldman        : 1.1.30415.40216
   goldmanres     : 1.1.30415.40216
   nullptr        : 1.2.30415.30908
   sqleye.tsql    : 1.2.30415.30516
   in             : <no version>
   sqleye.managed.escapinganddelimiting: <no version>
   sqleye.native.escapinganddelimiting: <no version>
   sqleye.native.missingcommandsal: <no version>
   sqleye.native.missingconnectionstringsal: <no version>
   sqleye.native.truncation: <no version>
   sqleye.tsql.escapinganddelimiting: <no version>

Generated on 03/29/10 at 15:27:42

*****************************************************************************/


#ifdef OACR

/* MSPFT */

#define __WARNING_6001 6001
#define __WARNING_USING_UNINIT_VAR 6001
#define __WARNING_6011 6011
#define __WARNING_DEREF_NULL_PTR 6011
#define __WARNING_6029 6029
#define __WARNING_USING_TAINTED_DATA 6029
#define __WARNING_6031 6031
#define __WARNING_RETVAL_IGNORED_FUNC_COULD_FAIL 6031
#define __WARNING_6053 6053
#define __WARNING_MISSING_ZERO_TERMINATION1 6053
#define __WARNING_6054 6054
#define __WARNING_MISSING_ZERO_TERMINATION2 6054
#define __WARNING_6057 6057
#define __WARNING_CHAR_BYTE_SIZE_MISMATCH 6057
#define __WARNING_6059 6059
#define __WARNING_BAD_CONCATENATION 6059
#define __WARNING_6063 6063
#define __WARNING_MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6063
#define __WARNING_6064 6064
#define __WARNING_MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6064
#define __WARNING_6066 6066
#define __WARNING_NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION 6066
#define __WARNING_6067 6067
#define __WARNING_NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6067
#define __WARNING_6200 6200
#define __WARNING_INDEX_EXCEEDS_MAX_NONSTACK 6200
#define __WARNING_6201 6201
#define __WARNING_INDEX_EXCEEDS_MAX 6201
#define __WARNING_6202 6202
#define __WARNING_BUFFER_OVERRUN 6202
#define __WARNING_6203 6203
#define __WARNING_BUFFER_OVERRUN_NONSTACK 6203
#define __WARNING_6204 6204
#define __WARNING_UNVALIDATED_PARAM 6204
#define __WARNING_6209 6209
#define __WARNING_SIZEOF_CHAR_BYTE_SIZE_MISMATCH 6209
#define __WARNING_6211 6211
#define __WARNING_MEMORY_LEAK_EXCEPTION 6211
#define __WARNING_6214 6214
#define __WARNING_CAST_HRESULT_TO_BOOL 6214
#define __WARNING_6215 6215
#define __WARNING_CAST_BOOL_TO_HRESULT 6215
#define __WARNING_6216 6216
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_HRESULT 6216
#define __WARNING_6217 6217
#define __WARNING_TESTING_HRESULT_WITH_NOT 6217
#define __WARNING_6219 6219
#define __WARNING_COMPARING_HRESULT_TO_ONE 6219
#define __WARNING_6220 6220
#define __WARNING_COMPARING_HRESULT_TO_MINUS_ONE 6220
#define __WARNING_6221 6221
#define __WARNING_COMPARING_HRESULT_TO_INT 6221
#define __WARNING_6225 6225
#define __WARNING_ASSIGNING_ONE_TO_HRESULT 6225
#define __WARNING_6226 6226
#define __WARNING_ASSIGNING_MINUS_ONE_TO_HRESULT 6226
#define __WARNING_6230 6230
#define __WARNING_USING_HRESULT_IN_BOOLEAN_CONTEXT 6230
#define __WARNING_6235 6235
#define __WARNING_NONZEROLOGICALOR 6235
#define __WARNING_6236 6236
#define __WARNING_LOGICALORNONZERO 6236
#define __WARNING_6237 6237
#define __WARNING_ZEROLOGICALANDLOSINGSIDEEFFECTS 6237
#define __WARNING_6239 6239
#define __WARNING_NONZEROLOGICALAND 6239
#define __WARNING_6240 6240
#define __WARNING_LOGICALANDNONZERO 6240
#define __WARNING_6242 6242
#define __WARNING_LOCALUNWINDFORCED 6242
#define __WARNING_6244 6244
#define __WARNING_LOCALDECLHIDESGLOBAL 6244
#define __WARNING_6246 6246
#define __WARNING_LOCALDECLHIDESLOCAL 6246
#define __WARNING_6248 6248
#define __WARNING_CREATINGNULLDACL 6248
#define __WARNING_6250 6250
#define __WARNING_WIN32UNRELEASEDVADS 6250
#define __WARNING_6255 6255
#define __WARNING_UNPROTECTEDUSEOFALLOCA 6255
#define __WARNING_6258 6258
#define __WARNING_USINGTERMINATETHREAD 6258
#define __WARNING_6259 6259
#define __WARNING_DEADCODEINBITORLIMITEDSWITCH 6259
#define __WARNING_6260 6260
#define __WARNING_USEOFBYTEAREA 6260
#define __WARNING_6262 6262
#define __WARNING_EXCESSIVESTACKUSAGE 6262
#define __WARNING_6263 6263
#define __WARNING_USINGALLOCAINLOOP 6263
#define __WARNING_6268 6268
#define __WARNING_MISPARENTHESIZED_CASTS 6268
#define __WARNING_6269 6269
#define __WARNING_POINTER_DEREF_DISCARDED 6269
#define __WARNING_6270 6270
#define __WARNING_MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6270
#define __WARNING_6271 6271
#define __WARNING_EXTRA_ARGUMENT_TO_FORMAT_FUNCTION 6271
#define __WARNING_6272 6272
#define __WARNING_NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6272
#define __WARNING_6273 6273
#define __WARNING_NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6273
#define __WARNING_6274 6274
#define __WARNING_NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6274
#define __WARNING_6276 6276
#define __WARNING_CHAR_TO_WCHAR_CAST 6276
#define __WARNING_6277 6277
#define __WARNING_CREATEPROCESS_ESCAPE 6277
#define __WARNING_6278 6278
#define __WARNING_ARRAY_NEW_DELETE_MISMATCH 6278
#define __WARNING_6279 6279
#define __WARNING_NEW_ARRAY_DELETE_MISMATCH 6279
#define __WARNING_6280 6280
#define __WARNING_MEMORY_ALLOCATION_MISMATCH 6280
#define __WARNING_6281 6281
#define __WARNING_BITWISERELATIONPRECEDENCEERROR 6281
#define __WARNING_6282 6282
#define __WARNING_ASSIGNMENTREPLACESTEST 6282
#define __WARNING_6283 6283
#define __WARNING_PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH 6283
#define __WARNING_6284 6284
#define __WARNING_OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6284
#define __WARNING_6285 6285
#define __WARNING_LOGICALOROFCONSTANTS 6285
#define __WARNING_6286 6286
#define __WARNING_NONZEROLOGICALORLOSINGSIDEEFFECTS 6286
#define __WARNING_6287 6287
#define __WARNING_REDUNDANTTEST 6287
#define __WARNING_6288 6288
#define __WARNING_MUTUALINCLUSIONOVERANDISFALSE 6288
#define __WARNING_6289 6289
#define __WARNING_MUTUALEXCLUSIONOVERORISTRUE 6289
#define __WARNING_6290 6290
#define __WARNING_LOGICALNOTBITWISEAND 6290
#define __WARNING_6291 6291
#define __WARNING_LOGICALNOTBITWISEOR 6291
#define __WARNING_6292 6292
#define __WARNING_LOOP_COUNTS_UP_FROM_MAX 6292
#define __WARNING_6293 6293
#define __WARNING_LOOP_INDEX_GOES_NEGATIVE 6293
#define __WARNING_6294 6294
#define __WARNING_LOOP_BODY_NEVER_EXECUTED 6294
#define __WARNING_6295 6295
#define __WARNING_INFINITE_LOOP 6295
#define __WARNING_6296 6296
#define __WARNING_LOOP_ONLY_EXECUTED_ONCE 6296
#define __WARNING_6297 6297
#define __WARNING_RESULTOFSHIFTCASTTOLARGERSIZE 6297
#define __WARNING_6298 6298
#define __WARNING_CONST_STRING_TO_WRITABLE_STRING 6298
#define __WARNING_6299 6299
#define __WARNING_BITFIELD_TO_BOOL_COMPARISON 6299
#define __WARNING_6302 6302
#define __WARNING_CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION 6302
#define __WARNING_6303 6303
#define __WARNING_WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6303
#define __WARNING_6305 6305
#define __WARNING_SIZEOF_COUNTOF_MISMATCH 6305
#define __WARNING_6306 6306
#define __WARNING_INCORRECT_VARARG_FUNCTIONCALL 6306
#define __WARNING_6308 6308
#define __WARNING_REALLOCLEAK 6308
#define __WARNING_6309 6309
#define __WARNING_PASSING_FUNCTION_UNEXPECTED_NULL 6309
#define __WARNING_6310 6310
#define __WARNING_ILLEGALEXCEPTEXPRCONST 6310
#define __WARNING_6312 6312
#define __WARNING_EXCEPTIONCONTINUEEXECUTION 6312
#define __WARNING_6313 6313
#define __WARNING_BITANDVSZEROVALUEDFLAG 6313
#define __WARNING_6314 6314
#define __WARNING_BITORVSQUESTION 6314
#define __WARNING_6315 6315
#define __WARNING_BITORVSBITAND 6315
#define __WARNING_6316 6316
#define __WARNING_INAPPROPRIATEUSEOFBITOR 6316
#define __WARNING_6317 6317
#define __WARNING_NOTNOTCOMPLEMENT 6317
#define __WARNING_6318 6318
#define __WARNING_EXCEPTIONCONTINUESEARCH 6318
#define __WARNING_6319 6319
#define __WARNING_IGNOREDBYCOMMA 6319
#define __WARNING_6320 6320
#define __WARNING_EXCEPTIONEXECUTEHANDLER 6320
#define __WARNING_6322 6322
#define __WARNING_EXCEPT_BLOCK_EMPTY 6322
#define __WARNING_6323 6323
#define __WARNING_ARITH_OP_ON_BOOL 6323
#define __WARNING_6324 6324
#define __WARNING_STRCPY_INSTEAD_OF_STRCMP 6324
#define __WARNING_6326 6326
#define __WARNING_CONST_CONST_COMP 6326
#define __WARNING_6327 6327
#define __WARNING_DEST_BUFFER_INSUFFICIENT 6327
#define __WARNING_6328 6328
#define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH 6328
#define __WARNING_6329 6329
#define __WARNING_POTENTIAL_INCORRECT_RETVAL_CHECK 6329
#define __WARNING_6331 6331
#define __WARNING_VIRTUALFREEINVALIDPARAM1 6331
#define __WARNING_6332 6332
#define __WARNING_VIRTUALFREEINVALIDPARAM2 6332
#define __WARNING_6333 6333
#define __WARNING_VIRTUALFREEINVALIDPARAM3 6333
#define __WARNING_6334 6334
#define __WARNING_SIZEOFEXPR 6334
#define __WARNING_6335 6335
#define __WARNING_LEAKING_PROCESS_HANDLE 6335
#define __WARNING_6336 6336
#define __WARNING_QUESTIONPRECEDENCE 6336
#define __WARNING_6381 6381
#define __WARNING_SHUTDOWN_API 6381
#define __WARNING_6383 6383
#define __WARNING_ELEMENTS_TO_BYTES 6383
#define __WARNING_6384 6384
#define __WARNING_DIVIDING_SIZEOF_POINTER 6384
#define __WARNING_6385 6385
#define __WARNING_READ_OVERRUN 6385
#define __WARNING_6386 6386
#define __WARNING_WRITE_OVERRUN 6386
#define __WARNING_6387 6387
#define __WARNING_INVALID_PARAM_VALUE_1 6387
#define __WARNING_6388 6388
#define __WARNING_INVALID_PARAM_VALUE_2 6388
#define __WARNING_6400 6400
#define __WARNING_LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON 6400
#define __WARNING_6401 6401
#define __WARNING_DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON 6401
#define __WARNING_6500 6500
#define __WARNING_INVALID_ATTRIBUTE_PROPERTY 6500
#define __WARNING_6501 6501
#define __WARNING_CONFLICTING_ATTRIBUTE_PROPERTY_VALUES 6501
#define __WARNING_6503 6503
#define __WARNING_REFERENCES_CANT_BE_NULL 6503
#define __WARNING_6504 6504
#define __WARNING_NULL_ON_NON_POINTER 6504
#define __WARNING_6505 6505
#define __WARNING_MUSTCHECK_ON_VOID 6505
#define __WARNING_6506 6506
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER_OR_ARRAY 6506
#define __WARNING_6507 6507
#define __WARNING_NULL_MISMATCH_AT_DEREF_0 6507
#define __WARNING_6508 6508
#define __WARNING_WRITE_ACCESS_ON_CONST 6508
#define __WARNING_6509 6509
#define __WARNING_RETURN_USED_ON_PRECONDITION 6509
#define __WARNING_6510 6510
#define __WARNING_NULLTERMINATED_ON_NON_POINTER 6510
#define __WARNING_6511 6511
#define __WARNING_MUSTCHECK_MAYBE 6511
#define __WARNING_6512 6512
#define __WARNING_NULL_CONFLICTS_WITH_NOT_VALID 6512
#define __WARNING_6513 6513
#define __WARNING_ELEMENT_SIZE_WITHOUT_BUFFER_SIZE 6513
#define __WARNING_6514 6514
#define __WARNING_BUFFER_SIZE_EXCEEDS_ARRAY_SIZE 6514
#define __WARNING_6515 6515
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER 6515
#define __WARNING_6516 6516
#define __WARNING_NO_PROPERTIES_ON_ATTRIBUTE 6516
#define __WARNING_6517 6517
#define __WARNING_VALID_SIZE_ON_NON_READABLE_BUFFER 6517
#define __WARNING_6518 6518
#define __WARNING_WRITABLE_SIZE_ON_NON_WRITABLE_BUFFER 6518
#define __WARNING_6521 6521
#define __WARNING_INVALID_SIZE_STRING_DEREF 6521
#define __WARNING_6522 6522
#define __WARNING_INVALID_SIZE_STRING_TYPE 6522
#define __WARNING_6523 6523
#define __WARNING_INVALID_SIZE_STRING_PARAM 6523
#define __WARNING_6525 6525
#define __WARNING_INVALID_SIZE_STRING_UNREACHABLE_LOCATION 6525
#define __WARNING_6526 6526
#define __WARNING_INVALID_SIZE_STRING_BUFFER_TYPE 6526
#define __WARNING_6530 6530
#define __WARNING_UNRECOGNIZED_FORMAT_STRING_STYLE 6530
#define __WARNING_6535 6535
#define __WARNING_BUFFERSIZE_INFEASIBLE 6535
#define __WARNING_6540 6540
#define __WARNING_OVERRIDING_OLD_MODEL 6540
#define __WARNING_6990 6990
#define __WARNING_MANAGEDCODENOTSUPPORTED 6990
#define __WARNING_6991 6991
#define __WARNING_ATTRIBUTESNOTSUPPORTED 6991
#define __WARNING_6992 6992
#define __WARNING_NATIVEEVENTSYNTAXNOTSUPPORTED 6992
#define __WARNING_6993 6993
#define __WARNING_OMPNOTSUPPORTED 6993
#define __WARNING_6994 6994
#define __WARNING_PCHNOTFOUND 6994
#define __WARNING_6995 6995
#define __WARNING_SAVETOXMLFAILED 6995

/* GoldMan */

#define __WARNING_17900 17900
#define __WARNING_HARDCODED_STR_IN_USER_FACING_API 17900
#define __WARNING_17901 17901
#define __WARNING_HARDCODED_STR_FOR_LOCALIZED_ATTRIBUTE 17901
#define __WARNING_17902 17902
#define __WARNING_HARDCODED_STR_IN_TURKISH_I 17902
#define __WARNING_17903 17903
#define __WARNING_CULTURE_INFO_FROM_LCID 17903
#define __WARNING_17904 17904
#define __WARNING_CULTURE_INFO_MISUSE 17904
#define __WARNING_17905 17905
#define __WARNING_HARDCODED_FONT_FAMILY_AND_SIZE 17905
#define __WARNING_17906 17906
#define __WARNING_RESOURCE_STRING_CONCAT 17906
#define __WARNING_17907 17907
#define __WARNING_CONCAT_STR_IN_USER_FACING_API 17907
#define __WARNING_17908 17908
#define __WARNING_CONCAT_STR_FOR_LOCALIZED_ATTRIBUTE 17908
#define __WARNING_17909 17909
#define __WARNING_LOC_METADATA_GENERATED_GOLDMAN 17909

/* IntegerOverflow */

#define __WARNING_22010 22010
#define __WARNING_DUMMY_IO_WARNING1 22010
#define __WARNING_22011 22011
#define __WARNING_ALLOC_SIZE_OVERFLOW 22011
#define __WARNING_22012 22012
#define __WARNING_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22012
#define __WARNING_22013 22013
#define __WARNING_INDEX_WRONG_OVERFLOW_CHECK 22013
#define __WARNING_22014 22014
#define __WARNING_ALLOC_SIZE_NEGATIVE 22014
#define __WARNING_22015 22015
#define __WARNING_INDEX_NEGATIVE 22015
#define __WARNING_22016 22016
#define __WARNING_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22016
#define __WARNING_22017 22017
#define __WARNING_ALLOC_SIZE_UNDERFLOW 22017
#define __WARNING_22018 22018
#define __WARNING_INDEX_UNDERFLOW 22018
#define __WARNING_22019 22019
#define __WARNING_LOOP_INDEX_UNDERFLOW 22019
#define __WARNING_22020 22020
#define __WARNING_SIGNED_UNSIGNED_COMPARISON 22020
#define __WARNING_22021 22021
#define __WARNING_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22021
#define __WARNING_22022 22022
#define __WARNING_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22022
#define __WARNING_22023 22023
#define __WARNING_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22023
#define __WARNING_22024 22024
#define __WARNING_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22024
#define __WARNING_22025 22025
#define __WARNING_RETVAL_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22025
#define __WARNING_22026 22026
#define __WARNING_REFARG_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22026
#define __WARNING_22027 22027
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22027
#define __WARNING_22028 22028
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22028
#define __WARNING_22029 22029
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22029
#define __WARNING_22030 22030
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22030
#define __WARNING_22051 22051
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW 22051
#define __WARNING_22052 22052
#define __WARNING_UNTRUSTED_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22052
#define __WARNING_22053 22053
#define __WARNING_UNTRUSTED_INDEX_WRONG_OVERFLOW_CHECK 22053
#define __WARNING_22054 22054
#define __WARNING_UNTRUSTED_ALLOC_SIZE_NEGATIVE 22054
#define __WARNING_22055 22055
#define __WARNING_UNTRUSTED_INDEX_NEGATIVE 22055
#define __WARNING_22056 22056
#define __WARNING_UNTRUSTED_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22056
#define __WARNING_22057 22057
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW 22057
#define __WARNING_22058 22058
#define __WARNING_UNTRUSTED_INDEX_UNDERFLOW 22058
#define __WARNING_22059 22059
#define __WARNING_UNTRUSTED_LOOP_INDEX_UNDERFLOW 22059
#define __WARNING_22060 22060
#define __WARNING_UNTRUSTED_SIGNED_UNSIGNED_COMPARISON 22060
#define __WARNING_22061 22061
#define __WARNING_UNTRUSTED_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22061
#define __WARNING_22062 22062
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22062
#define __WARNING_22063 22063
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22063
#define __WARNING_22064 22064
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22064
#define __WARNING_22067 22067
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22067
#define __WARNING_22068 22068
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22068
#define __WARNING_22069 22069
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22069
#define __WARNING_22070 22070
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22070
#define __WARNING_22081 22081
#define __WARNING_UNTRUSTED_ALLOC_SIZE 22081
#define __WARNING_22082 22082
#define __WARNING_UNTRUSTED_INDEX 22082
#define __WARNING_22083 22083
#define __WARNING_UNTRUSTED_LOOP_INDEX 22083
#define __WARNING_22084 22084
#define __WARNING_UNTRUSTED_OVERFLOWN_EXPR 22084
#define __WARNING_22085 22085
#define __WARNING_UNTRUSTED_UNDERFLOWN_EXPR 22085

/* OACRCPLUS */

#define __WARNING_25000 25000
#define __WARNING_BIG_FORMAL_PARAM 25000
#define __WARNING_25001 25001
#define __WARNING_IMPLICIT_CTOR 25001
#define __WARNING_25002 25002
#define __WARNING_UPCAST_CTOR 25002
#define __WARNING_25003 25003
#define __WARNING_NONCONST_LOCAL 25003
#define __WARNING_25004 25004
#define __WARNING_NONCONST_PARAM 25004
#define __WARNING_25005 25005
#define __WARNING_NONCONST_FUNCTION 25005
#define __WARNING_25006 25006
#define __WARNING_UNUSED_PARAM 25006
#define __WARNING_25007 25007
#define __WARNING_STATIC_FUNCTION 25007
#define __WARNING_25008 25008
#define __WARNING_FREE_CONSTRUCTOR_CALL 25008
#define __WARNING_25009 25009
#define __WARNING_IDENTITY_ASSIGNMENT 25009
#define __WARNING_25010 25010
#define __WARNING_VIRTUAL_CALL_IN_CTOR 25010
#define __WARNING_25011 25011
#define __WARNING_CASE_FALLTHRU 25011
#define __WARNING_25012 25012
#define __WARNING_SMARTPOINTER_DELETE 25012
#define __WARNING_25013 25013
#define __WARNING_RETURN_FROM_GOTO_CONTEXT 25013
#define __WARNING_25014 25014
#define __WARNING_MISSING_OVERRIDE 25014
#define __WARNING_25015 25015
#define __WARNING_DOESNT_OVERRIDE 25015
#define __WARNING_25016 25016
#define __WARNING_OVERRIDE_CONST_MISMATCH 25016
#define __WARNING_25017 25017
#define __WARNING_OVERRIDING_NONVIRTUAL 25017
#define __WARNING_25018 25018
#define __WARNING_DIFFERENT_CALLING_CONVENTION 25018
#define __WARNING_25019 25019
#define __WARNING_VERYBIG_FORMAL_PARAM 25019
#define __WARNING_25020 25020
#define __WARNING_SAMENAME_DATAMEMBER 25020
#define __WARNING_25021 25021
#define __WARNING_POOR_DATAALIGNMENT 25021
#define __WARNING_25022 25022
#define __WARNING_REMOVERETURNCONST_FUNCTIONCAST 25022
#define __WARNING_25023 25023
#define __WARNING_BOGUS_BSTRCONST 25023
#define __WARNING_25024 25024
#define __WARNING_DANGEROUS_POINTERCAST 25024
#define __WARNING_25025 25025
#define __WARNING_UNSAFE_STRING_FUNCTION 25025
#define __WARNING_25026 25026
#define __WARNING_OBSOLETE_INI_ACCESSOR 25026
#define __WARNING_25027 25027
#define __WARNING_BANNED_FUNCTION 25027
#define __WARNING_25028 25028
#define __WARNING_FUNCTION_NEEDS_REVIEW 25028
#define __WARNING_25029 25029
#define __WARNING_OBSOLETE_ACL_FUNCTION 25029
#define __WARNING_25030 25030
#define __WARNING_BOGUS_EXPRESSION_LIST 25030
#define __WARNING_25031 25031
#define __WARNING_HRESULT_NOT_CHECKED 25031
#define __WARNING_25032 25032
#define __WARNING_NONCONST_LOCAL_BUFFERPTR 25032
#define __WARNING_25033 25033
#define __WARNING_NONCONST_BUFFER_PARAM 25033
#define __WARNING_25035 25035
#define __WARNING_SIZEOF_POINTER_IN_DIVISION 25035
#define __WARNING_25036 25036
#define __WARNING_STATIC_MASKING_VIRTUAL 25036
#define __WARNING_25037 25037
#define __WARNING_TRUE_CONSTANT_EXPR_IN_AND 25037
#define __WARNING_25038 25038
#define __WARNING_FALSE_CONSTANT_EXPR_IN_AND 25038
#define __WARNING_25039 25039
#define __WARNING_TRUE_CONSTANT_EXPR_IN_OR 25039
#define __WARNING_25040 25040
#define __WARNING_FALSE_CONSTANT_EXPR_IN_OR 25040
#define __WARNING_25041 25041
#define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE 25041
#define __WARNING_25042 25042
#define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE 25042
#define __WARNING_25043 25043
#define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR 25043
#define __WARNING_25044 25044
#define __WARNING_BSTR_PARAM_SHOULD_BE_CONST_WCHAR_PTR 25044
#define __WARNING_25045 25045
#define __WARNING_ISBADPTR_FUNCTION 25045
#define __WARNING_25046 25046
#define __WARNING_SPECIFY_SELECTANY 25046
#define __WARNING_25047 25047
#define __WARNING_INCORRECT_SELECTANY 25047
#define __WARNING_25048 25048
#define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST 25048
#define __WARNING_25049 25049
#define __WARNING_FREESTANDING_CONSTANT 25049
#define __WARNING_25050 25050
#define __WARNING_LOCAL_FUNCDECL 25050
#define __WARNING_25051 25051
#define __WARNING_DIFFERENT_RETURN_TYPE_SIZE 25051
#define __WARNING_25052 25052
#define __WARNING_DIFFERENT_RETURN_TYPE_KIND 25052
#define __WARNING_25053 25053
#define __WARNING_DIFFERENT_PARAM_COUNT 25053
#define __WARNING_25054 25054
#define __WARNING_DIFFERENT_PARAM_TYPE_SIZE 25054
#define __WARNING_25055 25055
#define __WARNING_DIFFERENT_PARAM_TYPE_KIND 25055
#define __WARNING_25056 25056
#define __WARNING_REMOVEPARAMCONST_FUNCTIONCAST 25056
#define __WARNING_25057 25057
#define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER 25057
#define __WARNING_25058 25058
#define __WARNING_CAST_CAN_BE_CONST 25058
#define __WARNING_25059 25059
#define __WARNING_SUPERFLUOUS_CAST 25059
#define __WARNING_25060 25060
#define __WARNING_SUPERFLUOUS_NOTNOT 25060
#define __WARNING_25061 25061
#define __WARNING_BACKWARD_JUMP 25061
#define __WARNING_25062 25062
#define __WARNING_BACKWARD_JUMP_IN_MACRO 25062
#define __WARNING_25063 25063
#define __WARNING_FILEMAPPING_WITH_GLOBAL_NAME 25063
#define __WARNING_25064 25064
#define __WARNING_FUNCTION_CALLED_TWICE_IN_MACRO 25064
#define __WARNING_25065 25065
#define __WARNING_UNSIGNED_SHORT_NEGATIVE_INT_COMPARISON 25065
#define __WARNING_25066 25066
#define __WARNING_OUTOFRANGE_SHORT_LONG_COMPARISON 25066
#define __WARNING_25067 25067
#define __WARNING_UNREACHABLE_CASE_LABEL 25067
#define __WARNING_25068 25068
#define __WARNING_USE_WIDE_API 25068
#define __WARNING_25069 25069
#define __WARNING_GOTO 25069
#define __WARNING_25070 25070
#define __WARNING_UNINITIALIZED_DATAMEMBER 25070
#define __WARNING_25071 25071
#define __WARNING_NO_MEMBERINIT 25071
#define __WARNING_25073 25073
#define __WARNING_WRONG_MEMBERINIT_ORDER 25073
#define __WARNING_25075 25075
#define __WARNING_NOHEAP_MEMBER 25075
#define __WARNING_25076 25076
#define __WARNING_NOHEAP_BASECLASS 25076
#define __WARNING_25077 25077
#define __WARNING_NEW_ON_NOHEAP 25077
#define __WARNING_25078 25078
#define __WARNING_CONDITIONAL_WITH_FALSE_TRUE 25078
#define __WARNING_25079 25079
#define __WARNING_CONDITIONAL_WITH_TRUE_FALSE 25079
#define __WARNING_25080 25080
#define __WARNING_CONDITIONAL_WITH_SAME_ALTERNATIVES 25080
#define __WARNING_25084 25084
#define __WARNING_DANGEROUS_ALL_ACCESS_ACL 25084
#define __WARNING_25085 25085
#define __WARNING_URL_NEEDS_TO_BE_REVIEWED 25085
#define __WARNING_25086 25086
#define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT 25086
#define __WARNING_25087 25087
#define __WARNING_UNSPECIFIED_ACCESSRIGHTS 25087
#define __WARNING_25089 25089
#define __WARNING_DEPRECATED_WIN16_FUNCTION 25089
#define __WARNING_25090 25090
#define __WARNING_USE_CPLUSPLUS_BOOL_CONST 25090
#define __WARNING_25091 25091
#define __WARNING_RETURNTYPE_CAN_BE_BOOL 25091
#define __WARNING_25092 25092
#define __WARNING_LOCAL_CAN_BE_BOOL 25092
#define __WARNING_25093 25093
#define __WARNING_FORMAL_CAN_BE_BOOL 25093
#define __WARNING_25094 25094
#define __WARNING_BASECLASS_SHOULDHAVE_PROTECTED_OR_VIRTUAL_DTOR 25094
#define __WARNING_25096 25096
#define __WARNING_ENUM_TYPEDEF 25096
#define __WARNING_25098 25098
#define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE 25098
#define __WARNING_25099 25099
#define __WARNING_USE_PREFIX_OPERATOR 25099
#define __WARNING_25100 25100
#define __WARNING_LHS_TEMP_OBJECT 25100
#define __WARNING_25101 25101
#define __WARNING_RHS_TEMP_OBJECT 25101
#define __WARNING_25102 25102
#define __WARNING_EXC_NOT_CAUGHT_BY_REFERENCE 25102
#define __WARNING_25103 25103
#define __WARNING_EXC_NOT_THROWN_BY_VALUE 25103
#define __WARNING_25104 25104
#define __WARNING_INCONSISTENT_DECLSPECS 25104
#define __WARNING_25105 25105
#define __WARNING_SEALED_BASE_CLASS 25105
#define __WARNING_25106 25106
#define __WARNING_SEALED_BASE_METHOD 25106
#define __WARNING_25107 25107
#define __WARNING_NOTRUNCCAST_PARAM 25107
#define __WARNING_25108 25108
#define __WARNING_UNBOUND_RETURN 25108
#define __WARNING_25109 25109
#define __WARNING_MISSING_BINDRETURN 25109
#define __WARNING_25110 25110
#define __WARNING_CLARYFY_PRECEDENCE_FOR_QUESTIONOPERATOR 25110
#define __WARNING_25112 25112
#define __WARNING_DEPRECATED_FUNCTION 25112
#define __WARNING_25113 25113
#define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED 25113
#define __WARNING_25114 25114
#define __WARNING_UNMARKED_INTL_DEPRECATED_FUNCTION 25114
#define __WARNING_25115 25115
#define __WARNING_DEPRECATED_INTL_FUNCTION_CALL 25115
#define __WARNING_25119 25119
#define __WARNING_OLEO_DEPRECATED_FUNCTION 25119
#define __WARNING_25120 25120
#define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER 25120
#define __WARNING_25124 25124
#define __WARNING_RETURNING_TEMP_OBJECT 25124
#define __WARNING_25125 25125
#define __WARNING_STRCPY_LOOP 25125
#define __WARNING_25126 25126
#define __WARNING_POSSIBLE_STRCPY_LOOP 25126
#define __WARNING_25127 25127
#define __WARNING_BOOLEAN_BITWISE_OPERATOR_MIX 25127
#define __WARNING_25128 25128
#define __WARNING_DIFFERENT_COMPARE_ON_64BIT 25128
#define __WARNING_25129 25129
#define __WARNING_POSSIBLE_64BIT_TRUNCATION 25129
#define __WARNING_25130 25130
#define __WARNING_NONCONST_CLSID 25130
#define __WARNING_25131 25131
#define __WARNING_EMPTY_DTOR 25131
#define __WARNING_25132 25132
#define __WARNING_BY_VALUE_FORMAL_WITH_DTOR 25132
#define __WARNING_25133 25133
#define __WARNING_BY_VALUE_TEMPLATEFORMAL_WITH_DTOR 25133
#define __WARNING_25134 25134
#define __WARNING_IMPLICIT_TEMPLATECTOR 25134
#define __WARNING_25135 25135
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_STATIC 25135
#define __WARNING_25136 25136
#define __WARNING_NONCONST_LOCAL_ARRAY 25136
#define __WARNING_25137 25137
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_PTR 25137
#define __WARNING_25138 25138
#define __WARNING_STATIC_ARRAY_SHOULD_BE_LOCAL_PTR 25138
#define __WARNING_25139 25139
#define __WARNING_EMPTY_NONPUBLIC_DTOR 25139
#define __WARNING_25140 25140
#define __WARNING_DANGEROUS_INTTOPTR_CAST 25140
#define __WARNING_25141 25141
#define __WARNING_PRINTF_FORMAT_STRING_PARAM_NEEDS_REVIEW 25141
#define __WARNING_25142 25142
#define __WARNING_OBSOLETE_OACR_REVIEWED_CALL_MACRO 25142
#define __WARNING_25143 25143
#define __WARNING_WRITABLE_GLOBAL_FUNCTION_POINTER 25143
#define __WARNING_25144 25144
#define __WARNING_MISALIGNED_DATAMEMBER 25144
#define __WARNING_25145 25145
#define __WARNING_UNSAFE_EXPRESSION_AS_SAFEINT_ARGUMENT 25145
#define __WARNING_25146 25146
#define __WARNING_MISSING_DATAMEMBER_SWAP 25146
#define __WARNING_25147 25147
#define __WARNING_SIZEOF_WITHOUT_PARENS 25147
#define __WARNING_25148 25148
#define __WARNING_OACRCPLUS_REQUIRES_OACRMODEL 25148
#define __WARNING_25149 25149
#define __WARNING_ARRAY_COMPAREDWITH_NULL 25149

/* OACRExc */

#define __WARNING_25301 25301
#define __WARNING_DTOR_SHOULD_BE_NOTHROW 25301
#define __WARNING_25302 25302
#define __WARNING_OPERATOR_DELETE_SHOULD_BE_NOTHROW 25302
#define __WARNING_25303 25303
#define __WARNING_SWAP_FUNC_SHOULD_BE_NOTHROW 25303
#define __WARNING_25304 25304
#define __WARNING_CALLBACK_FUNC_SHOULD_BE_NOTHROW 25304
#define __WARNING_25305 25305
#define __WARNING_CLEANUP_FUNC_SHOULD_BE_NOTHROW 25305
#define __WARNING_25306 25306
#define __WARNING_NOTHROW_FUNC_THROWS 25306
#define __WARNING_25307 25307
#define __WARNING_FUNC_COULD_BE_NOTHROW 25307
#define __WARNING_25308 25308
#define __WARNING_UNNECESSARY_TRY_CATCH 25308
#define __WARNING_25309 25309
#define __WARNING_NOTHROW_BLOCK_THROWS 25309
#define __WARNING_25310 25310
#define __WARNING_COM_METHOD_THROWS 25310
#define __WARNING_25311 25311
#define __WARNING_GENERATED_FUNC_THROWS 25311
#define __WARNING_25312 25312
#define __WARNING_NO_EHSC_SWITCH 25312
#define __WARNING_25313 25313
#define __WARNING_OACREXC_REQUIRES_OACRMODEL 25313

/* OACRMODEL */

#define __WARNING_25351 25351
#define __WARNING_HUNGARIAN_INFERRED 25351
#define __WARNING_25352 25352
#define __WARNING_MISSING_ANNOTATION 25352
#define __WARNING_25353 25353
#define __WARNING_OVERRIDE_AT_NON_VIRTUAL 25353
#define __WARNING_25354 25354
#define __WARNING_OVERRIDE_AT_STATIC 25354
#define __WARNING_25355 25355
#define __WARNING_OVERRIDE_AT_BASECLASS 25355
#define __WARNING_25356 25356
#define __WARNING_UNSUPPORTED_DEREF_VALUE 25356
#define __WARNING_25357 25357
#define __WARNING_PRE_ANNOTATION_AT_RETURNVALUE 25357
#define __WARNING_25358 25358
#define __WARNING_MISSING_NOTHROW_AT_DECL 25358
#define __WARNING_25359 25359
#define __WARNING_DEPRECATED_OVERRIDE 25359
#define __WARNING_25360 25360
#define __WARNING_OBSOLETE_OVERRIDE 25360
#define __WARNING_25361 25361
#define __WARNING_ILLEGAL_BOUND_AT_PARAM 25361
#define __WARNING_25362 25362
#define __WARNING_ILLEGAL_BOUND_AT_RETURN 25362
#define __WARNING_25363 25363
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_PARAM 25363
#define __WARNING_25364 25364
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_RETURN 25364
#define __WARNING_25365 25365
#define __WARNING_ILLEGAL_RANGE_AT_PARAM 25365
#define __WARNING_25366 25366
#define __WARNING_ILLEGAL_RANGE_AT_RETURN 25366
#define __WARNING_25367 25367
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_PARAM 25367
#define __WARNING_25368 25368
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_RETURN 25368
#define __WARNING_25369 25369
#define __WARNING_PARAM_UPPERBOUND_LT_LOWERBOUND 25369
#define __WARNING_25370 25370
#define __WARNING_RETURN_UPPERBOUND_LT_LOWERBOUND 25370
#define __WARNING_25371 25371
#define __WARNING_NO_ANNOTATIONS_AT_DECLARATION 25371
#define __WARNING_25372 25372
#define __WARNING_DECLSPEC_SAL_ANNOTATION 25372

/* espX */

#define __WARNING_26000 26000
#define __WARNING_BUFFER_OVERFLOW 26000
#define __WARNING_26001 26001
#define __WARNING_BUFFER_UNDERFLOW 26001
#define __WARNING_26002 26002
#define __WARNING_READ_UNTRACKED_BUFFER 26002
#define __WARNING_26003 26003
#define __WARNING_UNTRACKED_BUFFER 26003
#define __WARNING_26004 26004
#define __WARNING_UNINITIALIZED_POINTER 26004
#define __WARNING_26005 26005
#define __WARNING_ZEROLENGTHARRAY 26005
#define __WARNING_26006 26006
#define __WARNING_INCORRECT_ANNOTATION_STRING 26006
#define __WARNING_26007 26007
#define __WARNING_INCORRECT_ANNOTATION 26007
#define __WARNING_26009 26009
#define __WARNING_BUFFERACCESS 26009
#define __WARNING_26010 26010
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW 26010
#define __WARNING_26011 26011
#define __WARNING_POTENTIAL_BUFFER_UNDERFLOW 26011
#define __WARNING_26012 26012
#define __WARNING_UNTRACKED_BUFFER_BUT_UNANNOTATABLE 26012
#define __WARNING_26013 26013
#define __WARNING_COMPLEX_EXPR 26013
#define __WARNING_26014 26014
#define __WARNING_INCORRECT_VALIDATION 26014
#define __WARNING_26015 26015
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY 26015
#define __WARNING_26016 26016
#define __WARNING_BUFFER_OVERFLOW_NULL_TERMINATED 26016
#define __WARNING_26017 26017
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_MISC 26017
#define __WARNING_26018 26018
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED 26018
#define __WARNING_26019 26019
#define __WARNING_INCORRECT_VALIDATION2 26019

/* SALCheck */

#define __WARNING_26020 26020
#define __WARNING_INSANE_ANNOTATION 26020
#define __WARNING_26021 26021
#define __WARNING_ANNOTATION_MISMATCH_MISSING_FIRST 26021
#define __WARNING_26022 26022
#define __WARNING_ANNOTATION_MISMATCH_MISSING_SECOND 26022
#define __WARNING_26023 26023
#define __WARNING_ANNOTATION_MISMATCH 26023

/* espX */

#define __WARNING_26030 26030
#define __WARNING_POSTCONDITION_BUFFER_OVERFLOW 26030
#define __WARNING_26031 26031
#define __WARNING_POSTCONDITION_BUFFER_UNDERFLOW 26031
#define __WARNING_26035 26035
#define __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION 26035
#define __WARNING_26036 26036
#define __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION 26036
#define __WARNING_26037 26037
#define __WARNING_POTENTIAL_NULLTERMINATION_VIOLATION 26037
#define __WARNING_26040 26040
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW 26040
#define __WARNING_26041 26041
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_UNDERFLOW 26041
#define __WARNING_26044 26044
#define __WARNING_INCORRECT_VALIDATION_POSTCONDITION 26044
#define __WARNING_26045 26045
#define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION 26045
#define __WARNING_26050 26050
#define __WARNING_CHECKER_ASSERTION_FAILURE 26050
#define __WARNING_26051 26051
#define __WARNING_IRREDUCIBLE_CFG 26051
#define __WARNING_26052 26052
#define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL 26052
#define __WARNING_26053 26053
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_LOOP_DEPENDENT 26053
#define __WARNING_26060 26060
#define __WARNING_RANGE_PRECONDITION_VIOLATION 26060
#define __WARNING_26061 26061
#define __WARNING_RANGE_POSTCONDITION_VIOLATION 26061
#define __WARNING_26070 26070
#define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION 26070
#define __WARNING_26071 26071
#define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION 26071
#define __WARNING_26080 26080
#define __WARNING_VALIDATED_ACCESS 26080
#define __WARNING_26081 26081
#define __WARNING_USING_STRUCT_ANNOTATION 26081
#define __WARNING_26090 26090
#define __WARNING_SUSPICIOUS_FUNCTION_POINTER_CAST 26090

/* NullPtr */

#define __WARNING_26500 26500
#define __WARNING_NULL_DEREFERENCE 26500
#define __WARNING_26501 26501
#define __WARNING_NULL_DEREFERENCE_THIS 26501
#define __WARNING_26505 26505
#define __WARNING_NULL_DEREFERENCE_API 26505
#define __WARNING_26506 26506
#define __WARNING_NULL_DEREFERENCE_THIS_API 26506
#define __WARNING_26510 26510
#define __WARNING_INTERFACE_PRE_NULL 26510
#define __WARNING_26511 26511
#define __WARNING_INTERFACE_PRE_NOTNULL 26511
#define __WARNING_26512 26512
#define __WARNING_INTERFACE_PRE_NOTNULL_VAL 26512
#define __WARNING_26515 26515
#define __WARNING_INTERFACE_POST_NULL 26515
#define __WARNING_26516 26516
#define __WARNING_INTERFACE_POST_NULL_CTOR 26516
#define __WARNING_26517 26517
#define __WARNING_INTERFACE_POST_NOTNULL 26517
#define __WARNING_26518 26518
#define __WARNING_INTERFACE_POST_NOTNULL_CTOR 26518
#define __WARNING_26520 26520
#define __WARNING_TRUNCATED_PTR 26520

/* in */

#define __WARNING_26550 26550
#define __WARNING_ASSIGNMENT_TO_IN_PARAMETER 26550

/* EspOpal */

#define __WARNING_26599 26599
#define __WARNING_GENERIC_OPAL_DEFECT 26599

/* sqleye.native.escapinganddelimiting */

#define __WARNING_26600 26600
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND 26600
#define __WARNING_26601 26601
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND 26601
#define __WARNING_26602 26602
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND 26602
#define __WARNING_26604 26604
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_PRECONDITION 26604
#define __WARNING_26610 26610
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING 26610
#define __WARNING_26611 26611
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING 26611
#define __WARNING_26612 26612
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING 26612

/* sqleye.native.missingcommandsal */

#define __WARNING_26620 26620
#define __WARNING_SQLINJECTION_CXX_MISSING_COMMAND_SAL 26620

/* sqleye.native.missingconnectionstringsal */

#define __WARNING_26625 26625
#define __WARNING_SQLINJECTION_CXX_MISSING_CONNECTION_STRING_SAL 26625

/* sqleye.native.truncation */

#define __WARNING_26630 26630
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_COMMAND 26630
#define __WARNING_26635 26635
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_CONNECTION_STRING 26635

/* sqleye.native.escapinganddelimiting */

#define __WARNING_26660 26660
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_LOWER_CONFIDENCE 26660
#define __WARNING_26661 26661
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND_LOWER_CONFIDENCE 26661
#define __WARNING_26662 26662
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND_LOWER_CONFIDENCE 26662
#define __WARNING_26670 26670
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING_LOWER_CONFIDENCE 26670
#define __WARNING_26671 26671
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26671
#define __WARNING_26672 26672
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26672

/* Goldpft */

#define __WARNING_38001 38001
#define __WARNING_LOCALE_SENSITIVE_STRCMP 38001
#define __WARNING_38002 38002
#define __WARNING_LOCALE_SENSITIVE_COMPARESTRING 38002
#define __WARNING_38003 38003
#define __WARNING_SYSTEM_LOCALE_MISUSE 38003
#define __WARNING_38004 38004
#define __WARNING_DEPRECATED_LIBRARY 38004
#define __WARNING_38010 38010
#define __WARNING_CALLING_SETTHREADLOCALE 38010
#define __WARNING_38011 38011
#define __WARNING_OVERRIDING_LOCALE_SETTINGS_WITH_SETLOCALEINFO 38011
#define __WARNING_38020 38020
#define __WARNING_ANSI_APICALL 38020
#define __WARNING_38021 38021
#define __WARNING_W2A_BEST_FIT 38021
#define __WARNING_38022 38022
#define __WARNING_CLIPBOARD_ANSI 38022
#define __WARNING_38023 38023
#define __WARNING_ANSI_DATAFILE 38023
#define __WARNING_38030 38030
#define __WARNING_HARD_CODED_STRING_TO_UI_FN 38030
#define __WARNING_38031 38031
#define __WARNING_HARDCODED_FONT_INFO 38031
#define __WARNING_38032 38032
#define __WARNING_CONSOLE_OUTPUT_ISSUE 38032
#define __WARNING_38033 38033
#define __WARNING_FORMAT_MESSAGE_LANG 38033
#define __WARNING_38034 38034
#define __WARNING_CONCATENATED_RESOURCE_STRING 38034
#define __WARNING_38035 38035
#define __WARNING_LOCALIZABLE_STRING_FORMAT_ISSUE 38035
#define __WARNING_38036 38036
#define __WARNING_MESSAGEBOX_RTL 38036
#define __WARNING_38037 38037
#define __WARNING_BITMAP_OR_ANSI_FONT 38037
#define __WARNING_38038 38038
#define __WARNING_COMMANDLINK_SETNOTE 38038
#define __WARNING_38039 38039
#define __WARNING_SCREEN_COORDINATES_CONVERSION 38039
#define __WARNING_38041 38041
#define __WARNING_GETDATEFORMAT_WRAPPER 38041
#define __WARNING_38042 38042
#define __WARNING_GETDATEFORMAT_AUTOLAYOUT 38042
#define __WARNING_38043 38043
#define __WARNING_LAYOUT_BITMAPORIENTATIONPRESERVED 38043
#define __WARNING_38044 38044
#define __WARNING_LOC_METADATA_GENERATED_GOLDPFT 38044
#define __WARNING_38045 38045
#define __WARNING_NON_LOCFRIENDLY_STRING_FORMATTING 38045

/* sqleye.tsql.escapinganddelimiting */

#define __WARNING_80100 80100
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND 80100
#define __WARNING_80101 80101
#define __WARNING_SQLINJECTION_TSQL_DELIMITING_COMMAND 80101
#define __WARNING_80102 80102
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_AND_DELIMITING_COMMAND 80102
#define __WARNING_80103 80103
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER 80103
#define __WARNING_80104 80104
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_PRECONDITION 80104
#define __WARNING_80105 80105
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER_PRECONDITION 80105

/* sqleye.tsql */

#define __WARNING_80130 80130
#define __WARNING_SQLINJECTION_TSQL_TRUNCATION_COMMAND 80130
#define __WARNING_80131 80131
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_COMMAND_EXECUTION 80131
#define __WARNING_80140 80140
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_PASSED_TO_SP 80140
#define __WARNING_80141 80141
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_CALL_TO_SP 80141
#define __WARNING_80142 80142
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_ASSIGNED_TO_OUTPUT 80142
#define __WARNING_80143 80143
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_OUTPUT_ASSIGNMENT 80143

/* sqleye.managed.escapinganddelimiting */

#define __WARNING_80200 80200
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_COMMAND 80200
#define __WARNING_80201 80201
#define __WARNING_SQLINJECTION_MSIL_DELIMITING_COMMAND 80201
#define __WARNING_80202 80202
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_AND_DELIMITING_COMMAND 80202

#endif // OACR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\dbivport.h ===
/* dbivport.h

	Provides macros that enable greater portability between DBI versions.

	This file should be *copied* and included in driver distributions
	and #included into the source, after #include DBIXS.h

	New driver releases should include an updated copy of dbivport.h
	from the most recent DBI release.
*/

#ifndef DBI_VPORT_H
#define DBI_VPORT_H

#ifndef DBIh_SET_ERR_CHAR
/* Emulate DBIh_SET_ERR_CHAR
	Only uses the err_i, errstr and state parameters.
*/
#define DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method) \
        sv_setiv(DBIc_ERR(imp_xxh), err_i); \
        (state) ? (void)sv_setpv(DBIc_STATE(imp_xxh), state) : (void)SvOK_off(DBIc_STATE(imp_xxh)); \
        sv_setpv(DBIc_ERRSTR(imp_xxh), errstr)
#endif

#ifndef DBIcf_Executed
#define DBIcf_Executed    0x080000
#endif

#ifndef DBIc_TRACE_LEVEL_MASK
#define DBIc_TRACE_LEVEL_MASK   0x0000000F
#define DBIc_TRACE_FLAGS_MASK   0xFFFFFF00
#define DBIc_TRACE_SETTINGS(imp) (DBIc_DBISTATE(imp)->debug)
#define DBIc_TRACE_LEVEL(imp)   (DBIc_TRACE_SETTINGS(imp) & DBIc_TRACE_LEVEL_MASK)
#define DBIc_TRACE_FLAGS(imp)   (DBIc_TRACE_SETTINGS(imp) & DBIc_TRACE_FLAGS_MASK)
/* DBIc_TRACE_MATCHES - true if s1 'matches' s2  (c.f. trace_msg())
   DBIc_TRACE_MATCHES(foo, DBIc_TRACE_SETTINGS(imp))
*/
#define DBIc_TRACE_MATCHES(s1, s2)      \
        (  ((s1 & DBIc_TRACE_LEVEL_MASK) >= (s2 & DBIc_TRACE_LEVEL_MASK)) \
        || ((s1 & DBIc_TRACE_FLAGS_MASK)  & (s2 & DBIc_TRACE_FLAGS_MASK)) )
/* DBIc_TRACE - true if flags match & DBI level>=flaglevel, or if DBI level>level
   DBIc_TRACE(imp,         0, 0, 4) = if level >= 4
   DBIc_TRACE(imp, DBDtf_FOO, 2, 4) = if tracing DBDtf_FOO & level>=2 or level>=4
   DBIc_TRACE(imp, DBDtf_FOO, 2, 0) = as above but never trace just due to level
*/
#define DBIc_TRACE(imp, flags, flaglevel, level)        \
        (  (flags && (DBIc_TRACE_FLAGS(imp) & flags) && (DBIc_TRACE_LEVEL(imp) >= flaglevel)) \
        || (level && DBIc_TRACE_LEVEL(imp) >= level) )
#endif


#endif /* !DBI_VPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\dbd_xsh.h ===
/* @(#)$Id: dbd_xsh.h 2488 2006-02-07 22:24:43Z timbo $
 *
 * Copyright 2000-2002 Tim Bunce
 * Copyright 2002      Jonathan Leffler
 *
 * These prototypes are for dbdimp.c funcs used in the XS file.
 * These names are #defined to driver specific names by the
 * dbdimp.h file in the driver source.
 */

#ifndef DBI_DBD_XSH_H
#define DBI_DBD_XSH_H

void     dbd_init _((dbistate_t *dbistate));

int      dbd_discon_all _((SV *drh, imp_drh_t *imp_drh));
SV      *dbd_take_imp_data _((SV *h, imp_xxh_t *imp_xxh, void *foo));

/* Support for dbd_dr_data_sources and dbd_db_do added to Driver.xst in DBI v1.33 */
/* dbd_dr_data_sources: optional: defined by a driver that calls a C */
/* function to get the list of data sources */
AV	*dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);

int      dbd_db_login6 _((SV *dbh, imp_dbh_t *imp_dbh, char *dbname, char *uid, char *pwd, SV*attribs));
int      dbd_db_login  _((SV *dbh, imp_dbh_t *imp_dbh, char *dbname, char *uid, char *pwd)); /* deprecated */
/* Note: interface of dbd_db_do changed in v1.33 */
/* Old prototype: dbd_db_do _((SV *sv, char *statement)); */
/* dbd_db_do: optional: defined by a driver if the DBI default version is too slow */
int      dbd_db_do4 _((SV *dbh, imp_dbh_t *imp_dbh, char *statement, SV *params));
int      dbd_db_commit     _((SV *dbh, imp_dbh_t *imp_dbh));
int      dbd_db_rollback   _((SV *dbh, imp_dbh_t *imp_dbh));
int      dbd_db_disconnect _((SV *dbh, imp_dbh_t *imp_dbh));
void     dbd_db_destroy    _((SV *dbh, imp_dbh_t *imp_dbh));
int      dbd_db_STORE_attrib _((SV *dbh, imp_dbh_t *imp_dbh, SV *keysv, SV *valuesv));
SV      *dbd_db_FETCH_attrib _((SV *dbh, imp_dbh_t *imp_dbh, SV *keysv));
SV	*dbd_db_last_insert_id _((SV *dbh, imp_dbh_t *imp_dbh, SV *catalog, SV *schema, SV *table, SV *field, SV *attr));
AV      *dbd_db_data_sources _((SV *dbh, imp_dbh_t *imp_dbh, SV *attr));

int      dbd_st_prepare _((SV *sth, imp_sth_t *imp_sth, char *statement, SV *attribs));
int      dbd_st_rows    _((SV *sth, imp_sth_t *imp_sth));
int      dbd_st_execute _((SV *sth, imp_sth_t *imp_sth));
AV      *dbd_st_fetch   _((SV *sth, imp_sth_t *imp_sth));
int      dbd_st_finish3 _((SV *sth, imp_sth_t *imp_sth, int from_destroy));
int      dbd_st_finish  _((SV *sth, imp_sth_t *imp_sth)); /* deprecated */
void     dbd_st_destroy _((SV *sth, imp_sth_t *imp_sth));
int      dbd_st_blob_read _((SV *sth, imp_sth_t *imp_sth,
                int field, long offset, long len, SV *destrv, long destoffset));
int      dbd_st_STORE_attrib _((SV *sth, imp_sth_t *imp_sth, SV *keysv, SV *valuesv));
SV      *dbd_st_FETCH_attrib _((SV *sth, imp_sth_t *imp_sth, SV *keysv));
SV      *dbd_st_execute_for_fetch _((SV *sth, imp_sth_t *imp_sth, SV *fetch_tuple_sub, SV *tuple_status));

int      dbd_bind_ph  _((SV *sth, imp_sth_t *imp_sth,
                SV *param, SV *value, IV sql_type, SV *attribs,
				int is_inout, IV maxlen));

#endif /* end of dbd_xsh.h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\dbipport.h ===
#if 0
<<'SKIP';
#endif
/*
----------------------------------------------------------------------

    ppport.h -- Perl/Pollution/Portability Version 3.06_01

    Automatically created by Devel::PPPort running under
    perl 5.008008 on Wed Apr 26 01:39:44 2006.

    Do NOT edit this file directly! -- Edit PPPort_pm.PL and the
    includes in parts/inc/ instead.

    Use 'perldoc ppport.h' to view the documentation below.

----------------------------------------------------------------------

SKIP

=pod

=head1 NAME

ppport.h - Perl/Pollution/Portability version 3.06_01

=head1 SYNOPSIS

  perl ppport.h [options] [source files]

  Searches current directory for files if no [source files] are given

  --help                      show short help

  --patch=file                write one patch file with changes
  --copy=suffix               write changed copies with suffix
  --diff=program              use diff program and options

  --compat-version=version    provide compatibility with Perl version
  --cplusplus                 accept C++ comments

  --quiet                     don't output anything except fatal errors
  --nodiag                    don't show diagnostics
  --nohints                   don't show hints
  --nochanges                 don't suggest changes
  --nofilter                  don't filter input files

  --list-provided             list provided API
  --list-unsupported          list unsupported API
  --api-info=name             show Perl API portability information

=head1 COMPATIBILITY

This version of F<ppport.h> is designed to support operation with Perl
installations back to 5.003, and has been tested up to 5.9.3.

=head1 OPTIONS

=head2 --help

Display a brief usage summary.

=head2 --patch=I<file>

If this option is given, a single patch file will be created if
any changes are suggested. This requires a working diff program
to be installed on your system.

=head2 --copy=I<suffix>

If this option is given, a copy of each file will be saved with
the given suffix that contains the suggested changes. This does
not require any external programs.

If neither C<--patch> or C<--copy> are given, the default is to
simply print the diffs for each file. This requires either
C<Text::Diff> or a C<diff> program to be installed.

=head2 --diff=I<program>

Manually set the diff program and options to use. The default
is to use C<Text::Diff>, when installed, and output unified
context diffs.

=head2 --compat-version=I<version>

Tell F<ppport.h> to check for compatibility with the given
Perl version. The default is to check for compatibility with Perl
version 5.003. You can use this option to reduce the output
of F<ppport.h> if you intend to be backward compatible only
up to a certain Perl version.

=head2 --cplusplus

Usually, F<ppport.h> will detect C++ style comments and
replace them with C style comments for portability reasons.
Using this option instructs F<ppport.h> to leave C++
comments untouched.

=head2 --quiet

Be quiet. Don't print anything except fatal errors.

=head2 --nodiag

Don't output any diagnostic messages. Only portability
alerts will be printed.

=head2 --nohints

Don't output any hints. Hints often contain useful portability
notes.

=head2 --nochanges

Don't suggest any changes. Only give diagnostic output and hints
unless these are also deactivated.

=head2 --nofilter

Don't filter the list of input files. By default, files not looking
like source code (i.e. not *.xs, *.c, *.cc, *.cpp or *.h) are skipped.

=head2 --list-provided

Lists the API elements for which compatibility is provided by
F<ppport.h>. Also lists if it must be explicitly requested,
if it has dependencies, and if there are hints for it.

=head2 --list-unsupported

Lists the API elements that are known not to be supported by
F<ppport.h> and below which version of Perl they probably
won't be available or work.

=head2 --api-info=I<name>

Show portability information for API elements matching I<name>.
If I<name> is surrounded by slashes, it is interpreted as a regular
expression.

=head1 DESCRIPTION

In order for a Perl extension (XS) module to be as portable as possible
across differing versions of Perl itself, certain steps need to be taken.

=over 4

=item *

Including this header is the first major one. This alone will give you
access to a large part of the Perl API that hasn't been available in
earlier Perl releases. Use

    perl ppport.h --list-provided

to see which API elements are provided by ppport.h.

=item *

You should avoid using deprecated parts of the API. For example, using
global Perl variables without the C<PL_> prefix is deprecated. Also,
some API functions used to have a C<perl_> prefix. Using this form is
also deprecated. You can safely use the supported API, as F<ppport.h>
will provide wrappers for older Perl versions.

=item *

If you use one of a few functions that were not present in earlier
versions of Perl, and that can't be provided using a macro, you have
to explicitly request support for these functions by adding one or
more C<#define>s in your source code before the inclusion of F<ppport.h>.

These functions will be marked C<explicit> in the list shown by
C<--list-provided>.

Depending on whether you module has a single or multiple files that
use such functions, you want either C<static> or global variants.

For a C<static> function, use:

    #define NEED_function

For a global function, use:

    #define NEED_function_GLOBAL

Note that you mustn't have more than one global request for one
function in your project.

    Function                  Static Request               Global Request
    -----------------------------------------------------------------------------------------
    eval_pv()                 NEED_eval_pv                 NEED_eval_pv_GLOBAL
    grok_bin()                NEED_grok_bin                NEED_grok_bin_GLOBAL
    grok_hex()                NEED_grok_hex                NEED_grok_hex_GLOBAL
    grok_number()             NEED_grok_number             NEED_grok_number_GLOBAL
    grok_numeric_radix()      NEED_grok_numeric_radix      NEED_grok_numeric_radix_GLOBAL
    grok_oct()                NEED_grok_oct                NEED_grok_oct_GLOBAL
    newCONSTSUB()             NEED_newCONSTSUB             NEED_newCONSTSUB_GLOBAL
    newRV_noinc()             NEED_newRV_noinc             NEED_newRV_noinc_GLOBAL
    sv_2pv_nolen()            NEED_sv_2pv_nolen            NEED_sv_2pv_nolen_GLOBAL
    sv_2pvbyte()              NEED_sv_2pvbyte              NEED_sv_2pvbyte_GLOBAL
    sv_catpvf_mg()            NEED_sv_catpvf_mg            NEED_sv_catpvf_mg_GLOBAL
    sv_catpvf_mg_nocontext()  NEED_sv_catpvf_mg_nocontext  NEED_sv_catpvf_mg_nocontext_GLOBAL
    sv_setpvf_mg()            NEED_sv_setpvf_mg            NEED_sv_setpvf_mg_GLOBAL
    sv_setpvf_mg_nocontext()  NEED_sv_setpvf_mg_nocontext  NEED_sv_setpvf_mg_nocontext_GLOBAL
    vnewSVpvf()               NEED_vnewSVpvf               NEED_vnewSVpvf_GLOBAL

To avoid namespace conflicts, you can change the namespace of the
explicitly exported functions using the C<DPPP_NAMESPACE> macro.
Just C<#define> the macro before including C<ppport.h>:

    #define DPPP_NAMESPACE MyOwnNamespace_
    #include "ppport.h"

The default namespace is C<DPPP_>.

=back

The good thing is that most of the above can be checked by running
F<ppport.h> on your source code. See the next section for
details.

=head1 EXAMPLES

To verify whether F<ppport.h> is needed for your module, whether you
should make any changes to your code, and whether any special defines
should be used, F<ppport.h> can be run as a Perl script to check your
source code. Simply say:

    perl ppport.h

The result will usually be a list of patches suggesting changes
that should at least be acceptable, if not necessarily the most
efficient solution, or a fix for all possible problems.

If you know that your XS module uses features only available in
newer Perl releases, if you're aware that it uses C++ comments,
and if you want all suggestions as a single patch file, you could
use something like this:

    perl ppport.h --compat-version=5.6.0 --cplusplus --patch=test.diff

If you only want your code to be scanned without any suggestions
for changes, use:

    perl ppport.h --nochanges

You can specify a different C<diff> program or options, using
the C<--diff> option:

    perl ppport.h --diff='diff -C 10'

This would output context diffs with 10 lines of context.

To display portability information for the C<newSVpvn> function,
use:

    perl ppport.h --api-info=newSVpvn

Since the argument to C<--api-info> can be a regular expression,
you can use

    perl ppport.h --api-info=/_nomg$/

to display portability information for all C<_nomg> functions or

    perl ppport.h --api-info=/./

to display information for all known API elements.

=head1 BUGS

If this version of F<ppport.h> is causing failure during
the compilation of this module, please check if newer versions
of either this module or C<Devel::PPPort> are available on CPAN
before sending a bug report.

If F<ppport.h> was generated using the latest version of
C<Devel::PPPort> and is causing failure of this module, please
file a bug report using the CPAN Request Tracker at L<http://rt.cpan.org/>.

Please include the following information:

=over 4

=item 1.

The complete output from running "perl -V"

=item 2.

This file.

=item 3.

The name and version of the module you were trying to build.

=item 4.

A full log of the build that failed.

=item 5.

Any other information that you think could be relevant.

=back

For the latest version of this code, please get the C<Devel::PPPort>
module from CPAN.

=head1 COPYRIGHT

Version 3.x, Copyright (c) 2004-2005, Marcus Holland-Moritz.

Version 2.x, Copyright (C) 2001, Paul Marquess.

Version 1.x, Copyright (C) 1999, Kenneth Albanowski.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 SEE ALSO

See L<Devel::PPPort>.

=cut

use strict;

my %opt = (
  quiet     => 0,
  diag      => 1,
  hints     => 1,
  changes   => 1,
  cplusplus => 0,
  filter    => 1,
);

my($ppport) = $0 =~ /([\w.]+)$/;
my $LF = '(?:\r\n|[\r\n])';   # line feed
my $HS = "[ \t]";             # horizontal whitespace

eval {
  require Getopt::Long;
  Getopt::Long::GetOptions(\%opt, qw(
    help quiet diag! filter! hints! changes! cplusplus
    patch=s copy=s diff=s compat-version=s
    list-provided list-unsupported api-info=s
  )) or usage();
};

if ($@ and grep /^-/, @ARGV) {
  usage() if "@ARGV" =~ /^--?h(?:elp)?$/;
  die "Getopt::Long not found. Please don't use any options.\n";
}

usage() if $opt{help};

if (exists $opt{'compat-version'}) {
  my($r,$v,$s) = eval { parse_version($opt{'compat-version'}) };
  if ($@) {
    die "Invalid version number format: '$opt{'compat-version'}'\n";
  }
  die "Only Perl 5 is supported\n" if $r != 5;
  die "Invalid version number: $opt{'compat-version'}\n" if $v >= 1000 || $s >= 1000;
  $opt{'compat-version'} = sprintf "%d.%03d%03d", $r, $v, $s;
}
else {
  $opt{'compat-version'} = 5;
}

# Never use C comments in this file!!!!!
my $ccs  = '/'.'*';
my $cce  = '*'.'/';
my $rccs = quotemeta $ccs;
my $rcce = quotemeta $cce;

my %API = map { /^(\w+)\|([^|]*)\|([^|]*)\|(\w*)$/
                ? ( $1 => {
                      ($2                  ? ( base     => $2 ) : ()),
                      ($3                  ? ( todo     => $3 ) : ()),
                      (index($4, 'v') >= 0 ? ( varargs  => 1  ) : ()),
                      (index($4, 'p') >= 0 ? ( provided => 1  ) : ()),
                      (index($4, 'n') >= 0 ? ( nothxarg => 1  ) : ()),
                    } )
                : die "invalid spec: $_" } qw(
AvFILLp|5.004050||p
AvFILL|||
CLASS|||n
CX_CURPAD_SAVE|||
CX_CURPAD_SV|||
CopFILEAV|5.006000||p
CopFILEGV_set|5.006000||p
CopFILEGV|5.006000||p
CopFILESV|5.006000||p
CopFILE_set|5.006000||p
CopFILE|5.006000||p
CopSTASHPV_set|5.006000||p
CopSTASHPV|5.006000||p
CopSTASH_eq|5.006000||p
CopSTASH_set|5.006000||p
CopSTASH|5.006000||p
CopyD|5.009002||p
Copy|||
CvPADLIST|||
CvSTASH|||
CvWEAKOUTSIDE|||
DEFSV|5.004050||p
END_EXTERN_C|5.005000||p
ENTER|||
ERRSV|5.004050||p
EXTEND|||
EXTERN_C|5.005000||p
FREETMPS|||
GIMME_V||5.004000|n
GIMME|||n
GROK_NUMERIC_RADIX|5.007002||p
G_ARRAY|||
G_DISCARD|||
G_EVAL|||
G_NOARGS|||
G_SCALAR|||
G_VOID||5.004000|
GetVars|||
GvSV|||
Gv_AMupdate|||
HEf_SVKEY||5.004000|
HeHASH||5.004000|
HeKEY||5.004000|
HeKLEN||5.004000|
HePV||5.004000|
HeSVKEY_force||5.004000|
HeSVKEY_set||5.004000|
HeSVKEY||5.004000|
HeVAL||5.004000|
HvNAME|||
INT2PTR|5.006000||p
IN_LOCALE_COMPILETIME|5.007002||p
IN_LOCALE_RUNTIME|5.007002||p
IN_LOCALE|5.007002||p
IN_PERL_COMPILETIME|5.008001||p
IS_NUMBER_GREATER_THAN_UV_MAX|5.007002||p
IS_NUMBER_INFINITY|5.007002||p
IS_NUMBER_IN_UV|5.007002||p
IS_NUMBER_NAN|5.007003||p
IS_NUMBER_NEG|5.007002||p
IS_NUMBER_NOT_INT|5.007002||p
IVSIZE|5.006000||p
IVTYPE|5.006000||p
IVdf|5.006000||p
LEAVE|||
LVRET|||
MARK|||
MY_CXT_CLONE|5.009002||p
MY_CXT_INIT|5.007003||p
MY_CXT|5.007003||p
MoveD|5.009002||p
Move|||
NEWSV|||
NOOP|5.005000||p
NUM2PTR|5.006000||p
NVTYPE|5.006000||p
NVef|5.006001||p
NVff|5.006001||p
NVgf|5.006001||p
Newc|||
Newz|||
New|||
Nullav|||
Nullch|||
Nullcv|||
Nullhv|||
Nullsv|||
ORIGMARK|||
PAD_BASE_SV|||
PAD_CLONE_VARS|||
PAD_COMPNAME_FLAGS|||
PAD_COMPNAME_GEN_set|||
PAD_COMPNAME_GEN|||
PAD_COMPNAME_OURSTASH|||
PAD_COMPNAME_PV|||
PAD_COMPNAME_TYPE|||
PAD_RESTORE_LOCAL|||
PAD_SAVE_LOCAL|||
PAD_SAVE_SETNULLPAD|||
PAD_SETSV|||
PAD_SET_CUR_NOSAVE|||
PAD_SET_CUR|||
PAD_SVl|||
PAD_SV|||
PERL_BCDVERSION|5.009003||p
PERL_GCC_BRACE_GROUPS_FORBIDDEN|5.008001||p
PERL_INT_MAX|5.004000||p
PERL_INT_MIN|5.004000||p
PERL_LONG_MAX|5.004000||p
PERL_LONG_MIN|5.004000||p
PERL_MAGIC_arylen|5.007002||p
PERL_MAGIC_backref|5.007002||p
PERL_MAGIC_bm|5.007002||p
PERL_MAGIC_collxfrm|5.007002||p
PERL_MAGIC_dbfile|5.007002||p
PERL_MAGIC_dbline|5.007002||p
PERL_MAGIC_defelem|5.007002||p
PERL_MAGIC_envelem|5.007002||p
PERL_MAGIC_env|5.007002||p
PERL_MAGIC_ext|5.007002||p
PERL_MAGIC_fm|5.007002||p
PERL_MAGIC_glob|5.007002||p
PERL_MAGIC_isaelem|5.007002||p
PERL_MAGIC_isa|5.007002||p
PERL_MAGIC_mutex|5.007002||p
PERL_MAGIC_nkeys|5.007002||p
PERL_MAGIC_overload_elem|5.007002||p
PERL_MAGIC_overload_table|5.007002||p
PERL_MAGIC_overload|5.007002||p
PERL_MAGIC_pos|5.007002||p
PERL_MAGIC_qr|5.007002||p
PERL_MAGIC_regdata|5.007002||p
PERL_MAGIC_regdatum|5.007002||p
PERL_MAGIC_regex_global|5.007002||p
PERL_MAGIC_shared_scalar|5.007003||p
PERL_MAGIC_shared|5.007003||p
PERL_MAGIC_sigelem|5.007002||p
PERL_MAGIC_sig|5.007002||p
PERL_MAGIC_substr|5.007002||p
PERL_MAGIC_sv|5.007002||p
PERL_MAGIC_taint|5.007002||p
PERL_MAGIC_tiedelem|5.007002||p
PERL_MAGIC_tiedscalar|5.007002||p
PERL_MAGIC_tied|5.007002||p
PERL_MAGIC_utf8|5.008001||p
PERL_MAGIC_uvar_elem|5.007003||p
PERL_MAGIC_uvar|5.007002||p
PERL_MAGIC_vec|5.007002||p
PERL_MAGIC_vstring|5.008001||p
PERL_QUAD_MAX|5.004000||p
PERL_QUAD_MIN|5.004000||p
PERL_REVISION|5.006000||p
PERL_SCAN_ALLOW_UNDERSCORES|5.007003||p
PERL_SCAN_DISALLOW_PREFIX|5.007003||p
PERL_SCAN_GREATER_THAN_UV_MAX|5.007003||p
PERL_SCAN_SILENT_ILLDIGIT|5.008001||p
PERL_SHORT_MAX|5.004000||p
PERL_SHORT_MIN|5.004000||p
PERL_SUBVERSION|5.006000||p
PERL_UCHAR_MAX|5.004000||p
PERL_UCHAR_MIN|5.004000||p
PERL_UINT_MAX|5.004000||p
PERL_UINT_MIN|5.004000||p
PERL_ULONG_MAX|5.004000||p
PERL_ULONG_MIN|5.004000||p
PERL_UNUSED_DECL|5.007002||p
PERL_UQUAD_MAX|5.004000||p
PERL_UQUAD_MIN|5.004000||p
PERL_USHORT_MAX|5.004000||p
PERL_USHORT_MIN|5.004000||p
PERL_VERSION|5.006000||p
PL_DBsingle|||pn
PL_DBsub|||pn
PL_DBtrace|||n
PL_Sv|5.005000||p
PL_compiling|5.004050||p
PL_copline|5.005000||p
PL_curcop|5.004050||p
PL_curstash|5.004050||p
PL_debstash|5.004050||p
PL_defgv|5.004050||p
PL_diehook|5.004050||p
PL_dirty|5.004050||p
PL_dowarn|||pn
PL_errgv|5.004050||p
PL_hexdigit|5.005000||p
PL_hints|5.005000||p
PL_last_in_gv|||n
PL_modglobal||5.005000|n
PL_na|5.004050||pn
PL_no_modify|5.006000||p
PL_ofs_sv|||n
PL_perl_destruct_level|5.004050||p
PL_perldb|5.004050||p
PL_ppaddr|5.006000||p
PL_rsfp_filters|5.004050||p
PL_rsfp|5.004050||p
PL_rs|||n
PL_stack_base|5.004050||p
PL_stack_sp|5.004050||p
PL_stdingv|5.004050||p
PL_sv_arenaroot|5.004050||p
PL_sv_no|5.004050||pn
PL_sv_undef|5.004050||pn
PL_sv_yes|5.004050||pn
PL_tainted|5.004050||p
PL_tainting|5.004050||p
POPi|||n
POPl|||n
POPn|||n
POPpbytex||5.007001|n
POPpx||5.005030|n
POPp|||n
POPs|||n
PTR2IV|5.006000||p
PTR2NV|5.006000||p
PTR2UV|5.006000||p
PTR2ul|5.007001||p
PTRV|5.006000||p
PUSHMARK|||
PUSHi|||
PUSHmortal|5.009002||p
PUSHn|||
PUSHp|||
PUSHs|||
PUSHu|5.004000||p
PUTBACK|||
PerlIO_clearerr||5.007003|
PerlIO_close||5.007003|
PerlIO_eof||5.007003|
PerlIO_error||5.007003|
PerlIO_fileno||5.007003|
PerlIO_fill||5.007003|
PerlIO_flush||5.007003|
PerlIO_get_base||5.007003|
PerlIO_get_bufsiz||5.007003|
PerlIO_get_cnt||5.007003|
PerlIO_get_ptr||5.007003|
PerlIO_read||5.007003|
PerlIO_seek||5.007003|
PerlIO_set_cnt||5.007003|
PerlIO_set_ptrcnt||5.007003|
PerlIO_setlinebuf||5.007003|
PerlIO_stderr||5.007003|
PerlIO_stdin||5.007003|
PerlIO_stdout||5.007003|
PerlIO_tell||5.007003|
PerlIO_unread||5.007003|
PerlIO_write||5.007003|
Poison|5.008000||p
RETVAL|||n
Renewc|||
Renew|||
SAVECLEARSV|||
SAVECOMPPAD|||
SAVEPADSV|||
SAVETMPS|||
SAVE_DEFSV|5.004050||p
SPAGAIN|||
SP|||
START_EXTERN_C|5.005000||p
START_MY_CXT|5.007003||p
STMT_END|||p
STMT_START|||p
ST|||
SVt_IV|||
SVt_NV|||
SVt_PVAV|||
SVt_PVCV|||
SVt_PVHV|||
SVt_PVMG|||
SVt_PV|||
Safefree|||
Slab_Alloc|||
Slab_Free|||
StructCopy|||
SvCUR_set|||
SvCUR|||
SvEND|||
SvGETMAGIC|5.004050||p
SvGROW|||
SvIOK_UV||5.006000|
SvIOK_notUV||5.006000|
SvIOK_off|||
SvIOK_only_UV||5.006000|
SvIOK_only|||
SvIOK_on|||
SvIOKp|||
SvIOK|||
SvIVX|||
SvIV_nomg|5.009001||p
SvIV_set|||
SvIVx|||
SvIV|||
SvIsCOW_shared_hash||5.008003|
SvIsCOW||5.008003|
SvLEN_set|||
SvLEN|||
SvLOCK||5.007003|
SvMAGIC_set||5.009003|
SvNIOK_off|||
SvNIOKp|||
SvNIOK|||
SvNOK_off|||
SvNOK_only|||
SvNOK_on|||
SvNOKp|||
SvNOK|||
SvNVX|||
SvNV_set|||
SvNVx|||
SvNV|||
SvOK|||
SvOOK|||
SvPOK_off|||
SvPOK_only_UTF8||5.006000|
SvPOK_only|||
SvPOK_on|||
SvPOKp|||
SvPOK|||
SvPVX|||
SvPV_force_nomg|5.007002||p
SvPV_force|||
SvPV_nolen|5.006000||p
SvPV_nomg|5.007002||p
SvPV_set|||
SvPVbyte_force||5.009002|
SvPVbyte_nolen||5.006000|
SvPVbytex_force||5.006000|
SvPVbytex||5.006000|
SvPVbyte|5.006000||p
SvPVutf8_force||5.006000|
SvPVutf8_nolen||5.006000|
SvPVutf8x_force||5.006000|
SvPVutf8x||5.006000|
SvPVutf8||5.006000|
SvPVx|||
SvPV|||
SvREFCNT_dec|||
SvREFCNT_inc|||
SvREFCNT|||
SvROK_off|||
SvROK_on|||
SvROK|||
SvRV_set||5.009003|
SvRV|||
SvSETMAGIC|||
SvSHARE||5.007003|
SvSTASH_set||5.009003|
SvSTASH|||
SvSetMagicSV_nosteal||5.004000|
SvSetMagicSV||5.004000|
SvSetSV_nosteal||5.004000|
SvSetSV|||
SvTAINTED_off||5.004000|
SvTAINTED_on||5.004000|
SvTAINTED||5.004000|
SvTAINT|||
SvTRUE|||
SvTYPE|||
SvUNLOCK||5.007003|
SvUOK||5.007001|
SvUPGRADE|||
SvUTF8_off||5.006000|
SvUTF8_on||5.006000|
SvUTF8||5.006000|
SvUVXx|5.004000||p
SvUVX|5.004000||p
SvUV_nomg|5.009001||p
SvUV_set||5.009003|
SvUVx|5.004000||p
SvUV|5.004000||p
SvVOK||5.008001|
THIS|||n
UNDERBAR|5.009002||p
UVSIZE|5.006000||p
UVTYPE|5.006000||p
UVXf|5.007001||p
UVof|5.006000||p
UVuf|5.006000||p
UVxf|5.006000||p
XCPT_CATCH|5.009002||p
XCPT_RETHROW|5.009002||p
XCPT_TRY_END|5.009002||p
XCPT_TRY_START|5.009002||p
XPUSHi|||
XPUSHmortal|5.009002||p
XPUSHn|||
XPUSHp|||
XPUSHs|||
XPUSHu|5.004000||p
XSRETURN_EMPTY|||
XSRETURN_IV|||
XSRETURN_NO|||
XSRETURN_NV|||
XSRETURN_PV|||
XSRETURN_UNDEF|||
XSRETURN_UV|5.008001||p
XSRETURN_YES|||
XSRETURN|||
XST_mIV|||
XST_mNO|||
XST_mNV|||
XST_mPV|||
XST_mUNDEF|||
XST_mUV|5.008001||p
XST_mYES|||
XS_VERSION_BOOTCHECK|||
XS_VERSION|||
XS|||
ZeroD|5.009002||p
Zero|||
_aMY_CXT|5.007003||p
_pMY_CXT|5.007003||p
aMY_CXT_|5.007003||p
aMY_CXT|5.007003||p
aTHX_|5.006000||p
aTHX|5.006000||p
add_data|||
allocmy|||
amagic_call|||
any_dup|||
ao|||
append_elem|||
append_list|||
apply_attrs_my|||
apply_attrs_string||5.006001|
apply_attrs|||
apply|||
asIV|||
asUV|||
atfork_lock||5.007003|n
atfork_unlock||5.007003|n
av_arylen_p||5.009003|
av_clear|||
av_delete||5.006000|
av_exists||5.006000|
av_extend|||
av_fake|||
av_fetch|||
av_fill|||
av_len|||
av_make|||
av_pop|||
av_push|||
av_reify|||
av_shift|||
av_store|||
av_undef|||
av_unshift|||
ax|||n
bad_type|||
bind_match|||
block_end|||
block_gimme||5.004000|
block_start|||
boolSV|5.004000||p
boot_core_PerlIO|||
boot_core_UNIVERSAL|||
boot_core_xsutils|||
bytes_from_utf8||5.007001|
bytes_to_utf8||5.006001|
cache_re|||
call_argv|5.006000||p
call_atexit||5.006000|
call_body|||
call_list_body|||
call_list||5.004000|
call_method|5.006000||p
call_pv|5.006000||p
call_sv|5.006000||p
calloc||5.007002|n
cando|||
cast_i32||5.006000|
cast_iv||5.006000|
cast_ulong||5.006000|
cast_uv||5.006000|
check_uni|||
checkcomma|||
checkposixcc|||
ck_anoncode|||
ck_bitop|||
ck_concat|||
ck_defined|||
ck_delete|||
ck_die|||
ck_eof|||
ck_eval|||
ck_exec|||
ck_exists|||
ck_exit|||
ck_ftst|||
ck_fun|||
ck_glob|||
ck_grep|||
ck_index|||
ck_join|||
ck_lengthconst|||
ck_lfun|||
ck_listiob|||
ck_match|||
ck_method|||
ck_null|||
ck_open|||
ck_repeat|||
ck_require|||
ck_retarget|||
ck_return|||
ck_rfun|||
ck_rvconst|||
ck_sassign|||
ck_select|||
ck_shift|||
ck_sort|||
ck_spair|||
ck_split|||
ck_subr|||
ck_substr|||
ck_svconst|||
ck_trunc|||
ck_unpack|||
cl_and|||
cl_anything|||
cl_init_zero|||
cl_init|||
cl_is_anything|||
cl_or|||
closest_cop|||
convert|||
cop_free|||
cr_textfilter|||
croak_nocontext|||vn
croak|||v
csighandler||5.007001|n
custom_op_desc||5.007003|
custom_op_name||5.007003|
cv_ckproto|||
cv_clone|||
cv_const_sv||5.004000|
cv_dump|||
cv_undef|||
cx_dump||5.005000|
cx_dup|||
cxinc|||
dAXMARK||5.009003|
dAX|5.007002||p
dITEMS|5.007002||p
dMARK|||
dMY_CXT_SV|5.007003||p
dMY_CXT|5.007003||p
dNOOP|5.006000||p
dORIGMARK|||
dSP|||
dTHR|5.004050||p
dTHXa|5.006000||p
dTHXoa|5.006000||p
dTHX|5.006000||p
dUNDERBAR|5.009002||p
dXCPT|5.009002||p
dXSARGS|||
dXSI32|||
dXSTARG|5.006000||p
deb_curcv|||
deb_nocontext|||vn
deb_stack_all|||
deb_stack_n|||
debop||5.005000|
debprofdump||5.005000|
debprof|||
debstackptrs||5.007003|
debstack||5.007003|
deb||5.007003|v
del_he|||
del_sv|||
delimcpy||5.004000|
depcom|||
deprecate_old|||
deprecate|||
despatch_signals||5.007001|
die_nocontext|||vn
die_where|||
die|||v
dirp_dup|||
div128|||
djSP|||
do_aexec5|||
do_aexec|||
do_aspawn|||
do_binmode||5.004050|
do_chomp|||
do_chop|||
do_close|||
do_dump_pad|||
do_eof|||
do_exec3|||
do_execfree|||
do_exec|||
do_gv_dump||5.006000|
do_gvgv_dump||5.006000|
do_hv_dump||5.006000|
do_ipcctl|||
do_ipcget|||
do_join|||
do_kv|||
do_magic_dump||5.006000|
do_msgrcv|||
do_msgsnd|||
do_oddball|||
do_op_dump||5.006000|
do_open9||5.006000|
do_openn||5.007001|
do_open||5.004000|
do_pipe|||
do_pmop_dump||5.006000|
do_print|||
do_readline|||
do_seek|||
do_semop|||
do_shmio|||
do_spawn_nowait|||
do_spawn|||
do_sprintf|||
do_sv_dump||5.006000|
do_sysseek|||
do_tell|||
do_trans_complex_utf8|||
do_trans_complex|||
do_trans_count_utf8|||
do_trans_count|||
do_trans_simple_utf8|||
do_trans_simple|||
do_trans|||
do_vecget|||
do_vecset|||
do_vop|||
docatch_body|||
docatch|||
doeval|||
dofile|||
dofindlabel|||
doform|||
doing_taint||5.008001|n
dooneliner|||
doopen_pm|||
doparseform|||
dopoptoeval|||
dopoptolabel|||
dopoptoloop|||
dopoptosub_at|||
dopoptosub|||
dounwind|||
dowantarray|||
dump_all||5.006000|
dump_eval||5.006000|
dump_fds|||
dump_form||5.006000|
dump_indent||5.006000|v
dump_mstats|||
dump_packsubs||5.006000|
dump_sub||5.006000|
dump_vindent||5.006000|
dumpuntil|||
dup_attrlist|||
emulate_eaccess|||
eval_pv|5.006000||p
eval_sv|5.006000||p
expect_number|||
fbm_compile||5.005000|
fbm_instr||5.005000|
fd_on_nosuid_fs|||
filter_add|||
filter_del|||
filter_gets|||
filter_read|||
find_beginning|||
find_byclass|||
find_in_my_stash|||
find_runcv|||
find_rundefsvoffset||5.009002|
find_script|||
find_uninit_var|||
fold_constants|||
forbid_setid|||
force_ident|||
force_list|||
force_next|||
force_version|||
force_word|||
form_nocontext|||vn
form||5.004000|v
fp_dup|||
fprintf_nocontext|||vn
free_global_struct|||
free_tied_hv_pool|||
free_tmps|||
gen_constant_list|||
get_av|5.006000||p
get_context||5.006000|n
get_cv|5.006000||p
get_db_sub|||
get_debug_opts|||
get_hash_seed|||
get_hv|5.006000||p
get_mstats|||
get_no_modify|||
get_num|||
get_op_descs||5.005000|
get_op_names||5.005000|
get_opargs|||
get_ppaddr||5.006000|
get_sv|5.006000||p
get_vtbl||5.005030|
getcwd_sv||5.007002|
getenv_len|||
gp_dup|||
gp_free|||
gp_ref|||
grok_bin|5.007003||p
grok_hex|5.007003||p
grok_number|5.007002||p
grok_numeric_radix|5.007002||p
grok_oct|5.007003||p
group_end|||
gv_AVadd|||
gv_HVadd|||
gv_IOadd|||
gv_autoload4||5.004000|
gv_check|||
gv_dump||5.006000|
gv_efullname3||5.004000|
gv_efullname4||5.006001|
gv_efullname|||
gv_ename|||
gv_fetchfile|||
gv_fetchmeth_autoload||5.007003|
gv_fetchmethod_autoload||5.004000|
gv_fetchmethod|||
gv_fetchmeth|||
gv_fetchpvn_flags||5.009002|
gv_fetchpv|||
gv_fetchsv||5.009002|
gv_fullname3||5.004000|
gv_fullname4||5.006001|
gv_fullname|||
gv_handler||5.007001|
gv_init_sv|||
gv_init|||
gv_share|||
gv_stashpvn|5.006000||p
gv_stashpv|||
gv_stashsv|||
he_dup|||
hek_dup|||
hfreeentries|||
hsplit|||
hv_assert||5.009001|
hv_auxinit|||
hv_clear_placeholders||5.009001|
hv_clear|||
hv_delayfree_ent||5.004000|
hv_delete_common|||
hv_delete_ent||5.004000|
hv_delete|||
hv_eiter_p||5.009003|
hv_eiter_set||5.009003|
hv_exists_ent||5.004000|
hv_exists|||
hv_fetch_common|||
hv_fetch_ent||5.004000|
hv_fetch|||
hv_free_ent||5.004000|
hv_iterinit|||
hv_iterkeysv||5.004000|
hv_iterkey|||
hv_iternext_flags||5.008000|
hv_iternextsv|||
hv_iternext|||
hv_iterval|||
hv_ksplit||5.004000|
hv_magic_check|||
hv_magic|||
hv_name_set||5.009003|
hv_notallowed|||
hv_placeholders_get||5.009003|
hv_placeholders_p||5.009003|
hv_placeholders_set||5.009003|
hv_riter_p||5.009003|
hv_riter_set||5.009003|
hv_scalar||5.009001|
hv_store_ent||5.004000|
hv_store_flags||5.008000|
hv_store|||
hv_undef|||
ibcmp_locale||5.004000|
ibcmp_utf8||5.007003|
ibcmp|||
incl_perldb|||
incline|||
incpush|||
ingroup|||
init_argv_symbols|||
init_debugger|||
init_global_struct|||
init_i18nl10n||5.006000|
init_i18nl14n||5.006000|
init_ids|||
init_interp|||
init_lexer|||
init_main_stash|||
init_perllib|||
init_postdump_symbols|||
init_predump_symbols|||
init_stacks||5.005000|
init_tm||5.007002|
instr|||
intro_my|||
intuit_method|||
intuit_more|||
invert|||
io_close|||
isALNUM|||
isALPHA|||
isDIGIT|||
isLOWER|||
isSPACE|||
isUPPER|||
is_an_int|||
is_gv_magical_sv|||
is_gv_magical|||
is_handle_constructor|||
is_list_assignment|||
is_lvalue_sub||5.007001|
is_uni_alnum_lc||5.006000|
is_uni_alnumc_lc||5.006000|
is_uni_alnumc||5.006000|
is_uni_alnum||5.006000|
is_uni_alpha_lc||5.006000|
is_uni_alpha||5.006000|
is_uni_ascii_lc||5.006000|
is_uni_ascii||5.006000|
is_uni_cntrl_lc||5.006000|
is_uni_cntrl||5.006000|
is_uni_digit_lc||5.006000|
is_uni_digit||5.006000|
is_uni_graph_lc||5.006000|
is_uni_graph||5.006000|
is_uni_idfirst_lc||5.006000|
is_uni_idfirst||5.006000|
is_uni_lower_lc||5.006000|
is_uni_lower||5.006000|
is_uni_print_lc||5.006000|
is_uni_print||5.006000|
is_uni_punct_lc||5.006000|
is_uni_punct||5.006000|
is_uni_space_lc||5.006000|
is_uni_space||5.006000|
is_uni_upper_lc||5.006000|
is_uni_upper||5.006000|
is_uni_xdigit_lc||5.006000|
is_uni_xdigit||5.006000|
is_utf8_alnumc||5.006000|
is_utf8_alnum||5.006000|
is_utf8_alpha||5.006000|
is_utf8_ascii||5.006000|
is_utf8_char_slow|||
is_utf8_char||5.006000|
is_utf8_cntrl||5.006000|
is_utf8_digit||5.006000|
is_utf8_graph||5.006000|
is_utf8_idcont||5.008000|
is_utf8_idfirst||5.006000|
is_utf8_lower||5.006000|
is_utf8_mark||5.006000|
is_utf8_print||5.006000|
is_utf8_punct||5.006000|
is_utf8_space||5.006000|
is_utf8_string_loclen||5.009003|
is_utf8_string_loc||5.008001|
is_utf8_string||5.006001|
is_utf8_upper||5.006000|
is_utf8_xdigit||5.006000|
isa_lookup|||
items|||n
ix|||n
jmaybe|||
keyword|||
leave_scope|||
lex_end|||
lex_start|||
linklist|||
listkids|||
list|||
load_module_nocontext|||vn
load_module||5.006000|v
localize|||
looks_like_number|||
lop|||
mPUSHi|5.009002||p
mPUSHn|5.009002||p
mPUSHp|5.009002||p
mPUSHu|5.009002||p
mXPUSHi|5.009002||p
mXPUSHn|5.009002||p
mXPUSHp|5.009002||p
mXPUSHu|5.009002||p
magic_clear_all_env|||
magic_clearenv|||
magic_clearpack|||
magic_clearsig|||
magic_dump||5.006000|
magic_existspack|||
magic_freearylen_p|||
magic_freeovrld|||
magic_freeregexp|||
magic_getarylen|||
magic_getdefelem|||
magic_getglob|||
magic_getnkeys|||
magic_getpack|||
magic_getpos|||
magic_getsig|||
magic_getsubstr|||
magic_gettaint|||
magic_getuvar|||
magic_getvec|||
magic_get|||
magic_killbackrefs|||
magic_len|||
magic_methcall|||
magic_methpack|||
magic_nextpack|||
magic_regdata_cnt|||
magic_regdatum_get|||
magic_regdatum_set|||
magic_scalarpack|||
magic_set_all_env|||
magic_setamagic|||
magic_setarylen|||
magic_setbm|||
magic_setcollxfrm|||
magic_setdbline|||
magic_setdefelem|||
magic_setenv|||
magic_setfm|||
magic_setglob|||
magic_setisa|||
magic_setmglob|||
magic_setnkeys|||
magic_setpack|||
magic_setpos|||
magic_setregexp|||
magic_setsig|||
magic_setsubstr|||
magic_settaint|||
magic_setutf8|||
magic_setuvar|||
magic_setvec|||
magic_set|||
magic_sizepack|||
magic_wipepack|||
magicname|||
make_trie|||
malloced_size|||n
malloc||5.007002|n
markstack_grow|||
measure_struct|||
memEQ|5.004000||p
memNE|5.004000||p
mem_collxfrm|||
mess_alloc|||
mess_nocontext|||vn
mess||5.006000|v
method_common|||
mfree||5.007002|n
mg_clear|||
mg_copy|||
mg_dup|||
mg_find|||
mg_free|||
mg_get|||
mg_length||5.005000|
mg_localize|||
mg_magical|||
mg_set|||
mg_size||5.005000|
mini_mktime||5.007002|
missingterm|||
mode_from_discipline|||
modkids|||
mod|||
moreswitches|||
mul128|||
mulexp10|||n
my_atof2||5.007002|
my_atof||5.006000|
my_attrs|||
my_bcopy|||n
my_betoh16|||n
my_betoh32|||n
my_betoh64|||n
my_betohi|||n
my_betohl|||n
my_betohs|||n
my_bzero|||n
my_chsize|||
my_exit_jump|||
my_exit|||
my_failure_exit||5.004000|
my_fflush_all||5.006000|
my_fork||5.007003|n
my_htobe16|||n
my_htobe32|||n
my_htobe64|||n
my_htobei|||n
my_htobel|||n
my_htobes|||n
my_htole16|||n
my_htole32|||n
my_htole64|||n
my_htolei|||n
my_htolel|||n
my_htoles|||n
my_htonl|||
my_kid|||
my_letoh16|||n
my_letoh32|||n
my_letoh64|||n
my_letohi|||n
my_letohl|||n
my_letohs|||n
my_lstat|||
my_memcmp||5.004000|n
my_memset|||n
my_ntohl|||
my_pclose||5.004000|
my_popen_list||5.007001|
my_popen||5.004000|
my_setenv|||
my_socketpair||5.007003|n
my_stat|||
my_strftime||5.007002|
my_swabn|||n
my_swap|||
my_unexec|||
my|||
newANONATTRSUB||5.006000|
newANONHASH|||
newANONLIST|||
newANONSUB|||
newASSIGNOP|||
newATTRSUB||5.006000|
newAVREF|||
newAV|||
newBINOP|||
newCONDOP|||
newCONSTSUB|5.006000||p
newCVREF|||
newDEFSVOP|||
newFORM|||
newFOROP|||
newGVOP|||
newGVREF|||
newGVgen|||
newHVREF|||
newHVhv||5.005000|
newHV|||
newIO|||
newLISTOP|||
newLOGOP|||
newLOOPEX|||
newLOOPOP|||
newMYSUB||5.006000|
newNULLLIST|||
newOP|||
newPADOP||5.006000|
newPMOP|||
newPROG|||
newPVOP|||
newRANGE|||
newRV_inc|5.004000||p
newRV_noinc|5.006000||p
newRV|||
newSLICEOP|||
newSTATEOP|||
newSUB|||
newSVOP|||
newSVREF|||
newSVhek||5.009003|
newSViv|||
newSVnv|||
newSVpvf_nocontext|||vn
newSVpvf||5.004000|v
newSVpvn_share||5.007001|
newSVpvn|5.006000||p
newSVpv|||
newSVrv|||
newSVsv|||
newSVuv|5.006000||p
newSV|||
newUNOP|||
newWHILEOP||5.009003|
newXSproto||5.006000|
newXS||5.006000|
new_collate||5.006000|
new_constant|||
new_ctype||5.006000|
new_he|||
new_logop|||
new_numeric||5.006000|
new_stackinfo||5.005000|
new_version||5.009000|
next_symbol|||
nextargv|||
nextchar|||
ninstr|||
no_bareword_allowed|||
no_fh_allowed|||
no_op|||
not_a_number|||
nothreadhook||5.008000|
nuke_stacks|||
num_overflow|||n
oopsAV|||
oopsCV|||
oopsHV|||
op_clear|||
op_const_sv|||
op_dump||5.006000|
op_free|||
op_null||5.007002|
op_refcnt_lock||5.009002|
op_refcnt_unlock||5.009002|
open_script|||
pMY_CXT_|5.007003||p
pMY_CXT|5.007003||p
pTHX_|5.006000||p
pTHX|5.006000||p
pack_cat||5.007003|
pack_rec|||
package|||
packlist||5.008001|
pad_add_anon|||
pad_add_name|||
pad_alloc|||
pad_block_start|||
pad_check_dup|||
pad_compname_type|||
pad_findlex|||
pad_findmy|||
pad_fixup_inner_anons|||
pad_free|||
pad_leavemy|||
pad_new|||
pad_push|||
pad_reset|||
pad_setsv|||
pad_sv|||
pad_swipe|||
pad_tidy|||
pad_undef|||
parse_body|||
parse_unicode_opts|||
path_is_absolute|||
peep|||
pending_ident|||
perl_alloc_using|||n
perl_alloc|||n
perl_clone_using|||n
perl_clone|||n
perl_construct|||n
perl_destruct||5.007003|n
perl_free|||n
perl_parse||5.006000|n
perl_run|||n
pidgone|||
pmflag|||
pmop_dump||5.006000|
pmruntime|||
pmtrans|||
pop_scope|||
pregcomp|||
pregexec|||
pregfree|||
prepend_elem|||
printf_nocontext|||vn
ptr_table_clear|||
ptr_table_fetch|||
ptr_table_free|||
ptr_table_new|||
ptr_table_split|||
ptr_table_store|||
push_scope|||
put_byte|||
pv_display||5.006000|
pv_uni_display||5.007003|
qerror|||
re_croak2|||
re_dup|||
re_intuit_start||5.006000|
re_intuit_string||5.006000|
realloc||5.007002|n
reentrant_free|||
reentrant_init|||
reentrant_retry|||vn
reentrant_size|||
refkids|||
refto|||
ref|||
reg_node|||
reganode|||
regatom|||
regbranch|||
regclass_swash||5.007003|
regclass|||
regcp_set_to|||
regcppop|||
regcppush|||
regcurly|||
regdump||5.005000|
regexec_flags||5.005000|
reghop3|||
reghopmaybe3|||
reghopmaybe|||
reghop|||
reginclass|||
reginitcolors||5.006000|
reginsert|||
regmatch|||
regnext||5.005000|
regoptail|||
regpiece|||
regpposixcc|||
regprop|||
regrepeat_hard|||
regrepeat|||
regtail|||
regtry|||
reguni|||
regwhite|||
reg|||
repeatcpy|||
report_evil_fh|||
report_uninit|||
require_errno|||
require_pv||5.006000|
rninstr|||
rsignal_restore|||
rsignal_save|||
rsignal_state||5.004000|
rsignal||5.004000|
run_body|||
runops_debug||5.005000|
runops_standard||5.005000|
rvpv_dup|||
rxres_free|||
rxres_restore|||
rxres_save|||
safesyscalloc||5.006000|n
safesysfree||5.006000|n
safesysmalloc||5.006000|n
safesysrealloc||5.006000|n
same_dirent|||
save_I16||5.004000|
save_I32|||
save_I8||5.006000|
save_aelem||5.004050|
save_alloc||5.006000|
save_aptr|||
save_ary|||
save_bool||5.008001|
save_clearsv|||
save_delete|||
save_destructor_x||5.006000|
save_destructor||5.006000|
save_freeop|||
save_freepv|||
save_freesv|||
save_generic_pvref||5.006001|
save_generic_svref||5.005030|
save_gp||5.004000|
save_hash|||
save_hek_flags|||
save_helem||5.004050|
save_hints||5.005000|
save_hptr|||
save_int|||
save_item|||
save_iv||5.005000|
save_lines|||
save_list|||
save_long|||
save_magic|||
save_mortalizesv||5.007001|
save_nogv|||
save_op|||
save_padsv||5.007001|
save_pptr|||
save_re_context||5.006000|
save_scalar_at|||
save_scalar|||
save_set_svflags||5.009000|
save_shared_pvref||5.007003|
save_sptr|||
save_svref|||
save_threadsv||5.005000|
save_vptr||5.006000|
savepvn|||
savepv|||
savesharedpv||5.007003|
savestack_grow_cnt||5.008001|
savestack_grow|||
savesvpv||5.009002|
sawparens|||
scalar_mod_type|||
scalarboolean|||
scalarkids|||
scalarseq|||
scalarvoid|||
scalar|||
scan_bin||5.006000|
scan_commit|||
scan_const|||
scan_formline|||
scan_heredoc|||
scan_hex|||
scan_ident|||
scan_inputsymbol|||
scan_num||5.007001|
scan_oct|||
scan_pat|||
scan_str|||
scan_subst|||
scan_trans|||
scan_version||5.009001|
scan_vstring||5.008001|
scan_word|||
scope|||
screaminstr||5.005000|
seed|||
set_context||5.006000|n
set_csh|||
set_numeric_local||5.006000|
set_numeric_radix||5.006000|
set_numeric_standard||5.006000|
setdefout|||
setenv_getix|||
share_hek_flags|||
share_hek|||
si_dup|||
sighandler|||n
simplify_sort|||
skipspace|||
sortsv||5.007003|
ss_dup|||
stack_grow|||
start_glob|||
start_subparse||5.004000|
stashpv_hvname_match||5.009003|
stdize_locale|||
strEQ|||
strGE|||
strGT|||
strLE|||
strLT|||
strNE|||
str_to_version||5.006000|
strnEQ|||
strnNE|||
study_chunk|||
sub_crush_depth|||
sublex_done|||
sublex_push|||
sublex_start|||
sv_2bool|||
sv_2cv|||
sv_2io|||
sv_2iuv_non_preserve|||
sv_2iv_flags||5.009001|
sv_2iv|||
sv_2mortal|||
sv_2nv|||
sv_2pv_flags||5.007002|
sv_2pv_nolen|5.006000||p
sv_2pvbyte_nolen|||
sv_2pvbyte|5.006000||p
sv_2pvutf8_nolen||5.006000|
sv_2pvutf8||5.006000|
sv_2pv|||
sv_2uv_flags||5.009001|
sv_2uv|5.004000||p
sv_add_arena|||
sv_add_backref|||
sv_backoff|||
sv_bless|||
sv_cat_decode||5.008001|
sv_catpv_mg|5.006000||p
sv_catpvf_mg_nocontext|||pvn
sv_catpvf_mg|5.006000|5.004000|pv
sv_catpvf_nocontext|||vn
sv_catpvf||5.004000|v
sv_catpvn_flags||5.007002|
sv_catpvn_mg|5.006000||p
sv_catpvn_nomg|5.007002||p
sv_catpvn|||
sv_catpv|||
sv_catsv_flags||5.007002|
sv_catsv_mg|5.006000||p
sv_catsv_nomg|5.007002||p
sv_catsv|||
sv_chop|||
sv_clean_all|||
sv_clean_objs|||
sv_clear|||
sv_cmp_locale||5.004000|
sv_cmp|||
sv_collxfrm|||
sv_compile_2op||5.008001|
sv_copypv||5.007003|
sv_dec|||
sv_del_backref|||
sv_derived_from||5.004000|
sv_dump|||
sv_dup|||
sv_eq|||
sv_force_normal_flags||5.007001|
sv_force_normal||5.006000|
sv_free2|||
sv_free_arenas|||
sv_free|||
sv_gets||5.004000|
sv_grow|||
sv_inc|||
sv_insert|||
sv_isa|||
sv_isobject|||
sv_iv||5.005000|
sv_len_utf8||5.006000|
sv_len|||
sv_magicext||5.007003|
sv_magic|||
sv_mortalcopy|||
sv_newmortal|||
sv_newref|||
sv_nolocking||5.007003|
sv_nosharing||5.007003|
sv_nounlocking||5.007003|
sv_nv||5.005000|
sv_peek||5.005000|
sv_pos_b2u||5.006000|
sv_pos_u2b||5.006000|
sv_pvbyten_force||5.006000|
sv_pvbyten||5.006000|
sv_pvbyte||5.006000|
sv_pvn_force_flags||5.007002|
sv_pvn_force|||p
sv_pvn_nomg|5.007003||p
sv_pvn|5.006000||p
sv_pvutf8n_force||5.006000|
sv_pvutf8n||5.006000|
sv_pvutf8||5.006000|
sv_pv||5.006000|
sv_recode_to_utf8||5.007003|
sv_reftype|||
sv_release_COW|||
sv_release_IVX|||
sv_replace|||
sv_report_used|||
sv_reset|||
sv_rvweaken||5.006000|
sv_setiv_mg|5.006000||p
sv_setiv|||
sv_setnv_mg|5.006000||p
sv_setnv|||
sv_setpv_mg|5.006000||p
sv_setpvf_mg_nocontext|||pvn
sv_setpvf_mg|5.006000|5.004000|pv
sv_setpvf_nocontext|||vn
sv_setpvf||5.004000|v
sv_setpviv_mg||5.008001|
sv_setpviv||5.008001|
sv_setpvn_mg|5.006000||p
sv_setpvn|||
sv_setpv|||
sv_setref_iv|||
sv_setref_nv|||
sv_setref_pvn|||
sv_setref_pv|||
sv_setref_uv||5.007001|
sv_setsv_cow|||
sv_setsv_flags||5.007002|
sv_setsv_mg|5.006000||p
sv_setsv_nomg|5.007002||p
sv_setsv|||
sv_setuv_mg|5.006000||p
sv_setuv|5.006000||p
sv_tainted||5.004000|
sv_taint||5.004000|
sv_true||5.005000|
sv_unglob|||
sv_uni_display||5.007003|
sv_unmagic|||
sv_unref_flags||5.007001|
sv_unref|||
sv_untaint||5.004000|
sv_upgrade|||
sv_usepvn_mg|5.006000||p
sv_usepvn|||
sv_utf8_decode||5.006000|
sv_utf8_downgrade||5.006000|
sv_utf8_encode||5.006000|
sv_utf8_upgrade_flags||5.007002|
sv_utf8_upgrade||5.007001|
sv_uv|5.006000||p
sv_vcatpvf_mg|5.006000|5.004000|p
sv_vcatpvfn||5.004000|
sv_vcatpvf|5.006000|5.004000|p
sv_vsetpvf_mg|5.006000|5.004000|p
sv_vsetpvfn||5.004000|
sv_vsetpvf|5.006000|5.004000|p
svtype|||
swallow_bom|||
swash_fetch||5.007002|
swash_init||5.006000|
sys_intern_clear|||
sys_intern_dup|||
sys_intern_init|||
taint_env|||
taint_proper|||
tmps_grow||5.006000|
toLOWER|||
toUPPER|||
to_byte_substr|||
to_uni_fold||5.007003|
to_uni_lower_lc||5.006000|
to_uni_lower||5.007003|
to_uni_title_lc||5.006000|
to_uni_title||5.007003|
to_uni_upper_lc||5.006000|
to_uni_upper||5.007003|
to_utf8_case||5.007003|
to_utf8_fold||5.007003|
to_utf8_lower||5.007003|
to_utf8_substr|||
to_utf8_title||5.007003|
to_utf8_upper||5.007003|
tokeq|||
tokereport|||
too_few_arguments|||
too_many_arguments|||
unlnk|||
unpack_rec|||
unpack_str||5.007003|
unpackstring||5.008001|
unshare_hek_or_pvn|||
unshare_hek|||
unsharepvn||5.004000|
upg_version||5.009000|
usage|||
utf16_textfilter|||
utf16_to_utf8_reversed||5.006001|
utf16_to_utf8||5.006001|
utf16rev_textfilter|||
utf8_distance||5.006000|
utf8_hop||5.006000|
utf8_length||5.007001|
utf8_mg_pos_init|||
utf8_mg_pos|||
utf8_to_bytes||5.006001|
utf8_to_uvchr||5.007001|
utf8_to_uvuni||5.007001|
utf8n_to_uvchr||5.007001|
utf8n_to_uvuni||5.007001|
utilize|||
uvchr_to_utf8_flags||5.007003|
uvchr_to_utf8||5.007001|
uvuni_to_utf8_flags||5.007003|
uvuni_to_utf8||5.007001|
validate_suid|||
varname|||
vcmp||5.009000|
vcroak||5.006000|
vdeb||5.007003|
vdie|||
vform||5.006000|
visit|||
vivify_defelem|||
vivify_ref|||
vload_module||5.006000|
vmess||5.006000|
vnewSVpvf|5.006000|5.004000|p
vnormal||5.009002|
vnumify||5.009000|
vstringify||5.009000|
vwarner||5.006000|
vwarn||5.006000|
wait4pid|||
warn_nocontext|||vn
warner_nocontext|||vn
warner||5.006000|v
warn|||v
watch|||
whichsig|||
write_to_stderr|||
yyerror|||
yylex|||
yyparse|||
yywarn|||
);

if (exists $opt{'list-unsupported'}) {
  my $f;
  for $f (sort { lc $a cmp lc $b } keys %API) {
    next unless $API{$f}{todo};
    print "$f ", '.'x(40-length($f)), " ", format_version($API{$f}{todo}), "\n";
  }
  exit 0;
}

# Scan for possible replacement candidates

my(%replace, %need, %hints, %depends);
my $replace = 0;
my $hint = '';

while (<DATA>) {
  if ($hint) {
    if (m{^\s*\*\s(.*?)\s*$}) {
      $hints{$hint} ||= '';  # suppress warning with older perls
      $hints{$hint} .= "$1\n";
    }
    else {
      $hint = '';
    }
  }
  $hint = $1 if m{^\s*$rccs\sHint:\s+(\w+)\s*$};

  $replace     = $1 if m{^\s*$rccs\s+Replace:\s+(\d+)\s+$rcce\s*$};
  $replace{$2} = $1 if $replace and m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+)};
  $replace{$2} = $1 if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+).*$rccs\s+Replace\s+$rcce};
  $replace{$1} = $2 if m{^\s*$rccs\s+Replace (\w+) with (\w+)\s+$rcce\s*$};

  if (m{^\s*$rccs\s+(\w+)\s+depends\s+on\s+(\w+(\s*,\s*\w+)*)\s+$rcce\s*$}) {
    push @{$depends{$1}}, map { s/\s+//g; $_ } split /,/, $2;
  }

  $need{$1} = 1 if m{^#if\s+defined\(NEED_(\w+)(?:_GLOBAL)?\)};
}

if (exists $opt{'api-info'}) {
  my $f;
  my $count = 0;
  my $match = $opt{'api-info'} =~ m!^/(.*)/$! ? $1 : "^\Q$opt{'api-info'}\E\$";
  for $f (sort { lc $a cmp lc $b } keys %API) {
    next unless $f =~ /$match/;
    print "\n=== $f ===\n\n";
    my $info = 0;
    if ($API{$f}{base} || $API{$f}{todo}) {
      my $base = format_version($API{$f}{base} || $API{$f}{todo});
      print "Supported at least starting from perl-$base.\n";
      $info++;
    }
    if ($API{$f}{provided}) {
      my $todo = $API{$f}{todo} ? format_version($API{$f}{todo}) : "5.003";
      print "Support by $ppport provided back to perl-$todo.\n";
      print "Support needs to be explicitly requested by NEED_$f.\n" if exists $need{$f};
      print "Depends on: ", join(', ', @{$depends{$f}}), ".\n" if exists $depends{$f};
      print "$hints{$f}" if exists $hints{$f};
      $info++;
    }
    unless ($info) {
      print "No portability information available.\n";
    }
    $count++;
  }
  if ($count > 0) {
    print "\n";
  }
  else {
    print "Found no API matching '$opt{'api-info'}'.\n";
  }
  exit 0;
}

if (exists $opt{'list-provided'}) {
  my $f;
  for $f (sort { lc $a cmp lc $b } keys %API) {
    next unless $API{$f}{provided};
    my @flags;
    push @flags, 'explicit' if exists $need{$f};
    push @flags, 'depend'   if exists $depends{$f};
    push @flags, 'hint'     if exists $hints{$f};
    my $flags = @flags ? '  ['.join(', ', @flags).']' : '';
    print "$f$flags\n";
  }
  exit 0;
}

my @files;
my @srcext = qw( xs c h cc cpp );
my $srcext = join '|', @srcext;

if (@ARGV) {
  my %seen;
  @files = grep { -f && !exists $seen{$_} } map { glob $_ } @ARGV;
}
else {
  eval {
    require File::Find;
    File::Find::find(sub {
      $File::Find::name =~ /\.($srcext)$/i
          and push @files, $File::Find::name;
    }, '.');
  };
  if ($@) {
    @files = map { glob "*.$_" } @srcext;
  }
}

if (!@ARGV || $opt{filter}) {
  my(@in, @out);
  my %xsc = map { /(.*)\.xs$/ ? ("$1.c" => 1, "$1.cc" => 1) : () } @files;
  for (@files) {
    my $out = exists $xsc{$_} || /\b\Q$ppport\E$/i || !/\.($srcext)$/i;
    push @{ $out ? \@out : \@in }, $_;
  }
  if (@ARGV && @out) {
    warning("Skipping the following files (use --nofilter to avoid this):\n| ", join "\n| ", @out);
  }
  @files = @in;
}

unless (@files) {
  die "No input files given!\n";
}

my(%files, %global, %revreplace);
%revreplace = reverse %replace;
my $filename;
my $patch_opened = 0;

for $filename (@files) {
  unless (open IN, "<$filename") {
    warn "Unable to read from $filename: $!\n";
    next;
  }

  info("Scanning $filename ...");

  my $c = do { local $/; <IN> };
  close IN;

  my %file = (orig => $c, changes => 0);

  # temporarily remove C comments from the code
  my @ccom;
  $c =~ s{
    (
        [^"'/]+
      |
        (?:"[^"\\]*(?:\\.[^"\\]*)*" [^"'/]*)+
      |
        (?:'[^'\\]*(?:\\.[^'\\]*)*' [^"'/]*)+
    )
  |
    (/ (?:
        \*[^*]*\*+(?:[^$ccs][^*]*\*+)* /
        |
        /[^\r\n]*
      ))
  }{
    defined $2 and push @ccom, $2;
    defined $1 ? $1 : "$ccs$#ccom$cce";
  }egsx;

  $file{ccom} = \@ccom;
  $file{code} = $c;
  $file{has_inc_ppport} = ($c =~ /#.*include.*\Q$ppport\E/);

  my $func;

  for $func (keys %API) {
    my $match = $func;
    $match .= "|$revreplace{$func}" if exists $revreplace{$func};
    if ($c =~ /\b(?:Perl_)?($match)\b/) {
      $file{uses_replace}{$1}++ if exists $revreplace{$func} && $1 eq $revreplace{$func};
      $file{uses_Perl}{$func}++ if $c =~ /\bPerl_$func\b/;
      if (exists $API{$func}{provided}) {
        if (!exists $API{$func}{base} || $API{$func}{base} > $opt{'compat-version'}) {
          $file{uses}{$func}++;
          my @deps = rec_depend($func);
          if (@deps) {
            $file{uses_deps}{$func} = \@deps;
            for (@deps) {
              $file{uses}{$_} = 0 unless exists $file{uses}{$_};
            }
          }
          for ($func, @deps) {
            if (exists $need{$_}) {
              $file{needs}{$_} = 'static';
            }
          }
        }
      }
      if (exists $API{$func}{todo} && $API{$func}{todo} > $opt{'compat-version'}) {
        if ($c =~ /\b$func\b/) {
          $file{uses_todo}{$func}++;
        }
      }
    }
  }

  while ($c =~ /^$HS*#$HS*define$HS+(NEED_(\w+?)(_GLOBAL)?)\b/mg) {
    if (exists $need{$2}) {
      $file{defined $3 ? 'needed_global' : 'needed_static'}{$2}++;
    }
    else {
      warning("Possibly wrong #define $1 in $filename");
    }
  }

  for (qw(uses needs uses_todo needed_global needed_static)) {
    for $func (keys %{$file{$_}}) {
      push @{$global{$_}{$func}}, $filename;
    }
  }

  $files{$filename} = \%file;
}

# Globally resolve NEED_'s
my $need;
for $need (keys %{$global{needs}}) {
  if (@{$global{needs}{$need}} > 1) {
    my @targets = @{$global{needs}{$need}};
    my @t = grep $files{$_}{needed_global}{$need}, @targets;
    @targets = @t if @t;
    @t = grep /\.xs$/i, @targets;
    @targets = @t if @t;
    my $target = shift @targets;
    $files{$target}{needs}{$need} = 'global';
    for (@{$global{needs}{$need}}) {
      $files{$_}{needs}{$need} = 'extern' if $_ ne $target;
    }
  }
}

for $filename (@files) {
  exists $files{$filename} or next;

  info("=== Analyzing $filename ===");

  my %file = %{$files{$filename}};
  my $func;
  my $c = $file{code};

  for $func (sort keys %{$file{uses_Perl}}) {
    if ($API{$func}{varargs}) {
      my $changes = ($c =~ s{\b(Perl_$func\s*\(\s*)(?!aTHX_?)(\)|[^\s)]*\))}
                            { $1 . ($2 eq ')' ? 'aTHX' : 'aTHX_ ') . $2 }ge);
      if ($changes) {
        warning("Doesn't pass interpreter argument aTHX to Perl_$func");
        $file{changes} += $changes;
      }
    }
    else {
      warning("Uses Perl_$func instead of $func");
      $file{changes} += ($c =~ s{\bPerl_$func(\s*)\((\s*aTHX_?)?\s*}
                                {$func$1(}g);
    }
  }

  for $func (sort keys %{$file{uses_replace}}) {
    warning("Uses $func instead of $replace{$func}");
    $file{changes} += ($c =~ s/\b$func\b/$replace{$func}/g);
  }

  for $func (sort keys %{$file{uses}}) {
    next unless $file{uses}{$func};   # if it's only a dependency
    if (exists $file{uses_deps}{$func}) {
      diag("Uses $func, which depends on ", join(', ', @{$file{uses_deps}{$func}}));
    }
    elsif (exists $replace{$func}) {
      warning("Uses $func instead of $replace{$func}");
      $file{changes} += ($c =~ s/\b$func\b/$replace{$func}/g);
    }
    else {
      diag("Uses $func");
    }
    hint($func);
  }

  for $func (sort keys %{$file{uses_todo}}) {
    warning("Uses $func, which may not be portable below perl ",
            format_version($API{$func}{todo}));
  }

  for $func (sort keys %{$file{needed_static}}) {
    my $message = '';
    if (not exists $file{uses}{$func}) {
      $message = "No need to define NEED_$func if $func is never used";
    }
    elsif (exists $file{needs}{$func} && $file{needs}{$func} ne 'static') {
      $message = "No need to define NEED_$func when already needed globally";
    }
    if ($message) {
      diag($message);
      $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_$func\b.*$LF//mg);
    }
  }

  for $func (sort keys %{$file{needed_global}}) {
    my $message = '';
    if (not exists $global{uses}{$func}) {
      $message = "No need to define NEED_${func}_GLOBAL if $func is never used";
    }
    elsif (exists $file{needs}{$func}) {
      if ($file{needs}{$func} eq 'extern') {
        $message = "No need to define NEED_${func}_GLOBAL when already needed globally";
      }
      elsif ($file{needs}{$func} eq 'static') {
        $message = "No need to define NEED_${func}_GLOBAL when only used in this file";
      }
    }
    if ($message) {
      diag($message);
      $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_${func}_GLOBAL\b.*$LF//mg);
    }
  }

  $file{needs_inc_ppport} = keys %{$file{uses}};

  if ($file{needs_inc_ppport}) {
    my $pp = '';

    for $func (sort keys %{$file{needs}}) {
      my $type = $file{needs}{$func};
      next if $type eq 'extern';
      my $suffix = $type eq 'global' ? '_GLOBAL' : '';
      unless (exists $file{"needed_$type"}{$func}) {
        if ($type eq 'global') {
          diag("Files [@{$global{needs}{$func}}] need $func, adding global request");
        }
        else {
          diag("File needs $func, adding static request");
        }
        $pp .= "#define NEED_$func$suffix\n";
      }
    }

    if ($pp && ($c =~ s/^(?=$HS*#$HS*define$HS+NEED_\w+)/$pp/m)) {
      $pp = '';
      $file{changes}++;
    }

    unless ($file{has_inc_ppport}) {
      diag("Needs to include '$ppport'");
      $pp .= qq(#include "$ppport"\n)
    }

    if ($pp) {
      $file{changes} += ($c =~ s/^($HS*#$HS*define$HS+NEED_\w+.*?)^/$1$pp/ms)
                     || ($c =~ s/^(?=$HS*#$HS*include.*\Q$ppport\E)/$pp/m)
                     || ($c =~ s/^($HS*#$HS*include.*XSUB.*\s*?)^/$1$pp/m)
                     || ($c =~ s/^/$pp/);
    }
  }
  else {
    if ($file{has_inc_ppport}) {
      diag("No need to include '$ppport'");
      $file{changes} += ($c =~ s/^$HS*?#$HS*include.*\Q$ppport\E.*?$LF//m);
    }
  }

  # put back in our C comments
  my $ix;
  my $cppc = 0;
  my @ccom = @{$file{ccom}};
  for $ix (0 .. $#ccom) {
    if (!$opt{cplusplus} && $ccom[$ix] =~ s!^//!!) {
      $cppc++;
      $file{changes} += $c =~ s/$rccs$ix$rcce/$ccs$ccom[$ix] $cce/;
    }
    else {
      $c =~ s/$rccs$ix$rcce/$ccom[$ix]/;
    }
  }

  if ($cppc) {
    my $s = $cppc != 1 ? 's' : '';
    warning("Uses $cppc C++ style comment$s, which is not portable");
  }

  if ($file{changes}) {
    if (exists $opt{copy}) {
      my $newfile = "$filename$opt{copy}";
      if (-e $newfile) {
        error("'$newfile' already exists, refusing to write copy of '$filename'");
      }
      else {
        local *F;
        if (open F, ">$newfile") {
          info("Writing copy of '$filename' with changes to '$newfile'");
          print F $c;
          close F;
        }
        else {
          error("Cannot open '$newfile' for writing: $!");
        }
      }
    }
    elsif (exists $opt{patch} || $opt{changes}) {
      if (exists $opt{patch}) {
        unless ($patch_opened) {
          if (open PATCH, ">$opt{patch}") {
            $patch_opened = 1;
          }
          else {
            error("Cannot open '$opt{patch}' for writing: $!");
            delete $opt{patch};
            $opt{changes} = 1;
            goto fallback;
          }
        }
        mydiff(\*PATCH, $filename, $c);
      }
      else {
fallback:
        info("Suggested changes:");
        mydiff(\*STDOUT, $filename, $c);
      }
    }
    else {
      my $s = $file{changes} == 1 ? '' : 's';
      info("$file{changes} potentially required change$s detected");
    }
  }
  else {
    info("Looks good");
  }
}

close PATCH if $patch_opened;

exit 0;


sub mydiff
{
  local *F = shift;
  my($file, $str) = @_;
  my $diff;

  if (exists $opt{diff}) {
    $diff = run_diff($opt{diff}, $file, $str);
  }

  if (!defined $diff and can_use('Text::Diff')) {
    $diff = Text::Diff::diff($file, \$str, { STYLE => 'Unified' });
    $diff = <<HEADER . $diff;
--- $file
+++ $file.patched
HEADER
  }

  if (!defined $diff) {
    $diff = run_diff('diff -u', $file, $str);
  }

  if (!defined $diff) {
    $diff = run_diff('diff', $file, $str);
  }

  if (!defined $diff) {
    error("Cannot generate a diff. Please install Text::Diff or use --copy.");
    return;
  }

  print F $diff;

}

sub run_diff
{
  my($prog, $file, $str) = @_;
  my $tmp = 'dppptemp';
  my $suf = 'aaa';
  my $diff = '';
  local *F;

  while (-e "$tmp.$suf") { $suf++ }
  $tmp = "$tmp.$suf";

  if (open F, ">$tmp") {
    print F $str;
    close F;

    if (open F, "$prog $file $tmp |") {
      while (<F>) {
        s/\Q$tmp\E/$file.patched/;
        $diff .= $_;
      }
      close F;
      unlink $tmp;
      return $diff;
    }

    unlink $tmp;
  }
  else {
    error("Cannot open '$tmp' for writing: $!");
  }

  return undef;
}

sub can_use
{
  eval "use @_;";
  return $@ eq '';
}

sub rec_depend
{
  my $func = shift;
  my %seen;
  return () unless exists $depends{$func};
  grep !$seen{$_}++, map { ($_, rec_depend($_)) } @{$depends{$func}};
}

sub parse_version
{
  my $ver = shift;

  if ($ver =~ /^(\d+)\.(\d+)\.(\d+)$/) {
    return ($1, $2, $3);
  }
  elsif ($ver !~ /^\d+\.[\d_]+$/) {
    die "cannot parse version '$ver'\n";
  }

  $ver =~ s/_//g;
  $ver =~ s/$/000000/;

  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;

  $v = int $v;
  $s = int $s;

  if ($r < 5 || ($r == 5 && $v < 6)) {
    if ($s % 10) {
      die "cannot parse version '$ver'\n";
    }
  }

  return ($r, $v, $s);
}

sub format_version
{
  my $ver = shift;

  $ver =~ s/$/000000/;
  my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;

  $v = int $v;
  $s = int $s;

  if ($r < 5 || ($r == 5 && $v < 6)) {
    if ($s % 10) {
      die "invalid version '$ver'\n";
    }
    $s /= 10;

    $ver = sprintf "%d.%03d", $r, $v;
    $s > 0 and $ver .= sprintf "_%02d", $s;

    return $ver;
  }

  return sprintf "%d.%d.%d", $r, $v, $s;
}

sub info
{
  $opt{quiet} and return;
  print @_, "\n";
}

sub diag
{
  $opt{quiet} and return;
  $opt{diag} and print @_, "\n";
}

sub warning
{
  $opt{quiet} and return;
  print "*** ", @_, "\n";
}

sub error
{
  print "*** ERROR: ", @_, "\n";
}

my %given_hints;
sub hint
{
  $opt{quiet} and return;
  $opt{hints} or return;
  my $func = shift;
  exists $hints{$func} or return;
  $given_hints{$func}++ and return;
  my $hint = $hints{$func};
  $hint =~ s/^/   /mg;
  print "   --- hint for $func ---\n", $hint;
}

sub usage
{
  my($usage) = do { local(@ARGV,$/)=($0); <> } =~ /^=head\d$HS+SYNOPSIS\s*^(.*?)\s*^=/ms;
  my %M = ( 'I' => '*' );
  $usage =~ s/^\s*perl\s+\S+/$^X $0/;
  $usage =~ s/([A-Z])<([^>]+)>/$M{$1}$2$M{$1}/g;

  print <<ENDUSAGE;

Usage: $usage

See perldoc $0 for details.

ENDUSAGE

  exit 2;
}

__DATA__
*/

#ifndef _P_P_PORTABILITY_H_
#define _P_P_PORTABILITY_H_

#ifndef DPPP_NAMESPACE
#  define DPPP_NAMESPACE DPPP_
#endif

#define DPPP_CAT2(x,y) CAT2(x,y)
#define DPPP_(name) DPPP_CAT2(DPPP_NAMESPACE, name)

#ifndef PERL_REVISION
#  if !defined(__PATCHLEVEL_H_INCLUDED__) && !(defined(PATCHLEVEL) && defined(SUBVERSION))
#    define PERL_PATCHLEVEL_H_IMPLICIT
#    include <patchlevel.h>
#  endif
#  if !(defined(PERL_VERSION) || (defined(SUBVERSION) && defined(PATCHLEVEL)))
#    include <could_not_find_Perl_patchlevel.h>
#  endif
#  ifndef PERL_REVISION
#    define PERL_REVISION       (5)
     /* Replace: 1 */
#    define PERL_VERSION        PATCHLEVEL
#    define PERL_SUBVERSION     SUBVERSION
     /* Replace PERL_PATCHLEVEL with PERL_VERSION */
     /* Replace: 0 */
#  endif
#endif

#define PERL_BCDVERSION ((PERL_REVISION * 0x1000000L) + (PERL_VERSION * 0x1000L) + PERL_SUBVERSION)

/* It is very unlikely that anyone will try to use this with Perl 6
   (or greater), but who knows.
 */
#if PERL_REVISION != 5
#  error ppport.h only works with Perl version 5
#endif /* PERL_REVISION != 5 */

#ifdef I_LIMITS
#  include <limits.h>
#endif

#ifndef PERL_UCHAR_MIN
#  define PERL_UCHAR_MIN ((unsigned char)0)
#endif

#ifndef PERL_UCHAR_MAX
#  ifdef UCHAR_MAX
#    define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#  else
#    ifdef MAXUCHAR
#      define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#    else
#      define PERL_UCHAR_MAX ((unsigned char)~(unsigned)0)
#    endif
#  endif
#endif

#ifndef PERL_USHORT_MIN
#  define PERL_USHORT_MIN ((unsigned short)0)
#endif

#ifndef PERL_USHORT_MAX
#  ifdef USHORT_MAX
#    define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#  else
#    ifdef MAXUSHORT
#      define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#    else
#      ifdef USHRT_MAX
#        define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#      else
#        define PERL_USHORT_MAX ((unsigned short)~(unsigned)0)
#      endif
#    endif
#  endif
#endif

#ifndef PERL_SHORT_MAX
#  ifdef SHORT_MAX
#    define PERL_SHORT_MAX ((short)SHORT_MAX)
#  else
#    ifdef MAXSHORT    /* Often used in <values.h> */
#      define PERL_SHORT_MAX ((short)MAXSHORT)
#    else
#      ifdef SHRT_MAX
#        define PERL_SHORT_MAX ((short)SHRT_MAX)
#      else
#        define PERL_SHORT_MAX ((short) (PERL_USHORT_MAX >> 1))
#      endif
#    endif
#  endif
#endif

#ifndef PERL_SHORT_MIN
#  ifdef SHORT_MIN
#    define PERL_SHORT_MIN ((short)SHORT_MIN)
#  else
#    ifdef MINSHORT
#      define PERL_SHORT_MIN ((short)MINSHORT)
#    else
#      ifdef SHRT_MIN
#        define PERL_SHORT_MIN ((short)SHRT_MIN)
#      else
#        define PERL_SHORT_MIN (-PERL_SHORT_MAX - ((3 & -1) == 3))
#      endif
#    endif
#  endif
#endif

#ifndef PERL_UINT_MAX
#  ifdef UINT_MAX
#    define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#  else
#    ifdef MAXUINT
#      define PERL_UINT_MAX ((unsigned int)MAXUINT)
#    else
#      define PERL_UINT_MAX (~(unsigned int)0)
#    endif
#  endif
#endif

#ifndef PERL_UINT_MIN
#  define PERL_UINT_MIN ((unsigned int)0)
#endif

#ifndef PERL_INT_MAX
#  ifdef INT_MAX
#    define PERL_INT_MAX ((int)INT_MAX)
#  else
#    ifdef MAXINT    /* Often used in <values.h> */
#      define PERL_INT_MAX ((int)MAXINT)
#    else
#      define PERL_INT_MAX ((int)(PERL_UINT_MAX >> 1))
#    endif
#  endif
#endif

#ifndef PERL_INT_MIN
#  ifdef INT_MIN
#    define PERL_INT_MIN ((int)INT_MIN)
#  else
#    ifdef MININT
#      define PERL_INT_MIN ((int)MININT)
#    else
#      define PERL_INT_MIN (-PERL_INT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifndef PERL_ULONG_MAX
#  ifdef ULONG_MAX
#    define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#  else
#    ifdef MAXULONG
#      define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#    else
#      define PERL_ULONG_MAX (~(unsigned long)0)
#    endif
#  endif
#endif

#ifndef PERL_ULONG_MIN
#  define PERL_ULONG_MIN ((unsigned long)0L)
#endif

#ifndef PERL_LONG_MAX
#  ifdef LONG_MAX
#    define PERL_LONG_MAX ((long)LONG_MAX)
#  else
#    ifdef MAXLONG
#      define PERL_LONG_MAX ((long)MAXLONG)
#    else
#      define PERL_LONG_MAX ((long) (PERL_ULONG_MAX >> 1))
#    endif
#  endif
#endif

#ifndef PERL_LONG_MIN
#  ifdef LONG_MIN
#    define PERL_LONG_MIN ((long)LONG_MIN)
#  else
#    ifdef MINLONG
#      define PERL_LONG_MIN ((long)MINLONG)
#    else
#      define PERL_LONG_MIN (-PERL_LONG_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#if defined(HAS_QUAD) && (defined(convex) || defined(uts))
#  ifndef PERL_UQUAD_MAX
#    ifdef ULONGLONG_MAX
#      define PERL_UQUAD_MAX ((unsigned long long)ULONGLONG_MAX)
#    else
#      ifdef MAXULONGLONG
#        define PERL_UQUAD_MAX ((unsigned long long)MAXULONGLONG)
#      else
#        define PERL_UQUAD_MAX (~(unsigned long long)0)
#      endif
#    endif
#  endif

#  ifndef PERL_UQUAD_MIN
#    define PERL_UQUAD_MIN ((unsigned long long)0L)
#  endif

#  ifndef PERL_QUAD_MAX
#    ifdef LONGLONG_MAX
#      define PERL_QUAD_MAX ((long long)LONGLONG_MAX)
#    else
#      ifdef MAXLONGLONG
#        define PERL_QUAD_MAX ((long long)MAXLONGLONG)
#      else
#        define PERL_QUAD_MAX ((long long) (PERL_UQUAD_MAX >> 1))
#      endif
#    endif
#  endif

#  ifndef PERL_QUAD_MIN
#    ifdef LONGLONG_MIN
#      define PERL_QUAD_MIN ((long long)LONGLONG_MIN)
#    else
#      ifdef MINLONGLONG
#        define PERL_QUAD_MIN ((long long)MINLONGLONG)
#      else
#        define PERL_QUAD_MIN (-PERL_QUAD_MAX - ((3 & -1) == 3))
#      endif
#    endif
#  endif
#endif

/* This is based on code from 5.003 perl.h */
#ifdef HAS_QUAD
#  ifdef cray
#ifndef IVTYPE
#  define IVTYPE                         int
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_INT_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_INT_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_UINT_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_UINT_MAX
#endif

#    ifdef INTSIZE
#ifndef IVSIZE
#  define IVSIZE                         INTSIZE
#endif

#    endif
#  else
#    if defined(convex) || defined(uts)
#ifndef IVTYPE
#  define IVTYPE                         long long
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_QUAD_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_QUAD_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_UQUAD_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_UQUAD_MAX
#endif

#      ifdef LONGLONGSIZE
#ifndef IVSIZE
#  define IVSIZE                         LONGLONGSIZE
#endif

#      endif
#    else
#ifndef IVTYPE
#  define IVTYPE                         long
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_LONG_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_LONG_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_ULONG_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_ULONG_MAX
#endif

#      ifdef LONGSIZE
#ifndef IVSIZE
#  define IVSIZE                         LONGSIZE
#endif

#      endif
#    endif
#  endif
#ifndef IVSIZE
#  define IVSIZE                         8
#endif

#ifndef PERL_QUAD_MIN
#  define PERL_QUAD_MIN                  IV_MIN
#endif

#ifndef PERL_QUAD_MAX
#  define PERL_QUAD_MAX                  IV_MAX
#endif

#ifndef PERL_UQUAD_MIN
#  define PERL_UQUAD_MIN                 UV_MIN
#endif

#ifndef PERL_UQUAD_MAX
#  define PERL_UQUAD_MAX                 UV_MAX
#endif

#else
#ifndef IVTYPE
#  define IVTYPE                         long
#endif

#ifndef IV_MIN
#  define IV_MIN                         PERL_LONG_MIN
#endif

#ifndef IV_MAX
#  define IV_MAX                         PERL_LONG_MAX
#endif

#ifndef UV_MIN
#  define UV_MIN                         PERL_ULONG_MIN
#endif

#ifndef UV_MAX
#  define UV_MAX                         PERL_ULONG_MAX
#endif

#endif

#ifndef IVSIZE
#  ifdef LONGSIZE
#    define IVSIZE LONGSIZE
#  else
#    define IVSIZE 4 /* A bold guess, but the best we can make. */
#  endif
#endif
#ifndef UVTYPE
#  define UVTYPE                         unsigned IVTYPE
#endif

#ifndef UVSIZE
#  define UVSIZE                         IVSIZE
#endif

#ifndef sv_setuv
#  define sv_setuv(sv, uv)                  \
   STMT_START {                             \
       UV TeMpUv = uv;                      \
       if (TeMpUv <= IV_MAX)                \
           sv_setiv(sv, TeMpUv);            \
       else                                 \
           sv_setnv(sv, (double)TeMpUv);    \
   } STMT_END
#endif

#ifndef newSVuv
#  define newSVuv(uv) ((uv) <= IV_MAX ? newSViv((IV)uv) : newSVnv((NV)uv))
#endif
#ifndef sv_2uv
#  define sv_2uv(sv)                     ((PL_Sv = (sv)), (UV) (SvNOK(PL_Sv) ? SvNV(PL_Sv) : sv_2nv(PL_Sv)))
#endif

#ifndef SvUVX
#  define SvUVX(sv)                      ((UV)SvIVX(sv))
#endif

#ifndef SvUVXx
#  define SvUVXx(sv)                     SvUVX(sv)
#endif

#ifndef SvUV
#  define SvUV(sv)                       (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
#endif

#ifndef SvUVx
#  define SvUVx(sv)                      ((PL_Sv = (sv)), SvUV(PL_Sv))
#endif

/* Hint: sv_uv
 * Always use the SvUVx() macro instead of sv_uv().
 */
#ifndef sv_uv
#  define sv_uv(sv)                      SvUVx(sv)
#endif
#ifndef XST_mUV
#  define XST_mUV(i,v)                   (ST(i) = sv_2mortal(newSVuv(v))  )
#endif

#ifndef XSRETURN_UV
#  define XSRETURN_UV(v)                 STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
#endif
#ifndef PUSHu
#  define PUSHu(u)                       STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG;  } STMT_END
#endif

#ifndef XPUSHu
#  define XPUSHu(u)                      STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
#endif

#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 5))
/* Replace: 1 */
#  define PL_DBsingle               DBsingle
#  define PL_DBsub                  DBsub
#  define PL_Sv                     Sv
#  define PL_compiling              compiling
#  define PL_copline                copline
#  define PL_curcop                 curcop
#  define PL_curstash               curstash
#  define PL_debstash               debstash
#  define PL_defgv                  defgv
#  define PL_diehook                diehook
#  define PL_dirty                  dirty
#  define PL_dowarn                 dowarn
#  define PL_errgv                  errgv
#  define PL_hexdigit               hexdigit
#  define PL_hints                  hints
#  define PL_na	                    na
#  define PL_no_modify              no_modify
#  define PL_perl_destruct_level    perl_destruct_level
#  define PL_perldb                 perldb
#  define PL_ppaddr                 ppaddr
#  define PL_rsfp_filters           rsfp_filters
#  define PL_rsfp                   rsfp
#  define PL_stack_base             stack_base
#  define PL_stack_sp               stack_sp
#  define PL_stdingv                stdingv
#  define PL_sv_arenaroot           sv_arenaroot
#  define PL_sv_no                  sv_no
#  define PL_sv_undef               sv_undef
#  define PL_sv_yes                 sv_yes
#  define PL_tainted                tainted
#  define PL_tainting               tainting
/* Replace: 0 */
#endif

#ifndef PERL_UNUSED_DECL
#  ifdef HASATTRIBUTE
#    if (defined(__GNUC__) && defined(__cplusplus)) || defined(__INTEL_COMPILER)
#      define PERL_UNUSED_DECL
#    else
#      define PERL_UNUSED_DECL __attribute__((unused))
#    endif
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif
#ifndef NOOP
#  define NOOP                           (void)0
#endif

#ifndef dNOOP
#  define dNOOP                          extern int Perl___notused PERL_UNUSED_DECL
#endif

#ifndef NVTYPE
#  if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE)
#    define NVTYPE long double
#  else
#    define NVTYPE double
#  endif
typedef NVTYPE NV;
#endif

#ifndef INT2PTR

#  if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#    define PTRV                  UV
#    define INT2PTR(any,d)        (any)(d)
#  else
#    if PTRSIZE == LONGSIZE
#      define PTRV                unsigned long
#    else
#      define PTRV                unsigned
#    endif
#    define INT2PTR(any,d)        (any)(PTRV)(d)
#  endif

#  define NUM2PTR(any,d)  (any)(PTRV)(d)
#  define PTR2IV(p)       INT2PTR(IV,p)
#  define PTR2UV(p)       INT2PTR(UV,p)
#  define PTR2NV(p)       NUM2PTR(NV,p)

#  if PTRSIZE == LONGSIZE
#    define PTR2ul(p)     (unsigned long)(p)
#  else
#    define PTR2ul(p)     INT2PTR(unsigned long,p)
#  endif

#endif /* !INT2PTR */

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

#ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  if defined(__STRICT_ANSI__) && defined(PERL_GCC_PEDANTIC)
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

#undef STMT_START
#undef STMT_END
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
#  define STMT_START	(void)(	/* gcc supports ``({ STATEMENTS; })'' */
#  define STMT_END	)
#else
#  if defined(VOIDFLAGS) && (VOIDFLAGS) && (defined(sun) || defined(__sun__)) && !defined(__GNUC__)
#    define STMT_START	if (1)
#    define STMT_END	else (void)0
#  else
#    define STMT_START	do
#    define STMT_END	while (0)
#  endif
#endif
#ifndef boolSV
#  define boolSV(b)                      ((b) ? &PL_sv_yes : &PL_sv_no)
#endif

/* DEFSV appears first in 5.004_56 */
#ifndef DEFSV
#  define DEFSV                          GvSV(PL_defgv)
#endif

#ifndef SAVE_DEFSV
#  define SAVE_DEFSV                     SAVESPTR(GvSV(PL_defgv))
#endif

/* Older perls (<=5.003) lack AvFILLp */
#ifndef AvFILLp
#  define AvFILLp                        AvFILL
#endif
#ifndef ERRSV
#  define ERRSV                          get_sv("@",FALSE)
#endif
#ifndef newSVpvn
#  define newSVpvn(data,len)             ((data)                                              \
                                    ? ((len) ? newSVpv((data), (len)) : newSVpv("", 0)) \
                                    : newSV(0))
#endif

/* Hint: gv_stashpvn
 * This function's backport doesn't support the length parameter, but
 * rather ignores it. Portability can only be ensured if the length
 * parameter is used for speed reasons, but the length can always be
 * correctly computed from the string argument.
 */
#ifndef gv_stashpvn
#  define gv_stashpvn(str,len,create)    gv_stashpv(str,create)
#endif

/* Replace: 1 */
#ifndef get_cv
#  define get_cv                         perl_get_cv
#endif

#ifndef get_sv
#  define get_sv                         perl_get_sv
#endif

#ifndef get_av
#  define get_av                         perl_get_av
#endif

#ifndef get_hv
#  define get_hv                         perl_get_hv
#endif

/* Replace: 0 */

#ifdef HAS_MEMCMP
#ifndef memNE
#  define memNE(s1,s2,l)                 (memcmp(s1,s2,l))
#endif

#ifndef memEQ
#  define memEQ(s1,s2,l)                 (!memcmp(s1,s2,l))
#endif

#else
#ifndef memNE
#  define memNE(s1,s2,l)                 (bcmp(s1,s2,l))
#endif

#ifndef memEQ
#  define memEQ(s1,s2,l)                 (!bcmp(s1,s2,l))
#endif

#endif
#ifndef MoveD
#  define MoveD(s,d,n,t)                 memmove((char*)(d),(char*)(s), (n) * sizeof(t))
#endif

#ifndef CopyD
#  define CopyD(s,d,n,t)                 memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
#endif

#ifdef HAS_MEMSET
#ifndef ZeroD
#  define ZeroD(d,n,t)                   memzero((char*)(d), (n) * sizeof(t))
#endif

#else
#ifndef ZeroD
#  define ZeroD(d,n,t)                   ((void)memzero((char*)(d), (n) * sizeof(t)),d)
#endif

#endif
#ifndef Poison
#  define Poison(d,n,t)                  (void)memset((char*)(d), 0xAB, (n) * sizeof(t))
#endif
#ifndef dUNDERBAR
#  define dUNDERBAR                      dNOOP
#endif

#ifndef UNDERBAR
#  define UNDERBAR                       DEFSV
#endif
#ifndef dAX
#  define dAX                            I32 ax = MARK - PL_stack_base + 1
#endif

#ifndef dITEMS
#  define dITEMS                         I32 items = SP - MARK
#endif
#ifndef dXSTARG
#  define dXSTARG                        SV * targ = sv_newmortal()
#endif
#ifndef dTHR
#  define dTHR                           dNOOP
#endif
#ifndef dTHX
#  define dTHX                           dNOOP
#endif

#ifndef dTHXa
#  define dTHXa(x)                       dNOOP
#endif
#ifndef pTHX
#  define pTHX                           void
#endif

#ifndef pTHX_
#  define pTHX_
#endif

#ifndef aTHX
#  define aTHX
#endif

#ifndef aTHX_
#  define aTHX_
#endif
#ifndef dTHXoa
#  define dTHXoa(x)                      dTHXa(x)
#endif
#ifndef PUSHmortal
#  define PUSHmortal                     PUSHs(sv_newmortal())
#endif

#ifndef mPUSHp
#  define mPUSHp(p,l)                    sv_setpvn_mg(PUSHmortal, (p), (l))
#endif

#ifndef mPUSHn
#  define mPUSHn(n)                      sv_setnv_mg(PUSHmortal, (NV)(n))
#endif

#ifndef mPUSHi
#  define mPUSHi(i)                      sv_setiv_mg(PUSHmortal, (IV)(i))
#endif

#ifndef mPUSHu
#  define mPUSHu(u)                      sv_setuv_mg(PUSHmortal, (UV)(u))
#endif
#ifndef XPUSHmortal
#  define XPUSHmortal                    XPUSHs(sv_newmortal())
#endif

#ifndef mXPUSHp
#  define mXPUSHp(p,l)                   STMT_START { EXTEND(sp,1); sv_setpvn_mg(PUSHmortal, (p), (l)); } STMT_END
#endif

#ifndef mXPUSHn
#  define mXPUSHn(n)                     STMT_START { EXTEND(sp,1); sv_setnv_mg(PUSHmortal, (NV)(n)); } STMT_END
#endif

#ifndef mXPUSHi
#  define mXPUSHi(i)                     STMT_START { EXTEND(sp,1); sv_setiv_mg(PUSHmortal, (IV)(i)); } STMT_END
#endif

#ifndef mXPUSHu
#  define mXPUSHu(u)                     STMT_START { EXTEND(sp,1); sv_setuv_mg(PUSHmortal, (UV)(u)); } STMT_END
#endif

/* Replace: 1 */
#ifndef call_sv
#  define call_sv                        perl_call_sv
#endif

#ifndef call_pv
#  define call_pv                        perl_call_pv
#endif

#ifndef call_argv
#  define call_argv                      perl_call_argv
#endif

#ifndef call_method
#  define call_method                    perl_call_method
#endif
#ifndef eval_sv
#  define eval_sv                        perl_eval_sv
#endif

/* Replace: 0 */

/* Replace perl_eval_pv with eval_pv */
/* eval_pv depends on eval_sv */

#ifndef eval_pv
#if defined(NEED_eval_pv)
static SV* DPPP_(my_eval_pv)(char *p, I32 croak_on_error);
static
#else
extern SV* DPPP_(my_eval_pv)(char *p, I32 croak_on_error);
#endif

#ifdef eval_pv
#  undef eval_pv
#endif
#define eval_pv(a,b) DPPP_(my_eval_pv)(aTHX_ a,b)
#define Perl_eval_pv DPPP_(my_eval_pv)

#if defined(NEED_eval_pv) || defined(NEED_eval_pv_GLOBAL)

SV*
DPPP_(my_eval_pv)(char *p, I32 croak_on_error)
{
    dSP;
    SV* sv = newSVpv(p, 0);

    PUSHMARK(sp);
    eval_sv(sv, G_SCALAR);
    SvREFCNT_dec(sv);

    SPAGAIN;
    sv = POPs;
    PUTBACK;

    if (croak_on_error && SvTRUE(GvSV(errgv)))
	croak(SvPVx(GvSV(errgv), na));

    return sv;
}

#endif
#endif
#ifndef newRV_inc
#  define newRV_inc(sv)                  newRV(sv)   /* Replace */
#endif

#ifndef newRV_noinc
#if defined(NEED_newRV_noinc)
static SV * DPPP_(my_newRV_noinc)(SV *sv);
static
#else
extern SV * DPPP_(my_newRV_noinc)(SV *sv);
#endif

#ifdef newRV_noinc
#  undef newRV_noinc
#endif
#define newRV_noinc(a) DPPP_(my_newRV_noinc)(aTHX_ a)
#define Perl_newRV_noinc DPPP_(my_newRV_noinc)

#if defined(NEED_newRV_noinc) || defined(NEED_newRV_noinc_GLOBAL)
SV *
DPPP_(my_newRV_noinc)(SV *sv)
{
  SV *rv = (SV *)newRV(sv);
  SvREFCNT_dec(sv);
  return rv;
}
#endif
#endif

/* Hint: newCONSTSUB
 * Returns a CV* as of perl-5.7.1. This return value is not supported
 * by Devel::PPPort.
 */

/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
#if ((PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION < 63))) && ((PERL_VERSION != 4) || (PERL_SUBVERSION != 5))
#if defined(NEED_newCONSTSUB)
static void DPPP_(my_newCONSTSUB)(HV *stash, char *name, SV *sv);
static
#else
extern void DPPP_(my_newCONSTSUB)(HV *stash, char *name, SV *sv);
#endif

#ifdef newCONSTSUB
#  undef newCONSTSUB
#endif
#define newCONSTSUB(a,b,c) DPPP_(my_newCONSTSUB)(aTHX_ a,b,c)
#define Perl_newCONSTSUB DPPP_(my_newCONSTSUB)

#if defined(NEED_newCONSTSUB) || defined(NEED_newCONSTSUB_GLOBAL)

void
DPPP_(my_newCONSTSUB)(HV *stash, char *name, SV *sv)
{
	U32 oldhints = PL_hints;
	HV *old_cop_stash = PL_curcop->cop_stash;
	HV *old_curstash = PL_curstash;
	line_t oldline = PL_curcop->cop_line;
	PL_curcop->cop_line = PL_copline;

	PL_hints &= ~HINT_BLOCK_SCOPE;
	if (stash)
		PL_curstash = PL_curcop->cop_stash = stash;

	newSUB(

#if   ((PERL_VERSION < 3) || ((PERL_VERSION == 3) && (PERL_SUBVERSION < 22)))
		start_subparse(),
#elif ((PERL_VERSION == 3) && (PERL_SUBVERSION == 22))
     		start_subparse(0),
#else  /* 5.003_23  onwards */
     		start_subparse(FALSE, 0),
#endif

		newSVOP(OP_CONST, 0, newSVpv(name,0)),
		newSVOP(OP_CONST, 0, &PL_sv_no),   /* SvPV(&PL_sv_no) == "" -- GMB */
		newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
	);

	PL_hints = oldhints;
	PL_curcop->cop_stash = old_cop_stash;
	PL_curstash = old_curstash;
	PL_curcop->cop_line = oldline;
}
#endif
#endif

/*
 * Boilerplate macros for initializing and accessing interpreter-local
 * data from C.  All statics in extensions should be reworked to use
 * this, if you want to make the extension thread-safe.  See ext/re/re.xs
 * for an example of the use of these macros.
 *
 * Code that uses these macros is responsible for the following:
 * 1. #define MY_CXT_KEY to a unique string, e.g. "DynaLoader_guts"
 * 2. Declare a typedef named my_cxt_t that is a structure that contains
 *    all the data that needs to be interpreter-local.
 * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
 * 4. Use the MY_CXT_INIT macro such that it is called exactly once
 *    (typically put in the BOOT: section).
 * 5. Use the members of the my_cxt_t structure everywhere as
 *    MY_CXT.member.
 * 6. Use the dMY_CXT macro (a declaration) in all the functions that
 *    access MY_CXT.
 */

#if defined(MULTIPLICITY) || defined(PERL_OBJECT) || \
    defined(PERL_CAPI)    || defined(PERL_IMPLICIT_CONTEXT)

#ifndef START_MY_CXT

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT

#if (PERL_VERSION < 4 || (PERL_VERSION == 4 && PERL_SUBVERSION < 68 ))
/* Fetches the SV that keeps the per-interpreter data. */
#define dMY_CXT_SV \
	SV *my_cxt_sv = get_sv(MY_CXT_KEY, FALSE)
#else /* >= perl5.004_68 */
#define dMY_CXT_SV \
	SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,		\
				  sizeof(MY_CXT_KEY)-1, TRUE)
#endif /* < perl5.004_68 */

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT	\
	dMY_CXT_SV;							\
	my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*,SvUV(my_cxt_sv))

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
	dMY_CXT_SV;							\
	/* newSV() allocates one more than needed */			\
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Zero(my_cxtp, 1, my_cxt_t);					\
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))

/* This macro must be used to access members of the my_cxt_t structure.
 * e.g. MYCXT.some_data */
#define MY_CXT		(*my_cxtp)

/* Judicious use of these macros can reduce the number of times dMY_CXT
 * is used.  Use is similar to pTHX, aTHX etc. */
#define pMY_CXT		my_cxt_t *my_cxtp
#define pMY_CXT_	pMY_CXT,
#define _pMY_CXT	,pMY_CXT
#define aMY_CXT		my_cxtp
#define aMY_CXT_	aMY_CXT,
#define _aMY_CXT	,aMY_CXT

#endif /* START_MY_CXT */

#ifndef MY_CXT_CLONE
/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
	dMY_CXT_SV;							\
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t);\
	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
#endif

#else /* single interpreter */

#ifndef START_MY_CXT

#define START_MY_CXT	static my_cxt_t my_cxt;
#define dMY_CXT_SV	dNOOP
#define dMY_CXT		dNOOP
#define MY_CXT_INIT	NOOP
#define MY_CXT		my_cxt

#define pMY_CXT		void
#define pMY_CXT_
#define _pMY_CXT
#define aMY_CXT
#define aMY_CXT_
#define _aMY_CXT

#endif /* START_MY_CXT */

#ifndef MY_CXT_CLONE
#define MY_CXT_CLONE	NOOP
#endif

#endif

#ifndef IVdf
#  if IVSIZE == LONGSIZE
#    define	IVdf      "ld"
#    define	UVuf      "lu"
#    define	UVof      "lo"
#    define	UVxf      "lx"
#    define	UVXf      "lX"
#  else
#    if IVSIZE == INTSIZE
#      define	IVdf      "d"
#      define	UVuf      "u"
#      define	UVof      "o"
#      define	UVxf      "x"
#      define	UVXf      "X"
#    endif
#  endif
#endif

#ifndef NVef
#  if defined(USE_LONG_DOUBLE) && defined(HAS_LONG_DOUBLE) && \
      defined(PERL_PRIfldbl) /* Not very likely, but let's try anyway. */
#    define NVef          PERL_PRIeldbl
#    define NVff          PERL_PRIfldbl
#    define NVgf          PERL_PRIgldbl
#  else
#    define NVef          "e"
#    define NVff          "f"
#    define NVgf          "g"
#  endif
#endif

#ifndef SvPV_nolen

#if defined(NEED_sv_2pv_nolen)
static char * DPPP_(my_sv_2pv_nolen)(pTHX_ register SV *sv);
static
#else
extern char * DPPP_(my_sv_2pv_nolen)(pTHX_ register SV *sv);
#endif

#ifdef sv_2pv_nolen
#  undef sv_2pv_nolen
#endif
#define sv_2pv_nolen(a) DPPP_(my_sv_2pv_nolen)(aTHX_ a)
#define Perl_sv_2pv_nolen DPPP_(my_sv_2pv_nolen)

#if defined(NEED_sv_2pv_nolen) || defined(NEED_sv_2pv_nolen_GLOBAL)

char *
DPPP_(my_sv_2pv_nolen)(pTHX_ register SV *sv)
{
  STRLEN n_a;
  return sv_2pv(sv, &n_a);
}

#endif

/* Hint: sv_2pv_nolen
 * Use the SvPV_nolen() macro instead of sv_2pv_nolen().
 */

/* SvPV_nolen depends on sv_2pv_nolen */
#define SvPV_nolen(sv) \
          ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
           ? SvPVX(sv) : sv_2pv_nolen(sv))

#endif

#ifdef SvPVbyte

/* Hint: SvPVbyte
 * Does not work in perl-5.6.1, ppport.h implements a version
 * borrowed from perl-5.7.3.
 */

#if ((PERL_VERSION < 7) || ((PERL_VERSION == 7) && (PERL_SUBVERSION < 0)))

#if defined(NEED_sv_2pvbyte)
static char * DPPP_(my_sv_2pvbyte)(pTHX_ register SV *sv, STRLEN *lp);
static
#else
extern char * DPPP_(my_sv_2pvbyte)(pTHX_ register SV *sv, STRLEN *lp);
#endif

#ifdef sv_2pvbyte
#  undef sv_2pvbyte
#endif
#define sv_2pvbyte(a,b) DPPP_(my_sv_2pvbyte)(aTHX_ a,b)
#define Perl_sv_2pvbyte DPPP_(my_sv_2pvbyte)

#if defined(NEED_sv_2pvbyte) || defined(NEED_sv_2pvbyte_GLOBAL)

char *
DPPP_(my_sv_2pvbyte)(pTHX_ register SV *sv, STRLEN *lp)
{
  sv_utf8_downgrade(sv,0);
  return SvPV(sv,*lp);
}

#endif

/* Hint: sv_2pvbyte
 * Use the SvPVbyte() macro instead of sv_2pvbyte().
 */

#undef SvPVbyte

/* SvPVbyte depends on sv_2pvbyte */
#define SvPVbyte(sv, lp)                                                \
        ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK)                \
         ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#endif

#else

#  define SvPVbyte          SvPV
#  define sv_2pvbyte        sv_2pv

#endif

/* sv_2pvbyte_nolen depends on sv_2pv_nolen */
#ifndef sv_2pvbyte_nolen
#  define sv_2pvbyte_nolen               sv_2pv_nolen
#endif

/* Hint: sv_pvn
 * Always use the SvPV() macro instead of sv_pvn().
 */
#ifndef sv_pvn
#  define sv_pvn(sv, len)                SvPV(sv, len)
#endif

/* Hint: sv_pvn_force
 * Always use the SvPV_force() macro instead of sv_pvn_force().
 */
#ifndef sv_pvn_force
#  define sv_pvn_force(sv, len)          SvPV_force(sv, len)
#endif

#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(vnewSVpvf)
#if defined(NEED_vnewSVpvf)
static SV * DPPP_(my_vnewSVpvf)(pTHX_ const char * pat, va_list * args);
static
#else
extern SV * DPPP_(my_vnewSVpvf)(pTHX_ const char * pat, va_list * args);
#endif

#ifdef vnewSVpvf
#  undef vnewSVpvf
#endif
#define vnewSVpvf(a,b) DPPP_(my_vnewSVpvf)(aTHX_ a,b)
#define Perl_vnewSVpvf DPPP_(my_vnewSVpvf)

#if defined(NEED_vnewSVpvf) || defined(NEED_vnewSVpvf_GLOBAL)

SV *
DPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)
{
  register SV *sv = newSV(0);
  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));
  return sv;
}

#endif
#endif

/* sv_vcatpvf depends on sv_vcatpvfn */
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_vcatpvf)
#  define sv_vcatpvf(sv, pat, args)  sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
#endif

/* sv_vsetpvf depends on sv_vsetpvfn */
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_vsetpvf)
#  define sv_vsetpvf(sv, pat, args)  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
#endif

/* sv_catpvf_mg depends on sv_vcatpvfn, sv_catpvf_mg_nocontext */
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_catpvf_mg)
#if defined(NEED_sv_catpvf_mg)
static void DPPP_(my_sv_catpvf_mg)(pTHX_ SV * sv, const char * pat, ...);
static
#else
extern void DPPP_(my_sv_catpvf_mg)(pTHX_ SV * sv, const char * pat, ...);
#endif

#define Perl_sv_catpvf_mg DPPP_(my_sv_catpvf_mg)

#if defined(NEED_sv_catpvf_mg) || defined(NEED_sv_catpvf_mg_GLOBAL)

void
DPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...)
{
  va_list args;
  va_start(args, pat);
  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif

/* sv_catpvf_mg_nocontext depends on sv_vcatpvfn */
#ifdef PERL_IMPLICIT_CONTEXT
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_catpvf_mg_nocontext)
#if defined(NEED_sv_catpvf_mg_nocontext)
static void DPPP_(my_sv_catpvf_mg_nocontext)(SV * sv, const char * pat, ...);
static
#else
extern void DPPP_(my_sv_catpvf_mg_nocontext)(SV * sv, const char * pat, ...);
#endif

#define sv_catpvf_mg_nocontext DPPP_(my_sv_catpvf_mg_nocontext)
#define Perl_sv_catpvf_mg_nocontext DPPP_(my_sv_catpvf_mg_nocontext)

#if defined(NEED_sv_catpvf_mg_nocontext) || defined(NEED_sv_catpvf_mg_nocontext_GLOBAL)

void
DPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...)
{
  dTHX;
  va_list args;
  va_start(args, pat);
  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif
#endif

#ifndef sv_catpvf_mg
#  ifdef PERL_IMPLICIT_CONTEXT
#    define sv_catpvf_mg   Perl_sv_catpvf_mg_nocontext
#  else
#    define sv_catpvf_mg   Perl_sv_catpvf_mg
#  endif
#endif

/* sv_vcatpvf_mg depends on sv_vcatpvfn */
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_vcatpvf_mg)
#  define sv_vcatpvf_mg(sv, pat, args)                                     \
   STMT_START {                                                            \
     sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \
     SvSETMAGIC(sv);                                                       \
   } STMT_END
#endif

/* sv_setpvf_mg depends on sv_vsetpvfn, sv_setpvf_mg_nocontext */
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_setpvf_mg)
#if defined(NEED_sv_setpvf_mg)
static void DPPP_(my_sv_setpvf_mg)(pTHX_ SV * sv, const char * pat, ...);
static
#else
extern void DPPP_(my_sv_setpvf_mg)(pTHX_ SV * sv, const char * pat, ...);
#endif

#define Perl_sv_setpvf_mg DPPP_(my_sv_setpvf_mg)

#if defined(NEED_sv_setpvf_mg) || defined(NEED_sv_setpvf_mg_GLOBAL)

void
DPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...)
{
  va_list args;
  va_start(args, pat);
  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif

/* sv_setpvf_mg_nocontext depends on sv_vsetpvfn */
#ifdef PERL_IMPLICIT_CONTEXT
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_setpvf_mg_nocontext)
#if defined(NEED_sv_setpvf_mg_nocontext)
static void DPPP_(my_sv_setpvf_mg_nocontext)(SV * sv, const char * pat, ...);
static
#else
extern void DPPP_(my_sv_setpvf_mg_nocontext)(SV * sv, const char * pat, ...);
#endif

#define sv_setpvf_mg_nocontext DPPP_(my_sv_setpvf_mg_nocontext)
#define Perl_sv_setpvf_mg_nocontext DPPP_(my_sv_setpvf_mg_nocontext)

#if defined(NEED_sv_setpvf_mg_nocontext) || defined(NEED_sv_setpvf_mg_nocontext_GLOBAL)

void
DPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...)
{
  dTHX;
  va_list args;
  va_start(args, pat);
  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));
  SvSETMAGIC(sv);
  va_end(args);
}

#endif
#endif
#endif

#ifndef sv_setpvf_mg
#  ifdef PERL_IMPLICIT_CONTEXT
#    define sv_setpvf_mg   Perl_sv_setpvf_mg_nocontext
#  else
#    define sv_setpvf_mg   Perl_sv_setpvf_mg
#  endif
#endif

/* sv_vsetpvf_mg depends on sv_vsetpvfn */
#if ((PERL_VERSION > 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION >= 0))) && !defined(sv_vsetpvf_mg)
#  define sv_vsetpvf_mg(sv, pat, args)                                     \
   STMT_START {                                                            \
     sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \
     SvSETMAGIC(sv);                                                       \
   } STMT_END
#endif
#ifndef SvGETMAGIC
#  define SvGETMAGIC(x)                  STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
#endif
#ifndef PERL_MAGIC_sv
#  define PERL_MAGIC_sv                  '\0'
#endif

#ifndef PERL_MAGIC_overload
#  define PERL_MAGIC_overload            'A'
#endif

#ifndef PERL_MAGIC_overload_elem
#  define PERL_MAGIC_overload_elem       'a'
#endif

#ifndef PERL_MAGIC_overload_table
#  define PERL_MAGIC_overload_table      'c'
#endif

#ifndef PERL_MAGIC_bm
#  define PERL_MAGIC_bm                  'B'
#endif

#ifndef PERL_MAGIC_regdata
#  define PERL_MAGIC_regdata             'D'
#endif

#ifndef PERL_MAGIC_regdatum
#  define PERL_MAGIC_regdatum            'd'
#endif

#ifndef PERL_MAGIC_env
#  define PERL_MAGIC_env                 'E'
#endif

#ifndef PERL_MAGIC_envelem
#  define PERL_MAGIC_envelem             'e'
#endif

#ifndef PERL_MAGIC_fm
#  define PERL_MAGIC_fm                  'f'
#endif

#ifndef PERL_MAGIC_regex_global
#  define PERL_MAGIC_regex_global        'g'
#endif

#ifndef PERL_MAGIC_isa
#  define PERL_MAGIC_isa                 'I'
#endif

#ifndef PERL_MAGIC_isaelem
#  define PERL_MAGIC_isaelem             'i'
#endif

#ifndef PERL_MAGIC_nkeys
#  define PERL_MAGIC_nkeys               'k'
#endif

#ifndef PERL_MAGIC_dbfile
#  define PERL_MAGIC_dbfile              'L'
#endif

#ifndef PERL_MAGIC_dbline
#  define PERL_MAGIC_dbline              'l'
#endif

#ifndef PERL_MAGIC_mutex
#  define PERL_MAGIC_mutex               'm'
#endif

#ifndef PERL_MAGIC_shared
#  define PERL_MAGIC_shared              'N'
#endif

#ifndef PERL_MAGIC_shared_scalar
#  define PERL_MAGIC_shared_scalar       'n'
#endif

#ifndef PERL_MAGIC_collxfrm
#  define PERL_MAGIC_collxfrm            'o'
#endif

#ifndef PERL_MAGIC_tied
#  define PERL_MAGIC_tied                'P'
#endif

#ifndef PERL_MAGIC_tiedelem
#  define PERL_MAGIC_tiedelem            'p'
#endif

#ifndef PERL_MAGIC_tiedscalar
#  define PERL_MAGIC_tiedscalar          'q'
#endif

#ifndef PERL_MAGIC_qr
#  define PERL_MAGIC_qr                  'r'
#endif

#ifndef PERL_MAGIC_sig
#  define PERL_MAGIC_sig                 'S'
#endif

#ifndef PERL_MAGIC_sigelem
#  define PERL_MAGIC_sigelem             's'
#endif

#ifndef PERL_MAGIC_taint
#  define PERL_MAGIC_taint               't'
#endif

#ifndef PERL_MAGIC_uvar
#  define PERL_MAGIC_uvar                'U'
#endif

#ifndef PERL_MAGIC_uvar_elem
#  define PERL_MAGIC_uvar_elem           'u'
#endif

#ifndef PERL_MAGIC_vstring
#  define PERL_MAGIC_vstring             'V'
#endif

#ifndef PERL_MAGIC_vec
#  define PERL_MAGIC_vec                 'v'
#endif

#ifndef PERL_MAGIC_utf8
#  define PERL_MAGIC_utf8                'w'
#endif

#ifndef PERL_MAGIC_substr
#  define PERL_MAGIC_substr              'x'
#endif

#ifndef PERL_MAGIC_defelem
#  define PERL_MAGIC_defelem             'y'
#endif

#ifndef PERL_MAGIC_glob
#  define PERL_MAGIC_glob                '*'
#endif

#ifndef PERL_MAGIC_arylen
#  define PERL_MAGIC_arylen              '#'
#endif

#ifndef PERL_MAGIC_pos
#  define PERL_MAGIC_pos                 '.'
#endif

#ifndef PERL_MAGIC_backref
#  define PERL_MAGIC_backref             '<'
#endif

#ifndef PERL_MAGIC_ext
#  define PERL_MAGIC_ext                 '~'
#endif

/* That's the best we can do... */
#ifndef SvPV_force_nomg
#  define SvPV_force_nomg                SvPV_force
#endif

#ifndef SvPV_nomg
#  define SvPV_nomg                      SvPV
#endif

#ifndef sv_catpvn_nomg
#  define sv_catpvn_nomg                 sv_catpvn
#endif

#ifndef sv_catsv_nomg
#  define sv_catsv_nomg                  sv_catsv
#endif

#ifndef sv_setsv_nomg
#  define sv_setsv_nomg                  sv_setsv
#endif

#ifndef sv_pvn_nomg
#  define sv_pvn_nomg                    sv_pvn
#endif

#ifndef SvIV_nomg
#  define SvIV_nomg                      SvIV
#endif

#ifndef SvUV_nomg
#  define SvUV_nomg                      SvUV
#endif

#ifndef sv_catpv_mg
#  define sv_catpv_mg(sv, ptr)          \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_catpv(TeMpSv,ptr);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_catpvn_mg
#  define sv_catpvn_mg(sv, ptr, len)    \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_catpvn(TeMpSv,ptr,len);         \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_catsv_mg
#  define sv_catsv_mg(dsv, ssv)         \
   STMT_START {                         \
     SV *TeMpSv = dsv;                  \
     sv_catsv(TeMpSv,ssv);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setiv_mg
#  define sv_setiv_mg(sv, i)            \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setiv(TeMpSv,i);                \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setnv_mg
#  define sv_setnv_mg(sv, num)          \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setnv(TeMpSv,num);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setpv_mg
#  define sv_setpv_mg(sv, ptr)          \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setpv(TeMpSv,ptr);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setpvn_mg
#  define sv_setpvn_mg(sv, ptr, len)    \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setpvn(TeMpSv,ptr,len);         \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setsv_mg
#  define sv_setsv_mg(dsv, ssv)         \
   STMT_START {                         \
     SV *TeMpSv = dsv;                  \
     sv_setsv(TeMpSv,ssv);              \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_setuv_mg
#  define sv_setuv_mg(sv, i)            \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_setuv(TeMpSv,i);                \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifndef sv_usepvn_mg
#  define sv_usepvn_mg(sv, ptr, len)    \
   STMT_START {                         \
     SV *TeMpSv = sv;                   \
     sv_usepvn(TeMpSv,ptr,len);         \
     SvSETMAGIC(TeMpSv);                \
   } STMT_END
#endif

#ifdef USE_ITHREADS
#ifndef CopFILE
#  define CopFILE(c)                     ((c)->cop_file)
#endif

#ifndef CopFILEGV
#  define CopFILEGV(c)                   (CopFILE(c) ? gv_fetchfile(CopFILE(c)) : Nullgv)
#endif

#ifndef CopFILE_set
#  define CopFILE_set(c,pv)              ((c)->cop_file = savepv(pv))
#endif

#ifndef CopFILESV
#  define CopFILESV(c)                   (CopFILE(c) ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
#endif

#ifndef CopFILEAV
#  define CopFILEAV(c)                   (CopFILE(c) ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
#endif

#ifndef CopSTASHPV
#  define CopSTASHPV(c)                  ((c)->cop_stashpv)
#endif

#ifndef CopSTASHPV_set
#  define CopSTASHPV_set(c,pv)           ((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
#endif

#ifndef CopSTASH
#  define CopSTASH(c)                    (CopSTASHPV(c) ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
#endif

#ifndef CopSTASH_set
#  define CopSTASH_set(c,hv)             CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
#endif

#ifndef CopSTASH_eq
#  define CopSTASH_eq(c,hv)              ((hv) && (CopSTASHPV(c) == HvNAME(hv) \
					|| (CopSTASHPV(c) && HvNAME(hv) \
					&& strEQ(CopSTASHPV(c), HvNAME(hv)))))
#endif

#else
#ifndef CopFILEGV
#  define CopFILEGV(c)                   ((c)->cop_filegv)
#endif

#ifndef CopFILEGV_set
#  define CopFILEGV_set(c,gv)            ((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#endif

#ifndef CopFILE_set
#  define CopFILE_set(c,pv)              CopFILEGV_set((c), gv_fetchfile(pv))
#endif

#ifndef CopFILESV
#  define CopFILESV(c)                   (CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
#endif

#ifndef CopFILEAV
#  define CopFILEAV(c)                   (CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
#endif

#ifndef CopFILE
#  define CopFILE(c)                     (CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
#endif

#ifndef CopSTASH
#  define CopSTASH(c)                    ((c)->cop_stash)
#endif

#ifndef CopSTASH_set
#  define CopSTASH_set(c,hv)             ((c)->cop_stash = (hv))
#endif

#ifndef CopSTASHPV
#  define CopSTASHPV(c)                  (CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
#endif

#ifndef CopSTASHPV_set
#  define CopSTASHPV_set(c,pv)           CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#endif

#ifndef CopSTASH_eq
#  define CopSTASH_eq(c,hv)              (CopSTASH(c) == (hv))
#endif

#endif /* USE_ITHREADS */
#ifndef IN_PERL_COMPILETIME
#  define IN_PERL_COMPILETIME            (PL_curcop == &PL_compiling)
#endif

#ifndef IN_LOCALE_RUNTIME
#  define IN_LOCALE_RUNTIME              (PL_curcop->op_private & HINT_LOCALE)
#endif

#ifndef IN_LOCALE_COMPILETIME
#  define IN_LOCALE_COMPILETIME          (PL_hints & HINT_LOCALE)
#endif

#ifndef IN_LOCALE
#  define IN_LOCALE                      (IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
#endif
#ifndef IS_NUMBER_IN_UV
#  define IS_NUMBER_IN_UV                0x01
#endif

#ifndef IS_NUMBER_GREATER_THAN_UV_MAX
#  define IS_NUMBER_GREATER_THAN_UV_MAX  0x02
#endif

#ifndef IS_NUMBER_NOT_INT
#  define IS_NUMBER_NOT_INT              0x04
#endif

#ifndef IS_NUMBER_NEG
#  define IS_NUMBER_NEG                  0x08
#endif

#ifndef IS_NUMBER_INFINITY
#  define IS_NUMBER_INFINITY             0x10
#endif

#ifndef IS_NUMBER_NAN
#  define IS_NUMBER_NAN                  0x20
#endif

/* GROK_NUMERIC_RADIX depends on grok_numeric_radix */
#ifndef GROK_NUMERIC_RADIX
#  define GROK_NUMERIC_RADIX(sp, send)   grok_numeric_radix(sp, send)
#endif
#ifndef PERL_SCAN_GREATER_THAN_UV_MAX
#  define PERL_SCAN_GREATER_THAN_UV_MAX  0x02
#endif

#ifndef PERL_SCAN_SILENT_ILLDIGIT
#  define PERL_SCAN_SILENT_ILLDIGIT      0x04
#endif

#ifndef PERL_SCAN_ALLOW_UNDERSCORES
#  define PERL_SCAN_ALLOW_UNDERSCORES    0x01
#endif

#ifndef PERL_SCAN_DISALLOW_PREFIX
#  define PERL_SCAN_DISALLOW_PREFIX      0x02
#endif

#ifndef grok_numeric_radix
#if defined(NEED_grok_numeric_radix)
static bool DPPP_(my_grok_numeric_radix)(pTHX_ const char ** sp, const char * send);
static
#else
extern bool DPPP_(my_grok_numeric_radix)(pTHX_ const char ** sp, const char * send);
#endif

#ifdef grok_numeric_radix
#  undef grok_numeric_radix
#endif
#define grok_numeric_radix(a,b) DPPP_(my_grok_numeric_radix)(aTHX_ a,b)
#define Perl_grok_numeric_radix DPPP_(my_grok_numeric_radix)

#if defined(NEED_grok_numeric_radix) || defined(NEED_grok_numeric_radix_GLOBAL)
bool
DPPP_(my_grok_numeric_radix)(pTHX_ const char **sp, const char *send)
{
#ifdef USE_LOCALE_NUMERIC
#ifdef PL_numeric_radix_sv
    if (PL_numeric_radix_sv && IN_LOCALE) {
        STRLEN len;
        char* radix = SvPV(PL_numeric_radix_sv, len);
        if (*sp + len <= send && memEQ(*sp, radix, len)) {
            *sp += len;
            return TRUE;
        }
    }
#else
    /* older perls don't have PL_numeric_radix_sv so the radix
     * must manually be requested from locale.h
     */
#include <locale.h>
    dTHR;  /* needed for older threaded perls */
    struct lconv *lc = localeconv();
    char *radix = lc->decimal_point;
    if (radix && IN_LOCALE) {
        STRLEN len = strlen(radix);
        if (*sp + len <= send && memEQ(*sp, radix, len)) {
            *sp += len;
            return TRUE;
        }
    }
#endif /* PERL_VERSION */
#endif /* USE_LOCALE_NUMERIC */
    /* always try "." if numeric radix didn't match because
     * we may have data from different locales mixed */
    if (*sp < send && **sp == '.') {
        ++*sp;
        return TRUE;
    }
    return FALSE;
}
#endif
#endif

/* grok_number depends on grok_numeric_radix */

#ifndef grok_number
#if defined(NEED_grok_number)
static int DPPP_(my_grok_number)(pTHX_ const char * pv, STRLEN len, UV * valuep);
static
#else
extern int DPPP_(my_grok_number)(pTHX_ const char * pv, STRLEN len, UV * valuep);
#endif

#ifdef grok_number
#  undef grok_number
#endif
#define grok_number(a,b,c) DPPP_(my_grok_number)(aTHX_ a,b,c)
#define Perl_grok_number DPPP_(my_grok_number)

#if defined(NEED_grok_number) || defined(NEED_grok_number_GLOBAL)
int
DPPP_(my_grok_number)(pTHX_ const char *pv, STRLEN len, UV *valuep)
{
  const char *s = pv;
  const char *send = pv + len;
  const UV max_div_10 = UV_MAX / 10;
  const char max_mod_10 = UV_MAX % 10;
  int numtype = 0;
  int sawinf = 0;
  int sawnan = 0;

  while (s < send && isSPACE(*s))
    s++;
  if (s == send) {
    return 0;
  } else if (*s == '-') {
    s++;
    numtype = IS_NUMBER_NEG;
  }
  else if (*s == '+')
  s++;

  if (s == send)
    return 0;

  /* next must be digit or the radix separator or beginning of infinity */
  if (isDIGIT(*s)) {
    /* UVs are at least 32 bits, so the first 9 decimal digits cannot
       overflow.  */
    UV value = *s - '0';
    /* This construction seems to be more optimiser friendly.
       (without it gcc does the isDIGIT test and the *s - '0' separately)
       With it gcc on arm is managing 6 instructions (6 cycles) per digit.
       In theory the optimiser could deduce how far to unroll the loop
       before checking for overflow.  */
    if (++s < send) {
      int digit = *s - '0';
      if (digit >= 0 && digit <= 9) {
        value = value * 10 + digit;
        if (++s < send) {
          digit = *s - '0';
          if (digit >= 0 && digit <= 9) {
            value = value * 10 + digit;
            if (++s < send) {
              digit = *s - '0';
              if (digit >= 0 && digit <= 9) {
                value = value * 10 + digit;
		if (++s < send) {
                  digit = *s - '0';
                  if (digit >= 0 && digit <= 9) {
                    value = value * 10 + digit;
                    if (++s < send) {
                      digit = *s - '0';
                      if (digit >= 0 && digit <= 9) {
                        value = value * 10 + digit;
                        if (++s < send) {
                          digit = *s - '0';
                          if (digit >= 0 && digit <= 9) {
                            value = value * 10 + digit;
                            if (++s < send) {
                              digit = *s - '0';
                              if (digit >= 0 && digit <= 9) {
                                value = value * 10 + digit;
                                if (++s < send) {
                                  digit = *s - '0';
                                  if (digit >= 0 && digit <= 9) {
                                    value = value * 10 + digit;
                                    if (++s < send) {
                                      /* Now got 9 digits, so need to check
                                         each time for overflow.  */
                                      digit = *s - '0';
                                      while (digit >= 0 && digit <= 9
                                             && (value < max_div_10
                                                 || (value == max_div_10
                                                     && digit <= max_mod_10))) {
                                        value = value * 10 + digit;
                                        if (++s < send)
                                          digit = *s - '0';
                                        else
                                          break;
                                      }
                                      if (digit >= 0 && digit <= 9
                                          && (s < send)) {
                                        /* value overflowed.
                                           skip the remaining digits, don't
                                           worry about setting *valuep.  */
                                        do {
                                          s++;
                                        } while (s < send && isDIGIT(*s));
                                        numtype |=
                                          IS_NUMBER_GREATER_THAN_UV_MAX;
                                        goto skip_value;
                                      }
                                    }
                                  }
				}
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
	}
      }
    }
    numtype |= IS_NUMBER_IN_UV;
    if (valuep)
      *valuep = value;

  skip_value:
    if (GROK_NUMERIC_RADIX(&s, send)) {
      numtype |= IS_NUMBER_NOT_INT;
      while (s < send && isDIGIT(*s))  /* optional digits after the radix */
        s++;
    }
  }
  else if (GROK_NUMERIC_RADIX(&s, send)) {
    numtype |= IS_NUMBER_NOT_INT | IS_NUMBER_IN_UV; /* valuep assigned below */
    /* no digits before the radix means we need digits after it */
    if (s < send && isDIGIT(*s)) {
      do {
        s++;
      } while (s < send && isDIGIT(*s));
      if (valuep) {
        /* integer approximation is valid - it's 0.  */
        *valuep = 0;
      }
    }
    else
      return 0;
  } else if (*s == 'I' || *s == 'i') {
    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
    s++; if (s == send || (*s != 'F' && *s != 'f')) return 0;
    s++; if (s < send && (*s == 'I' || *s == 'i')) {
      s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
      s++; if (s == send || (*s != 'I' && *s != 'i')) return 0;
      s++; if (s == send || (*s != 'T' && *s != 't')) return 0;
      s++; if (s == send || (*s != 'Y' && *s != 'y')) return 0;
      s++;
    }
    sawinf = 1;
  } else if (*s == 'N' || *s == 'n') {
    /* XXX TODO: There are signaling NaNs and quiet NaNs. */
    s++; if (s == send || (*s != 'A' && *s != 'a')) return 0;
    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;
    s++;
    sawnan = 1;
  } else
    return 0;

  if (sawinf) {
    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
    numtype |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;
  } else if (sawnan) {
    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */
    numtype |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;
  } else if (s < send) {
    /* we can have an optional exponent part */
    if (*s == 'e' || *s == 'E') {
      /* The only flag we keep is sign.  Blow away any "it's UV"  */
      numtype &= IS_NUMBER_NEG;
      numtype |= IS_NUMBER_NOT_INT;
      s++;
      if (s < send && (*s == '-' || *s == '+'))
        s++;
      if (s < send && isDIGIT(*s)) {
        do {
          s++;
        } while (s < send && isDIGIT(*s));
      }
      else
      return 0;
    }
  }
  while (s < send && isSPACE(*s))
    s++;
  if (s >= send)
    return numtype;
  if (len == 10 && memEQ(pv, "0 but true", 10)) {
    if (valuep)
      *valuep = 0;
    return IS_NUMBER_IN_UV;
  }
  return 0;
}
#endif
#endif

/*
 * The grok_* routines have been modified to use warn() instead of
 * Perl_warner(). Also, 'hexdigit' was the former name of PL_hexdigit,
 * which is why the stack variable has been renamed to 'xdigit'.
 */

#ifndef grok_bin
#if defined(NEED_grok_bin)
static UV DPPP_(my_grok_bin)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result);
static
#else
extern UV DPPP_(my_grok_bin)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result);
#endif

#ifdef grok_bin
#  undef grok_bin
#endif
#define grok_bin(a,b,c,d) DPPP_(my_grok_bin)(aTHX_ a,b,c,d)
#define Perl_grok_bin DPPP_(my_grok_bin)

#if defined(NEED_grok_bin) || defined(NEED_grok_bin_GLOBAL)
UV
DPPP_(my_grok_bin)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_2 = UV_MAX / 2;
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
    bool overflowed = FALSE;

    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
        /* strip off leading b or 0b.
           for compatibility silently suffer "b" and "0b" as valid binary
           numbers. */
        if (len >= 1) {
            if (s[0] == 'b') {
                s++;
                len--;
            }
            else if (len >= 2 && s[0] == '0' && s[1] == 'b') {
                s+=2;
                len-=2;
            }
        }
    }

    for (; len-- && *s; s++) {
        char bit = *s;
        if (bit == '0' || bit == '1') {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
               With gcc seems to be much straighter code than old scan_bin.  */
          redo:
            if (!overflowed) {
                if (value <= max_div_2) {
                    value = (value << 1) | (bit - '0');
                    continue;
                }
                /* Bah. We're just overflowed.  */
                warn("Integer overflow in binary number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 2.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent a UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply value_nv by the
	     * right amount. */
            value_nv += (NV)(bit - '0');
            continue;
        }
        if (bit == '_' && len && allow_underscores && (bit = s[1])
            && (bit == '0' || bit == '1'))
	    {
		--len;
		++s;
                goto redo;
	    }
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            warn("Illegal binary digit '%c' ignored", *s);
        break;
    }

    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && value > 0xffffffff  )
#endif
	) {
	warn("Binary number > 0b11111111111111111111111111111111 non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}
#endif
#endif

#ifndef grok_hex
#if defined(NEED_grok_hex)
static UV DPPP_(my_grok_hex)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result);
static
#else
extern UV DPPP_(my_grok_hex)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result);
#endif

#ifdef grok_hex
#  undef grok_hex
#endif
#define grok_hex(a,b,c,d) DPPP_(my_grok_hex)(aTHX_ a,b,c,d)
#define Perl_grok_hex DPPP_(my_grok_hex)

#if defined(NEED_grok_hex) || defined(NEED_grok_hex_GLOBAL)
UV
DPPP_(my_grok_hex)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_16 = UV_MAX / 16;
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
    bool overflowed = FALSE;
    const char *xdigit;

    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {
        /* strip off leading x or 0x.
           for compatibility silently suffer "x" and "0x" as valid hex numbers.
        */
        if (len >= 1) {
            if (s[0] == 'x') {
                s++;
                len--;
            }
            else if (len >= 2 && s[0] == '0' && s[1] == 'x') {
                s+=2;
                len-=2;
            }
        }
    }

    for (; len-- && *s; s++) {
	xdigit = strchr((char *) PL_hexdigit, *s);
        if (xdigit) {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
               With gcc seems to be much straighter code than old scan_hex.  */
          redo:
            if (!overflowed) {
                if (value <= max_div_16) {
                    value = (value << 4) | ((xdigit - PL_hexdigit) & 15);
                    continue;
                }
                warn("Integer overflow in hexadecimal number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 16.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent a UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply value_nv by the
	     * right amount of 16-tuples. */
            value_nv += (NV)((xdigit - PL_hexdigit) & 15);
            continue;
        }
        if (*s == '_' && len && allow_underscores && s[1]
		&& (xdigit = strchr((char *) PL_hexdigit, s[1])))
	    {
		--len;
		++s;
                goto redo;
	    }
        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
            warn("Illegal hexadecimal digit '%c' ignored", *s);
        break;
    }

    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && value > 0xffffffff  )
#endif
	) {
	warn("Hexadecimal number > 0xffffffff non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}
#endif
#endif

#ifndef grok_oct
#if defined(NEED_grok_oct)
static UV DPPP_(my_grok_oct)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result);
static
#else
extern UV DPPP_(my_grok_oct)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result);
#endif

#ifdef grok_oct
#  undef grok_oct
#endif
#define grok_oct(a,b,c,d) DPPP_(my_grok_oct)(aTHX_ a,b,c,d)
#define Perl_grok_oct DPPP_(my_grok_oct)

#if defined(NEED_grok_oct) || defined(NEED_grok_oct_GLOBAL)
UV
DPPP_(my_grok_oct)(pTHX_ char *start, STRLEN *len_p, I32 *flags, NV *result)
{
    const char *s = start;
    STRLEN len = *len_p;
    UV value = 0;
    NV value_nv = 0;

    const UV max_div_8 = UV_MAX / 8;
    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;
    bool overflowed = FALSE;

    for (; len-- && *s; s++) {
         /* gcc 2.95 optimiser not smart enough to figure that this subtraction
            out front allows slicker code.  */
        int digit = *s - '0';
        if (digit >= 0 && digit <= 7) {
            /* Write it in this wonky order with a goto to attempt to get the
               compiler to make the common case integer-only loop pretty tight.
            */
          redo:
            if (!overflowed) {
                if (value <= max_div_8) {
                    value = (value << 3) | digit;
                    continue;
                }
                /* Bah. We're just overflowed.  */
                warn("Integer overflow in octal number");
                overflowed = TRUE;
                value_nv = (NV) value;
            }
            value_nv *= 8.0;
	    /* If an NV has not enough bits in its mantissa to
	     * represent a UV this summing of small low-order numbers
	     * is a waste of time (because the NV cannot preserve
	     * the low-order bits anyway): we could just remember when
	     * did we overflow and in the end just multiply value_nv by the
	     * right amount of 8-tuples. */
            value_nv += (NV)digit;
            continue;
        }
        if (digit == ('_' - '0') && len && allow_underscores
            && (digit = s[1] - '0') && (digit >= 0 && digit <= 7))
	    {
		--len;
		++s;
                goto redo;
	    }
        /* Allow \octal to work the DWIM way (that is, stop scanning
         * as soon as non-octal characters are seen, complain only iff
         * someone seems to want to use the digits eight and nine). */
        if (digit == 8 || digit == 9) {
            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))
                warn("Illegal octal digit '%c' ignored", *s);
        }
        break;
    }

    if (   ( overflowed && value_nv > 4294967295.0)
#if UVSIZE > 4
	|| (!overflowed && value > 0xffffffff  )
#endif
	) {
	warn("Octal number > 037777777777 non-portable");
    }
    *len_p = s - start;
    if (!overflowed) {
        *flags = 0;
        return value;
    }
    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;
    if (result)
        *result = value_nv;
    return UV_MAX;
}
#endif
#endif

#ifdef NO_XSLOCKS
#  ifdef dJMPENV
#    define dXCPT             dJMPENV; int rEtV = 0
#    define XCPT_TRY_START    JMPENV_PUSH(rEtV); if (rEtV == 0)
#    define XCPT_TRY_END      JMPENV_POP;
#    define XCPT_CATCH        if (rEtV != 0)
#    define XCPT_RETHROW      JMPENV_JUMP(rEtV)
#  else
#    define dXCPT             Sigjmp_buf oldTOP; int rEtV = 0
#    define XCPT_TRY_START    Copy(top_env, oldTOP, 1, Sigjmp_buf); rEtV = Sigsetjmp(top_env, 1); if (rEtV == 0)
#    define XCPT_TRY_END      Copy(oldTOP, top_env, 1, Sigjmp_buf);
#    define XCPT_CATCH        if (rEtV != 0)
#    define XCPT_RETHROW      Siglongjmp(top_env, rEtV)
#  endif
#endif

#endif /* _P_P_PORTABILITY_H_ */

/* End of File ppport.h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\dbixs_rev.h ===
/* Mon Jul 16 12:10:43 2007 */
#define DBIXS_REVISION 9743
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\DBIXS.h ===
/* $Id: DBIXS.h 9659 2007-06-18 14:19:45Z timbo $
 *
 * Copyright (c) 1994-2002  Tim Bunce  Ireland
 *
 * See COPYRIGHT section in DBI.pm for usage and distribution rights.
 */

/* DBI Interface Definitions for DBD Modules */

#ifndef DBIXS_VERSION				/* prevent multiple inclusion */

#ifndef DBIS
#define DBIS	dbis	/* default name for dbistate_t variable	*/
#endif

/* first pull in the standard Perl header files for extensions	*/
#define PERL_POLLUTE
#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>

#ifdef debug		/* causes problems with DBIS->debug	*/
#undef debug
#endif

#ifdef std             /* causes problems with STLport <tscheresky@micron.com> */
#undef std
#endif

/* define DBIXS_REVISION */
#include "dbixs_rev.h"

/* Perl backwards compatibility definitions */
#include "dbipport.h"

/* DBI SQL_* type definitions */
#include "dbi_sql.h"


/* The DBIXS_VERSION value will be incremented whenever new code is
 * added to the interface (this file) or significant changes are made.
 * It's primary goal is to allow newer drivers to compile against an
 * older installed DBI. This is mainly an issue whilst the API grows
 * and learns from the needs of various drivers.  See also the
 * DBISTATE_VERSION macro below. You can think of DBIXS_VERSION as
 * being a compile time check and DBISTATE_VERSION as a runtime check.
 * By contract, DBIXS_REVISION is a driver source compatibility tool.
 */
#define DBIXS_VERSION 93

#ifdef NEED_DBIXS_VERSION
#if NEED_DBIXS_VERSION > DBIXS_VERSION
error You_need_to_upgrade_your_DBI_module_before_building_this_driver
#endif
#else
#define NEED_DBIXS_VERSION DBIXS_VERSION
#endif


#define DBI_LOCK
#define DBI_UNLOCK

#ifndef DBI_NO_THREADS
#ifdef USE_ITHREADS
#define DBI_USE_THREADS
#endif /* USE_ITHREADS */
#endif /* DBI_NO_THREADS */


/* forward struct declarations						*/

typedef struct dbistate_st dbistate_t;
/* implementor needs to define actual struct { dbih_??c_t com; ... }*/
typedef struct imp_drh_st imp_drh_t;	/* driver			*/
typedef struct imp_dbh_st imp_dbh_t;	/* database			*/
typedef struct imp_sth_st imp_sth_t;	/* statement			*/
typedef struct imp_fdh_st imp_fdh_t;	/* field descriptor		*/
typedef struct imp_xxh_st imp_xxh_t;	/* any (defined below)		*/
#define DBI_imp_data_ imp_xxh_t		/* friendly for take_imp_data	*/



/* --- DBI Handle Common Data Structure (all handles have one) ---	*/

/* Handle types. Code currently assumes child = parent + 1.		*/
#define DBIt_DR		1
#define DBIt_DB		2
#define DBIt_ST		3
#define DBIt_FD		4

/* component structures */

typedef struct dbih_com_std_st {
    U32  flags;
    int  call_depth;	/* used by DBI to track nested calls (int)	*/
    U16  type;		/* DBIt_DR, DBIt_DB, DBIt_ST			*/
    HV   *my_h;		/* copy of outer handle HV (not refcounted)	*/
    SV   *parent_h;	/* parent inner handle (ref to hv) (r.c.inc)	*/
    imp_xxh_t *parent_com;	/* parent com struct shortcut		*/
    PerlInterpreter * thr_user;  /* thread that owns the handle         */

    HV   *imp_stash;	/* who is the implementor for this handle	*/
    SV   *imp_data;	/* optional implementors data (for perl imp's)	*/

    I32  kids;		/* count of db's for dr's, st's for db's etc	*/
    I32  active_kids;	/* kids which are currently DBIc_ACTIVE		*/
    U32 pad;		/* keep binary compat */
    dbistate_t *dbistate;
} dbih_com_std_t;

typedef struct dbih_com_attr_st {
    /* These are copies of the Hash values (ref.cnt.inc'd)	*/
    /* Many of the hash values are themselves references	*/
    SV *TraceLevel;
    SV *State;		/* Standard SQLSTATE, 5 char string	*/
    SV *Err;		/* Native engine error code		*/
    SV *Errstr;		/* Native engine error message		*/
    UV ErrCount;
    U32  LongReadLen;	/* auto read length for long/blob types	*/
    SV *FetchHashKeyName;	/* for fetchrow_hashref		*/
    /* (NEW FIELDS?... DON'T FORGET TO UPDATE dbih_clearcom()!)	*/
} dbih_com_attr_t;


struct dbih_com_st {	/* complete core structure (typedef'd above)	*/
    dbih_com_std_t	std;
    dbih_com_attr_t	attr;
};

/* This 'implementors' type the DBI defines by default as a way to	*/
/* refer to the imp_??h data of a handle without considering its type.	*/
struct imp_xxh_st { struct dbih_com_st com; };

/* Define handle-type specific structures for implementors to include	*/
/* at the start of their private structures.				*/

typedef struct {		/* -- DRIVER --				*/
    dbih_com_std_t	std;
    dbih_com_attr_t	attr;
    HV          *_old_cached_kids; /* not used, here for binary compat */
} dbih_drc_t;

typedef struct {		/* -- DATABASE --			*/
    dbih_com_std_t	std;	/* \__ standard structure		*/
    dbih_com_attr_t	attr;	/* /   plus... (nothing else right now)	*/
    HV          *_old_cached_kids; /* not used, here for binary compat */
} dbih_dbc_t;

typedef struct {		/* -- STATEMENT --			*/
    dbih_com_std_t	std;	/* \__ standard structure		*/
    dbih_com_attr_t	attr;	/* /   plus ...				*/

    int 	num_params;	/* number of placeholders		*/
    int 	num_fields;	/* NUM_OF_FIELDS, must be set		*/
    AV  	*fields_svav;	/* special row buffer (inc bind_cols)	*/
    IV		row_count;	/* incremented by get_fbav()		*/

    AV		*fields_fdav;	/* not used yet, may change */

    I32  spare1;
    void *spare2;
} dbih_stc_t;


/* XXX THIS STRUCTURE SHOULD NOT BE USED */
typedef struct {		/* -- FIELD DESCRIPTOR --		*/
    dbih_com_std_t	std;	/* standard structure (not fully setup)	*/

    /* core attributes (from DescribeCol in ODBC)		*/
    char *col_name;		/* see dbih_make_fdsv		*/
    I16   col_name_len;
    I16   col_sql_type;
    I16   col_precision;
    I16   col_scale;
    I16   col_nullable;

    /* additional attributes (from ColAttributes in ODBC)	*/
    I32   col_length;
    I32   col_disp_size;

    I32  spare1;
    void *spare2;
} dbih_fdc_t;


#define _imp2com(p,f)      	((p)->com.f)

#define DBIc_FLAGS(imp)		_imp2com(imp, std.flags)
#define DBIc_TYPE(imp)		_imp2com(imp, std.type)
#define DBIc_CALL_DEPTH(imp)	_imp2com(imp, std.call_depth)
#define DBIc_MY_H(imp)  	_imp2com(imp, std.my_h)
#define DBIc_PARENT_H(imp)  	_imp2com(imp, std.parent_h)
#define DBIc_PARENT_COM(imp)  	_imp2com(imp, std.parent_com)
#define DBIc_THR_COND(imp)  	_imp2com(imp, std.thr_cond)
#define DBIc_THR_USER(imp)  	_imp2com(imp, std.thr_user)
#define DBIc_THR_USER_NONE  	(0xFFFF)
#define DBIc_IMP_STASH(imp)  	_imp2com(imp, std.imp_stash)
#define DBIc_IMP_DATA(imp)  	_imp2com(imp, std.imp_data)
#define DBIc_DBISTATE(imp)  	_imp2com(imp, std.dbistate)
#define DBIc_LOGPIO(imp)  	DBIc_DBISTATE(imp)->logfp
#define DBIc_KIDS(imp)  	_imp2com(imp, std.kids)
#define DBIc_ACTIVE_KIDS(imp)  	_imp2com(imp, std.active_kids)
#define DBIc_LAST_METHOD(imp)  	_imp2com(imp, std.last_method)

#define DBIc_TRACE_LEVEL_MASK	0x0000000F
#define DBIc_TRACE_FLAGS_MASK	0xFFFFFF00
#define DBIc_TRACE_SETTINGS(imp) (DBIc_DBISTATE(imp)->debug)
#define DBIc_TRACE_LEVEL(imp)	(DBIc_TRACE_SETTINGS(imp) & DBIc_TRACE_LEVEL_MASK)
#define DBIc_TRACE_FLAGS(imp)	(DBIc_TRACE_SETTINGS(imp) & DBIc_TRACE_FLAGS_MASK)
/* DBIc_TRACE_MATCHES(this, crnt): true if this 'matches' (is within) crnt
   DBIc_TRACE_MATCHES(foo, DBIc_TRACE_SETTINGS(imp))
*/
#define DBIc_TRACE_MATCHES(this, crnt)	\
	(  ((crnt & DBIc_TRACE_LEVEL_MASK) >= (this & DBIc_TRACE_LEVEL_MASK)) \
	|| ((crnt & DBIc_TRACE_FLAGS_MASK)  & (this & DBIc_TRACE_FLAGS_MASK)) )
/* DBIc_TRACE: true if flags match & DBI level>=flaglevel, or if DBI level>level
   This is the main trace testing macro to be used by drivers.
   (Drivers should define their own DBDtf_* macros for the top 8 bits: 0xFF000000)
   DBIc_TRACE(imp,         0, 0, 4) = if level >= 4
   DBIc_TRACE(imp, DBDtf_FOO, 2, 4) = if tracing DBDtf_FOO & level>=2 or level>=4
   DBIc_TRACE(imp, DBDtf_FOO, 2, 0) = as above but never trace just due to level
*/
#define DBIc_TRACE(imp, flags, flaglevel, level)	\
	(  (flags && (DBIc_TRACE_FLAGS(imp) & flags) && (DBIc_TRACE_LEVEL(imp) >= flaglevel)) \
	|| (level && DBIc_TRACE_LEVEL(imp) >= level) )

#define DBIc_DEBUG(imp)		(_imp2com(imp, attr.TraceLevel)) /* deprecated */
#define DBIc_DEBUGIV(imp)	SvIV(DBIc_DEBUG(imp))		 /* deprecated */
#define DBIc_STATE(imp)		SvRV(_imp2com(imp, attr.State))
#define DBIc_ERR(imp)		SvRV(_imp2com(imp, attr.Err))
#define DBIc_ERRSTR(imp)	SvRV(_imp2com(imp, attr.Errstr))
#define DBIc_ErrCount(imp)	_imp2com(imp, attr.ErrCount)
#define DBIc_LongReadLen(imp)  	_imp2com(imp, attr.LongReadLen)
#define DBIc_LongReadLen_init	80	/* may change */
#define DBIc_FetchHashKeyName(imp) (_imp2com(imp, attr.FetchHashKeyName))

/* handle sub-type specific fields						*/
/*	dbh & drh	*/
#define DBIc_CACHED_KIDS(imp)  	Nullhv /* no longer used, here for src compat */
/*	sth	*/
#define DBIc_NUM_FIELDS(imp)  	_imp2com(imp, num_fields)
#define DBIc_NUM_PARAMS(imp)  	_imp2com(imp, num_params)
#define DBIc_NUM_PARAMS_AT_EXECUTE	-9 /* see Driver.xst */
#define DBIc_ROW_COUNT(imp)  	_imp2com(imp, row_count)
#define DBIc_FIELDS_AV(imp)  	_imp2com(imp, fields_svav)
#define DBIc_FDESC_AV(imp)  	_imp2com(imp, fields_fdav)
#define DBIc_FDESC(imp, i)  	((imp_fdh_t*)(void*)SvPVX(AvARRAY(DBIc_FDESC_AV(imp))[i]))

/* XXX --- DO NOT CHANGE THESE VALUES AS THEY ARE COMPILED INTO DRIVERS --- XXX */
#define DBIcf_COMSET	  0x000001	/* needs to be clear'd before free'd	*/
#define DBIcf_IMPSET	  0x000002	/* has implementor data to be clear'd	*/
#define DBIcf_ACTIVE	  0x000004	/* needs finish/disconnect before clear	*/
#define DBIcf_IADESTROY	  0x000008	/* do DBIc_ACTIVE_off before DESTROY	*/
#define DBIcf_WARN  	  0x000010	/* warn about poor practice etc  	*/
#define DBIcf_COMPAT  	  0x000020	/* compat/emulation mode (eg oraperl)	*/
#define DBIcf_ChopBlanks  0x000040	/* rtrim spaces from fetch char columns	*/
#define DBIcf_RaiseError  0x000080	/* throw exception (croak) on error	*/
#define DBIcf_PrintError  0x000100	/* warn() on error			*/
#define DBIcf_AutoCommit  0x000200	/* dbh only. used by drivers		*/
#define DBIcf_LongTruncOk 0x000400	/* truncation to LongReadLen is okay	*/
#define DBIcf_MultiThread 0x000800	/* allow multiple threads to enter	*/
#define DBIcf_HandleSetErr 0x001000	/* has coderef HandleSetErr attribute	*/
#define DBIcf_ShowErrorStatement  0x002000   /* include Statement in error	*/
#define DBIcf_BegunWork   0x004000	/* between begin_work & commit/rollback */
#define DBIcf_HandleError 0x008000	/* has coderef in HandleError attribute */
#define DBIcf_Profile     0x010000	/* profile activity on this handle      */
#define DBIcf_TaintIn     0x020000	/* check inputs for taintedness */
#define DBIcf_TaintOut    0x040000	/* taint outgoing data */
#define DBIcf_Executed    0x080000	/* do/execute called since commit/rollb */
#define DBIcf_PrintWarn   0x100000	/* warn() on warning (err="0")		*/
#define DBIcf_Callbacks   0x200000	/* has Callbacks attribute hash		*/
/* NOTE: new flags may require clone() to be updated */

#define DBIcf_INHERITMASK		/* what NOT to pass on to children */	\
  (U32)( DBIcf_COMSET | DBIcf_IMPSET | DBIcf_ACTIVE | DBIcf_IADESTROY		\
  | DBIcf_AutoCommit | DBIcf_BegunWork | DBIcf_Executed | DBIcf_Callbacks )

/* general purpose bit setting and testing macros			*/
#define DBIbf_is( bitset,flag)		((bitset) &   (flag))
#define DBIbf_has(bitset,flag)		DBIbf_is(bitset, flag) /* alias for _is */
#define DBIbf_on( bitset,flag)		((bitset) |=  (flag))
#define DBIbf_off(bitset,flag)		((bitset) &= ~(flag))
#define DBIbf_set(bitset,flag,on)	((on) ? DBIbf_on(bitset, flag) : DBIbf_off(bitset,flag))

/* as above, but specifically for DBIc_FLAGS imp flags (except ACTIVE)	*/
#define DBIc_is(imp, flag)	DBIbf_is( DBIc_FLAGS(imp), flag)
#define DBIc_has(imp,flag)	DBIc_is(imp, flag) /* alias for DBIc_is */
#define DBIc_on(imp, flag)	DBIbf_on( DBIc_FLAGS(imp), flag)
#define DBIc_off(imp,flag)	DBIbf_off(DBIc_FLAGS(imp), flag)
#define DBIc_set(imp,flag,on)	DBIbf_set(DBIc_FLAGS(imp), flag, on)

#define DBIc_COMSET(imp)	DBIc_is(imp, DBIcf_COMSET)
#define DBIc_COMSET_on(imp)	DBIc_on(imp, DBIcf_COMSET)
#define DBIc_COMSET_off(imp)	DBIc_off(imp,DBIcf_COMSET)

#define DBIc_IMPSET(imp)	DBIc_is(imp, DBIcf_IMPSET)
#define DBIc_IMPSET_on(imp)	DBIc_on(imp, DBIcf_IMPSET)
#define DBIc_IMPSET_off(imp)	DBIc_off(imp,DBIcf_IMPSET)

#define DBIc_ACTIVE(imp)	(DBIc_FLAGS(imp) &   DBIcf_ACTIVE)
#define DBIc_ACTIVE_on(imp)	/* adjust parent's active kid count */	\
    do {								\
	imp_xxh_t *ph_com = DBIc_PARENT_COM(imp);			\
	if (!DBIc_ACTIVE(imp) && ph_com && !dirty			\
		&& ++DBIc_ACTIVE_KIDS(ph_com) > DBIc_KIDS(ph_com))	\
	    croak("panic: DBI active kids (%ld) > kids (%ld)",		\
		DBIc_ACTIVE_KIDS(ph_com), DBIc_KIDS(ph_com));		\
	DBIc_FLAGS(imp) |=  DBIcf_ACTIVE;				\
    } while(0)
#define DBIc_ACTIVE_off(imp)	/* adjust parent's active kid count */	\
    do {								\
	imp_xxh_t *ph_com = DBIc_PARENT_COM(imp);			\
	if (DBIc_ACTIVE(imp) && ph_com && !dirty			\
		&& (--DBIc_ACTIVE_KIDS(ph_com) > DBIc_KIDS(ph_com)	\
		   || DBIc_ACTIVE_KIDS(ph_com) < 0) )			\
	    croak("panic: DBI active kids (%ld) < 0 or > kids (%ld)",	\
		DBIc_ACTIVE_KIDS(ph_com), DBIc_KIDS(ph_com));		\
	DBIc_FLAGS(imp) &= ~DBIcf_ACTIVE;				\
    } while(0)

#define DBIc_IADESTROY(imp)	(DBIc_FLAGS(imp) &   DBIcf_IADESTROY)
#define DBIc_IADESTROY_on(imp)	(DBIc_FLAGS(imp) |=  DBIcf_IADESTROY)
#define DBIc_IADESTROY_off(imp)	(DBIc_FLAGS(imp) &= ~DBIcf_IADESTROY)

#define DBIc_WARN(imp)   	(DBIc_FLAGS(imp) &   DBIcf_WARN)
#define DBIc_WARN_on(imp)	(DBIc_FLAGS(imp) |=  DBIcf_WARN)
#define DBIc_WARN_off(imp)	(DBIc_FLAGS(imp) &= ~DBIcf_WARN)

#define DBIc_COMPAT(imp)   	(DBIc_FLAGS(imp) &   DBIcf_COMPAT)
#define DBIc_COMPAT_on(imp)	(DBIc_FLAGS(imp) |=  DBIcf_COMPAT)
#define DBIc_COMPAT_off(imp)	(DBIc_FLAGS(imp) &= ~DBIcf_COMPAT)


#ifdef IN_DBI_XS		/* get Handle Common Data Structure	*/
#define DBIh_COM(h)         	(dbih_getcom2(aTHX_ h, 0))
#else
#define DBIh_COM(h)         	(DBIS->getcom(h))
#define neatsvpv(sv,len)       	(DBIS->neat_svpv(sv,len))
#endif


/* --- Implementors Private Data Support --- */

#define D_impdata(name,type,h)	type *name = (type*)(DBIh_COM(h))
#define D_imp_drh(h) D_impdata(imp_drh, imp_drh_t, h)
#define D_imp_dbh(h) D_impdata(imp_dbh, imp_dbh_t, h)
#define D_imp_sth(h) D_impdata(imp_sth, imp_sth_t, h)
#define D_imp_xxh(h) D_impdata(imp_xxh, imp_xxh_t, h)

#define D_imp_from_child(name,type,child)	\
				type *name = (type*)(DBIc_PARENT_COM(child))
#define D_imp_drh_from_dbh D_imp_from_child(imp_drh, imp_drh_t, imp_dbh)
#define D_imp_dbh_from_sth D_imp_from_child(imp_dbh, imp_dbh_t, imp_sth)

#define DBI_IMP_SIZE(n,s) sv_setiv(perl_get_sv((n), GV_ADDMULTI), (s)) /* XXX */



/* --- Event Support (VERY LIABLE TO CHANGE) --- */

#define DBIh_EVENTx(h,t,a1,a2)	/* deprecated XXX */ &PL_sv_no
#define DBIh_EVENT0(h,t)	DBIh_EVENTx((h), (t), &PL_sv_undef, &PL_sv_undef)
#define DBIh_EVENT1(h,t, a1)	DBIh_EVENTx((h), (t), (a1),         &PL_sv_undef)
#define DBIh_EVENT2(h,t, a1,a2)	DBIh_EVENTx((h), (t), (a1),         (a2))

#define ERROR_event	"ERROR"
#define WARN_event	"WARN"
#define MSG_event	"MESSAGE"
#define DBEVENT_event	"DBEVENT"
#define UNKNOWN_event	"UNKNOWN"

#define DBIh_SET_ERR_SV(h,i, err, errstr, state, method) \
	(DBIc_DBISTATE(i)->set_err_sv(h,i, err, errstr, state, method))
#define DBIh_SET_ERR_CHAR(h,i, err_c, err_i, errstr, state, method) \
	(DBIc_DBISTATE(i)->set_err_char(h,i, err_c, err_i, errstr, state, method))


/* --- Handy Macros --- */

#define DBIh_CLEAR_ERROR(imp_xxh) (void)( \
	(void)SvOK_off(DBIc_ERR(imp_xxh)),    	\
	(void)SvOK_off(DBIc_ERRSTR(imp_xxh)),	\
	(void)SvOK_off(DBIc_STATE(imp_xxh))	\
    )


/* --- DBI State Structure --- */

struct dbistate_st {

#define DBISTATE_VERSION  94	/* Must change whenever dbistate_t does	*/

    /* this must be the first member in structure			*/
    void (*check_version) _((const char *name,
		int dbis_cv, int dbis_cs, int need_dbixs_cv,
		int drc_s, int dbc_s, int stc_s, int fdc_s));

    /* version and size are used to check for DBI/DBD version mis-match	*/
    U16 version;	/* version of this structure			*/
    U16 size;
    U16 xs_version;	/* version of the overall DBIXS / DBD interface	*/
    U16 spare_pad;

    I32 debug;
    PerlIO *logfp;

    /* pointers to DBI functions which the DBD's will want to use	*/
    char      * (*neat_svpv)	_((SV *sv, STRLEN maxlen));
    imp_xxh_t * (*getcom)	_((SV *h));	/* see DBIh_COM macro	*/
    void        (*clearcom)	_((imp_xxh_t *imp_xxh));
    SV        * (*event)	_((SV *h, const char *name, SV*, SV*));
    int         (*set_attr_k)	_((SV *h, SV *keysv, int dbikey, SV *valuesv));
    SV        * (*get_attr_k)	_((SV *h, SV *keysv, int dbikey));
    AV        * (*get_fbav)	_((imp_sth_t *imp_sth));
    SV        * (*make_fdsv)	_((SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name));
    int         (*bind_as_num)	_((int sql_type, int p, int s, int *t, void *v));
    I32         (*hash)		_((const char *string, long i));
    SV        * (*preparse)	_((SV *sth, char *statement, IV ps_return, IV ps_accept, void *foo));

    SV *neatsvpvlen;		/* only show dbgpvlen chars when debugging pv's	*/

    PerlInterpreter * thr_owner;	/* thread that owns this dbistate	*/

    int         (*logmsg)	_((imp_xxh_t *imp_xxh, const char *fmt, ...));
    int         (*set_err_sv)	_((SV *h, imp_xxh_t *imp_xxh, SV   *err, SV   *errstr, SV   *state, SV   *method));
    int         (*set_err_char) _((SV *h, imp_xxh_t *imp_xxh, const char *err, IV err_i, const char *errstr, const char *state, const char *method));
    int         (*bind_col)     _((SV *sth, SV *col, SV *ref, SV *attribs));

    IO *logfp_ref;	/* DAA keep ptr to filehandle for refcounting */

    /* WARNING: Only add new structure members here, and reduce pad2 to keep */
    /* the memory footprint exactly the same */
    void *pad2[4];
};

/* macros for backwards compatibility */
#define set_attr(h, k, v)	set_attr_k(h, k, 0, v)
#define get_attr(h, k)		get_attr_k(h, k, 0)

#define DBISTATE_PERLNAME "DBI::_dbistate"
#define DBISTATE_ADDRSV   (perl_get_sv(DBISTATE_PERLNAME, 0x05))
#define DBILOGFP	(DBIS->logfp)
#ifdef IN_DBI_XS
#define DBILOGMSG	(dbih_logmsg)
#else
#define DBILOGMSG	(DBIS->logmsg)
#endif


/* --- perl object (ActiveState) / multiplicity hooks and hoops --- */
/* note that USE_ITHREADS implies MULTIPLICITY                      */
#if defined(MULTIPLICITY) || defined(PERL_OBJECT) || defined(PERL_CAPI)

# define DBISTATE_DECLARE typedef int dummy_dbistate /* keep semicolon from feeling lonely */
# define DBISTATE_ASSIGN(st)
# define DBISTATE_INIT
# undef DBIS
# define DBIS (*(INT2PTR(dbistate_t**, &SvIVX(DBISTATE_ADDRSV))))
/* 'dbis' is temp for bad drivers using 'dbis' instead of 'DBIS' */
# define dbis (*(INT2PTR(dbistate_t**, &SvIVX(DBISTATE_ADDRSV))))

#else	/* plain and simple non perl object / multiplicity case */

# define DBISTATE_DECLARE	static dbistate_t *DBIS
# define DBISTATE_ASSIGN(st)	(DBIS = (st))
# define DBISTATE_INIT_DBIS	DBISTATE_ASSIGN(INT2PTR(dbistate_t*, SvIV(DBISTATE_ADDRSV)))
# define DBISTATE_INIT {	/* typically use in BOOT: of XS file	*/    \
    DBISTATE_INIT_DBIS;	\
    if (DBIS == NULL)	\
	croak("Unable to get DBI state from %s at %p. DBI not loaded.", DBISTATE_PERLNAME, DBISTATE_ADDRSV); \
    DBIS->check_version(__FILE__, DBISTATE_VERSION, sizeof(*DBIS), NEED_DBIXS_VERSION, \
		sizeof(dbih_drc_t), sizeof(dbih_dbc_t), sizeof(dbih_stc_t), sizeof(dbih_fdc_t) \
    ); \
}
#endif


/* --- Assorted Utility Macros	--- */

#define DBD_ATTRIB_OK(attribs)	/* is this a usable attrib value */	\
	(attribs && SvROK(attribs) && SvTYPE(SvRV(attribs))==SVt_PVHV)

/* If attribs value supplied then croak if it's not a hash ref.		*/
/* Also map undef to Null. Should always be called to pre-process the	*/
/* attribs value. One day we may add some extra magic in here.		*/
#define DBD_ATTRIBS_CHECK(func, h, attribs)	\
    if ((attribs) && SvOK(attribs)) {		\
	if (!SvROK(attribs) || SvTYPE(SvRV(attribs))!=SVt_PVHV)		\
	    croak("%s->%s(...): attribute parameter '%s' is not a hash ref",	\
		    SvPV_nolen(h), func, SvPV_nolen(attribs));		\
    } else (attribs) = Nullsv

#define DBD_ATTRIB_GET_SVP(attribs, key,klen)			\
	(DBD_ATTRIB_OK(attribs)					\
	    ? hv_fetch((HV*)SvRV(attribs), key,klen, 0)		\
	    : (SV **)Nullsv)

#define DBD_ATTRIB_GET_IV(attribs, key,klen, svp, var)			\
	if ((svp=DBD_ATTRIB_GET_SVP(attribs, key,klen)) != NULL)	\
	    var = SvIV(*svp)

#define DBD_ATTRIB_GET_BOOL(attribs, key,klen, svp, var)		\
	if ((svp=DBD_ATTRIB_GET_SVP(attribs, key,klen)) != NULL)	\
	    var = SvTRUE(*svp)

#define DBD_ATTRIB_TRUE(attribs, key,klen, svp)				\
	(  ((svp=DBD_ATTRIB_GET_SVP(attribs, key,klen)) != NULL)	\
	    ? SvTRUE(*svp) : 0 )

#define DBD_ATTRIB_GET_PV(attribs, key,klen, svp, dflt)			\
	(((svp=DBD_ATTRIB_GET_SVP(attribs, key,klen)) != NULL)		\
	    ? SvPV_nolen(*svp) : (dflt))

#define DBD_ATTRIB_DELETE(attribs, key, klen)			\
	hv_delete((HV*)attribs, key, klen, G_DISCARD)

#endif /* DBIXS_VERSION */
/* end of DBIXS.h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\av.h ===
/*    av.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct xpvav {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* max index for which array has space */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
};

typedef struct {
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* max index for which array has space */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
} xpvav_allocated;

/* SV**	xav_alloc; */
#define xav_alloc xiv_u.xivu_p1
/* SV*	xav_arylen; */

/* SVpav_REAL is set for all AVs whose xav_array contents are refcounted.
 * Some things like "@_" and the scratchpad list do not set this, to
 * indicate that they are cheating (for efficiency) by not refcounting
 * the AV's contents.
 * 
 * SVpav_REIFY is only meaningful on such "fake" AVs (i.e. where SVpav_REAL
 * is not set).  It indicates that the fake AV is capable of becoming
 * real if the array needs to be modified in some way.  Functions that
 * modify fake AVs check both flags to call av_reify() as appropriate.
 *
 * Note that the Perl stack and @DB::args have neither flag set. (Thus,
 * items that go on the stack are never refcounted.)
 *
 * These internal details are subject to change any time.  AV
 * manipulations external to perl should not care about any of this.
 * GSAR 1999-09-10
 */

/*
=head1 Handy Values

=for apidoc AmU||Nullav
Null AV pointer.

=head1 Array Manipulation Functions

=for apidoc Am|int|AvFILL|AV* av
Same as C<av_len()>.  Deprecated, use C<av_len()> instead.

=cut
*/

#define Nullav Null(AV*)

#define AvARRAY(av)	((av)->sv_u.svu_array)
#define AvALLOC(av)	(*((SV***)&((XPVAV*)  SvANY(av))->xav_alloc))
#define AvMAX(av)	((XPVAV*)  SvANY(av))->xav_max
#define AvFILLp(av)	((XPVAV*)  SvANY(av))->xav_fill
#define AvARYLEN(av)	(*Perl_av_arylen_p(aTHX_ (AV*)av))

#define AvREAL(av)	(SvFLAGS(av) & SVpav_REAL)
#define AvREAL_on(av)	(SvFLAGS(av) |= SVpav_REAL)
#define AvREAL_off(av)	(SvFLAGS(av) &= ~SVpav_REAL)
#define AvREAL_only(av)	(AvREIFY_off(av), SvFLAGS(av) |= SVpav_REAL)
#define AvREIFY(av)	(SvFLAGS(av) & SVpav_REIFY)
#define AvREIFY_on(av)	(SvFLAGS(av) |= SVpav_REIFY)
#define AvREIFY_off(av)	(SvFLAGS(av) &= ~SVpav_REIFY)
#define AvREIFY_only(av)	(AvREAL_off(av), SvFLAGS(av) |= SVpav_REIFY)

#define AvREALISH(av)	(SvFLAGS(av) & (SVpav_REAL|SVpav_REIFY))
                                          
#define AvFILL(av)	((SvRMAGICAL((SV *) (av))) \
			  ? mg_size((SV *) av) : AvFILLp(av))

#define NEGATIVE_INDICES_VAR "NEGATIVE_INDICES"

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\dbi_sql.h ===
/* $Id: dbi_sql.h 2488 2006-02-07 22:24:43Z timbo $
 *
 * Copyright (c) 1997,1998,1999  Tim Bunce  England
 *
 * See COPYRIGHT section in DBI.pm for usage and distribution rights.
 */


/* Some core SQL CLI standard (ODBC) declarations		*/
#ifndef SQL_SUCCESS	/* don't clash with ODBC based drivers	*/

/* SQL datatype codes */
#define SQL_GUID                         (-11)
#define SQL_WLONGVARCHAR                 (-10)
#define SQL_WVARCHAR                      (-9)
#define SQL_WCHAR                         (-8)
#define SQL_BIT                           (-7)
#define SQL_TINYINT                       (-6)
#define SQL_BIGINT                        (-5)
#define SQL_LONGVARBINARY                 (-4)
#define SQL_VARBINARY                     (-3)
#define SQL_BINARY                        (-2)
#define SQL_LONGVARCHAR                   (-1)
#define SQL_UNKNOWN_TYPE                    0
#define SQL_ALL_TYPES                       0
#define SQL_CHAR                            1
#define SQL_NUMERIC                         2
#define SQL_DECIMAL                         3
#define SQL_INTEGER                         4
#define SQL_SMALLINT                        5
#define SQL_FLOAT                           6
#define SQL_REAL                            7
#define SQL_DOUBLE                          8
#define SQL_DATETIME                        9
#define SQL_DATE                            9
#define SQL_INTERVAL                       10
#define SQL_TIME                           10
#define SQL_TIMESTAMP                      11
#define SQL_VARCHAR                        12
#define SQL_BOOLEAN                        16
#define SQL_UDT                            17
#define SQL_UDT_LOCATOR                    18
#define SQL_ROW                            19
#define SQL_REF                            20
#define SQL_BLOB                           30
#define SQL_BLOB_LOCATOR                   31
#define SQL_CLOB                           40
#define SQL_CLOB_LOCATOR                   41
#define SQL_ARRAY                          50
#define SQL_ARRAY_LOCATOR                  51
#define SQL_MULTISET                       55
#define SQL_MULTISET_LOCATOR               56
#define SQL_TYPE_DATE                      91
#define SQL_TYPE_TIME                      92
#define SQL_TYPE_TIMESTAMP                 93
#define SQL_TYPE_TIME_WITH_TIMEZONE        94
#define SQL_TYPE_TIMESTAMP_WITH_TIMEZONE   95
#define SQL_INTERVAL_YEAR                 101
#define SQL_INTERVAL_MONTH                102
#define SQL_INTERVAL_DAY                  103
#define SQL_INTERVAL_HOUR                 104
#define SQL_INTERVAL_MINUTE               105
#define SQL_INTERVAL_SECOND               106
#define SQL_INTERVAL_YEAR_TO_MONTH        107
#define SQL_INTERVAL_DAY_TO_HOUR          108
#define SQL_INTERVAL_DAY_TO_MINUTE        109
#define SQL_INTERVAL_DAY_TO_SECOND        110
#define SQL_INTERVAL_HOUR_TO_MINUTE       111
#define SQL_INTERVAL_HOUR_TO_SECOND       112
#define SQL_INTERVAL_MINUTE_TO_SECOND     113


/* Main return codes						*/
#define	SQL_ERROR			(-1)
#define	SQL_SUCCESS			0
#define	SQL_SUCCESS_WITH_INFO		1
#define	SQL_NO_DATA_FOUND		100

/*
 * for ODBC SQL Cursor Types
 */
#define SQL_CURSOR_FORWARD_ONLY         0UL
#define SQL_CURSOR_KEYSET_DRIVEN        1UL
#define SQL_CURSOR_DYNAMIC              2UL
#define SQL_CURSOR_STATIC               3UL
#define SQL_CURSOR_TYPE_DEFAULT         SQL_CURSOR_FORWARD_ONLY

#endif	/*	SQL_SUCCESS	*/

/* Handy macro for testing for success and success with info.		*/
/* BEWARE that this macro can have side effects since rc appears twice!	*/
/* So DONT use it as if(SQL_ok(func(...))) { ... }			*/
#define SQL_ok(rc)	((rc)==SQL_SUCCESS || (rc)==SQL_SUCCESS_WITH_INFO)


/* end of dbi_sql.h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\auto\DBI\Driver_xst.h ===
/*
#  $Id: Driver_xst.h 9454 2007-04-26 10:26:47Z timbo $
#  Copyright (c) 2002  Tim Bunce  Ireland
#
#  You may distribute under the terms of either the GNU General Public
#  License or the Artistic License, as specified in the Perl README file.
*/


/* This is really just a workaround for SUPER:: not working right for XS code.
 * It would be better if we setup perl's context so SUPER:: did the right thing
 * (borrowing the relevant magic from pp_entersub in perl pp_hot.c).
 * Then we could just use call_method("SUPER::foo") instead.
 */
static SV *
dbixst_bounce_method(char *methname, int params)
{
    dTHX;
    /* XXX this 'magic' undoes the dMARK embedded in the dXSARGS of our caller	*/
    /* so that the dXSARGS below can set things up as they were for our caller	*/
    void *xxx = PL_markstack_ptr++;
    dXSARGS; /* declares sp, ax, mark, items */
    int i;
    SV *sv;
    int debug = 0;
    D_imp_xxh(ST(0));
    if (debug >= 3) {
	PerlIO_printf(DBIc_LOGPIO(imp_xxh),
	    "    -> %s (trampoline call with %d (%ld) params)\n", methname, params, (long)items);
	xxx = xxx; /* avoid unused var warning */
    }
    EXTEND(SP, params);
    PUSHMARK(SP);
    for (i=0; i < params; ++i) {
	sv = (i >= items) ? &sv_undef : ST(i);
        PUSHs(sv);
    }
    PUTBACK;
    i = perl_call_method(methname, G_SCALAR);
    SPAGAIN;
    sv = (i) ? POPs : &sv_undef;
    PUTBACK;
    if (debug >= 3)
	PerlIO_printf(DBIc_LOGPIO(imp_xxh),
	    "    <- %s= %s (trampoline call return)\n", methname, neatsvpv(sv,0));
    return sv;
}


static int
dbdxst_bind_params(SV *sth, imp_sth_t *imp_sth, I32 items, I32 ax)
{
    /* Handle binding supplied values to placeholders.		*/
    /* items = one greater than the number of params		*/
    /* ax = ax from calling sub, maybe adjusted to match items	*/
    dTHX;
    int i;
    SV *idx;
    if (items-1 != DBIc_NUM_PARAMS(imp_sth)
	&& DBIc_NUM_PARAMS(imp_sth) != DBIc_NUM_PARAMS_AT_EXECUTE
    ) {
	char errmsg[99];
	sprintf(errmsg,"called with %d bind variables when %d are needed",
		(int)items-1, DBIc_NUM_PARAMS(imp_sth));
	sv_setpv(DBIc_ERRSTR(imp_sth), errmsg);
	sv_setiv(DBIc_ERR(imp_sth), (IV)-1);
	return 0;
    }
    idx = sv_2mortal(newSViv(0));
    for(i=1; i < items ; ++i) {
	SV* value = ST(i);
	if (SvGMAGICAL(value))
	    mg_get(value);	/* trigger magic to FETCH the value     */
	sv_setiv(idx, i);
	if (!dbd_bind_ph(sth, imp_sth, idx, value, 0, Nullsv, FALSE, 0)) {
	    return 0;	/* dbd_bind_ph already registered error	*/
	}
    }
    return 1;
}

#ifndef dbd_fetchall_arrayref
static SV *
dbdxst_fetchall_arrayref(SV *sth, SV *slice, SV *batch_row_count)
{
    dTHX;
    D_imp_sth(sth);
    SV *rows_rvav;
    if (SvOK(slice)) {  /* should never get here */
	char errmsg[99];
	sprintf(errmsg,"slice param not supported by XS version of fetchall_arrayref");
	sv_setpv(DBIc_ERRSTR(imp_sth), errmsg);
	sv_setiv(DBIc_ERR(imp_sth), (IV)-1);
	return &sv_undef;
    }
    else {
	IV maxrows = SvOK(batch_row_count) ? SvIV(batch_row_count) : -1;
	AV *fetched_av;
	AV *rows_av = newAV();
	if ( !DBIc_ACTIVE(imp_sth) && maxrows>0 ) {
	    /* to simplify application logic we return undef without an error	*/
	    /* if we've fetched all the rows and called with a batch_row_count	*/
	    return &sv_undef;
	}
	av_extend(rows_av, (maxrows>0) ? maxrows : 31);
	while ( (maxrows < 0 || maxrows-- > 0)
	    && (fetched_av = dbd_st_fetch(sth, imp_sth))
	) {
	    AV *copy_row_av = av_make(AvFILL(fetched_av)+1, AvARRAY(fetched_av));
	    av_push(rows_av, newRV_noinc((SV*)copy_row_av));
	}
	rows_rvav = sv_2mortal(newRV_noinc((SV *)rows_av));
    }
    return rows_rvav;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\BuildInfo.h ===
/* BuildInfo.h
 *
 * Copyright (C) 1998-2007 ActiveState Corp.  All rights reserved.
 *
 */

#ifndef ___BuildInfo__h___
#define ___BuildInfo__h___

#define ACTIVEPERL_PRODUCT      "ActivePerl"
#define ACTIVEPERL_VERSION      1002
#define ACTIVEPERL_SUBVERSION   0
#define ACTIVEPERL_CHANGELIST   " [283697]"
#define ACTIVEPERL_RELEASE_TYPE ""
#define PERL_VENDORLIB_NAME	"ActiveState"

#ifndef STRINGIFY
#  include "config.h"
#endif

/* Derived values and legacy */
#if ACTIVEPERL_SUBVERSION > 0
#  define PRODUCT_BUILD_NUMBER	STRINGIFY(ACTIVEPERL_VERSION) "." STRINGIFY(ACTIVEPERL_SUBVERSION)
#else
#  define PRODUCT_BUILD_NUMBER	STRINGIFY(ACTIVEPERL_VERSION)
#endif
#define PERLFILEVERSION		"5,10,0," STRINGIFY(ACTIVEPERL_VERSION) "\0"
#define PERLRC_VERSION		5,10,0,ACTIVEPERL_VERSION
#define PERLPRODUCTVERSION	"Build " PRODUCT_BUILD_NUMBER ACTIVEPERL_CHANGELIST "\0"
#define PERLPRODUCTNAME		ACTIVEPERL_PRODUCT "\0"
#define ACTIVEPERL_LOCAL_PATCHES_ENTRY	ACTIVEPERL_PRODUCT " Build " PRODUCT_BUILD_NUMBER ACTIVEPERL_CHANGELIST ACTIVEPERL_RELEASE_TYPE
#ifdef BUILT_BY_ACTIVESTATE
#define BINARY_BUILD_NOTICE	PerlIO_printf(PerlIO_stdout(), "\n\
Binary build " PRODUCT_BUILD_NUMBER ACTIVEPERL_CHANGELIST ACTIVEPERL_RELEASE_TYPE " provided by ActiveState http://www.ActiveState.com\n\
Built " __DATE__ " " __TIME__ "\n");
#endif

#endif  /* ___BuildInfo__h___ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\cc_runtime.h ===
/*    cc_runtime.h
 *
 *    Copyright (C) 1999, 2000, 2001, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define DOOP(ppname) PUTBACK; PL_op = ppname(aTHX); SPAGAIN
#define CCPP(s)   OP * s(pTHX)

#define PP_LIST(g) do {			\
	dMARK;				\
	if (g != G_ARRAY) {		\
	    if (++MARK <= SP)		\
		*MARK = *SP;		\
	    else			\
		*MARK = &PL_sv_undef;	\
	    SP = MARK;			\
	}				\
   } while (0)

#define MAYBE_TAINT_SASSIGN_SRC(sv) \
    if (PL_tainting && PL_tainted && (!SvGMAGICAL(left) || !SvSMAGICAL(left) || \
        !((mg=mg_find(left, PERL_MAGIC_taint)) && mg->mg_len & 1)))\
        TAINT_NOT

#define PP_PREINC(sv) do {	\
	if (SvIOK(sv)) {	\
            ++SvIVX(sv);	\
	    SvFLAGS(sv) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK); \
	}			\
	else			\
	    sv_inc(sv);		\
	SvSETMAGIC(sv);		\
    } while (0)

#define PP_UNSTACK do {		\
	TAINT_NOT;		\
	PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;	\
	FREETMPS;		\
	oldsave = PL_scopestack[PL_scopestack_ix - 1]; \
	LEAVE_SCOPE(oldsave);	\
	SPAGAIN;		\
    } while(0)

/* Anyone using eval "" deserves this mess */
#define PP_EVAL(ppaddr, nxt) do {		\
	dJMPENV;				\
	int ret;				\
	PUTBACK;				\
	JMPENV_PUSH(ret);			\
	switch (ret) {				\
	case 0:					\
	    PL_op = ppaddr(aTHX);		\
	    if (PL_op != nxt) CALLRUNOPS();	\
	    JMPENV_POP;				\
	    break;				\
	case 1: JMPENV_POP; JMPENV_JUMP(1);	\
	case 2: JMPENV_POP; JMPENV_JUMP(2);	\
	case 3:					\
	    JMPENV_POP;				\
	    if (PL_restartop && PL_restartop != nxt)		\
		JMPENV_JUMP(3);			\
	}					\
	PL_op = nxt;				\
	SPAGAIN;				\
    } while (0)


#define PP_ENTERTRY(jmpbuf,label)  \
	STMT_START {                    \
		int ret;		\
		JMPENV_PUSH_ENV(jmpbuf,ret);			\
		switch (ret) {				\
			case 1: JMPENV_POP_ENV(jmpbuf); JMPENV_JUMP(1);\
			case 2: JMPENV_POP_ENV(jmpbuf); JMPENV_JUMP(2);\
			case 3: JMPENV_POP_ENV(jmpbuf); SPAGAIN; goto label;\
		}                                       \
	} STMT_END
#define PP_LEAVETRY \
	STMT_START{ PL_top_env=PL_top_env->je_prev; }STMT_END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\config.h ===
/*
 * This file was produced by running the config_h.SH script, which
 * gets its values from undef, which is generally produced by
 * running Configure.
 *
 * Feel free to modify any of this as the need arises.  Note, however,
 * that running config_h.SH again will wipe out any changes you've made.
 * For a more permanent change edit undef and rerun config_h.SH.
 *
 * $Id: Config_h.U,v 3.0.1.5 1997/02/28 14:57:43 ram Exp $
 */

/*
 * Package name      : perl5
 * Source directory  : 
 * Configuration time: Thu Jan 10 11:00:30 2008
 * Configured by     : SYSTEM
 * Target system     : 
 */

#ifndef _config_h_
#define _config_h_

/* LOC_SED:
 *	This symbol holds the complete pathname to the sed program.
 */
#define LOC_SED 	""	/**/

/* HAS_ALARM:
 *	This symbol, if defined, indicates that the alarm routine is
 *	available.
 */
#define HAS_ALARM		/**/

/* HAS_BCMP:
 *	This symbol is defined if the bcmp() routine is available to
 *	compare blocks of memory.
 */
/*#define HAS_BCMP	/**/

/* HAS_BCOPY:
 *	This symbol is defined if the bcopy() routine is available to
 *	copy blocks of memory.
 */
/*#define HAS_BCOPY	/**/

/* HAS_BZERO:
 *	This symbol is defined if the bzero() routine is available to
 *	set a memory block to 0.
 */
/*#define HAS_BZERO	/**/

/* HAS_CHOWN:
 *	This symbol, if defined, indicates that the chown routine is
 *	available.
 */
/*#define HAS_CHOWN		/**/

/* HAS_CHROOT:
 *	This symbol, if defined, indicates that the chroot routine is
 *	available.
 */
/*#define HAS_CHROOT		/**/

/* HAS_CHSIZE:
 *	This symbol, if defined, indicates that the chsize routine is available
 *	to truncate files.  You might need a -lx to get this routine.
 */
#define	HAS_CHSIZE		/**/

/* HAS_CTERMID:
 *	This symbol, if defined, indicates that the ctermid routine is
 *	available to generate filename for terminal.
 */
/*#define HAS_CTERMID		/**/

/* HAS_CUSERID:
 *	This symbol, if defined, indicates that the cuserid routine is
 *	available to get character login names.
 */
/*#define HAS_CUSERID		/**/

/* HAS_DBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol DBL_DIG, which is the number
 *	of significant digits in a double precision number.  If this
 *	symbol is not defined, a guess of 15 is usually pretty good.
 */
#define HAS_DBL_DIG 	/**/

/* HAS_DIFFTIME:
 *	This symbol, if defined, indicates that the difftime routine is
 *	available.
 */
#define HAS_DIFFTIME		/**/

/* HAS_DLERROR:
 *	This symbol, if defined, indicates that the dlerror routine is
 *	available to return a string describing the last error that
 *	occurred from a call to dlopen(), dlclose() or dlsym().
 */
#define HAS_DLERROR	/**/

/* HAS_DUP2:
 *	This symbol, if defined, indicates that the dup2 routine is
 *	available to duplicate file descriptors.
 */
#define HAS_DUP2	/**/

/* HAS_FCHMOD:
 *	This symbol, if defined, indicates that the fchmod routine is available
 *	to change mode of opened files.  If unavailable, use chmod().
 */
/*#define HAS_FCHMOD		/**/

/* HAS_FCHOWN:
 *	This symbol, if defined, indicates that the fchown routine is available
 *	to change ownership of opened files.  If unavailable, use chown().
 */
/*#define HAS_FCHOWN		/**/

/* HAS_FCNTL:
 *	This symbol, if defined, indicates to the C program that
 *	the fcntl() function exists.
 */
/*#define HAS_FCNTL		/**/

/* HAS_FGETPOS:
 *	This symbol, if defined, indicates that the fgetpos routine is
 *	available to get the file position indicator, similar to ftell().
 */
#define HAS_FGETPOS	/**/

/* HAS_FLOCK:
 *	This symbol, if defined, indicates that the flock routine is
 *	available to do file locking.
 */
#define HAS_FLOCK		/**/

/* HAS_FORK:
 *	This symbol, if defined, indicates that the fork routine is
 *	available.
 */
/*#define HAS_FORK		/**/

/* HAS_FSETPOS:
 *	This symbol, if defined, indicates that the fsetpos routine is
 *	available to set the file position indicator, similar to fseek().
 */
#define HAS_FSETPOS	/**/

/* HAS_GETTIMEOFDAY:
 *	This symbol, if defined, indicates that the gettimeofday() system
 *	call is available for a sub-second accuracy clock. Usually, the file
 *	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
 *	The type "Timeval" should be used to refer to "struct timeval".
 */
#define HAS_GETTIMEOFDAY	/**/
#ifdef HAS_GETTIMEOFDAY
#define Timeval struct timeval	/* Structure used by gettimeofday() */
#endif

/* HAS_GETGROUPS:
 *	This symbol, if defined, indicates that the getgroups() routine is
 *	available to get the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_GETGROUPS		/**/

/* HAS_GETLOGIN:
 *	This symbol, if defined, indicates that the getlogin routine is
 *	available to get the login name.
 */
#define HAS_GETLOGIN		/**/

/* HAS_GETPGID:
 *	This symbol, if defined, indicates to the C program that 
 *	the getpgid(pid) function is available to get the
 *	process group id.
 */
/*#define HAS_GETPGID		/**/

/* HAS_GETPGRP2:
 *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
 *	routine is available to get the current process group.
 */
/*#define HAS_GETPGRP2		/**/

/* HAS_GETPPID:
 *	This symbol, if defined, indicates that the getppid routine is
 *	available to get the parent process ID.
 */
/*#define HAS_GETPPID		/**/

/* HAS_GETPRIORITY:
 *	This symbol, if defined, indicates that the getpriority routine is
 *	available to get a process's priority.
 */
/*#define HAS_GETPRIORITY		/**/

/* HAS_INET_ATON:
 *	This symbol, if defined, indicates to the C program that the
 *	inet_aton() function is available to parse IP address "dotted-quad"
 *	strings.
 */
/*#define HAS_INET_ATON		/**/

/* HAS_KILLPG:
 *	This symbol, if defined, indicates that the killpg routine is available
 *	to kill process groups.  If unavailable, you probably should use kill
 *	with a negative process number.
 */
#define HAS_KILLPG	/**/

/* HAS_LINK:
 *	This symbol, if defined, indicates that the link routine is
 *	available to create hard links.
 */
#define HAS_LINK	/**/

/* HAS_LOCALECONV:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available for numeric and monetary formatting conventions.
 */
#define HAS_LOCALECONV	/**/

/* HAS_LOCKF:
 *	This symbol, if defined, indicates that the lockf routine is
 *	available to do file locking.
 */
/*#define HAS_LOCKF		/**/

/* HAS_LSTAT:
 *	This symbol, if defined, indicates that the lstat routine is
 *	available to do file stats on symbolic links.
 */
/*#define HAS_LSTAT		/**/

/* HAS_MBLEN:
 *	This symbol, if defined, indicates that the mblen routine is available
 *	to find the number of bytes in a multibye character.
 */
#define HAS_MBLEN		/**/

/* HAS_MBSTOWCS:
 *	This symbol, if defined, indicates that the mbstowcs routine is
 *	available to covert a multibyte string into a wide character string.
 */
#define	HAS_MBSTOWCS		/**/

/* HAS_MBTOWC:
 *	This symbol, if defined, indicates that the mbtowc routine is available
 *	to covert a multibyte to a wide character.
 */
#define HAS_MBTOWC		/**/

/* HAS_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	to compare blocks of memory.
 */
#define HAS_MEMCMP	/**/

/* HAS_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy blocks of memory.
 */
#define HAS_MEMCPY	/**/

/* HAS_MEMMOVE:
 *	This symbol, if defined, indicates that the memmove routine is available
 *	to copy potentially overlapping blocks of memory. This should be used
 *	only when HAS_SAFE_BCOPY is not defined. If neither is there, roll your
 *	own version.
 */
#define HAS_MEMMOVE	/**/

/* HAS_MEMSET:
 *	This symbol, if defined, indicates that the memset routine is available
 *	to set blocks of memory.
 */
#define HAS_MEMSET	/**/

/* HAS_MKDIR:
 *	This symbol, if defined, indicates that the mkdir routine is available
 *	to create directories.  Otherwise you should fork off a new process to
 *	exec /bin/mkdir.
 */
#define HAS_MKDIR		/**/

/* HAS_MKFIFO:
 *	This symbol, if defined, indicates that the mkfifo routine is
 *	available to create FIFOs. Otherwise, mknod should be able to
 *	do it for you. However, if mkfifo is there, mknod might require
 *	super-user privileges which mkfifo will not.
 */
/*#define HAS_MKFIFO		/**/

/* HAS_MKTIME:
 *	This symbol, if defined, indicates that the mktime routine is
 *	available.
 */
#define HAS_MKTIME		/**/

/* HAS_MSYNC:
 *	This symbol, if defined, indicates that the msync system call is
 *	available to synchronize a mapped file.
 */
/*#define HAS_MSYNC		/**/

/* HAS_MUNMAP:
 *	This symbol, if defined, indicates that the munmap system call is
 *	available to unmap a region, usually mapped by mmap().
 */
/*#define HAS_MUNMAP		/**/

/* HAS_NICE:
 *	This symbol, if defined, indicates that the nice routine is
 *	available.
 */
/*#define HAS_NICE		/**/

/* HAS_PATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given filename.
 */
/* HAS_FPATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given open file descriptor.
 */
/*#define HAS_PATHCONF		/**/
/*#define HAS_FPATHCONF		/**/

/* HAS_PAUSE:
 *	This symbol, if defined, indicates that the pause routine is
 *	available to suspend a process until a signal is received.
 */
#define HAS_PAUSE		/**/

/* HAS_PIPE:
 *	This symbol, if defined, indicates that the pipe routine is
 *	available to create an inter-process channel.
 */
#define HAS_PIPE		/**/

/* HAS_READDIR:
 *	This symbol, if defined, indicates that the readdir routine is
 *	available to read directory entries. You may have to include
 *	<dirent.h>. See I_DIRENT.
 */
#define HAS_READDIR		/**/

/* HAS_SEEKDIR:
 *	This symbol, if defined, indicates that the seekdir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_SEEKDIR		/**/

/* HAS_TELLDIR:
 *	This symbol, if defined, indicates that the telldir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_TELLDIR		/**/

/* HAS_REWINDDIR:
 *	This symbol, if defined, indicates that the rewinddir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_REWINDDIR		/**/

/* HAS_READLINK:
 *	This symbol, if defined, indicates that the readlink routine is
 *	available to read the value of a symbolic link.
 */
/*#define HAS_READLINK		/**/

/* HAS_RENAME:
 *	This symbol, if defined, indicates that the rename routine is available
 *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
 *	trick.
 */
#define HAS_RENAME	/**/

/* HAS_RMDIR:
 *	This symbol, if defined, indicates that the rmdir routine is
 *	available to remove directories. Otherwise you should fork off a
 *	new process to exec /bin/rmdir.
 */
#define HAS_RMDIR		/**/

/* HAS_SELECT:
 *	This symbol, if defined, indicates that the select routine is
 *	available to select active file descriptors. If the timeout field
 *	is used, <sys/time.h> may need to be included.
 */
#define HAS_SELECT	/**/

/* HAS_SETEGID:
 *	This symbol, if defined, indicates that the setegid routine is available
 *	to change the effective gid of the current program.
 */
/*#define HAS_SETEGID		/**/

/* HAS_SETEUID:
 *	This symbol, if defined, indicates that the seteuid routine is available
 *	to change the effective uid of the current program.
 */
/*#define HAS_SETEUID		/**/

/* HAS_SETLINEBUF:
 *	This symbol, if defined, indicates that the setlinebuf routine is
 *	available to change stderr or stdout from block-buffered or unbuffered
 *	to a line-buffered mode.
 */
/*#define HAS_SETLINEBUF		/**/

/* HAS_SETLOCALE:
 *	This symbol, if defined, indicates that the setlocale routine is
 *	available to handle locale-specific ctype implementations.
 */
#define HAS_SETLOCALE	/**/

/* HAS_SETPGID:
 *	This symbol, if defined, indicates that the setpgid(pid, gpid)
 *	routine is available to set process group ID.
 */
/*#define HAS_SETPGID	/**/

/* HAS_SETPGRP2:
 *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
 *	routine is available to set the current process group.
 */
/*#define HAS_SETPGRP2		/**/

/* HAS_SETPRIORITY:
 *	This symbol, if defined, indicates that the setpriority routine is
 *	available to set a process's priority.
 */
/*#define HAS_SETPRIORITY		/**/

/* HAS_SETREGID:
 *	This symbol, if defined, indicates that the setregid routine is
 *	available to change the real and effective gid of the current
 *	process.
 */
/* HAS_SETRESGID:
 *	This symbol, if defined, indicates that the setresgid routine is
 *	available to change the real, effective and saved gid of the current
 *	process.
 */
/*#define HAS_SETREGID		/**/
/*#define HAS_SETRESGID		/**/

/* HAS_SETREUID:
 *	This symbol, if defined, indicates that the setreuid routine is
 *	available to change the real and effective uid of the current
 *	process.
 */
/* HAS_SETRESUID:
 *	This symbol, if defined, indicates that the setresuid routine is
 *	available to change the real, effective and saved uid of the current
 *	process.
 */
/*#define HAS_SETREUID		/**/
/*#define HAS_SETRESUID		/**/

/* HAS_SETRGID:
 *	This symbol, if defined, indicates that the setrgid routine is available
 *	to change the real gid of the current program.
 */
/*#define HAS_SETRGID		/**/

/* HAS_SETRUID:
 *	This symbol, if defined, indicates that the setruid routine is available
 *	to change the real uid of the current program.
 */
/*#define HAS_SETRUID		/**/

/* HAS_SETSID:
 *	This symbol, if defined, indicates that the setsid routine is
 *	available to set the process group ID.
 */
/*#define HAS_SETSID	/**/

/* HAS_STRCHR:
 *	This symbol is defined to indicate that the strchr()/strrchr()
 *	functions are available for string searching. If not, try the
 *	index()/rindex() pair.
 */
/* HAS_INDEX:
 *	This symbol is defined to indicate that the index()/rindex()
 *	functions are available for string searching.
 */
#define HAS_STRCHR	/**/
/*#define HAS_INDEX	/**/

/* HAS_STRCOLL:
 *	This symbol, if defined, indicates that the strcoll routine is
 *	available to compare strings using collating information.
 */
#define HAS_STRCOLL	/**/

/* HAS_STRTOD:
 *	This symbol, if defined, indicates that the strtod routine is
 *	available to provide better numeric string conversion than atof().
 */
#define HAS_STRTOD	/**/

/* HAS_STRTOL:
 *	This symbol, if defined, indicates that the strtol routine is available
 *	to provide better numeric string conversion than atoi() and friends.
 */
#define HAS_STRTOL	/**/

/* HAS_STRXFRM:
 *	This symbol, if defined, indicates that the strxfrm() routine is
 *	available to transform strings.
 */
#define HAS_STRXFRM	/**/

/* HAS_SYMLINK:
 *	This symbol, if defined, indicates that the symlink routine is available
 *	to create symbolic links.
 */
/*#define HAS_SYMLINK	/**/

/* HAS_SYSCALL:
 *	This symbol, if defined, indicates that the syscall routine is
 *	available to call arbitrary system calls. If undefined, that's tough.
 */
/*#define HAS_SYSCALL	/**/

/* HAS_SYSCONF:
 *	This symbol, if defined, indicates that sysconf() is available
 *	to determine system related limits and options.
 */
/*#define HAS_SYSCONF	/**/

/* HAS_SYSTEM:
 *	This symbol, if defined, indicates that the system routine is
 *	available to issue a shell command.
 */
#define HAS_SYSTEM	/**/

/* HAS_TCGETPGRP:
 *	This symbol, if defined, indicates that the tcgetpgrp routine is
 *	available to get foreground process group ID.
 */
/*#define HAS_TCGETPGRP		/**/

/* HAS_TCSETPGRP:
 *	This symbol, if defined, indicates that the tcsetpgrp routine is
 *	available to set foreground process group ID.
 */
/*#define HAS_TCSETPGRP		/**/

/* HAS_TRUNCATE:
 *	This symbol, if defined, indicates that the truncate routine is
 *	available to truncate files.
 */
/*#define HAS_TRUNCATE	/**/

/* HAS_TZNAME:
 *	This symbol, if defined, indicates that the tzname[] array is
 *	available to access timezone names.
 */
#define HAS_TZNAME		/**/

/* HAS_UMASK:
 *	This symbol, if defined, indicates that the umask routine is
 *	available to set and get the value of the file creation mask.
 */
#define HAS_UMASK		/**/

/* HAS_USLEEP:
 *	This symbol, if defined, indicates that the usleep routine is
 *	available to let the process sleep on a sub-second accuracy.
 */
/*#define HAS_USLEEP		/**/

/* HAS_WAIT4:
 *	This symbol, if defined, indicates that wait4() exists.
 */
/*#define HAS_WAIT4	/**/

/* HAS_WAITPID:
 *	This symbol, if defined, indicates that the waitpid routine is
 *	available to wait for child process.
 */
#define HAS_WAITPID	/**/

/* HAS_WCSTOMBS:
 *	This symbol, if defined, indicates that the wcstombs routine is
 *	available to convert wide character strings to multibyte strings.
 */
#define HAS_WCSTOMBS	/**/

/* HAS_WCTOMB:
 *	This symbol, if defined, indicates that the wctomb routine is available
 *	to covert a wide character to a multibyte.
 */
#define HAS_WCTOMB		/**/

/* I_ARPA_INET:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <arpa/inet.h> to get inet_addr and friends declarations.
 */
#define	I_ARPA_INET		/**/

/* I_DBM:
 *	This symbol, if defined, indicates that <dbm.h> exists and should
 *	be included.
 */
/* I_RPCSVC_DBM:
 *	This symbol, if defined, indicates that <rpcsvc/dbm.h> exists and
 *	should be included.
 */
/*#define I_DBM	/**/
#define I_RPCSVC_DBM	/**/

/* I_DLFCN:
 *	This symbol, if defined, indicates that <dlfcn.h> exists and should
 *	be included.
 */
#define I_DLFCN		/**/

/* I_FCNTL:
 *	This manifest constant tells the C program to include <fcntl.h>.
 */
#define I_FCNTL	/**/

/* I_FLOAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <float.h> to get definition of symbols like DBL_MAX or
 *	DBL_MIN, i.e. machine dependent floating point values.
 */
#define I_FLOAT		/**/

/* I_GDBM:
 *	This symbol, if defined, indicates that <gdbm.h> exists and should
 *	be included.
 */
/*#define I_GDBM	/**/

/* I_LIMITS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <limits.h> to get definition of symbols like WORD_BIT or
 *	LONG_MAX, i.e. machine dependant limitations.
 */
#define I_LIMITS		/**/

/* I_LOCALE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <locale.h>.
 */
#define	I_LOCALE		/**/

/* I_MATH:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <math.h>.
 */
#define I_MATH		/**/

/* I_MEMORY:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <memory.h>.
 */
/*#define I_MEMORY		/**/

/* I_NET_ERRNO:
 *	This symbol, if defined, indicates that <net/errno.h> exists and 
 *	should be included.
 */
/*#define I_NET_ERRNO		/**/

/* I_NETINET_IN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <netinet/in.h>. Otherwise, you may try <sys/in.h>.
 */
/*#define I_NETINET_IN	/**/

/* I_SFIO:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sfio.h>.
 */
/*#define	I_SFIO		/**/

/* I_STDDEF:
 *	This symbol, if defined, indicates that <stddef.h> exists and should
 *	be included.
 */
#define I_STDDEF	/**/

/* I_STDLIB:
 *	This symbol, if defined, indicates that <stdlib.h> exists and should
 *	be included.
 */
#define I_STDLIB		/**/

/* I_STRING:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
 */
#define I_STRING		/**/

/* I_SYS_DIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/dir.h>.
 */
/*#define I_SYS_DIR		/**/

/* I_SYS_FILE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/file.h> to get definition of R_OK and friends.
 */
/*#define I_SYS_FILE		/**/

/* I_SYS_IOCTL:
 *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
 *	be included. Otherwise, include <sgtty.h> or <termio.h>.
 */
/* I_SYS_SOCKIO:
 *	This symbol, if defined, indicates the <sys/sockio.h> should be included
 *	to get socket ioctl options, like SIOCATMARK.
 */
/*#define	I_SYS_IOCTL		/**/
/*#define I_SYS_SOCKIO	/**/

/* I_SYS_NDIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/ndir.h>.
 */
/*#define I_SYS_NDIR	/**/

/* I_SYS_PARAM:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/param.h>.
 */
/*#define I_SYS_PARAM		/**/

/* I_SYS_RESOURCE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/resource.h>.
 */
/*#define I_SYS_RESOURCE		/**/

/* I_SYS_SELECT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/select.h> in order to get definition of struct timeval.
 */
/*#define I_SYS_SELECT	/**/

/* I_SYS_STAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/stat.h>.
 */
#define	I_SYS_STAT		/**/

/* I_SYS_TIMES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/times.h>.
 */
/*#define	I_SYS_TIMES		/**/

/* I_SYS_TYPES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/types.h>.
 */
#define	I_SYS_TYPES		/**/

/* I_SYS_UN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/un.h> to get UNIX domain socket definitions.
 */
/*#define I_SYS_UN		/**/

/* I_SYS_WAIT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/wait.h>.
 */
/*#define I_SYS_WAIT	/**/

/* I_TERMIO:
 *	This symbol, if defined, indicates that the program should include
 *	<termio.h> rather than <sgtty.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/* I_TERMIOS:
 *	This symbol, if defined, indicates that the program should include
 *	the POSIX termios.h rather than sgtty.h or termio.h.
 *	There are also differences in the ioctl() calls that depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/**/
/*#define I_TERMIOS		/**/
/*#define I_SGTTY		/**/

/* I_UNISTD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <unistd.h>.
 */
/*#define I_UNISTD		/**/

/* I_UTIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <utime.h>.
 */
#define I_UTIME		/**/

/* I_VALUES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <values.h> to get definition of symbols like MINFLOAT or
 *	MAXLONG, i.e. machine dependant limitations.  Probably, you
 *	should use <limits.h> instead, if it is available.
 */
/*#define I_VALUES		/**/

/* I_VFORK:
 *	This symbol, if defined, indicates to the C program that it should
 *	include vfork.h.
 */
/*#define I_VFORK	/**/

/* INTSIZE:
 *	This symbol contains the value of sizeof(int) so that the C
 *	preprocessor can make decisions based on it.
 */
/* LONGSIZE:
 *	This symbol contains the value of sizeof(long) so that the C
 *	preprocessor can make decisions based on it.
 */
/* SHORTSIZE:
 *	This symbol contains the value of sizeof(short) so that the C
 *	preprocessor can make decisions based on it.
 */
#define INTSIZE 4		/**/
#define LONGSIZE 4		/**/
#define SHORTSIZE 2		/**/

/* MULTIARCH:
 *	This symbol, if defined, signifies that the build
 *	process will produce some binary files that are going to be
 *	used in a cross-platform environment.  This is the case for
 *	example with the NeXT "fat" binaries that contain executables
 *	for several CPUs.
 */
/*#define MULTIARCH		/**/

/* HAS_QUAD:
 *	This symbol, if defined, tells that there's a 64-bit integer type,
 *	Quad_t, and its unsigned counterpar, Uquad_t. QUADKIND will be one
 *	of QUAD_IS_INT, QUAD_IS_LONG, QUAD_IS_LONG_LONG, or QUAD_IS_INT64_T.
 */
/*#define HAS_QUAD	/**/
#ifdef HAS_QUAD
#   define Quad_t __int64	/**/
#   define Uquad_t unsigned __int64	/**/
#   define QUADKIND 5	/**/
#   define QUAD_IS_INT	1
#   define QUAD_IS_LONG	2
#   define QUAD_IS_LONG_LONG	3
#   define QUAD_IS_INT64_T	4
#endif

/* OSNAME:
 *	This symbol contains the name of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
/* OSVERS:
 *	This symbol contains the version of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
#define OSNAME "MSWin32"		/**/
#define OSVERS "5.00"		/**/

/* ARCHLIB:
 *	This variable, if defined, holds the name of the directory in
 *	which the user wants to put architecture-dependent public
 *	library files for perl5.  It is most often a local directory
 *	such as /usr/local/lib.  Programs using this variable must be
 *	prepared to deal with filename expansion.  If ARCHLIB is the
 *	same as PRIVLIB, it is not defined, since presumably the
 *	program already searches PRIVLIB.
 */
/* ARCHLIB_EXP:
 *	This symbol contains the ~name expanded version of ARCHLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define ARCHLIB "C:\Perl\\lib"		/**/
/*#define ARCHLIB_EXP ""	/**/

/* ARCHNAME:
 *	This symbol holds a string representing the architecture name.
 *	It may be used to construct an architecture-dependant pathname
 *	where library files may be held under a private library, for
 *	instance.
 */
#define ARCHNAME "MSWin32-x86-multi-thread"		/**/

/* BIN:
 *	This symbol holds the path of the bin directory where the package will
 *	be installed. Program must be prepared to deal with ~name substitution.
 */
/* BIN_EXP:
 *	This symbol is the filename expanded version of the BIN symbol, for
 *	programs that do not want to deal with that at run-time.
 */
/* PERL_RELOCATABLE_INC:
 *	This symbol, if defined, indicates that we'd like to relocate entries
 *	in @INC at run time based on the location of the perl binary.
 */
#define BIN "C:\Perl\\bin"	/**/
#define BIN_EXP "C:\Perl\\bin"	/**/
#define PERL_RELOCATABLE_INC "undef" 		/**/

/* CAT2:
 *	This macro concatenates 2 tokens together.
 */
/* STRINGIFY:
 *	This macro surrounds its token with double quotes.
 */
#if 42 == 1
#define CAT2(a,b)	a/**/b
#define STRINGIFY(a)	"a"
		/* If you can get stringification with catify, tell me how! */
#endif
#if 42 == 42
#define PeRl_CaTiFy(a, b)	a ## b	
#define PeRl_StGiFy(a)	#a
/* the additional level of indirection enables these macros to be
 * used as arguments to other macros.  See K&R 2nd ed., page 231. */
#define CAT2(a,b)	PeRl_CaTiFy(a,b)
#define StGiFy(a)	PeRl_StGiFy(a)
#define STRINGIFY(a)	PeRl_StGiFy(a)
#endif
#if 42 != 1 && 42 != 42
#   include "Bletch: How does this C preprocessor concatenate tokens?"
#endif

/* CPPSTDIN:
 *	This symbol contains the first part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.	 Typical value of "cc -E" or "/lib/cpp", but it can also
 *	call a wrapper. See CPPRUN.
 */
/* CPPMINUS:
 *	This symbol contains the second part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
 *	to specify standard input, otherwise the value is "".
 */
/* CPPRUN:
 *	This symbol contains the string which will invoke a C preprocessor on
 *	the standard input and produce to standard output. It needs to end
 *	with CPPLAST, after all other preprocessor flags have been specified.
 *	The main difference with CPPSTDIN is that this program will never be a
 *	pointer to a shell wrapper, i.e. it will be empty if no preprocessor is
 *	available directly to the user. Note that it may well be different from
 *	the preprocessor used to compile the C program.
 */
/* CPPLAST:
 *	This symbol is intended to be used along with CPPRUN in the same manner
 *	symbol CPPMINUS is used with CPPSTDIN. It contains either "-" or "".
 */
#define CPPSTDIN "cppstdin"
#define CPPMINUS ""
#define CPPRUN "cl -nologo -E"
#define CPPLAST ""

/* HAS_ACCESS:
 *	This manifest constant lets the C program know that the access()
 *	system call is available to check for accessibility using real UID/GID.
 *	(always present on UNIX.)
 */
#define HAS_ACCESS		/**/

/* HAS_ACCESSX:
 *	This symbol, if defined, indicates that the accessx routine is
 *	available to do extended access checks.
 */
/*#define HAS_ACCESSX		/**/

/* HAS_ASCTIME_R:
 *	This symbol, if defined, indicates that the asctime_r routine
 *	is available to asctime re-entrantly.
 */
/* ASCTIME_R_PROTO:
 *	This symbol encodes the prototype of asctime_r.
 *	It is zero if d_asctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_asctime_r
 *	is defined.
 */
/*#define HAS_ASCTIME_R	   /**/
#define ASCTIME_R_PROTO 0	   /**/

/* HASATTRIBUTE_FORMAT:
 *	Can we handle GCC attribute for checking printf-style formats
 */
/* PRINTF_FORMAT_NULL_OK:
 *	Allows __printf__ format to be null when checking printf-style
 */
/* HASATTRIBUTE_MALLOC:
 *	Can we handle GCC attribute for malloc-style functions.
 */
/* HASATTRIBUTE_NONNULL:
 *	Can we handle GCC attribute for nonnull function parms.
 */
/* HASATTRIBUTE_NORETURN:
 *	Can we handle GCC attribute for functions that do not return
 */
/* HASATTRIBUTE_PURE:
 *	Can we handle GCC attribute for pure functions
 */
/* HASATTRIBUTE_UNUSED:
 *	Can we handle GCC attribute for unused variables and arguments
 */
/* HASATTRIBUTE_WARN_UNUSED_RESULT:
 *	Can we handle GCC attribute for warning on unused results
 */
/*#define HASATTRIBUTE_FORMAT	/**/
/*#define PRINTF_FORMAT_NULL_OK	/**/
/*#define HASATTRIBUTE_NORETURN	/**/
/*#define HASATTRIBUTE_MALLOC	/**/
/*#define HASATTRIBUTE_NONNULL	/**/
/*#define HASATTRIBUTE_PURE	/**/
/*#define HASATTRIBUTE_UNUSED	/**/
/*#define HASATTRIBUTE_WARN_UNUSED_RESULT	/**/

/* HASCONST:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the const type. There is no need to actually test for that symbol
 *	within your programs. The mere use of the "const" keyword will
 *	trigger the necessary tests.
 */
#define HASCONST	/**/
#ifndef HASCONST
#define const
#endif

/* HAS_CRYPT:
 *	This symbol, if defined, indicates that the crypt routine is available
 *	to encrypt passwords and the like.
 */
#define HAS_CRYPT		/**/

/* HAS_CRYPT_R:
 *	This symbol, if defined, indicates that the crypt_r routine
 *	is available to crypt re-entrantly.
 */
/* CRYPT_R_PROTO:
 *	This symbol encodes the prototype of crypt_r.
 *	It is zero if d_crypt_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_crypt_r
 *	is defined.
 */
/*#define HAS_CRYPT_R	   /**/
#define CRYPT_R_PROTO 0	   /**/

/* HAS_CSH:
 *	This symbol, if defined, indicates that the C-shell exists.
 */
/* CSH:
 *	This symbol, if defined, contains the full pathname of csh.
 */
/*#define HAS_CSH		/**/
#ifdef HAS_CSH
#define CSH ""	/**/
#endif

/* HAS_CTERMID_R:
 *	This symbol, if defined, indicates that the ctermid_r routine
 *	is available to ctermid re-entrantly.
 */
/* CTERMID_R_PROTO:
 *	This symbol encodes the prototype of ctermid_r.
 *	It is zero if d_ctermid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctermid_r
 *	is defined.
 */
/*#define HAS_CTERMID_R	   /**/
#define CTERMID_R_PROTO 0	   /**/

/* HAS_CTIME_R:
 *	This symbol, if defined, indicates that the ctime_r routine
 *	is available to ctime re-entrantly.
 */
/* CTIME_R_PROTO:
 *	This symbol encodes the prototype of ctime_r.
 *	It is zero if d_ctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctime_r
 *	is defined.
 */
/*#define HAS_CTIME_R	   /**/
#define CTIME_R_PROTO 0	   /**/

/* SETUID_SCRIPTS_ARE_SECURE_NOW:
 *	This symbol, if defined, indicates that the bug that prevents
 *	setuid scripts from being secure is not present in this kernel.
 */
/* DOSUID:
 *	This symbol, if defined, indicates that the C program should
 *	check the script that it is executing for setuid/setgid bits, and
 *	attempt to emulate setuid/setgid on systems that have disabled
 *	setuid #! scripts because the kernel can't do it securely.
 *	It is up to the package designer to make sure that this emulation
 *	is done securely.  Among other things, it should do an fstat on
 *	the script it just opened to make sure it really is a setuid/setgid
 *	script, it should make sure the arguments passed correspond exactly
 *	to the argument on the #! line, and it should not trust any
 *	subprocesses to which it must pass the filename rather than the
 *	file descriptor of the script to be executed.
 */
/*#define SETUID_SCRIPTS_ARE_SECURE_NOW	/**/
/*#define DOSUID		/**/

/* HAS_DRAND48_R:
 *	This symbol, if defined, indicates that the drand48_r routine
 *	is available to drand48 re-entrantly.
 */
/* DRAND48_R_PROTO:
 *	This symbol encodes the prototype of drand48_r.
 *	It is zero if d_drand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_drand48_r
 *	is defined.
 */
/*#define HAS_DRAND48_R	   /**/
#define DRAND48_R_PROTO 0	   /**/

/* HAS_DRAND48_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the drand48() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern double drand48(void);
 */
/*#define	HAS_DRAND48_PROTO	/**/

/* HAS_EACCESS:
 *	This symbol, if defined, indicates that the eaccess routine is
 *	available to do extended access checks.
 */
/*#define HAS_EACCESS		/**/

/* HAS_ENDGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the group database.
 */
/*#define HAS_ENDGRENT		/**/

/* HAS_ENDGRENT_R:
 *	This symbol, if defined, indicates that the endgrent_r routine
 *	is available to endgrent re-entrantly.
 */
/* ENDGRENT_R_PROTO:
 *	This symbol encodes the prototype of endgrent_r.
 *	It is zero if d_endgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endgrent_r
 *	is defined.
 */
/*#define HAS_ENDGRENT_R	   /**/
#define ENDGRENT_R_PROTO 0	   /**/

/* HAS_ENDHOSTENT:
 *	This symbol, if defined, indicates that the endhostent() routine is
 *	available to close whatever was being used for host queries.
 */
/*#define HAS_ENDHOSTENT		/**/

/* HAS_ENDHOSTENT_R:
 *	This symbol, if defined, indicates that the endhostent_r routine
 *	is available to endhostent re-entrantly.
 */
/* ENDHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of endhostent_r.
 *	It is zero if d_endhostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endhostent_r
 *	is defined.
 */
/*#define HAS_ENDHOSTENT_R	   /**/
#define ENDHOSTENT_R_PROTO 0	   /**/

/* HAS_ENDNETENT:
 *	This symbol, if defined, indicates that the endnetent() routine is
 *	available to close whatever was being used for network queries.
 */
/*#define HAS_ENDNETENT		/**/

/* HAS_ENDNETENT_R:
 *	This symbol, if defined, indicates that the endnetent_r routine
 *	is available to endnetent re-entrantly.
 */
/* ENDNETENT_R_PROTO:
 *	This symbol encodes the prototype of endnetent_r.
 *	It is zero if d_endnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endnetent_r
 *	is defined.
 */
/*#define HAS_ENDNETENT_R	   /**/
#define ENDNETENT_R_PROTO 0	   /**/

/* HAS_ENDPROTOENT:
 *	This symbol, if defined, indicates that the endprotoent() routine is
 *	available to close whatever was being used for protocol queries.
 */
/*#define HAS_ENDPROTOENT		/**/

/* HAS_ENDPROTOENT_R:
 *	This symbol, if defined, indicates that the endprotoent_r routine
 *	is available to endprotoent re-entrantly.
 */
/* ENDPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of endprotoent_r.
 *	It is zero if d_endprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endprotoent_r
 *	is defined.
 */
/*#define HAS_ENDPROTOENT_R	   /**/
#define ENDPROTOENT_R_PROTO 0	   /**/

/* HAS_ENDPWENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the passwd database.
 */
/*#define HAS_ENDPWENT		/**/

/* HAS_ENDPWENT_R:
 *	This symbol, if defined, indicates that the endpwent_r routine
 *	is available to endpwent re-entrantly.
 */
/* ENDPWENT_R_PROTO:
 *	This symbol encodes the prototype of endpwent_r.
 *	It is zero if d_endpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endpwent_r
 *	is defined.
 */
/*#define HAS_ENDPWENT_R	   /**/
#define ENDPWENT_R_PROTO 0	   /**/

/* HAS_ENDSERVENT:
 *	This symbol, if defined, indicates that the endservent() routine is
 *	available to close whatever was being used for service queries.
 */
/*#define HAS_ENDSERVENT		/**/

/* HAS_ENDSERVENT_R:
 *	This symbol, if defined, indicates that the endservent_r routine
 *	is available to endservent re-entrantly.
 */
/* ENDSERVENT_R_PROTO:
 *	This symbol encodes the prototype of endservent_r.
 *	It is zero if d_endservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endservent_r
 *	is defined.
 */
/*#define HAS_ENDSERVENT_R	   /**/
#define ENDSERVENT_R_PROTO 0	   /**/

/* FLEXFILENAMES:
 *	This symbol, if defined, indicates that the system supports filenames
 *	longer than 14 characters.
 */
#define	FLEXFILENAMES		/**/

/* HAS_GETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for sequential access of the group database.
 */
/*#define HAS_GETGRENT		/**/

/* HAS_GETGRENT_R:
 *	This symbol, if defined, indicates that the getgrent_r routine
 *	is available to getgrent re-entrantly.
 */
/* GETGRENT_R_PROTO:
 *	This symbol encodes the prototype of getgrent_r.
 *	It is zero if d_getgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrent_r
 *	is defined.
 */
/*#define HAS_GETGRENT_R	   /**/
#define GETGRENT_R_PROTO 0	   /**/

/* HAS_GETGRGID_R:
 *	This symbol, if defined, indicates that the getgrgid_r routine
 *	is available to getgrgid re-entrantly.
 */
/* GETGRGID_R_PROTO:
 *	This symbol encodes the prototype of getgrgid_r.
 *	It is zero if d_getgrgid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrgid_r
 *	is defined.
 */
/*#define HAS_GETGRGID_R	   /**/
#define GETGRGID_R_PROTO 0	   /**/

/* HAS_GETGRNAM_R:
 *	This symbol, if defined, indicates that the getgrnam_r routine
 *	is available to getgrnam re-entrantly.
 */
/* GETGRNAM_R_PROTO:
 *	This symbol encodes the prototype of getgrnam_r.
 *	It is zero if d_getgrnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrnam_r
 *	is defined.
 */
/*#define HAS_GETGRNAM_R	   /**/
#define GETGRNAM_R_PROTO 0	   /**/

/* HAS_GETHOSTBYADDR:
 *	This symbol, if defined, indicates that the gethostbyaddr() routine is
 *	available to look up hosts by their IP addresses.
 */
#define HAS_GETHOSTBYADDR		/**/

/* HAS_GETHOSTBYNAME:
 *	This symbol, if defined, indicates that the gethostbyname() routine is
 *	available to look up host names in some data base or other.
 */
#define HAS_GETHOSTBYNAME		/**/

/* HAS_GETHOSTENT:
 *	This symbol, if defined, indicates that the gethostent() routine is
 *	available to look up host names in some data base or another.
 */
/*#define HAS_GETHOSTENT		/**/

/* HAS_GETHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	gethostname() routine to derive the host name.  See also HAS_UNAME
 *	and PHOSTNAME.
 */
/* HAS_UNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and PHOSTNAME.
 */
/* PHOSTNAME:
 *	This symbol, if defined, indicates the command to feed to the
 *	popen() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and HAS_UNAME.	Note that the command uses a fully qualified path,
 *	so that it is safe even if used by a process with super-user
 *	privileges.
 */
/* HAS_PHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	contents of PHOSTNAME as a command to feed to the popen() routine
 *	to derive the host name.
 */
#define HAS_GETHOSTNAME	/**/
#define HAS_UNAME		/**/
/*#define HAS_PHOSTNAME	/**/
#ifdef HAS_PHOSTNAME
#define PHOSTNAME ""	/* How to get the host name */
#endif

/* HAS_GETHOSTBYADDR_R:
 *	This symbol, if defined, indicates that the gethostbyaddr_r routine
 *	is available to gethostbyaddr re-entrantly.
 */
/* GETHOSTBYADDR_R_PROTO:
 *	This symbol encodes the prototype of gethostbyaddr_r.
 *	It is zero if d_gethostbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyaddr_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYADDR_R	   /**/
#define GETHOSTBYADDR_R_PROTO 0	   /**/

/* HAS_GETHOSTBYNAME_R:
 *	This symbol, if defined, indicates that the gethostbyname_r routine
 *	is available to gethostbyname re-entrantly.
 */
/* GETHOSTBYNAME_R_PROTO:
 *	This symbol encodes the prototype of gethostbyname_r.
 *	It is zero if d_gethostbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyname_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYNAME_R	   /**/
#define GETHOSTBYNAME_R_PROTO 0	   /**/

/* HAS_GETHOSTENT_R:
 *	This symbol, if defined, indicates that the gethostent_r routine
 *	is available to gethostent re-entrantly.
 */
/* GETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of gethostent_r.
 *	It is zero if d_gethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostent_r
 *	is defined.
 */
/*#define HAS_GETHOSTENT_R	   /**/
#define GETHOSTENT_R_PROTO 0	   /**/

/* HAS_GETHOST_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for gethostent(), gethostbyname(), and
 *	gethostbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETHOST_PROTOS	/**/

/* HAS_GETLOGIN_R:
 *	This symbol, if defined, indicates that the getlogin_r routine
 *	is available to getlogin re-entrantly.
 */
/* GETLOGIN_R_PROTO:
 *	This symbol encodes the prototype of getlogin_r.
 *	It is zero if d_getlogin_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getlogin_r
 *	is defined.
 */
/*#define HAS_GETLOGIN_R	   /**/
#define GETLOGIN_R_PROTO 0	   /**/

/* HAS_GETNETBYADDR:
 *	This symbol, if defined, indicates that the getnetbyaddr() routine is
 *	available to look up networks by their IP addresses.
 */
/*#define HAS_GETNETBYADDR		/**/

/* HAS_GETNETBYNAME:
 *	This symbol, if defined, indicates that the getnetbyname() routine is
 *	available to look up networks by their names.
 */
/*#define HAS_GETNETBYNAME		/**/

/* HAS_GETNETENT:
 *	This symbol, if defined, indicates that the getnetent() routine is
 *	available to look up network names in some data base or another.
 */
/*#define HAS_GETNETENT		/**/

/* HAS_GETNETBYADDR_R:
 *	This symbol, if defined, indicates that the getnetbyaddr_r routine
 *	is available to getnetbyaddr re-entrantly.
 */
/* GETNETBYADDR_R_PROTO:
 *	This symbol encodes the prototype of getnetbyaddr_r.
 *	It is zero if d_getnetbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyaddr_r
 *	is defined.
 */
/*#define HAS_GETNETBYADDR_R	   /**/
#define GETNETBYADDR_R_PROTO 0	   /**/

/* HAS_GETNETBYNAME_R:
 *	This symbol, if defined, indicates that the getnetbyname_r routine
 *	is available to getnetbyname re-entrantly.
 */
/* GETNETBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getnetbyname_r.
 *	It is zero if d_getnetbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyname_r
 *	is defined.
 */
/*#define HAS_GETNETBYNAME_R	   /**/
#define GETNETBYNAME_R_PROTO 0	   /**/

/* HAS_GETNETENT_R:
 *	This symbol, if defined, indicates that the getnetent_r routine
 *	is available to getnetent re-entrantly.
 */
/* GETNETENT_R_PROTO:
 *	This symbol encodes the prototype of getnetent_r.
 *	It is zero if d_getnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetent_r
 *	is defined.
 */
/*#define HAS_GETNETENT_R	   /**/
#define GETNETENT_R_PROTO 0	   /**/

/* HAS_GETNET_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getnetent(), getnetbyname(), and
 *	getnetbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETNET_PROTOS	/**/

/* HAS_GETPROTOENT:
 *	This symbol, if defined, indicates that the getprotoent() routine is
 *	available to look up protocols in some data base or another.
 */
/*#define HAS_GETPROTOENT		/**/

/* HAS_GETPGRP:
 *	This symbol, if defined, indicates that the getpgrp routine is
 *	available to get the current process group.
 */
/* USE_BSD_GETPGRP:
 *	This symbol, if defined, indicates that getpgrp needs one
 *	arguments whereas USG one needs none.
 */
/*#define HAS_GETPGRP		/**/
/*#define USE_BSD_GETPGRP	/**/

/* HAS_GETPROTOBYNAME:
 *	This symbol, if defined, indicates that the getprotobyname()
 *	routine is available to look up protocols by their name.
 */
/* HAS_GETPROTOBYNUMBER:
 *	This symbol, if defined, indicates that the getprotobynumber()
 *	routine is available to look up protocols by their number.
 */
#define HAS_GETPROTOBYNAME		/**/
#define HAS_GETPROTOBYNUMBER		/**/

/* HAS_GETPROTOBYNAME_R:
 *	This symbol, if defined, indicates that the getprotobyname_r routine
 *	is available to getprotobyname re-entrantly.
 */
/* GETPROTOBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getprotobyname_r.
 *	It is zero if d_getprotobyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobyname_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNAME_R	   /**/
#define GETPROTOBYNAME_R_PROTO 0	   /**/

/* HAS_GETPROTOBYNUMBER_R:
 *	This symbol, if defined, indicates that the getprotobynumber_r routine
 *	is available to getprotobynumber re-entrantly.
 */
/* GETPROTOBYNUMBER_R_PROTO:
 *	This symbol encodes the prototype of getprotobynumber_r.
 *	It is zero if d_getprotobynumber_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobynumber_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNUMBER_R	   /**/
#define GETPROTOBYNUMBER_R_PROTO 0	   /**/

/* HAS_GETPROTOENT_R:
 *	This symbol, if defined, indicates that the getprotoent_r routine
 *	is available to getprotoent re-entrantly.
 */
/* GETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of getprotoent_r.
 *	It is zero if d_getprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotoent_r
 *	is defined.
 */
/*#define HAS_GETPROTOENT_R	   /**/
#define GETPROTOENT_R_PROTO 0	   /**/

/* HAS_GETPROTO_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getprotoent(), getprotobyname(), and
 *	getprotobyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETPROTO_PROTOS	/**/

/* HAS_GETPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for sequential access of the passwd database.
 *	If this is not available, the older getpw() function may be available.
 */
/*#define HAS_GETPWENT		/**/

/* HAS_GETPWENT_R:
 *	This symbol, if defined, indicates that the getpwent_r routine
 *	is available to getpwent re-entrantly.
 */
/* GETPWENT_R_PROTO:
 *	This symbol encodes the prototype of getpwent_r.
 *	It is zero if d_getpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwent_r
 *	is defined.
 */
/*#define HAS_GETPWENT_R	   /**/
#define GETPWENT_R_PROTO 0	   /**/

/* HAS_GETPWNAM_R:
 *	This symbol, if defined, indicates that the getpwnam_r routine
 *	is available to getpwnam re-entrantly.
 */
/* GETPWNAM_R_PROTO:
 *	This symbol encodes the prototype of getpwnam_r.
 *	It is zero if d_getpwnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwnam_r
 *	is defined.
 */
/*#define HAS_GETPWNAM_R	   /**/
#define GETPWNAM_R_PROTO 0	   /**/

/* HAS_GETPWUID_R:
 *	This symbol, if defined, indicates that the getpwuid_r routine
 *	is available to getpwuid re-entrantly.
 */
/* GETPWUID_R_PROTO:
 *	This symbol encodes the prototype of getpwuid_r.
 *	It is zero if d_getpwuid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwuid_r
 *	is defined.
 */
/*#define HAS_GETPWUID_R	   /**/
#define GETPWUID_R_PROTO 0	   /**/

/* HAS_GETSERVENT:
 *	This symbol, if defined, indicates that the getservent() routine is
 *	available to look up network services in some data base or another.
 */
/*#define HAS_GETSERVENT		/**/

/* HAS_GETSERVBYNAME_R:
 *	This symbol, if defined, indicates that the getservbyname_r routine
 *	is available to getservbyname re-entrantly.
 */
/* GETSERVBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getservbyname_r.
 *	It is zero if d_getservbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyname_r
 *	is defined.
 */
/*#define HAS_GETSERVBYNAME_R	   /**/
#define GETSERVBYNAME_R_PROTO 0	   /**/

/* HAS_GETSERVBYPORT_R:
 *	This symbol, if defined, indicates that the getservbyport_r routine
 *	is available to getservbyport re-entrantly.
 */
/* GETSERVBYPORT_R_PROTO:
 *	This symbol encodes the prototype of getservbyport_r.
 *	It is zero if d_getservbyport_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyport_r
 *	is defined.
 */
/*#define HAS_GETSERVBYPORT_R	   /**/
#define GETSERVBYPORT_R_PROTO 0	   /**/

/* HAS_GETSERVENT_R:
 *	This symbol, if defined, indicates that the getservent_r routine
 *	is available to getservent re-entrantly.
 */
/* GETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of getservent_r.
 *	It is zero if d_getservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservent_r
 *	is defined.
 */
/*#define HAS_GETSERVENT_R	   /**/
#define GETSERVENT_R_PROTO 0	   /**/

/* HAS_GETSERV_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getservent(), getservbyname(), and
 *	getservbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETSERV_PROTOS	/**/

/* HAS_GETSPNAM_R:
 *	This symbol, if defined, indicates that the getspnam_r routine
 *	is available to getspnam re-entrantly.
 */
/* GETSPNAM_R_PROTO:
 *	This symbol encodes the prototype of getspnam_r.
 *	It is zero if d_getspnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getspnam_r
 *	is defined.
 */
/*#define HAS_GETSPNAM_R	   /**/
#define GETSPNAM_R_PROTO 0	   /**/

/* HAS_GETSERVBYNAME:
 *	This symbol, if defined, indicates that the getservbyname()
 *	routine is available to look up services by their name.
 */
/* HAS_GETSERVBYPORT:
 *	This symbol, if defined, indicates that the getservbyport()
 *	routine is available to look up services by their port.
 */
#define HAS_GETSERVBYNAME		/**/
#define HAS_GETSERVBYPORT		/**/

/* HAS_GMTIME_R:
 *	This symbol, if defined, indicates that the gmtime_r routine
 *	is available to gmtime re-entrantly.
 */
/* GMTIME_R_PROTO:
 *	This symbol encodes the prototype of gmtime_r.
 *	It is zero if d_gmtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gmtime_r
 *	is defined.
 */
/*#define HAS_GMTIME_R	   /**/
#define GMTIME_R_PROTO 0	   /**/

/* HAS_HTONL:
 *	This symbol, if defined, indicates that the htonl() routine (and
 *	friends htons() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_HTONS:
 *	This symbol, if defined, indicates that the htons() routine (and
 *	friends htonl() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHL:
 *	This symbol, if defined, indicates that the ntohl() routine (and
 *	friends htonl() htons() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHS:
 *	This symbol, if defined, indicates that the ntohs() routine (and
 *	friends htonl() htons() ntohl()) are available to do network
 *	order byte swapping.
 */
#define HAS_HTONL		/**/
#define HAS_HTONS		/**/
#define HAS_NTOHL		/**/
#define HAS_NTOHS		/**/

/* HAS_LOCALTIME_R:
 *	This symbol, if defined, indicates that the localtime_r routine
 *	is available to localtime re-entrantly.
 */
/* LOCALTIME_R_NEEDS_TZSET:
 *	Many libc's localtime_r implementations do not call tzset,
 *	making them differ from localtime(), and making timezone
 *	changes using \undef{TZ} without explicitly calling tzset
 *	impossible. This symbol makes us call tzset before localtime_r
 */
/*#define LOCALTIME_R_NEEDS_TZSET /**/
#ifdef LOCALTIME_R_NEEDS_TZSET
#define L_R_TZSET tzset(),
#else
#define L_R_TZSET
#endif

/* LOCALTIME_R_PROTO:
 *	This symbol encodes the prototype of localtime_r.
 *	It is zero if d_localtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_localtime_r
 *	is defined.
 */
/*#define HAS_LOCALTIME_R	   /**/
#define LOCALTIME_R_PROTO 0	   /**/

/* HAS_LONG_DOUBLE:
 *	This symbol will be defined if the C compiler supports long
 *	doubles.
 */
/* LONG_DOUBLESIZE:
 *	This symbol contains the size of a long double, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long doubles.
 */
#define HAS_LONG_DOUBLE		/**/
#ifdef HAS_LONG_DOUBLE
#define LONG_DOUBLESIZE 10		/**/
#endif

/* HAS_LONG_LONG:
 *	This symbol will be defined if the C compiler supports long long.
 */
/* LONGLONGSIZE:
 *	This symbol contains the size of a long long, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long long.
 */
/*#define HAS_LONG_LONG		/**/
#ifdef HAS_LONG_LONG
#define LONGLONGSIZE 8		/**/
#endif

/* HAS_LSEEK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the lseek() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern off_t lseek(int, off_t, int);
 */
#define	HAS_LSEEK_PROTO	/**/

/* HAS_MEMCHR:
 *	This symbol, if defined, indicates that the memchr routine is available
 *	to locate characters within a C string.
 */
#define HAS_MEMCHR	/**/

/* HAS_MKSTEMP:
 *	This symbol, if defined, indicates that the mkstemp routine is
 *	available to exclusively create and open a uniquely named
 *	temporary file.
 */
/*#define HAS_MKSTEMP		/**/

/* HAS_MMAP:
 *	This symbol, if defined, indicates that the mmap system call is
 *	available to map a file into memory.
 */
/* Mmap_t:
 *	This symbol holds the return type of the mmap() system call
 *	(and simultaneously the type of the first argument).
 *	Usually set to 'void *' or 'caddr_t'.
 */
/*#define HAS_MMAP		/**/
#define Mmap_t void *	/**/

/* HAS_MSG:
 *	This symbol, if defined, indicates that the entire msg*(2) library is
 *	supported (IPC mechanism based on message queues).
 */
/*#define HAS_MSG		/**/

/* HAS_POLL:
 *	This symbol, if defined, indicates that the poll routine is
 *	available to poll active file descriptors. You may safely
 *	include <poll.h> when both this symbol *and* I_POLL are defined.
 */
/*#define HAS_POLL		/**/

/* OLD_PTHREAD_CREATE_JOINABLE:
 *	This symbol, if defined, indicates how to create pthread
 *	in joinable (aka undetached) state.  NOTE: not defined
 *	if pthread.h already has defined PTHREAD_CREATE_JOINABLE
 *	(the new version of the constant).
 *	If defined, known values are PTHREAD_CREATE_UNDETACHED
 *	and __UNDETACHED.
 */
/*#define OLD_PTHREAD_CREATE_JOINABLE  /**/

/* HAS_PTHREAD_ATFORK:
 *	This symbol, if defined, indicates that the pthread_atfork routine
 *	is available to setup fork handlers.
 */
/*#define HAS_PTHREAD_ATFORK		/**/

/* HAS_PTHREAD_YIELD:
 *	This symbol, if defined, indicates that the pthread_yield 
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/* SCHED_YIELD:
 *	This symbol defines the way to yield the execution of
 *	the current thread.  Known ways are sched_yield,
 *	pthread_yield, and pthread_yield with NULL.
 */
/* HAS_SCHED_YIELD:
 *	This symbol, if defined, indicates that the sched_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/*#define HAS_PTHREAD_YIELD	/**/
#define SCHED_YIELD		/**/
/*#define HAS_SCHED_YIELD	/**/

/* HAS_RANDOM_R:
 *	This symbol, if defined, indicates that the random_r routine
 *	is available to random re-entrantly.
 */
/* RANDOM_R_PROTO:
 *	This symbol encodes the prototype of random_r.
 *	It is zero if d_random_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_random_r
 *	is defined.
 */
/*#define HAS_RANDOM_R	   /**/
#define RANDOM_R_PROTO 0	   /**/

/* HAS_READDIR64_R:
 *	This symbol, if defined, indicates that the readdir64_r routine
 *	is available to readdir64 re-entrantly.
 */
/* READDIR64_R_PROTO:
 *	This symbol encodes the prototype of readdir64_r.
 *	It is zero if d_readdir64_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir64_r
 *	is defined.
 */
/*#define HAS_READDIR64_R	   /**/
#define READDIR64_R_PROTO 0	   /**/

/* HAS_READDIR_R:
 *	This symbol, if defined, indicates that the readdir_r routine
 *	is available to readdir re-entrantly.
 */
/* READDIR_R_PROTO:
 *	This symbol encodes the prototype of readdir_r.
 *	It is zero if d_readdir_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir_r
 *	is defined.
 */
/*#define HAS_READDIR_R	   /**/
#define READDIR_R_PROTO 0	   /**/

/* HAS_SEM:
 *	This symbol, if defined, indicates that the entire sem*(2) library is
 *	supported.
 */
/*#define HAS_SEM		/**/

/* HAS_SETGRENT:
 *	This symbol, if defined, indicates that the setgrent routine is
 *	available for initializing sequential access of the group database.
 */
/*#define HAS_SETGRENT		/**/

/* HAS_SETGRENT_R:
 *	This symbol, if defined, indicates that the setgrent_r routine
 *	is available to setgrent re-entrantly.
 */
/* SETGRENT_R_PROTO:
 *	This symbol encodes the prototype of setgrent_r.
 *	It is zero if d_setgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setgrent_r
 *	is defined.
 */
/*#define HAS_SETGRENT_R	   /**/
#define SETGRENT_R_PROTO 0	   /**/

/* HAS_SETGROUPS:
 *	This symbol, if defined, indicates that the setgroups() routine is
 *	available to set the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_SETGROUPS		/**/

/* HAS_SETHOSTENT:
 *	This symbol, if defined, indicates that the sethostent() routine is
 *	available.
 */
/*#define HAS_SETHOSTENT		/**/

/* HAS_SETHOSTENT_R:
 *	This symbol, if defined, indicates that the sethostent_r routine
 *	is available to sethostent re-entrantly.
 */
/* SETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of sethostent_r.
 *	It is zero if d_sethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_sethostent_r
 *	is defined.
 */
/*#define HAS_SETHOSTENT_R	   /**/
#define SETHOSTENT_R_PROTO 0	   /**/

/* HAS_SETLOCALE_R:
 *	This symbol, if defined, indicates that the setlocale_r routine
 *	is available to setlocale re-entrantly.
 */
/* SETLOCALE_R_PROTO:
 *	This symbol encodes the prototype of setlocale_r.
 *	It is zero if d_setlocale_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setlocale_r
 *	is defined.
 */
/*#define HAS_SETLOCALE_R	   /**/
#define SETLOCALE_R_PROTO 0	   /**/

/* HAS_SETNETENT:
 *	This symbol, if defined, indicates that the setnetent() routine is
 *	available.
 */
/*#define HAS_SETNETENT		/**/

/* HAS_SETNETENT_R:
 *	This symbol, if defined, indicates that the setnetent_r routine
 *	is available to setnetent re-entrantly.
 */
/* SETNETENT_R_PROTO:
 *	This symbol encodes the prototype of setnetent_r.
 *	It is zero if d_setnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setnetent_r
 *	is defined.
 */
/*#define HAS_SETNETENT_R	   /**/
#define SETNETENT_R_PROTO 0	   /**/

/* HAS_SETPROTOENT:
 *	This symbol, if defined, indicates that the setprotoent() routine is
 *	available.
 */
/*#define HAS_SETPROTOENT		/**/

/* HAS_SETPGRP:
 *	This symbol, if defined, indicates that the setpgrp routine is
 *	available to set the current process group.
 */
/* USE_BSD_SETPGRP:
 *	This symbol, if defined, indicates that setpgrp needs two
 *	arguments whereas USG one needs none.  See also HAS_SETPGID
 *	for a POSIX interface.
 */
/*#define HAS_SETPGRP		/**/
/*#define USE_BSD_SETPGRP	/**/

/* HAS_SETPROTOENT_R:
 *	This symbol, if defined, indicates that the setprotoent_r routine
 *	is available to setprotoent re-entrantly.
 */
/* SETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of setprotoent_r.
 *	It is zero if d_setprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setprotoent_r
 *	is defined.
 */
/*#define HAS_SETPROTOENT_R	   /**/
#define SETPROTOENT_R_PROTO 0	   /**/

/* HAS_SETPWENT:
 *	This symbol, if defined, indicates that the setpwent routine is
 *	available for initializing sequential access of the passwd database.
 */
/*#define HAS_SETPWENT		/**/

/* HAS_SETPWENT_R:
 *	This symbol, if defined, indicates that the setpwent_r routine
 *	is available to setpwent re-entrantly.
 */
/* SETPWENT_R_PROTO:
 *	This symbol encodes the prototype of setpwent_r.
 *	It is zero if d_setpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setpwent_r
 *	is defined.
 */
/*#define HAS_SETPWENT_R	   /**/
#define SETPWENT_R_PROTO 0	   /**/

/* HAS_SETSERVENT:
 *	This symbol, if defined, indicates that the setservent() routine is
 *	available.
 */
/*#define HAS_SETSERVENT		/**/

/* HAS_SETSERVENT_R:
 *	This symbol, if defined, indicates that the setservent_r routine
 *	is available to setservent re-entrantly.
 */
/* SETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of setservent_r.
 *	It is zero if d_setservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setservent_r
 *	is defined.
 */
/*#define HAS_SETSERVENT_R	   /**/
#define SETSERVENT_R_PROTO 0	   /**/

/* HAS_SETVBUF:
 *	This symbol, if defined, indicates that the setvbuf routine is
 *	available to change buffering on an open stdio stream.
 *	to a line-buffered mode.
 */
#define HAS_SETVBUF		/**/

/* HAS_SHM:
 *	This symbol, if defined, indicates that the entire shm*(2) library is
 *	supported.
 */
/*#define HAS_SHM		/**/

/* Shmat_t:
 *	This symbol holds the return type of the shmat() system call.
 *	Usually set to 'void *' or 'char *'.
 */
/* HAS_SHMAT_PROTOTYPE:
 *	This symbol, if defined, indicates that the sys/shm.h includes
 *	a prototype for shmat().  Otherwise, it is up to the program to
 *	guess one.  Shmat_t shmat(int, Shmat_t, int) is a good guess,
 *	but not always right so it should be emitted by the program only
 *	when HAS_SHMAT_PROTOTYPE is not defined to avoid conflicting defs.
 */
#define Shmat_t void *	/**/
/*#define HAS_SHMAT_PROTOTYPE	/**/

/* HAS_SOCKET:
 *	This symbol, if defined, indicates that the BSD socket interface is
 *	supported.
 */
/* HAS_SOCKETPAIR:
 *	This symbol, if defined, indicates that the BSD socketpair() call is
 *	supported.
 */
/* HAS_MSG_CTRUNC:
 *	This symbol, if defined, indicates that the MSG_CTRUNC is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_DONTROUTE:
 *	This symbol, if defined, indicates that the MSG_DONTROUTE is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_OOB:
 *	This symbol, if defined, indicates that the MSG_OOB is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PEEK:
 *	This symbol, if defined, indicates that the MSG_PEEK is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PROXY:
 *	This symbol, if defined, indicates that the MSG_PROXY is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_SCM_RIGHTS:
 *	This symbol, if defined, indicates that the SCM_RIGHTS is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
#define	HAS_SOCKET		/**/
/*#define	HAS_SOCKETPAIR	/**/
/*#define	HAS_MSG_CTRUNC	/**/
/*#define	HAS_MSG_DONTROUTE	/**/
/*#define	HAS_MSG_OOB	/**/
/*#define	HAS_MSG_PEEK	/**/
/*#define	HAS_MSG_PROXY	/**/
/*#define	HAS_SCM_RIGHTS	/**/

/* HAS_SRAND48_R:
 *	This symbol, if defined, indicates that the srand48_r routine
 *	is available to srand48 re-entrantly.
 */
/* SRAND48_R_PROTO:
 *	This symbol encodes the prototype of srand48_r.
 *	It is zero if d_srand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srand48_r
 *	is defined.
 */
/*#define HAS_SRAND48_R	   /**/
#define SRAND48_R_PROTO 0	   /**/

/* HAS_SRANDOM_R:
 *	This symbol, if defined, indicates that the srandom_r routine
 *	is available to srandom re-entrantly.
 */
/* SRANDOM_R_PROTO:
 *	This symbol encodes the prototype of srandom_r.
 *	It is zero if d_srandom_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srandom_r
 *	is defined.
 */
/*#define HAS_SRANDOM_R	   /**/
#define SRANDOM_R_PROTO 0	   /**/

/* USE_STAT_BLOCKS:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_blksize and st_blocks.
 */
#ifndef USE_STAT_BLOCKS
/*#define USE_STAT_BLOCKS 	/**/
#endif

/* USE_STRUCT_COPY:
 *	This symbol, if defined, indicates that this C compiler knows how
 *	to copy structures.  If undefined, you'll need to use a block copy
 *	routine of some sort instead.
 */
#define	USE_STRUCT_COPY	/**/

/* HAS_STRERROR:
 *	This symbol, if defined, indicates that the strerror routine is
 *	available to translate error numbers to strings. See the writeup
 *	of Strerror() in this file before you try to define your own.
 */
/* HAS_SYS_ERRLIST:
 *	This symbol, if defined, indicates that the sys_errlist array is
 *	available to translate error numbers to strings. The extern int
 *	sys_nerr gives the size of that table.
 */
/* Strerror:
 *	This preprocessor symbol is defined as a macro if strerror() is
 *	not available to translate error numbers to strings but sys_errlist[]
 *	array is there.
 */
#define HAS_STRERROR		/**/
#define HAS_SYS_ERRLIST	/**/
#define Strerror(e) strerror(e)

/* HAS_STRERROR_R:
 *	This symbol, if defined, indicates that the strerror_r routine
 *	is available to strerror re-entrantly.
 */
/* STRERROR_R_PROTO:
 *	This symbol encodes the prototype of strerror_r.
 *	It is zero if d_strerror_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_strerror_r
 *	is defined.
 */
/*#define HAS_STRERROR_R	   /**/
#define STRERROR_R_PROTO 0	   /**/

/* HAS_STRTOUL:
 *	This symbol, if defined, indicates that the strtoul routine is
 *	available to provide conversion of strings to unsigned long.
 */
#define HAS_STRTOUL	/**/

/* HAS_TIME:
 *	This symbol, if defined, indicates that the time() routine exists.
 */
/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define HAS_TIME		/**/
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 * use getrusage(). It may be necessary to include <sys/times.h>.
 */
#define HAS_TIMES		/**/

/* HAS_TMPNAM_R:
 *	This symbol, if defined, indicates that the tmpnam_r routine
 *	is available to tmpnam re-entrantly.
 */
/* TMPNAM_R_PROTO:
 *	This symbol encodes the prototype of tmpnam_r.
 *	It is zero if d_tmpnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_tmpnam_r
 *	is defined.
 */
/*#define HAS_TMPNAM_R	   /**/
#define TMPNAM_R_PROTO 0	   /**/

/* HAS_TTYNAME_R:
 *	This symbol, if defined, indicates that the ttyname_r routine
 *	is available to ttyname re-entrantly.
 */
/* TTYNAME_R_PROTO:
 *	This symbol encodes the prototype of ttyname_r.
 *	It is zero if d_ttyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ttyname_r
 *	is defined.
 */
/*#define HAS_TTYNAME_R	   /**/
#define TTYNAME_R_PROTO 0	   /**/

/* HAS_UNION_SEMUN:
 *	This symbol, if defined, indicates that the union semun is
 *	defined by including <sys/sem.h>.  If not, the user code
 *	probably needs to define it as:
 *	union semun {
 *	    int val;
 *	    struct semid_ds *buf;
 *	    unsigned short *array;
 *	}
 */
/* USE_SEMCTL_SEMUN:
 *	This symbol, if defined, indicates that union semun is
 *	used for semctl IPC_STAT.
 */
/* USE_SEMCTL_SEMID_DS:
 *	This symbol, if defined, indicates that struct semid_ds * is
 *	used for semctl IPC_STAT.
 */
#define HAS_UNION_SEMUN	/**/
/*#define USE_SEMCTL_SEMUN	/**/
/*#define USE_SEMCTL_SEMID_DS	/**/

/* HAS_VFORK:
 *	This symbol, if defined, indicates that vfork() exists.
 */
/*#define HAS_VFORK	/**/

/* HAS_PSEUDOFORK:
 *	This symbol, if defined, indicates that an emulation of the
 *	fork routine is available.
 */
#define HAS_PSEUDOFORK	/**/

/* Signal_t:
 *	This symbol's value is either "void" or "int", corresponding to the
 *	appropriate return type of a signal handler.  Thus, you can declare
 *	a signal handler using "Signal_t (*handler)()", and define the
 *	handler using "Signal_t handler(sig)".
 */
#define Signal_t void	/* Signal handler's return type */

/* HASVOLATILE:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the volatile declaration.
 */
#define	HASVOLATILE	/**/
#ifndef HASVOLATILE
#define volatile
#endif

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t fpos_t		/* File position type */

/* Gid_t_f:
 *	This symbol defines the format string used for printing a Gid_t.
 */
#define	Gid_t_f		"ld"		/**/

/* Gid_t_sign:
 *	This symbol holds the signedess of a Gid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Gid_t_sign	-1		/* GID sign */

/* Gid_t_size:
 *	This symbol holds the size of a Gid_t in bytes.
 */
#define Gid_t_size 4		/* GID size */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	gid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t gid_t		/* Type for getgid(), etc... */

/* Groups_t:
 *	This symbol holds the type used for the second argument to
 *	getgroups() and setgroups().  Usually, this is the same as
 *	gidtype (gid_t) , but sometimes it isn't.
 *	It can be int, ushort, gid_t, etc... 
 *	It may be necessary to include <sys/types.h> to get any 
 *	typedef'ed information.  This is only required if you have
 *	getgroups() or setgroups()..
 */
#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#define Groups_t gid_t	/* Type for 2nd arg to [sg]etgroups() */
#endif

/* I_DIRENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <dirent.h>. Using this symbol also triggers the definition
 *	of the Direntry_t define which ends up being 'struct dirent' or
 *	'struct direct' depending on the availability of <dirent.h>.
 */
/* DIRNAMLEN:
 *	This symbol, if defined, indicates to the C program that the length
 *	of directory entry names is provided by a d_namlen field.  Otherwise
 *	you need to do strlen() on the d_name field.
 */
/* Direntry_t:
 *	This symbol is set to 'struct direct' or 'struct dirent' depending on
 *	whether dirent is available or not. You should use this pseudo type to
 *	portably declare your directory entries.
 */
#define I_DIRENT		/**/
#define DIRNAMLEN	/**/
#define Direntry_t struct direct

/* I_GRP:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <grp.h>.
 */
/* GRPASSWD:
 *	This symbol, if defined, indicates to the C program that struct group
 *	in <grp.h> contains gr_passwd.
 */
/*#define I_GRP		/**/
/*#define GRPASSWD	/**/

/* I_MACH_CTHREADS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <mach/cthreads.h>.
 */
/*#define   I_MACH_CTHREADS	/**/

/* I_NDBM:
 *	This symbol, if defined, indicates that <ndbm.h> exists and should
 *	be included.
 */
/*#define I_NDBM	/**/

/* I_NETDB:
 *	This symbol, if defined, indicates that <netdb.h> exists and
 *	should be included.
 */
/*#define I_NETDB		/**/

/* I_PTHREAD:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <pthread.h>.
 */
/*#define   I_PTHREAD	/**/

/* I_PWD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pwd.h>.
 */
/* PWQUOTA:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_quota.
 */
/* PWAGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_age.
 */
/* PWCHANGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_change.
 */
/* PWCLASS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_class.
 */
/* PWEXPIRE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_expire.
 */
/* PWCOMMENT:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_comment.
 */
/* PWGECOS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_gecos.
 */
/* PWPASSWD:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_passwd.
 */
/*#define I_PWD		/**/
/*#define PWQUOTA	/**/
/*#define PWAGE	/**/
/*#define PWCHANGE	/**/
/*#define PWCLASS	/**/
/*#define PWEXPIRE	/**/
/*#define PWCOMMENT	/**/
/*#define PWGECOS	/**/
/*#define PWPASSWD	/**/

/* I_SYS_ACCESS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/access.h>.
 */
/*#define   I_SYS_ACCESS                /**/

/* I_SYS_SECURITY:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/security.h>.
 */
/*#define   I_SYS_SECURITY	/**/

/* I_SYSUIO:
 *	This symbol, if defined, indicates that <sys/uio.h> exists and
 *	should be included.
 */
/*#define	I_SYSUIO		/**/

/* I_STDARG:
 *	This symbol, if defined, indicates that <stdarg.h> exists and should
 *	be included.
 */
/* I_VARARGS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <varargs.h>.
 */
#define I_STDARG		/**/
/*#define I_VARARGS	/**/

/* PERL_INC_VERSION_LIST:
 *	This variable specifies the list of subdirectories in over
 *	which perl.c:incpush() and lib/lib.pm will automatically
 *	search when adding directories to @INC, in a format suitable
 *	for a C initialization string.  See the inc_version_list entry
 *	in Porting/Glossary for more details.
 */
/*#define PERL_INC_VERSION_LIST 0		/**/

/* INSTALL_USR_BIN_PERL:
 *	This symbol, if defined, indicates that Perl is to be installed
 * 	also as /usr/bin/perl.
 */
/*#define INSTALL_USR_BIN_PERL	/**/

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
/* LSEEKSIZE:
 *	This symbol holds the number of bytes used by the Off_t.
 */
/* Off_t_size:
 *	This symbol holds the number of bytes used by the Off_t.
 */
#define Off_t __int64		/* <offset> type */
#define LSEEKSIZE 8		/* <offset> size */
#define Off_t_size 8	/* <offset> size */

/* Free_t:
 *	This variable contains the return type of free().  It is usually
 * void, but occasionally int.
 */
/* Malloc_t:
 *	This symbol is the type of pointer returned by malloc and realloc.
 */
#define Malloc_t void *			/**/
#define Free_t void			/**/

/* PERL_MALLOC_WRAP:
 *	This symbol, if defined, indicates that we'd like malloc wrap checks.
 */
#define PERL_MALLOC_WRAP		/**/

/* MYMALLOC:
 *	This symbol, if defined, indicates that we're using our own malloc.
 */
/*#define MYMALLOC			/**/

/* Mode_t:
 *	This symbol holds the type used to declare file modes 
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t mode_t	 /* file mode parameter for system calls */

/* Netdb_host_t:
 *	This symbol holds the type used for the 1st argument
 *	to gethostbyaddr().
 */
/* Netdb_hlen_t:
 *	This symbol holds the type used for the 2nd argument
 *	to gethostbyaddr().
 */
/* Netdb_name_t:
 *	This symbol holds the type used for the argument to
 *	gethostbyname().
 */
/* Netdb_net_t:
 *	This symbol holds the type used for the 1st argument to
 *	getnetbyaddr().
 */
#define Netdb_host_t		char * /**/
#define Netdb_hlen_t		int /**/
#define Netdb_name_t		char * /**/
#define Netdb_net_t		long /**/

/* PERL_OTHERLIBDIRS:
 *	This variable contains a colon-separated set of paths for the perl
 *	binary to search for additional library files or modules.
 *	These directories will be tacked to the end of @INC.
 *	Perl will automatically search below each path for version-
 *	and architecture-specific directories.  See PERL_INC_VERSION_LIST
 *	for more details.
 */
/*#define PERL_OTHERLIBDIRS ""		/**/

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t int		/* PID type */

/* PRIVLIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 */
/* PRIVLIB_EXP:
 *	This symbol contains the ~name expanded version of PRIVLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define PRIVLIB "C:\Perl\\lib"		/**/
#define PRIVLIB_EXP (win32_get_privlib("5.10.0"))	/**/

/* CAN_PROTOTYPE:
 *	If defined, this macro indicates that the C compiler can handle
 *	function prototypes.
 */
/* _:
 *	This macro is used to declare function parameters for folks who want
 *	to make declarations with prototypes using a different style than
 *	the above macros.  Use double parentheses.  For example:
 *
 *		int main _((int argc, char *argv[]));
 */
#define	CAN_PROTOTYPE	/**/
#ifdef CAN_PROTOTYPE
#define	_(args) args
#else
#define	_(args) ()
#endif

/* Select_fd_set_t:
 *	This symbol holds the type used for the 2nd, 3rd, and 4th
 *	arguments to select.  Usually, this is 'fd_set *', if HAS_FD_SET
 *	is defined, and 'int *' otherwise.  This is only useful if you 
 *	have select(), of course.
 */
#define Select_fd_set_t 	Perl_fd_set *	/**/

/* SH_PATH:
 *	This symbol contains the full pathname to the shell used on this
 *	on this system to execute Bourne shell scripts.  Usually, this will be
 *	/bin/sh, though it's possible that some systems will have /bin/ksh,
 *	/bin/pdksh, /bin/ash, /bin/bash, or even something such as
 *	D:/bin/sh.exe.
 */
#define SH_PATH "cmd /x /c"  /**/

/* SIG_NAME:
 *	This symbol contains a list of signal names in order of
 *	signal number. This is intended
 *	to be used as a static array initialization, like this:
 *		char *sig_name[] = { SIG_NAME };
 *	The signals in the list are separated with commas, and each signal
 *	is surrounded by double quotes. There is no leading SIG in the signal
 *	name, i.e. SIGQUIT is known as "QUIT".
 *	Gaps in the signal numbers (up to NSIG) are filled in with NUMnn,
 *	etc., where nn is the actual signal number (e.g. NUM37).
 *	The signal number for sig_name[i] is stored in sig_num[i].
 *	The last element is 0 to terminate the list with a NULL.  This
 *	corresponds to the 0 at the end of the sig_name_init list.
 *	Note that this variable is initialized from the sig_name_init,
 *	not from sig_name (which is unused).
 */
/* SIG_NUM:
 *	This symbol contains a list of signal numbers, in the same order as the
 *	SIG_NAME list. It is suitable for static array initialization, as in:
 *		int sig_num[] = { SIG_NUM };
 *	The signals in the list are separated with commas, and the indices
 *	within that list and the SIG_NAME list match, so it's easy to compute
 *	the signal name from a number or vice versa at the price of a small
 *	dynamic linear lookup. 
 *	Duplicates are allowed, but are moved to the end of the list.
 *	The signal number corresponding to sig_name[i] is sig_number[i].
 *	if (i < NSIG) then sig_number[i] == i.  
 *	The last element is 0, corresponding to the 0 at the end of
 *	the sig_name_init list.
 *	Note that this variable is initialized from the sig_num_init,
 *	not from sig_num (which is unused).
 */
/* SIG_SIZE:
 *	This variable contains the number of elements of the SIG_NAME
 *	and SIG_NUM arrays, excluding the final NULL entry.
 */
#define SIG_NAME "ZERO", "HUP", "INT", "QUIT", "ILL", "NUM05", "NUM06", "NUM07", "FPE", "KILL", "NUM10", "SEGV", "NUM12", "PIPE", "ALRM", "TERM", "NUM16", "NUM17", "NUM18", "NUM19", "CHLD", "BREAK", "ABRT", "STOP", "NUM24", "CONT", "CLD", 0		/**/
#define SIG_NUM  0, 1, 2, 21, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 20, 0		/**/
#define SIG_SIZE 27			/**/

/* SITEARCH:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-dependent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITEARCH_EXP:
 *	This symbol contains the ~name expanded version of SITEARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define SITEARCH "C:\Perl\\site\\lib"		/**/
/*#define SITEARCH_EXP ""	/**/

/* SITELIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-independent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITELIB_EXP:
 *	This symbol contains the ~name expanded version of SITELIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* SITELIB_STEM:
 *	This define is SITELIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
#define SITELIB "C:\Perl\\site\\lib"		/**/
#define SITELIB_EXP (win32_get_sitelib("5.10.0"))	/**/
#define SITELIB_STEM ""		/**/

/* Size_t_size:
 *	This symbol holds the size of a Size_t in bytes.
 */
#define Size_t_size 4		/**/

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length paramater for string functions */

/* Sock_size_t:
 *	This symbol holds the type used for the size argument of
 *	various socket calls (just the base type, not the pointer-to).
 */
#define Sock_size_t		int /**/

/* STDCHAR:
 *	This symbol is defined to be the type of char used in stdio.h.
 *	It has the values "unsigned char" or "char".
 */
#define STDCHAR char	/**/

/* Uid_t_f:
 *	This symbol defines the format string used for printing a Uid_t.
 */
#define	Uid_t_f		"ld"		/**/

/* Uid_t_sign:
 *	This symbol holds the signedess of a Uid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Uid_t_sign	-1		/* UID sign */

/* Uid_t_size:
 *	This symbol holds the size of a Uid_t in bytes.
 */
#define Uid_t_size 4		/* UID size */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t uid_t		/* UID type */

/* USE_ITHREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the interpreter-based threading implementation.
 */
/* USE_5005THREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the 5.005-based threading implementation.
 *	Only valid up to 5.8.x.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/* USE_REENTRANT_API:
 *	This symbol, if defined, indicates that Perl should
 *	try to use the various _r versions of library functions.
 *	This is extremely experimental.
 */
/*#define	USE_5005THREADS		/**/
#define	USE_ITHREADS		/**/
#if defined(USE_5005THREADS) && !defined(USE_ITHREADS)
#define		USE_THREADS		/* until src is revised*/
#endif
/*#define	OLD_PTHREADS_API		/**/
/*#define	USE_REENTRANT_API	/**/

/* PERL_VENDORARCH:
 *	If defined, this symbol contains the name of a private library.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.
 *	It may have a ~ on the front.
 *	The standard distribution will put nothing in this directory.
 *	Vendors who distribute perl may wish to place their own
 *	architecture-dependent modules and extensions in this directory with
 *		MakeMaker Makefile.PL INSTALLDIRS=vendor
 *	or equivalent.  See INSTALL for details.
 */
/* PERL_VENDORARCH_EXP:
 *	This symbol contains the ~name expanded version of PERL_VENDORARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define PERL_VENDORARCH ""		/**/
/*#define PERL_VENDORARCH_EXP ""		/**/

/* PERL_VENDORLIB_EXP:
 *	This symbol contains the ~name expanded version of VENDORLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* PERL_VENDORLIB_STEM:
 *	This define is PERL_VENDORLIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
/*#define PERL_VENDORLIB_EXP ""		/**/
/*#define PERL_VENDORLIB_STEM ""		/**/

/* VOIDFLAGS:
 *	This symbol indicates how much support of the void type is given by this
 *	compiler.  What various bits mean:
 *
 *	    1 = supports declaration of void
 *	    2 = supports arrays of pointers to functions returning void
 *	    4 = supports comparisons between pointers to void functions and
 *		    addresses of void functions
 *	    8 = suports declaration of generic void pointers
 *
 *	The package designer should define VOIDUSED to indicate the requirements
 *	of the package.  This can be done either by #defining VOIDUSED before
 *	including config.h, or by defining defvoidused in Myinit.U.  If the
 *	latter approach is taken, only those flags will be tested.  If the
 *	level of void support necessary is not present, defines void to int.
 */
#ifndef VOIDUSED
#define VOIDUSED 15
#endif
#define VOIDFLAGS 15
#if (VOIDFLAGS & VOIDUSED) != VOIDUSED
#define void int		/* is void to be avoided? */
#define M_VOID			/* Xenix strikes again */
#endif

/* USE_CROSS_COMPILE:
 *	This symbol, if defined, indicates that Perl is being cross-compiled.
 */
/* PERL_TARGETARCH:
 *	This symbol, if defined, indicates the target architecture
 *	Perl has been cross-compiled to.  Undefined if not a cross-compile.
 */
#ifndef USE_CROSS_COMPILE
/*#define	USE_CROSS_COMPILE	/**/
#define	PERL_TARGETARCH	""	/**/
#endif

/* MEM_ALIGNBYTES:
 *	This symbol contains the number of bytes required to align a
 *	double, or a long double when applicable. Usual values are 2,
 *	4 and 8. The default is eight, for safety.
 */
#if defined(USE_CROSS_COMPILE) || defined(MULTIARCH)
#  define MEM_ALIGNBYTES 8
#else
#define MEM_ALIGNBYTES 8
#endif

/* BYTEORDER:
 *	This symbol holds the hexadecimal constant defined in byteorder,
 *	in a UV, i.e. 0x1234 or 0x4321 or 0x12345678, etc...
 *	If the compiler supports cross-compiling or multiple-architecture
 *	binaries (eg. on NeXT systems), use compiler-defined macros to
 *	determine the byte order.
 *	On NeXT 3.2 (and greater), you can build "Fat" Multiple Architecture
 *	Binaries (MAB) on either big endian or little endian machines.
 *	The endian-ness is available at compile-time.  This only matters
 *	for perl, where the config.h can be generated and installed on 
 *	one system, and used by a different architecture to build an
 *	extension.  Older versions of NeXT that might not have
 *	defined either *_ENDIAN__ were all on Motorola 680x0 series,
 *	so the default case (for NeXT) is big endian to catch them. 
 *	This might matter for NeXT 3.0.
 */
#if defined(USE_CROSS_COMPILE) || defined(MULTIARCH)
#  ifdef __LITTLE_ENDIAN__
#    if LONGSIZE == 4
#      define BYTEORDER 0x1234
#    else
#      if LONGSIZE == 8
#        define BYTEORDER 0x12345678
#      endif
#    endif
#  else
#    ifdef __BIG_ENDIAN__
#      if LONGSIZE == 4
#        define BYTEORDER 0x4321
#      else
#        if LONGSIZE == 8
#          define BYTEORDER 0x87654321
#        endif
#      endif
#    endif
#  endif
#  if !defined(BYTEORDER) && (defined(NeXT) || defined(__NeXT__))
#    define BYTEORDER 0x4321
#  endif
#else
#define BYTEORDER 0x1234	/* large digits for MSB */
#endif /* NeXT */

/* CASTI32:
 *	This symbol is defined if the C compiler can cast negative
 *	or large floating point numbers to 32-bit ints.
 */
/*#define	CASTI32		/**/

/* CASTNEGFLOAT:
 *	This symbol is defined if the C compiler can cast negative
 *	numbers to unsigned longs, ints and shorts.
 */
/* CASTFLAGS:
 *	This symbol contains flags that say what difficulties the compiler
 *	has casting odd floating values to unsigned long:
 *		0 = ok
 *		1 = couldn't cast < 0
 *		2 = couldn't cast >= 0x80000000
 *		4 = couldn't cast in argument expression list
 */
#define	CASTNEGFLOAT		/**/
#define CASTFLAGS 0		/**/

/* VOID_CLOSEDIR:
 *	This symbol, if defined, indicates that the closedir() routine
 *	does not return a value.
 */
/*#define VOID_CLOSEDIR		/**/

/* HAS_FD_SET:
 *	This symbol, when defined, indicates presence of the fd_set typedef
 *	in <sys/types.h>
 */
#define HAS_FD_SET	/**/

/* Gconvert:
 *	This preprocessor macro is defined to convert a floating point
 *	number to a string without a trailing decimal point.  This
 *	emulates the behavior of sprintf("%g"), but is sometimes much more
 *	efficient.  If gconvert() is not available, but gcvt() drops the
 *	trailing decimal point, then gcvt() is used.  If all else fails,
 *	a macro using sprintf("%g") is used. Arguments for the Gconvert
 *	macro are: value, number of digits, whether trailing zeros should
 *	be retained, and the output buffer.
 *	The usual values are:
 *		d_Gconvert='gconvert((x),(n),(t),(b))'
 *		d_Gconvert='gcvt((x),(n),(b))'
 *		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
 *	The last two assume trailing zeros should not be kept.
 */
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))

/* HAS_GETPAGESIZE:
 *	This symbol, if defined, indicates that the getpagesize system call
 *	is available to get system page size, which is the granularity of
 *	many memory management calls.
 */
/*#define HAS_GETPAGESIZE		/**/

/* HAS_GNULIBC:
 *	This symbol, if defined, indicates to the C program that 
 *	the GNU C library is being used.  A better check is to use
 *	the __GLIBC__ and __GLIBC_MINOR__ symbols supplied with glibc.
 */
/*#define HAS_GNULIBC  	/**/
#if defined(HAS_GNULIBC) && !defined(_GNU_SOURCE)
#   define _GNU_SOURCE
#endif
/* HAS_ISASCII:
 *	This manifest constant lets the C program know that isascii 
 *	is available.
 */
#define HAS_ISASCII		/**/

/* HAS_LCHOWN:
 *	This symbol, if defined, indicates that the lchown routine is
 *	available to operate on a symbolic link (instead of following the
 *	link).
 */
/*#define HAS_LCHOWN		/**/

/* HAS_OPEN3:
 *	This manifest constant lets the C program know that the three
 *	argument form of open(2) is available.
 */
/*#define HAS_OPEN3		/**/

/* HAS_SAFE_BCOPY:
 *	This symbol, if defined, indicates that the bcopy routine is available
 *	to copy potentially overlapping memory blocks. Normally, you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_BCOPY	/**/

/* HAS_SAFE_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy potentially overlapping memory blocks.  If you need to
 *	copy overlapping memory blocks, you should check HAS_MEMMOVE and
 *	use memmove() instead, if available.
 */
/*#define HAS_SAFE_MEMCPY	/**/

/* HAS_SANE_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	and can be used to compare relative magnitudes of chars with their high
 *	bits set.  If it is not defined, roll your own version.
 */
#define HAS_SANE_MEMCMP	/**/

/* HAS_SIGACTION:
 *	This symbol, if defined, indicates that Vr4's sigaction() routine
 *	is available.
 */
/*#define HAS_SIGACTION	/**/

/* HAS_SIGSETJMP:
 *	This variable indicates to the C program that the sigsetjmp()
 *	routine is available to save the calling process's registers
 *	and stack environment for later use by siglongjmp(), and
 *	to optionally save the process's signal mask.  See
 *	Sigjmp_buf, Sigsetjmp, and Siglongjmp.
 */
/* Sigjmp_buf:
 *	This is the buffer type to be used with Sigsetjmp and Siglongjmp.
 */
/* Sigsetjmp:
 *	This macro is used in the same way as sigsetjmp(), but will invoke
 *	traditional setjmp() if sigsetjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/* Siglongjmp:
 *	This macro is used in the same way as siglongjmp(), but will invoke
 *	traditional longjmp() if siglongjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/*#define HAS_SIGSETJMP	/**/
#ifdef HAS_SIGSETJMP
#define Sigjmp_buf sigjmp_buf
#define Sigsetjmp(buf,save_mask) sigsetjmp((buf),(save_mask))
#define Siglongjmp(buf,retval) siglongjmp((buf),(retval))
#else
#define Sigjmp_buf jmp_buf
#define Sigsetjmp(buf,save_mask) setjmp((buf))
#define Siglongjmp(buf,retval) longjmp((buf),(retval))
#endif

/* USE_STDIO_PTR:
 *	This symbol is defined if the _ptr and _cnt fields (or similar)
 *	of the stdio FILE structure can be used to access the stdio buffer
 *	for a file handle.  If this is defined, then the FILE_ptr(fp)
 *	and FILE_cnt(fp) macros will also be defined and should be used
 *	to access these fields.
 */
/* FILE_ptr:
 *	This macro is used to access the _ptr field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_PTR_LVALUE:
 *	This symbol is defined if the FILE_ptr macro can be used as an
 *	lvalue.
 */
/* FILE_cnt:
 *	This macro is used to access the _cnt field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_CNT_LVALUE:
 *	This symbol is defined if the FILE_cnt macro can be used as an
 *	lvalue.
 */
/* STDIO_PTR_LVAL_SETS_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n has the side effect of decreasing the
 *	value of File_cnt(fp) by n.
 */
/* STDIO_PTR_LVAL_NOCHANGE_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n leaves File_cnt(fp) unchanged.
 */
#define USE_STDIO_PTR 	/**/
#ifdef USE_STDIO_PTR
#define FILE_ptr(fp)	((fp)->_ptr)
#define STDIO_PTR_LVALUE 		/**/
#define FILE_cnt(fp)	((fp)->_cnt)
#define STDIO_CNT_LVALUE 		/**/
/*#define STDIO_PTR_LVAL_SETS_CNT	/**/
#define STDIO_PTR_LVAL_NOCHANGE_CNT	/**/
#endif

/* USE_STDIO_BASE:
 *	This symbol is defined if the _base field (or similar) of the
 *	stdio FILE structure can be used to access the stdio buffer for
 *	a file handle.  If this is defined, then the FILE_base(fp) macro
 *	will also be defined and should be used to access this field.
 *	Also, the FILE_bufsiz(fp) macro will be defined and should be used
 *	to determine the number of bytes in the buffer.  USE_STDIO_BASE
 *	will never be defined unless USE_STDIO_PTR is.
 */
/* FILE_base:
 *	This macro is used to access the _base field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_BASE is defined.
 */
/* FILE_bufsiz:
 *	This macro is used to determine the number of bytes in the I/O
 *	buffer pointed to by _base field (or equivalent) of the FILE
 *	structure pointed to its argument. This macro will always be defined
 *	if USE_STDIO_BASE is defined.
 */
#define USE_STDIO_BASE 	/**/
#ifdef USE_STDIO_BASE
#define FILE_base(fp)	((fp)->_base)
#define FILE_bufsiz(fp)	((fp)->_cnt + (fp)->_ptr - (fp)->_base)
#endif

/* HAS_VPRINTF:
 *	This symbol, if defined, indicates that the vprintf routine is available
 *	to printf with a pointer to an argument list.  If unavailable, you
 *	may need to write your own, probably in terms of _doprnt().
 */
/* USE_CHAR_VSPRINTF:
 *	This symbol is defined if this system has vsprintf() returning type
 *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
 *	is up to the package author to declare vsprintf correctly based on the
 *	symbol.
 */
#define HAS_VPRINTF	/**/
/*#define USE_CHAR_VSPRINTF 	/**/

/* DOUBLESIZE:
 *	This symbol contains the size of a double, so that the C preprocessor
 *	can make decisions based on it.
 */
#define DOUBLESIZE 8		/**/

/* I_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <time.h>.
 */
/* I_SYS_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h>.
 */
/* I_SYS_TIME_KERNEL:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h> with KERNEL defined.
 */
/* HAS_TM_TM_ZONE:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_zone field.
 */
/* HAS_TM_TM_GMTOFF:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_gmtoff field.
 */
#define I_TIME		/**/
/*#define I_SYS_TIME		/**/
/*#define I_SYS_TIME_KERNEL		/**/
/*#define HAS_TM_TM_ZONE		/**/
/*#define HAS_TM_TM_GMTOFF		/**/

/* VAL_O_NONBLOCK:
 *	This symbol is to be used during open() or fcntl(F_SETFL) to turn on
 *	non-blocking I/O for the file descriptor. Note that there is no way
 *	back, i.e. you cannot turn it blocking again this way. If you wish to
 *	alternatively switch between blocking and non-blocking, use the
 *	ioctl(FIOSNBIO) call instead, but that is not supported by all devices.
 */
/* VAL_EAGAIN:
 *	This symbol holds the errno error code set by read() when no data was
 *	present on the non-blocking file descriptor.
 */
/* RD_NODATA:
 *	This symbol holds the return code from read() when no data is present
 *	on the non-blocking file descriptor. Be careful! If EOF_NONBLOCK is
 *	not defined, then you can't distinguish between no data and EOF by
 *	issuing a read(). You'll have to find another way to tell for sure!
 */
/* EOF_NONBLOCK:
 *	This symbol, if defined, indicates to the C program that a read() on
 *	a non-blocking file descriptor will return 0 on EOF, and not the value
 *	held in RD_NODATA (-1 usually, in that case!).
 */
#define VAL_O_NONBLOCK O_NONBLOCK
#define VAL_EAGAIN EAGAIN
#define RD_NODATA -1
#define EOF_NONBLOCK

/* PTRSIZE:
 *	This symbol contains the size of a pointer, so that the C preprocessor
 *	can make decisions based on it.  It will be sizeof(void *) if
 *	the compiler supports (void *); otherwise it will be
 *	sizeof(char *).
 */
#define PTRSIZE 4		/**/

/* Drand01:
 *	This macro is to be used to generate uniformly distributed
 *	random numbers over the range [0., 1.[.  You may have to supply
 *	an 'extern double drand48();' in your program since SunOS 4.1.3
 *	doesn't provide you with anything relevant in its headers.
 *	See HAS_DRAND48_PROTO.
 */
/* Rand_seed_t:
 *	This symbol defines the type of the argument of the
 *	random seed function.
 */
/* seedDrand01:
 *	This symbol defines the macro to be used in seeding the
 *	random number generator (see Drand01).
 */
/* RANDBITS:
 *	This symbol indicates how many bits are produced by the
 *	function used to generate normalized random numbers.
 *	Values include 15, 16, 31, and 48.
 */
#define Drand01()		(rand()/(double)((unsigned)1<<RANDBITS))		/**/
#define Rand_seed_t		unsigned		/**/
#define seedDrand01(x)	srand((Rand_seed_t)x)	/**/
#define RANDBITS		15		/**/

/* SSize_t:
 *	This symbol holds the type used by functions that return
 *	a count of bytes or an error condition.  It must be a signed type.
 *	It is usually ssize_t, but may be long or int, etc.
 *	It may be necessary to include <sys/types.h> or <unistd.h>
 *	to get any typedef'ed information.
 *	We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
 */
#define SSize_t int	 /* signed count of bytes */

/* EBCDIC:
 *     This symbol, if defined, indicates that this system uses
 *	EBCDIC encoding.
 */
/*#define	EBCDIC 		/**/

/* HAS_ATOLF:
 *	This symbol, if defined, indicates that the atolf routine is
 *	available to convert strings into long doubles.
 */
/*#define HAS_ATOLF		/**/

/* HAS_ATOLL:
 *	This symbol, if defined, indicates that the atoll routine is
 *	available to convert strings into long longs.
 */
/*#define HAS_ATOLL		/**/

/* HAS__FWALK:
 *	This symbol, if defined, indicates that the _fwalk system call is
 *	available to apply a function to all the file handles.
 */
/*#define HAS__FWALK		/**/

/* HAS_AINTL:
 *	This symbol, if defined, indicates that the aintl routine is
 *	available.  If copysignl is also present we can emulate modfl.
 */
/*#define HAS_AINTL		/**/

/* HAS_BUILTIN_CHOOSE_EXPR:
 *	Can we handle GCC builtin for compile-time ternary-like expressions
 */
/* HAS_BUILTIN_EXPECT:
 *	Can we handle GCC builtin for telling that certain values are more
 *	likely
 */
/*#define HAS_BUILTIN_EXPECT	/**/
/*#define HAS_BUILTIN_CHOOSE_EXPR	/**/

/* HAS_C99_VARIADIC_MACROS:
 *	If defined, the compiler supports C99 variadic macros.
 */
/*#define	HAS_C99_VARIADIC_MACROS	/**/

/* HAS_CLASS:
 *	This symbol, if defined, indicates that the class routine is
 *	available to classify doubles.  Available for example in AIX.
 *	The returned values are defined in <float.h> and are:
 *
 *	FP_PLUS_NORM	Positive normalized, nonzero
 *	FP_MINUS_NORM	Negative normalized, nonzero
 *	FP_PLUS_DENORM	Positive denormalized, nonzero
 *	FP_MINUS_DENORM	Negative denormalized, nonzero
 *	FP_PLUS_ZERO	+0.0
 *	FP_MINUS_ZERO	-0.0
 *	FP_PLUS_INF	+INF
 *	FP_MINUS_INF	-INF
 *	FP_NANS		Signaling Not a Number (NaNS)
 *	FP_NANQ		Quiet Not a Number (NaNQ)
 */
/*#define HAS_CLASS		/**/

/* HAS_CLEARENV:
 *	This symbol, if defined, indicates that the clearenv () routine is
 *	available for use.
 */
/*#define HAS_CLEARENV		/**/

/* HAS_STRUCT_CMSGHDR:
 *	This symbol, if defined, indicates that the struct cmsghdr
 *	is supported.
 */
/*#define HAS_STRUCT_CMSGHDR	/**/

/* HAS_COPYSIGNL:
 *	This symbol, if defined, indicates that the copysignl routine is
 *	available.  If aintl is also present we can emulate modfl.
 */
/*#define HAS_COPYSIGNL		/**/

/* USE_CPLUSPLUS:
 *	This symbol, if defined, indicates that a C++ compiler was
 *	used to compiled Perl and will be used to compile extensions.
 */
/*#define USE_CPLUSPLUS		/**/

/* HAS_DBMINIT_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the dbminit() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int dbminit(char *);
 */
/*#define	HAS_DBMINIT_PROTO	/**/

/* HAS_DIR_DD_FD:
 *	This symbol, if defined, indicates that the the DIR* dirstream
 *	structure contains a member variable named dd_fd.
 */
/*#define HAS_DIR_DD_FD		/**/

/* HAS_DIRFD:
 *	This manifest constant lets the C program know that dirfd
 *	is available.
 */
/*#define HAS_DIRFD		/**/

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/**/

/* HAS_FAST_STDIO:
 *	This symbol, if defined, indicates that the "fast stdio"
 *	is available to manipulate the stdio buffers directly.
 */
#define HAS_FAST_STDIO		/**/

/* HAS_FCHDIR:
 *	This symbol, if defined, indicates that the fchdir routine is
 *	available to change directory using a file descriptor.
 */
/*#define HAS_FCHDIR		/**/

/* FCNTL_CAN_LOCK:
 *	This symbol, if defined, indicates that fcntl() can be used
 *	for file locking.  Normally on Unix systems this is defined.
 *	It may be undefined on VMS.
 */
/*#define FCNTL_CAN_LOCK		/**/

/* HAS_FINITE:
 *	This symbol, if defined, indicates that the finite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_FINITE		/**/

/* HAS_FINITEL:
 *	This symbol, if defined, indicates that the finitel routine is
 *	available to check whether a long double is finite
 *	(non-infinity non-NaN).
 */
/*#define HAS_FINITEL		/**/

/* HAS_FLOCK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the flock() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int flock(int, int);
 */
#define	HAS_FLOCK_PROTO	/**/

/* HAS_FP_CLASS:
 *	This symbol, if defined, indicates that the fp_class routine is
 *	available to classify doubles.  Available for example in Digital UNIX.
 *	The returned values are defined in <math.h> and are:
 *
 *	FP_SNAN           Signaling NaN (Not-a-Number)
 *	FP_QNAN           Quiet NaN (Not-a-Number)
 *	FP_POS_INF        +infinity
 *	FP_NEG_INF        -infinity
 *	FP_POS_NORM       Positive normalized
 *	FP_NEG_NORM       Negative normalized
 *	FP_POS_DENORM     Positive denormalized
 *	FP_NEG_DENORM     Negative denormalized
 *	FP_POS_ZERO       +0.0 (positive zero)
 *	FP_NEG_ZERO       -0.0 (negative zero)
 */
/*#define HAS_FP_CLASS		/**/

/* HAS_FPCLASS:
 *	This symbol, if defined, indicates that the fpclass routine is
 *	available to classify doubles.  Available for example in Solaris/SVR4.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASS		/**/

/* HAS_FPCLASSIFY:
 *	This symbol, if defined, indicates that the fpclassify routine is
 *	available to classify doubles.  Available for example in HP-UX.
 *	The returned values are defined in <math.h> and are
 *
 *           FP_NORMAL     Normalized
 *           FP_ZERO       Zero
 *           FP_INFINITE   Infinity
 *           FP_SUBNORMAL  Denormalized
 *           FP_NAN        NaN
 *
 */
/*#define HAS_FPCLASSIFY		/**/

/* HAS_FPCLASSL:
 *	This symbol, if defined, indicates that the fpclassl routine is
 *	available to classify long doubles.  Available for example in IRIX.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASSL		/**/

/* HAS_FPOS64_T:
 *	This symbol will be defined if the C compiler supports fpos64_t.
 */
/*#define	HAS_FPOS64_T    	/**/

/* HAS_FREXPL:
 *	This symbol, if defined, indicates that the frexpl routine is
 *	available to break a long double floating-point number into
 *	a normalized fraction and an integral power of 2.
 */
/*#define HAS_FREXPL		/**/

/* HAS_STRUCT_FS_DATA:
 *	This symbol, if defined, indicates that the struct fs_data
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_FS_DATA	/**/

/* HAS_FSEEKO:
 *	This symbol, if defined, indicates that the fseeko routine is
 *	available to fseek beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FSEEKO		/**/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATFS		/**/

/* HAS_FSYNC:
 *	This symbol, if defined, indicates that the fsync routine is
 *	available to write a file's modified data and attributes to
 *	permanent storage.
 */
/*#define HAS_FSYNC		/**/

/* HAS_FTELLO:
 *	This symbol, if defined, indicates that the ftello routine is
 *	available to ftell beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FTELLO		/**/

/* HAS_FUTIMES:
 *	This symbol, if defined, indicates that the futimes routine is
 *	available to change file descriptor time stamps with struct timevals.
 */
/*#define HAS_FUTIMES		/**/

/* HAS_GETCWD:
 *	This symbol, if defined, indicates that the getcwd routine is
 *	available to get the current working directory.
 */
#define HAS_GETCWD		/**/

/* HAS_GETESPWNAM:
 *	This symbol, if defined, indicates that the getespwnam system call is
 *	available to retrieve enchanced (shadow) password entries by name.
 */
/*#define HAS_GETESPWNAM		/**/

/* HAS_GETFSSTAT:
 *	This symbol, if defined, indicates that the getfsstat routine is
 *	available to stat filesystems in bulk.
 */
/*#define HAS_GETFSSTAT		/**/

/* HAS_GETITIMER:
 *	This symbol, if defined, indicates that the getitimer routine is
 *	available to return interval timers.
 */
/*#define HAS_GETITIMER		/**/

/* HAS_GETMNT:
 *	This symbol, if defined, indicates that the getmnt routine is
 *	available to get filesystem mount info by filename.
 */
/*#define HAS_GETMNT		/**/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to iterate through mounted file systems to get their info.
 */
/*#define HAS_GETMNTENT		/**/

/* HAS_GETPRPWNAM:
 *	This symbol, if defined, indicates that the getprpwnam system call is
 *	available to retrieve protected (shadow) password entries by name.
 */
/*#define HAS_GETPRPWNAM		/**/

/* HAS_GETSPNAM:
 *	This symbol, if defined, indicates that the getspnam system call is
 *	available to retrieve SysV shadow password entries by name.
 */
/*#define HAS_GETSPNAM		/**/

/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query the mount options of file systems.
 */
/*#define HAS_HASMNTOPT		/**/

/* HAS_ILOGBL:
 *	This symbol, if defined, indicates that the ilogbl routine is
 *	available.  If scalbnl is also present we can emulate frexpl.
 */
/*#define HAS_ILOGBL		/**/

/* HAS_INT64_T:
 *     This symbol will defined if the C compiler supports int64_t.
 *     Usually the <inttypes.h> needs to be included, but sometimes
 *	<sys/types.h> is enough.
 */
/*#define     HAS_INT64_T               /**/

/* HAS_ISFINITE:
 *	This symbol, if defined, indicates that the isfinite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_ISFINITE		/**/

/* HAS_ISINF:
 *	This symbol, if defined, indicates that the isinf routine is
 *	available to check whether a double is an infinity.
 */
/*#define HAS_ISINF		/**/

/* HAS_ISNAN:
 *	This symbol, if defined, indicates that the isnan routine is
 *	available to check whether a double is a NaN.
 */
#define HAS_ISNAN		/**/

/* HAS_ISNANL:
 *	This symbol, if defined, indicates that the isnanl routine is
 *	available to check whether a long double is a NaN.
 */
/*#define HAS_ISNANL		/**/

/* HAS_LDBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol LDBL_DIG, which is the number
 *	of significant digits in a long double precision number. Unlike
 *	for DBL_DIG, there's no good guess for LDBL_DIG if it is undefined.
 */
#define HAS_LDBL_DIG 	/**/

/* LIBM_LIB_VERSION:
 *	This symbol, if defined, indicates that libm exports _LIB_VERSION
 *	and that math.h defines the enum to manipulate it.
 */
/*#define LIBM_LIB_VERSION		/**/

/* HAS_MADVISE:
 *	This symbol, if defined, indicates that the madvise system call is
 *	available to map a file into memory.
 */
/*#define HAS_MADVISE		/**/

/* HAS_MALLOC_SIZE:
 *	This symbol, if defined, indicates that the malloc_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_SIZE		/**/

/* HAS_MALLOC_GOOD_SIZE:
 *	This symbol, if defined, indicates that the malloc_good_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_GOOD_SIZE	/**/

/* HAS_MKDTEMP:
 *	This symbol, if defined, indicates that the mkdtemp routine is
 *	available to exclusively create a uniquely named temporary directory.
 */
/*#define HAS_MKDTEMP		/**/

/* HAS_MKSTEMPS:
 *	This symbol, if defined, indicates that the mkstemps routine is
 *	available to excluslvely create and open a uniquely named
 *	(with a suffix) temporary file.
 */
/*#define HAS_MKSTEMPS		/**/

/* HAS_MODFL:
 *	This symbol, if defined, indicates that the modfl routine is
 *	available to split a long double x into a fractional part f and
 *	an integer part i such that |f| < 1.0 and (f + i) = x.
 */
/* HAS_MODFL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the modfl() function.  Otherwise, it is up
 *	to the program to supply one.
 */
/* HAS_MODFL_POW32_BUG:
 *	This symbol, if defined, indicates that the modfl routine is
 *	broken for long doubles >= pow(2, 32).
 *	For example from 4294967303.150000 one would get 4294967302.000000
 *	and 1.150000.  The bug has been seen in certain versions of glibc,
 *	release 2.2.2 is known to be okay.
 */
/*#define HAS_MODFL		/**/
/*#define HAS_MODFL_PROTO		/**/
/*#define HAS_MODFL_POW32_BUG		/**/

/* HAS_MPROTECT:
 *	This symbol, if defined, indicates that the mprotect system call is
 *	available to modify the access protection of a memory mapped file.
 */
/*#define HAS_MPROTECT		/**/

/* HAS_STRUCT_MSGHDR:
 *	This symbol, if defined, indicates that the struct msghdr
 *	is supported.
 */
/*#define HAS_STRUCT_MSGHDR	/**/

/* HAS_NL_LANGINFO:
 *	This symbol, if defined, indicates that the nl_langinfo routine is
 *	available to return local data.  You will also need <langinfo.h>
 *	and therefore I_LANGINFO.
 */
/*#define HAS_NL_LANGINFO		/**/

/* HAS_OFF64_T:
 *	This symbol will be defined if the C compiler supports off64_t.
 */
/*#define	HAS_OFF64_T    		/**/

/* HAS_PROCSELFEXE:
 *	This symbol is defined if PROCSELFEXE_PATH is a symlink
 *	to the absolute pathname of the executing program.
 */
/* PROCSELFEXE_PATH:
 *	If HAS_PROCSELFEXE is defined this symbol is the filename
 *	of the symbolic link pointing to the absolute pathname of
 *	the executing program.
 */
/*#define HAS_PROCSELFEXE	/**/
#if defined(HAS_PROCSELFEXE) && !defined(PROCSELFEXE_PATH)
#define PROCSELFEXE_PATH		/**/
#endif

/* HAS_PTHREAD_ATTR_SETSCOPE:
 *	This symbol, if defined, indicates that the pthread_attr_setscope
 *	system call is available to set the contention scope attribute of
 *	a thread attribute object.
 */
/*#define HAS_PTHREAD_ATTR_SETSCOPE		/**/

/* HAS_READV:
 *	This symbol, if defined, indicates that the readv routine is
 *	available to do gather reads.  You will also need <sys/uio.h>
 *	and there I_SYSUIO.
 */
/*#define HAS_READV		/**/

/* HAS_RECVMSG:
 *	This symbol, if defined, indicates that the recvmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_RECVMSG		/**/

/* HAS_SBRK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sbrk() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern void* sbrk(int);
 *		extern void* sbrk(size_t);
 */
/*#define	HAS_SBRK_PROTO	/**/

/* HAS_SCALBNL:
 *	This symbol, if defined, indicates that the scalbnl routine is
 *	available.  If ilogbl is also present we can emulate frexpl.
 */
/*#define HAS_SCALBNL		/**/

/* HAS_SENDMSG:
 *	This symbol, if defined, indicates that the sendmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_SENDMSG		/**/

/* HAS_SETITIMER:
 *	This symbol, if defined, indicates that the setitimer routine is
 *	available to set interval timers.
 */
/*#define HAS_SETITIMER		/**/

/* HAS_SETPROCTITLE:
 *	This symbol, if defined, indicates that the setproctitle routine is
 *	available to set process title.
 */
/*#define HAS_SETPROCTITLE		/**/

/* USE_SFIO:
 *	This symbol, if defined, indicates that sfio should
 *	be used.
 */
/*#define	USE_SFIO		/**/

/* HAS_SIGNBIT:
 *	This symbol, if defined, indicates that the signbit routine is
 *	available to check if the given number has the sign bit set.
 *	This should include correct testing of -0.0.  This will only be set
 *	if the signbit() routine is safe to use with the NV type used internally
 *	in perl.  Users should call Perl_signbit(), which will be #defined to
 *	the system's signbit() function or macro if this symbol is defined.
 */
/*#define HAS_SIGNBIT		/**/

/* HAS_SIGPROCMASK:
 *	This symbol, if defined, indicates that the sigprocmask
 *	system call is available to examine or change the signal mask
 *	of the calling process.
 */
/*#define HAS_SIGPROCMASK		/**/

/* USE_SITECUSTOMIZE:
 *	This symbol, if defined, indicates that sitecustomize should
 *	be used.
 */
#ifndef USE_SITECUSTOMIZE
#define	USE_SITECUSTOMIZE		/**/
#endif

/* HAS_SNPRINTF:
 *	This symbol, if defined, indicates that the snprintf () library
 *	function is available for use.
 */
/* HAS_VSNPRINTF:
 *	This symbol, if defined, indicates that the vsnprintf () library
 *	function is available for use.
 */
#define HAS_SNPRINTF	/**/
#define HAS_VSNPRINTF	/**/

/* HAS_SOCKATMARK:
 *	This symbol, if defined, indicates that the sockatmark routine is
 *	available to test whether a socket is at the out-of-band mark.
 */
/*#define HAS_SOCKATMARK		/**/

/* HAS_SOCKATMARK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sockatmark() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int sockatmark(int);
 */
/*#define	HAS_SOCKATMARK_PROTO	/**/

/* HAS_SOCKS5_INIT:
 *	This symbol, if defined, indicates that the socks5_init routine is
 *	available to initialize SOCKS 5.
 */
/*#define HAS_SOCKS5_INIT		/**/

/* SPRINTF_RETURNS_STRLEN:
 *	This variable defines whether sprintf returns the length of the string
 *	(as per the ANSI spec). Some C libraries retain compatibility with
 *	pre-ANSI C and return a pointer to the passed in buffer; for these
 *	this variable will be undef.
 */
#define SPRINTF_RETURNS_STRLEN	/**/

/* HAS_SQRTL:
 *	This symbol, if defined, indicates that the sqrtl routine is
 *	available to do long double square roots.
 */
/*#define HAS_SQRTL		/**/

/* HAS_SETRESGID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresgid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESGID_PROTO	/**/

/* HAS_SETRESUID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresuid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESUID_PROTO	/**/

/* HAS_STRUCT_STATFS_F_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs
 *	does have the f_flags member containing the mount flags of
 *	the filesystem containing the file.
 *	This kind of struct statfs is coming from <sys/mount.h> (BSD 4.3),
 *	not from <sys/statfs.h> (SYSV).  Older BSDs (like Ultrix) do not
 *	have statfs() and struct statfs, they have ustat() and getmnt()
 *	with struct ustat and struct fs_data.
 */
/*#define HAS_STRUCT_STATFS_F_FLAGS		/**/

/* HAS_STRUCT_STATFS:
 *	This symbol, if defined, indicates that the struct statfs
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_STATFS	/**/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATVFS		/**/

/* HAS_STRFTIME:
 *	This symbol, if defined, indicates that the strftime routine is
 *	available to do time formatting.
 */
#define HAS_STRFTIME		/**/

/* HAS_STRLCAT:
 *	This symbol, if defined, indicates that the strlcat () routine is
 *	available to do string concatenation.
 */
/*#define HAS_STRLCAT		/**/

/* HAS_STRLCPY:
 *	This symbol, if defined, indicates that the strlcpy () routine is
 *	available to do string copying.
 */
/*#define HAS_STRLCPY		/**/

/* HAS_STRTOLD:
 *	This symbol, if defined, indicates that the strtold routine is
 *	available to convert strings to long doubles.
 */
/*#define HAS_STRTOLD		/**/

/* HAS_STRTOLL:
 *	This symbol, if defined, indicates that the strtoll routine is
 *	available to convert strings to long longs.
 */
/*#define HAS_STRTOLL		/**/

/* HAS_STRTOQ:
 *	This symbol, if defined, indicates that the strtoq routine is
 *	available to convert strings to long longs (quads).
 */
/*#define HAS_STRTOQ		/**/

/* HAS_STRTOULL:
 *	This symbol, if defined, indicates that the strtoull routine is
 *	available to convert strings to unsigned long longs.
 */
/*#define HAS_STRTOULL		/**/

/* HAS_STRTOUQ:
 *	This symbol, if defined, indicates that the strtouq routine is
 *	available to convert strings to unsigned long longs (quads).
 */
/*#define HAS_STRTOUQ		/**/

/* HAS_SYSCALL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the syscall() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int syscall(int,  ...);
 *		extern int syscall(long, ...);
 */
/*#define	HAS_SYSCALL_PROTO	/**/

/* HAS_TELLDIR_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the telldir() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern long telldir(DIR*);
 */
#define	HAS_TELLDIR_PROTO	/**/

/* U32_ALIGNMENT_REQUIRED:
 *	This symbol, if defined, indicates that you must access
 *	character data through U32-aligned pointers.
 */
#ifndef U32_ALIGNMENT_REQUIRED
#define U32_ALIGNMENT_REQUIRED	/**/
#endif

/* HAS_UALARM:
 *	This symbol, if defined, indicates that the ualarm routine is
 *	available to do alarms with microsecond granularity.
 */
/*#define HAS_UALARM		/**/

/* HAS_UNORDERED:
 *	This symbol, if defined, indicates that the unordered routine is
 *	available to check whether two doubles are unordered
 *	(effectively: whether either of them is NaN)
 */
/*#define HAS_UNORDERED		/**/

/* HAS_UNSETENV:
 *	This symbol, if defined, indicates that the unsetenv () routine is
 *	available for use.
 */
/*#define HAS_UNSETENV		/**/

/* HAS_USLEEP_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the usleep() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int usleep(useconds_t);
 */
/*#define	HAS_USLEEP_PROTO	/**/

/* HAS_USTAT:
 *	This symbol, if defined, indicates that the ustat system call is
 *	available to query file system statistics by dev_t.
 */
/*#define HAS_USTAT		/**/

/* HAS_WRITEV:
 *	This symbol, if defined, indicates that the writev routine is
 *	available to do scatter writes.
 */
/*#define HAS_WRITEV		/**/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
#define USE_DYNAMIC_LOADING		/**/

/* FFLUSH_NULL:
 *	This symbol, if defined, tells that fflush(NULL) does flush
 *	all pending stdio output.
 */
/* FFLUSH_ALL:
 *	This symbol, if defined, tells that to flush
 *	all pending stdio output one must loop through all
 *	the stdio file handles stored in an array and fflush them.
 *	Note that if fflushNULL is defined, fflushall will not
 *	even be probed for and will be left undefined.
 */
#define	FFLUSH_NULL 		/**/
/*#define	FFLUSH_ALL 		/**/

/* I_CRYPT:
 *	This symbol, if defined, indicates that <crypt.h> exists and
 *	should be included.
 */
/*#define	I_CRYPT		/**/

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
/* DB_VERSION_MAJOR_CFG:
 *	This symbol, if defined, defines the major version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 */
/* DB_VERSION_MINOR_CFG:
 *	This symbol, if defined, defines the minor version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
/* DB_VERSION_PATCH_CFG:
 *	This symbol, if defined, defines the patch version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
#define DB_Hash_t	int		/**/
#define DB_Prefix_t	int  	/**/
#define DB_VERSION_MAJOR_CFG	0  	/**/
#define DB_VERSION_MINOR_CFG	0  	/**/
#define DB_VERSION_PATCH_CFG	0  	/**/

/* I_FP:
 *	This symbol, if defined, indicates that <fp.h> exists and
 *	should be included.
 */
/*#define	I_FP		/**/

/* I_FP_CLASS:
 *	This symbol, if defined, indicates that <fp_class.h> exists and
 *	should be included.
 */
/*#define	I_FP_CLASS		/**/

/* I_IEEEFP:
 *	This symbol, if defined, indicates that <ieeefp.h> exists and
 *	should be included.
 */
/*#define	I_IEEEFP		/**/

/* I_INTTYPES:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <inttypes.h>.
 */
/*#define   I_INTTYPES                /**/

/* I_LANGINFO:
 *	This symbol, if defined, indicates that <langinfo.h> exists and
 *	should be included.
 */
/*#define	I_LANGINFO		/**/

/* I_LIBUTIL:
 *	This symbol, if defined, indicates that <libutil.h> exists and
 *	should be included.
 */
/*#define	I_LIBUTIL		/**/

/* I_MNTENT:
 *	This symbol, if defined, indicates that <mntent.h> exists and
 *	should be included.
 */
/*#define	I_MNTENT		/**/

/* I_NETINET_TCP:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <netinet/tcp.h>.
 */
/*#define   I_NETINET_TCP                /**/

/* I_POLL:
 *	This symbol, if defined, indicates that <poll.h> exists and
 *	should be included. (see also HAS_POLL)
 */
/*#define	I_POLL		/**/

/* I_PROT:
 *	This symbol, if defined, indicates that <prot.h> exists and
 *	should be included.
 */
/*#define	I_PROT		/**/

/* I_SHADOW:
 *	This symbol, if defined, indicates that <shadow.h> exists and
 *	should be included.
 */
/*#define	I_SHADOW		/**/

/* I_SOCKS:
 *	This symbol, if defined, indicates that <socks.h> exists and
 *	should be included.
 */
/*#define	I_SOCKS		/**/

/* I_SUNMATH:
 *	This symbol, if defined, indicates that <sunmath.h> exists and
 *	should be included.
 */
/*#define	I_SUNMATH		/**/

/* I_SYSLOG:
 *	This symbol, if defined, indicates that <syslog.h> exists and
 *	should be included.
 */
/*#define	I_SYSLOG		/**/

/* I_SYSMODE:
 *	This symbol, if defined, indicates that <sys/mode.h> exists and
 *	should be included.
 */
/*#define	I_SYSMODE		/**/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates that <sys/mount.h> exists and
 *	should be included.
 */
/*#define	I_SYS_MOUNT		/**/

/* I_SYS_STATFS:
 *	This symbol, if defined, indicates that <sys/statfs.h> exists.
 */
/*#define	I_SYS_STATFS		/**/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates that <sys/statvfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_STATVFS		/**/

/* I_SYSUTSNAME:
 *	This symbol, if defined, indicates that <sys/utsname.h> exists and
 *	should be included.
 */
/*#define	I_SYSUTSNAME		/**/

/* I_SYS_VFS:
 *	This symbol, if defined, indicates that <sys/vfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_VFS		/**/

/* I_USTAT:
 *	This symbol, if defined, indicates that <ustat.h> exists and
 *	should be included.
 */
/*#define	I_USTAT		/**/

/* PERL_PRIfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for output.
 */
/* PERL_PRIgldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'g') for output.
 */
/* PERL_PRIeldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'e') for output.
 */
/* PERL_SCNfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for input.
 */
/*#define PERL_PRIfldbl	"f"	/**/
/*#define PERL_PRIgldbl	"g"	/**/
/*#define PERL_PRIeldbl	"e"	/**/
/*#define PERL_SCNfldbl	"f"	/**/

/* PERL_MAD:
 *	This symbol, if defined, indicates that the Misc Attribution
 *	Declaration code should be conditionally compiled.
 */
/*#define	PERL_MAD		/**/

/* NEED_VA_COPY:
 *	This symbol, if defined, indicates that the system stores
 *	the variable argument list datatype, va_list, in a format
 *	that cannot be copied by simple assignment, so that some
 *	other means must be used when copying is required.
 *	As such systems vary in their provision (or non-provision)
 *	of copying mechanisms, handy.h defines a platform-
 *	independent macro, Perl_va_copy(src, dst), to do the job.
 */
/*#define	NEED_VA_COPY		/**/

/* IVTYPE:
 *	This symbol defines the C type used for Perl's IV.
 */
/* UVTYPE:
 *	This symbol defines the C type used for Perl's UV.
 */
/* I8TYPE:
 *	This symbol defines the C type used for Perl's I8.
 */
/* U8TYPE:
 *	This symbol defines the C type used for Perl's U8.
 */
/* I16TYPE:
 *	This symbol defines the C type used for Perl's I16.
 */
/* U16TYPE:
 *	This symbol defines the C type used for Perl's U16.
 */
/* I32TYPE:
 *	This symbol defines the C type used for Perl's I32.
 */
/* U32TYPE:
 *	This symbol defines the C type used for Perl's U32.
 */
/* I64TYPE:
 *	This symbol defines the C type used for Perl's I64.
 */
/* U64TYPE:
 *	This symbol defines the C type used for Perl's U64.
 */
/* NVTYPE:
 *	This symbol defines the C type used for Perl's NV.
 */
/* IVSIZE:
 *	This symbol contains the sizeof(IV).
 */
/* UVSIZE:
 *	This symbol contains the sizeof(UV).
 */
/* I8SIZE:
 *	This symbol contains the sizeof(I8).
 */
/* U8SIZE:
 *	This symbol contains the sizeof(U8).
 */
/* I16SIZE:
 *	This symbol contains the sizeof(I16).
 */
/* U16SIZE:
 *	This symbol contains the sizeof(U16).
 */
/* I32SIZE:
 *	This symbol contains the sizeof(I32).
 */
/* U32SIZE:
 *	This symbol contains the sizeof(U32).
 */
/* I64SIZE:
 *	This symbol contains the sizeof(I64).
 */
/* U64SIZE:
 *	This symbol contains the sizeof(U64).
 */
/* NVSIZE:
 *	This symbol contains the sizeof(NV).
 */
/* NV_PRESERVES_UV:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	can preserve all the bits of a variable of type UVTYPE.
 */
/* NV_PRESERVES_UV_BITS:
 *	This symbol contains the number of bits a variable of type NVTYPE
 *	can preserve of a variable of type UVTYPE.
 */
/* NV_ZERO_IS_ALLBITS_ZERO:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	stores 0.0 in memory as all bits zero.
 */
#define	IVTYPE		long		/**/
#define	UVTYPE		unsigned long		/**/
#define	I8TYPE		char		/**/
#define	U8TYPE		unsigned char		/**/
#define	I16TYPE		short	/**/
#define	U16TYPE		unsigned short	/**/
#define	I32TYPE		long	/**/
#define	U32TYPE		unsigned long	/**/
#ifdef HAS_QUAD
#define	I64TYPE		__int64	/**/
#define	U64TYPE		unsigned __int64	/**/
#endif
#define	NVTYPE		double		/**/
#define	IVSIZE		4		/**/
#define	UVSIZE		4		/**/
#define	I8SIZE		1		/**/
#define	U8SIZE		1		/**/
#define	I16SIZE		2	/**/
#define	U16SIZE		2	/**/
#define	I32SIZE		4	/**/
#define	U32SIZE		4	/**/
#ifdef HAS_QUAD
#define	I64SIZE		8	/**/
#define	U64SIZE		8	/**/
#endif
#define	NVSIZE		8		/**/
#define	NV_PRESERVES_UV
#define	NV_PRESERVES_UV_BITS	32
#define	NV_ZERO_IS_ALLBITS_ZERO
#if UVSIZE == 8
#   ifdef BYTEORDER
#       if BYTEORDER == 0x1234
#           undef BYTEORDER
#           define BYTEORDER 0x12345678
#       else
#           if BYTEORDER == 0x4321
#               undef BYTEORDER
#               define BYTEORDER 0x87654321
#           endif
#       endif
#   endif
#endif

/* IVdf:
 *	This symbol defines the format string used for printing a Perl IV
 *	as a signed decimal integer.
 */
/* UVuf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned decimal integer.
 */
/* UVof:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned octal integer.
 */
/* UVxf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in lowercase abcdef.
 */
/* UVXf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in uppercase ABCDEF.
 */
/* NVef:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %e-ish floating point format.
 */
/* NVff:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %f-ish floating point format.
 */
/* NVgf:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %g-ish floating point format.
 */
#define	IVdf		"ld"		/**/
#define	UVuf		"lu"		/**/
#define	UVof		"lo"		/**/
#define	UVxf		"lx"		/**/
#define	UVXf		"lX"		/**/
#define	NVef		"e"		/**/
#define	NVff		"f"		/**/
#define	NVgf		"g"		/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	32	/**/

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL "#!perl"		/**/

/* HAS_STDIO_STREAM_ARRAY:
 *	This symbol, if defined, tells that there is an array
 *	holding the stdio streams.
 */
/* STDIO_STREAM_ARRAY:
 *	This symbol tells the name of the array holding the stdio streams.
 *	Usual values include _iob, __iob, and __sF.
 */
/*#define	HAS_STDIO_STREAM_ARRAY	/**/
#define STDIO_STREAM_ARRAY	

/* USE_64_BIT_INT:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be employed (be they 32 or 64 bits).  The minimal possible
 *	64-bitness is used, just enough to get 64-bit integers into Perl.
 *	This may mean using for example "long longs", while your memory
 *	may still be limited to 2 gigabytes.
 */
/* USE_64_BIT_ALL:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be used (be they 32 or 64 bits).  The maximal possible
 *	64-bitness is employed: LP64 or ILP64, meaning that you will
 *	be able to use more than 2 gigabytes of memory.  This mode is
 *	even more binary incompatible than USE_64_BIT_INT. You may not
 *	be able to run the resulting executable in a 32-bit CPU at all or
 *	you may need at least to reboot your OS to 64-bit mode.
 */
#ifndef USE_64_BIT_INT
/*#define	USE_64_BIT_INT		/**/
#endif

#ifndef USE_64_BIT_ALL
/*#define	USE_64_BIT_ALL		/**/
#endif

/* USE_FAST_STDIO:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use 'fast stdio'.
 *	Defaults to define in Perls 5.8 and earlier, to undef later.
 */
#ifndef USE_FAST_STDIO
/*#define	USE_FAST_STDIO		/**/
#endif

/* USE_LARGE_FILES:
 *	This symbol, if defined, indicates that large file support
 *	should be used when available.
 */
#ifndef USE_LARGE_FILES
#define	USE_LARGE_FILES		/**/
#endif

/* USE_LONG_DOUBLE:
 *	This symbol, if defined, indicates that long doubles should
 *	be used when available.
 */
#ifndef USE_LONG_DOUBLE
/*#define	USE_LONG_DOUBLE		/**/
#endif

/* USE_MORE_BITS:
 *	This symbol, if defined, indicates that 64-bit interfaces and
 *	long doubles should be used when available.
 */
#ifndef USE_MORE_BITS
/*#define	USE_MORE_BITS		/**/
#endif

/* MULTIPLICITY:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use multiplicity.
 */
#ifndef MULTIPLICITY
#define	MULTIPLICITY		/**/
#endif

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
#ifndef USE_PERLIO
#define	USE_PERLIO		/**/
#endif

/* USE_SOCKS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use socks.
 */
#ifndef USE_SOCKS
/*#define	USE_SOCKS		/**/
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\cop.h ===
/*    cop.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Control ops (cops) are one of the three ops OP_NEXTSTATE, OP_DBSTATE,
 * and OP_SETSTATE that (loosely speaking) are separate statements.
 * They hold information important for lexical state and error reporting.
 * At run time, PL_curcop is set to point to the most recently executed cop,
 * and thus can be used to determine our current state.
 */

/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a start_env initialized when perl starts, and top_env
 * points to this initially, so top_env should always be non-null.
 *
 * Existence of a non-null top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		/* only for use if !je_throw */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
};

typedef struct jmpenv JMPENV;

#ifdef OP_IN_REGISTER
#define OP_REG_TO_MEM	PL_opsave = op
#define OP_MEM_TO_REG	op = PL_opsave
#else
#define OP_REG_TO_MEM	NOOP
#define OP_MEM_TO_REG	NOOP
#endif

/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
	Zero(&PL_start_env, 1, JMPENV);		\
	PL_start_env.je_ret = -1;		\
	PL_start_env.je_mustcatch = TRUE;	\
	PL_top_env = &PL_start_env;		\
    } STMT_END

/*
 *   PERL_FLEXIBLE_EXCEPTIONS
 * 
 * All the flexible exceptions code has been removed.
 * See the following threads for details:
 *
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2004-07/msg00378.html
 * 
 * Joshua's original patches (which weren't applied) and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01396.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01489.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01491.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01608.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02144.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02998.html
 * 
 * Chip's reworked patch and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1999-03/msg00520.html
 * 
 * The flaw in these patches (which went unnoticed at the time) was
 * that they moved some code that could potentially die() out of the
 * region protected by the setjmp()s.  This caused exceptions within
 * END blocks and such to not be handled by the correct setjmp().
 * 
 * The original patches that introduces flexible exceptions were:
 *
 *   http://public.activestate.com/cgi-bin/perlbrowse?patch=3386
 *   http://public.activestate.com/cgi-bin/perlbrowse?patch=5162
 */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			 (void*)&cur_env, (void*)PL_top_env));			\
	cur_env.je_prev = PL_top_env;					\
	OP_REG_TO_MEM;							\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
	OP_MEM_TO_REG;							\
	PL_top_env = &cur_env;						\
	cur_env.je_mustcatch = FALSE;					\
	(v) = cur_env.je_ret;						\
    } STMT_END

#define JMPENV_POP \
    STMT_START {							\
	DEBUG_l(Perl_deb(aTHX_ "popping jumplevel was %p, now %p\n",	\
			 (void*)PL_top_env, (void*)cur_env.je_prev));			\
	PL_top_env = cur_env.je_prev;					\
    } STMT_END

#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev)				\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));		\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_EXIT);		                \
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");	\
	PerlProc_exit(1);					\
    } STMT_END

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v)		(PL_top_env->je_mustcatch = (v))



struct cop {
    BASEOP
    /* On LP64 putting this here takes advantage of the fact that BASEOP isn't
       an exact multiple of 8 bytes to save structure padding.  */
    line_t      cop_line;       /* line # of this command */
    char *	cop_label;	/* label for this construct */
#ifdef USE_ITHREADS
    char *	cop_stashpv;	/* package line was compiled in */
    char *	cop_file;	/* file name the following line # is from */
#else
    HV *	cop_stash;	/* package line was compiled in */
    GV *	cop_filegv;	/* file the following line # is from */
#endif
    U32		cop_hints;	/* hints bits from pragmata */
    U32		cop_seq;	/* parse sequence number */
    /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */
    STRLEN *	cop_warnings;	/* lexical warnings bitmask */
    /* compile time state of %^H.  See the comment in op.c for how this is
       used to recreate a hash to return from caller.  */
    struct refcounted_he * cop_hints_hash;
};

#ifdef USE_ITHREADS
#  define CopFILE(c)		((c)->cop_file)
#  define CopFILEGV(c)		(CopFILE(c) \
				 ? gv_fetchfile(CopFILE(c)) : NULL)
				 
#  ifdef NETWARE
#    define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savepv((pv),(l)))
#  else
#    define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savesharedpvn((pv),(l)))
#  endif

#  define CopFILESV(c)		(CopFILE(c) \
				 ? GvSV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAV(c)		(CopFILE(c) \
				 ? GvAV(gv_fetchfile(CopFILE(c))) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILE(c)), \
				   GvAV(gv_fetchfile(CopFILE(c))))
#  else
#    define CopFILEAVx(c)	(GvAV(gv_fetchfile(CopFILE(c))))
#  endif
#  define CopSTASHPV(c)		((c)->cop_stashpv)

#  ifdef NETWARE
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : NULL))
#  else
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savesharedpv(pv))
#  endif

#  define CopSTASH(c)		(CopSTASHPV(c) \
				 ? gv_stashpv(CopSTASHPV(c),GV_ADD) : NULL)
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME_get(hv) : NULL)
#  define CopSTASH_eq(c,hv)	((hv) && stashpv_hvname_match(c,hv))
#  define CopLABEL(c)		((c)->cop_label)
#  define CopLABEL_set(c,pv)	(CopLABEL(c) = (pv))
#  ifdef NETWARE
#    define CopSTASH_free(c) SAVECOPSTASH_FREE(c)
#    define CopFILE_free(c) SAVECOPFILE_FREE(c)
#    define CopLABEL_free(c) SAVECOPLABEL_FREE(c)
#    define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
#  else
#    define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = NULL))
#    define CopLABEL_free(c)	(PerlMemShared_free(CopLABEL(c)),(CopLABEL(c) = NULL))
#    define CopLABEL_alloc(pv)	((pv)?savesharedpv(pv):NULL)
#  endif
#else
#  define CopFILEGV(c)		((c)->cop_filegv)
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#  define CopFILE_set(c,pv)	CopFILEGV_set((c), gv_fetchfile(pv))
#  define CopFILE_setn(c,pv,l)	CopFILEGV_set((c), gv_fetchfile_flags((pv),(l),0))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : NULL)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILEGV(c)), GvAV(CopFILEGV(c)))
#  else
#    define CopFILEAVx(c)	(GvAV(CopFILEGV(c)))
# endif
#  define CopFILE(c)		(CopFILEGV(c) && GvSV(CopFILEGV(c)) \
				    ? SvPVX(GvSV(CopFILEGV(c))) : NULL)
#  define CopSTASH(c)		((c)->cop_stash)
#  define CopLABEL(c)		((c)->cop_label)
#  define CopSTASH_set(c,hv)	((c)->cop_stash = (hv))
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
   /* cop_stash is not refcounted */
#  define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#  define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))
#  define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
#  define CopLABEL_set(c,pv)	(CopLABEL(c) = (pv))
#  define CopSTASH_free(c)	
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = NULL))
#  define CopLABEL_free(c)	(Safefree(CopLABEL(c)),(CopLABEL(c) = NULL))

#endif /* USE_ITHREADS */

#define CopSTASH_ne(c,hv)	(!CopSTASH_eq(c,hv))
#define CopLINE(c)		((c)->cop_line)
#define CopLINE_inc(c)		(++CopLINE(c))
#define CopLINE_dec(c)		(--CopLINE(c))
#define CopLINE_set(c,l)	(CopLINE(c) = (l))

/* OutCopFILE() is CopFILE for output (caller, die, warn, etc.) */
#ifdef MACOS_TRADITIONAL
#  define OutCopFILE(c) MacPerl_MPWFileName(CopFILE(c))
#else
#  define OutCopFILE(c) CopFILE(c)
#endif

/* If $[ is non-zero, it's stored in cop_hints under the key "$[", and
   HINT_ARYBASE is set to indicate this.
   Setting it is ineficient due to the need to create 2 mortal SVs, but as
   using $[ is highly discouraged, no sane Perl code will be using it.  */
#define CopARYBASE_get(c)	\
	((CopHINTS_get(c) & HINT_ARYBASE)				\
	 ? SvIV(Perl_refcounted_he_fetch(aTHX_ (c)->cop_hints_hash, 0,	\
					 "$[", 2, 0, 0))		\
	 : 0)
#define CopARYBASE_set(c, b) STMT_START { \
	if (b || ((c)->cop_hints & HINT_ARYBASE)) {			\
	    (c)->cop_hints |= HINT_ARYBASE;				\
	    if ((c) == &PL_compiling)					\
		PL_hints |= HINT_LOCALIZE_HH | HINT_ARYBASE;		\
	    (c)->cop_hints_hash						\
	       = Perl_refcounted_he_new(aTHX_ (c)->cop_hints_hash,	\
					sv_2mortal(newSVpvs("$[")),	\
					sv_2mortal(newSViv(b)));	\
	}								\
    } STMT_END

/* FIXME NATIVE_HINTS if this is changed from op_private (see perl.h)  */
#define CopHINTS_get(c)		((c)->cop_hints + 0)
#define CopHINTS_set(c, h)	STMT_START {				\
				    (c)->cop_hints = (h);		\
				} STMT_END

/*
 * Here we have some enormously heavy (or at least ponderous) wizardry.
 */

/* subroutine context */
struct block_sub {
    CV *	cv;
    GV *	gv;
    GV *	dfoutgv;
    AV *	savearray;
    AV *	argarray;
    I32		olddepth;
    U8		hasargs;
    U8		lval;		/* XXX merge lval and hasargs? */
    PAD		*oldcomppad;
    OP *	retop;	/* op to execute on exit from sub */
};

/* base for the next two macros. Don't use directly.
 * Note that the refcnt of the cv is incremented twice;  The CX one is
 * decremented by LEAVESUB, the other by LEAVE. */

#define PUSHSUB_BASE(cx)						\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.olddepth = CvDEPTH(cv);				\
	cx->blk_sub.hasargs = hasargs;					\
	cx->blk_sub.retop = NULL;					\
	if (!CvDEPTH(cv)) {						\
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SAVEFREESV(cv);						\
	}


#define PUSHSUB(cx)							\
	PUSHSUB_BASE(cx)						\
	cx->blk_sub.lval = PL_op->op_private &                          \
	                      (OPpLVAL_INTRO|OPpENTERSUB_INARGS);

/* variant for use by OP_DBSTATE, where op_private holds hint bits */
#define PUSHSUB_DB(cx)							\
	PUSHSUB_BASE(cx)						\
	cx->blk_sub.lval = 0;


#define PUSHFORMAT(cx)							\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.gv = gv;						\
	cx->blk_sub.retop = NULL;					\
	cx->blk_sub.hasargs = 0;					\
	cx->blk_sub.dfoutgv = PL_defoutgv;				\
	SvREFCNT_inc_void(cx->blk_sub.dfoutgv)

#define POP_SAVEARRAY()						\
    STMT_START {							\
	SvREFCNT_dec(GvAV(PL_defgv));					\
	GvAV(PL_defgv) = cx->blk_sub.savearray;				\
    } STMT_END

/* junk in @_ spells trouble when cloning CVs and in pp_caller(), so don't
 * leave any (a fast av_clear(ary), basically) */
#define CLEAR_ARGARRAY(ary) \
    STMT_START {							\
	AvMAX(ary) += AvARRAY(ary) - AvALLOC(ary);			\
	AvARRAY(ary) = AvALLOC(ary);					\
	AvFILLp(ary) = -1;						\
    } STMT_END

#define POPSUB(cx,sv)							\
    STMT_START {							\
	if (cx->blk_sub.hasargs) {					\
	    POP_SAVEARRAY();						\
	    /* abandon @_ if it got reified */				\
	    if (AvREAL(cx->blk_sub.argarray)) {				\
		const SSize_t fill = AvFILLp(cx->blk_sub.argarray);	\
		SvREFCNT_dec(cx->blk_sub.argarray);			\
		cx->blk_sub.argarray = newAV();				\
		av_extend(cx->blk_sub.argarray, fill);			\
		AvREIFY_only(cx->blk_sub.argarray);			\
		CX_CURPAD_SV(cx->blk_sub, 0) = (SV*)cx->blk_sub.argarray;	\
	    }								\
	    else {							\
		CLEAR_ARGARRAY(cx->blk_sub.argarray);			\
	    }								\
	}								\
	sv = (SV*)cx->blk_sub.cv;					\
	if (sv && (CvDEPTH((CV*)sv) = cx->blk_sub.olddepth))		\
	    sv = NULL;						\
    } STMT_END

#define LEAVESUB(sv)							\
    STMT_START {							\
	if (sv)								\
	    SvREFCNT_dec(sv);						\
    } STMT_END

#define POPFORMAT(cx)							\
	setdefout(cx->blk_sub.dfoutgv);					\
	SvREFCNT_dec(cx->blk_sub.dfoutgv);

/* eval context */
struct block_eval {
    U8		old_in_eval;
    U16		old_op_type;
    SV *	old_namesv;
    OP *	old_eval_root;
    SV *	cur_text;
    CV *	cv;
    OP *	retop;	/* op to execute on exit from eval */
    JMPENV *	cur_top_env; /* value of PL_top_env when eval CX created */
};

#define PUSHEVAL(cx,n,fgv)						\
    STMT_START {							\
	cx->blk_eval.old_in_eval = PL_in_eval;				\
	cx->blk_eval.old_op_type = PL_op->op_type;			\
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : NULL);		\
	cx->blk_eval.old_eval_root = PL_eval_root;			\
	cx->blk_eval.cur_text = PL_parser ? PL_parser->linestr : NULL;	\
	cx->blk_eval.cv = NULL; /* set by doeval(), as applicable */	\
	cx->blk_eval.retop = NULL;					\
	cx->blk_eval.cur_top_env = PL_top_env; 				\
    } STMT_END

#define POPEVAL(cx)							\
    STMT_START {							\
	PL_in_eval = cx->blk_eval.old_in_eval;				\
	optype = cx->blk_eval.old_op_type;				\
	PL_eval_root = cx->blk_eval.old_eval_root;			\
	if (cx->blk_eval.old_namesv)					\
	    sv_2mortal(cx->blk_eval.old_namesv);			\
    } STMT_END

/* loop context */
struct block_loop {
    char *	label;
    I32		resetsp;
    LOOP *	my_op;	/* My op, that contains redo, next and last ops.  */
    /* (except for non_ithreads we need to modify next_op in pp_ctl.c, hence
	why next_op is conditionally defined below.)  */
#ifdef USE_ITHREADS
    void *	iterdata;
    PAD		*oldcomppad;
#else
    OP *	next_op;
    SV **	itervar;
#endif
    SV *	itersave;
    /* (from inspection of source code) for a .. range of strings this is the
       current string.  */
    SV *	iterlval;
    /* (from inspection of source code) for a foreach loop this is the array
       being iterated over. For a .. range of numbers it's the current value.
       A check is often made on the SvTYPE of iterary to determine whether
       we are iterating over an array or a range. (numbers or strings)  */
    AV *	iterary;
    IV		iterix;
    /* (from inspection of source code) for a .. range of numbers this is the
       maximum value.  */
    IV		itermax;
};
/* It might be possible to squeeze this structure further. As best I can tell
   itermax and iterlval are never used at the same time, so it might be possible
   to make them into a union. However, I'm not confident that there are enough
   flag bits/NULLable pointers in this structure alone to encode which is
   active. There is, however, U8 of space free in struct block, which could be
   used. Right now it may not be worth squeezing this structure further, as it's
   the largest part of struct block, and currently struct block is 64 bytes on
   an ILP32 system, which will give good cache alignment.
*/

#ifdef USE_ITHREADS
#  define CxITERVAR(c)							\
	((c)->blk_loop.iterdata						\
	 ? (CxPADLOOP(cx) 						\
	    ? &CX_CURPAD_SV( (c)->blk_loop, 				\
		    INT2PTR(PADOFFSET, (c)->blk_loop.iterdata))		\
	    : &GvSV((GV*)(c)->blk_loop.iterdata))			\
	 : (SV**)NULL)
#  define CX_ITERDATA_SET(cx,idata)					\
	CX_CURPAD_SAVE(cx->blk_loop);					\
	if ((cx->blk_loop.iterdata = (idata)))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));	\
	else								\
	    cx->blk_loop.itersave = NULL;
#else
#  define CxITERVAR(c)		((c)->blk_loop.itervar)
#  define CX_ITERDATA_SET(cx,ivar)					\
	if ((cx->blk_loop.itervar = (SV**)(ivar)))			\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));	\
	else								\
	    cx->blk_loop.itersave = NULL;
#endif

#ifdef USE_ITHREADS
#  define PUSHLOOP_OP_NEXT		/* No need to do anything.  */
#  define CX_LOOP_NEXTOP_GET(cx)	((cx)->blk_loop.my_op->op_nextop + 0)
#else
#  define PUSHLOOP_OP_NEXT		cx->blk_loop.next_op = cLOOP->op_nextop
#  define CX_LOOP_NEXTOP_GET(cx)	((cx)->blk_loop.next_op + 0)
#endif

#define PUSHLOOP(cx, dat, s)						\
	cx->blk_loop.label = PL_curcop->cop_label;			\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.my_op = cLOOP;					\
	PUSHLOOP_OP_NEXT;						\
	cx->blk_loop.iterlval = NULL;					\
	cx->blk_loop.iterary = NULL;					\
	cx->blk_loop.iterix = -1;					\
	CX_ITERDATA_SET(cx,dat);

#define POPLOOP(cx)							\
	SvREFCNT_dec(cx->blk_loop.iterlval);				\
	if (CxITERVAR(cx)) {						\
            if (SvPADMY(cx->blk_loop.itersave)) {			\
		SV ** const s_v_p = CxITERVAR(cx);			\
		sv_2mortal(*s_v_p);					\
		*s_v_p = cx->blk_loop.itersave;				\
	    }								\
	    else {							\
		SvREFCNT_dec(cx->blk_loop.itersave);			\
	    }								\
	}								\
	if (cx->blk_loop.iterary && cx->blk_loop.iterary != PL_curstack)\
	    SvREFCNT_dec(cx->blk_loop.iterary);

/* given/when context */
struct block_givwhen {
	OP *leave_op;
};

#define PUSHGIVEN(cx)							\
	cx->blk_givwhen.leave_op = cLOGOP->op_other;

#define PUSHWHEN PUSHGIVEN

/* context common to subroutines, evals and loops */
struct block {
    U16		blku_type;	/* what kind of context this is */
    U8		blku_gimme;	/* is this block running in list context? */
    U8		blku_spare;	/* Padding to match with struct subst */
    I32		blku_oldsp;	/* stack pointer to copy stuff down to */
    COP *	blku_oldcop;	/* old curcop pointer */
    I32		blku_oldmarksp;	/* mark stack index */
    I32		blku_oldscopesp;	/* scope stack index */
    PMOP *	blku_oldpm;	/* values of pattern match vars */

    union {
	struct block_sub	blku_sub;
	struct block_eval	blku_eval;
	struct block_loop	blku_loop;
	struct block_givwhen	blku_givwhen;
    } blk_u;
};
#define blk_oldsp	cx_u.cx_blk.blku_oldsp
#define blk_oldcop	cx_u.cx_blk.blku_oldcop
#define blk_oldmarksp	cx_u.cx_blk.blku_oldmarksp
#define blk_oldscopesp	cx_u.cx_blk.blku_oldscopesp
#define blk_oldpm	cx_u.cx_blk.blku_oldpm
#define blk_gimme	cx_u.cx_blk.blku_gimme
#define blk_sub		cx_u.cx_blk.blk_u.blku_sub
#define blk_eval	cx_u.cx_blk.blk_u.blku_eval
#define blk_loop	cx_u.cx_blk.blk_u.blku_loop
#define blk_givwhen	cx_u.cx_blk.blk_u.blku_givwhen

/* Enter a block. */
#define PUSHBLOCK(cx,t,sp) CXINC, cx = &cxstack[cxstack_ix],		\
	cx->cx_type		= t,					\
	cx->blk_oldsp		= sp - PL_stack_base,			\
	cx->blk_oldcop		= PL_curcop,				\
	cx->blk_oldmarksp	= PL_markstack_ptr - PL_markstack,	\
	cx->blk_oldscopesp	= PL_scopestack_ix,			\
	cx->blk_oldpm		= PL_curpm,				\
	cx->blk_gimme		= (U8)gimme;				\
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, PL_block_type[CxTYPE(cx)]); )

/* Exit a block (RETURN and LAST). */
#define POPBLOCK(cx,pm) cx = &cxstack[cxstack_ix--],			\
	newsp		 = PL_stack_base + cx->blk_oldsp,		\
	PL_curcop	 = cx->blk_oldcop,				\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	pm		 = cx->blk_oldpm,				\
	gimme		 = cx->blk_gimme;				\
	DEBUG_SCOPE("POPBLOCK");					\
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,PL_block_type[CxTYPE(cx)]); )

/* Continue a block elsewhere (NEXT and REDO). */
#define TOPBLOCK(cx) cx  = &cxstack[cxstack_ix],			\
	PL_stack_sp	 = PL_stack_base + cx->blk_oldsp,		\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_curpm         = cx->blk_oldpm;				\
	DEBUG_SCOPE("TOPBLOCK");

/* substitution context */
struct subst {
    U16		sbu_type;	/* what kind of context this is */
    U8		sbu_once;	/* Actually both booleans, but U8 to matches */
    U8		sbu_rxtainted;	/* struct block */
    I32		sbu_iters;
    I32		sbu_maxiters;
    I32		sbu_rflags;
    I32		sbu_oldsave;
    char *	sbu_orig;
    SV *	sbu_dstr;
    SV *	sbu_targ;
    char *	sbu_s;
    char *	sbu_m;
    char *	sbu_strend;
    void *	sbu_rxres;
    REGEXP *	sbu_rx;
};
#define sb_iters	cx_u.cx_subst.sbu_iters
#define sb_maxiters	cx_u.cx_subst.sbu_maxiters
#define sb_rflags	cx_u.cx_subst.sbu_rflags
#define sb_oldsave	cx_u.cx_subst.sbu_oldsave
#define sb_once		cx_u.cx_subst.sbu_once
#define sb_rxtainted	cx_u.cx_subst.sbu_rxtainted
#define sb_orig		cx_u.cx_subst.sbu_orig
#define sb_dstr		cx_u.cx_subst.sbu_dstr
#define sb_targ		cx_u.cx_subst.sbu_targ
#define sb_s		cx_u.cx_subst.sbu_s
#define sb_m		cx_u.cx_subst.sbu_m
#define sb_strend	cx_u.cx_subst.sbu_strend
#define sb_rxres	cx_u.cx_subst.sbu_rxres
#define sb_rx		cx_u.cx_subst.sbu_rx

#define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],			\
	cx->sb_iters		= iters,				\
	cx->sb_maxiters		= maxiters,				\
	cx->sb_rflags		= r_flags,				\
	cx->sb_oldsave		= oldsave,				\
	cx->sb_once		= once,					\
	cx->sb_rxtainted	= rxtainted,				\
	cx->sb_orig		= orig,					\
	cx->sb_dstr		= dstr,					\
	cx->sb_targ		= targ,					\
	cx->sb_s		= s,					\
	cx->sb_m		= m,					\
	cx->sb_strend		= strend,				\
	cx->sb_rxres		= NULL,					\
	cx->sb_rx		= rx,					\
	cx->cx_type		= CXt_SUBST;				\
	rxres_save(&cx->sb_rxres, rx);					\
	(void)ReREFCNT_inc(rx)

#define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
	rxres_free(&cx->sb_rxres);					\
	ReREFCNT_dec(cx->sb_rx)

struct context {
    union {
	struct block	cx_blk;
	struct subst	cx_subst;
    } cx_u;
};
#define cx_type cx_u.cx_subst.sbu_type

#define CXTYPEMASK	0xff
#define CXt_NULL	0
#define CXt_SUB		1
#define CXt_EVAL	2
#define CXt_LOOP	3
#define CXt_SUBST	4
#define CXt_BLOCK	5
#define CXt_FORMAT	6
#define CXt_GIVEN	7
#define CXt_WHEN	8

/* private flags for CXt_SUB and CXt_NULL */
#define CXp_MULTICALL	0x00000400	/* part of a multicall (so don't
					   tear down context on exit). */ 

/* private flags for CXt_EVAL */
#define CXp_REAL	0x00000100	/* truly eval'', not a lookalike */
#define CXp_TRYBLOCK	0x00000200	/* eval{}, not eval'' or similar */

/* private flags for CXt_LOOP */
#define CXp_FOREACH	0x00000200	/* a foreach loop */
#define CXp_FOR_DEF	0x00000400	/* foreach using $_ */
#ifdef USE_ITHREADS
#  define CXp_PADVAR	0x00000100	/* itervar lives on pad, iterdata
					   has pad offset; if not set,
					   iterdata holds GV* */
#  define CxPADLOOP(c)	(((c)->cx_type & (CXt_LOOP|CXp_PADVAR))		\
			 == (CXt_LOOP|CXp_PADVAR))
#endif

#define CxTYPE(c)	((c)->cx_type & CXTYPEMASK)
#define CxMULTICALL(c)	(((c)->cx_type & CXp_MULTICALL)			\
			 == CXp_MULTICALL)
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL))		\
			 == (CXt_EVAL|CXp_REAL))
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXt_EVAL|CXp_TRYBLOCK))	\
			 == (CXt_EVAL|CXp_TRYBLOCK))
#define CxFOREACH(c)	(((c)->cx_type & (CXt_LOOP|CXp_FOREACH))	\
                         == (CXt_LOOP|CXp_FOREACH))
#define CxFOREACHDEF(c)	(((c)->cx_type & (CXt_LOOP|CXp_FOREACH|CXp_FOR_DEF))\
			 == (CXt_LOOP|CXp_FOREACH|CXp_FOR_DEF))

#define CXINC (cxstack_ix < cxstack_max ? ++cxstack_ix : (cxstack_ix = cxinc()))

/* 
=head1 "Gimme" Values
*/

/*
=for apidoc AmU||G_SCALAR
Used to indicate scalar context.  See C<GIMME_V>, C<GIMME>, and
L<perlcall>.

=for apidoc AmU||G_ARRAY
Used to indicate list context.  See C<GIMME_V>, C<GIMME> and
L<perlcall>.

=for apidoc AmU||G_VOID
Used to indicate void context.  See C<GIMME_V> and L<perlcall>.

=for apidoc AmU||G_DISCARD
Indicates that arguments returned from a callback should be discarded.  See
L<perlcall>.

=for apidoc AmU||G_EVAL

Used to force a Perl C<eval> wrapper around a callback.  See
L<perlcall>.

=for apidoc AmU||G_NOARGS

Indicates that no arguments are being sent to a callback.  See
L<perlcall>.

=cut
*/

#define G_SCALAR	0
#define G_ARRAY		1
#define G_VOID		128	/* skip this bit when adding flags below */

/* extra flags for Perl_call_* routines */
#define G_DISCARD	2	/* Call FREETMPS.
				   Don't change this without consulting the
				   hash actions codes defined in hv.h */
#define G_EVAL		4	/* Assume eval {} around subroutine call. */
#define G_NOARGS	8	/* Don't construct a @_ array. */
#define G_KEEPERR      16	/* Append errors to $@, don't overwrite it */
#define G_NODEBUG      32	/* Disable debugging at toplevel.  */
#define G_METHOD       64       /* Calling method. */
#define G_FAKINGEVAL  256	/* Faking an eval context for call_sv or
				   fold_constants. */

/* flag bits for PL_in_eval */
#define EVAL_NULL	0	/* not in an eval */
#define EVAL_INEVAL	1	/* some enclosing scope is an eval */
#define EVAL_WARNONLY	2	/* used by yywarn() when calling yyerror() */
#define EVAL_KEEPERR	4	/* set by Perl_call_sv if G_KEEPERR */
#define EVAL_INREQUIRE	8	/* The code is being required. */

/* Support for switching (stack and block) contexts.
 * This ensures magic doesn't invalidate local stack and cx pointers.
 */

#define PERLSI_UNKNOWN		-1
#define PERLSI_UNDEF		0
#define PERLSI_MAIN		1
#define PERLSI_MAGIC		2
#define PERLSI_SORT		3
#define PERLSI_SIGNAL		4
#define PERLSI_OVERLOAD		5
#define PERLSI_DESTROY		6
#define PERLSI_WARNHOOK		7
#define PERLSI_DIEHOOK		8
#define PERLSI_REQUIRE		9

struct stackinfo {
    AV *		si_stack;	/* stack for current runlevel */
    PERL_CONTEXT *	si_cxstack;	/* context stack for runlevel */
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
    I32			si_cxix;	/* current context index */
    I32			si_cxmax;	/* maximum allocated index */
    I32			si_type;	/* type of runlevel */
    I32			si_markoff;	/* offset where markstack begins for us.
					 * currently used only with DEBUGGING,
					 * but not #ifdef-ed for bincompat */
};

typedef struct stackinfo PERL_SI;

#define cxstack		(PL_curstackinfo->si_cxstack)
#define cxstack_ix	(PL_curstackinfo->si_cxix)
#define cxstack_max	(PL_curstackinfo->si_cxmax)

#ifdef DEBUGGING
#  define	SET_MARK_OFFSET \
    PL_curstackinfo->si_markoff = PL_markstack_ptr - PL_markstack
#else
#  define	SET_MARK_OFFSET NOOP
#endif

#define PUSHSTACKi(type) \
    STMT_START {							\
	PERL_SI *next = PL_curstackinfo->si_next;			\
	if (!next) {							\
	    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);	\
	    next->si_prev = PL_curstackinfo;				\
	    PL_curstackinfo->si_next = next;				\
	}								\
	next->si_type = type;						\
	next->si_cxix = -1;						\
	AvFILLp(next->si_stack) = 0;					\
	SWITCHSTACK(PL_curstack,next->si_stack);			\
	PL_curstackinfo = next;						\
	SET_MARK_OFFSET;						\
    } STMT_END

#define PUSHSTACK PUSHSTACKi(PERLSI_UNKNOWN)

/* POPSTACK works with PL_stack_sp, so it may need to be bracketed by
 * PUTBACK/SPAGAIN to flush/refresh any local SP that may be active */
#define POPSTACK \
    STMT_START {							\
	dSP;								\
	PERL_SI * const prev = PL_curstackinfo->si_prev;		\
	if (!prev) {							\
	    PerlIO_printf(Perl_error_log, "panic: POPSTACK\n");		\
	    my_exit(1);							\
	}								\
	SWITCHSTACK(PL_curstack,prev->si_stack);			\
	/* don't free prev here, free them all at the END{} */		\
	PL_curstackinfo = prev;						\
    } STMT_END

#define POPSTACK_TO(s) \
    STMT_START {							\
	while (PL_curstack != s) {					\
	    dounwind(-1);						\
	    POPSTACK;							\
	}								\
    } STMT_END

#define IN_PERL_COMPILETIME	(PL_curcop == &PL_compiling)
#define IN_PERL_RUNTIME		(PL_curcop != &PL_compiling)

/*
=head1 Multicall Functions

=for apidoc Ams||dMULTICALL
Declare local variables for a multicall. See L<perlcall/Lightweight Callbacks>.

=for apidoc Ams||PUSH_MULTICALL
Opening bracket for a lightweight callback.
See L<perlcall/Lightweight Callbacks>.

=for apidoc Ams||MULTICALL
Make a lightweight callback. See L<perlcall/Lightweight Callbacks>.

=for apidoc Ams||POP_MULTICALL
Closing bracket for a lightweight callback.
See L<perlcall/Lightweight Callbacks>.

=cut
*/

#define dMULTICALL \
    SV **newsp;			/* set by POPBLOCK */			\
    PERL_CONTEXT *cx;							\
    CV *multicall_cv;							\
    OP *multicall_cop;							\
    bool multicall_oldcatch; 						\
    U8 hasargs = 0		/* used by PUSHSUB */

#define PUSH_MULTICALL(the_cv) \
    STMT_START {							\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	AV * const padlist = CvPADLIST(cv);				\
	ENTER;								\
 	multicall_oldcatch = CATCH_GET;					\
	SAVETMPS; SAVEVPTR(PL_op);					\
	CATCH_SET(TRUE);						\
	PUSHBLOCK(cx, CXt_SUB|CXp_MULTICALL, PL_stack_sp);		\
	PUSHSUB(cx);							\
	if (++CvDEPTH(cv) >= 2) {					\
	    PERL_STACK_OVERFLOW_CHECK();				\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	}								\
	SAVECOMPPAD();							\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cv = cv;						\
	multicall_cop = CvSTART(cv);					\
    } STMT_END

#define MULTICALL \
    STMT_START {							\
	PL_op = multicall_cop;						\
	CALLRUNOPS(aTHX);						\
    } STMT_END

#define POP_MULTICALL \
    STMT_START {							\
	LEAVESUB(multicall_cv);						\
	CvDEPTH(multicall_cv)--;					\
	POPBLOCK(cx,PL_curpm);						\
	CATCH_SET(multicall_oldcatch);					\
	LEAVE;								\
    } STMT_END

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\embedvar.h ===
/*  -*- buffer-read-only: t -*-
 *
 *    embedvar.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by embed.pl from data in embed.fnc, embed.pl,
 * pp.sym, intrpvar.h, and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

/* (Doing namespace management portably in C is really gross.) */

/*
   The following combinations of MULTIPLICITY and PERL_IMPLICIT_CONTEXT
   are supported:
     1) none
     2) MULTIPLICITY	# supported for compatibility
     3) MULTIPLICITY && PERL_IMPLICIT_CONTEXT

   All other combinations of these flags are errors.

   only #3 is supported directly, while #2 is a special
   case of #3 (supported by redefining vTHX appropriately).
*/

#if defined(MULTIPLICITY)
/* cases 2 and 3 above */

#  if defined(PERL_IMPLICIT_CONTEXT)
#    define vTHX	aTHX
#  else
#    define vTHX	PERL_GET_INTERP
#  endif

#define PL_Argv			(vTHX->IArgv)
#define PL_Cmd			(vTHX->ICmd)
#define PL_DBcv			(vTHX->IDBcv)
#define PL_DBgv			(vTHX->IDBgv)
#define PL_DBline		(vTHX->IDBline)
#define PL_DBsignal		(vTHX->IDBsignal)
#define PL_DBsingle		(vTHX->IDBsingle)
#define PL_DBsub		(vTHX->IDBsub)
#define PL_DBtrace		(vTHX->IDBtrace)
#define PL_Dir			(vTHX->IDir)
#define PL_Env			(vTHX->IEnv)
#define PL_LIO			(vTHX->ILIO)
#define PL_Mem			(vTHX->IMem)
#define PL_MemParse		(vTHX->IMemParse)
#define PL_MemShared		(vTHX->IMemShared)
#define PL_OpPtr		(vTHX->IOpPtr)
#define PL_OpSlab		(vTHX->IOpSlab)
#define PL_OpSpace		(vTHX->IOpSpace)
#define PL_Proc			(vTHX->IProc)
#define PL_Sock			(vTHX->ISock)
#define PL_StdIO		(vTHX->IStdIO)
#define PL_Sv			(vTHX->ISv)
#define PL_Xpv			(vTHX->IXpv)
#define PL_amagic_generation	(vTHX->Iamagic_generation)
#define PL_an			(vTHX->Ian)
#define PL_argvgv		(vTHX->Iargvgv)
#define PL_argvout_stack	(vTHX->Iargvout_stack)
#define PL_argvoutgv		(vTHX->Iargvoutgv)
#define PL_basetime		(vTHX->Ibasetime)
#define PL_beginav		(vTHX->Ibeginav)
#define PL_beginav_save		(vTHX->Ibeginav_save)
#define PL_bitcount		(vTHX->Ibitcount)
#define PL_body_arenas		(vTHX->Ibody_arenas)
#define PL_body_roots		(vTHX->Ibody_roots)
#define PL_bodytarget		(vTHX->Ibodytarget)
#define PL_checkav		(vTHX->Icheckav)
#define PL_checkav_save		(vTHX->Icheckav_save)
#define PL_chopset		(vTHX->Ichopset)
#define PL_clocktick		(vTHX->Iclocktick)
#define PL_collation_ix		(vTHX->Icollation_ix)
#define PL_collation_name	(vTHX->Icollation_name)
#define PL_collation_standard	(vTHX->Icollation_standard)
#define PL_collxfrm_base	(vTHX->Icollxfrm_base)
#define PL_collxfrm_mult	(vTHX->Icollxfrm_mult)
#define PL_colors		(vTHX->Icolors)
#define PL_colorset		(vTHX->Icolorset)
#define PL_compcv		(vTHX->Icompcv)
#define PL_compiling		(vTHX->Icompiling)
#define PL_comppad		(vTHX->Icomppad)
#define PL_comppad_name		(vTHX->Icomppad_name)
#define PL_comppad_name_fill	(vTHX->Icomppad_name_fill)
#define PL_comppad_name_floor	(vTHX->Icomppad_name_floor)
#define PL_cop_seqmax		(vTHX->Icop_seqmax)
#define PL_cryptseen		(vTHX->Icryptseen)
#define PL_curcop		(vTHX->Icurcop)
#define PL_curcopdb		(vTHX->Icurcopdb)
#define PL_curpad		(vTHX->Icurpad)
#define PL_curpm		(vTHX->Icurpm)
#define PL_curstack		(vTHX->Icurstack)
#define PL_curstackinfo		(vTHX->Icurstackinfo)
#define PL_curstash		(vTHX->Icurstash)
#define PL_curstname		(vTHX->Icurstname)
#define PL_custom_op_descs	(vTHX->Icustom_op_descs)
#define PL_custom_op_names	(vTHX->Icustom_op_names)
#define PL_cv_has_eval		(vTHX->Icv_has_eval)
#define PL_dbargs		(vTHX->Idbargs)
#define PL_debstash		(vTHX->Idebstash)
#define PL_debug		(vTHX->Idebug)
#define PL_debug_pad		(vTHX->Idebug_pad)
#define PL_def_layerlist	(vTHX->Idef_layerlist)
#define PL_defgv		(vTHX->Idefgv)
#define PL_defoutgv		(vTHX->Idefoutgv)
#define PL_defstash		(vTHX->Idefstash)
#define PL_delaymagic		(vTHX->Idelaymagic)
#define PL_destroyhook		(vTHX->Idestroyhook)
#define PL_diehook		(vTHX->Idiehook)
#define PL_dirty		(vTHX->Idirty)
#define PL_doextract		(vTHX->Idoextract)
#define PL_doswitches		(vTHX->Idoswitches)
#define PL_dowarn		(vTHX->Idowarn)
#define PL_dumper_fd		(vTHX->Idumper_fd)
#define PL_dumpindent		(vTHX->Idumpindent)
#define PL_e_script		(vTHX->Ie_script)
#define PL_efloatbuf		(vTHX->Iefloatbuf)
#define PL_efloatsize		(vTHX->Iefloatsize)
#define PL_egid			(vTHX->Iegid)
#define PL_encoding		(vTHX->Iencoding)
#define PL_endav		(vTHX->Iendav)
#define PL_envgv		(vTHX->Ienvgv)
#define PL_errgv		(vTHX->Ierrgv)
#define PL_errors		(vTHX->Ierrors)
#define PL_euid			(vTHX->Ieuid)
#define PL_eval_root		(vTHX->Ieval_root)
#define PL_eval_start		(vTHX->Ieval_start)
#define PL_evalseq		(vTHX->Ievalseq)
#define PL_exit_flags		(vTHX->Iexit_flags)
#define PL_exitlist		(vTHX->Iexitlist)
#define PL_exitlistlen		(vTHX->Iexitlistlen)
#define PL_fdpid		(vTHX->Ifdpid)
#define PL_filemode		(vTHX->Ifilemode)
#define PL_firstgv		(vTHX->Ifirstgv)
#define PL_forkprocess		(vTHX->Iforkprocess)
#define PL_formfeed		(vTHX->Iformfeed)
#define PL_formtarget		(vTHX->Iformtarget)
#define PL_generation		(vTHX->Igeneration)
#define PL_gensym		(vTHX->Igensym)
#define PL_gid			(vTHX->Igid)
#define PL_glob_index		(vTHX->Iglob_index)
#define PL_globalstash		(vTHX->Iglobalstash)
#define PL_hash_seed		(vTHX->Ihash_seed)
#define PL_hintgv		(vTHX->Ihintgv)
#define PL_hints		(vTHX->Ihints)
#define PL_hv_fetch_ent_mh	(vTHX->Ihv_fetch_ent_mh)
#define PL_in_clean_all		(vTHX->Iin_clean_all)
#define PL_in_clean_objs	(vTHX->Iin_clean_objs)
#define PL_in_eval		(vTHX->Iin_eval)
#define PL_in_load_module	(vTHX->Iin_load_module)
#define PL_incgv		(vTHX->Iincgv)
#define PL_initav		(vTHX->Iinitav)
#define PL_inplace		(vTHX->Iinplace)
#define PL_isarev		(vTHX->Iisarev)
#define PL_known_layers		(vTHX->Iknown_layers)
#define PL_last_in_gv		(vTHX->Ilast_in_gv)
#define PL_last_swash_hv	(vTHX->Ilast_swash_hv)
#define PL_last_swash_key	(vTHX->Ilast_swash_key)
#define PL_last_swash_klen	(vTHX->Ilast_swash_klen)
#define PL_last_swash_slen	(vTHX->Ilast_swash_slen)
#define PL_last_swash_tmps	(vTHX->Ilast_swash_tmps)
#define PL_lastfd		(vTHX->Ilastfd)
#define PL_lastgotoprobe	(vTHX->Ilastgotoprobe)
#define PL_lastscream		(vTHX->Ilastscream)
#define PL_laststatval		(vTHX->Ilaststatval)
#define PL_laststype		(vTHX->Ilaststype)
#define PL_localizing		(vTHX->Ilocalizing)
#define PL_localpatches		(vTHX->Ilocalpatches)
#define PL_lockhook		(vTHX->Ilockhook)
#define PL_madskills		(vTHX->Imadskills)
#define PL_main_cv		(vTHX->Imain_cv)
#define PL_main_root		(vTHX->Imain_root)
#define PL_main_start		(vTHX->Imain_start)
#define PL_mainstack		(vTHX->Imainstack)
#define PL_markstack		(vTHX->Imarkstack)
#define PL_markstack_max	(vTHX->Imarkstack_max)
#define PL_markstack_ptr	(vTHX->Imarkstack_ptr)
#define PL_max_intro_pending	(vTHX->Imax_intro_pending)
#define PL_maxo			(vTHX->Imaxo)
#define PL_maxscream		(vTHX->Imaxscream)
#define PL_maxsysfd		(vTHX->Imaxsysfd)
#define PL_memory_debug_header	(vTHX->Imemory_debug_header)
#define PL_mess_sv		(vTHX->Imess_sv)
#define PL_min_intro_pending	(vTHX->Imin_intro_pending)
#define PL_minus_E		(vTHX->Iminus_E)
#define PL_minus_F		(vTHX->Iminus_F)
#define PL_minus_a		(vTHX->Iminus_a)
#define PL_minus_c		(vTHX->Iminus_c)
#define PL_minus_l		(vTHX->Iminus_l)
#define PL_minus_n		(vTHX->Iminus_n)
#define PL_minus_p		(vTHX->Iminus_p)
#define PL_modcount		(vTHX->Imodcount)
#define PL_modglobal		(vTHX->Imodglobal)
#define PL_my_cxt_keys		(vTHX->Imy_cxt_keys)
#define PL_my_cxt_list		(vTHX->Imy_cxt_list)
#define PL_my_cxt_size		(vTHX->Imy_cxt_size)
#define PL_na			(vTHX->Ina)
#define PL_nice_chunk		(vTHX->Inice_chunk)
#define PL_nice_chunk_size	(vTHX->Inice_chunk_size)
#define PL_nomemok		(vTHX->Inomemok)
#define PL_numeric_local	(vTHX->Inumeric_local)
#define PL_numeric_name		(vTHX->Inumeric_name)
#define PL_numeric_radix_sv	(vTHX->Inumeric_radix_sv)
#define PL_numeric_standard	(vTHX->Inumeric_standard)
#define PL_ofs_sv		(vTHX->Iofs_sv)
#define PL_oldname		(vTHX->Ioldname)
#define PL_op			(vTHX->Iop)
#define PL_op_mask		(vTHX->Iop_mask)
#define PL_opsave		(vTHX->Iopsave)
#define PL_origalen		(vTHX->Iorigalen)
#define PL_origargc		(vTHX->Iorigargc)
#define PL_origargv		(vTHX->Iorigargv)
#define PL_origenviron		(vTHX->Iorigenviron)
#define PL_origfilename		(vTHX->Iorigfilename)
#define PL_ors_sv		(vTHX->Iors_sv)
#define PL_osname		(vTHX->Iosname)
#define PL_pad_reset_pending	(vTHX->Ipad_reset_pending)
#define PL_padix		(vTHX->Ipadix)
#define PL_padix_floor		(vTHX->Ipadix_floor)
#define PL_parser		(vTHX->Iparser)
#define PL_patchlevel		(vTHX->Ipatchlevel)
#define PL_peepp		(vTHX->Ipeepp)
#define PL_perl_destruct_level	(vTHX->Iperl_destruct_level)
#define PL_perldb		(vTHX->Iperldb)
#define PL_perlio		(vTHX->Iperlio)
#define PL_pidstatus		(vTHX->Ipidstatus)
#define PL_ppid			(vTHX->Ippid)
#define PL_preambleav		(vTHX->Ipreambleav)
#define PL_preprocess		(vTHX->Ipreprocess)
#define PL_profiledata		(vTHX->Iprofiledata)
#define PL_psig_name		(vTHX->Ipsig_name)
#define PL_psig_pend		(vTHX->Ipsig_pend)
#define PL_psig_ptr		(vTHX->Ipsig_ptr)
#define PL_ptr_table		(vTHX->Iptr_table)
#define PL_reentrant_buffer	(vTHX->Ireentrant_buffer)
#define PL_reentrant_retint	(vTHX->Ireentrant_retint)
#define PL_reg_state		(vTHX->Ireg_state)
#define PL_regdummy		(vTHX->Iregdummy)
#define PL_regex_pad		(vTHX->Iregex_pad)
#define PL_regex_padav		(vTHX->Iregex_padav)
#define PL_reginterp_cnt	(vTHX->Ireginterp_cnt)
#define PL_regmatch_slab	(vTHX->Iregmatch_slab)
#define PL_regmatch_state	(vTHX->Iregmatch_state)
#define PL_rehash_seed		(vTHX->Irehash_seed)
#define PL_rehash_seed_set	(vTHX->Irehash_seed_set)
#define PL_replgv		(vTHX->Ireplgv)
#define PL_restartop		(vTHX->Irestartop)
#define PL_rs			(vTHX->Irs)
#define PL_runops		(vTHX->Irunops)
#define PL_savebegin		(vTHX->Isavebegin)
#define PL_savestack		(vTHX->Isavestack)
#define PL_savestack_ix		(vTHX->Isavestack_ix)
#define PL_savestack_max	(vTHX->Isavestack_max)
#define PL_sawampersand		(vTHX->Isawampersand)
#define PL_scopestack		(vTHX->Iscopestack)
#define PL_scopestack_ix	(vTHX->Iscopestack_ix)
#define PL_scopestack_max	(vTHX->Iscopestack_max)
#define PL_screamfirst		(vTHX->Iscreamfirst)
#define PL_screamnext		(vTHX->Iscreamnext)
#define PL_secondgv		(vTHX->Isecondgv)
#define PL_sharehook		(vTHX->Isharehook)
#define PL_sig_pending		(vTHX->Isig_pending)
#define PL_sighandlerp		(vTHX->Isighandlerp)
#define PL_signals		(vTHX->Isignals)
#define PL_slab_count		(vTHX->Islab_count)
#define PL_slabs		(vTHX->Islabs)
#define PL_sort_RealCmp		(vTHX->Isort_RealCmp)
#define PL_sortcop		(vTHX->Isortcop)
#define PL_sortstash		(vTHX->Isortstash)
#define PL_splitstr		(vTHX->Isplitstr)
#define PL_srand_called		(vTHX->Isrand_called)
#define PL_stack_base		(vTHX->Istack_base)
#define PL_stack_max		(vTHX->Istack_max)
#define PL_stack_sp		(vTHX->Istack_sp)
#define PL_start_env		(vTHX->Istart_env)
#define PL_stashcache		(vTHX->Istashcache)
#define PL_statbuf		(vTHX->Istatbuf)
#define PL_statcache		(vTHX->Istatcache)
#define PL_statgv		(vTHX->Istatgv)
#define PL_statname		(vTHX->Istatname)
#define PL_statusvalue		(vTHX->Istatusvalue)
#define PL_statusvalue_posix	(vTHX->Istatusvalue_posix)
#define PL_statusvalue_vms	(vTHX->Istatusvalue_vms)
#define PL_stderrgv		(vTHX->Istderrgv)
#define PL_stdingv		(vTHX->Istdingv)
#define PL_strtab		(vTHX->Istrtab)
#define PL_sub_generation	(vTHX->Isub_generation)
#define PL_subline		(vTHX->Isubline)
#define PL_subname		(vTHX->Isubname)
#define PL_sv_arenaroot		(vTHX->Isv_arenaroot)
#define PL_sv_count		(vTHX->Isv_count)
#define PL_sv_no		(vTHX->Isv_no)
#define PL_sv_objcount		(vTHX->Isv_objcount)
#define PL_sv_root		(vTHX->Isv_root)
#define PL_sv_undef		(vTHX->Isv_undef)
#define PL_sv_yes		(vTHX->Isv_yes)
#define PL_sys_intern		(vTHX->Isys_intern)
#define PL_taint_warn		(vTHX->Itaint_warn)
#define PL_tainted		(vTHX->Itainted)
#define PL_tainting		(vTHX->Itainting)
#define PL_threadhook		(vTHX->Ithreadhook)
#define PL_timesbuf		(vTHX->Itimesbuf)
#define PL_tmps_floor		(vTHX->Itmps_floor)
#define PL_tmps_ix		(vTHX->Itmps_ix)
#define PL_tmps_max		(vTHX->Itmps_max)
#define PL_tmps_stack		(vTHX->Itmps_stack)
#define PL_top_env		(vTHX->Itop_env)
#define PL_toptarget		(vTHX->Itoptarget)
#define PL_uid			(vTHX->Iuid)
#define PL_unicode		(vTHX->Iunicode)
#define PL_unitcheckav		(vTHX->Iunitcheckav)
#define PL_unitcheckav_save	(vTHX->Iunitcheckav_save)
#define PL_unlockhook		(vTHX->Iunlockhook)
#define PL_unsafe		(vTHX->Iunsafe)
#define PL_utf8_alnum		(vTHX->Iutf8_alnum)
#define PL_utf8_alnumc		(vTHX->Iutf8_alnumc)
#define PL_utf8_alpha		(vTHX->Iutf8_alpha)
#define PL_utf8_ascii		(vTHX->Iutf8_ascii)
#define PL_utf8_cntrl		(vTHX->Iutf8_cntrl)
#define PL_utf8_digit		(vTHX->Iutf8_digit)
#define PL_utf8_graph		(vTHX->Iutf8_graph)
#define PL_utf8_idcont		(vTHX->Iutf8_idcont)
#define PL_utf8_idstart		(vTHX->Iutf8_idstart)
#define PL_utf8_lower		(vTHX->Iutf8_lower)
#define PL_utf8_mark		(vTHX->Iutf8_mark)
#define PL_utf8_print		(vTHX->Iutf8_print)
#define PL_utf8_punct		(vTHX->Iutf8_punct)
#define PL_utf8_space		(vTHX->Iutf8_space)
#define PL_utf8_tofold		(vTHX->Iutf8_tofold)
#define PL_utf8_tolower		(vTHX->Iutf8_tolower)
#define PL_utf8_totitle		(vTHX->Iutf8_totitle)
#define PL_utf8_toupper		(vTHX->Iutf8_toupper)
#define PL_utf8_upper		(vTHX->Iutf8_upper)
#define PL_utf8_xdigit		(vTHX->Iutf8_xdigit)
#define PL_utf8cache		(vTHX->Iutf8cache)
#define PL_utf8locale		(vTHX->Iutf8locale)
#define PL_warnhook		(vTHX->Iwarnhook)
#define PL_watchaddr		(vTHX->Iwatchaddr)
#define PL_watchok		(vTHX->Iwatchok)
#define PL_xmlfp		(vTHX->Ixmlfp)

#else	/* !MULTIPLICITY */

/* case 1 above */

#define PL_IArgv		PL_Argv
#define PL_ICmd			PL_Cmd
#define PL_IDBcv		PL_DBcv
#define PL_IDBgv		PL_DBgv
#define PL_IDBline		PL_DBline
#define PL_IDBsignal		PL_DBsignal
#define PL_IDBsingle		PL_DBsingle
#define PL_IDBsub		PL_DBsub
#define PL_IDBtrace		PL_DBtrace
#define PL_IDir			PL_Dir
#define PL_IEnv			PL_Env
#define PL_ILIO			PL_LIO
#define PL_IMem			PL_Mem
#define PL_IMemParse		PL_MemParse
#define PL_IMemShared		PL_MemShared
#define PL_IOpPtr		PL_OpPtr
#define PL_IOpSlab		PL_OpSlab
#define PL_IOpSpace		PL_OpSpace
#define PL_IProc		PL_Proc
#define PL_ISock		PL_Sock
#define PL_IStdIO		PL_StdIO
#define PL_ISv			PL_Sv
#define PL_IXpv			PL_Xpv
#define PL_Iamagic_generation	PL_amagic_generation
#define PL_Ian			PL_an
#define PL_Iargvgv		PL_argvgv
#define PL_Iargvout_stack	PL_argvout_stack
#define PL_Iargvoutgv		PL_argvoutgv
#define PL_Ibasetime		PL_basetime
#define PL_Ibeginav		PL_beginav
#define PL_Ibeginav_save	PL_beginav_save
#define PL_Ibitcount		PL_bitcount
#define PL_Ibody_arenas		PL_body_arenas
#define PL_Ibody_roots		PL_body_roots
#define PL_Ibodytarget		PL_bodytarget
#define PL_Icheckav		PL_checkav
#define PL_Icheckav_save	PL_checkav_save
#define PL_Ichopset		PL_chopset
#define PL_Iclocktick		PL_clocktick
#define PL_Icollation_ix	PL_collation_ix
#define PL_Icollation_name	PL_collation_name
#define PL_Icollation_standard	PL_collation_standard
#define PL_Icollxfrm_base	PL_collxfrm_base
#define PL_Icollxfrm_mult	PL_collxfrm_mult
#define PL_Icolors		PL_colors
#define PL_Icolorset		PL_colorset
#define PL_Icompcv		PL_compcv
#define PL_Icompiling		PL_compiling
#define PL_Icomppad		PL_comppad
#define PL_Icomppad_name	PL_comppad_name
#define PL_Icomppad_name_fill	PL_comppad_name_fill
#define PL_Icomppad_name_floor	PL_comppad_name_floor
#define PL_Icop_seqmax		PL_cop_seqmax
#define PL_Icryptseen		PL_cryptseen
#define PL_Icurcop		PL_curcop
#define PL_Icurcopdb		PL_curcopdb
#define PL_Icurpad		PL_curpad
#define PL_Icurpm		PL_curpm
#define PL_Icurstack		PL_curstack
#define PL_Icurstackinfo	PL_curstackinfo
#define PL_Icurstash		PL_curstash
#define PL_Icurstname		PL_curstname
#define PL_Icustom_op_descs	PL_custom_op_descs
#define PL_Icustom_op_names	PL_custom_op_names
#define PL_Icv_has_eval		PL_cv_has_eval
#define PL_Idbargs		PL_dbargs
#define PL_Idebstash		PL_debstash
#define PL_Idebug		PL_debug
#define PL_Idebug_pad		PL_debug_pad
#define PL_Idef_layerlist	PL_def_layerlist
#define PL_Idefgv		PL_defgv
#define PL_Idefoutgv		PL_defoutgv
#define PL_Idefstash		PL_defstash
#define PL_Idelaymagic		PL_delaymagic
#define PL_Idestroyhook		PL_destroyhook
#define PL_Idiehook		PL_diehook
#define PL_Idirty		PL_dirty
#define PL_Idoextract		PL_doextract
#define PL_Idoswitches		PL_doswitches
#define PL_Idowarn		PL_dowarn
#define PL_Idumper_fd		PL_dumper_fd
#define PL_Idumpindent		PL_dumpindent
#define PL_Ie_script		PL_e_script
#define PL_Iefloatbuf		PL_efloatbuf
#define PL_Iefloatsize		PL_efloatsize
#define PL_Iegid		PL_egid
#define PL_Iencoding		PL_encoding
#define PL_Iendav		PL_endav
#define PL_Ienvgv		PL_envgv
#define PL_Ierrgv		PL_errgv
#define PL_Ierrors		PL_errors
#define PL_Ieuid		PL_euid
#define PL_Ieval_root		PL_eval_root
#define PL_Ieval_start		PL_eval_start
#define PL_Ievalseq		PL_evalseq
#define PL_Iexit_flags		PL_exit_flags
#define PL_Iexitlist		PL_exitlist
#define PL_Iexitlistlen		PL_exitlistlen
#define PL_Ifdpid		PL_fdpid
#define PL_Ifilemode		PL_filemode
#define PL_Ifirstgv		PL_firstgv
#define PL_Iforkprocess		PL_forkprocess
#define PL_Iformfeed		PL_formfeed
#define PL_Iformtarget		PL_formtarget
#define PL_Igeneration		PL_generation
#define PL_Igensym		PL_gensym
#define PL_Igid			PL_gid
#define PL_Iglob_index		PL_glob_index
#define PL_Iglobalstash		PL_globalstash
#define PL_Ihash_seed		PL_hash_seed
#define PL_Ihintgv		PL_hintgv
#define PL_Ihints		PL_hints
#define PL_Ihv_fetch_ent_mh	PL_hv_fetch_ent_mh
#define PL_Iin_clean_all	PL_in_clean_all
#define PL_Iin_clean_objs	PL_in_clean_objs
#define PL_Iin_eval		PL_in_eval
#define PL_Iin_load_module	PL_in_load_module
#define PL_Iincgv		PL_incgv
#define PL_Iinitav		PL_initav
#define PL_Iinplace		PL_inplace
#define PL_Iisarev		PL_isarev
#define PL_Iknown_layers	PL_known_layers
#define PL_Ilast_in_gv		PL_last_in_gv
#define PL_Ilast_swash_hv	PL_last_swash_hv
#define PL_Ilast_swash_key	PL_last_swash_key
#define PL_Ilast_swash_klen	PL_last_swash_klen
#define PL_Ilast_swash_slen	PL_last_swash_slen
#define PL_Ilast_swash_tmps	PL_last_swash_tmps
#define PL_Ilastfd		PL_lastfd
#define PL_Ilastgotoprobe	PL_lastgotoprobe
#define PL_Ilastscream		PL_lastscream
#define PL_Ilaststatval		PL_laststatval
#define PL_Ilaststype		PL_laststype
#define PL_Ilocalizing		PL_localizing
#define PL_Ilocalpatches	PL_localpatches
#define PL_Ilockhook		PL_lockhook
#define PL_Imadskills		PL_madskills
#define PL_Imain_cv		PL_main_cv
#define PL_Imain_root		PL_main_root
#define PL_Imain_start		PL_main_start
#define PL_Imainstack		PL_mainstack
#define PL_Imarkstack		PL_markstack
#define PL_Imarkstack_max	PL_markstack_max
#define PL_Imarkstack_ptr	PL_markstack_ptr
#define PL_Imax_intro_pending	PL_max_intro_pending
#define PL_Imaxo		PL_maxo
#define PL_Imaxscream		PL_maxscream
#define PL_Imaxsysfd		PL_maxsysfd
#define PL_Imemory_debug_header	PL_memory_debug_header
#define PL_Imess_sv		PL_mess_sv
#define PL_Imin_intro_pending	PL_min_intro_pending
#define PL_Iminus_E		PL_minus_E
#define PL_Iminus_F		PL_minus_F
#define PL_Iminus_a		PL_minus_a
#define PL_Iminus_c		PL_minus_c
#define PL_Iminus_l		PL_minus_l
#define PL_Iminus_n		PL_minus_n
#define PL_Iminus_p		PL_minus_p
#define PL_Imodcount		PL_modcount
#define PL_Imodglobal		PL_modglobal
#define PL_Imy_cxt_keys		PL_my_cxt_keys
#define PL_Imy_cxt_list		PL_my_cxt_list
#define PL_Imy_cxt_size		PL_my_cxt_size
#define PL_Ina			PL_na
#define PL_Inice_chunk		PL_nice_chunk
#define PL_Inice_chunk_size	PL_nice_chunk_size
#define PL_Inomemok		PL_nomemok
#define PL_Inumeric_local	PL_numeric_local
#define PL_Inumeric_name	PL_numeric_name
#define PL_Inumeric_radix_sv	PL_numeric_radix_sv
#define PL_Inumeric_standard	PL_numeric_standard
#define PL_Iofs_sv		PL_ofs_sv
#define PL_Ioldname		PL_oldname
#define PL_Iop			PL_op
#define PL_Iop_mask		PL_op_mask
#define PL_Iopsave		PL_opsave
#define PL_Iorigalen		PL_origalen
#define PL_Iorigargc		PL_origargc
#define PL_Iorigargv		PL_origargv
#define PL_Iorigenviron		PL_origenviron
#define PL_Iorigfilename	PL_origfilename
#define PL_Iors_sv		PL_ors_sv
#define PL_Iosname		PL_osname
#define PL_Ipad_reset_pending	PL_pad_reset_pending
#define PL_Ipadix		PL_padix
#define PL_Ipadix_floor		PL_padix_floor
#define PL_Iparser		PL_parser
#define PL_Ipatchlevel		PL_patchlevel
#define PL_Ipeepp		PL_peepp
#define PL_Iperl_destruct_level	PL_perl_destruct_level
#define PL_Iperldb		PL_perldb
#define PL_Iperlio		PL_perlio
#define PL_Ipidstatus		PL_pidstatus
#define PL_Ippid		PL_ppid
#define PL_Ipreambleav		PL_preambleav
#define PL_Ipreprocess		PL_preprocess
#define PL_Iprofiledata		PL_profiledata
#define PL_Ipsig_name		PL_psig_name
#define PL_Ipsig_pend		PL_psig_pend
#define PL_Ipsig_ptr		PL_psig_ptr
#define PL_Iptr_table		PL_ptr_table
#define PL_Ireentrant_buffer	PL_reentrant_buffer
#define PL_Ireentrant_retint	PL_reentrant_retint
#define PL_Ireg_state		PL_reg_state
#define PL_Iregdummy		PL_regdummy
#define PL_Iregex_pad		PL_regex_pad
#define PL_Iregex_padav		PL_regex_padav
#define PL_Ireginterp_cnt	PL_reginterp_cnt
#define PL_Iregmatch_slab	PL_regmatch_slab
#define PL_Iregmatch_state	PL_regmatch_state
#define PL_Irehash_seed		PL_rehash_seed
#define PL_Irehash_seed_set	PL_rehash_seed_set
#define PL_Ireplgv		PL_replgv
#define PL_Irestartop		PL_restartop
#define PL_Irs			PL_rs
#define PL_Irunops		PL_runops
#define PL_Isavebegin		PL_savebegin
#define PL_Isavestack		PL_savestack
#define PL_Isavestack_ix	PL_savestack_ix
#define PL_Isavestack_max	PL_savestack_max
#define PL_Isawampersand	PL_sawampersand
#define PL_Iscopestack		PL_scopestack
#define PL_Iscopestack_ix	PL_scopestack_ix
#define PL_Iscopestack_max	PL_scopestack_max
#define PL_Iscreamfirst		PL_screamfirst
#define PL_Iscreamnext		PL_screamnext
#define PL_Isecondgv		PL_secondgv
#define PL_Isharehook		PL_sharehook
#define PL_Isig_pending		PL_sig_pending
#define PL_Isighandlerp		PL_sighandlerp
#define PL_Isignals		PL_signals
#define PL_Islab_count		PL_slab_count
#define PL_Islabs		PL_slabs
#define PL_Isort_RealCmp	PL_sort_RealCmp
#define PL_Isortcop		PL_sortcop
#define PL_Isortstash		PL_sortstash
#define PL_Isplitstr		PL_splitstr
#define PL_Isrand_called	PL_srand_called
#define PL_Istack_base		PL_stack_base
#define PL_Istack_max		PL_stack_max
#define PL_Istack_sp		PL_stack_sp
#define PL_Istart_env		PL_start_env
#define PL_Istashcache		PL_stashcache
#define PL_Istatbuf		PL_statbuf
#define PL_Istatcache		PL_statcache
#define PL_Istatgv		PL_statgv
#define PL_Istatname		PL_statname
#define PL_Istatusvalue		PL_statusvalue
#define PL_Istatusvalue_posix	PL_statusvalue_posix
#define PL_Istatusvalue_vms	PL_statusvalue_vms
#define PL_Istderrgv		PL_stderrgv
#define PL_Istdingv		PL_stdingv
#define PL_Istrtab		PL_strtab
#define PL_Isub_generation	PL_sub_generation
#define PL_Isubline		PL_subline
#define PL_Isubname		PL_subname
#define PL_Isv_arenaroot	PL_sv_arenaroot
#define PL_Isv_count		PL_sv_count
#define PL_Isv_no		PL_sv_no
#define PL_Isv_objcount		PL_sv_objcount
#define PL_Isv_root		PL_sv_root
#define PL_Isv_undef		PL_sv_undef
#define PL_Isv_yes		PL_sv_yes
#define PL_Isys_intern		PL_sys_intern
#define PL_Itaint_warn		PL_taint_warn
#define PL_Itainted		PL_tainted
#define PL_Itainting		PL_tainting
#define PL_Ithreadhook		PL_threadhook
#define PL_Itimesbuf		PL_timesbuf
#define PL_Itmps_floor		PL_tmps_floor
#define PL_Itmps_ix		PL_tmps_ix
#define PL_Itmps_max		PL_tmps_max
#define PL_Itmps_stack		PL_tmps_stack
#define PL_Itop_env		PL_top_env
#define PL_Itoptarget		PL_toptarget
#define PL_Iuid			PL_uid
#define PL_Iunicode		PL_unicode
#define PL_Iunitcheckav		PL_unitcheckav
#define PL_Iunitcheckav_save	PL_unitcheckav_save
#define PL_Iunlockhook		PL_unlockhook
#define PL_Iunsafe		PL_unsafe
#define PL_Iutf8_alnum		PL_utf8_alnum
#define PL_Iutf8_alnumc		PL_utf8_alnumc
#define PL_Iutf8_alpha		PL_utf8_alpha
#define PL_Iutf8_ascii		PL_utf8_ascii
#define PL_Iutf8_cntrl		PL_utf8_cntrl
#define PL_Iutf8_digit		PL_utf8_digit
#define PL_Iutf8_graph		PL_utf8_graph
#define PL_Iutf8_idcont		PL_utf8_idcont
#define PL_Iutf8_idstart	PL_utf8_idstart
#define PL_Iutf8_lower		PL_utf8_lower
#define PL_Iutf8_mark		PL_utf8_mark
#define PL_Iutf8_print		PL_utf8_print
#define PL_Iutf8_punct		PL_utf8_punct
#define PL_Iutf8_space		PL_utf8_space
#define PL_Iutf8_tofold		PL_utf8_tofold
#define PL_Iutf8_tolower	PL_utf8_tolower
#define PL_Iutf8_totitle	PL_utf8_totitle
#define PL_Iutf8_toupper	PL_utf8_toupper
#define PL_Iutf8_upper		PL_utf8_upper
#define PL_Iutf8_xdigit		PL_utf8_xdigit
#define PL_Iutf8cache		PL_utf8cache
#define PL_Iutf8locale		PL_utf8locale
#define PL_Iwarnhook		PL_warnhook
#define PL_Iwatchaddr		PL_watchaddr
#define PL_Iwatchok		PL_watchok
#define PL_Ixmlfp		PL_xmlfp


#endif	/* MULTIPLICITY */

#if defined(PERL_GLOBAL_STRUCT)

#define PL_No			(my_vars->GNo)
#define PL_GNo			(my_vars->GNo)
#define PL_Yes			(my_vars->GYes)
#define PL_GYes			(my_vars->GYes)
#define PL_appctx		(my_vars->Gappctx)
#define PL_Gappctx		(my_vars->Gappctx)
#define PL_check		(my_vars->Gcheck)
#define PL_Gcheck		(my_vars->Gcheck)
#define PL_csighandlerp		(my_vars->Gcsighandlerp)
#define PL_Gcsighandlerp	(my_vars->Gcsighandlerp)
#define PL_curinterp		(my_vars->Gcurinterp)
#define PL_Gcurinterp		(my_vars->Gcurinterp)
#define PL_do_undump		(my_vars->Gdo_undump)
#define PL_Gdo_undump		(my_vars->Gdo_undump)
#define PL_dollarzero_mutex	(my_vars->Gdollarzero_mutex)
#define PL_Gdollarzero_mutex	(my_vars->Gdollarzero_mutex)
#define PL_fold_locale		(my_vars->Gfold_locale)
#define PL_Gfold_locale		(my_vars->Gfold_locale)
#define PL_global_struct_size	(my_vars->Gglobal_struct_size)
#define PL_Gglobal_struct_size	(my_vars->Gglobal_struct_size)
#define PL_hexdigit		(my_vars->Ghexdigit)
#define PL_Ghexdigit		(my_vars->Ghexdigit)
#define PL_hints_mutex		(my_vars->Ghints_mutex)
#define PL_Ghints_mutex		(my_vars->Ghints_mutex)
#define PL_interp_size		(my_vars->Ginterp_size)
#define PL_Ginterp_size		(my_vars->Ginterp_size)
#define PL_interp_size_5_10_0	(my_vars->Ginterp_size_5_10_0)
#define PL_Ginterp_size_5_10_0	(my_vars->Ginterp_size_5_10_0)
#define PL_malloc_mutex		(my_vars->Gmalloc_mutex)
#define PL_Gmalloc_mutex	(my_vars->Gmalloc_mutex)
#define PL_mmap_page_size	(my_vars->Gmmap_page_size)
#define PL_Gmmap_page_size	(my_vars->Gmmap_page_size)
#define PL_my_ctx_mutex		(my_vars->Gmy_ctx_mutex)
#define PL_Gmy_ctx_mutex	(my_vars->Gmy_ctx_mutex)
#define PL_my_cxt_index		(my_vars->Gmy_cxt_index)
#define PL_Gmy_cxt_index	(my_vars->Gmy_cxt_index)
#define PL_op_mutex		(my_vars->Gop_mutex)
#define PL_Gop_mutex		(my_vars->Gop_mutex)
#define PL_op_seq		(my_vars->Gop_seq)
#define PL_Gop_seq		(my_vars->Gop_seq)
#define PL_op_sequence		(my_vars->Gop_sequence)
#define PL_Gop_sequence		(my_vars->Gop_sequence)
#define PL_patleave		(my_vars->Gpatleave)
#define PL_Gpatleave		(my_vars->Gpatleave)
#define PL_perlio_debug_fd	(my_vars->Gperlio_debug_fd)
#define PL_Gperlio_debug_fd	(my_vars->Gperlio_debug_fd)
#define PL_perlio_fd_refcnt	(my_vars->Gperlio_fd_refcnt)
#define PL_Gperlio_fd_refcnt	(my_vars->Gperlio_fd_refcnt)
#define PL_perlio_fd_refcnt_size	(my_vars->Gperlio_fd_refcnt_size)
#define PL_Gperlio_fd_refcnt_size	(my_vars->Gperlio_fd_refcnt_size)
#define PL_perlio_mutex		(my_vars->Gperlio_mutex)
#define PL_Gperlio_mutex	(my_vars->Gperlio_mutex)
#define PL_ppaddr		(my_vars->Gppaddr)
#define PL_Gppaddr		(my_vars->Gppaddr)
#define PL_revision		(my_vars->Grevision)
#define PL_Grevision		(my_vars->Grevision)
#define PL_runops_dbg		(my_vars->Grunops_dbg)
#define PL_Grunops_dbg		(my_vars->Grunops_dbg)
#define PL_runops_std		(my_vars->Grunops_std)
#define PL_Grunops_std		(my_vars->Grunops_std)
#define PL_sh_path		(my_vars->Gsh_path)
#define PL_Gsh_path		(my_vars->Gsh_path)
#define PL_sig_defaulting	(my_vars->Gsig_defaulting)
#define PL_Gsig_defaulting	(my_vars->Gsig_defaulting)
#define PL_sig_handlers_initted	(my_vars->Gsig_handlers_initted)
#define PL_Gsig_handlers_initted	(my_vars->Gsig_handlers_initted)
#define PL_sig_ignoring		(my_vars->Gsig_ignoring)
#define PL_Gsig_ignoring	(my_vars->Gsig_ignoring)
#define PL_sig_sv		(my_vars->Gsig_sv)
#define PL_Gsig_sv		(my_vars->Gsig_sv)
#define PL_sig_trapped		(my_vars->Gsig_trapped)
#define PL_Gsig_trapped		(my_vars->Gsig_trapped)
#define PL_sigfpe_saved		(my_vars->Gsigfpe_saved)
#define PL_Gsigfpe_saved	(my_vars->Gsigfpe_saved)
#define PL_subversion		(my_vars->Gsubversion)
#define PL_Gsubversion		(my_vars->Gsubversion)
#define PL_sv_placeholder	(my_vars->Gsv_placeholder)
#define PL_Gsv_placeholder	(my_vars->Gsv_placeholder)
#define PL_thr_key		(my_vars->Gthr_key)
#define PL_Gthr_key		(my_vars->Gthr_key)
#define PL_timesbase		(my_vars->Gtimesbase)
#define PL_Gtimesbase		(my_vars->Gtimesbase)
#define PL_use_safe_putenv	(my_vars->Guse_safe_putenv)
#define PL_Guse_safe_putenv	(my_vars->Guse_safe_putenv)
#define PL_version		(my_vars->Gversion)
#define PL_Gversion		(my_vars->Gversion)
#define PL_veto_cleanup		(my_vars->Gveto_cleanup)
#define PL_Gveto_cleanup	(my_vars->Gveto_cleanup)
#define PL_watch_pvx		(my_vars->Gwatch_pvx)
#define PL_Gwatch_pvx		(my_vars->Gwatch_pvx)

#else /* !PERL_GLOBAL_STRUCT */

#define PL_GNo			PL_No
#define PL_GYes			PL_Yes
#define PL_Gappctx		PL_appctx
#define PL_Gcheck		PL_check
#define PL_Gcsighandlerp	PL_csighandlerp
#define PL_Gcurinterp		PL_curinterp
#define PL_Gdo_undump		PL_do_undump
#define PL_Gdollarzero_mutex	PL_dollarzero_mutex
#define PL_Gfold_locale		PL_fold_locale
#define PL_Gglobal_struct_size	PL_global_struct_size
#define PL_Ghexdigit		PL_hexdigit
#define PL_Ghints_mutex		PL_hints_mutex
#define PL_Ginterp_size		PL_interp_size
#define PL_Ginterp_size_5_10_0	PL_interp_size_5_10_0
#define PL_Gmalloc_mutex	PL_malloc_mutex
#define PL_Gmmap_page_size	PL_mmap_page_size
#define PL_Gmy_ctx_mutex	PL_my_ctx_mutex
#define PL_Gmy_cxt_index	PL_my_cxt_index
#define PL_Gop_mutex		PL_op_mutex
#define PL_Gop_seq		PL_op_seq
#define PL_Gop_sequence		PL_op_sequence
#define PL_Gpatleave		PL_patleave
#define PL_Gperlio_debug_fd	PL_perlio_debug_fd
#define PL_Gperlio_fd_refcnt	PL_perlio_fd_refcnt
#define PL_Gperlio_fd_refcnt_size	PL_perlio_fd_refcnt_size
#define PL_Gperlio_mutex	PL_perlio_mutex
#define PL_Gppaddr		PL_ppaddr
#define PL_Grevision		PL_revision
#define PL_Grunops_dbg		PL_runops_dbg
#define PL_Grunops_std		PL_runops_std
#define PL_Gsh_path		PL_sh_path
#define PL_Gsig_defaulting	PL_sig_defaulting
#define PL_Gsig_handlers_initted	PL_sig_handlers_initted
#define PL_Gsig_ignoring	PL_sig_ignoring
#define PL_Gsig_sv		PL_sig_sv
#define PL_Gsig_trapped		PL_sig_trapped
#define PL_Gsigfpe_saved	PL_sigfpe_saved
#define PL_Gsubversion		PL_subversion
#define PL_Gsv_placeholder	PL_sv_placeholder
#define PL_Gthr_key		PL_thr_key
#define PL_Gtimesbase		PL_timesbase
#define PL_Guse_safe_putenv	PL_use_safe_putenv
#define PL_Gversion		PL_version
#define PL_Gveto_cleanup	PL_veto_cleanup
#define PL_Gwatch_pvx		PL_watch_pvx

#endif /* PERL_GLOBAL_STRUCT */

#ifdef PERL_POLLUTE		/* disabled by default in 5.6.0 */

#define DBassertion		PL_DBassertion
#define DBsingle		PL_DBsingle
#define DBsub			PL_DBsub
#define compiling		PL_compiling
#define curcop			PL_curcop
#define curstash		PL_curstash
#define debstash		PL_debstash
#define defgv			PL_defgv
#define diehook			PL_diehook
#define dirty			PL_dirty
#define dowarn			PL_dowarn
#define errgv			PL_errgv
#define na			PL_na
#define no_modify		PL_no_modify
#define perl_destruct_level	PL_perl_destruct_level
#define perldb			PL_perldb
#define ppaddr			PL_ppaddr
#define rsfp			PL_rsfp
#define rsfp_filters		PL_rsfp_filters
#define stack_base		PL_stack_base
#define stack_sp		PL_stack_sp
#define stdingv			PL_stdingv
#define sv_arenaroot		PL_sv_arenaroot
#define sv_no			PL_sv_no
#define sv_undef		PL_sv_undef
#define sv_yes			PL_sv_yes
#define tainted			PL_tainted
#define tainting		PL_tainting

#endif /* PERL_POLLUTE */

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\dosish.h ===
/*    dosish.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
#define ABORT() abort();

#ifndef SH_PATH
#define SH_PATH "/bin/sh"
#endif

#ifdef DJGPP
#  define BIT_BUCKET "nul"
#  define OP_BINARY O_BINARY
#  define PERL_SYS_INIT_BODY(c,v)					\
	 MALLOC_CHECK_TAINT2(*c,*v) Perl_DJGPP_init(c,v); PERLIO_INIT
#  define init_os_extras Perl_init_os_extras
#  define HAS_UTIME
#  define HAS_KILL
   char *djgpp_pathexp (const char*);
   void Perl_DJGPP_init (int *argcp,char ***argvp);
#  if (DJGPP==2 && DJGPP_MINOR < 2)
#    define NO_LOCALECONV_MON_THOUSANDS_SEP
#  endif
#  define PERL_FS_VER_FMT	"%d_%d_%d"
#else	/* DJGPP */
#  ifdef WIN32
#    define PERL_SYS_INIT_BODY(c,v)					\
	MALLOC_CHECK_TAINT2(*c,*v) Perl_win32_init(c,v); PERLIO_INIT
#    define PERL_SYS_TERM_BODY()   Perl_win32_term()
#    define BIT_BUCKET "nul"
#  else
#	 ifdef NETWARE
#      define PERL_SYS_INIT_BODY(c,v)					\
	MALLOC_CHECK_TAINT2(*c,*v) Perl_nw5_init(c,v); PERLIO_INIT
#      define BIT_BUCKET "nwnul"
#    else
#      define PERL_SYS_INIT_BODY(c,v)		\
	MALLOC_CHECK_TAINT2(*c,*v); PERLIO_INIT
#      define BIT_BUCKET "\\dev\\nul" /* "wanna be like, umm, Newlined, or somethin?" */
#    endif /* NETWARE */
#  endif
#endif	/* DJGPP */

#ifndef PERL_SYS_TERM_BODY
#  define PERL_SYS_TERM_BODY() HINTS_REFCNT_TERM; OP_REFCNT_TERM; PERLIO_TERM; MALLOC_TERM
#endif
#define dXSUB_SYS

/*
 * 5.003_07 and earlier keyed on #ifdef MSDOS for determining if we were 
 * running on DOS, *and* if we had to cope with 16 bit memory addressing 
 * constraints, *and* we need to have memory allocated as unsigned long.
 *
 * with the advent of *real* compilers for DOS, they are not locked together.
 * MSDOS means "I am running on MSDOS". HAS_64K_LIMIT means "I have 
 * 16 bit memory addressing constraints".
 *
 * if you need the last, try #DEFINE MEM_SIZE unsigned long.
 */
#ifdef MSDOS
#  ifndef DJGPP
#    define HAS_64K_LIMIT
#  endif
#endif

/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#if defined(WIN64) || defined(USE_LARGE_FILES)
# if defined(__BORLANDC__) /* buk */
#  include <sys\stat.h>
#  define Stat_t struct stati64
# else
#define Stat_t struct _stati64
# endif
#else
#if defined(UNDER_CE)
#define Stat_t struct xcestat
#else
#define Stat_t struct stat
#endif
#endif

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if it finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
/* #define ALTERNATE_SHEBANG "#!" / **/

#include <signal.h>

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#ifdef DJGPP
#   define Fflush(fp)      djgpp_fflush(fp)
#else
#   define Fflush(fp)      fflush(fp)
#endif
#define Mkdir(path,mode)   mkdir((path),(mode))

#ifndef WIN32
#  define Stat(fname,bufptr) stat((fname),(bufptr))
#else
#  define HAS_IOCTL
#  define HAS_UTIME
#  define HAS_KILL
#  define HAS_WAIT
#  define HAS_CHOWN
#endif	/* WIN32 */

/*
 * <rich@phekda.freeserve.co.uk>: The DJGPP port has code that converts
 * the return code of system() into the form that Unixy wait usually
 * returns:
 *
 * - signal number in bits 0-6;
 * - core dump flag in bit 7;
 * - exit code in bits 8-15.
 *
 * Bits 0-7 are always zero for DJGPP, because it uses system().
 * See djgpp.c.
 *
 * POSIX::W* use the W* macros from <sys/wait.h> to decode
 * the return code. Unfortunately the W* macros for DJGPP use
 * a different format than Unixy wait does. So there's a mismatch
 * and, say, WEXITSTATUS($?) will return bogus values.
 *
 * So here we add hack to redefine the W* macros from DJGPP's <sys/wait.h>
 * to work with our return-code conversion.
 */

#ifdef DJGPP

#include <sys/wait.h>

#undef WEXITSTATUS
#undef WIFEXITED
#undef WIFSIGNALED
#undef WIFSTOPPED
#undef WNOHANG
#undef WSTOPSIG
#undef WTERMSIG
#undef WUNTRACED

#define WEXITSTATUS(stat_val) ((stat_val) >> 8)
#define WIFEXITED(stat_val)   0
#define WIFSIGNALED(stat_val) 0
#define WIFSTOPPED(stat_val)  0
#define WNOHANG               0
#define WSTOPSIG(stat_val)    0
#define WTERMSIG(stat_val)    0
#define WUNTRACED             0

#endif

/* Don't go reading from /dev/urandom */
#define PERL_NO_DEV_RANDOM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\dirent.h ===
/* dirent.h */

/* djl
 * Provide UNIX compatibility
 */

#ifndef  _INC_DIRENT
#define  _INC_DIRENT

/*
 * NT versions of readdir(), etc
 * From the MSDOS implementation
 */

/* Directory entry size */
#ifdef DIRSIZ
#undef DIRSIZ
#endif
#define DIRSIZ(rp)  (sizeof(struct direct))

/* needed to compile directory stuff */
#define DIRENT direct

/* structure of a directory entry */
typedef struct direct 
{
	long	d_ino;			/* inode number (not used by MS-DOS)  */
	long	d_namlen;		/* name length  */
	char	d_name[257];		/* file name  */
} _DIRECT;

/* structure for dir operations */
typedef struct _dir_struc
{
	char	*start;			/* starting position */
	char	*curr;			/* current position */
	long	size;			/* allocated size of string table */
	long	nfiles;			/* number of filenames in table */
	struct direct dirstr;		/* directory structure to return */
	void*	handle;			/* system handle */
	char	*end;			/* position after last filename */
} DIR;

#if 0		/* these have moved to win32iop.h */
DIR *		win32_opendir(const char *filename);
struct direct *	win32_readdir(DIR *dirp);
long		win32_telldir(DIR *dirp);
void		win32_seekdir(DIR *dirp,long loc);
void		win32_rewinddir(DIR *dirp);
int		win32_closedir(DIR *dirp);
#endif

#endif /* _INC_DIRENT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\cv.h ===
/*    cv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* This structure must the beginning of XPVFM in sv.h  */

struct xpvcv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* depth, >= 2 indicates recursive call */
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    PADLIST *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
};

typedef struct {
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* depth, >= 2 indicates recursive call */
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    PADLIST *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
} xpvcv_allocated;

/*
=head1 Handy Values

=for apidoc AmU||Nullcv
Null CV pointer.

=head1 CV Manipulation Functions

=for apidoc Am|HV*|CvSTASH|CV* cv
Returns the stash of the CV.

=cut
*/

#define Nullcv Null(CV*)

#define CvSTASH(sv)	((XPVCV*)SvANY(sv))->xcv_stash
#define CvSTART(sv)	((XPVCV*)SvANY(sv))->xcv_start_u.xcv_start
#define CvROOT(sv)	((XPVCV*)SvANY(sv))->xcv_root_u.xcv_root
#define CvXSUB(sv)	((XPVCV*)SvANY(sv))->xcv_root_u.xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)SvANY(sv))->xcv_start_u.xcv_xsubany
#define CvGV(sv)	((XPVCV*)SvANY(sv))->xcv_gv
#define CvFILE(sv)	((XPVCV*)SvANY(sv))->xcv_file
#ifdef USE_ITHREADS
#  define CvFILE_set_from_cop(sv, cop)	(CvFILE(sv) = savepv(CopFILE(cop)))
#else
#  define CvFILE_set_from_cop(sv, cop)	(CvFILE(sv) = CopFILE(cop))
#endif
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv)))
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define CvDEPTH(sv) (*({const CV *_cv = (CV *)sv; \
			  assert(SvTYPE(_cv) == SVt_PVCV ||	 \
				 SvTYPE(_cv) == SVt_PVFM);	 \
			  &((XPVCV*)SvANY(_cv))->xiv_u.xivu_i32; \
			}))
#else
#  define CvDEPTH(sv)	((XPVCV*)SvANY(sv))->xiv_u.xivu_i32
#endif
#define CvPADLIST(sv)	((XPVCV*)SvANY(sv))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)SvANY(sv))->xcv_outside
#define CvFLAGS(sv)	((XPVCV*)SvANY(sv))->xcv_flags
#define CvOUTSIDE_SEQ(sv) ((XPVCV*)SvANY(sv))->xcv_outside_seq

#define CVf_METHOD	0x0001	/* CV is explicitly marked as a method */
#define CVf_LOCKED	0x0002	/* CV locks itself or first arg on entry */
#define CVf_LVALUE	0x0004  /* CV return value can be used as lvalue */

#define CVf_WEAKOUTSIDE	0x0010  /* CvOUTSIDE isn't ref counted */
#define CVf_CLONE	0x0020	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0040	/* a clone of one of those */
#define CVf_ANON	0x0080	/* CvGV() can't be trusted */
#define CVf_UNIQUE	0x0100	/* sub is only called once (eg PL_main_cv,
				 * require, eval). */
#define CVf_NODEBUG	0x0200	/* no DB::sub indirection for this CV
				   (esp. useful for special XSUBs) */
#define CVf_CONST	0x0400  /* inlinable sub */
#define CVf_ISXSUB	0x0800	/* CV is an XSUB, not pure perl.  */

/* This symbol for optimised communication between toke.c and op.c: */
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LOCKED|CVf_LVALUE)

#define CvCLONE(cv)		(CvFLAGS(cv) & CVf_CLONE)
#define CvCLONE_on(cv)		(CvFLAGS(cv) |= CVf_CLONE)
#define CvCLONE_off(cv)		(CvFLAGS(cv) &= ~CVf_CLONE)

#define CvCLONED(cv)		(CvFLAGS(cv) & CVf_CLONED)
#define CvCLONED_on(cv)		(CvFLAGS(cv) |= CVf_CLONED)
#define CvCLONED_off(cv)	(CvFLAGS(cv) &= ~CVf_CLONED)

#define CvANON(cv)		(CvFLAGS(cv) & CVf_ANON)
#define CvANON_on(cv)		(CvFLAGS(cv) |= CVf_ANON)
#define CvANON_off(cv)		(CvFLAGS(cv) &= ~CVf_ANON)

#define CvUNIQUE(cv)		(CvFLAGS(cv) & CVf_UNIQUE)
#define CvUNIQUE_on(cv)		(CvFLAGS(cv) |= CVf_UNIQUE)
#define CvUNIQUE_off(cv)	(CvFLAGS(cv) &= ~CVf_UNIQUE)

#define CvNODEBUG(cv)		(CvFLAGS(cv) & CVf_NODEBUG)
#define CvNODEBUG_on(cv)	(CvFLAGS(cv) |= CVf_NODEBUG)
#define CvNODEBUG_off(cv)	(CvFLAGS(cv) &= ~CVf_NODEBUG)

#define CvMETHOD(cv)		(CvFLAGS(cv) & CVf_METHOD)
#define CvMETHOD_on(cv)		(CvFLAGS(cv) |= CVf_METHOD)
#define CvMETHOD_off(cv)	(CvFLAGS(cv) &= ~CVf_METHOD)

#define CvLOCKED(cv)		(CvFLAGS(cv) & CVf_LOCKED)
#define CvLOCKED_on(cv)		(CvFLAGS(cv) |= CVf_LOCKED)
#define CvLOCKED_off(cv)	(CvFLAGS(cv) &= ~CVf_LOCKED)

#define CvLVALUE(cv)		(CvFLAGS(cv) & CVf_LVALUE)
#define CvLVALUE_on(cv)		(CvFLAGS(cv) |= CVf_LVALUE)
#define CvLVALUE_off(cv)	(CvFLAGS(cv) &= ~CVf_LVALUE)

#define CvEVAL(cv)		(CvUNIQUE(cv) && !SvFAKE(cv))
#define CvEVAL_on(cv)		(CvUNIQUE_on(cv),SvFAKE_off(cv))
#define CvEVAL_off(cv)		CvUNIQUE_off(cv)

/* BEGIN|CHECK|INIT|UNITCHECK|END */
#define CvSPECIAL(cv)		(CvUNIQUE(cv) && SvFAKE(cv))
#define CvSPECIAL_on(cv)	(CvUNIQUE_on(cv),SvFAKE_on(cv))
#define CvSPECIAL_off(cv)	(CvUNIQUE_off(cv),SvFAKE_off(cv))

#define CvCONST(cv)		(CvFLAGS(cv) & CVf_CONST)
#define CvCONST_on(cv)		(CvFLAGS(cv) |= CVf_CONST)
#define CvCONST_off(cv)		(CvFLAGS(cv) &= ~CVf_CONST)

#define CvWEAKOUTSIDE(cv)	(CvFLAGS(cv) & CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_on(cv)	(CvFLAGS(cv) |= CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_off(cv)	(CvFLAGS(cv) &= ~CVf_WEAKOUTSIDE)

#define CvISXSUB(cv)		(CvFLAGS(cv) & CVf_ISXSUB)
#define CvISXSUB_on(cv)		(CvFLAGS(cv) |= CVf_ISXSUB)
#define CvISXSUB_off(cv)	(CvFLAGS(cv) &= ~CVf_ISXSUB)

/* Flags for newXS_flags  */
#define XS_DYNAMIC_FILENAME	0x01	/* The filename isn't static  */

/*
=head1 CV reference counts and CvOUTSIDE

=for apidoc m|bool|CvWEAKOUTSIDE|CV *cv

Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any). Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us. In this case, we set the
C<CvWEAKOUTSIDE> flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>. In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();

=cut
*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\embed.h ===
/*  -*- buffer-read-only: t -*-
 *
 *    embed.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by embed.pl from data in embed.fnc, embed.pl,
 * pp.sym, intrpvar.h, and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

/* (Doing namespace management portably in C is really gross.) */

/* By defining PERL_NO_SHORT_NAMES (not done by default) the short forms
 * (like warn instead of Perl_warn) for the API are not defined.
 * Not defining the short forms is a good thing for cleaner embedding. */

#ifndef PERL_NO_SHORT_NAMES

/* Hide global symbols */

#if !defined(PERL_IMPLICIT_CONTEXT)

#if defined(PERL_IMPLICIT_SYS)
#endif
#define doing_taint		Perl_doing_taint
#if defined(USE_ITHREADS)
#  if defined(PERL_IMPLICIT_SYS)
#  endif
#endif
#if defined(MYMALLOC)
#ifdef PERL_CORE
#define malloced_size		Perl_malloced_size
#endif
#endif
#define get_context		Perl_get_context
#define set_context		Perl_set_context
#define amagic_call		Perl_amagic_call
#define Gv_AMupdate		Perl_Gv_AMupdate
#define gv_handler		Perl_gv_handler
#ifdef PERL_CORE
#define append_elem		Perl_append_elem
#define append_list		Perl_append_list
#define apply			Perl_apply
#endif
#define apply_attrs_string	Perl_apply_attrs_string
#define av_clear		Perl_av_clear
#define av_delete		Perl_av_delete
#define av_exists		Perl_av_exists
#define av_extend		Perl_av_extend
#ifdef PERL_CORE
#define av_fake			Perl_av_fake
#endif
#define av_fetch		Perl_av_fetch
#define av_fill			Perl_av_fill
#define av_len			Perl_av_len
#define av_make			Perl_av_make
#define av_pop			Perl_av_pop
#define av_push			Perl_av_push
#if defined(PERL_CORE) || defined(PERL_EXT)
#define av_reify		Perl_av_reify
#endif
#define av_shift		Perl_av_shift
#define av_store		Perl_av_store
#define av_undef		Perl_av_undef
#define av_unshift		Perl_av_unshift
#ifdef PERL_CORE
#define bind_match		Perl_bind_match
#define block_end		Perl_block_end
#endif
#define block_gimme		Perl_block_gimme
#ifdef PERL_CORE
#define block_start		Perl_block_start
#define boot_core_UNIVERSAL	Perl_boot_core_UNIVERSAL
#define boot_core_ActivePerl	Perl_boot_core_ActivePerl
#define boot_core_PerlIO	Perl_boot_core_PerlIO
#endif
#define call_list		Perl_call_list
#ifdef PERL_CORE
#define cando			Perl_cando
#endif
#define cast_ulong		Perl_cast_ulong
#define cast_i32		Perl_cast_i32
#define cast_iv			Perl_cast_iv
#define cast_uv			Perl_cast_uv
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#define my_chsize		Perl_my_chsize
#endif
#ifdef PERL_CORE
#define convert			Perl_convert
#define create_eval_scope	Perl_create_eval_scope
#endif
#define croak			Perl_croak
#define vcroak			Perl_vcroak
#if defined(PERL_IMPLICIT_CONTEXT)
#define croak_nocontext		Perl_croak_nocontext
#define die_nocontext		Perl_die_nocontext
#define deb_nocontext		Perl_deb_nocontext
#define form_nocontext		Perl_form_nocontext
#define load_module_nocontext	Perl_load_module_nocontext
#define mess_nocontext		Perl_mess_nocontext
#define warn_nocontext		Perl_warn_nocontext
#define warner_nocontext	Perl_warner_nocontext
#define newSVpvf_nocontext	Perl_newSVpvf_nocontext
#define sv_catpvf_nocontext	Perl_sv_catpvf_nocontext
#define sv_setpvf_nocontext	Perl_sv_setpvf_nocontext
#define sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg_nocontext
#define sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg_nocontext
#define fprintf_nocontext	Perl_fprintf_nocontext
#define printf_nocontext	Perl_printf_nocontext
#endif
#ifdef PERL_CORE
#define cv_ckproto		Perl_cv_ckproto
#define cv_ckproto_len		Perl_cv_ckproto_len
#define cv_clone		Perl_cv_clone
#endif
#define gv_const_sv		Perl_gv_const_sv
#define cv_const_sv		Perl_cv_const_sv
#ifdef PERL_CORE
#define op_const_sv		Perl_op_const_sv
#endif
#define cv_undef		Perl_cv_undef
#define cx_dump			Perl_cx_dump
#define filter_add		Perl_filter_add
#define filter_del		Perl_filter_del
#define filter_read		Perl_filter_read
#define get_op_descs		Perl_get_op_descs
#define get_op_names		Perl_get_op_names
#ifdef PERL_CORE
#define get_no_modify		Perl_get_no_modify
#define get_opargs		Perl_get_opargs
#endif
#define get_ppaddr		Perl_get_ppaddr
#if defined(PERL_CORE) || defined(PERL_EXT)
#define cxinc			Perl_cxinc
#endif
#define deb			Perl_deb
#define vdeb			Perl_vdeb
#define debprofdump		Perl_debprofdump
#define debop			Perl_debop
#define debstack		Perl_debstack
#define debstackptrs		Perl_debstackptrs
#define delimcpy		Perl_delimcpy
#ifdef PERL_CORE
#define delete_eval_scope	Perl_delete_eval_scope
#define deprecate		Perl_deprecate
#define deprecate_old		Perl_deprecate_old
#endif
#define die			Perl_die
#ifdef PERL_CORE
#define vdie			Perl_vdie
#define die_where		Perl_die_where
#endif
#define dounwind		Perl_dounwind
#ifdef PERL_CORE
#define do_aexec5		Perl_do_aexec5
#endif
#define do_binmode		Perl_do_binmode
#ifdef PERL_CORE
#define do_chop			Perl_do_chop
#endif
#define do_close		Perl_do_close
#ifdef PERL_CORE
#define do_eof			Perl_do_eof
#endif
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#else
#ifdef PERL_CORE
#define do_exec			Perl_do_exec
#endif
#endif
#if defined(WIN32) || defined(__SYMBIAN32__)
#define do_aspawn		Perl_do_aspawn
#define do_spawn		Perl_do_spawn
#define do_spawn_nowait		Perl_do_spawn_nowait
#endif
#if !defined(WIN32)
#ifdef PERL_CORE
#define do_exec3		Perl_do_exec3
#endif
#endif
#ifdef PERL_CORE
#define do_execfree		Perl_do_execfree
#endif
#ifdef PERL_IN_DOIO_C
#ifdef PERL_CORE
#define exec_failed		S_exec_failed
#endif
#endif
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#ifdef PERL_CORE
#define do_ipcctl		Perl_do_ipcctl
#define do_ipcget		Perl_do_ipcget
#define do_msgrcv		Perl_do_msgrcv
#define do_msgsnd		Perl_do_msgsnd
#define do_semop		Perl_do_semop
#define do_shmio		Perl_do_shmio
#endif
#endif
#define do_join			Perl_do_join
#ifdef PERL_CORE
#define do_kv			Perl_do_kv
#endif
#define do_open9		Perl_do_open9
#define do_openn		Perl_do_openn
#ifdef PERL_CORE
#define do_print		Perl_do_print
#define do_readline		Perl_do_readline
#define do_chomp		Perl_do_chomp
#define do_seek			Perl_do_seek
#endif
#define do_sprintf		Perl_do_sprintf
#ifdef PERL_CORE
#define do_sysseek		Perl_do_sysseek
#define do_tell			Perl_do_tell
#define do_trans		Perl_do_trans
#define do_vecget		Perl_do_vecget
#define do_vecset		Perl_do_vecset
#define do_vop			Perl_do_vop
#define dofile			Perl_dofile
#endif
#define dowantarray		Perl_dowantarray
#define dump_all		Perl_dump_all
#define dump_eval		Perl_dump_eval
#if defined(DUMP_FDS)
#define dump_fds		Perl_dump_fds
#endif
#define dump_form		Perl_dump_form
#define gv_dump			Perl_gv_dump
#define op_dump			Perl_op_dump
#define pmop_dump		Perl_pmop_dump
#define dump_packsubs		Perl_dump_packsubs
#define dump_sub		Perl_dump_sub
#define fbm_compile		Perl_fbm_compile
#define fbm_instr		Perl_fbm_instr
#ifdef PERL_CORE
#define find_script		Perl_find_script
#define force_list		Perl_force_list
#define fold_constants		Perl_fold_constants
#endif
#define form			Perl_form
#define vform			Perl_vform
#define free_tmps		Perl_free_tmps
#ifdef PERL_CORE
#define gen_constant_list	Perl_gen_constant_list
#endif
#if !defined(HAS_GETENV_LEN)
#ifdef PERL_CORE
#define getenv_len		Perl_getenv_len
#endif
#endif
#define gp_free			Perl_gp_free
#define gp_ref			Perl_gp_ref
#define gv_AVadd		Perl_gv_AVadd
#define gv_HVadd		Perl_gv_HVadd
#define gv_IOadd		Perl_gv_IOadd
#define gv_autoload4		Perl_gv_autoload4
#define gv_check		Perl_gv_check
#define gv_efullname		Perl_gv_efullname
#define gv_efullname4		Perl_gv_efullname4
#define gv_fetchfile		Perl_gv_fetchfile
#define gv_fetchfile_flags	Perl_gv_fetchfile_flags
#define gv_fetchmeth		Perl_gv_fetchmeth
#define gv_fetchmeth_autoload	Perl_gv_fetchmeth_autoload
#define gv_fetchmethod_autoload	Perl_gv_fetchmethod_autoload
#define gv_fetchpv		Perl_gv_fetchpv
#define gv_fullname		Perl_gv_fullname
#define gv_fullname4		Perl_gv_fullname4
#define gv_init			Perl_gv_init
#define gv_name_set		Perl_gv_name_set
#define gv_stashpv		Perl_gv_stashpv
#define gv_stashpvn		Perl_gv_stashpvn
#define gv_stashsv		Perl_gv_stashsv
#define hv_clear		Perl_hv_clear
#define hv_delayfree_ent	Perl_hv_delayfree_ent
#define hv_common		Perl_hv_common
#define hv_common_key_len	Perl_hv_common_key_len
#define hv_free_ent		Perl_hv_free_ent
#define hv_iterinit		Perl_hv_iterinit
#define hv_iterkey		Perl_hv_iterkey
#define hv_iterkeysv		Perl_hv_iterkeysv
#define hv_iternextsv		Perl_hv_iternextsv
#define hv_iternext_flags	Perl_hv_iternext_flags
#define hv_iterval		Perl_hv_iterval
#define hv_ksplit		Perl_hv_ksplit
#define hv_undef		Perl_hv_undef
#define ibcmp			Perl_ibcmp
#define ibcmp_locale		Perl_ibcmp_locale
#define ibcmp_utf8		Perl_ibcmp_utf8
#ifdef PERL_CORE
#define ingroup			Perl_ingroup
#define init_argv_symbols	Perl_init_argv_symbols
#define init_debugger		Perl_init_debugger
#endif
#define init_stacks		Perl_init_stacks
#define init_tm			Perl_init_tm
#ifdef PERL_CORE
#define intro_my		Perl_intro_my
#endif
#define instr			Perl_instr
#ifdef PERL_CORE
#define io_close		Perl_io_close
#define invert			Perl_invert
#define is_gv_magical		Perl_is_gv_magical
#endif
#define is_lvalue_sub		Perl_is_lvalue_sub
#define to_uni_upper_lc		Perl_to_uni_upper_lc
#define to_uni_title_lc		Perl_to_uni_title_lc
#define to_uni_lower_lc		Perl_to_uni_lower_lc
#define is_uni_alnum		Perl_is_uni_alnum
#define is_uni_alnumc		Perl_is_uni_alnumc
#define is_uni_idfirst		Perl_is_uni_idfirst
#define is_uni_alpha		Perl_is_uni_alpha
#define is_uni_ascii		Perl_is_uni_ascii
#define is_uni_space		Perl_is_uni_space
#define is_uni_cntrl		Perl_is_uni_cntrl
#define is_uni_graph		Perl_is_uni_graph
#define is_uni_digit		Perl_is_uni_digit
#define is_uni_upper		Perl_is_uni_upper
#define is_uni_lower		Perl_is_uni_lower
#define is_uni_print		Perl_is_uni_print
#define is_uni_punct		Perl_is_uni_punct
#define is_uni_xdigit		Perl_is_uni_xdigit
#define to_uni_upper		Perl_to_uni_upper
#define to_uni_title		Perl_to_uni_title
#define to_uni_lower		Perl_to_uni_lower
#define to_uni_fold		Perl_to_uni_fold
#define is_uni_alnum_lc		Perl_is_uni_alnum_lc
#define is_uni_alnumc_lc	Perl_is_uni_alnumc_lc
#define is_uni_idfirst_lc	Perl_is_uni_idfirst_lc
#define is_uni_alpha_lc		Perl_is_uni_alpha_lc
#define is_uni_ascii_lc		Perl_is_uni_ascii_lc
#define is_uni_space_lc		Perl_is_uni_space_lc
#define is_uni_cntrl_lc		Perl_is_uni_cntrl_lc
#define is_uni_graph_lc		Perl_is_uni_graph_lc
#define is_uni_digit_lc		Perl_is_uni_digit_lc
#define is_uni_upper_lc		Perl_is_uni_upper_lc
#define is_uni_lower_lc		Perl_is_uni_lower_lc
#define is_uni_print_lc		Perl_is_uni_print_lc
#define is_uni_punct_lc		Perl_is_uni_punct_lc
#define is_uni_xdigit_lc	Perl_is_uni_xdigit_lc
#define is_utf8_char		Perl_is_utf8_char
#define is_utf8_string		Perl_is_utf8_string
#define is_utf8_string_loclen	Perl_is_utf8_string_loclen
#define is_utf8_alnum		Perl_is_utf8_alnum
#define is_utf8_alnumc		Perl_is_utf8_alnumc
#define is_utf8_idfirst		Perl_is_utf8_idfirst
#define is_utf8_idcont		Perl_is_utf8_idcont
#define is_utf8_alpha		Perl_is_utf8_alpha
#define is_utf8_ascii		Perl_is_utf8_ascii
#define is_utf8_space		Perl_is_utf8_space
#define is_utf8_cntrl		Perl_is_utf8_cntrl
#define is_utf8_digit		Perl_is_utf8_digit
#define is_utf8_graph		Perl_is_utf8_graph
#define is_utf8_upper		Perl_is_utf8_upper
#define is_utf8_lower		Perl_is_utf8_lower
#define is_utf8_print		Perl_is_utf8_print
#define is_utf8_punct		Perl_is_utf8_punct
#define is_utf8_xdigit		Perl_is_utf8_xdigit
#define is_utf8_mark		Perl_is_utf8_mark
#ifdef PERL_CORE
#define jmaybe			Perl_jmaybe
#define keyword			Perl_keyword
#endif
#define leave_scope		Perl_leave_scope
#if defined(PERL_CORE) || defined(PERL_EXT)
#define lex_end			Perl_lex_end
#endif
#ifdef PERL_CORE
#define lex_start		Perl_lex_start
#endif
#define op_null			Perl_op_null
#if defined(PERL_CORE) || defined(PERL_EXT)
#define op_clear		Perl_op_clear
#endif
#define op_refcnt_lock		Perl_op_refcnt_lock
#define op_refcnt_unlock	Perl_op_refcnt_unlock
#ifdef PERL_CORE
#define linklist		Perl_linklist
#define list			Perl_list
#define listkids		Perl_listkids
#endif
#define load_module		Perl_load_module
#define vload_module		Perl_vload_module
#ifdef PERL_CORE
#define localize		Perl_localize
#endif
#define looks_like_number	Perl_looks_like_number
#define grok_bin		Perl_grok_bin
#define grok_hex		Perl_grok_hex
#define grok_number		Perl_grok_number
#define grok_numeric_radix	Perl_grok_numeric_radix
#define grok_oct		Perl_grok_oct
#ifdef PERL_CORE
#define magic_clearenv		Perl_magic_clearenv
#define magic_clear_all_env	Perl_magic_clear_all_env
#define magic_clearhint		Perl_magic_clearhint
#define magic_clearpack		Perl_magic_clearpack
#define magic_clearsig		Perl_magic_clearsig
#define magic_existspack	Perl_magic_existspack
#define magic_freeregexp	Perl_magic_freeregexp
#define magic_freeovrld		Perl_magic_freeovrld
#define magic_get		Perl_magic_get
#define magic_getarylen		Perl_magic_getarylen
#define magic_getdefelem	Perl_magic_getdefelem
#define magic_getnkeys		Perl_magic_getnkeys
#define magic_getpack		Perl_magic_getpack
#define magic_getpos		Perl_magic_getpos
#define magic_getsig		Perl_magic_getsig
#define magic_getsubstr		Perl_magic_getsubstr
#define magic_gettaint		Perl_magic_gettaint
#define magic_getuvar		Perl_magic_getuvar
#define magic_getvec		Perl_magic_getvec
#define magic_len		Perl_magic_len
#define magic_nextpack		Perl_magic_nextpack
#define magic_regdata_cnt	Perl_magic_regdata_cnt
#define magic_regdatum_get	Perl_magic_regdatum_get
#define magic_regdatum_set	Perl_magic_regdatum_set
#define magic_set		Perl_magic_set
#define magic_setamagic		Perl_magic_setamagic
#define magic_setarylen		Perl_magic_setarylen
#define magic_freearylen_p	Perl_magic_freearylen_p
#define magic_setbm		Perl_magic_setbm
#define magic_setdbline		Perl_magic_setdbline
#define magic_setdefelem	Perl_magic_setdefelem
#define magic_setenv		Perl_magic_setenv
#define magic_setfm		Perl_magic_setfm
#define magic_sethint		Perl_magic_sethint
#define magic_setisa		Perl_magic_setisa
#define magic_setglob		Perl_magic_setglob
#define magic_setmglob		Perl_magic_setmglob
#define magic_setnkeys		Perl_magic_setnkeys
#define magic_setpack		Perl_magic_setpack
#define magic_setpos		Perl_magic_setpos
#define magic_setregexp		Perl_magic_setregexp
#define magic_setsig		Perl_magic_setsig
#define magic_setsubstr		Perl_magic_setsubstr
#define magic_settaint		Perl_magic_settaint
#define magic_setuvar		Perl_magic_setuvar
#define magic_setvec		Perl_magic_setvec
#define magic_setutf8		Perl_magic_setutf8
#define magic_set_all_env	Perl_magic_set_all_env
#define magic_sizepack		Perl_magic_sizepack
#define magic_wipepack		Perl_magic_wipepack
#define magicname		Perl_magicname
#endif
#define markstack_grow		Perl_markstack_grow
#if defined(USE_LOCALE_COLLATE)
#ifdef PERL_CORE
#define magic_setcollxfrm	Perl_magic_setcollxfrm
#define mem_collxfrm		Perl_mem_collxfrm
#endif
#endif
#define mess			Perl_mess
#define vmess			Perl_vmess
#if defined(PERL_CORE) || defined(PERL_EXT)
#define qerror			Perl_qerror
#endif
#define sortsv			Perl_sortsv
#define sortsv_flags		Perl_sortsv_flags
#define mg_clear		Perl_mg_clear
#define mg_copy			Perl_mg_copy
#ifdef PERL_CORE
#define mg_localize		Perl_mg_localize
#endif
#define mg_find			Perl_mg_find
#define mg_free			Perl_mg_free
#define mg_get			Perl_mg_get
#define mg_length		Perl_mg_length
#define mg_magical		Perl_mg_magical
#define mg_set			Perl_mg_set
#define mg_size			Perl_mg_size
#define mini_mktime		Perl_mini_mktime
#if defined(PERL_CORE) || defined(PERL_EXT)
#define mod			Perl_mod
#endif
#ifdef PERL_CORE
#define mode_from_discipline	Perl_mode_from_discipline
#endif
#define moreswitches		Perl_moreswitches
#ifdef PERL_CORE
#define my			Perl_my
#endif
#define my_atof			Perl_my_atof
#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
#define my_bcopy		Perl_my_bcopy
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
#define my_bzero		Perl_my_bzero
#endif
#define my_exit			Perl_my_exit
#define my_failure_exit		Perl_my_failure_exit
#define my_fflush_all		Perl_my_fflush_all
#define my_fork			Perl_my_fork
#define atfork_lock		Perl_atfork_lock
#define atfork_unlock		Perl_atfork_unlock
#define my_lstat		Perl_my_lstat
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
#define my_memcmp		Perl_my_memcmp
#endif
#if !defined(HAS_MEMSET)
#define my_memset		Perl_my_memset
#endif
#define my_pclose		Perl_my_pclose
#define my_popen		Perl_my_popen
#define my_popen_list		Perl_my_popen_list
#define my_setenv		Perl_my_setenv
#define my_stat			Perl_my_stat
#define my_strftime		Perl_my_strftime
#if defined(MYSWAP)
#define my_swap			Perl_my_swap
#define my_htonl		Perl_my_htonl
#define my_ntohl		Perl_my_ntohl
#endif
#ifdef PERL_CORE
#define my_unexec		Perl_my_unexec
#endif
#define newANONLIST		Perl_newANONLIST
#define newANONHASH		Perl_newANONHASH
#define newANONSUB		Perl_newANONSUB
#define newASSIGNOP		Perl_newASSIGNOP
#define newCONDOP		Perl_newCONDOP
#define newCONSTSUB		Perl_newCONSTSUB
#ifdef PERL_MAD
#define newFORM			Perl_newFORM
#else
#define newFORM			Perl_newFORM
#endif
#define newFOROP		Perl_newFOROP
#define newGIVENOP		Perl_newGIVENOP
#define newLOGOP		Perl_newLOGOP
#define newLOOPEX		Perl_newLOOPEX
#define newLOOPOP		Perl_newLOOPOP
#define newNULLLIST		Perl_newNULLLIST
#define newOP			Perl_newOP
#define newPROG			Perl_newPROG
#define newRANGE		Perl_newRANGE
#define newSLICEOP		Perl_newSLICEOP
#define newSTATEOP		Perl_newSTATEOP
#define newSUB			Perl_newSUB
#define newXS_flags		Perl_newXS_flags
#define newXS			Perl_newXS
#define newAV			Perl_newAV
#define newAVREF		Perl_newAVREF
#define newBINOP		Perl_newBINOP
#define newCVREF		Perl_newCVREF
#define newGVOP			Perl_newGVOP
#define newGVgen		Perl_newGVgen
#define newGVREF		Perl_newGVREF
#define newHVREF		Perl_newHVREF
#define newHV			Perl_newHV
#define newHVhv			Perl_newHVhv
#define newIO			Perl_newIO
#define newLISTOP		Perl_newLISTOP
#ifdef USE_ITHREADS
#define newPADOP		Perl_newPADOP
#endif
#define newPMOP			Perl_newPMOP
#define newPVOP			Perl_newPVOP
#define newRV			Perl_newRV
#define newRV_noinc		Perl_newRV_noinc
#define newSV			Perl_newSV
#define newSVREF		Perl_newSVREF
#define newSVOP			Perl_newSVOP
#define newSViv			Perl_newSViv
#define newSVuv			Perl_newSVuv
#define newSVnv			Perl_newSVnv
#define newSVpv			Perl_newSVpv
#define newSVpvn		Perl_newSVpvn
#define newSVhek		Perl_newSVhek
#define newSVpvn_share		Perl_newSVpvn_share
#define newSVpvf		Perl_newSVpvf
#define vnewSVpvf		Perl_vnewSVpvf
#define newSVrv			Perl_newSVrv
#define newSVsv			Perl_newSVsv
#define newSV_type		Perl_newSV_type
#define newUNOP			Perl_newUNOP
#define newWHENOP		Perl_newWHENOP
#define newWHILEOP		Perl_newWHILEOP
#define new_stackinfo		Perl_new_stackinfo
#define scan_vstring		Perl_scan_vstring
#define scan_version		Perl_scan_version
#define new_version		Perl_new_version
#define upg_version		Perl_upg_version
#define vverify			Perl_vverify
#define vnumify			Perl_vnumify
#define vnormal			Perl_vnormal
#define vstringify		Perl_vstringify
#define vcmp			Perl_vcmp
#ifdef PERL_CORE
#define nextargv		Perl_nextargv
#endif
#define ninstr			Perl_ninstr
#ifdef PERL_CORE
#define oopsCV			Perl_oopsCV
#endif
#define op_free			Perl_op_free
#ifdef PERL_MAD
#ifdef PERL_CORE
#define package			Perl_package
#endif
#else
#ifdef PERL_CORE
#define package			Perl_package
#endif
#endif
#ifdef PERL_CORE
#define pad_alloc		Perl_pad_alloc
#define allocmy			Perl_allocmy
#define pad_findmy		Perl_pad_findmy
#endif
#define find_rundefsvoffset	Perl_find_rundefsvoffset
#ifdef PERL_CORE
#define oopsAV			Perl_oopsAV
#define oopsHV			Perl_oopsHV
#define pad_leavemy		Perl_pad_leavemy
#endif
#define pad_sv			Perl_pad_sv
#ifdef PERL_CORE
#define pad_free		Perl_pad_free
#define pad_reset		Perl_pad_reset
#define pad_swipe		Perl_pad_swipe
#define peep			Perl_peep
#endif
#if defined(USE_REENTRANT_API)
#define reentrant_size		Perl_reentrant_size
#define reentrant_init		Perl_reentrant_init
#define reentrant_free		Perl_reentrant_free
#define reentrant_retry		Perl_reentrant_retry
#endif
#define call_atexit		Perl_call_atexit
#define call_argv		Perl_call_argv
#define call_method		Perl_call_method
#define call_pv			Perl_call_pv
#define call_sv			Perl_call_sv
#define despatch_signals	Perl_despatch_signals
#define doref			Perl_doref
#define eval_pv			Perl_eval_pv
#define eval_sv			Perl_eval_sv
#define get_sv			Perl_get_sv
#define get_av			Perl_get_av
#define get_hv			Perl_get_hv
#define get_cv			Perl_get_cv
#define get_cvn_flags		Perl_get_cvn_flags
#define init_i18nl10n		Perl_init_i18nl10n
#define init_i18nl14n		Perl_init_i18nl14n
#define new_collate		Perl_new_collate
#define new_ctype		Perl_new_ctype
#define new_numeric		Perl_new_numeric
#define set_numeric_local	Perl_set_numeric_local
#define set_numeric_radix	Perl_set_numeric_radix
#define set_numeric_standard	Perl_set_numeric_standard
#define require_pv		Perl_require_pv
#define pack_cat		Perl_pack_cat
#define packlist		Perl_packlist
#ifdef PERL_USES_PL_PIDSTATUS
#ifdef PERL_CORE
#define pidgone			Perl_pidgone
#endif
#endif
#define pmflag			Perl_pmflag
#ifdef PERL_CORE
#define pmruntime		Perl_pmruntime
#define pmtrans			Perl_pmtrans
#endif
#define pop_scope		Perl_pop_scope
#ifdef PERL_CORE
#define prepend_elem		Perl_prepend_elem
#endif
#define push_scope		Perl_push_scope
#ifdef PERL_CORE
#define refkids			Perl_refkids
#endif
#define regdump			Perl_regdump
#define regdump			Perl_regdump
#define regclass_swash		Perl_regclass_swash
#define pregexec		Perl_pregexec
#define pregfree		Perl_pregfree
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_temp_copy		Perl_reg_temp_copy
#endif
#define regfree_internal	Perl_regfree_internal
#define reg_stringify		Perl_reg_stringify
#if defined(USE_ITHREADS)
#define regdupe_internal	Perl_regdupe_internal
#endif
#define pregcomp		Perl_pregcomp
#define re_compile		Perl_re_compile
#define re_intuit_start		Perl_re_intuit_start
#define re_intuit_string	Perl_re_intuit_string
#define regexec_flags		Perl_regexec_flags
#define regnext			Perl_regnext
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_named_buff		Perl_reg_named_buff
#define reg_named_buff_iter	Perl_reg_named_buff_iter
#endif
#define reg_named_buff_fetch	Perl_reg_named_buff_fetch
#define reg_named_buff_exists	Perl_reg_named_buff_exists
#define reg_named_buff_firstkey	Perl_reg_named_buff_firstkey
#define reg_named_buff_nextkey	Perl_reg_named_buff_nextkey
#define reg_named_buff_scalar	Perl_reg_named_buff_scalar
#define reg_named_buff_all	Perl_reg_named_buff_all
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_numbered_buff_fetch	Perl_reg_numbered_buff_fetch
#define reg_numbered_buff_store	Perl_reg_numbered_buff_store
#define reg_numbered_buff_length	Perl_reg_numbered_buff_length
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_qr_package		Perl_reg_qr_package
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regprop			Perl_regprop
#endif
#define repeatcpy		Perl_repeatcpy
#define rninstr			Perl_rninstr
#define rsignal			Perl_rsignal
#ifdef PERL_CORE
#define rsignal_restore		Perl_rsignal_restore
#define rsignal_save		Perl_rsignal_save
#endif
#define rsignal_state		Perl_rsignal_state
#ifdef PERL_CORE
#define rxres_free		Perl_rxres_free
#define rxres_restore		Perl_rxres_restore
#define rxres_save		Perl_rxres_save
#endif
#if !defined(HAS_RENAME)
#ifdef PERL_CORE
#define same_dirent		Perl_same_dirent
#endif
#endif
#define savepv			Perl_savepv
#define savepvn			Perl_savepvn
#define savesharedpv		Perl_savesharedpv
#define savesharedpvn		Perl_savesharedpvn
#define savesvpv		Perl_savesvpv
#define savestack_grow		Perl_savestack_grow
#define savestack_grow_cnt	Perl_savestack_grow_cnt
#define save_aelem		Perl_save_aelem
#define save_alloc		Perl_save_alloc
#define save_aptr		Perl_save_aptr
#define save_ary		Perl_save_ary
#define save_bool		Perl_save_bool
#define save_clearsv		Perl_save_clearsv
#define save_delete		Perl_save_delete
#define save_destructor		Perl_save_destructor
#define save_destructor_x	Perl_save_destructor_x
#define save_freesv		Perl_save_freesv
#ifdef PERL_CORE
#define save_freeop		Perl_save_freeop
#endif
#define save_freepv		Perl_save_freepv
#define save_generic_svref	Perl_save_generic_svref
#define save_generic_pvref	Perl_save_generic_pvref
#define save_shared_pvref	Perl_save_shared_pvref
#define save_gp			Perl_save_gp
#define save_hash		Perl_save_hash
#define save_helem		Perl_save_helem
#define save_hptr		Perl_save_hptr
#define save_I16		Perl_save_I16
#define save_I32		Perl_save_I32
#define save_I8			Perl_save_I8
#define save_int		Perl_save_int
#define save_item		Perl_save_item
#define save_iv			Perl_save_iv
#define save_list		Perl_save_list
#define save_long		Perl_save_long
#define save_mortalizesv	Perl_save_mortalizesv
#define save_nogv		Perl_save_nogv
#ifdef PERL_CORE
#define save_op			Perl_save_op
#endif
#define save_scalar		Perl_save_scalar
#define save_pptr		Perl_save_pptr
#define save_vptr		Perl_save_vptr
#define save_re_context		Perl_save_re_context
#define save_padsv		Perl_save_padsv
#define save_sptr		Perl_save_sptr
#define save_svref		Perl_save_svref
#ifdef PERL_CORE
#define sawparens		Perl_sawparens
#define scalar			Perl_scalar
#define scalarkids		Perl_scalarkids
#define scalarseq		Perl_scalarseq
#define scalarvoid		Perl_scalarvoid
#endif
#define scan_bin		Perl_scan_bin
#define scan_hex		Perl_scan_hex
#define scan_num		Perl_scan_num
#define scan_oct		Perl_scan_oct
#ifdef PERL_CORE
#define scope			Perl_scope
#endif
#define screaminstr		Perl_screaminstr
#if !defined(VMS)
#ifdef PERL_CORE
#define setenv_getix		Perl_setenv_getix
#endif
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define setdefout		Perl_setdefout
#endif
#define share_hek		Perl_share_hek
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#ifdef PERL_CORE
#define sighandler		Perl_sighandler
#endif
#define csighandler		Perl_csighandler
#else
#ifdef PERL_CORE
#define sighandler		Perl_sighandler
#endif
#define csighandler		Perl_csighandler
#endif
#define stack_grow		Perl_stack_grow
#define start_subparse		Perl_start_subparse
#ifdef PERL_CORE
#define sub_crush_depth		Perl_sub_crush_depth
#endif
#define sv_2bool		Perl_sv_2bool
#define sv_2cv			Perl_sv_2cv
#define sv_2io			Perl_sv_2io
#ifdef PERL_IN_SV_C
#ifdef PERL_CORE
#define glob_2number		S_glob_2number
#define glob_2pv		S_glob_2pv
#endif
#endif
#define sv_2iv_flags		Perl_sv_2iv_flags
#define sv_2mortal		Perl_sv_2mortal
#define sv_2nv			Perl_sv_2nv
#ifdef PERL_CORE
#define sv_2num			Perl_sv_2num
#endif
#define sv_2pv_flags		Perl_sv_2pv_flags
#define sv_2pvutf8		Perl_sv_2pvutf8
#define sv_2pvbyte		Perl_sv_2pvbyte
#define sv_pvn_nomg		Perl_sv_pvn_nomg
#define sv_2uv_flags		Perl_sv_2uv_flags
#define sv_iv			Perl_sv_iv
#define sv_uv			Perl_sv_uv
#define sv_nv			Perl_sv_nv
#define sv_pvn			Perl_sv_pvn
#define sv_pvutf8n		Perl_sv_pvutf8n
#define sv_pvbyten		Perl_sv_pvbyten
#define sv_true			Perl_sv_true
#ifdef PERL_CORE
#define sv_add_arena		Perl_sv_add_arena
#endif
#define sv_backoff		Perl_sv_backoff
#define sv_bless		Perl_sv_bless
#define sv_catpvf		Perl_sv_catpvf
#define sv_vcatpvf		Perl_sv_vcatpvf
#define sv_catpv		Perl_sv_catpv
#define sv_chop			Perl_sv_chop
#ifdef PERL_CORE
#define sv_clean_all		Perl_sv_clean_all
#define sv_clean_objs		Perl_sv_clean_objs
#endif
#define sv_clear		Perl_sv_clear
#define sv_cmp			Perl_sv_cmp
#define sv_cmp_locale		Perl_sv_cmp_locale
#if defined(USE_LOCALE_COLLATE)
#define sv_collxfrm		Perl_sv_collxfrm
#endif
#define sv_compile_2op		Perl_sv_compile_2op
#define getcwd_sv		Perl_getcwd_sv
#define sv_dec			Perl_sv_dec
#define sv_dump			Perl_sv_dump
#define sv_derived_from		Perl_sv_derived_from
#define sv_does			Perl_sv_does
#define sv_eq			Perl_sv_eq
#define sv_free			Perl_sv_free
#ifdef PERL_CORE
#define sv_free_arenas		Perl_sv_free_arenas
#endif
#define sv_gets			Perl_sv_gets
#define sv_grow			Perl_sv_grow
#define sv_inc			Perl_sv_inc
#define sv_insert		Perl_sv_insert
#define sv_isa			Perl_sv_isa
#define sv_isobject		Perl_sv_isobject
#define sv_len			Perl_sv_len
#define sv_len_utf8		Perl_sv_len_utf8
#define sv_magic		Perl_sv_magic
#define sv_magicext		Perl_sv_magicext
#define sv_mortalcopy		Perl_sv_mortalcopy
#define sv_newmortal		Perl_sv_newmortal
#define sv_newref		Perl_sv_newref
#define sv_peek			Perl_sv_peek
#define sv_pos_u2b		Perl_sv_pos_u2b
#define sv_pos_b2u		Perl_sv_pos_b2u
#define sv_pvutf8n_force	Perl_sv_pvutf8n_force
#define sv_pvbyten_force	Perl_sv_pvbyten_force
#define sv_recode_to_utf8	Perl_sv_recode_to_utf8
#define sv_cat_decode		Perl_sv_cat_decode
#define sv_reftype		Perl_sv_reftype
#define sv_replace		Perl_sv_replace
#define sv_report_used		Perl_sv_report_used
#define sv_reset		Perl_sv_reset
#define sv_setpvf		Perl_sv_setpvf
#define sv_vsetpvf		Perl_sv_vsetpvf
#define sv_setiv		Perl_sv_setiv
#define sv_setpviv		Perl_sv_setpviv
#define sv_setuv		Perl_sv_setuv
#define sv_setnv		Perl_sv_setnv
#define sv_setref_iv		Perl_sv_setref_iv
#define sv_setref_uv		Perl_sv_setref_uv
#define sv_setref_nv		Perl_sv_setref_nv
#define sv_setref_pv		Perl_sv_setref_pv
#define sv_setref_pvn		Perl_sv_setref_pvn
#define sv_setpv		Perl_sv_setpv
#define sv_setpvn		Perl_sv_setpvn
#define sv_tainted		Perl_sv_tainted
#define sv_unmagic		Perl_sv_unmagic
#define sv_unref_flags		Perl_sv_unref_flags
#define sv_untaint		Perl_sv_untaint
#define sv_upgrade		Perl_sv_upgrade
#define sv_usepvn_flags		Perl_sv_usepvn_flags
#define sv_vcatpvfn		Perl_sv_vcatpvfn
#define sv_vsetpvfn		Perl_sv_vsetpvfn
#define str_to_version		Perl_str_to_version
#define swash_init		Perl_swash_init
#define swash_fetch		Perl_swash_fetch
#define taint_env		Perl_taint_env
#define taint_proper		Perl_taint_proper
#define to_utf8_case		Perl_to_utf8_case
#define to_utf8_lower		Perl_to_utf8_lower
#define to_utf8_upper		Perl_to_utf8_upper
#define to_utf8_title		Perl_to_utf8_title
#define to_utf8_fold		Perl_to_utf8_fold
#if defined(UNLINK_ALL_VERSIONS)
#define unlnk			Perl_unlnk
#endif
#define unpack_str		Perl_unpack_str
#define unpackstring		Perl_unpackstring
#define unsharepvn		Perl_unsharepvn
#ifdef PERL_CORE
#define unshare_hek		Perl_unshare_hek
#endif
#ifdef PERL_MAD
#ifdef PERL_CORE
#define utilize			Perl_utilize
#endif
#else
#ifdef PERL_CORE
#define utilize			Perl_utilize
#endif
#endif
#define utf16_to_utf8		Perl_utf16_to_utf8
#define utf16_to_utf8_reversed	Perl_utf16_to_utf8_reversed
#define utf8_length		Perl_utf8_length
#define utf8_distance		Perl_utf8_distance
#define utf8_hop		Perl_utf8_hop
#define utf8_to_bytes		Perl_utf8_to_bytes
#define bytes_from_utf8		Perl_bytes_from_utf8
#define bytes_to_utf8		Perl_bytes_to_utf8
#define utf8_to_uvchr		Perl_utf8_to_uvchr
#define utf8_to_uvuni		Perl_utf8_to_uvuni
#ifdef EBCDIC
#define utf8n_to_uvchr		Perl_utf8n_to_uvchr
#else
#endif
#define utf8n_to_uvuni		Perl_utf8n_to_uvuni
#ifdef EBCDIC
#define uvchr_to_utf8		Perl_uvchr_to_utf8
#else
#endif
#define uvchr_to_utf8_flags	Perl_uvchr_to_utf8_flags
#define uvuni_to_utf8_flags	Perl_uvuni_to_utf8_flags
#define pv_uni_display		Perl_pv_uni_display
#define sv_uni_display		Perl_sv_uni_display
#if defined(PERL_CORE) || defined(PERL_EXT)
#define vivify_defelem		Perl_vivify_defelem
#endif
#ifdef PERL_CORE
#define vivify_ref		Perl_vivify_ref
#define wait4pid		Perl_wait4pid
#define parse_unicode_opts	Perl_parse_unicode_opts
#endif
#define seed			Perl_seed
#ifdef PERL_CORE
#define get_hash_seed		Perl_get_hash_seed
#define report_evil_fh		Perl_report_evil_fh
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define report_uninit		Perl_report_uninit
#endif
#define warn			Perl_warn
#define vwarn			Perl_vwarn
#define warner			Perl_warner
#define vwarner			Perl_vwarner
#ifdef PERL_CORE
#define watch			Perl_watch
#endif
#define whichsig		Perl_whichsig
#ifdef PERL_CORE
#define write_to_stderr		Perl_write_to_stderr
#define yyerror			Perl_yyerror
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define yylex			Perl_yylex
#endif
#ifdef PERL_CORE
#define yyparse			Perl_yyparse
#define parser_free		Perl_parser_free
#define yywarn			Perl_yywarn
#endif
#if defined(MYMALLOC)
#define dump_mstats		Perl_dump_mstats
#define get_mstats		Perl_get_mstats
#endif
#define safesysmalloc		Perl_safesysmalloc
#define safesyscalloc		Perl_safesyscalloc
#define safesysrealloc		Perl_safesysrealloc
#define safesysfree		Perl_safesysfree
#if defined(PERL_GLOBAL_STRUCT)
#define GetVars			Perl_GetVars
#define init_global_struct	Perl_init_global_struct
#define free_global_struct	Perl_free_global_struct
#endif
#define runops_standard		Perl_runops_standard
#define runops_debug		Perl_runops_debug
#define sv_catpvf_mg		Perl_sv_catpvf_mg
#define sv_vcatpvf_mg		Perl_sv_vcatpvf_mg
#define sv_catpv_mg		Perl_sv_catpv_mg
#define sv_setpvf_mg		Perl_sv_setpvf_mg
#define sv_vsetpvf_mg		Perl_sv_vsetpvf_mg
#define sv_setiv_mg		Perl_sv_setiv_mg
#define sv_setpviv_mg		Perl_sv_setpviv_mg
#define sv_setuv_mg		Perl_sv_setuv_mg
#define sv_setnv_mg		Perl_sv_setnv_mg
#define sv_setpv_mg		Perl_sv_setpv_mg
#define sv_setpvn_mg		Perl_sv_setpvn_mg
#define sv_setsv_mg		Perl_sv_setsv_mg
#define get_vtbl		Perl_get_vtbl
#define pv_display		Perl_pv_display
#define pv_escape		Perl_pv_escape
#define pv_pretty		Perl_pv_pretty
#define dump_indent		Perl_dump_indent
#define dump_vindent		Perl_dump_vindent
#define do_gv_dump		Perl_do_gv_dump
#define do_gvgv_dump		Perl_do_gvgv_dump
#define do_hv_dump		Perl_do_hv_dump
#define do_magic_dump		Perl_do_magic_dump
#define do_op_dump		Perl_do_op_dump
#define do_pmop_dump		Perl_do_pmop_dump
#define do_sv_dump		Perl_do_sv_dump
#define magic_dump		Perl_magic_dump
#define reginitcolors		Perl_reginitcolors
#define sv_utf8_downgrade	Perl_sv_utf8_downgrade
#define sv_utf8_encode		Perl_sv_utf8_encode
#define sv_utf8_decode		Perl_sv_utf8_decode
#define sv_force_normal_flags	Perl_sv_force_normal_flags
#define tmps_grow		Perl_tmps_grow
#define sv_rvweaken		Perl_sv_rvweaken
#ifdef PERL_CORE
#define magic_killbackrefs	Perl_magic_killbackrefs
#endif
#define newANONATTRSUB		Perl_newANONATTRSUB
#define newATTRSUB		Perl_newATTRSUB
#ifdef PERL_MAD
#define newMYSUB		Perl_newMYSUB
#else
#define newMYSUB		Perl_newMYSUB
#endif
#ifdef PERL_CORE
#define my_attrs		Perl_my_attrs
#define boot_core_xsutils	Perl_boot_core_xsutils
#endif
#if defined(USE_ITHREADS)
#define cx_dup			Perl_cx_dup
#define si_dup			Perl_si_dup
#define ss_dup			Perl_ss_dup
#define any_dup			Perl_any_dup
#define he_dup			Perl_he_dup
#define hek_dup			Perl_hek_dup
#define re_dup			Perl_re_dup
#define fp_dup			Perl_fp_dup
#define dirp_dup		Perl_dirp_dup
#define gp_dup			Perl_gp_dup
#define mg_dup			Perl_mg_dup
#define sv_dup			Perl_sv_dup
#define rvpv_dup		Perl_rvpv_dup
#define parser_dup		Perl_parser_dup
#endif
#define ptr_table_new		Perl_ptr_table_new
#define ptr_table_fetch		Perl_ptr_table_fetch
#define ptr_table_store		Perl_ptr_table_store
#define ptr_table_split		Perl_ptr_table_split
#define ptr_table_clear		Perl_ptr_table_clear
#define ptr_table_free		Perl_ptr_table_free
#if defined(USE_ITHREADS)
#  if defined(HAVE_INTERP_INTERN)
#define sys_intern_dup		Perl_sys_intern_dup
#  endif
#endif
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_clear	Perl_sys_intern_clear
#define sys_intern_init		Perl_sys_intern_init
#endif
#define custom_op_name		Perl_custom_op_name
#define custom_op_desc		Perl_custom_op_desc
#define sv_nosharing		Perl_sv_nosharing
#define sv_destroyable		Perl_sv_destroyable
#ifdef NO_MATHOMS
#else
#define sv_nounlocking		Perl_sv_nounlocking
#endif
#define nothreadhook		Perl_nothreadhook
#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define do_trans_simple		S_do_trans_simple
#define do_trans_count		S_do_trans_count
#define do_trans_complex	S_do_trans_complex
#define do_trans_simple_utf8	S_do_trans_simple_utf8
#define do_trans_count_utf8	S_do_trans_count_utf8
#define do_trans_complex_utf8	S_do_trans_complex_utf8
#endif
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define gv_init_sv		S_gv_init_sv
#define gv_get_super_pkg	S_gv_get_super_pkg
#define require_tie_mod		S_require_tie_mod
#endif
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define hsplit			S_hsplit
#define hfreeentries		S_hfreeentries
#define new_he			S_new_he
#define save_hek_flags		S_save_hek_flags
#define hv_magic_check		S_hv_magic_check
#define unshare_hek_or_pvn	S_unshare_hek_or_pvn
#define share_hek_flags		S_share_hek_flags
#define hv_notallowed		S_hv_notallowed
#define hv_auxinit		S_hv_auxinit
#define hv_delete_common	S_hv_delete_common
#define clear_placeholders	S_clear_placeholders
#define refcounted_he_value	S_refcounted_he_value
#endif
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define save_magic		S_save_magic
#define magic_methpack		S_magic_methpack
#define magic_methcall		S_magic_methcall
#define restore_magic		S_restore_magic
#define unwind_handler_stack	S_unwind_handler_stack
#endif
#endif
#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define ck_anoncode		Perl_ck_anoncode
#define ck_bitop		Perl_ck_bitop
#define ck_concat		Perl_ck_concat
#define ck_defined		Perl_ck_defined
#define ck_delete		Perl_ck_delete
#define ck_die			Perl_ck_die
#define ck_eof			Perl_ck_eof
#define ck_eval			Perl_ck_eval
#define ck_exec			Perl_ck_exec
#define ck_exists		Perl_ck_exists
#define ck_exit			Perl_ck_exit
#define ck_ftst			Perl_ck_ftst
#define ck_fun			Perl_ck_fun
#define ck_glob			Perl_ck_glob
#define ck_grep			Perl_ck_grep
#define ck_index		Perl_ck_index
#define ck_join			Perl_ck_join
#define ck_lengthconst		Perl_ck_lengthconst
#define ck_lfun			Perl_ck_lfun
#define ck_listiob		Perl_ck_listiob
#define ck_match		Perl_ck_match
#define ck_method		Perl_ck_method
#define ck_null			Perl_ck_null
#define ck_open			Perl_ck_open
#define ck_readline		Perl_ck_readline
#define ck_repeat		Perl_ck_repeat
#define ck_require		Perl_ck_require
#define ck_retarget		Perl_ck_retarget
#define ck_return		Perl_ck_return
#define ck_rfun			Perl_ck_rfun
#define ck_rvconst		Perl_ck_rvconst
#define ck_sassign		Perl_ck_sassign
#define ck_select		Perl_ck_select
#define ck_shift		Perl_ck_shift
#define ck_sort			Perl_ck_sort
#define ck_spair		Perl_ck_spair
#define ck_split		Perl_ck_split
#define ck_subr			Perl_ck_subr
#define ck_substr		Perl_ck_substr
#define ck_svconst		Perl_ck_svconst
#define ck_trunc		Perl_ck_trunc
#define ck_unpack		Perl_ck_unpack
#define is_handle_constructor	S_is_handle_constructor
#define is_list_assignment	S_is_list_assignment
#endif
#  ifdef USE_ITHREADS
#  else
#  endif
#ifdef PERL_CORE
#define find_and_forget_pmops	S_find_and_forget_pmops
#define cop_free		S_cop_free
#define modkids			S_modkids
#define scalarboolean		S_scalarboolean
#define newDEFSVOP		S_newDEFSVOP
#define new_logop		S_new_logop
#define simplify_sort		S_simplify_sort
#define gv_ename		S_gv_ename
#define scalar_mod_type		S_scalar_mod_type
#define my_kid			S_my_kid
#define dup_attrlist		S_dup_attrlist
#define apply_attrs		S_apply_attrs
#define apply_attrs_my		S_apply_attrs_my
#define bad_type		S_bad_type
#define no_bareword_allowed	S_no_bareword_allowed
#define no_fh_allowed		S_no_fh_allowed
#define too_few_arguments	S_too_few_arguments
#define too_many_arguments	S_too_many_arguments
#define looks_like_bool		S_looks_like_bool
#define newGIVWHENOP		S_newGIVWHENOP
#define ref_array_or_hash	S_ref_array_or_hash
#define process_special_blocks	S_process_special_blocks
#endif
#endif
#if defined(PL_OP_SLAB_ALLOC)
#define Slab_Alloc		Perl_Slab_Alloc
#define Slab_Free		Perl_Slab_Free
#  if defined(PERL_DEBUG_READONLY_OPS)
#    if defined(PERL_IN_OP_C)
#ifdef PERL_CORE
#define Slab_to_rw		S_Slab_to_rw
#endif
#    endif
#  endif
#endif
#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define find_beginning		S_find_beginning
#define forbid_setid		S_forbid_setid
#define incpush			S_incpush
#define init_interp		S_init_interp
#define init_ids		S_init_ids
#define init_main_stash		S_init_main_stash
#define init_perllib		S_init_perllib
#define init_postdump_symbols	S_init_postdump_symbols
#define init_predump_symbols	S_init_predump_symbols
#define my_exit_jump		S_my_exit_jump
#define nuke_stacks		S_nuke_stacks
#define open_script		S_open_script
#define usage			S_usage
#define validate_suid		S_validate_suid
#endif
#  if defined(IAMSUID)
#ifdef PERL_CORE
#define fd_on_nosuid_fs		S_fd_on_nosuid_fs
#endif
#  endif
#ifdef PERL_CORE
#define parse_body		S_parse_body
#define run_body		S_run_body
#define incpush_if_exists	S_incpush_if_exists
#endif
#endif
#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define refto			S_refto
#endif
#endif
#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
#endif
#if defined(PERL_IN_PP_PACK_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define unpack_rec		S_unpack_rec
#define pack_rec		S_pack_rec
#define mul128			S_mul128
#define measure_struct		S_measure_struct
#define next_symbol		S_next_symbol
#define is_an_int		S_is_an_int
#define div128			S_div128
#define group_end		S_group_end
#define get_num			S_get_num
#define need_utf8		S_need_utf8
#define first_symbol		S_first_symbol
#define sv_exp_grow		S_sv_exp_grow
#define bytes_to_uni		S_bytes_to_uni
#endif
#endif
#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define docatch			S_docatch
#define dofindlabel		S_dofindlabel
#define doparseform		S_doparseform
#define num_overflow		S_num_overflow
#define dopoptoeval		S_dopoptoeval
#define dopoptogiven		S_dopoptogiven
#define dopoptolabel		S_dopoptolabel
#define dopoptoloop		S_dopoptoloop
#define dopoptosub_at		S_dopoptosub_at
#define dopoptowhen		S_dopoptowhen
#define save_lines		S_save_lines
#define doeval			S_doeval
#define check_type_and_open	S_check_type_and_open
#endif
#ifndef PERL_DISABLE_PMC
#ifdef PERL_CORE
#define doopen_pm		S_doopen_pm
#endif
#endif
#ifdef PERL_CORE
#define path_is_absolute	S_path_is_absolute
#define run_user_filter		S_run_user_filter
#define make_matcher		S_make_matcher
#define matcher_matches_sv	S_matcher_matches_sv
#define destroy_matcher		S_destroy_matcher
#define do_smartmatch		S_do_smartmatch
#endif
#endif
#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define do_oddball		S_do_oddball
#define method_common		S_method_common
#endif
#endif
#if defined(PERL_IN_PP_SORT_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define sv_ncmp			S_sv_ncmp
#define sv_i_ncmp		S_sv_i_ncmp
#define amagic_ncmp		S_amagic_ncmp
#define amagic_i_ncmp		S_amagic_i_ncmp
#define amagic_cmp		S_amagic_cmp
#define amagic_cmp_locale	S_amagic_cmp_locale
#define sortcv			S_sortcv
#define sortcv_xsub		S_sortcv_xsub
#define sortcv_stacked		S_sortcv_stacked
#define qsortsvu		S_qsortsvu
#endif
#endif
#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define doform			S_doform
#endif
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#ifdef PERL_CORE
#define dooneliner		S_dooneliner
#endif
#  endif
#ifdef PERL_CORE
#define space_join_names_mortal	S_space_join_names_mortal
#endif
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg			S_reg
#define reganode		S_reganode
#define regatom			S_regatom
#define regbranch		S_regbranch
#define reguni			S_reguni
#define regclass		S_regclass
#define regcurly		S_regcurly
#define reg_node		S_reg_node
#define reg_recode		S_reg_recode
#define regpiece		S_regpiece
#define reg_namedseq		S_reg_namedseq
#define reginsert		S_reginsert
#define regtail			S_regtail
#define reg_scan_name		S_reg_scan_name
#define join_exact		S_join_exact
#define regwhite		S_regwhite
#define nextchar		S_nextchar
#define reg_skipcomment		S_reg_skipcomment
#define scan_commit		S_scan_commit
#define cl_anything		S_cl_anything
#define cl_is_anything		S_cl_is_anything
#define cl_init			S_cl_init
#define cl_init_zero		S_cl_init_zero
#define cl_and			S_cl_and
#define cl_or			S_cl_or
#define study_chunk		S_study_chunk
#define add_data		S_add_data
#endif
#ifdef PERL_CORE
#define re_croak2		S_re_croak2
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regpposixcc		S_regpposixcc
#define checkposixcc		S_checkposixcc
#define make_trie		S_make_trie
#define make_trie_failtable	S_make_trie_failtable
#endif
#  ifdef DEBUGGING
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regdump_extflags	S_regdump_extflags
#define dumpuntil		S_dumpuntil
#define put_byte		S_put_byte
#define dump_trie		S_dump_trie
#define dump_trie_interim_list	S_dump_trie_interim_list
#define dump_trie_interim_table	S_dump_trie_interim_table
#define regtail_study		S_regtail_study
#endif
#  endif
#endif
#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regmatch		S_regmatch
#define regrepeat		S_regrepeat
#define regtry			S_regtry
#define reginclass		S_reginclass
#define regcppush		S_regcppush
#define regcppop		S_regcppop
#define reghop3			S_reghop3
#endif
#ifdef XXX_dmq
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reghop4			S_reghop4
#endif
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reghopmaybe3		S_reghopmaybe3
#define find_byclass		S_find_byclass
#define swap_match_buff		S_swap_match_buff
#define to_utf8_substr		S_to_utf8_substr
#define to_byte_substr		S_to_byte_substr
#define reg_check_named_buff_matched	S_reg_check_named_buff_matched
#endif
#  ifdef DEBUGGING
#if defined(PERL_CORE) || defined(PERL_EXT)
#define dump_exec_pos		S_dump_exec_pos
#define debug_start_match	S_debug_start_match
#endif
#  endif
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define deb_curcv		S_deb_curcv
#define debprof			S_debprof
#define sequence		S_sequence
#define sequence_tail		S_sequence_tail
#define sequence_num		S_sequence_num
#define pm_description		S_pm_description
#endif
#endif
#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define save_scalar_at		S_save_scalar_at
#endif
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_DECL_PROT)
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#endif
#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define uiv_2buf		S_uiv_2buf
#define sv_unglob		S_sv_unglob
#define not_a_number		S_not_a_number
#define visit			S_visit
#define sv_del_backref		S_sv_del_backref
#define varname			S_varname
#endif
#  ifdef DEBUGGING
#ifdef PERL_CORE
#define del_sv			S_del_sv
#endif
#  endif
#  if !defined(NV_PRESERVES_UV)
#ifdef PERL_CORE
#define sv_2iuv_non_preserve	S_sv_2iuv_non_preserve
#endif
#  endif
#ifdef PERL_CORE
#define expect_number		S_expect_number
#endif
#ifdef PERL_CORE
#define sv_pos_u2b_forwards	S_sv_pos_u2b_forwards
#define sv_pos_u2b_midway	S_sv_pos_u2b_midway
#define sv_pos_u2b_cached	S_sv_pos_u2b_cached
#define utf8_mg_pos_cache_update	S_utf8_mg_pos_cache_update
#define sv_pos_b2u_midway	S_sv_pos_b2u_midway
#define F0convert		S_F0convert
#endif
#  if defined(PERL_OLD_COPY_ON_WRITE)
#ifdef PERL_CORE
#define sv_release_COW		S_sv_release_COW
#endif
#  endif
#ifdef PERL_CORE
#define more_sv			S_more_sv
#define more_bodies		S_more_bodies
#define sv_2iuv_common		S_sv_2iuv_common
#define glob_assign_glob	S_glob_assign_glob
#define glob_assign_ref		S_glob_assign_ref
#define ptr_table_find		S_ptr_table_find
#endif
#endif
#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define check_uni		S_check_uni
#define force_next		S_force_next
#define force_version		S_force_version
#define force_word		S_force_word
#define tokeq			S_tokeq
#define readpipe_override	S_readpipe_override
#define scan_const		S_scan_const
#define scan_formline		S_scan_formline
#define scan_heredoc		S_scan_heredoc
#define scan_ident		S_scan_ident
#define scan_inputsymbol	S_scan_inputsymbol
#define scan_pat		S_scan_pat
#define scan_str		S_scan_str
#define scan_subst		S_scan_subst
#define scan_trans		S_scan_trans
#define scan_word		S_scan_word
#define update_debugger_info	S_update_debugger_info
#define skipspace		S_skipspace
#define swallow_bom		S_swallow_bom
#define checkcomma		S_checkcomma
#define feature_is_enabled	S_feature_is_enabled
#define force_ident		S_force_ident
#define incline			S_incline
#define intuit_method		S_intuit_method
#define intuit_more		S_intuit_more
#define lop			S_lop
#define missingterm		S_missingterm
#define no_op			S_no_op
#define sublex_done		S_sublex_done
#define sublex_push		S_sublex_push
#define sublex_start		S_sublex_start
#define filter_gets		S_filter_gets
#define find_in_my_stash	S_find_in_my_stash
#define tokenize_use		S_tokenize_use
#endif
#ifdef PERL_CORE
#define ao			S_ao
#endif
#  if defined(PERL_CR_FILTER)
#ifdef PERL_CORE
#define cr_textfilter		S_cr_textfilter
#define strip_return		S_strip_return
#endif
#  endif
#  if defined(DEBUGGING)
#ifdef PERL_CORE
#define tokereport		S_tokereport
#define printbuf		S_printbuf
#endif
#  endif
#endif
#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define isa_lookup		S_isa_lookup
#endif
#endif
#if defined(PERL_IN_LOCALE_C) || defined(PERL_DECL_PROT)
#if defined(USE_LOCALE_NUMERIC) || defined(USE_LOCALE_COLLATE)
#ifdef PERL_CORE
#define stdize_locale		S_stdize_locale
#endif
#endif
#endif
#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define closest_cop		S_closest_cop
#define mess_alloc		S_mess_alloc
#define vdie_croak_common	S_vdie_croak_common
#define vdie_common		S_vdie_common
#define write_no_mem		S_write_no_mem
#endif
#endif
#if defined(PERL_IN_NUMERIC_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define mulexp10		S_mulexp10
#endif
#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define is_utf8_char_slow	S_is_utf8_char_slow
#define is_utf8_common		S_is_utf8_common
#define swash_get		S_swash_get
#endif
#endif
#define sv_setsv_flags		Perl_sv_setsv_flags
#define sv_catpvn_flags		Perl_sv_catpvn_flags
#define sv_catsv_flags		Perl_sv_catsv_flags
#define sv_utf8_upgrade_flags	Perl_sv_utf8_upgrade_flags
#define sv_pvn_force_flags	Perl_sv_pvn_force_flags
#define sv_copypv		Perl_sv_copypv
#define my_atof2		Perl_my_atof2
#define my_socketpair		Perl_my_socketpair
#define my_dirfd		Perl_my_dirfd
#ifdef PERL_OLD_COPY_ON_WRITE
#if defined(PERL_CORE) || defined(PERL_EXT)
#define sv_setsv_cow		Perl_sv_setsv_cow
#endif
#endif
#if defined(USE_PERLIO) && !defined(USE_SFIO)
#define PerlIO_close		Perl_PerlIO_close
#define PerlIO_fill		Perl_PerlIO_fill
#define PerlIO_fileno		Perl_PerlIO_fileno
#define PerlIO_eof		Perl_PerlIO_eof
#define PerlIO_error		Perl_PerlIO_error
#define PerlIO_flush		Perl_PerlIO_flush
#define PerlIO_clearerr		Perl_PerlIO_clearerr
#define PerlIO_set_cnt		Perl_PerlIO_set_cnt
#define PerlIO_set_ptrcnt	Perl_PerlIO_set_ptrcnt
#define PerlIO_setlinebuf	Perl_PerlIO_setlinebuf
#define PerlIO_read		Perl_PerlIO_read
#define PerlIO_write		Perl_PerlIO_write
#define PerlIO_unread		Perl_PerlIO_unread
#define PerlIO_tell		Perl_PerlIO_tell
#define PerlIO_seek		Perl_PerlIO_seek
#define PerlIO_get_base		Perl_PerlIO_get_base
#define PerlIO_get_ptr		Perl_PerlIO_get_ptr
#define PerlIO_get_bufsiz	Perl_PerlIO_get_bufsiz
#define PerlIO_get_cnt		Perl_PerlIO_get_cnt
#define PerlIO_stdin		Perl_PerlIO_stdin
#define PerlIO_stdout		Perl_PerlIO_stdout
#define PerlIO_stderr		Perl_PerlIO_stderr
#endif /* PERLIO_LAYERS */
#ifdef PERL_CORE
#define deb_stack_all		Perl_deb_stack_all
#endif
#ifdef PERL_IN_DEB_C
#ifdef PERL_CORE
#define deb_stack_n		S_deb_stack_n
#endif
#endif
#ifdef PERL_CORE
#define pad_new			Perl_pad_new
#define pad_undef		Perl_pad_undef
#define pad_add_name		Perl_pad_add_name
#define pad_add_anon		Perl_pad_add_anon
#define pad_check_dup		Perl_pad_check_dup
#endif
#ifdef DEBUGGING
#ifdef PERL_CORE
#define pad_setsv		Perl_pad_setsv
#endif
#endif
#ifdef PERL_CORE
#define pad_block_start		Perl_pad_block_start
#define pad_tidy		Perl_pad_tidy
#define do_dump_pad		Perl_do_dump_pad
#define pad_fixup_inner_anons	Perl_pad_fixup_inner_anons
#endif
#ifdef PERL_CORE
#define pad_push		Perl_pad_push
#define pad_compname_type	Perl_pad_compname_type
#endif
#if defined(PERL_IN_PAD_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define pad_findlex		S_pad_findlex
#endif
#  if defined(DEBUGGING)
#ifdef PERL_CORE
#define cv_dump			S_cv_dump
#endif
#  endif
#endif
#define find_runcv		Perl_find_runcv
#ifdef PERL_CORE
#define free_tied_hv_pool	Perl_free_tied_hv_pool
#endif
#if defined(DEBUGGING)
#ifdef PERL_CORE
#define get_debug_opts		Perl_get_debug_opts
#endif
#endif
#define save_set_svflags	Perl_save_set_svflags
#define hv_scalar		Perl_hv_scalar
#define hv_name_set		Perl_hv_name_set
#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#endif
#define hv_clear_placeholders	Perl_hv_clear_placeholders
#ifdef PERL_CORE
#define magic_scalarpack	Perl_magic_scalarpack
#endif
#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define find_hash_subscript	S_find_hash_subscript
#define find_array_subscript	S_find_array_subscript
#define find_uninit_var		S_find_uninit_var
#endif
#endif
#ifdef PERL_NEED_MY_HTOLE16
#ifdef PERL_CORE
#define my_htole16		Perl_my_htole16
#endif
#endif
#ifdef PERL_NEED_MY_LETOH16
#ifdef PERL_CORE
#define my_letoh16		Perl_my_letoh16
#endif
#endif
#ifdef PERL_NEED_MY_HTOBE16
#ifdef PERL_CORE
#define my_htobe16		Perl_my_htobe16
#endif
#endif
#ifdef PERL_NEED_MY_BETOH16
#ifdef PERL_CORE
#define my_betoh16		Perl_my_betoh16
#endif
#endif
#ifdef PERL_NEED_MY_HTOLE32
#ifdef PERL_CORE
#define my_htole32		Perl_my_htole32
#endif
#endif
#ifdef PERL_NEED_MY_LETOH32
#ifdef PERL_CORE
#define my_letoh32		Perl_my_letoh32
#endif
#endif
#ifdef PERL_NEED_MY_HTOBE32
#ifdef PERL_CORE
#define my_htobe32		Perl_my_htobe32
#endif
#endif
#ifdef PERL_NEED_MY_BETOH32
#ifdef PERL_CORE
#define my_betoh32		Perl_my_betoh32
#endif
#endif
#ifdef PERL_NEED_MY_HTOLE64
#ifdef PERL_CORE
#define my_htole64		Perl_my_htole64
#endif
#endif
#ifdef PERL_NEED_MY_LETOH64
#ifdef PERL_CORE
#define my_letoh64		Perl_my_letoh64
#endif
#endif
#ifdef PERL_NEED_MY_HTOBE64
#ifdef PERL_CORE
#define my_htobe64		Perl_my_htobe64
#endif
#endif
#ifdef PERL_NEED_MY_BETOH64
#ifdef PERL_CORE
#define my_betoh64		Perl_my_betoh64
#endif
#endif
#ifdef PERL_NEED_MY_HTOLES
#ifdef PERL_CORE
#define my_htoles		Perl_my_htoles
#endif
#endif
#ifdef PERL_NEED_MY_LETOHS
#ifdef PERL_CORE
#define my_letohs		Perl_my_letohs
#endif
#endif
#ifdef PERL_NEED_MY_HTOBES
#ifdef PERL_CORE
#define my_htobes		Perl_my_htobes
#endif
#endif
#ifdef PERL_NEED_MY_BETOHS
#ifdef PERL_CORE
#define my_betohs		Perl_my_betohs
#endif
#endif
#ifdef PERL_NEED_MY_HTOLEI
#ifdef PERL_CORE
#define my_htolei		Perl_my_htolei
#endif
#endif
#ifdef PERL_NEED_MY_LETOHI
#ifdef PERL_CORE
#define my_letohi		Perl_my_letohi
#endif
#endif
#ifdef PERL_NEED_MY_HTOBEI
#ifdef PERL_CORE
#define my_htobei		Perl_my_htobei
#endif
#endif
#ifdef PERL_NEED_MY_BETOHI
#ifdef PERL_CORE
#define my_betohi		Perl_my_betohi
#endif
#endif
#ifdef PERL_NEED_MY_HTOLEL
#ifdef PERL_CORE
#define my_htolel		Perl_my_htolel
#endif
#endif
#ifdef PERL_NEED_MY_LETOHL
#ifdef PERL_CORE
#define my_letohl		Perl_my_letohl
#endif
#endif
#ifdef PERL_NEED_MY_HTOBEL
#ifdef PERL_CORE
#define my_htobel		Perl_my_htobel
#endif
#endif
#ifdef PERL_NEED_MY_BETOHL
#ifdef PERL_CORE
#define my_betohl		Perl_my_betohl
#endif
#endif
#ifdef PERL_CORE
#define my_swabn		Perl_my_swabn
#endif
#define gv_fetchpvn_flags	Perl_gv_fetchpvn_flags
#define gv_fetchsv		Perl_gv_fetchsv
#ifdef PERL_CORE
#define is_gv_magical_sv	Perl_is_gv_magical_sv
#endif
#define stashpv_hvname_match	Perl_stashpv_hvname_match
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
#ifdef PERL_CORE
#define dump_sv_child		Perl_dump_sv_child
#endif
#endif
#ifdef PERL_DONT_CREATE_GVSV
#define gv_SVadd		Perl_gv_SVadd
#endif
#ifdef PERL_CORE
#define offer_nice_chunk	Perl_offer_nice_chunk
#endif
#ifndef SPRINTF_RETURNS_STRLEN
#endif
#ifdef PERL_CORE
#define my_clearenv		Perl_my_clearenv
#endif
#ifdef PERL_IMPLICIT_CONTEXT
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#else
#endif
#endif
#ifndef HAS_STRLCAT
#endif
#ifndef HAS_STRLCPY
#endif
#ifdef PERL_MAD
#ifdef PERL_CORE
#define pad_peg			Perl_pad_peg
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define xmldump_attr		S_xmldump_attr
#endif
#endif
#ifdef PERL_CORE
#define xmldump_indent		Perl_xmldump_indent
#define xmldump_vindent		Perl_xmldump_vindent
#define xmldump_all		Perl_xmldump_all
#define xmldump_packsubs	Perl_xmldump_packsubs
#define xmldump_sub		Perl_xmldump_sub
#define xmldump_form		Perl_xmldump_form
#define xmldump_eval		Perl_xmldump_eval
#define sv_catxmlsv		Perl_sv_catxmlsv
#define sv_catxmlpvn		Perl_sv_catxmlpvn
#define sv_xmlpeek		Perl_sv_xmlpeek
#define do_pmop_xmldump		Perl_do_pmop_xmldump
#define pmop_xmldump		Perl_pmop_xmldump
#define do_op_xmldump		Perl_do_op_xmldump
#define op_xmldump		Perl_op_xmldump
#endif
#ifdef PERL_CORE
#define newTOKEN		Perl_newTOKEN
#define token_free		Perl_token_free
#define token_getmad		Perl_token_getmad
#define op_getmad_weak		Perl_op_getmad_weak
#define op_getmad		Perl_op_getmad
#define prepend_madprops	Perl_prepend_madprops
#define append_madprops		Perl_append_madprops
#define addmad			Perl_addmad
#define newMADsv		Perl_newMADsv
#define newMADPROP		Perl_newMADPROP
#define mad_free		Perl_mad_free
#endif
#  if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define skipspace0		S_skipspace0
#define skipspace1		S_skipspace1
#define skipspace2		S_skipspace2
#define start_force		S_start_force
#define curmad			S_curmad
#endif
#  endif
#ifdef PERL_CORE
#define madlex			Perl_madlex
#define madparse		Perl_madparse
#endif
#endif
#if !defined(HAS_SIGNBIT)
#endif
#ifdef PERL_CORE
#define mro_meta_init		Perl_mro_meta_init
#endif
#if defined(USE_ITHREADS)
#ifdef PERL_CORE
#define mro_meta_dup		Perl_mro_meta_dup
#endif
#endif
#define mro_get_linear_isa	Perl_mro_get_linear_isa
#if defined(PERL_IN_MRO_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define mro_get_linear_isa_c3	S_mro_get_linear_isa_c3
#define mro_get_linear_isa_dfs	S_mro_get_linear_isa_dfs
#endif
#endif
#ifdef PERL_CORE
#define mro_isa_changed_in	Perl_mro_isa_changed_in
#endif
#define mro_method_changed_in	Perl_mro_method_changed_in
#ifdef PERL_CORE
#define boot_core_mro		Perl_boot_core_mro
#endif
#define ck_anoncode		Perl_ck_anoncode
#define ck_bitop		Perl_ck_bitop
#define ck_chdir		Perl_ck_chdir
#define ck_concat		Perl_ck_concat
#define ck_defined		Perl_ck_defined
#define ck_delete		Perl_ck_delete
#define ck_die			Perl_ck_die
#define ck_eof			Perl_ck_eof
#define ck_eval			Perl_ck_eval
#define ck_exec			Perl_ck_exec
#define ck_exists		Perl_ck_exists
#define ck_exit			Perl_ck_exit
#define ck_ftst			Perl_ck_ftst
#define ck_fun			Perl_ck_fun
#define ck_glob			Perl_ck_glob
#define ck_grep			Perl_ck_grep
#define ck_index		Perl_ck_index
#define ck_join			Perl_ck_join
#define ck_lengthconst		Perl_ck_lengthconst
#define ck_lfun			Perl_ck_lfun
#define ck_listiob		Perl_ck_listiob
#define ck_match		Perl_ck_match
#define ck_method		Perl_ck_method
#define ck_null			Perl_ck_null
#define ck_open			Perl_ck_open
#define ck_readline		Perl_ck_readline
#define ck_repeat		Perl_ck_repeat
#define ck_require		Perl_ck_require
#define ck_return		Perl_ck_return
#define ck_rfun			Perl_ck_rfun
#define ck_rvconst		Perl_ck_rvconst
#define ck_sassign		Perl_ck_sassign
#define ck_select		Perl_ck_select
#define ck_shift		Perl_ck_shift
#define ck_smartmatch		Perl_ck_smartmatch
#define ck_sort			Perl_ck_sort
#define ck_spair		Perl_ck_spair
#define ck_split		Perl_ck_split
#define ck_subr			Perl_ck_subr
#define ck_substr		Perl_ck_substr
#define ck_svconst		Perl_ck_svconst
#define ck_trunc		Perl_ck_trunc
#define ck_unpack		Perl_ck_unpack
#define pp_aassign		Perl_pp_aassign
#define pp_abs			Perl_pp_abs
#define pp_accept		Perl_pp_accept
#define pp_add			Perl_pp_add
#define pp_aelem		Perl_pp_aelem
#define pp_aelemfast		Perl_pp_aelemfast
#define pp_alarm		Perl_pp_alarm
#define pp_and			Perl_pp_and
#define pp_andassign		Perl_pp_andassign
#define pp_anoncode		Perl_pp_anoncode
#define pp_anonhash		Perl_pp_anonhash
#define pp_anonlist		Perl_pp_anonlist
#define pp_aslice		Perl_pp_aslice
#define pp_atan2		Perl_pp_atan2
#define pp_av2arylen		Perl_pp_av2arylen
#define pp_backtick		Perl_pp_backtick
#define pp_bind			Perl_pp_bind
#define pp_binmode		Perl_pp_binmode
#define pp_bit_and		Perl_pp_bit_and
#define pp_bit_or		Perl_pp_bit_or
#define pp_bit_xor		Perl_pp_bit_xor
#define pp_bless		Perl_pp_bless
#define pp_break		Perl_pp_break
#define pp_caller		Perl_pp_caller
#define pp_chdir		Perl_pp_chdir
#define pp_chmod		Perl_pp_chmod
#define pp_chomp		Perl_pp_chomp
#define pp_chop			Perl_pp_chop
#define pp_chown		Perl_pp_chown
#define pp_chr			Perl_pp_chr
#define pp_chroot		Perl_pp_chroot
#define pp_close		Perl_pp_close
#define pp_closedir		Perl_pp_closedir
#define pp_complement		Perl_pp_complement
#define pp_concat		Perl_pp_concat
#define pp_cond_expr		Perl_pp_cond_expr
#define pp_connect		Perl_pp_connect
#define pp_const		Perl_pp_const
#define pp_continue		Perl_pp_continue
#define pp_cos			Perl_pp_cos
#define pp_crypt		Perl_pp_crypt
#define pp_dbmclose		Perl_pp_dbmclose
#define pp_dbmopen		Perl_pp_dbmopen
#define pp_dbstate		Perl_pp_dbstate
#define pp_defined		Perl_pp_defined
#define pp_delete		Perl_pp_delete
#define pp_die			Perl_pp_die
#define pp_divide		Perl_pp_divide
#define pp_dofile		Perl_pp_dofile
#define pp_dor			Perl_pp_dor
#define pp_dorassign		Perl_pp_dorassign
#define pp_dump			Perl_pp_dump
#define pp_each			Perl_pp_each
#define pp_egrent		Perl_pp_egrent
#define pp_ehostent		Perl_pp_ehostent
#define pp_enetent		Perl_pp_enetent
#define pp_enter		Perl_pp_enter
#define pp_entereval		Perl_pp_entereval
#define pp_entergiven		Perl_pp_entergiven
#define pp_enteriter		Perl_pp_enteriter
#define pp_enterloop		Perl_pp_enterloop
#define pp_entersub		Perl_pp_entersub
#define pp_entertry		Perl_pp_entertry
#define pp_enterwhen		Perl_pp_enterwhen
#define pp_enterwrite		Perl_pp_enterwrite
#define pp_eof			Perl_pp_eof
#define pp_eprotoent		Perl_pp_eprotoent
#define pp_epwent		Perl_pp_epwent
#define pp_eq			Perl_pp_eq
#define pp_eservent		Perl_pp_eservent
#define pp_exec			Perl_pp_exec
#define pp_exists		Perl_pp_exists
#define pp_exit			Perl_pp_exit
#define pp_exp			Perl_pp_exp
#define pp_fcntl		Perl_pp_fcntl
#define pp_fileno		Perl_pp_fileno
#define pp_flip			Perl_pp_flip
#define pp_flock		Perl_pp_flock
#define pp_flop			Perl_pp_flop
#define pp_fork			Perl_pp_fork
#define pp_formline		Perl_pp_formline
#define pp_ftatime		Perl_pp_ftatime
#define pp_ftbinary		Perl_pp_ftbinary
#define pp_ftblk		Perl_pp_ftblk
#define pp_ftchr		Perl_pp_ftchr
#define pp_ftctime		Perl_pp_ftctime
#define pp_ftdir		Perl_pp_ftdir
#define pp_fteexec		Perl_pp_fteexec
#define pp_fteowned		Perl_pp_fteowned
#define pp_fteread		Perl_pp_fteread
#define pp_ftewrite		Perl_pp_ftewrite
#define pp_ftfile		Perl_pp_ftfile
#define pp_ftis			Perl_pp_ftis
#define pp_ftlink		Perl_pp_ftlink
#define pp_ftmtime		Perl_pp_ftmtime
#define pp_ftpipe		Perl_pp_ftpipe
#define pp_ftrexec		Perl_pp_ftrexec
#define pp_ftrowned		Perl_pp_ftrowned
#define pp_ftrread		Perl_pp_ftrread
#define pp_ftrwrite		Perl_pp_ftrwrite
#define pp_ftsgid		Perl_pp_ftsgid
#define pp_ftsize		Perl_pp_ftsize
#define pp_ftsock		Perl_pp_ftsock
#define pp_ftsuid		Perl_pp_ftsuid
#define pp_ftsvtx		Perl_pp_ftsvtx
#define pp_fttext		Perl_pp_fttext
#define pp_fttty		Perl_pp_fttty
#define pp_ftzero		Perl_pp_ftzero
#define pp_ge			Perl_pp_ge
#define pp_gelem		Perl_pp_gelem
#define pp_getc			Perl_pp_getc
#define pp_getlogin		Perl_pp_getlogin
#define pp_getpeername		Perl_pp_getpeername
#define pp_getpgrp		Perl_pp_getpgrp
#define pp_getppid		Perl_pp_getppid
#define pp_getpriority		Perl_pp_getpriority
#define pp_getsockname		Perl_pp_getsockname
#define pp_ggrent		Perl_pp_ggrent
#define pp_ggrgid		Perl_pp_ggrgid
#define pp_ggrnam		Perl_pp_ggrnam
#define pp_ghbyaddr		Perl_pp_ghbyaddr
#define pp_ghbyname		Perl_pp_ghbyname
#define pp_ghostent		Perl_pp_ghostent
#define pp_glob			Perl_pp_glob
#define pp_gmtime		Perl_pp_gmtime
#define pp_gnbyaddr		Perl_pp_gnbyaddr
#define pp_gnbyname		Perl_pp_gnbyname
#define pp_gnetent		Perl_pp_gnetent
#define pp_goto			Perl_pp_goto
#define pp_gpbyname		Perl_pp_gpbyname
#define pp_gpbynumber		Perl_pp_gpbynumber
#define pp_gprotoent		Perl_pp_gprotoent
#define pp_gpwent		Perl_pp_gpwent
#define pp_gpwnam		Perl_pp_gpwnam
#define pp_gpwuid		Perl_pp_gpwuid
#define pp_grepstart		Perl_pp_grepstart
#define pp_grepwhile		Perl_pp_grepwhile
#define pp_gsbyname		Perl_pp_gsbyname
#define pp_gsbyport		Perl_pp_gsbyport
#define pp_gservent		Perl_pp_gservent
#define pp_gsockopt		Perl_pp_gsockopt
#define pp_gt			Perl_pp_gt
#define pp_gv			Perl_pp_gv
#define pp_gvsv			Perl_pp_gvsv
#define pp_helem		Perl_pp_helem
#define pp_hex			Perl_pp_hex
#define pp_hslice		Perl_pp_hslice
#define pp_i_add		Perl_pp_i_add
#define pp_i_divide		Perl_pp_i_divide
#define pp_i_eq			Perl_pp_i_eq
#define pp_i_ge			Perl_pp_i_ge
#define pp_i_gt			Perl_pp_i_gt
#define pp_i_le			Perl_pp_i_le
#define pp_i_lt			Perl_pp_i_lt
#define pp_i_modulo		Perl_pp_i_modulo
#define pp_i_multiply		Perl_pp_i_multiply
#define pp_i_ncmp		Perl_pp_i_ncmp
#define pp_i_ne			Perl_pp_i_ne
#define pp_i_negate		Perl_pp_i_negate
#define pp_i_subtract		Perl_pp_i_subtract
#define pp_index		Perl_pp_index
#define pp_int			Perl_pp_int
#define pp_ioctl		Perl_pp_ioctl
#define pp_iter			Perl_pp_iter
#define pp_join			Perl_pp_join
#define pp_keys			Perl_pp_keys
#define pp_kill			Perl_pp_kill
#define pp_last			Perl_pp_last
#define pp_lc			Perl_pp_lc
#define pp_lcfirst		Perl_pp_lcfirst
#define pp_le			Perl_pp_le
#define pp_leave		Perl_pp_leave
#define pp_leaveeval		Perl_pp_leaveeval
#define pp_leavegiven		Perl_pp_leavegiven
#define pp_leaveloop		Perl_pp_leaveloop
#define pp_leavesub		Perl_pp_leavesub
#define pp_leavesublv		Perl_pp_leavesublv
#define pp_leavetry		Perl_pp_leavetry
#define pp_leavewhen		Perl_pp_leavewhen
#define pp_leavewrite		Perl_pp_leavewrite
#define pp_left_shift		Perl_pp_left_shift
#define pp_length		Perl_pp_length
#define pp_lineseq		Perl_pp_lineseq
#define pp_link			Perl_pp_link
#define pp_list			Perl_pp_list
#define pp_listen		Perl_pp_listen
#define pp_localtime		Perl_pp_localtime
#define pp_lock			Perl_pp_lock
#define pp_log			Perl_pp_log
#define pp_lslice		Perl_pp_lslice
#define pp_lstat		Perl_pp_lstat
#define pp_lt			Perl_pp_lt
#define pp_mapstart		Perl_pp_mapstart
#define pp_mapwhile		Perl_pp_mapwhile
#define pp_match		Perl_pp_match
#define pp_method		Perl_pp_method
#define pp_method_named		Perl_pp_method_named
#define pp_mkdir		Perl_pp_mkdir
#define pp_modulo		Perl_pp_modulo
#define pp_msgctl		Perl_pp_msgctl
#define pp_msgget		Perl_pp_msgget
#define pp_msgrcv		Perl_pp_msgrcv
#define pp_msgsnd		Perl_pp_msgsnd
#define pp_multiply		Perl_pp_multiply
#define pp_ncmp			Perl_pp_ncmp
#define pp_ne			Perl_pp_ne
#define pp_negate		Perl_pp_negate
#define pp_next			Perl_pp_next
#define pp_nextstate		Perl_pp_nextstate
#define pp_not			Perl_pp_not
#define pp_null			Perl_pp_null
#define pp_oct			Perl_pp_oct
#define pp_once			Perl_pp_once
#define pp_open			Perl_pp_open
#define pp_open_dir		Perl_pp_open_dir
#define pp_or			Perl_pp_or
#define pp_orassign		Perl_pp_orassign
#define pp_ord			Perl_pp_ord
#define pp_pack			Perl_pp_pack
#define pp_padany		Perl_pp_padany
#define pp_padav		Perl_pp_padav
#define pp_padhv		Perl_pp_padhv
#define pp_padsv		Perl_pp_padsv
#define pp_pipe_op		Perl_pp_pipe_op
#define pp_pop			Perl_pp_pop
#define pp_pos			Perl_pp_pos
#define pp_postdec		Perl_pp_postdec
#define pp_postinc		Perl_pp_postinc
#define pp_pow			Perl_pp_pow
#define pp_predec		Perl_pp_predec
#define pp_preinc		Perl_pp_preinc
#define pp_print		Perl_pp_print
#define pp_prototype		Perl_pp_prototype
#define pp_prtf			Perl_pp_prtf
#define pp_push			Perl_pp_push
#define pp_pushmark		Perl_pp_pushmark
#define pp_pushre		Perl_pp_pushre
#define pp_qr			Perl_pp_qr
#define pp_quotemeta		Perl_pp_quotemeta
#define pp_rand			Perl_pp_rand
#define pp_range		Perl_pp_range
#define pp_rcatline		Perl_pp_rcatline
#define pp_read			Perl_pp_read
#define pp_readdir		Perl_pp_readdir
#define pp_readline		Perl_pp_readline
#define pp_readlink		Perl_pp_readlink
#define pp_recv			Perl_pp_recv
#define pp_redo			Perl_pp_redo
#define pp_ref			Perl_pp_ref
#define pp_refgen		Perl_pp_refgen
#define pp_regcmaybe		Perl_pp_regcmaybe
#define pp_regcomp		Perl_pp_regcomp
#define pp_regcreset		Perl_pp_regcreset
#define pp_rename		Perl_pp_rename
#define pp_repeat		Perl_pp_repeat
#define pp_require		Perl_pp_require
#define pp_reset		Perl_pp_reset
#define pp_return		Perl_pp_return
#define pp_reverse		Perl_pp_reverse
#define pp_rewinddir		Perl_pp_rewinddir
#define pp_right_shift		Perl_pp_right_shift
#define pp_rindex		Perl_pp_rindex
#define pp_rmdir		Perl_pp_rmdir
#define pp_rv2av		Perl_pp_rv2av
#define pp_rv2cv		Perl_pp_rv2cv
#define pp_rv2gv		Perl_pp_rv2gv
#define pp_rv2hv		Perl_pp_rv2hv
#define pp_rv2sv		Perl_pp_rv2sv
#define pp_sassign		Perl_pp_sassign
#define pp_say			Perl_pp_say
#define pp_scalar		Perl_pp_scalar
#define pp_schomp		Perl_pp_schomp
#define pp_schop		Perl_pp_schop
#define pp_scmp			Perl_pp_scmp
#define pp_scope		Perl_pp_scope
#define pp_seek			Perl_pp_seek
#define pp_seekdir		Perl_pp_seekdir
#define pp_select		Perl_pp_select
#define pp_semctl		Perl_pp_semctl
#define pp_semget		Perl_pp_semget
#define pp_semop		Perl_pp_semop
#define pp_send			Perl_pp_send
#define pp_seq			Perl_pp_seq
#define pp_setpgrp		Perl_pp_setpgrp
#define pp_setpriority		Perl_pp_setpriority
#define pp_setstate		Perl_pp_setstate
#define pp_sge			Perl_pp_sge
#define pp_sgrent		Perl_pp_sgrent
#define pp_sgt			Perl_pp_sgt
#define pp_shift		Perl_pp_shift
#define pp_shmctl		Perl_pp_shmctl
#define pp_shmget		Perl_pp_shmget
#define pp_shmread		Perl_pp_shmread
#define pp_shmwrite		Perl_pp_shmwrite
#define pp_shostent		Perl_pp_shostent
#define pp_shutdown		Perl_pp_shutdown
#define pp_sin			Perl_pp_sin
#define pp_sle			Perl_pp_sle
#define pp_sleep		Perl_pp_sleep
#define pp_slt			Perl_pp_slt
#define pp_smartmatch		Perl_pp_smartmatch
#define pp_sne			Perl_pp_sne
#define pp_snetent		Perl_pp_snetent
#define pp_socket		Perl_pp_socket
#define pp_sockpair		Perl_pp_sockpair
#define pp_sort			Perl_pp_sort
#define pp_splice		Perl_pp_splice
#define pp_split		Perl_pp_split
#define pp_sprintf		Perl_pp_sprintf
#define pp_sprotoent		Perl_pp_sprotoent
#define pp_spwent		Perl_pp_spwent
#define pp_sqrt			Perl_pp_sqrt
#define pp_srand		Perl_pp_srand
#define pp_srefgen		Perl_pp_srefgen
#define pp_sselect		Perl_pp_sselect
#define pp_sservent		Perl_pp_sservent
#define pp_ssockopt		Perl_pp_ssockopt
#define pp_stat			Perl_pp_stat
#define pp_stringify		Perl_pp_stringify
#define pp_stub			Perl_pp_stub
#define pp_study		Perl_pp_study
#define pp_subst		Perl_pp_subst
#define pp_substcont		Perl_pp_substcont
#define pp_substr		Perl_pp_substr
#define pp_subtract		Perl_pp_subtract
#define pp_symlink		Perl_pp_symlink
#define pp_syscall		Perl_pp_syscall
#define pp_sysopen		Perl_pp_sysopen
#define pp_sysread		Perl_pp_sysread
#define pp_sysseek		Perl_pp_sysseek
#define pp_system		Perl_pp_system
#define pp_syswrite		Perl_pp_syswrite
#define pp_tell			Perl_pp_tell
#define pp_telldir		Perl_pp_telldir
#define pp_tie			Perl_pp_tie
#define pp_tied			Perl_pp_tied
#define pp_time			Perl_pp_time
#define pp_tms			Perl_pp_tms
#define pp_trans		Perl_pp_trans
#define pp_truncate		Perl_pp_truncate
#define pp_uc			Perl_pp_uc
#define pp_ucfirst		Perl_pp_ucfirst
#define pp_umask		Perl_pp_umask
#define pp_undef		Perl_pp_undef
#define pp_unlink		Perl_pp_unlink
#define pp_unpack		Perl_pp_unpack
#define pp_unshift		Perl_pp_unshift
#define pp_unstack		Perl_pp_unstack
#define pp_untie		Perl_pp_untie
#define pp_utime		Perl_pp_utime
#define pp_values		Perl_pp_values
#define pp_vec			Perl_pp_vec
#define pp_wait			Perl_pp_wait
#define pp_waitpid		Perl_pp_waitpid
#define pp_wantarray		Perl_pp_wantarray
#define pp_warn			Perl_pp_warn
#define pp_xor			Perl_pp_xor

#else	/* PERL_IMPLICIT_CONTEXT */

#if defined(PERL_IMPLICIT_SYS)
#endif
#define doing_taint		Perl_doing_taint
#if defined(USE_ITHREADS)
#  if defined(PERL_IMPLICIT_SYS)
#  endif
#endif
#if defined(MYMALLOC)
#ifdef PERL_CORE
#define malloced_size		Perl_malloced_size
#endif
#endif
#define get_context		Perl_get_context
#define set_context		Perl_set_context
#define amagic_call(a,b,c,d)	Perl_amagic_call(aTHX_ a,b,c,d)
#define Gv_AMupdate(a)		Perl_Gv_AMupdate(aTHX_ a)
#define gv_handler(a,b)		Perl_gv_handler(aTHX_ a,b)
#ifdef PERL_CORE
#define append_elem(a,b,c)	Perl_append_elem(aTHX_ a,b,c)
#define append_list(a,b,c)	Perl_append_list(aTHX_ a,b,c)
#define apply(a,b,c)		Perl_apply(aTHX_ a,b,c)
#endif
#define apply_attrs_string(a,b,c,d)	Perl_apply_attrs_string(aTHX_ a,b,c,d)
#define av_clear(a)		Perl_av_clear(aTHX_ a)
#define av_delete(a,b,c)	Perl_av_delete(aTHX_ a,b,c)
#define av_exists(a,b)		Perl_av_exists(aTHX_ a,b)
#define av_extend(a,b)		Perl_av_extend(aTHX_ a,b)
#ifdef PERL_CORE
#define av_fake(a,b)		Perl_av_fake(aTHX_ a,b)
#endif
#define av_fetch(a,b,c)		Perl_av_fetch(aTHX_ a,b,c)
#define av_fill(a,b)		Perl_av_fill(aTHX_ a,b)
#define av_len(a)		Perl_av_len(aTHX_ a)
#define av_make(a,b)		Perl_av_make(aTHX_ a,b)
#define av_pop(a)		Perl_av_pop(aTHX_ a)
#define av_push(a,b)		Perl_av_push(aTHX_ a,b)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define av_reify(a)		Perl_av_reify(aTHX_ a)
#endif
#define av_shift(a)		Perl_av_shift(aTHX_ a)
#define av_store(a,b,c)		Perl_av_store(aTHX_ a,b,c)
#define av_undef(a)		Perl_av_undef(aTHX_ a)
#define av_unshift(a,b)		Perl_av_unshift(aTHX_ a,b)
#ifdef PERL_CORE
#define bind_match(a,b,c)	Perl_bind_match(aTHX_ a,b,c)
#define block_end(a,b)		Perl_block_end(aTHX_ a,b)
#endif
#define block_gimme()		Perl_block_gimme(aTHX)
#ifdef PERL_CORE
#define block_start(a)		Perl_block_start(aTHX_ a)
#define boot_core_UNIVERSAL()	Perl_boot_core_UNIVERSAL(aTHX)
#define boot_core_ActivePerl()	Perl_boot_core_ActivePerl(aTHX)
#define boot_core_PerlIO()	Perl_boot_core_PerlIO(aTHX)
#endif
#define call_list(a,b)		Perl_call_list(aTHX_ a,b)
#ifdef PERL_CORE
#define cando(a,b,c)		Perl_cando(aTHX_ a,b,c)
#endif
#define cast_ulong(a)		Perl_cast_ulong(aTHX_ a)
#define cast_i32(a)		Perl_cast_i32(aTHX_ a)
#define cast_iv(a)		Perl_cast_iv(aTHX_ a)
#define cast_uv(a)		Perl_cast_uv(aTHX_ a)
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#define my_chsize(a,b)		Perl_my_chsize(aTHX_ a,b)
#endif
#ifdef PERL_CORE
#define convert(a,b,c)		Perl_convert(aTHX_ a,b,c)
#define create_eval_scope(a)	Perl_create_eval_scope(aTHX_ a)
#endif
#define vcroak(a,b)		Perl_vcroak(aTHX_ a,b)
#if defined(PERL_IMPLICIT_CONTEXT)
#endif
#ifdef PERL_CORE
#define cv_ckproto(a,b,c)	Perl_cv_ckproto(aTHX_ a,b,c)
#define cv_ckproto_len(a,b,c,d)	Perl_cv_ckproto_len(aTHX_ a,b,c,d)
#define cv_clone(a)		Perl_cv_clone(aTHX_ a)
#endif
#define gv_const_sv(a)		Perl_gv_const_sv(aTHX_ a)
#define cv_const_sv(a)		Perl_cv_const_sv(aTHX_ a)
#ifdef PERL_CORE
#define op_const_sv(a,b)	Perl_op_const_sv(aTHX_ a,b)
#endif
#define cv_undef(a)		Perl_cv_undef(aTHX_ a)
#define cx_dump(a)		Perl_cx_dump(aTHX_ a)
#define filter_add(a,b)		Perl_filter_add(aTHX_ a,b)
#define filter_del(a)		Perl_filter_del(aTHX_ a)
#define filter_read(a,b,c)	Perl_filter_read(aTHX_ a,b,c)
#define get_op_descs()		Perl_get_op_descs(aTHX)
#define get_op_names()		Perl_get_op_names(aTHX)
#ifdef PERL_CORE
#define get_no_modify()		Perl_get_no_modify(aTHX)
#define get_opargs()		Perl_get_opargs(aTHX)
#endif
#define get_ppaddr()		Perl_get_ppaddr(aTHX)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define cxinc()			Perl_cxinc(aTHX)
#endif
#define vdeb(a,b)		Perl_vdeb(aTHX_ a,b)
#define debprofdump()		Perl_debprofdump(aTHX)
#define debop(a)		Perl_debop(aTHX_ a)
#define debstack()		Perl_debstack(aTHX)
#define debstackptrs()		Perl_debstackptrs(aTHX)
#define delimcpy(a,b,c,d,e,f)	Perl_delimcpy(aTHX_ a,b,c,d,e,f)
#ifdef PERL_CORE
#define delete_eval_scope()	Perl_delete_eval_scope(aTHX)
#define deprecate(a)		Perl_deprecate(aTHX_ a)
#define deprecate_old(a)	Perl_deprecate_old(aTHX_ a)
#endif
#ifdef PERL_CORE
#define vdie(a,b)		Perl_vdie(aTHX_ a,b)
#define die_where(a,b)		Perl_die_where(aTHX_ a,b)
#endif
#define dounwind(a)		Perl_dounwind(aTHX_ a)
#ifdef PERL_CORE
#define do_aexec5(a,b,c,d,e)	Perl_do_aexec5(aTHX_ a,b,c,d,e)
#endif
#define do_binmode(a,b,c)	Perl_do_binmode(aTHX_ a,b,c)
#ifdef PERL_CORE
#define do_chop(a,b)		Perl_do_chop(aTHX_ a,b)
#endif
#define do_close(a,b)		Perl_do_close(aTHX_ a,b)
#ifdef PERL_CORE
#define do_eof(a)		Perl_do_eof(aTHX_ a)
#endif
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#ifdef PERL_CORE
#endif
#else
#ifdef PERL_CORE
#define do_exec(a)		Perl_do_exec(aTHX_ a)
#endif
#endif
#if defined(WIN32) || defined(__SYMBIAN32__)
#define do_aspawn(a,b,c)	Perl_do_aspawn(aTHX_ a,b,c)
#define do_spawn(a)		Perl_do_spawn(aTHX_ a)
#define do_spawn_nowait(a)	Perl_do_spawn_nowait(aTHX_ a)
#endif
#if !defined(WIN32)
#ifdef PERL_CORE
#define do_exec3(a,b,c)		Perl_do_exec3(aTHX_ a,b,c)
#endif
#endif
#ifdef PERL_CORE
#define do_execfree()		Perl_do_execfree(aTHX)
#endif
#ifdef PERL_IN_DOIO_C
#ifdef PERL_CORE
#define exec_failed(a,b,c)	S_exec_failed(aTHX_ a,b,c)
#endif
#endif
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#ifdef PERL_CORE
#define do_ipcctl(a,b,c)	Perl_do_ipcctl(aTHX_ a,b,c)
#define do_ipcget(a,b,c)	Perl_do_ipcget(aTHX_ a,b,c)
#define do_msgrcv(a,b)		Perl_do_msgrcv(aTHX_ a,b)
#define do_msgsnd(a,b)		Perl_do_msgsnd(aTHX_ a,b)
#define do_semop(a,b)		Perl_do_semop(aTHX_ a,b)
#define do_shmio(a,b,c)		Perl_do_shmio(aTHX_ a,b,c)
#endif
#endif
#define do_join(a,b,c,d)	Perl_do_join(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#define do_kv()			Perl_do_kv(aTHX)
#endif
#define do_open9(a,b,c,d,e,f,g,h,i)	Perl_do_open9(aTHX_ a,b,c,d,e,f,g,h,i)
#define do_openn(a,b,c,d,e,f,g,h,i)	Perl_do_openn(aTHX_ a,b,c,d,e,f,g,h,i)
#ifdef PERL_CORE
#define do_print(a,b)		Perl_do_print(aTHX_ a,b)
#define do_readline()		Perl_do_readline(aTHX)
#define do_chomp(a)		Perl_do_chomp(aTHX_ a)
#define do_seek(a,b,c)		Perl_do_seek(aTHX_ a,b,c)
#endif
#define do_sprintf(a,b,c)	Perl_do_sprintf(aTHX_ a,b,c)
#ifdef PERL_CORE
#define do_sysseek(a,b,c)	Perl_do_sysseek(aTHX_ a,b,c)
#define do_tell(a)		Perl_do_tell(aTHX_ a)
#define do_trans(a)		Perl_do_trans(aTHX_ a)
#define do_vecget(a,b,c)	Perl_do_vecget(aTHX_ a,b,c)
#define do_vecset(a)		Perl_do_vecset(aTHX_ a)
#define do_vop(a,b,c,d)		Perl_do_vop(aTHX_ a,b,c,d)
#define dofile(a,b)		Perl_dofile(aTHX_ a,b)
#endif
#define dowantarray()		Perl_dowantarray(aTHX)
#define dump_all()		Perl_dump_all(aTHX)
#define dump_eval()		Perl_dump_eval(aTHX)
#if defined(DUMP_FDS)
#define dump_fds(a)		Perl_dump_fds(aTHX_ a)
#endif
#define dump_form(a)		Perl_dump_form(aTHX_ a)
#define gv_dump(a)		Perl_gv_dump(aTHX_ a)
#define op_dump(a)		Perl_op_dump(aTHX_ a)
#define pmop_dump(a)		Perl_pmop_dump(aTHX_ a)
#define dump_packsubs(a)	Perl_dump_packsubs(aTHX_ a)
#define dump_sub(a)		Perl_dump_sub(aTHX_ a)
#define fbm_compile(a,b)	Perl_fbm_compile(aTHX_ a,b)
#define fbm_instr(a,b,c,d)	Perl_fbm_instr(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#define find_script(a,b,c,d)	Perl_find_script(aTHX_ a,b,c,d)
#define force_list(a)		Perl_force_list(aTHX_ a)
#define fold_constants(a)	Perl_fold_constants(aTHX_ a)
#endif
#define vform(a,b)		Perl_vform(aTHX_ a,b)
#define free_tmps()		Perl_free_tmps(aTHX)
#ifdef PERL_CORE
#define gen_constant_list(a)	Perl_gen_constant_list(aTHX_ a)
#endif
#if !defined(HAS_GETENV_LEN)
#ifdef PERL_CORE
#define getenv_len(a,b)		Perl_getenv_len(aTHX_ a,b)
#endif
#endif
#ifdef PERL_CORE
#endif
#define gp_free(a)		Perl_gp_free(aTHX_ a)
#define gp_ref(a)		Perl_gp_ref(aTHX_ a)
#define gv_AVadd(a)		Perl_gv_AVadd(aTHX_ a)
#define gv_HVadd(a)		Perl_gv_HVadd(aTHX_ a)
#define gv_IOadd(a)		Perl_gv_IOadd(aTHX_ a)
#define gv_autoload4(a,b,c,d)	Perl_gv_autoload4(aTHX_ a,b,c,d)
#define gv_check(a)		Perl_gv_check(aTHX_ a)
#define gv_efullname(a,b)	Perl_gv_efullname(aTHX_ a,b)
#define gv_efullname4(a,b,c,d)	Perl_gv_efullname4(aTHX_ a,b,c,d)
#define gv_fetchfile(a)		Perl_gv_fetchfile(aTHX_ a)
#define gv_fetchfile_flags(a,b,c)	Perl_gv_fetchfile_flags(aTHX_ a,b,c)
#define gv_fetchmeth(a,b,c,d)	Perl_gv_fetchmeth(aTHX_ a,b,c,d)
#define gv_fetchmeth_autoload(a,b,c,d)	Perl_gv_fetchmeth_autoload(aTHX_ a,b,c,d)
#define gv_fetchmethod_autoload(a,b,c)	Perl_gv_fetchmethod_autoload(aTHX_ a,b,c)
#define gv_fetchpv(a,b,c)	Perl_gv_fetchpv(aTHX_ a,b,c)
#define gv_fullname(a,b)	Perl_gv_fullname(aTHX_ a,b)
#define gv_fullname4(a,b,c,d)	Perl_gv_fullname4(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#endif
#define gv_init(a,b,c,d,e)	Perl_gv_init(aTHX_ a,b,c,d,e)
#define gv_name_set(a,b,c,d)	Perl_gv_name_set(aTHX_ a,b,c,d)
#define gv_stashpv(a,b)		Perl_gv_stashpv(aTHX_ a,b)
#define gv_stashpvn(a,b,c)	Perl_gv_stashpvn(aTHX_ a,b,c)
#define gv_stashsv(a,b)		Perl_gv_stashsv(aTHX_ a,b)
#define hv_clear(a)		Perl_hv_clear(aTHX_ a)
#ifdef PERL_CORE
#endif
#define hv_delayfree_ent(a,b)	Perl_hv_delayfree_ent(aTHX_ a,b)
#define hv_common(a,b,c,d,e,f,g,h)	Perl_hv_common(aTHX_ a,b,c,d,e,f,g,h)
#define hv_common_key_len(a,b,c,d,e,f)	Perl_hv_common_key_len(aTHX_ a,b,c,d,e,f)
#define hv_free_ent(a,b)	Perl_hv_free_ent(aTHX_ a,b)
#define hv_iterinit(a)		Perl_hv_iterinit(aTHX_ a)
#define hv_iterkey(a,b)		Perl_hv_iterkey(aTHX_ a,b)
#define hv_iterkeysv(a)		Perl_hv_iterkeysv(aTHX_ a)
#define hv_iternextsv(a,b,c)	Perl_hv_iternextsv(aTHX_ a,b,c)
#define hv_iternext_flags(a,b)	Perl_hv_iternext_flags(aTHX_ a,b)
#define hv_iterval(a,b)		Perl_hv_iterval(aTHX_ a,b)
#define hv_ksplit(a,b)		Perl_hv_ksplit(aTHX_ a,b)
#if defined(PERL_CORE) || defined(PERL_EXT)
#endif
#ifdef PERL_CORE
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#endif
#define hv_undef(a)		Perl_hv_undef(aTHX_ a)
#define ibcmp(a,b,c)		Perl_ibcmp(aTHX_ a,b,c)
#define ibcmp_locale(a,b,c)	Perl_ibcmp_locale(aTHX_ a,b,c)
#define ibcmp_utf8(a,b,c,d,e,f,g,h)	Perl_ibcmp_utf8(aTHX_ a,b,c,d,e,f,g,h)
#ifdef PERL_CORE
#define ingroup(a,b)		Perl_ingroup(aTHX_ a,b)
#define init_argv_symbols(a,b)	Perl_init_argv_symbols(aTHX_ a,b)
#define init_debugger()		Perl_init_debugger(aTHX)
#endif
#define init_stacks()		Perl_init_stacks(aTHX)
#define init_tm(a)		Perl_init_tm(aTHX_ a)
#ifdef PERL_CORE
#define intro_my()		Perl_intro_my(aTHX)
#endif
#define instr(a,b)		Perl_instr(aTHX_ a,b)
#ifdef PERL_CORE
#define io_close(a,b)		Perl_io_close(aTHX_ a,b)
#define invert(a)		Perl_invert(aTHX_ a)
#define is_gv_magical(a,b,c)	Perl_is_gv_magical(aTHX_ a,b,c)
#endif
#define is_lvalue_sub()		Perl_is_lvalue_sub(aTHX)
#define to_uni_upper_lc(a)	Perl_to_uni_upper_lc(aTHX_ a)
#define to_uni_title_lc(a)	Perl_to_uni_title_lc(aTHX_ a)
#define to_uni_lower_lc(a)	Perl_to_uni_lower_lc(aTHX_ a)
#define is_uni_alnum(a)		Perl_is_uni_alnum(aTHX_ a)
#define is_uni_alnumc(a)	Perl_is_uni_alnumc(aTHX_ a)
#define is_uni_idfirst(a)	Perl_is_uni_idfirst(aTHX_ a)
#define is_uni_alpha(a)		Perl_is_uni_alpha(aTHX_ a)
#define is_uni_ascii(a)		Perl_is_uni_ascii(aTHX_ a)
#define is_uni_space(a)		Perl_is_uni_space(aTHX_ a)
#define is_uni_cntrl(a)		Perl_is_uni_cntrl(aTHX_ a)
#define is_uni_graph(a)		Perl_is_uni_graph(aTHX_ a)
#define is_uni_digit(a)		Perl_is_uni_digit(aTHX_ a)
#define is_uni_upper(a)		Perl_is_uni_upper(aTHX_ a)
#define is_uni_lower(a)		Perl_is_uni_lower(aTHX_ a)
#define is_uni_print(a)		Perl_is_uni_print(aTHX_ a)
#define is_uni_punct(a)		Perl_is_uni_punct(aTHX_ a)
#define is_uni_xdigit(a)	Perl_is_uni_xdigit(aTHX_ a)
#define to_uni_upper(a,b,c)	Perl_to_uni_upper(aTHX_ a,b,c)
#define to_uni_title(a,b,c)	Perl_to_uni_title(aTHX_ a,b,c)
#define to_uni_lower(a,b,c)	Perl_to_uni_lower(aTHX_ a,b,c)
#define to_uni_fold(a,b,c)	Perl_to_uni_fold(aTHX_ a,b,c)
#define is_uni_alnum_lc(a)	Perl_is_uni_alnum_lc(aTHX_ a)
#define is_uni_alnumc_lc(a)	Perl_is_uni_alnumc_lc(aTHX_ a)
#define is_uni_idfirst_lc(a)	Perl_is_uni_idfirst_lc(aTHX_ a)
#define is_uni_alpha_lc(a)	Perl_is_uni_alpha_lc(aTHX_ a)
#define is_uni_ascii_lc(a)	Perl_is_uni_ascii_lc(aTHX_ a)
#define is_uni_space_lc(a)	Perl_is_uni_space_lc(aTHX_ a)
#define is_uni_cntrl_lc(a)	Perl_is_uni_cntrl_lc(aTHX_ a)
#define is_uni_graph_lc(a)	Perl_is_uni_graph_lc(aTHX_ a)
#define is_uni_digit_lc(a)	Perl_is_uni_digit_lc(aTHX_ a)
#define is_uni_upper_lc(a)	Perl_is_uni_upper_lc(aTHX_ a)
#define is_uni_lower_lc(a)	Perl_is_uni_lower_lc(aTHX_ a)
#define is_uni_print_lc(a)	Perl_is_uni_print_lc(aTHX_ a)
#define is_uni_punct_lc(a)	Perl_is_uni_punct_lc(aTHX_ a)
#define is_uni_xdigit_lc(a)	Perl_is_uni_xdigit_lc(aTHX_ a)
#define is_utf8_char(a)		Perl_is_utf8_char(aTHX_ a)
#define is_utf8_string(a,b)	Perl_is_utf8_string(aTHX_ a,b)
#define is_utf8_string_loclen(a,b,c,d)	Perl_is_utf8_string_loclen(aTHX_ a,b,c,d)
#define is_utf8_alnum(a)	Perl_is_utf8_alnum(aTHX_ a)
#define is_utf8_alnumc(a)	Perl_is_utf8_alnumc(aTHX_ a)
#define is_utf8_idfirst(a)	Perl_is_utf8_idfirst(aTHX_ a)
#define is_utf8_idcont(a)	Perl_is_utf8_idcont(aTHX_ a)
#define is_utf8_alpha(a)	Perl_is_utf8_alpha(aTHX_ a)
#define is_utf8_ascii(a)	Perl_is_utf8_ascii(aTHX_ a)
#define is_utf8_space(a)	Perl_is_utf8_space(aTHX_ a)
#define is_utf8_cntrl(a)	Perl_is_utf8_cntrl(aTHX_ a)
#define is_utf8_digit(a)	Perl_is_utf8_digit(aTHX_ a)
#define is_utf8_graph(a)	Perl_is_utf8_graph(aTHX_ a)
#define is_utf8_upper(a)	Perl_is_utf8_upper(aTHX_ a)
#define is_utf8_lower(a)	Perl_is_utf8_lower(aTHX_ a)
#define is_utf8_print(a)	Perl_is_utf8_print(aTHX_ a)
#define is_utf8_punct(a)	Perl_is_utf8_punct(aTHX_ a)
#define is_utf8_xdigit(a)	Perl_is_utf8_xdigit(aTHX_ a)
#define is_utf8_mark(a)		Perl_is_utf8_mark(aTHX_ a)
#ifdef PERL_CORE
#define jmaybe(a)		Perl_jmaybe(aTHX_ a)
#define keyword(a,b,c)		Perl_keyword(aTHX_ a,b,c)
#endif
#define leave_scope(a)		Perl_leave_scope(aTHX_ a)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define lex_end()		Perl_lex_end(aTHX)
#endif
#ifdef PERL_CORE
#define lex_start(a,b,c)	Perl_lex_start(aTHX_ a,b,c)
#endif
#define op_null(a)		Perl_op_null(aTHX_ a)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define op_clear(a)		Perl_op_clear(aTHX_ a)
#endif
#define op_refcnt_lock()	Perl_op_refcnt_lock(aTHX)
#define op_refcnt_unlock()	Perl_op_refcnt_unlock(aTHX)
#ifdef PERL_CORE
#define linklist(a)		Perl_linklist(aTHX_ a)
#define list(a)			Perl_list(aTHX_ a)
#define listkids(a)		Perl_listkids(aTHX_ a)
#endif
#define vload_module(a,b,c,d)	Perl_vload_module(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#define localize(a,b)		Perl_localize(aTHX_ a,b)
#endif
#define looks_like_number(a)	Perl_looks_like_number(aTHX_ a)
#define grok_bin(a,b,c,d)	Perl_grok_bin(aTHX_ a,b,c,d)
#define grok_hex(a,b,c,d)	Perl_grok_hex(aTHX_ a,b,c,d)
#define grok_number(a,b,c)	Perl_grok_number(aTHX_ a,b,c)
#define grok_numeric_radix(a,b)	Perl_grok_numeric_radix(aTHX_ a,b)
#define grok_oct(a,b,c,d)	Perl_grok_oct(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#define magic_clearenv(a,b)	Perl_magic_clearenv(aTHX_ a,b)
#define magic_clear_all_env(a,b)	Perl_magic_clear_all_env(aTHX_ a,b)
#define magic_clearhint(a,b)	Perl_magic_clearhint(aTHX_ a,b)
#define magic_clearpack(a,b)	Perl_magic_clearpack(aTHX_ a,b)
#define magic_clearsig(a,b)	Perl_magic_clearsig(aTHX_ a,b)
#define magic_existspack(a,b)	Perl_magic_existspack(aTHX_ a,b)
#define magic_freeregexp(a,b)	Perl_magic_freeregexp(aTHX_ a,b)
#define magic_freeovrld(a,b)	Perl_magic_freeovrld(aTHX_ a,b)
#define magic_get(a,b)		Perl_magic_get(aTHX_ a,b)
#define magic_getarylen(a,b)	Perl_magic_getarylen(aTHX_ a,b)
#define magic_getdefelem(a,b)	Perl_magic_getdefelem(aTHX_ a,b)
#define magic_getnkeys(a,b)	Perl_magic_getnkeys(aTHX_ a,b)
#define magic_getpack(a,b)	Perl_magic_getpack(aTHX_ a,b)
#define magic_getpos(a,b)	Perl_magic_getpos(aTHX_ a,b)
#define magic_getsig(a,b)	Perl_magic_getsig(aTHX_ a,b)
#define magic_getsubstr(a,b)	Perl_magic_getsubstr(aTHX_ a,b)
#define magic_gettaint(a,b)	Perl_magic_gettaint(aTHX_ a,b)
#define magic_getuvar(a,b)	Perl_magic_getuvar(aTHX_ a,b)
#define magic_getvec(a,b)	Perl_magic_getvec(aTHX_ a,b)
#define magic_len(a,b)		Perl_magic_len(aTHX_ a,b)
#define magic_nextpack(a,b,c)	Perl_magic_nextpack(aTHX_ a,b,c)
#define magic_regdata_cnt(a,b)	Perl_magic_regdata_cnt(aTHX_ a,b)
#define magic_regdatum_get(a,b)	Perl_magic_regdatum_get(aTHX_ a,b)
#define magic_regdatum_set(a,b)	Perl_magic_regdatum_set(aTHX_ a,b)
#define magic_set(a,b)		Perl_magic_set(aTHX_ a,b)
#define magic_setamagic(a,b)	Perl_magic_setamagic(aTHX_ a,b)
#define magic_setarylen(a,b)	Perl_magic_setarylen(aTHX_ a,b)
#define magic_freearylen_p(a,b)	Perl_magic_freearylen_p(aTHX_ a,b)
#define magic_setbm(a,b)	Perl_magic_setbm(aTHX_ a,b)
#define magic_setdbline(a,b)	Perl_magic_setdbline(aTHX_ a,b)
#define magic_setdefelem(a,b)	Perl_magic_setdefelem(aTHX_ a,b)
#define magic_setenv(a,b)	Perl_magic_setenv(aTHX_ a,b)
#define magic_setfm(a,b)	Perl_magic_setfm(aTHX_ a,b)
#define magic_sethint(a,b)	Perl_magic_sethint(aTHX_ a,b)
#define magic_setisa(a,b)	Perl_magic_setisa(aTHX_ a,b)
#define magic_setglob(a,b)	Perl_magic_setglob(aTHX_ a,b)
#define magic_setmglob(a,b)	Perl_magic_setmglob(aTHX_ a,b)
#define magic_setnkeys(a,b)	Perl_magic_setnkeys(aTHX_ a,b)
#define magic_setpack(a,b)	Perl_magic_setpack(aTHX_ a,b)
#define magic_setpos(a,b)	Perl_magic_setpos(aTHX_ a,b)
#define magic_setregexp(a,b)	Perl_magic_setregexp(aTHX_ a,b)
#define magic_setsig(a,b)	Perl_magic_setsig(aTHX_ a,b)
#define magic_setsubstr(a,b)	Perl_magic_setsubstr(aTHX_ a,b)
#define magic_settaint(a,b)	Perl_magic_settaint(aTHX_ a,b)
#define magic_setuvar(a,b)	Perl_magic_setuvar(aTHX_ a,b)
#define magic_setvec(a,b)	Perl_magic_setvec(aTHX_ a,b)
#define magic_setutf8(a,b)	Perl_magic_setutf8(aTHX_ a,b)
#define magic_set_all_env(a,b)	Perl_magic_set_all_env(aTHX_ a,b)
#define magic_sizepack(a,b)	Perl_magic_sizepack(aTHX_ a,b)
#define magic_wipepack(a,b)	Perl_magic_wipepack(aTHX_ a,b)
#define magicname(a,b,c)	Perl_magicname(aTHX_ a,b,c)
#endif
#define markstack_grow()	Perl_markstack_grow(aTHX)
#if defined(USE_LOCALE_COLLATE)
#ifdef PERL_CORE
#define magic_setcollxfrm(a,b)	Perl_magic_setcollxfrm(aTHX_ a,b)
#define mem_collxfrm(a,b,c)	Perl_mem_collxfrm(aTHX_ a,b,c)
#endif
#endif
#define vmess(a,b)		Perl_vmess(aTHX_ a,b)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define qerror(a)		Perl_qerror(aTHX_ a)
#endif
#define sortsv(a,b,c)		Perl_sortsv(aTHX_ a,b,c)
#define sortsv_flags(a,b,c,d)	Perl_sortsv_flags(aTHX_ a,b,c,d)
#define mg_clear(a)		Perl_mg_clear(aTHX_ a)
#define mg_copy(a,b,c,d)	Perl_mg_copy(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#define mg_localize(a,b)	Perl_mg_localize(aTHX_ a,b)
#endif
#define mg_find(a,b)		Perl_mg_find(aTHX_ a,b)
#define mg_free(a)		Perl_mg_free(aTHX_ a)
#define mg_get(a)		Perl_mg_get(aTHX_ a)
#define mg_length(a)		Perl_mg_length(aTHX_ a)
#define mg_magical(a)		Perl_mg_magical(aTHX_ a)
#define mg_set(a)		Perl_mg_set(aTHX_ a)
#define mg_size(a)		Perl_mg_size(aTHX_ a)
#define mini_mktime(a)		Perl_mini_mktime(aTHX_ a)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define mod(a,b)		Perl_mod(aTHX_ a,b)
#endif
#ifdef PERL_CORE
#define mode_from_discipline(a)	Perl_mode_from_discipline(aTHX_ a)
#endif
#define moreswitches(a)		Perl_moreswitches(aTHX_ a)
#ifdef PERL_CORE
#define my(a)			Perl_my(aTHX_ a)
#endif
#define my_atof(a)		Perl_my_atof(aTHX_ a)
#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
#define my_bcopy		Perl_my_bcopy
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
#define my_bzero		Perl_my_bzero
#endif
#define my_exit(a)		Perl_my_exit(aTHX_ a)
#define my_failure_exit()	Perl_my_failure_exit(aTHX)
#define my_fflush_all()		Perl_my_fflush_all(aTHX)
#define my_fork			Perl_my_fork
#define atfork_lock		Perl_atfork_lock
#define atfork_unlock		Perl_atfork_unlock
#define my_lstat()		Perl_my_lstat(aTHX)
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
#define my_memcmp		Perl_my_memcmp
#endif
#if !defined(HAS_MEMSET)
#define my_memset		Perl_my_memset
#endif
#define my_pclose(a)		Perl_my_pclose(aTHX_ a)
#define my_popen(a,b)		Perl_my_popen(aTHX_ a,b)
#define my_popen_list(a,b,c)	Perl_my_popen_list(aTHX_ a,b,c)
#define my_setenv(a,b)		Perl_my_setenv(aTHX_ a,b)
#define my_stat()		Perl_my_stat(aTHX)
#define my_strftime(a,b,c,d,e,f,g,h,i,j)	Perl_my_strftime(aTHX_ a,b,c,d,e,f,g,h,i,j)
#if defined(MYSWAP)
#define my_swap(a)		Perl_my_swap(aTHX_ a)
#define my_htonl(a)		Perl_my_htonl(aTHX_ a)
#define my_ntohl(a)		Perl_my_ntohl(aTHX_ a)
#endif
#ifdef PERL_CORE
#define my_unexec()		Perl_my_unexec(aTHX)
#endif
#define newANONLIST(a)		Perl_newANONLIST(aTHX_ a)
#define newANONHASH(a)		Perl_newANONHASH(aTHX_ a)
#define newANONSUB(a,b,c)	Perl_newANONSUB(aTHX_ a,b,c)
#define newASSIGNOP(a,b,c,d)	Perl_newASSIGNOP(aTHX_ a,b,c,d)
#define newCONDOP(a,b,c,d)	Perl_newCONDOP(aTHX_ a,b,c,d)
#define newCONSTSUB(a,b,c)	Perl_newCONSTSUB(aTHX_ a,b,c)
#ifdef PERL_MAD
#define newFORM(a,b,c)		Perl_newFORM(aTHX_ a,b,c)
#else
#define newFORM(a,b,c)		Perl_newFORM(aTHX_ a,b,c)
#endif
#define newFOROP(a,b,c,d,e,f,g)	Perl_newFOROP(aTHX_ a,b,c,d,e,f,g)
#define newGIVENOP(a,b,c)	Perl_newGIVENOP(aTHX_ a,b,c)
#define newLOGOP(a,b,c,d)	Perl_newLOGOP(aTHX_ a,b,c,d)
#define newLOOPEX(a,b)		Perl_newLOOPEX(aTHX_ a,b)
#define newLOOPOP(a,b,c,d)	Perl_newLOOPOP(aTHX_ a,b,c,d)
#define newNULLLIST()		Perl_newNULLLIST(aTHX)
#define newOP(a,b)		Perl_newOP(aTHX_ a,b)
#define newPROG(a)		Perl_newPROG(aTHX_ a)
#define newRANGE(a,b,c)		Perl_newRANGE(aTHX_ a,b,c)
#define newSLICEOP(a,b,c)	Perl_newSLICEOP(aTHX_ a,b,c)
#define newSTATEOP(a,b,c)	Perl_newSTATEOP(aTHX_ a,b,c)
#define newSUB(a,b,c,d)		Perl_newSUB(aTHX_ a,b,c,d)
#define newXS_flags(a,b,c,d,e)	Perl_newXS_flags(aTHX_ a,b,c,d,e)
#define newXS(a,b,c)		Perl_newXS(aTHX_ a,b,c)
#define newAV()			Perl_newAV(aTHX)
#define newAVREF(a)		Perl_newAVREF(aTHX_ a)
#define newBINOP(a,b,c,d)	Perl_newBINOP(aTHX_ a,b,c,d)
#define newCVREF(a,b)		Perl_newCVREF(aTHX_ a,b)
#define newGVOP(a,b,c)		Perl_newGVOP(aTHX_ a,b,c)
#define newGVgen(a)		Perl_newGVgen(aTHX_ a)
#define newGVREF(a,b)		Perl_newGVREF(aTHX_ a,b)
#define newHVREF(a)		Perl_newHVREF(aTHX_ a)
#define newHV()			Perl_newHV(aTHX)
#define newHVhv(a)		Perl_newHVhv(aTHX_ a)
#define newIO()			Perl_newIO(aTHX)
#define newLISTOP(a,b,c,d)	Perl_newLISTOP(aTHX_ a,b,c,d)
#ifdef USE_ITHREADS
#define newPADOP(a,b,c)		Perl_newPADOP(aTHX_ a,b,c)
#endif
#define newPMOP(a,b)		Perl_newPMOP(aTHX_ a,b)
#define newPVOP(a,b,c)		Perl_newPVOP(aTHX_ a,b,c)
#define newRV(a)		Perl_newRV(aTHX_ a)
#define newRV_noinc(a)		Perl_newRV_noinc(aTHX_ a)
#define newSV(a)		Perl_newSV(aTHX_ a)
#define newSVREF(a)		Perl_newSVREF(aTHX_ a)
#define newSVOP(a,b,c)		Perl_newSVOP(aTHX_ a,b,c)
#define newSViv(a)		Perl_newSViv(aTHX_ a)
#define newSVuv(a)		Perl_newSVuv(aTHX_ a)
#define newSVnv(a)		Perl_newSVnv(aTHX_ a)
#define newSVpv(a,b)		Perl_newSVpv(aTHX_ a,b)
#define newSVpvn(a,b)		Perl_newSVpvn(aTHX_ a,b)
#define newSVhek(a)		Perl_newSVhek(aTHX_ a)
#define newSVpvn_share(a,b,c)	Perl_newSVpvn_share(aTHX_ a,b,c)
#define vnewSVpvf(a,b)		Perl_vnewSVpvf(aTHX_ a,b)
#define newSVrv(a,b)		Perl_newSVrv(aTHX_ a,b)
#define newSVsv(a)		Perl_newSVsv(aTHX_ a)
#define newSV_type(a)		Perl_newSV_type(aTHX_ a)
#define newUNOP(a,b,c)		Perl_newUNOP(aTHX_ a,b,c)
#define newWHENOP(a,b)		Perl_newWHENOP(aTHX_ a,b)
#define newWHILEOP(a,b,c,d,e,f,g,h)	Perl_newWHILEOP(aTHX_ a,b,c,d,e,f,g,h)
#define new_stackinfo(a,b)	Perl_new_stackinfo(aTHX_ a,b)
#define scan_vstring(a,b,c)	Perl_scan_vstring(aTHX_ a,b,c)
#define scan_version(a,b,c)	Perl_scan_version(aTHX_ a,b,c)
#define new_version(a)		Perl_new_version(aTHX_ a)
#define upg_version(a,b)	Perl_upg_version(aTHX_ a,b)
#define vverify(a)		Perl_vverify(aTHX_ a)
#define vnumify(a)		Perl_vnumify(aTHX_ a)
#define vnormal(a)		Perl_vnormal(aTHX_ a)
#define vstringify(a)		Perl_vstringify(aTHX_ a)
#define vcmp(a,b)		Perl_vcmp(aTHX_ a,b)
#ifdef PERL_CORE
#define nextargv(a)		Perl_nextargv(aTHX_ a)
#endif
#define ninstr(a,b,c,d)		Perl_ninstr(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#define oopsCV(a)		Perl_oopsCV(aTHX_ a)
#endif
#define op_free(a)		Perl_op_free(aTHX_ a)
#ifdef PERL_MAD
#ifdef PERL_CORE
#define package(a)		Perl_package(aTHX_ a)
#endif
#else
#ifdef PERL_CORE
#define package(a)		Perl_package(aTHX_ a)
#endif
#endif
#ifdef PERL_CORE
#define pad_alloc(a,b)		Perl_pad_alloc(aTHX_ a,b)
#define allocmy(a)		Perl_allocmy(aTHX_ a)
#define pad_findmy(a)		Perl_pad_findmy(aTHX_ a)
#endif
#define find_rundefsvoffset()	Perl_find_rundefsvoffset(aTHX)
#ifdef PERL_CORE
#define oopsAV(a)		Perl_oopsAV(aTHX_ a)
#define oopsHV(a)		Perl_oopsHV(aTHX_ a)
#define pad_leavemy()		Perl_pad_leavemy(aTHX)
#endif
#define pad_sv(a)		Perl_pad_sv(aTHX_ a)
#ifdef PERL_CORE
#define pad_free(a)		Perl_pad_free(aTHX_ a)
#define pad_reset()		Perl_pad_reset(aTHX)
#define pad_swipe(a,b)		Perl_pad_swipe(aTHX_ a,b)
#define peep(a)			Perl_peep(aTHX_ a)
#endif
#if defined(USE_REENTRANT_API)
#define reentrant_size()	Perl_reentrant_size(aTHX)
#define reentrant_init()	Perl_reentrant_init(aTHX)
#define reentrant_free()	Perl_reentrant_free(aTHX)
#endif
#define call_atexit(a,b)	Perl_call_atexit(aTHX_ a,b)
#define call_argv(a,b,c)	Perl_call_argv(aTHX_ a,b,c)
#define call_method(a,b)	Perl_call_method(aTHX_ a,b)
#define call_pv(a,b)		Perl_call_pv(aTHX_ a,b)
#define call_sv(a,b)		Perl_call_sv(aTHX_ a,b)
#define despatch_signals()	Perl_despatch_signals(aTHX)
#define doref(a,b,c)		Perl_doref(aTHX_ a,b,c)
#define eval_pv(a,b)		Perl_eval_pv(aTHX_ a,b)
#define eval_sv(a,b)		Perl_eval_sv(aTHX_ a,b)
#define get_sv(a,b)		Perl_get_sv(aTHX_ a,b)
#define get_av(a,b)		Perl_get_av(aTHX_ a,b)
#define get_hv(a,b)		Perl_get_hv(aTHX_ a,b)
#define get_cv(a,b)		Perl_get_cv(aTHX_ a,b)
#define get_cvn_flags(a,b,c)	Perl_get_cvn_flags(aTHX_ a,b,c)
#define init_i18nl10n(a)	Perl_init_i18nl10n(aTHX_ a)
#define init_i18nl14n(a)	Perl_init_i18nl14n(aTHX_ a)
#define new_collate(a)		Perl_new_collate(aTHX_ a)
#define new_ctype(a)		Perl_new_ctype(aTHX_ a)
#define new_numeric(a)		Perl_new_numeric(aTHX_ a)
#define set_numeric_local()	Perl_set_numeric_local(aTHX)
#define set_numeric_radix()	Perl_set_numeric_radix(aTHX)
#define set_numeric_standard()	Perl_set_numeric_standard(aTHX)
#define require_pv(a)		Perl_require_pv(aTHX_ a)
#define pack_cat(a,b,c,d,e,f,g)	Perl_pack_cat(aTHX_ a,b,c,d,e,f,g)
#define packlist(a,b,c,d,e)	Perl_packlist(aTHX_ a,b,c,d,e)
#ifdef PERL_USES_PL_PIDSTATUS
#ifdef PERL_CORE
#define pidgone(a,b)		Perl_pidgone(aTHX_ a,b)
#endif
#endif
#define pmflag(a,b)		Perl_pmflag(aTHX_ a,b)
#ifdef PERL_CORE
#define pmruntime(a,b,c)	Perl_pmruntime(aTHX_ a,b,c)
#define pmtrans(a,b,c)		Perl_pmtrans(aTHX_ a,b,c)
#endif
#define pop_scope()		Perl_pop_scope(aTHX)
#ifdef PERL_CORE
#define prepend_elem(a,b,c)	Perl_prepend_elem(aTHX_ a,b,c)
#endif
#define push_scope()		Perl_push_scope(aTHX)
#ifdef PERL_CORE
#define refkids(a,b)		Perl_refkids(aTHX_ a,b)
#endif
#define regdump(a)		Perl_regdump(aTHX_ a)
#define regdump(a)		Perl_regdump(aTHX_ a)
#define regclass_swash(a,b,c,d,e)	Perl_regclass_swash(aTHX_ a,b,c,d,e)
#define pregexec(a,b,c,d,e,f,g)	Perl_pregexec(aTHX_ a,b,c,d,e,f,g)
#define pregfree(a)		Perl_pregfree(aTHX_ a)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_temp_copy(a)	Perl_reg_temp_copy(aTHX_ a)
#endif
#define regfree_internal(a)	Perl_regfree_internal(aTHX_ a)
#define reg_stringify(a,b,c,d)	Perl_reg_stringify(aTHX_ a,b,c,d)
#if defined(USE_ITHREADS)
#define regdupe_internal(a,b)	Perl_regdupe_internal(aTHX_ a,b)
#endif
#define pregcomp(a,b)		Perl_pregcomp(aTHX_ a,b)
#define re_compile(a,b)		Perl_re_compile(aTHX_ a,b)
#define re_intuit_start(a,b,c,d,e,f)	Perl_re_intuit_start(aTHX_ a,b,c,d,e,f)
#define re_intuit_string(a)	Perl_re_intuit_string(aTHX_ a)
#define regexec_flags(a,b,c,d,e,f,g,h)	Perl_regexec_flags(aTHX_ a,b,c,d,e,f,g,h)
#define regnext(a)		Perl_regnext(aTHX_ a)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_named_buff(a,b,c,d)	Perl_reg_named_buff(aTHX_ a,b,c,d)
#define reg_named_buff_iter(a,b,c)	Perl_reg_named_buff_iter(aTHX_ a,b,c)
#endif
#define reg_named_buff_fetch(a,b,c)	Perl_reg_named_buff_fetch(aTHX_ a,b,c)
#define reg_named_buff_exists(a,b,c)	Perl_reg_named_buff_exists(aTHX_ a,b,c)
#define reg_named_buff_firstkey(a,b)	Perl_reg_named_buff_firstkey(aTHX_ a,b)
#define reg_named_buff_nextkey(a,b)	Perl_reg_named_buff_nextkey(aTHX_ a,b)
#define reg_named_buff_scalar(a,b)	Perl_reg_named_buff_scalar(aTHX_ a,b)
#define reg_named_buff_all(a,b)	Perl_reg_named_buff_all(aTHX_ a,b)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_numbered_buff_fetch(a,b,c)	Perl_reg_numbered_buff_fetch(aTHX_ a,b,c)
#define reg_numbered_buff_store(a,b,c)	Perl_reg_numbered_buff_store(aTHX_ a,b,c)
#define reg_numbered_buff_length(a,b,c)	Perl_reg_numbered_buff_length(aTHX_ a,b,c)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg_qr_package(a)	Perl_reg_qr_package(aTHX_ a)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regprop(a,b,c)		Perl_regprop(aTHX_ a,b,c)
#endif
#define repeatcpy(a,b,c,d)	Perl_repeatcpy(aTHX_ a,b,c,d)
#define rninstr(a,b,c,d)	Perl_rninstr(aTHX_ a,b,c,d)
#define rsignal(a,b)		Perl_rsignal(aTHX_ a,b)
#ifdef PERL_CORE
#define rsignal_restore(a,b)	Perl_rsignal_restore(aTHX_ a,b)
#define rsignal_save(a,b,c)	Perl_rsignal_save(aTHX_ a,b,c)
#endif
#define rsignal_state(a)	Perl_rsignal_state(aTHX_ a)
#ifdef PERL_CORE
#define rxres_free(a)		Perl_rxres_free(aTHX_ a)
#define rxres_restore(a,b)	Perl_rxres_restore(aTHX_ a,b)
#define rxres_save(a,b)		Perl_rxres_save(aTHX_ a,b)
#endif
#if !defined(HAS_RENAME)
#ifdef PERL_CORE
#define same_dirent(a,b)	Perl_same_dirent(aTHX_ a,b)
#endif
#endif
#define savepv(a)		Perl_savepv(aTHX_ a)
#define savepvn(a,b)		Perl_savepvn(aTHX_ a,b)
#define savesharedpv(a)		Perl_savesharedpv(aTHX_ a)
#define savesharedpvn(a,b)	Perl_savesharedpvn(aTHX_ a,b)
#define savesvpv(a)		Perl_savesvpv(aTHX_ a)
#define savestack_grow()	Perl_savestack_grow(aTHX)
#define savestack_grow_cnt(a)	Perl_savestack_grow_cnt(aTHX_ a)
#define save_aelem(a,b,c)	Perl_save_aelem(aTHX_ a,b,c)
#define save_alloc(a,b)		Perl_save_alloc(aTHX_ a,b)
#define save_aptr(a)		Perl_save_aptr(aTHX_ a)
#define save_ary(a)		Perl_save_ary(aTHX_ a)
#define save_bool(a)		Perl_save_bool(aTHX_ a)
#define save_clearsv(a)		Perl_save_clearsv(aTHX_ a)
#define save_delete(a,b,c)	Perl_save_delete(aTHX_ a,b,c)
#define save_destructor(a,b)	Perl_save_destructor(aTHX_ a,b)
#define save_destructor_x(a,b)	Perl_save_destructor_x(aTHX_ a,b)
#define save_freesv(a)		Perl_save_freesv(aTHX_ a)
#ifdef PERL_CORE
#define save_freeop(a)		Perl_save_freeop(aTHX_ a)
#endif
#define save_freepv(a)		Perl_save_freepv(aTHX_ a)
#define save_generic_svref(a)	Perl_save_generic_svref(aTHX_ a)
#define save_generic_pvref(a)	Perl_save_generic_pvref(aTHX_ a)
#define save_shared_pvref(a)	Perl_save_shared_pvref(aTHX_ a)
#define save_gp(a,b)		Perl_save_gp(aTHX_ a,b)
#define save_hash(a)		Perl_save_hash(aTHX_ a)
#define save_helem(a,b,c)	Perl_save_helem(aTHX_ a,b,c)
#define save_hptr(a)		Perl_save_hptr(aTHX_ a)
#define save_I16(a)		Perl_save_I16(aTHX_ a)
#define save_I32(a)		Perl_save_I32(aTHX_ a)
#define save_I8(a)		Perl_save_I8(aTHX_ a)
#define save_int(a)		Perl_save_int(aTHX_ a)
#define save_item(a)		Perl_save_item(aTHX_ a)
#define save_iv(a)		Perl_save_iv(aTHX_ a)
#define save_list(a,b)		Perl_save_list(aTHX_ a,b)
#define save_long(a)		Perl_save_long(aTHX_ a)
#define save_mortalizesv(a)	Perl_save_mortalizesv(aTHX_ a)
#define save_nogv(a)		Perl_save_nogv(aTHX_ a)
#ifdef PERL_CORE
#define save_op()		Perl_save_op(aTHX)
#endif
#define save_scalar(a)		Perl_save_scalar(aTHX_ a)
#define save_pptr(a)		Perl_save_pptr(aTHX_ a)
#define save_vptr(a)		Perl_save_vptr(aTHX_ a)
#define save_re_context()	Perl_save_re_context(aTHX)
#define save_padsv(a)		Perl_save_padsv(aTHX_ a)
#define save_sptr(a)		Perl_save_sptr(aTHX_ a)
#define save_svref(a)		Perl_save_svref(aTHX_ a)
#ifdef PERL_CORE
#define sawparens(a)		Perl_sawparens(aTHX_ a)
#define scalar(a)		Perl_scalar(aTHX_ a)
#define scalarkids(a)		Perl_scalarkids(aTHX_ a)
#define scalarseq(a)		Perl_scalarseq(aTHX_ a)
#define scalarvoid(a)		Perl_scalarvoid(aTHX_ a)
#endif
#define scan_bin(a,b,c)		Perl_scan_bin(aTHX_ a,b,c)
#define scan_hex(a,b,c)		Perl_scan_hex(aTHX_ a,b,c)
#define scan_num(a,b)		Perl_scan_num(aTHX_ a,b)
#define scan_oct(a,b,c)		Perl_scan_oct(aTHX_ a,b,c)
#ifdef PERL_CORE
#define scope(a)		Perl_scope(aTHX_ a)
#endif
#define screaminstr(a,b,c,d,e,f)	Perl_screaminstr(aTHX_ a,b,c,d,e,f)
#if !defined(VMS)
#ifdef PERL_CORE
#define setenv_getix(a)		Perl_setenv_getix(aTHX_ a)
#endif
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define setdefout(a)		Perl_setdefout(aTHX_ a)
#endif
#define share_hek(a,b,c)	Perl_share_hek(aTHX_ a,b,c)
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#ifdef PERL_CORE
#define sighandler		Perl_sighandler
#endif
#define csighandler		Perl_csighandler
#else
#ifdef PERL_CORE
#define sighandler		Perl_sighandler
#endif
#define csighandler		Perl_csighandler
#endif
#define stack_grow(a,b,c)	Perl_stack_grow(aTHX_ a,b,c)
#define start_subparse(a,b)	Perl_start_subparse(aTHX_ a,b)
#ifdef PERL_CORE
#define sub_crush_depth(a)	Perl_sub_crush_depth(aTHX_ a)
#endif
#define sv_2bool(a)		Perl_sv_2bool(aTHX_ a)
#define sv_2cv(a,b,c,d)		Perl_sv_2cv(aTHX_ a,b,c,d)
#define sv_2io(a)		Perl_sv_2io(aTHX_ a)
#ifdef PERL_IN_SV_C
#ifdef PERL_CORE
#define glob_2number(a)		S_glob_2number(aTHX_ a)
#define glob_2pv(a,b)		S_glob_2pv(aTHX_ a,b)
#endif
#endif
#define sv_2iv_flags(a,b)	Perl_sv_2iv_flags(aTHX_ a,b)
#define sv_2mortal(a)		Perl_sv_2mortal(aTHX_ a)
#define sv_2nv(a)		Perl_sv_2nv(aTHX_ a)
#ifdef PERL_CORE
#define sv_2num(a)		Perl_sv_2num(aTHX_ a)
#endif
#define sv_2pv_flags(a,b,c)	Perl_sv_2pv_flags(aTHX_ a,b,c)
#define sv_2pvutf8(a,b)		Perl_sv_2pvutf8(aTHX_ a,b)
#define sv_2pvbyte(a,b)		Perl_sv_2pvbyte(aTHX_ a,b)
#define sv_pvn_nomg(a,b)	Perl_sv_pvn_nomg(aTHX_ a,b)
#define sv_2uv_flags(a,b)	Perl_sv_2uv_flags(aTHX_ a,b)
#define sv_iv(a)		Perl_sv_iv(aTHX_ a)
#define sv_uv(a)		Perl_sv_uv(aTHX_ a)
#define sv_nv(a)		Perl_sv_nv(aTHX_ a)
#define sv_pvn(a,b)		Perl_sv_pvn(aTHX_ a,b)
#define sv_pvutf8n(a,b)		Perl_sv_pvutf8n(aTHX_ a,b)
#define sv_pvbyten(a,b)		Perl_sv_pvbyten(aTHX_ a,b)
#define sv_true(a)		Perl_sv_true(aTHX_ a)
#ifdef PERL_CORE
#define sv_add_arena(a,b,c)	Perl_sv_add_arena(aTHX_ a,b,c)
#endif
#define sv_backoff(a)		Perl_sv_backoff(aTHX_ a)
#define sv_bless(a,b)		Perl_sv_bless(aTHX_ a,b)
#define sv_vcatpvf(a,b,c)	Perl_sv_vcatpvf(aTHX_ a,b,c)
#define sv_catpv(a,b)		Perl_sv_catpv(aTHX_ a,b)
#define sv_chop(a,b)		Perl_sv_chop(aTHX_ a,b)
#ifdef PERL_CORE
#define sv_clean_all()		Perl_sv_clean_all(aTHX)
#define sv_clean_objs()		Perl_sv_clean_objs(aTHX)
#endif
#define sv_clear(a)		Perl_sv_clear(aTHX_ a)
#define sv_cmp(a,b)		Perl_sv_cmp(aTHX_ a,b)
#define sv_cmp_locale(a,b)	Perl_sv_cmp_locale(aTHX_ a,b)
#if defined(USE_LOCALE_COLLATE)
#define sv_collxfrm(a,b)	Perl_sv_collxfrm(aTHX_ a,b)
#endif
#define sv_compile_2op(a,b,c,d)	Perl_sv_compile_2op(aTHX_ a,b,c,d)
#define getcwd_sv(a)		Perl_getcwd_sv(aTHX_ a)
#define sv_dec(a)		Perl_sv_dec(aTHX_ a)
#define sv_dump(a)		Perl_sv_dump(aTHX_ a)
#define sv_derived_from(a,b)	Perl_sv_derived_from(aTHX_ a,b)
#define sv_does(a,b)		Perl_sv_does(aTHX_ a,b)
#define sv_eq(a,b)		Perl_sv_eq(aTHX_ a,b)
#define sv_free(a)		Perl_sv_free(aTHX_ a)
#ifdef PERL_CORE
#define sv_free_arenas()	Perl_sv_free_arenas(aTHX)
#endif
#define sv_gets(a,b,c)		Perl_sv_gets(aTHX_ a,b,c)
#define sv_grow(a,b)		Perl_sv_grow(aTHX_ a,b)
#define sv_inc(a)		Perl_sv_inc(aTHX_ a)
#define sv_insert(a,b,c,d,e)	Perl_sv_insert(aTHX_ a,b,c,d,e)
#define sv_isa(a,b)		Perl_sv_isa(aTHX_ a,b)
#define sv_isobject(a)		Perl_sv_isobject(aTHX_ a)
#define sv_len(a)		Perl_sv_len(aTHX_ a)
#define sv_len_utf8(a)		Perl_sv_len_utf8(aTHX_ a)
#define sv_magic(a,b,c,d,e)	Perl_sv_magic(aTHX_ a,b,c,d,e)
#define sv_magicext(a,b,c,d,e,f)	Perl_sv_magicext(aTHX_ a,b,c,d,e,f)
#define sv_mortalcopy(a)	Perl_sv_mortalcopy(aTHX_ a)
#define sv_newmortal()		Perl_sv_newmortal(aTHX)
#define sv_newref(a)		Perl_sv_newref(aTHX_ a)
#define sv_peek(a)		Perl_sv_peek(aTHX_ a)
#define sv_pos_u2b(a,b,c)	Perl_sv_pos_u2b(aTHX_ a,b,c)
#define sv_pos_b2u(a,b)		Perl_sv_pos_b2u(aTHX_ a,b)
#define sv_pvutf8n_force(a,b)	Perl_sv_pvutf8n_force(aTHX_ a,b)
#define sv_pvbyten_force(a,b)	Perl_sv_pvbyten_force(aTHX_ a,b)
#define sv_recode_to_utf8(a,b)	Perl_sv_recode_to_utf8(aTHX_ a,b)
#define sv_cat_decode(a,b,c,d,e,f)	Perl_sv_cat_decode(aTHX_ a,b,c,d,e,f)
#define sv_reftype(a,b)		Perl_sv_reftype(aTHX_ a,b)
#define sv_replace(a,b)		Perl_sv_replace(aTHX_ a,b)
#define sv_report_used()	Perl_sv_report_used(aTHX)
#define sv_reset(a,b)		Perl_sv_reset(aTHX_ a,b)
#define sv_vsetpvf(a,b,c)	Perl_sv_vsetpvf(aTHX_ a,b,c)
#define sv_setiv(a,b)		Perl_sv_setiv(aTHX_ a,b)
#define sv_setpviv(a,b)		Perl_sv_setpviv(aTHX_ a,b)
#define sv_setuv(a,b)		Perl_sv_setuv(aTHX_ a,b)
#define sv_setnv(a,b)		Perl_sv_setnv(aTHX_ a,b)
#define sv_setref_iv(a,b,c)	Perl_sv_setref_iv(aTHX_ a,b,c)
#define sv_setref_uv(a,b,c)	Perl_sv_setref_uv(aTHX_ a,b,c)
#define sv_setref_nv(a,b,c)	Perl_sv_setref_nv(aTHX_ a,b,c)
#define sv_setref_pv(a,b,c)	Perl_sv_setref_pv(aTHX_ a,b,c)
#define sv_setref_pvn(a,b,c,d)	Perl_sv_setref_pvn(aTHX_ a,b,c,d)
#define sv_setpv(a,b)		Perl_sv_setpv(aTHX_ a,b)
#define sv_setpvn(a,b,c)	Perl_sv_setpvn(aTHX_ a,b,c)
#define sv_tainted(a)		Perl_sv_tainted(aTHX_ a)
#define sv_unmagic(a,b)		Perl_sv_unmagic(aTHX_ a,b)
#define sv_unref_flags(a,b)	Perl_sv_unref_flags(aTHX_ a,b)
#define sv_untaint(a)		Perl_sv_untaint(aTHX_ a)
#define sv_upgrade(a,b)		Perl_sv_upgrade(aTHX_ a,b)
#define sv_usepvn_flags(a,b,c,d)	Perl_sv_usepvn_flags(aTHX_ a,b,c,d)
#define sv_vcatpvfn(a,b,c,d,e,f,g)	Perl_sv_vcatpvfn(aTHX_ a,b,c,d,e,f,g)
#define sv_vsetpvfn(a,b,c,d,e,f,g)	Perl_sv_vsetpvfn(aTHX_ a,b,c,d,e,f,g)
#define str_to_version(a)	Perl_str_to_version(aTHX_ a)
#define swash_init(a,b,c,d,e)	Perl_swash_init(aTHX_ a,b,c,d,e)
#define swash_fetch(a,b,c)	Perl_swash_fetch(aTHX_ a,b,c)
#define taint_env()		Perl_taint_env(aTHX)
#define taint_proper(a,b)	Perl_taint_proper(aTHX_ a,b)
#define to_utf8_case(a,b,c,d,e,f)	Perl_to_utf8_case(aTHX_ a,b,c,d,e,f)
#define to_utf8_lower(a,b,c)	Perl_to_utf8_lower(aTHX_ a,b,c)
#define to_utf8_upper(a,b,c)	Perl_to_utf8_upper(aTHX_ a,b,c)
#define to_utf8_title(a,b,c)	Perl_to_utf8_title(aTHX_ a,b,c)
#define to_utf8_fold(a,b,c)	Perl_to_utf8_fold(aTHX_ a,b,c)
#if defined(UNLINK_ALL_VERSIONS)
#define unlnk(a)		Perl_unlnk(aTHX_ a)
#endif
#define unpack_str(a,b,c,d,e,f,g,h)	Perl_unpack_str(aTHX_ a,b,c,d,e,f,g,h)
#define unpackstring(a,b,c,d,e)	Perl_unpackstring(aTHX_ a,b,c,d,e)
#define unsharepvn(a,b,c)	Perl_unsharepvn(aTHX_ a,b,c)
#ifdef PERL_CORE
#define unshare_hek(a)		Perl_unshare_hek(aTHX_ a)
#endif
#ifdef PERL_MAD
#ifdef PERL_CORE
#define utilize(a,b,c,d,e)	Perl_utilize(aTHX_ a,b,c,d,e)
#endif
#else
#ifdef PERL_CORE
#define utilize(a,b,c,d,e)	Perl_utilize(aTHX_ a,b,c,d,e)
#endif
#endif
#define utf16_to_utf8(a,b,c,d)	Perl_utf16_to_utf8(aTHX_ a,b,c,d)
#define utf16_to_utf8_reversed(a,b,c,d)	Perl_utf16_to_utf8_reversed(aTHX_ a,b,c,d)
#define utf8_length(a,b)	Perl_utf8_length(aTHX_ a,b)
#define utf8_distance(a,b)	Perl_utf8_distance(aTHX_ a,b)
#define utf8_hop(a,b)		Perl_utf8_hop(aTHX_ a,b)
#define utf8_to_bytes(a,b)	Perl_utf8_to_bytes(aTHX_ a,b)
#define bytes_from_utf8(a,b,c)	Perl_bytes_from_utf8(aTHX_ a,b,c)
#define bytes_to_utf8(a,b)	Perl_bytes_to_utf8(aTHX_ a,b)
#define utf8_to_uvchr(a,b)	Perl_utf8_to_uvchr(aTHX_ a,b)
#define utf8_to_uvuni(a,b)	Perl_utf8_to_uvuni(aTHX_ a,b)
#ifdef EBCDIC
#define utf8n_to_uvchr(a,b,c,d)	Perl_utf8n_to_uvchr(aTHX_ a,b,c,d)
#else
#endif
#define utf8n_to_uvuni(a,b,c,d)	Perl_utf8n_to_uvuni(aTHX_ a,b,c,d)
#ifdef EBCDIC
#define uvchr_to_utf8(a,b)	Perl_uvchr_to_utf8(aTHX_ a,b)
#else
#endif
#define uvchr_to_utf8_flags(a,b,c)	Perl_uvchr_to_utf8_flags(aTHX_ a,b,c)
#define uvuni_to_utf8_flags(a,b,c)	Perl_uvuni_to_utf8_flags(aTHX_ a,b,c)
#define pv_uni_display(a,b,c,d,e)	Perl_pv_uni_display(aTHX_ a,b,c,d,e)
#define sv_uni_display(a,b,c,d)	Perl_sv_uni_display(aTHX_ a,b,c,d)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define vivify_defelem(a)	Perl_vivify_defelem(aTHX_ a)
#endif
#ifdef PERL_CORE
#define vivify_ref(a,b)		Perl_vivify_ref(aTHX_ a,b)
#define wait4pid(a,b,c)		Perl_wait4pid(aTHX_ a,b,c)
#define parse_unicode_opts(a)	Perl_parse_unicode_opts(aTHX_ a)
#endif
#define seed()			Perl_seed(aTHX)
#ifdef PERL_CORE
#define get_hash_seed()		Perl_get_hash_seed(aTHX)
#define report_evil_fh(a,b,c)	Perl_report_evil_fh(aTHX_ a,b,c)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define report_uninit(a)	Perl_report_uninit(aTHX_ a)
#endif
#define vwarn(a,b)		Perl_vwarn(aTHX_ a,b)
#define vwarner(a,b,c)		Perl_vwarner(aTHX_ a,b,c)
#ifdef PERL_CORE
#define watch(a)		Perl_watch(aTHX_ a)
#endif
#define whichsig(a)		Perl_whichsig(aTHX_ a)
#ifdef PERL_CORE
#define write_to_stderr(a,b)	Perl_write_to_stderr(aTHX_ a,b)
#define yyerror(a)		Perl_yyerror(aTHX_ a)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define yylex()			Perl_yylex(aTHX)
#endif
#ifdef PERL_CORE
#define yyparse()		Perl_yyparse(aTHX)
#define parser_free(a)		Perl_parser_free(aTHX_ a)
#define yywarn(a)		Perl_yywarn(aTHX_ a)
#endif
#if defined(MYMALLOC)
#define dump_mstats(a)		Perl_dump_mstats(aTHX_ a)
#define get_mstats(a,b,c)	Perl_get_mstats(aTHX_ a,b,c)
#endif
#define safesysmalloc		Perl_safesysmalloc
#define safesyscalloc		Perl_safesyscalloc
#define safesysrealloc		Perl_safesysrealloc
#define safesysfree		Perl_safesysfree
#if defined(PERL_GLOBAL_STRUCT)
#define GetVars()		Perl_GetVars(aTHX)
#define init_global_struct()	Perl_init_global_struct(aTHX)
#define free_global_struct(a)	Perl_free_global_struct(aTHX_ a)
#endif
#define runops_standard()	Perl_runops_standard(aTHX)
#define runops_debug()		Perl_runops_debug(aTHX)
#define sv_vcatpvf_mg(a,b,c)	Perl_sv_vcatpvf_mg(aTHX_ a,b,c)
#define sv_catpv_mg(a,b)	Perl_sv_catpv_mg(aTHX_ a,b)
#define sv_vsetpvf_mg(a,b,c)	Perl_sv_vsetpvf_mg(aTHX_ a,b,c)
#define sv_setiv_mg(a,b)	Perl_sv_setiv_mg(aTHX_ a,b)
#define sv_setpviv_mg(a,b)	Perl_sv_setpviv_mg(aTHX_ a,b)
#define sv_setuv_mg(a,b)	Perl_sv_setuv_mg(aTHX_ a,b)
#define sv_setnv_mg(a,b)	Perl_sv_setnv_mg(aTHX_ a,b)
#define sv_setpv_mg(a,b)	Perl_sv_setpv_mg(aTHX_ a,b)
#define sv_setpvn_mg(a,b,c)	Perl_sv_setpvn_mg(aTHX_ a,b,c)
#define sv_setsv_mg(a,b)	Perl_sv_setsv_mg(aTHX_ a,b)
#define get_vtbl(a)		Perl_get_vtbl(aTHX_ a)
#define pv_display(a,b,c,d,e)	Perl_pv_display(aTHX_ a,b,c,d,e)
#define pv_escape(a,b,c,d,e,f)	Perl_pv_escape(aTHX_ a,b,c,d,e,f)
#define pv_pretty(a,b,c,d,e,f,g)	Perl_pv_pretty(aTHX_ a,b,c,d,e,f,g)
#define dump_vindent(a,b,c,d)	Perl_dump_vindent(aTHX_ a,b,c,d)
#define do_gv_dump(a,b,c,d)	Perl_do_gv_dump(aTHX_ a,b,c,d)
#define do_gvgv_dump(a,b,c,d)	Perl_do_gvgv_dump(aTHX_ a,b,c,d)
#define do_hv_dump(a,b,c,d)	Perl_do_hv_dump(aTHX_ a,b,c,d)
#define do_magic_dump(a,b,c,d,e,f,g)	Perl_do_magic_dump(aTHX_ a,b,c,d,e,f,g)
#define do_op_dump(a,b,c)	Perl_do_op_dump(aTHX_ a,b,c)
#define do_pmop_dump(a,b,c)	Perl_do_pmop_dump(aTHX_ a,b,c)
#define do_sv_dump(a,b,c,d,e,f,g)	Perl_do_sv_dump(aTHX_ a,b,c,d,e,f,g)
#define magic_dump(a)		Perl_magic_dump(aTHX_ a)
#define reginitcolors()		Perl_reginitcolors(aTHX)
#define sv_utf8_downgrade(a,b)	Perl_sv_utf8_downgrade(aTHX_ a,b)
#define sv_utf8_encode(a)	Perl_sv_utf8_encode(aTHX_ a)
#define sv_utf8_decode(a)	Perl_sv_utf8_decode(aTHX_ a)
#define sv_force_normal_flags(a,b)	Perl_sv_force_normal_flags(aTHX_ a,b)
#define tmps_grow(a)		Perl_tmps_grow(aTHX_ a)
#define sv_rvweaken(a)		Perl_sv_rvweaken(aTHX_ a)
#ifdef PERL_CORE
#define magic_killbackrefs(a,b)	Perl_magic_killbackrefs(aTHX_ a,b)
#endif
#define newANONATTRSUB(a,b,c,d)	Perl_newANONATTRSUB(aTHX_ a,b,c,d)
#define newATTRSUB(a,b,c,d,e)	Perl_newATTRSUB(aTHX_ a,b,c,d,e)
#ifdef PERL_MAD
#define newMYSUB(a,b,c,d,e)	Perl_newMYSUB(aTHX_ a,b,c,d,e)
#else
#define newMYSUB(a,b,c,d,e)	Perl_newMYSUB(aTHX_ a,b,c,d,e)
#endif
#ifdef PERL_CORE
#define my_attrs(a,b)		Perl_my_attrs(aTHX_ a,b)
#define boot_core_xsutils()	Perl_boot_core_xsutils(aTHX)
#endif
#if defined(USE_ITHREADS)
#define cx_dup(a,b,c,d)		Perl_cx_dup(aTHX_ a,b,c,d)
#define si_dup(a,b)		Perl_si_dup(aTHX_ a,b)
#define ss_dup(a,b)		Perl_ss_dup(aTHX_ a,b)
#define any_dup(a,b)		Perl_any_dup(aTHX_ a,b)
#define he_dup(a,b,c)		Perl_he_dup(aTHX_ a,b,c)
#define hek_dup(a,b)		Perl_hek_dup(aTHX_ a,b)
#define re_dup(a,b)		Perl_re_dup(aTHX_ a,b)
#define fp_dup(a,b,c)		Perl_fp_dup(aTHX_ a,b,c)
#define dirp_dup(a)		Perl_dirp_dup(aTHX_ a)
#define gp_dup(a,b)		Perl_gp_dup(aTHX_ a,b)
#define mg_dup(a,b)		Perl_mg_dup(aTHX_ a,b)
#define sv_dup(a,b)		Perl_sv_dup(aTHX_ a,b)
#define rvpv_dup(a,b,c)		Perl_rvpv_dup(aTHX_ a,b,c)
#define parser_dup(a,b)		Perl_parser_dup(aTHX_ a,b)
#endif
#define ptr_table_new()		Perl_ptr_table_new(aTHX)
#define ptr_table_fetch(a,b)	Perl_ptr_table_fetch(aTHX_ a,b)
#define ptr_table_store(a,b,c)	Perl_ptr_table_store(aTHX_ a,b,c)
#define ptr_table_split(a)	Perl_ptr_table_split(aTHX_ a)
#define ptr_table_clear(a)	Perl_ptr_table_clear(aTHX_ a)
#define ptr_table_free(a)	Perl_ptr_table_free(aTHX_ a)
#if defined(USE_ITHREADS)
#  if defined(HAVE_INTERP_INTERN)
#define sys_intern_dup(a,b)	Perl_sys_intern_dup(aTHX_ a,b)
#  endif
#endif
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_clear()	Perl_sys_intern_clear(aTHX)
#define sys_intern_init()	Perl_sys_intern_init(aTHX)
#endif
#define custom_op_name(a)	Perl_custom_op_name(aTHX_ a)
#define custom_op_desc(a)	Perl_custom_op_desc(aTHX_ a)
#define sv_nosharing(a)		Perl_sv_nosharing(aTHX_ a)
#define sv_destroyable(a)	Perl_sv_destroyable(aTHX_ a)
#ifdef NO_MATHOMS
#else
#define sv_nounlocking(a)	Perl_sv_nounlocking(aTHX_ a)
#endif
#define nothreadhook()		Perl_nothreadhook(aTHX)
#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define do_trans_simple(a)	S_do_trans_simple(aTHX_ a)
#define do_trans_count(a)	S_do_trans_count(aTHX_ a)
#define do_trans_complex(a)	S_do_trans_complex(aTHX_ a)
#define do_trans_simple_utf8(a)	S_do_trans_simple_utf8(aTHX_ a)
#define do_trans_count_utf8(a)	S_do_trans_count_utf8(aTHX_ a)
#define do_trans_complex_utf8(a)	S_do_trans_complex_utf8(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define gv_init_sv(a,b)		S_gv_init_sv(aTHX_ a,b)
#define gv_get_super_pkg(a,b)	S_gv_get_super_pkg(aTHX_ a,b)
#define require_tie_mod(a,b,c,d,e)	S_require_tie_mod(aTHX_ a,b,c,d,e)
#endif
#endif
#ifdef PERL_CORE
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define hsplit(a)		S_hsplit(aTHX_ a)
#define hfreeentries(a)		S_hfreeentries(aTHX_ a)
#define new_he()		S_new_he(aTHX)
#define save_hek_flags		S_save_hek_flags
#define hv_magic_check		S_hv_magic_check
#define unshare_hek_or_pvn(a,b,c,d)	S_unshare_hek_or_pvn(aTHX_ a,b,c,d)
#define share_hek_flags(a,b,c,d)	S_share_hek_flags(aTHX_ a,b,c,d)
#define hv_notallowed(a,b,c,d)	S_hv_notallowed(aTHX_ a,b,c,d)
#define hv_auxinit		S_hv_auxinit
#define hv_delete_common(a,b,c,d,e,f,g)	S_hv_delete_common(aTHX_ a,b,c,d,e,f,g)
#define clear_placeholders(a,b)	S_clear_placeholders(aTHX_ a,b)
#define refcounted_he_value(a)	S_refcounted_he_value(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define save_magic(a,b)		S_save_magic(aTHX_ a,b)
#define magic_methpack(a,b,c)	S_magic_methpack(aTHX_ a,b,c)
#define magic_methcall(a,b,c,d,e,f)	S_magic_methcall(aTHX_ a,b,c,d,e,f)
#define restore_magic(a)	S_restore_magic(aTHX_ a)
#define unwind_handler_stack(a)	S_unwind_handler_stack(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define ck_anoncode(a)		Perl_ck_anoncode(aTHX_ a)
#define ck_bitop(a)		Perl_ck_bitop(aTHX_ a)
#define ck_concat(a)		Perl_ck_concat(aTHX_ a)
#define ck_defined(a)		Perl_ck_defined(aTHX_ a)
#define ck_delete(a)		Perl_ck_delete(aTHX_ a)
#define ck_die(a)		Perl_ck_die(aTHX_ a)
#define ck_eof(a)		Perl_ck_eof(aTHX_ a)
#define ck_eval(a)		Perl_ck_eval(aTHX_ a)
#define ck_exec(a)		Perl_ck_exec(aTHX_ a)
#define ck_exists(a)		Perl_ck_exists(aTHX_ a)
#define ck_exit(a)		Perl_ck_exit(aTHX_ a)
#define ck_ftst(a)		Perl_ck_ftst(aTHX_ a)
#define ck_fun(a)		Perl_ck_fun(aTHX_ a)
#define ck_glob(a)		Perl_ck_glob(aTHX_ a)
#define ck_grep(a)		Perl_ck_grep(aTHX_ a)
#define ck_index(a)		Perl_ck_index(aTHX_ a)
#define ck_join(a)		Perl_ck_join(aTHX_ a)
#define ck_lengthconst(a)	Perl_ck_lengthconst(aTHX_ a)
#define ck_lfun(a)		Perl_ck_lfun(aTHX_ a)
#define ck_listiob(a)		Perl_ck_listiob(aTHX_ a)
#define ck_match(a)		Perl_ck_match(aTHX_ a)
#define ck_method(a)		Perl_ck_method(aTHX_ a)
#define ck_null(a)		Perl_ck_null(aTHX_ a)
#define ck_open(a)		Perl_ck_open(aTHX_ a)
#define ck_readline(a)		Perl_ck_readline(aTHX_ a)
#define ck_repeat(a)		Perl_ck_repeat(aTHX_ a)
#define ck_require(a)		Perl_ck_require(aTHX_ a)
#define ck_retarget(a)		Perl_ck_retarget(aTHX_ a)
#define ck_return(a)		Perl_ck_return(aTHX_ a)
#define ck_rfun(a)		Perl_ck_rfun(aTHX_ a)
#define ck_rvconst(a)		Perl_ck_rvconst(aTHX_ a)
#define ck_sassign(a)		Perl_ck_sassign(aTHX_ a)
#define ck_select(a)		Perl_ck_select(aTHX_ a)
#define ck_shift(a)		Perl_ck_shift(aTHX_ a)
#define ck_sort(a)		Perl_ck_sort(aTHX_ a)
#define ck_spair(a)		Perl_ck_spair(aTHX_ a)
#define ck_split(a)		Perl_ck_split(aTHX_ a)
#define ck_subr(a)		Perl_ck_subr(aTHX_ a)
#define ck_substr(a)		Perl_ck_substr(aTHX_ a)
#define ck_svconst(a)		Perl_ck_svconst(aTHX_ a)
#define ck_trunc(a)		Perl_ck_trunc(aTHX_ a)
#define ck_unpack(a)		Perl_ck_unpack(aTHX_ a)
#define is_handle_constructor	S_is_handle_constructor
#define is_list_assignment(a)	S_is_list_assignment(aTHX_ a)
#endif
#  ifdef USE_ITHREADS
#ifdef PERL_CORE
#endif
#  else
#ifdef PERL_CORE
#endif
#  endif
#ifdef PERL_CORE
#define find_and_forget_pmops(a)	S_find_and_forget_pmops(aTHX_ a)
#define cop_free(a)		S_cop_free(aTHX_ a)
#define modkids(a,b)		S_modkids(aTHX_ a,b)
#define scalarboolean(a)	S_scalarboolean(aTHX_ a)
#define newDEFSVOP()		S_newDEFSVOP(aTHX)
#define new_logop(a,b,c,d)	S_new_logop(aTHX_ a,b,c,d)
#define simplify_sort(a)	S_simplify_sort(aTHX_ a)
#define gv_ename(a)		S_gv_ename(aTHX_ a)
#define scalar_mod_type		S_scalar_mod_type
#define my_kid(a,b,c)		S_my_kid(aTHX_ a,b,c)
#define dup_attrlist(a)		S_dup_attrlist(aTHX_ a)
#define apply_attrs(a,b,c,d)	S_apply_attrs(aTHX_ a,b,c,d)
#define apply_attrs_my(a,b,c,d)	S_apply_attrs_my(aTHX_ a,b,c,d)
#define bad_type(a,b,c,d)	S_bad_type(aTHX_ a,b,c,d)
#define no_bareword_allowed(a)	S_no_bareword_allowed(aTHX_ a)
#define no_fh_allowed(a)	S_no_fh_allowed(aTHX_ a)
#define too_few_arguments(a,b)	S_too_few_arguments(aTHX_ a,b)
#define too_many_arguments(a,b)	S_too_many_arguments(aTHX_ a,b)
#define looks_like_bool(a)	S_looks_like_bool(aTHX_ a)
#define newGIVWHENOP(a,b,c,d,e)	S_newGIVWHENOP(aTHX_ a,b,c,d,e)
#define ref_array_or_hash(a)	S_ref_array_or_hash(aTHX_ a)
#define process_special_blocks(a,b,c)	S_process_special_blocks(aTHX_ a,b,c)
#endif
#endif
#if defined(PL_OP_SLAB_ALLOC)
#define Slab_Alloc(a)		Perl_Slab_Alloc(aTHX_ a)
#define Slab_Free(a)		Perl_Slab_Free(aTHX_ a)
#  if defined(PERL_DEBUG_READONLY_OPS)
#ifdef PERL_CORE
#endif
#    if defined(PERL_IN_OP_C)
#ifdef PERL_CORE
#define Slab_to_rw(a)		S_Slab_to_rw(aTHX_ a)
#endif
#    endif
#  endif
#endif
#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define find_beginning(a,b)	S_find_beginning(aTHX_ a,b)
#define forbid_setid(a,b)	S_forbid_setid(aTHX_ a,b)
#define incpush(a,b,c,d,e)	S_incpush(aTHX_ a,b,c,d,e)
#define init_interp()		S_init_interp(aTHX)
#define init_ids()		S_init_ids(aTHX)
#define init_main_stash()	S_init_main_stash(aTHX)
#define init_perllib()		S_init_perllib(aTHX)
#define init_postdump_symbols(a,b,c)	S_init_postdump_symbols(aTHX_ a,b,c)
#define init_predump_symbols()	S_init_predump_symbols(aTHX)
#define my_exit_jump()		S_my_exit_jump(aTHX)
#define nuke_stacks()		S_nuke_stacks(aTHX)
#define open_script(a,b,c,d,e)	S_open_script(aTHX_ a,b,c,d,e)
#define usage(a)		S_usage(aTHX_ a)
#define validate_suid(a,b,c,d,e,f)	S_validate_suid(aTHX_ a,b,c,d,e,f)
#endif
#  if defined(IAMSUID)
#ifdef PERL_CORE
#define fd_on_nosuid_fs(a)	S_fd_on_nosuid_fs(aTHX_ a)
#endif
#  endif
#ifdef PERL_CORE
#define parse_body(a,b)		S_parse_body(aTHX_ a,b)
#define run_body(a)		S_run_body(aTHX_ a)
#define incpush_if_exists(a)	S_incpush_if_exists(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define refto(a)		S_refto(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#endif
#endif
#if defined(PERL_IN_PP_PACK_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define unpack_rec(a,b,c,d,e)	S_unpack_rec(aTHX_ a,b,c,d,e)
#define pack_rec(a,b,c,d)	S_pack_rec(aTHX_ a,b,c,d)
#define mul128(a,b)		S_mul128(aTHX_ a,b)
#define measure_struct(a)	S_measure_struct(aTHX_ a)
#define next_symbol(a)		S_next_symbol(aTHX_ a)
#define is_an_int(a,b)		S_is_an_int(aTHX_ a,b)
#define div128(a,b)		S_div128(aTHX_ a,b)
#define group_end(a,b,c)	S_group_end(aTHX_ a,b,c)
#define get_num(a,b)		S_get_num(aTHX_ a,b)
#define need_utf8		S_need_utf8
#define first_symbol		S_first_symbol
#define sv_exp_grow(a,b)	S_sv_exp_grow(aTHX_ a,b)
#define bytes_to_uni		S_bytes_to_uni
#endif
#endif
#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define docatch(a)		S_docatch(aTHX_ a)
#define dofindlabel(a,b,c,d)	S_dofindlabel(aTHX_ a,b,c,d)
#define doparseform(a)		S_doparseform(aTHX_ a)
#define num_overflow		S_num_overflow
#define dopoptoeval(a)		S_dopoptoeval(aTHX_ a)
#define dopoptogiven(a)		S_dopoptogiven(aTHX_ a)
#define dopoptolabel(a)		S_dopoptolabel(aTHX_ a)
#define dopoptoloop(a)		S_dopoptoloop(aTHX_ a)
#define dopoptosub_at(a,b)	S_dopoptosub_at(aTHX_ a,b)
#define dopoptowhen(a)		S_dopoptowhen(aTHX_ a)
#define save_lines(a,b)		S_save_lines(aTHX_ a,b)
#define doeval(a,b,c,d)		S_doeval(aTHX_ a,b,c,d)
#define check_type_and_open(a)	S_check_type_and_open(aTHX_ a)
#endif
#ifndef PERL_DISABLE_PMC
#ifdef PERL_CORE
#define doopen_pm(a,b)		S_doopen_pm(aTHX_ a,b)
#endif
#endif
#ifdef PERL_CORE
#define path_is_absolute	S_path_is_absolute
#define run_user_filter(a,b,c)	S_run_user_filter(aTHX_ a,b,c)
#define make_matcher(a)		S_make_matcher(aTHX_ a)
#define matcher_matches_sv(a,b)	S_matcher_matches_sv(aTHX_ a,b)
#define destroy_matcher(a)	S_destroy_matcher(aTHX_ a)
#define do_smartmatch(a,b)	S_do_smartmatch(aTHX_ a,b)
#endif
#endif
#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define do_oddball(a,b,c)	S_do_oddball(aTHX_ a,b,c)
#define method_common(a,b)	S_method_common(aTHX_ a,b)
#endif
#endif
#if defined(PERL_IN_PP_SORT_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define sv_ncmp(a,b)		S_sv_ncmp(aTHX_ a,b)
#define sv_i_ncmp(a,b)		S_sv_i_ncmp(aTHX_ a,b)
#define amagic_ncmp(a,b)	S_amagic_ncmp(aTHX_ a,b)
#define amagic_i_ncmp(a,b)	S_amagic_i_ncmp(aTHX_ a,b)
#define amagic_cmp(a,b)		S_amagic_cmp(aTHX_ a,b)
#define amagic_cmp_locale(a,b)	S_amagic_cmp_locale(aTHX_ a,b)
#define sortcv(a,b)		S_sortcv(aTHX_ a,b)
#define sortcv_xsub(a,b)	S_sortcv_xsub(aTHX_ a,b)
#define sortcv_stacked(a,b)	S_sortcv_stacked(aTHX_ a,b)
#define qsortsvu(a,b,c)		S_qsortsvu(aTHX_ a,b,c)
#endif
#endif
#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define doform(a,b,c)		S_doform(aTHX_ a,b,c)
#endif
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#ifdef PERL_CORE
#define dooneliner(a,b)		S_dooneliner(aTHX_ a,b)
#endif
#  endif
#ifdef PERL_CORE
#define space_join_names_mortal(a)	S_space_join_names_mortal(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reg(a,b,c,d)		S_reg(aTHX_ a,b,c,d)
#define reganode(a,b,c)		S_reganode(aTHX_ a,b,c)
#define regatom(a,b,c)		S_regatom(aTHX_ a,b,c)
#define regbranch(a,b,c,d)	S_regbranch(aTHX_ a,b,c,d)
#define reguni(a,b,c)		S_reguni(aTHX_ a,b,c)
#define regclass(a,b)		S_regclass(aTHX_ a,b)
#define regcurly		S_regcurly
#define reg_node(a,b)		S_reg_node(aTHX_ a,b)
#define reg_recode(a,b)		S_reg_recode(aTHX_ a,b)
#define regpiece(a,b,c)		S_regpiece(aTHX_ a,b,c)
#define reg_namedseq(a,b)	S_reg_namedseq(aTHX_ a,b)
#define reginsert(a,b,c,d)	S_reginsert(aTHX_ a,b,c,d)
#define regtail(a,b,c,d)	S_regtail(aTHX_ a,b,c,d)
#define reg_scan_name(a,b)	S_reg_scan_name(aTHX_ a,b)
#define join_exact(a,b,c,d,e,f)	S_join_exact(aTHX_ a,b,c,d,e,f)
#define regwhite		S_regwhite
#define nextchar(a)		S_nextchar(aTHX_ a)
#define reg_skipcomment(a)	S_reg_skipcomment(aTHX_ a)
#define scan_commit(a,b,c,d)	S_scan_commit(aTHX_ a,b,c,d)
#define cl_anything		S_cl_anything
#define cl_is_anything		S_cl_is_anything
#define cl_init			S_cl_init
#define cl_init_zero		S_cl_init_zero
#define cl_and			S_cl_and
#define cl_or			S_cl_or
#define study_chunk(a,b,c,d,e,f,g,h,i,j,k)	S_study_chunk(aTHX_ a,b,c,d,e,f,g,h,i,j,k)
#define add_data		S_add_data
#endif
#ifdef PERL_CORE
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regpposixcc(a,b)	S_regpposixcc(aTHX_ a,b)
#define checkposixcc(a)		S_checkposixcc(aTHX_ a)
#define make_trie(a,b,c,d,e,f,g,h)	S_make_trie(aTHX_ a,b,c,d,e,f,g,h)
#define make_trie_failtable(a,b,c,d)	S_make_trie_failtable(aTHX_ a,b,c,d)
#endif
#  ifdef DEBUGGING
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regdump_extflags(a,b)	S_regdump_extflags(aTHX_ a,b)
#define dumpuntil(a,b,c,d,e,f,g,h)	S_dumpuntil(aTHX_ a,b,c,d,e,f,g,h)
#define put_byte(a,b)		S_put_byte(aTHX_ a,b)
#define dump_trie(a,b,c,d)	S_dump_trie(aTHX_ a,b,c,d)
#define dump_trie_interim_list(a,b,c,d,e)	S_dump_trie_interim_list(aTHX_ a,b,c,d,e)
#define dump_trie_interim_table(a,b,c,d,e)	S_dump_trie_interim_table(aTHX_ a,b,c,d,e)
#define regtail_study(a,b,c,d)	S_regtail_study(aTHX_ a,b,c,d)
#endif
#  endif
#endif
#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
#if defined(PERL_CORE) || defined(PERL_EXT)
#define regmatch(a,b)		S_regmatch(aTHX_ a,b)
#define regrepeat(a,b,c,d)	S_regrepeat(aTHX_ a,b,c,d)
#define regtry(a,b)		S_regtry(aTHX_ a,b)
#define reginclass(a,b,c,d,e)	S_reginclass(aTHX_ a,b,c,d,e)
#define regcppush(a)		S_regcppush(aTHX_ a)
#define regcppop(a)		S_regcppop(aTHX_ a)
#define reghop3			S_reghop3
#endif
#ifdef XXX_dmq
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reghop4			S_reghop4
#endif
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#define reghopmaybe3		S_reghopmaybe3
#define find_byclass(a,b,c,d,e)	S_find_byclass(aTHX_ a,b,c,d,e)
#define swap_match_buff(a)	S_swap_match_buff(aTHX_ a)
#define to_utf8_substr(a)	S_to_utf8_substr(aTHX_ a)
#define to_byte_substr(a)	S_to_byte_substr(aTHX_ a)
#define reg_check_named_buff_matched(a,b)	S_reg_check_named_buff_matched(aTHX_ a,b)
#endif
#  ifdef DEBUGGING
#if defined(PERL_CORE) || defined(PERL_EXT)
#define dump_exec_pos(a,b,c,d,e,f)	S_dump_exec_pos(aTHX_ a,b,c,d,e,f)
#define debug_start_match(a,b,c,d,e)	S_debug_start_match(aTHX_ a,b,c,d,e)
#endif
#  endif
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define deb_curcv(a)		S_deb_curcv(aTHX_ a)
#define debprof(a)		S_debprof(aTHX_ a)
#define sequence(a)		S_sequence(aTHX_ a)
#define sequence_tail(a)	S_sequence_tail(aTHX_ a)
#define sequence_num(a)		S_sequence_num(aTHX_ a)
#define pm_description(a)	S_pm_description(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define save_scalar_at(a)	S_save_scalar_at(aTHX_ a)
#endif
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#endif
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#endif
#endif
#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define uiv_2buf		S_uiv_2buf
#define sv_unglob(a)		S_sv_unglob(aTHX_ a)
#define not_a_number(a)		S_not_a_number(aTHX_ a)
#define visit(a,b,c)		S_visit(aTHX_ a,b,c)
#define sv_del_backref(a,b)	S_sv_del_backref(aTHX_ a,b)
#define varname(a,b,c,d,e,f)	S_varname(aTHX_ a,b,c,d,e,f)
#endif
#  ifdef DEBUGGING
#ifdef PERL_CORE
#define del_sv(a)		S_del_sv(aTHX_ a)
#endif
#  endif
#  if !defined(NV_PRESERVES_UV)
#ifdef PERL_CORE
#define sv_2iuv_non_preserve(a,b)	S_sv_2iuv_non_preserve(aTHX_ a,b)
#endif
#  endif
#ifdef PERL_CORE
#define expect_number(a)	S_expect_number(aTHX_ a)
#endif
#ifdef PERL_CORE
#define sv_pos_u2b_forwards	S_sv_pos_u2b_forwards
#define sv_pos_u2b_midway	S_sv_pos_u2b_midway
#define sv_pos_u2b_cached(a,b,c,d,e,f,g)	S_sv_pos_u2b_cached(aTHX_ a,b,c,d,e,f,g)
#define utf8_mg_pos_cache_update(a,b,c,d,e)	S_utf8_mg_pos_cache_update(aTHX_ a,b,c,d,e)
#define sv_pos_b2u_midway(a,b,c,d)	S_sv_pos_b2u_midway(aTHX_ a,b,c,d)
#define F0convert		S_F0convert
#endif
#  if defined(PERL_OLD_COPY_ON_WRITE)
#ifdef PERL_CORE
#define sv_release_COW(a,b,c)	S_sv_release_COW(aTHX_ a,b,c)
#endif
#  endif
#ifdef PERL_CORE
#define more_sv()		S_more_sv(aTHX)
#define more_bodies(a)		S_more_bodies(aTHX_ a)
#define sv_2iuv_common(a)	S_sv_2iuv_common(aTHX_ a)
#define glob_assign_glob(a,b,c)	S_glob_assign_glob(aTHX_ a,b,c)
#define glob_assign_ref(a,b)	S_glob_assign_ref(aTHX_ a,b)
#define ptr_table_find		S_ptr_table_find
#endif
#endif
#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define check_uni()		S_check_uni(aTHX)
#define force_next(a)		S_force_next(aTHX_ a)
#define force_version(a,b)	S_force_version(aTHX_ a,b)
#define force_word(a,b,c,d,e)	S_force_word(aTHX_ a,b,c,d,e)
#define tokeq(a)		S_tokeq(aTHX_ a)
#define readpipe_override()	S_readpipe_override(aTHX)
#define scan_const(a)		S_scan_const(aTHX_ a)
#define scan_formline(a)	S_scan_formline(aTHX_ a)
#define scan_heredoc(a)		S_scan_heredoc(aTHX_ a)
#define scan_ident(a,b,c,d,e)	S_scan_ident(aTHX_ a,b,c,d,e)
#define scan_inputsymbol(a)	S_scan_inputsymbol(aTHX_ a)
#define scan_pat(a,b)		S_scan_pat(aTHX_ a,b)
#define scan_str(a,b,c)		S_scan_str(aTHX_ a,b,c)
#define scan_subst(a)		S_scan_subst(aTHX_ a)
#define scan_trans(a)		S_scan_trans(aTHX_ a)
#define scan_word(a,b,c,d,e)	S_scan_word(aTHX_ a,b,c,d,e)
#define update_debugger_info(a,b,c)	S_update_debugger_info(aTHX_ a,b,c)
#define skipspace(a)		S_skipspace(aTHX_ a)
#define swallow_bom(a)		S_swallow_bom(aTHX_ a)
#define checkcomma(a,b,c)	S_checkcomma(aTHX_ a,b,c)
#define feature_is_enabled(a,b)	S_feature_is_enabled(aTHX_ a,b)
#define force_ident(a,b)	S_force_ident(aTHX_ a,b)
#define incline(a)		S_incline(aTHX_ a)
#define intuit_method(a,b,c)	S_intuit_method(aTHX_ a,b,c)
#define intuit_more(a)		S_intuit_more(aTHX_ a)
#define lop(a,b,c)		S_lop(aTHX_ a,b,c)
#define missingterm(a)		S_missingterm(aTHX_ a)
#define no_op(a,b)		S_no_op(aTHX_ a,b)
#define sublex_done()		S_sublex_done(aTHX)
#define sublex_push()		S_sublex_push(aTHX)
#define sublex_start()		S_sublex_start(aTHX)
#define filter_gets(a,b,c)	S_filter_gets(aTHX_ a,b,c)
#define find_in_my_stash(a,b)	S_find_in_my_stash(aTHX_ a,b)
#define tokenize_use(a,b)	S_tokenize_use(aTHX_ a,b)
#define ao(a)			S_ao(aTHX_ a)
#endif
#  if defined(PERL_CR_FILTER)
#ifdef PERL_CORE
#define cr_textfilter(a,b,c)	S_cr_textfilter(aTHX_ a,b,c)
#define strip_return(a)		S_strip_return(aTHX_ a)
#endif
#  endif
#  if defined(DEBUGGING)
#ifdef PERL_CORE
#define tokereport(a)		S_tokereport(aTHX_ a)
#define printbuf(a,b)		S_printbuf(aTHX_ a,b)
#endif
#  endif
#endif
#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define isa_lookup(a,b,c)	S_isa_lookup(aTHX_ a,b,c)
#endif
#endif
#if defined(PERL_IN_LOCALE_C) || defined(PERL_DECL_PROT)
#if defined(USE_LOCALE_NUMERIC) || defined(USE_LOCALE_COLLATE)
#ifdef PERL_CORE
#define stdize_locale(a)	S_stdize_locale(aTHX_ a)
#endif
#endif
#endif
#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define closest_cop(a,b)	S_closest_cop(aTHX_ a,b)
#define mess_alloc()		S_mess_alloc(aTHX)
#define vdie_croak_common(a,b,c,d)	S_vdie_croak_common(aTHX_ a,b,c,d)
#define vdie_common(a,b,c,d)	S_vdie_common(aTHX_ a,b,c,d)
#define write_no_mem()		S_write_no_mem(aTHX)
#endif
#endif
#if defined(PERL_IN_NUMERIC_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define mulexp10		S_mulexp10
#endif
#endif
#if defined(PERL_IN_UTF8_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define is_utf8_char_slow	S_is_utf8_char_slow
#define is_utf8_common(a,b,c)	S_is_utf8_common(aTHX_ a,b,c)
#define swash_get(a,b,c)	S_swash_get(aTHX_ a,b,c)
#endif
#endif
#define sv_setsv_flags(a,b,c)	Perl_sv_setsv_flags(aTHX_ a,b,c)
#define sv_catpvn_flags(a,b,c,d)	Perl_sv_catpvn_flags(aTHX_ a,b,c,d)
#define sv_catsv_flags(a,b,c)	Perl_sv_catsv_flags(aTHX_ a,b,c)
#define sv_utf8_upgrade_flags(a,b)	Perl_sv_utf8_upgrade_flags(aTHX_ a,b)
#define sv_pvn_force_flags(a,b,c)	Perl_sv_pvn_force_flags(aTHX_ a,b,c)
#define sv_copypv(a,b)		Perl_sv_copypv(aTHX_ a,b)
#define my_atof2(a,b)		Perl_my_atof2(aTHX_ a,b)
#define my_socketpair		Perl_my_socketpair
#define my_dirfd(a)		Perl_my_dirfd(aTHX_ a)
#ifdef PERL_OLD_COPY_ON_WRITE
#if defined(PERL_CORE) || defined(PERL_EXT)
#define sv_setsv_cow(a,b)	Perl_sv_setsv_cow(aTHX_ a,b)
#endif
#endif
#if defined(USE_PERLIO) && !defined(USE_SFIO)
#define PerlIO_close(a)		Perl_PerlIO_close(aTHX_ a)
#define PerlIO_fill(a)		Perl_PerlIO_fill(aTHX_ a)
#define PerlIO_fileno(a)	Perl_PerlIO_fileno(aTHX_ a)
#define PerlIO_eof(a)		Perl_PerlIO_eof(aTHX_ a)
#define PerlIO_error(a)		Perl_PerlIO_error(aTHX_ a)
#define PerlIO_flush(a)		Perl_PerlIO_flush(aTHX_ a)
#define PerlIO_clearerr(a)	Perl_PerlIO_clearerr(aTHX_ a)
#define PerlIO_set_cnt(a,b)	Perl_PerlIO_set_cnt(aTHX_ a,b)
#define PerlIO_set_ptrcnt(a,b,c)	Perl_PerlIO_set_ptrcnt(aTHX_ a,b,c)
#define PerlIO_setlinebuf(a)	Perl_PerlIO_setlinebuf(aTHX_ a)
#define PerlIO_read(a,b,c)	Perl_PerlIO_read(aTHX_ a,b,c)
#define PerlIO_write(a,b,c)	Perl_PerlIO_write(aTHX_ a,b,c)
#define PerlIO_unread(a,b,c)	Perl_PerlIO_unread(aTHX_ a,b,c)
#define PerlIO_tell(a)		Perl_PerlIO_tell(aTHX_ a)
#define PerlIO_seek(a,b,c)	Perl_PerlIO_seek(aTHX_ a,b,c)
#define PerlIO_get_base(a)	Perl_PerlIO_get_base(aTHX_ a)
#define PerlIO_get_ptr(a)	Perl_PerlIO_get_ptr(aTHX_ a)
#define PerlIO_get_bufsiz(a)	Perl_PerlIO_get_bufsiz(aTHX_ a)
#define PerlIO_get_cnt(a)	Perl_PerlIO_get_cnt(aTHX_ a)
#define PerlIO_stdin()		Perl_PerlIO_stdin(aTHX)
#define PerlIO_stdout()		Perl_PerlIO_stdout(aTHX)
#define PerlIO_stderr()		Perl_PerlIO_stderr(aTHX)
#endif /* PERLIO_LAYERS */
#ifdef PERL_CORE
#define deb_stack_all()		Perl_deb_stack_all(aTHX)
#endif
#ifdef PERL_IN_DEB_C
#ifdef PERL_CORE
#define deb_stack_n(a,b,c,d,e)	S_deb_stack_n(aTHX_ a,b,c,d,e)
#endif
#endif
#ifdef PERL_CORE
#define pad_new(a)		Perl_pad_new(aTHX_ a)
#define pad_undef(a)		Perl_pad_undef(aTHX_ a)
#define pad_add_name(a,b,c,d,e)	Perl_pad_add_name(aTHX_ a,b,c,d,e)
#define pad_add_anon(a,b)	Perl_pad_add_anon(aTHX_ a,b)
#define pad_check_dup(a,b,c)	Perl_pad_check_dup(aTHX_ a,b,c)
#endif
#ifdef DEBUGGING
#ifdef PERL_CORE
#define pad_setsv(a,b)		Perl_pad_setsv(aTHX_ a,b)
#endif
#endif
#ifdef PERL_CORE
#define pad_block_start(a)	Perl_pad_block_start(aTHX_ a)
#define pad_tidy(a)		Perl_pad_tidy(aTHX_ a)
#define do_dump_pad(a,b,c,d)	Perl_do_dump_pad(aTHX_ a,b,c,d)
#define pad_fixup_inner_anons(a,b,c)	Perl_pad_fixup_inner_anons(aTHX_ a,b,c)
#endif
#ifdef PERL_CORE
#define pad_push(a,b)		Perl_pad_push(aTHX_ a,b)
#define pad_compname_type(a)	Perl_pad_compname_type(aTHX_ a)
#endif
#if defined(PERL_IN_PAD_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define pad_findlex(a,b,c,d,e,f,g)	S_pad_findlex(aTHX_ a,b,c,d,e,f,g)
#endif
#  if defined(DEBUGGING)
#ifdef PERL_CORE
#define cv_dump(a,b)		S_cv_dump(aTHX_ a,b)
#endif
#  endif
#endif
#define find_runcv(a)		Perl_find_runcv(aTHX_ a)
#ifdef PERL_CORE
#define free_tied_hv_pool()	Perl_free_tied_hv_pool(aTHX)
#endif
#if defined(DEBUGGING)
#ifdef PERL_CORE
#define get_debug_opts(a,b)	Perl_get_debug_opts(aTHX_ a,b)
#endif
#endif
#define save_set_svflags(a,b,c)	Perl_save_set_svflags(aTHX_ a,b,c)
#define hv_scalar(a)		Perl_hv_scalar(aTHX_ a)
#define hv_name_set(a,b,c,d)	Perl_hv_name_set(aTHX_ a,b,c,d)
#ifdef PERL_CORE
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#endif
#endif
#define hv_clear_placeholders(a)	Perl_hv_clear_placeholders(aTHX_ a)
#ifdef PERL_CORE
#define magic_scalarpack(a,b)	Perl_magic_scalarpack(aTHX_ a,b)
#endif
#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define find_hash_subscript(a,b)	S_find_hash_subscript(aTHX_ a,b)
#define find_array_subscript(a,b)	S_find_array_subscript(aTHX_ a,b)
#define find_uninit_var(a,b,c)	S_find_uninit_var(aTHX_ a,b,c)
#endif
#endif
#ifdef PERL_NEED_MY_HTOLE16
#ifdef PERL_CORE
#define my_htole16		Perl_my_htole16
#endif
#endif
#ifdef PERL_NEED_MY_LETOH16
#ifdef PERL_CORE
#define my_letoh16		Perl_my_letoh16
#endif
#endif
#ifdef PERL_NEED_MY_HTOBE16
#ifdef PERL_CORE
#define my_htobe16		Perl_my_htobe16
#endif
#endif
#ifdef PERL_NEED_MY_BETOH16
#ifdef PERL_CORE
#define my_betoh16		Perl_my_betoh16
#endif
#endif
#ifdef PERL_NEED_MY_HTOLE32
#ifdef PERL_CORE
#define my_htole32		Perl_my_htole32
#endif
#endif
#ifdef PERL_NEED_MY_LETOH32
#ifdef PERL_CORE
#define my_letoh32		Perl_my_letoh32
#endif
#endif
#ifdef PERL_NEED_MY_HTOBE32
#ifdef PERL_CORE
#define my_htobe32		Perl_my_htobe32
#endif
#endif
#ifdef PERL_NEED_MY_BETOH32
#ifdef PERL_CORE
#define my_betoh32		Perl_my_betoh32
#endif
#endif
#ifdef PERL_NEED_MY_HTOLE64
#ifdef PERL_CORE
#define my_htole64		Perl_my_htole64
#endif
#endif
#ifdef PERL_NEED_MY_LETOH64
#ifdef PERL_CORE
#define my_letoh64		Perl_my_letoh64
#endif
#endif
#ifdef PERL_NEED_MY_HTOBE64
#ifdef PERL_CORE
#define my_htobe64		Perl_my_htobe64
#endif
#endif
#ifdef PERL_NEED_MY_BETOH64
#ifdef PERL_CORE
#define my_betoh64		Perl_my_betoh64
#endif
#endif
#ifdef PERL_NEED_MY_HTOLES
#ifdef PERL_CORE
#define my_htoles		Perl_my_htoles
#endif
#endif
#ifdef PERL_NEED_MY_LETOHS
#ifdef PERL_CORE
#define my_letohs		Perl_my_letohs
#endif
#endif
#ifdef PERL_NEED_MY_HTOBES
#ifdef PERL_CORE
#define my_htobes		Perl_my_htobes
#endif
#endif
#ifdef PERL_NEED_MY_BETOHS
#ifdef PERL_CORE
#define my_betohs		Perl_my_betohs
#endif
#endif
#ifdef PERL_NEED_MY_HTOLEI
#ifdef PERL_CORE
#define my_htolei		Perl_my_htolei
#endif
#endif
#ifdef PERL_NEED_MY_LETOHI
#ifdef PERL_CORE
#define my_letohi		Perl_my_letohi
#endif
#endif
#ifdef PERL_NEED_MY_HTOBEI
#ifdef PERL_CORE
#define my_htobei		Perl_my_htobei
#endif
#endif
#ifdef PERL_NEED_MY_BETOHI
#ifdef PERL_CORE
#define my_betohi		Perl_my_betohi
#endif
#endif
#ifdef PERL_NEED_MY_HTOLEL
#ifdef PERL_CORE
#define my_htolel		Perl_my_htolel
#endif
#endif
#ifdef PERL_NEED_MY_LETOHL
#ifdef PERL_CORE
#define my_letohl		Perl_my_letohl
#endif
#endif
#ifdef PERL_NEED_MY_HTOBEL
#ifdef PERL_CORE
#define my_htobel		Perl_my_htobel
#endif
#endif
#ifdef PERL_NEED_MY_BETOHL
#ifdef PERL_CORE
#define my_betohl		Perl_my_betohl
#endif
#endif
#ifdef PERL_CORE
#define my_swabn		Perl_my_swabn
#endif
#define gv_fetchpvn_flags(a,b,c,d)	Perl_gv_fetchpvn_flags(aTHX_ a,b,c,d)
#define gv_fetchsv(a,b,c)	Perl_gv_fetchsv(aTHX_ a,b,c)
#ifdef PERL_CORE
#define is_gv_magical_sv(a,b)	Perl_is_gv_magical_sv(aTHX_ a,b)
#endif
#define stashpv_hvname_match(a,b)	Perl_stashpv_hvname_match(aTHX_ a,b)
#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
#ifdef PERL_CORE
#define dump_sv_child(a)	Perl_dump_sv_child(aTHX_ a)
#endif
#endif
#ifdef PERL_DONT_CREATE_GVSV
#define gv_SVadd(a)		Perl_gv_SVadd(aTHX_ a)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#endif
#ifdef PERL_CORE
#define offer_nice_chunk(a,b)	Perl_offer_nice_chunk(aTHX_ a,b)
#endif
#ifndef SPRINTF_RETURNS_STRLEN
#endif
#ifdef PERL_CORE
#define my_clearenv()		Perl_my_clearenv(aTHX)
#endif
#ifdef PERL_IMPLICIT_CONTEXT
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#else
#endif
#endif
#ifndef HAS_STRLCAT
#endif
#ifndef HAS_STRLCPY
#endif
#ifdef PERL_MAD
#ifdef PERL_CORE
#define pad_peg			Perl_pad_peg
#endif
#if defined(PERL_IN_DUMP_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#endif
#endif
#ifdef PERL_CORE
#define xmldump_vindent(a,b,c,d)	Perl_xmldump_vindent(aTHX_ a,b,c,d)
#define xmldump_all()		Perl_xmldump_all(aTHX)
#define xmldump_packsubs(a)	Perl_xmldump_packsubs(aTHX_ a)
#define xmldump_sub(a)		Perl_xmldump_sub(aTHX_ a)
#define xmldump_form(a)		Perl_xmldump_form(aTHX_ a)
#define xmldump_eval()		Perl_xmldump_eval(aTHX)
#define sv_catxmlsv(a,b)	Perl_sv_catxmlsv(aTHX_ a,b)
#define sv_catxmlpvn(a,b,c,d)	Perl_sv_catxmlpvn(aTHX_ a,b,c,d)
#define sv_xmlpeek(a)		Perl_sv_xmlpeek(aTHX_ a)
#define do_pmop_xmldump(a,b,c)	Perl_do_pmop_xmldump(aTHX_ a,b,c)
#define pmop_xmldump(a)		Perl_pmop_xmldump(aTHX_ a)
#define do_op_xmldump(a,b,c)	Perl_do_op_xmldump(aTHX_ a,b,c)
#define op_xmldump(a)		Perl_op_xmldump(aTHX_ a)
#endif
#ifdef PERL_CORE
#define newTOKEN(a,b,c)		Perl_newTOKEN(aTHX_ a,b,c)
#define token_free(a)		Perl_token_free(aTHX_ a)
#define token_getmad(a,b,c)	Perl_token_getmad(aTHX_ a,b,c)
#define op_getmad_weak(a,b,c)	Perl_op_getmad_weak(aTHX_ a,b,c)
#define op_getmad(a,b,c)	Perl_op_getmad(aTHX_ a,b,c)
#define prepend_madprops(a,b,c)	Perl_prepend_madprops(aTHX_ a,b,c)
#define append_madprops(a,b,c)	Perl_append_madprops(aTHX_ a,b,c)
#define addmad(a,b,c)		Perl_addmad(aTHX_ a,b,c)
#define newMADsv(a,b)		Perl_newMADsv(aTHX_ a,b)
#define newMADPROP(a,b,c,d)	Perl_newMADPROP(aTHX_ a,b,c,d)
#define mad_free(a)		Perl_mad_free(aTHX_ a)
#endif
#  if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define skipspace0(a)		S_skipspace0(aTHX_ a)
#define skipspace1(a)		S_skipspace1(aTHX_ a)
#define skipspace2(a,b)		S_skipspace2(aTHX_ a,b)
#define start_force(a)		S_start_force(aTHX_ a)
#define curmad(a,b)		S_curmad(aTHX_ a,b)
#endif
#  endif
#ifdef PERL_CORE
#define madlex()		Perl_madlex(aTHX)
#define madparse()		Perl_madparse(aTHX)
#endif
#endif
#if !defined(HAS_SIGNBIT)
#endif
#if defined(PERL_CORE) || defined(PERL_EXT)
#endif
#ifdef PERL_CORE
#define mro_meta_init(a)	Perl_mro_meta_init(aTHX_ a)
#endif
#if defined(USE_ITHREADS)
#ifdef PERL_CORE
#define mro_meta_dup(a,b)	Perl_mro_meta_dup(aTHX_ a,b)
#endif
#endif
#define mro_get_linear_isa(a)	Perl_mro_get_linear_isa(aTHX_ a)
#if defined(PERL_IN_MRO_C) || defined(PERL_DECL_PROT)
#ifdef PERL_CORE
#define mro_get_linear_isa_c3(a,b)	S_mro_get_linear_isa_c3(aTHX_ a,b)
#define mro_get_linear_isa_dfs(a,b)	S_mro_get_linear_isa_dfs(aTHX_ a,b)
#endif
#endif
#ifdef PERL_CORE
#define mro_isa_changed_in(a)	Perl_mro_isa_changed_in(aTHX_ a)
#endif
#define mro_method_changed_in(a)	Perl_mro_method_changed_in(aTHX_ a)
#ifdef PERL_CORE
#define boot_core_mro()		Perl_boot_core_mro(aTHX)
#endif
#define ck_anoncode(a)		Perl_ck_anoncode(aTHX_ a)
#define ck_bitop(a)		Perl_ck_bitop(aTHX_ a)
#define ck_chdir(a)		Perl_ck_chdir(aTHX_ a)
#define ck_concat(a)		Perl_ck_concat(aTHX_ a)
#define ck_defined(a)		Perl_ck_defined(aTHX_ a)
#define ck_delete(a)		Perl_ck_delete(aTHX_ a)
#define ck_die(a)		Perl_ck_die(aTHX_ a)
#define ck_eof(a)		Perl_ck_eof(aTHX_ a)
#define ck_eval(a)		Perl_ck_eval(aTHX_ a)
#define ck_exec(a)		Perl_ck_exec(aTHX_ a)
#define ck_exists(a)		Perl_ck_exists(aTHX_ a)
#define ck_exit(a)		Perl_ck_exit(aTHX_ a)
#define ck_ftst(a)		Perl_ck_ftst(aTHX_ a)
#define ck_fun(a)		Perl_ck_fun(aTHX_ a)
#define ck_glob(a)		Perl_ck_glob(aTHX_ a)
#define ck_grep(a)		Perl_ck_grep(aTHX_ a)
#define ck_index(a)		Perl_ck_index(aTHX_ a)
#define ck_join(a)		Perl_ck_join(aTHX_ a)
#define ck_lengthconst(a)	Perl_ck_lengthconst(aTHX_ a)
#define ck_lfun(a)		Perl_ck_lfun(aTHX_ a)
#define ck_listiob(a)		Perl_ck_listiob(aTHX_ a)
#define ck_match(a)		Perl_ck_match(aTHX_ a)
#define ck_method(a)		Perl_ck_method(aTHX_ a)
#define ck_null(a)		Perl_ck_null(aTHX_ a)
#define ck_open(a)		Perl_ck_open(aTHX_ a)
#define ck_readline(a)		Perl_ck_readline(aTHX_ a)
#define ck_repeat(a)		Perl_ck_repeat(aTHX_ a)
#define ck_require(a)		Perl_ck_require(aTHX_ a)
#define ck_return(a)		Perl_ck_return(aTHX_ a)
#define ck_rfun(a)		Perl_ck_rfun(aTHX_ a)
#define ck_rvconst(a)		Perl_ck_rvconst(aTHX_ a)
#define ck_sassign(a)		Perl_ck_sassign(aTHX_ a)
#define ck_select(a)		Perl_ck_select(aTHX_ a)
#define ck_shift(a)		Perl_ck_shift(aTHX_ a)
#define ck_smartmatch(a)	Perl_ck_smartmatch(aTHX_ a)
#define ck_sort(a)		Perl_ck_sort(aTHX_ a)
#define ck_spair(a)		Perl_ck_spair(aTHX_ a)
#define ck_split(a)		Perl_ck_split(aTHX_ a)
#define ck_subr(a)		Perl_ck_subr(aTHX_ a)
#define ck_substr(a)		Perl_ck_substr(aTHX_ a)
#define ck_svconst(a)		Perl_ck_svconst(aTHX_ a)
#define ck_trunc(a)		Perl_ck_trunc(aTHX_ a)
#define ck_unpack(a)		Perl_ck_unpack(aTHX_ a)
#define pp_aassign()		Perl_pp_aassign(aTHX)
#define pp_abs()		Perl_pp_abs(aTHX)
#define pp_accept()		Perl_pp_accept(aTHX)
#define pp_add()		Perl_pp_add(aTHX)
#define pp_aelem()		Perl_pp_aelem(aTHX)
#define pp_aelemfast()		Perl_pp_aelemfast(aTHX)
#define pp_alarm()		Perl_pp_alarm(aTHX)
#define pp_and()		Perl_pp_and(aTHX)
#define pp_andassign()		Perl_pp_andassign(aTHX)
#define pp_anoncode()		Perl_pp_anoncode(aTHX)
#define pp_anonhash()		Perl_pp_anonhash(aTHX)
#define pp_anonlist()		Perl_pp_anonlist(aTHX)
#define pp_aslice()		Perl_pp_aslice(aTHX)
#define pp_atan2()		Perl_pp_atan2(aTHX)
#define pp_av2arylen()		Perl_pp_av2arylen(aTHX)
#define pp_backtick()		Perl_pp_backtick(aTHX)
#define pp_bind()		Perl_pp_bind(aTHX)
#define pp_binmode()		Perl_pp_binmode(aTHX)
#define pp_bit_and()		Perl_pp_bit_and(aTHX)
#define pp_bit_or()		Perl_pp_bit_or(aTHX)
#define pp_bit_xor()		Perl_pp_bit_xor(aTHX)
#define pp_bless()		Perl_pp_bless(aTHX)
#define pp_break()		Perl_pp_break(aTHX)
#define pp_caller()		Perl_pp_caller(aTHX)
#define pp_chdir()		Perl_pp_chdir(aTHX)
#define pp_chmod()		Perl_pp_chmod(aTHX)
#define pp_chomp()		Perl_pp_chomp(aTHX)
#define pp_chop()		Perl_pp_chop(aTHX)
#define pp_chown()		Perl_pp_chown(aTHX)
#define pp_chr()		Perl_pp_chr(aTHX)
#define pp_chroot()		Perl_pp_chroot(aTHX)
#define pp_close()		Perl_pp_close(aTHX)
#define pp_closedir()		Perl_pp_closedir(aTHX)
#define pp_complement()		Perl_pp_complement(aTHX)
#define pp_concat()		Perl_pp_concat(aTHX)
#define pp_cond_expr()		Perl_pp_cond_expr(aTHX)
#define pp_connect()		Perl_pp_connect(aTHX)
#define pp_const()		Perl_pp_const(aTHX)
#define pp_continue()		Perl_pp_continue(aTHX)
#define pp_cos()		Perl_pp_cos(aTHX)
#define pp_crypt()		Perl_pp_crypt(aTHX)
#define pp_dbmclose()		Perl_pp_dbmclose(aTHX)
#define pp_dbmopen()		Perl_pp_dbmopen(aTHX)
#define pp_dbstate()		Perl_pp_dbstate(aTHX)
#define pp_defined()		Perl_pp_defined(aTHX)
#define pp_delete()		Perl_pp_delete(aTHX)
#define pp_die()		Perl_pp_die(aTHX)
#define pp_divide()		Perl_pp_divide(aTHX)
#define pp_dofile()		Perl_pp_dofile(aTHX)
#define pp_dor()		Perl_pp_dor(aTHX)
#define pp_dorassign()		Perl_pp_dorassign(aTHX)
#define pp_dump()		Perl_pp_dump(aTHX)
#define pp_each()		Perl_pp_each(aTHX)
#define pp_egrent()		Perl_pp_egrent(aTHX)
#define pp_ehostent()		Perl_pp_ehostent(aTHX)
#define pp_enetent()		Perl_pp_enetent(aTHX)
#define pp_enter()		Perl_pp_enter(aTHX)
#define pp_entereval()		Perl_pp_entereval(aTHX)
#define pp_entergiven()		Perl_pp_entergiven(aTHX)
#define pp_enteriter()		Perl_pp_enteriter(aTHX)
#define pp_enterloop()		Perl_pp_enterloop(aTHX)
#define pp_entersub()		Perl_pp_entersub(aTHX)
#define pp_entertry()		Perl_pp_entertry(aTHX)
#define pp_enterwhen()		Perl_pp_enterwhen(aTHX)
#define pp_enterwrite()		Perl_pp_enterwrite(aTHX)
#define pp_eof()		Perl_pp_eof(aTHX)
#define pp_eprotoent()		Perl_pp_eprotoent(aTHX)
#define pp_epwent()		Perl_pp_epwent(aTHX)
#define pp_eq()			Perl_pp_eq(aTHX)
#define pp_eservent()		Perl_pp_eservent(aTHX)
#define pp_exec()		Perl_pp_exec(aTHX)
#define pp_exists()		Perl_pp_exists(aTHX)
#define pp_exit()		Perl_pp_exit(aTHX)
#define pp_exp()		Perl_pp_exp(aTHX)
#define pp_fcntl()		Perl_pp_fcntl(aTHX)
#define pp_fileno()		Perl_pp_fileno(aTHX)
#define pp_flip()		Perl_pp_flip(aTHX)
#define pp_flock()		Perl_pp_flock(aTHX)
#define pp_flop()		Perl_pp_flop(aTHX)
#define pp_fork()		Perl_pp_fork(aTHX)
#define pp_formline()		Perl_pp_formline(aTHX)
#define pp_ftatime()		Perl_pp_ftatime(aTHX)
#define pp_ftbinary()		Perl_pp_ftbinary(aTHX)
#define pp_ftblk()		Perl_pp_ftblk(aTHX)
#define pp_ftchr()		Perl_pp_ftchr(aTHX)
#define pp_ftctime()		Perl_pp_ftctime(aTHX)
#define pp_ftdir()		Perl_pp_ftdir(aTHX)
#define pp_fteexec()		Perl_pp_fteexec(aTHX)
#define pp_fteowned()		Perl_pp_fteowned(aTHX)
#define pp_fteread()		Perl_pp_fteread(aTHX)
#define pp_ftewrite()		Perl_pp_ftewrite(aTHX)
#define pp_ftfile()		Perl_pp_ftfile(aTHX)
#define pp_ftis()		Perl_pp_ftis(aTHX)
#define pp_ftlink()		Perl_pp_ftlink(aTHX)
#define pp_ftmtime()		Perl_pp_ftmtime(aTHX)
#define pp_ftpipe()		Perl_pp_ftpipe(aTHX)
#define pp_ftrexec()		Perl_pp_ftrexec(aTHX)
#define pp_ftrowned()		Perl_pp_ftrowned(aTHX)
#define pp_ftrread()		Perl_pp_ftrread(aTHX)
#define pp_ftrwrite()		Perl_pp_ftrwrite(aTHX)
#define pp_ftsgid()		Perl_pp_ftsgid(aTHX)
#define pp_ftsize()		Perl_pp_ftsize(aTHX)
#define pp_ftsock()		Perl_pp_ftsock(aTHX)
#define pp_ftsuid()		Perl_pp_ftsuid(aTHX)
#define pp_ftsvtx()		Perl_pp_ftsvtx(aTHX)
#define pp_fttext()		Perl_pp_fttext(aTHX)
#define pp_fttty()		Perl_pp_fttty(aTHX)
#define pp_ftzero()		Perl_pp_ftzero(aTHX)
#define pp_ge()			Perl_pp_ge(aTHX)
#define pp_gelem()		Perl_pp_gelem(aTHX)
#define pp_getc()		Perl_pp_getc(aTHX)
#define pp_getlogin()		Perl_pp_getlogin(aTHX)
#define pp_getpeername()	Perl_pp_getpeername(aTHX)
#define pp_getpgrp()		Perl_pp_getpgrp(aTHX)
#define pp_getppid()		Perl_pp_getppid(aTHX)
#define pp_getpriority()	Perl_pp_getpriority(aTHX)
#define pp_getsockname()	Perl_pp_getsockname(aTHX)
#define pp_ggrent()		Perl_pp_ggrent(aTHX)
#define pp_ggrgid()		Perl_pp_ggrgid(aTHX)
#define pp_ggrnam()		Perl_pp_ggrnam(aTHX)
#define pp_ghbyaddr()		Perl_pp_ghbyaddr(aTHX)
#define pp_ghbyname()		Perl_pp_ghbyname(aTHX)
#define pp_ghostent()		Perl_pp_ghostent(aTHX)
#define pp_glob()		Perl_pp_glob(aTHX)
#define pp_gmtime()		Perl_pp_gmtime(aTHX)
#define pp_gnbyaddr()		Perl_pp_gnbyaddr(aTHX)
#define pp_gnbyname()		Perl_pp_gnbyname(aTHX)
#define pp_gnetent()		Perl_pp_gnetent(aTHX)
#define pp_goto()		Perl_pp_goto(aTHX)
#define pp_gpbyname()		Perl_pp_gpbyname(aTHX)
#define pp_gpbynumber()		Perl_pp_gpbynumber(aTHX)
#define pp_gprotoent()		Perl_pp_gprotoent(aTHX)
#define pp_gpwent()		Perl_pp_gpwent(aTHX)
#define pp_gpwnam()		Perl_pp_gpwnam(aTHX)
#define pp_gpwuid()		Perl_pp_gpwuid(aTHX)
#define pp_grepstart()		Perl_pp_grepstart(aTHX)
#define pp_grepwhile()		Perl_pp_grepwhile(aTHX)
#define pp_gsbyname()		Perl_pp_gsbyname(aTHX)
#define pp_gsbyport()		Perl_pp_gsbyport(aTHX)
#define pp_gservent()		Perl_pp_gservent(aTHX)
#define pp_gsockopt()		Perl_pp_gsockopt(aTHX)
#define pp_gt()			Perl_pp_gt(aTHX)
#define pp_gv()			Perl_pp_gv(aTHX)
#define pp_gvsv()		Perl_pp_gvsv(aTHX)
#define pp_helem()		Perl_pp_helem(aTHX)
#define pp_hex()		Perl_pp_hex(aTHX)
#define pp_hslice()		Perl_pp_hslice(aTHX)
#define pp_i_add()		Perl_pp_i_add(aTHX)
#define pp_i_divide()		Perl_pp_i_divide(aTHX)
#define pp_i_eq()		Perl_pp_i_eq(aTHX)
#define pp_i_ge()		Perl_pp_i_ge(aTHX)
#define pp_i_gt()		Perl_pp_i_gt(aTHX)
#define pp_i_le()		Perl_pp_i_le(aTHX)
#define pp_i_lt()		Perl_pp_i_lt(aTHX)
#define pp_i_modulo()		Perl_pp_i_modulo(aTHX)
#define pp_i_multiply()		Perl_pp_i_multiply(aTHX)
#define pp_i_ncmp()		Perl_pp_i_ncmp(aTHX)
#define pp_i_ne()		Perl_pp_i_ne(aTHX)
#define pp_i_negate()		Perl_pp_i_negate(aTHX)
#define pp_i_subtract()		Perl_pp_i_subtract(aTHX)
#define pp_index()		Perl_pp_index(aTHX)
#define pp_int()		Perl_pp_int(aTHX)
#define pp_ioctl()		Perl_pp_ioctl(aTHX)
#define pp_iter()		Perl_pp_iter(aTHX)
#define pp_join()		Perl_pp_join(aTHX)
#define pp_keys()		Perl_pp_keys(aTHX)
#define pp_kill()		Perl_pp_kill(aTHX)
#define pp_last()		Perl_pp_last(aTHX)
#define pp_lc()			Perl_pp_lc(aTHX)
#define pp_lcfirst()		Perl_pp_lcfirst(aTHX)
#define pp_le()			Perl_pp_le(aTHX)
#define pp_leave()		Perl_pp_leave(aTHX)
#define pp_leaveeval()		Perl_pp_leaveeval(aTHX)
#define pp_leavegiven()		Perl_pp_leavegiven(aTHX)
#define pp_leaveloop()		Perl_pp_leaveloop(aTHX)
#define pp_leavesub()		Perl_pp_leavesub(aTHX)
#define pp_leavesublv()		Perl_pp_leavesublv(aTHX)
#define pp_leavetry()		Perl_pp_leavetry(aTHX)
#define pp_leavewhen()		Perl_pp_leavewhen(aTHX)
#define pp_leavewrite()		Perl_pp_leavewrite(aTHX)
#define pp_left_shift()		Perl_pp_left_shift(aTHX)
#define pp_length()		Perl_pp_length(aTHX)
#define pp_lineseq()		Perl_pp_lineseq(aTHX)
#define pp_link()		Perl_pp_link(aTHX)
#define pp_list()		Perl_pp_list(aTHX)
#define pp_listen()		Perl_pp_listen(aTHX)
#define pp_localtime()		Perl_pp_localtime(aTHX)
#define pp_lock()		Perl_pp_lock(aTHX)
#define pp_log()		Perl_pp_log(aTHX)
#define pp_lslice()		Perl_pp_lslice(aTHX)
#define pp_lstat()		Perl_pp_lstat(aTHX)
#define pp_lt()			Perl_pp_lt(aTHX)
#define pp_mapstart()		Perl_pp_mapstart(aTHX)
#define pp_mapwhile()		Perl_pp_mapwhile(aTHX)
#define pp_match()		Perl_pp_match(aTHX)
#define pp_method()		Perl_pp_method(aTHX)
#define pp_method_named()	Perl_pp_method_named(aTHX)
#define pp_mkdir()		Perl_pp_mkdir(aTHX)
#define pp_modulo()		Perl_pp_modulo(aTHX)
#define pp_msgctl()		Perl_pp_msgctl(aTHX)
#define pp_msgget()		Perl_pp_msgget(aTHX)
#define pp_msgrcv()		Perl_pp_msgrcv(aTHX)
#define pp_msgsnd()		Perl_pp_msgsnd(aTHX)
#define pp_multiply()		Perl_pp_multiply(aTHX)
#define pp_ncmp()		Perl_pp_ncmp(aTHX)
#define pp_ne()			Perl_pp_ne(aTHX)
#define pp_negate()		Perl_pp_negate(aTHX)
#define pp_next()		Perl_pp_next(aTHX)
#define pp_nextstate()		Perl_pp_nextstate(aTHX)
#define pp_not()		Perl_pp_not(aTHX)
#define pp_null()		Perl_pp_null(aTHX)
#define pp_oct()		Perl_pp_oct(aTHX)
#define pp_once()		Perl_pp_once(aTHX)
#define pp_open()		Perl_pp_open(aTHX)
#define pp_open_dir()		Perl_pp_open_dir(aTHX)
#define pp_or()			Perl_pp_or(aTHX)
#define pp_orassign()		Perl_pp_orassign(aTHX)
#define pp_ord()		Perl_pp_ord(aTHX)
#define pp_pack()		Perl_pp_pack(aTHX)
#define pp_padany()		Perl_pp_padany(aTHX)
#define pp_padav()		Perl_pp_padav(aTHX)
#define pp_padhv()		Perl_pp_padhv(aTHX)
#define pp_padsv()		Perl_pp_padsv(aTHX)
#define pp_pipe_op()		Perl_pp_pipe_op(aTHX)
#define pp_pop()		Perl_pp_pop(aTHX)
#define pp_pos()		Perl_pp_pos(aTHX)
#define pp_postdec()		Perl_pp_postdec(aTHX)
#define pp_postinc()		Perl_pp_postinc(aTHX)
#define pp_pow()		Perl_pp_pow(aTHX)
#define pp_predec()		Perl_pp_predec(aTHX)
#define pp_preinc()		Perl_pp_preinc(aTHX)
#define pp_print()		Perl_pp_print(aTHX)
#define pp_prototype()		Perl_pp_prototype(aTHX)
#define pp_prtf()		Perl_pp_prtf(aTHX)
#define pp_push()		Perl_pp_push(aTHX)
#define pp_pushmark()		Perl_pp_pushmark(aTHX)
#define pp_pushre()		Perl_pp_pushre(aTHX)
#define pp_qr()			Perl_pp_qr(aTHX)
#define pp_quotemeta()		Perl_pp_quotemeta(aTHX)
#define pp_rand()		Perl_pp_rand(aTHX)
#define pp_range()		Perl_pp_range(aTHX)
#define pp_rcatline()		Perl_pp_rcatline(aTHX)
#define pp_read()		Perl_pp_read(aTHX)
#define pp_readdir()		Perl_pp_readdir(aTHX)
#define pp_readline()		Perl_pp_readline(aTHX)
#define pp_readlink()		Perl_pp_readlink(aTHX)
#define pp_recv()		Perl_pp_recv(aTHX)
#define pp_redo()		Perl_pp_redo(aTHX)
#define pp_ref()		Perl_pp_ref(aTHX)
#define pp_refgen()		Perl_pp_refgen(aTHX)
#define pp_regcmaybe()		Perl_pp_regcmaybe(aTHX)
#define pp_regcomp()		Perl_pp_regcomp(aTHX)
#define pp_regcreset()		Perl_pp_regcreset(aTHX)
#define pp_rename()		Perl_pp_rename(aTHX)
#define pp_repeat()		Perl_pp_repeat(aTHX)
#define pp_require()		Perl_pp_require(aTHX)
#define pp_reset()		Perl_pp_reset(aTHX)
#define pp_return()		Perl_pp_return(aTHX)
#define pp_reverse()		Perl_pp_reverse(aTHX)
#define pp_rewinddir()		Perl_pp_rewinddir(aTHX)
#define pp_right_shift()	Perl_pp_right_shift(aTHX)
#define pp_rindex()		Perl_pp_rindex(aTHX)
#define pp_rmdir()		Perl_pp_rmdir(aTHX)
#define pp_rv2av()		Perl_pp_rv2av(aTHX)
#define pp_rv2cv()		Perl_pp_rv2cv(aTHX)
#define pp_rv2gv()		Perl_pp_rv2gv(aTHX)
#define pp_rv2hv()		Perl_pp_rv2hv(aTHX)
#define pp_rv2sv()		Perl_pp_rv2sv(aTHX)
#define pp_sassign()		Perl_pp_sassign(aTHX)
#define pp_say()		Perl_pp_say(aTHX)
#define pp_scalar()		Perl_pp_scalar(aTHX)
#define pp_schomp()		Perl_pp_schomp(aTHX)
#define pp_schop()		Perl_pp_schop(aTHX)
#define pp_scmp()		Perl_pp_scmp(aTHX)
#define pp_scope()		Perl_pp_scope(aTHX)
#define pp_seek()		Perl_pp_seek(aTHX)
#define pp_seekdir()		Perl_pp_seekdir(aTHX)
#define pp_select()		Perl_pp_select(aTHX)
#define pp_semctl()		Perl_pp_semctl(aTHX)
#define pp_semget()		Perl_pp_semget(aTHX)
#define pp_semop()		Perl_pp_semop(aTHX)
#define pp_send()		Perl_pp_send(aTHX)
#define pp_seq()		Perl_pp_seq(aTHX)
#define pp_setpgrp()		Perl_pp_setpgrp(aTHX)
#define pp_setpriority()	Perl_pp_setpriority(aTHX)
#define pp_setstate()		Perl_pp_setstate(aTHX)
#define pp_sge()		Perl_pp_sge(aTHX)
#define pp_sgrent()		Perl_pp_sgrent(aTHX)
#define pp_sgt()		Perl_pp_sgt(aTHX)
#define pp_shift()		Perl_pp_shift(aTHX)
#define pp_shmctl()		Perl_pp_shmctl(aTHX)
#define pp_shmget()		Perl_pp_shmget(aTHX)
#define pp_shmread()		Perl_pp_shmread(aTHX)
#define pp_shmwrite()		Perl_pp_shmwrite(aTHX)
#define pp_shostent()		Perl_pp_shostent(aTHX)
#define pp_shutdown()		Perl_pp_shutdown(aTHX)
#define pp_sin()		Perl_pp_sin(aTHX)
#define pp_sle()		Perl_pp_sle(aTHX)
#define pp_sleep()		Perl_pp_sleep(aTHX)
#define pp_slt()		Perl_pp_slt(aTHX)
#define pp_smartmatch()		Perl_pp_smartmatch(aTHX)
#define pp_sne()		Perl_pp_sne(aTHX)
#define pp_snetent()		Perl_pp_snetent(aTHX)
#define pp_socket()		Perl_pp_socket(aTHX)
#define pp_sockpair()		Perl_pp_sockpair(aTHX)
#define pp_sort()		Perl_pp_sort(aTHX)
#define pp_splice()		Perl_pp_splice(aTHX)
#define pp_split()		Perl_pp_split(aTHX)
#define pp_sprintf()		Perl_pp_sprintf(aTHX)
#define pp_sprotoent()		Perl_pp_sprotoent(aTHX)
#define pp_spwent()		Perl_pp_spwent(aTHX)
#define pp_sqrt()		Perl_pp_sqrt(aTHX)
#define pp_srand()		Perl_pp_srand(aTHX)
#define pp_srefgen()		Perl_pp_srefgen(aTHX)
#define pp_sselect()		Perl_pp_sselect(aTHX)
#define pp_sservent()		Perl_pp_sservent(aTHX)
#define pp_ssockopt()		Perl_pp_ssockopt(aTHX)
#define pp_stat()		Perl_pp_stat(aTHX)
#define pp_stringify()		Perl_pp_stringify(aTHX)
#define pp_stub()		Perl_pp_stub(aTHX)
#define pp_study()		Perl_pp_study(aTHX)
#define pp_subst()		Perl_pp_subst(aTHX)
#define pp_substcont()		Perl_pp_substcont(aTHX)
#define pp_substr()		Perl_pp_substr(aTHX)
#define pp_subtract()		Perl_pp_subtract(aTHX)
#define pp_symlink()		Perl_pp_symlink(aTHX)
#define pp_syscall()		Perl_pp_syscall(aTHX)
#define pp_sysopen()		Perl_pp_sysopen(aTHX)
#define pp_sysread()		Perl_pp_sysread(aTHX)
#define pp_sysseek()		Perl_pp_sysseek(aTHX)
#define pp_system()		Perl_pp_system(aTHX)
#define pp_syswrite()		Perl_pp_syswrite(aTHX)
#define pp_tell()		Perl_pp_tell(aTHX)
#define pp_telldir()		Perl_pp_telldir(aTHX)
#define pp_tie()		Perl_pp_tie(aTHX)
#define pp_tied()		Perl_pp_tied(aTHX)
#define pp_time()		Perl_pp_time(aTHX)
#define pp_tms()		Perl_pp_tms(aTHX)
#define pp_trans()		Perl_pp_trans(aTHX)
#define pp_truncate()		Perl_pp_truncate(aTHX)
#define pp_uc()			Perl_pp_uc(aTHX)
#define pp_ucfirst()		Perl_pp_ucfirst(aTHX)
#define pp_umask()		Perl_pp_umask(aTHX)
#define pp_undef()		Perl_pp_undef(aTHX)
#define pp_unlink()		Perl_pp_unlink(aTHX)
#define pp_unpack()		Perl_pp_unpack(aTHX)
#define pp_unshift()		Perl_pp_unshift(aTHX)
#define pp_unstack()		Perl_pp_unstack(aTHX)
#define pp_untie()		Perl_pp_untie(aTHX)
#define pp_utime()		Perl_pp_utime(aTHX)
#define pp_values()		Perl_pp_values(aTHX)
#define pp_vec()		Perl_pp_vec(aTHX)
#define pp_wait()		Perl_pp_wait(aTHX)
#define pp_waitpid()		Perl_pp_waitpid(aTHX)
#define pp_wantarray()		Perl_pp_wantarray(aTHX)
#define pp_warn()		Perl_pp_warn(aTHX)
#define pp_xor()		Perl_pp_xor(aTHX)

#endif	/* PERL_IMPLICIT_CONTEXT */

#endif	/* #ifndef PERL_NO_SHORT_NAMES */


/* Compatibility stubs.  Compile extensions with -DPERL_NOCOMPAT to
   disable them.
 */

#if !defined(PERL_CORE)
#  define sv_setptrobj(rv,ptr,name)	sv_setref_iv(rv,name,PTR2IV(ptr))
#  define sv_setptrref(rv,ptr)		sv_setref_iv(rv,NULL,PTR2IV(ptr))
#endif

#if !defined(PERL_CORE) && !defined(PERL_NOCOMPAT)

/* Compatibility for various misnamed functions.  All functions
   in the API that begin with "perl_" (not "Perl_") take an explicit
   interpreter context pointer.
   The following are not like that, but since they had a "perl_"
   prefix in previous versions, we provide compatibility macros.
 */
#  define perl_atexit(a,b)		call_atexit(a,b)
#  define perl_call_argv(a,b,c)		call_argv(a,b,c)
#  define perl_call_pv(a,b)		call_pv(a,b)
#  define perl_call_method(a,b)		call_method(a,b)
#  define perl_call_sv(a,b)		call_sv(a,b)
#  define perl_eval_sv(a,b)		eval_sv(a,b)
#  define perl_eval_pv(a,b)		eval_pv(a,b)
#  define perl_require_pv(a)		require_pv(a)
#  define perl_get_sv(a,b)		get_sv(a,b)
#  define perl_get_av(a,b)		get_av(a,b)
#  define perl_get_hv(a,b)		get_hv(a,b)
#  define perl_get_cv(a,b)		get_cv(a,b)
#  define perl_init_i18nl10n(a)		init_i18nl10n(a)
#  define perl_init_i18nl14n(a)		init_i18nl14n(a)
#  define perl_new_ctype(a)		new_ctype(a)
#  define perl_new_collate(a)		new_collate(a)
#  define perl_new_numeric(a)		new_numeric(a)

/* varargs functions can't be handled with CPP macros. :-(
   This provides a set of compatibility functions that don't take
   an extra argument but grab the context pointer using the macro
   dTHX.
 */
#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_NO_SHORT_NAMES)
#  define croak				Perl_croak_nocontext
#  define deb				Perl_deb_nocontext
#  define die				Perl_die_nocontext
#  define form				Perl_form_nocontext
#  define load_module			Perl_load_module_nocontext
#  define mess				Perl_mess_nocontext
#  define newSVpvf			Perl_newSVpvf_nocontext
#  define sv_catpvf			Perl_sv_catpvf_nocontext
#  define sv_setpvf			Perl_sv_setpvf_nocontext
#  define warn				Perl_warn_nocontext
#  define warner			Perl_warner_nocontext
#  define sv_catpvf_mg			Perl_sv_catpvf_mg_nocontext
#  define sv_setpvf_mg			Perl_sv_setpvf_mg_nocontext
#endif

#endif /* !defined(PERL_CORE) && !defined(PERL_NOCOMPAT) */

#if !defined(PERL_IMPLICIT_CONTEXT)
/* undefined symbols, point them back at the usual ones */
#  define Perl_croak_nocontext		Perl_croak
#  define Perl_die_nocontext		Perl_die
#  define Perl_deb_nocontext		Perl_deb
#  define Perl_form_nocontext		Perl_form
#  define Perl_load_module_nocontext	Perl_load_module
#  define Perl_mess_nocontext		Perl_mess
#  define Perl_newSVpvf_nocontext	Perl_newSVpvf
#  define Perl_sv_catpvf_nocontext	Perl_sv_catpvf
#  define Perl_sv_setpvf_nocontext	Perl_sv_setpvf
#  define Perl_warn_nocontext		Perl_warn
#  define Perl_warner_nocontext		Perl_warner
#  define Perl_sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg
#  define Perl_sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg
#endif

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\fakesdio.h ===
/*    fakestdio.h
 *
 *    Copyright (C) 2000, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * This is "source level" stdio compatibility mode.
 * We try and #define stdio functions in terms of PerlIO.
 */
#define _CANNOT "CANNOT"
#undef FILE
#define FILE			PerlIO
#undef clearerr
#undef fclose
#undef fdopen
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fileno
#undef flockfile
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef ftrylockfile
#undef funlockfile
#undef fwrite
#undef getc
#undef getc_unlocked
#undef getw
#undef pclose
#undef popen
#undef putc
#undef putc_unlocked
#undef putw
#undef rewind
#undef setbuf
#undef setvbuf
#undef stderr
#undef stdin
#undef stdout
#undef tmpfile
#undef ungetc
#undef vfprintf
#undef printf

/* printf used to live in perl.h like this - more sophisticated 
   than the rest 
 */
#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
#define printf(fmt,args...) PerlIO_stdoutf(fmt,##args)
#else
#define printf PerlIO_stdoutf
#endif

#define fprintf			PerlIO_printf
#define stdin			PerlIO_stdin()
#define stdout			PerlIO_stdout()
#define stderr			PerlIO_stderr()
#define tmpfile()		PerlIO_tmpfile()
#define fclose(f)		PerlIO_close(f)
#define fflush(f)		PerlIO_flush(f)
#define fopen(p,m)		PerlIO_open(p,m)
#define vfprintf(f,fmt,a)	PerlIO_vprintf(f,fmt,a)
#define fgetc(f)		PerlIO_getc(f)
#define fputc(c,f)		PerlIO_putc(f,c)
#define fputs(s,f)		PerlIO_puts(f,s)
#define getc(f)			PerlIO_getc(f)
#define getc_unlocked(f)	PerlIO_getc(f)
#define putc(c,f)		PerlIO_putc(f,c)
#define putc_unlocked(c,f)	PerlIO_putc(c,f)
#define ungetc(c,f)		PerlIO_ungetc(f,c)
#if 0
/* return values of read/write need work */
#define fread(b,s,c,f)		PerlIO_read(f,b,(s*c))
#define fwrite(b,s,c,f)		PerlIO_write(f,b,(s*c))
#else
#define fread(b,s,c,f)		_CANNOT fread
#define fwrite(b,s,c,f)		_CANNOT fwrite
#endif
#define fseek(f,o,w)		PerlIO_seek(f,o,w)
#define ftell(f)		PerlIO_tell(f)
#define rewind(f)		PerlIO_rewind(f)
#define clearerr(f)		PerlIO_clearerr(f)
#define feof(f)			PerlIO_eof(f)
#define ferror(f)		PerlIO_error(f)
#define fdopen(fd,p)		PerlIO_fdopen(fd,p)
#define fileno(f)		PerlIO_fileno(f)
#define popen(c,m)		my_popen(c,m)
#define pclose(f)		my_pclose(f)

#define fsetpos(f,p)		_CANNOT _fsetpos_
#define fgetpos(f,p)		_CANNOT _fgetpos_

#define __filbuf(f)		_CANNOT __filbuf_
#define _filbuf(f)		_CANNOT _filbuf_
#define __flsbuf(c,f)		_CANNOT __flsbuf_
#define _flsbuf(c,f)		_CANNOT _flsbuf_
#define getw(f)			_CANNOT _getw_
#define putw(v,f)		_CANNOT _putw_
#if SFIO_VERSION < 20000101L
#define flockfile(f)		_CANNOT _flockfile_
#define ftrylockfile(f)		_CANNOT _ftrylockfile_
#define funlockfile(f)		_CANNOT _funlockfile_
#endif
#define freopen(p,m,f)		_CANNOT _freopen_
#define setbuf(f,b)		_CANNOT _setbuf_
#define setvbuf(f,b,x,s)	_CANNOT _setvbuf_
#define fscanf			_CANNOT _fscanf_
#define fgets(s,n,f)		_CANNOT _fgets_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\EXTERN.h ===
/*    EXTERN.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * EXT  designates a global var which is defined in perl.h
 * dEXT designates a global var which is defined in another
 *      file, so we can't count on finding it in perl.h
 *      (this practice should be avoided).
 */
#undef EXT
#undef dEXT
#undef EXTCONST
#undef dEXTCONST
#if defined(VMS) && !defined(__GNUC__)
    /* Suppress portability warnings from DECC for VMS-specific extensions */
#  ifdef __DECC
#    pragma message disable (GLOBALEXT,NOSHAREEXT,READONLYEXT)
#  endif
#  define EXT globalref
#  define dEXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define EXTCONST globalref
#  define dEXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#else
#  if (defined(WIN32) || defined(__SYMBIAN32__)) && !defined(PERL_STATIC_SYMS)
#    if defined(PERLDLL) || defined(__SYMBIAN32__)
#      define EXT extern __declspec(dllexport)
#      define dEXT 
#      define EXTCONST extern __declspec(dllexport) const
#      define dEXTCONST const
#    else
#      define EXT extern __declspec(dllimport)
#      define dEXT 
#      define EXTCONST extern __declspec(dllimport) const
#      define dEXTCONST const
#    endif
#  else
#    if defined(__CYGWIN__) && defined(USEIMPORTLIB)
#      define EXT extern __declspec(dllimport)
#      define dEXT 
#      define EXTCONST extern __declspec(dllimport) const
#      define dEXTCONST const
#    else
#      define EXT extern
#      define dEXT
#      define EXTCONST extern const
#      define dEXTCONST const
#    endif
#  endif
#endif

#undef INIT
#define INIT(x)

#undef DOINIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\fakethr.h ===
/*    fakethr.h
 *
 *    Copyright (C) 1999, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

typedef int perl_mutex;
typedef int perl_key;

typedef struct perl_thread *perl_os_thread;
/* With fake threads, thr is global(ish) so we don't need dTHR */
#define dTHR extern int errno

struct perl_wait_queue {
    struct perl_thread *	thread;
    struct perl_wait_queue *	next;
};
typedef struct perl_wait_queue *perl_cond;

/* Ask thread.h to include our per-thread extras */
#define HAVE_THREAD_INTERN
struct thread_intern {
    perl_os_thread next_run, prev_run;  /* Linked list of runnable threads */
    perl_cond   wait_queue;             /* Wait queue that we are waiting on */
    IV          private;                /* Holds data across time slices */
    I32         savemark;               /* Holds MARK for thread join values */
};

#define init_thread_intern(t) 				\
    STMT_START {					\
	t->self = (t);					\
	(t)->i.next_run = (t)->i.prev_run = (t);	\
	(t)->i.wait_queue = 0;				\
	(t)->i.private = 0;				\
    } STMT_END

/*
 * Note that SCHEDULE() is only callable from pp code (which
 * must be expecting to be restarted). We'll have to do
 * something a bit different for XS code.
 */

#define SCHEDULE() return schedule(), PL_op

#define MUTEX_LOCK(m)
#define MUTEX_UNLOCK(m)
#define MUTEX_INIT(m)
#define MUTEX_DESTROY(m)
#define COND_INIT(c) perl_cond_init(c)
#define COND_SIGNAL(c) perl_cond_signal(c)
#define COND_BROADCAST(c) perl_cond_broadcast(c)
#define COND_WAIT(c, m)		\
    STMT_START {		\
	perl_cond_wait(c);	\
	SCHEDULE();		\
    } STMT_END
#define COND_DESTROY(c)

#define THREAD_CREATE(t, f)	f((t))
#define THREAD_POST_CREATE(t)	NOOP

#define YIELD	NOOP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\form.h ===
/*    form.h
 *
 *    Copyright (C) 1991, 1992, 1993, 2000, 2004 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define FF_END          0
#define FF_LINEMARK     1
#define FF_LITERAL      2
#define FF_SKIP         3
#define FF_FETCH        4
#define FF_CHECKNL      5
#define FF_CHECKCHOP    6
#define FF_SPACE        7
#define FF_HALFSPACE    8
#define FF_ITEM         9
#define FF_CHOP         10
#define FF_LINEGLOB     11
#define FF_DECIMAL      12
#define FF_NEWLINE      13
#define FF_BLANK        14
#define FF_MORE         15
#define FF_0DECIMAL     16
#define FF_LINESNGL     17
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\handy.h ===
/*    handy.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if !defined(__STDC__)
#ifdef NULL
#undef NULL
#endif
#ifndef I286
#  define NULL 0
#else
#  define NULL 0L
#endif
#endif

#define Null(type) ((type)NULL)

/*
=head1 Handy Values

=for apidoc AmU||Nullch
Null character pointer.

=for apidoc AmU||Nullsv
Null SV pointer.

=cut
*/

#define Nullch Null(char*)
#define Nullfp Null(PerlIO*)
#define Nullsv Null(SV*)

#ifdef TRUE
#undef TRUE
#endif
#ifdef FALSE
#undef FALSE
#endif
#define TRUE (1)
#define FALSE (0)


/* XXX Configure ought to have a test for a boolean type, if I can
   just figure out all the headers such a test needs.
   Andy Dougherty	August 1996
*/
/* bool is built-in for g++-2.6.3 and later, which might be used
   for extensions.  <_G_config.h> defines _G_HAVE_BOOL, but we can't
   be sure _G_config.h will be included before this file.  _G_config.h
   also defines _G_HAVE_BOOL for both gcc and g++, but only g++
   actually has bool.  Hence, _G_HAVE_BOOL is pretty useless for us.
   g++ can be identified by __GNUG__.
   Andy Dougherty	February 2000
*/
#ifdef __GNUG__		/* GNU g++ has bool built-in */
#  ifndef HAS_BOOL
#    define HAS_BOOL 1
#  endif
#endif

/* The NeXT dynamic loader headers will not build with the bool macro
   So declare them now to clear confusion.
*/
#if defined(NeXT) || defined(__NeXT__)
# undef FALSE
# undef TRUE
  typedef enum bool { FALSE = 0, TRUE = 1 } bool;
# define ENUM_BOOL 1
# ifndef HAS_BOOL
#  define HAS_BOOL 1
# endif /* !HAS_BOOL */
#endif /* NeXT || __NeXT__ */

#ifndef HAS_BOOL
# if defined(UTS) || defined(VMS)
#  define bool int
# else
#  define bool char
# endif
# define HAS_BOOL 1
#endif

/* Try to figure out __func__ or __FUNCTION__ equivalent, if any.
 * XXX Should really be a Configure probe, with HAS__FUNCTION__
 *     and FUNCTION__ as results.
 * XXX Similarly, a Configure probe for __FILE__ and __LINE__ is needed. */
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || (defined(__SUNPRO_C)) /* C99 or close enough. */
#  define FUNCTION__ __func__
#else
#  if (defined(_MSC_VER) && _MSC_VER < 1300) || /* Pre-MSVC 7.0 has neither __func__ nor __FUNCTION and no good workarounds, either. */ \
      (defined(__DECC_VER)) /* Tru64 or VMS, and strict C89 being used, but not modern enough cc (in Tur64, -c99 not known, only -std1). */
#    define FUNCTION__ ""
#  else
#    define FUNCTION__ __FUNCTION__ /* Common extension. */
#  endif
#endif

/* XXX A note on the perl source internal type system.  The
   original intent was that I32 be *exactly* 32 bits.

   Currently, we only guarantee that I32 is *at least* 32 bits.
   Specifically, if int is 64 bits, then so is I32.  (This is the case
   for the Cray.)  This has the advantage of meshing nicely with
   standard library calls (where we pass an I32 and the library is
   expecting an int), but the disadvantage that an I32 is not 32 bits.
   Andy Dougherty	August 1996

   There is no guarantee that there is *any* integral type with
   exactly 32 bits.  It is perfectly legal for a system to have
   sizeof(short) == sizeof(int) == sizeof(long) == 8.

   Similarly, there is no guarantee that I16 and U16 have exactly 16
   bits.

   For dealing with issues that may arise from various 32/64-bit
   systems, we will ask Configure to check out

	SHORTSIZE == sizeof(short)
	INTSIZE == sizeof(int)
	LONGSIZE == sizeof(long)
	LONGLONGSIZE == sizeof(long long) (if HAS_LONG_LONG)
	PTRSIZE == sizeof(void *)
	DOUBLESIZE == sizeof(double)
	LONG_DOUBLESIZE == sizeof(long double) (if HAS_LONG_DOUBLE).

*/

#ifdef I_INTTYPES /* e.g. Linux has int64_t without <inttypes.h> */
#   include <inttypes.h>
#   ifdef INT32_MIN_BROKEN
#       undef  INT32_MIN
#       define INT32_MIN (-2147483647-1)
#   endif
#   ifdef INT64_MIN_BROKEN
#       undef  INT64_MIN
#       define INT64_MIN (-9223372036854775807LL-1)
#   endif
#endif

typedef I8TYPE I8;
typedef U8TYPE U8;
typedef I16TYPE I16;
typedef U16TYPE U16;
typedef I32TYPE I32;
typedef U32TYPE U32;
#ifdef PERL_CORE
#   ifdef HAS_QUAD
typedef I64TYPE I64;
typedef U64TYPE U64;
#   endif
#endif /* PERL_CORE */

#if defined(HAS_QUAD) && defined(USE_64_BIT_INT)
#   ifndef UINT64_C /* usually from <inttypes.h> */
#       if defined(HAS_LONG_LONG) && QUADKIND == QUAD_IS_LONG_LONG
#           define INT64_C(c)	CAT2(c,LL)
#           define UINT64_C(c)	CAT2(c,ULL)
#       else
#           if LONGSIZE == 8 && QUADKIND == QUAD_IS_LONG
#               define INT64_C(c)	CAT2(c,L)
#               define UINT64_C(c)	CAT2(c,UL)
#           else
#               define INT64_C(c)	((I64TYPE)(c))
#               define UINT64_C(c)	((U64TYPE)(c))
#           endif
#       endif
#   endif
#endif

/* HMB H.Merijn Brand - a placeholder for preparing Configure patches */
#if defined(HAS_MALLOC_SIZE) && defined(LOCALTIME_R_NEEDS_TZSET) && defined(HAS_PSEUDOFORK)
/* Not (yet) used at top level, but mention them for metaconfig */
#endif

/* Mention I8SIZE, U8SIZE, I16SIZE, U16SIZE, I32SIZE, U32SIZE,
   I64SIZE, and U64SIZE here so that metaconfig pulls them in. */

#if defined(UINT8_MAX) && defined(INT16_MAX) && defined(INT32_MAX)

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX UINT8_MAX
#define U8_MIN UINT8_MIN

#define I16_MAX INT16_MAX
#define I16_MIN INT16_MIN
#define U16_MAX UINT16_MAX
#define U16_MIN UINT16_MIN

#define I32_MAX INT32_MAX
#define I32_MIN INT32_MIN
#ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#  define U32_MAX UINT32_MAX
#else
#  define U32_MAX 4294967295U
#endif
#define U32_MIN UINT32_MIN

#else

/* I8_MAX and I8_MIN constants are not defined, as I8 is an ambiguous type.
   Please search CHAR_MAX in perl.h for further details. */
#define U8_MAX PERL_UCHAR_MAX
#define U8_MIN PERL_UCHAR_MIN

#define I16_MAX PERL_SHORT_MAX
#define I16_MIN PERL_SHORT_MIN
#define U16_MAX PERL_USHORT_MAX
#define U16_MIN PERL_USHORT_MIN

#if LONGSIZE > 4
# define I32_MAX PERL_INT_MAX
# define I32_MIN PERL_INT_MIN
# define U32_MAX PERL_UINT_MAX
# define U32_MIN PERL_UINT_MIN
#else
# define I32_MAX PERL_LONG_MAX
# define I32_MIN PERL_LONG_MIN
# define U32_MAX PERL_ULONG_MAX
# define U32_MIN PERL_ULONG_MIN
#endif

#endif

/* log(2) is pretty close to  0.30103, just in case anyone is grepping for it */
#define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
#define TYPE_DIGITS(T)  BIT_DIGITS(sizeof(T) * 8)
#define TYPE_CHARS(T)   (TYPE_DIGITS(T) + 2) /* sign, NUL */

#define Ctl(ch) ((ch) & 037)

/*
=head1 SV-Body Allocation

=for apidoc Ama|SV*|newSVpvs|const char* s
Like C<newSVpvn>, but takes a literal string instead of a string/length pair.

=for apidoc Ama|SV*|newSVpvs_share|const char* s
Like C<newSVpvn_share>, but takes a literal string instead of a string/length
pair and omits the hash parameter.

=for apidoc Am|void|sv_catpvs|SV* sv|const char* s
Like C<sv_catpvn>, but takes a literal string instead of a string/length pair.

=for apidoc Am|void|sv_setpvs|SV* sv|const char* s
Like C<sv_setpvn>, but takes a literal string instead of a string/length pair.

=head1 Memory Management

=for apidoc Ama|char*|savepvs|const char* s
Like C<savepvn>, but takes a literal string instead of a string/length pair.

=head1 GV Functions

=for apidoc Am|HV*|gv_stashpvs|const char* name|I32 create
Like C<gv_stashpvn>, but takes a literal string instead of a string/length pair.

=head1 Hash Manipulation Functions

=for apidoc Am|SV**|hv_fetchs|HV* tb|const char* key|I32 lval
Like C<hv_fetch>, but takes a literal string instead of a string/length pair.

=for apidoc Am|SV**|hv_stores|HV* tb|const char* key|NULLOK SV* val
Like C<hv_store>, but takes a literal string instead of a string/length pair
and omits the hash parameter.

=cut
*/

/* concatenating with "" ensures that only literal strings are accepted as argument */
#define STR_WITH_LEN(s)  (s ""), (sizeof(s)-1)

/* note that STR_WITH_LEN() can't be used as argument to macros or functions that
 * under some configurations might be macros, which means that it requires the full
 * Perl_xxx(aTHX_ ...) form for any API calls where it's used.
 */

/* STR_WITH_LEN() shortcuts */
#define newSVpvs(str) Perl_newSVpvn(aTHX_ STR_WITH_LEN(str))
#define newSVpvs_share(str) Perl_newSVpvn_share(aTHX_ STR_WITH_LEN(str), 0)
#define sv_catpvs(sv, str) Perl_sv_catpvn_flags(aTHX_ sv, STR_WITH_LEN(str), SV_GMAGIC)
#define sv_setpvs(sv, str) Perl_sv_setpvn(aTHX_ sv, STR_WITH_LEN(str))
#define savepvs(str) Perl_savepvn(aTHX_ STR_WITH_LEN(str))
#define gv_stashpvs(str, create) Perl_gv_stashpvn(aTHX_ STR_WITH_LEN(str), create)
#define gv_fetchpvs(namebeg, add, sv_type) Perl_gv_fetchpvn_flags(aTHX_ STR_WITH_LEN(namebeg), add, sv_type)
#define hv_fetchs(hv,key,lval)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (lval) ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			 : HV_FETCH_JUST_SV, NULL, 0))

#define hv_stores(hv,key,val)						\
  ((SV **)Perl_hv_common(aTHX_ (hv), NULL, STR_WITH_LEN(key), 0,	\
			 (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (val), 0))


/*
=head1 Miscellaneous Functions

=for apidoc Am|bool|strNE|char* s1|char* s2
Test two strings to see if they are different.  Returns true or
false.

=for apidoc Am|bool|strEQ|char* s1|char* s2
Test two strings to see if they are equal.  Returns true or false.

=for apidoc Am|bool|strLT|char* s1|char* s2
Test two strings to see if the first, C<s1>, is less than the second,
C<s2>.  Returns true or false.

=for apidoc Am|bool|strLE|char* s1|char* s2
Test two strings to see if the first, C<s1>, is less than or equal to the
second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strGT|char* s1|char* s2
Test two strings to see if the first, C<s1>, is greater than the second,
C<s2>.  Returns true or false.

=for apidoc Am|bool|strGE|char* s1|char* s2
Test two strings to see if the first, C<s1>, is greater than or equal to
the second, C<s2>.  Returns true or false.

=for apidoc Am|bool|strnNE|char* s1|char* s2|STRLEN len
Test two strings to see if they are different.  The C<len> parameter
indicates the number of bytes to compare.  Returns true or false. (A
wrapper for C<strncmp>).

=for apidoc Am|bool|strnEQ|char* s1|char* s2|STRLEN len
Test two strings to see if they are equal.  The C<len> parameter indicates
the number of bytes to compare.  Returns true or false. (A wrapper for
C<strncmp>).

=cut
*/

#define strNE(s1,s2) (strcmp(s1,s2))
#define strEQ(s1,s2) (!strcmp(s1,s2))
#define strLT(s1,s2) (strcmp(s1,s2) < 0)
#define strLE(s1,s2) (strcmp(s1,s2) <= 0)
#define strGT(s1,s2) (strcmp(s1,s2) > 0)
#define strGE(s1,s2) (strcmp(s1,s2) >= 0)
#define strnNE(s1,s2,l) (strncmp(s1,s2,l))
#define strnEQ(s1,s2,l) (!strncmp(s1,s2,l))

#ifdef HAS_MEMCMP
#  define memNE(s1,s2,l) (memcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!memcmp(s1,s2,l))
#else
#  define memNE(s1,s2,l) (bcmp(s1,s2,l))
#  define memEQ(s1,s2,l) (!bcmp(s1,s2,l))
#endif

#define memEQs(s1, l, s2) \
	(sizeof(s2)-1 == l && memEQ(s1, (s2 ""), (sizeof(s2)-1)))
#define memNEs(s1, l, s2) !memEQs(s1, l, s2)

/*
 * Character classes.
 *
 * Unfortunately, the introduction of locales means that we
 * can't trust isupper(), etc. to tell the truth.  And when
 * it comes to /\w+/ with tainting enabled, we *must* be able
 * to trust our character classes.
 *
 * Therefore, the default tests in the text of Perl will be
 * independent of locale.  Any code that wants to depend on
 * the current locale will use the tests that begin with "lc".
 */

#ifdef HAS_SETLOCALE  /* XXX Is there a better test for this? */
#  ifndef CTYPE256
#    define CTYPE256
#  endif
#endif

/*

=head1 Character classes

=for apidoc Am|bool|isALNUM|char ch
Returns a boolean indicating whether the C C<char> is an ASCII alphanumeric
character (including underscore) or digit.

=for apidoc Am|bool|isALPHA|char ch
Returns a boolean indicating whether the C C<char> is an ASCII alphabetic
character.

=for apidoc Am|bool|isSPACE|char ch
Returns a boolean indicating whether the C C<char> is whitespace.

=for apidoc Am|bool|isDIGIT|char ch
Returns a boolean indicating whether the C C<char> is an ASCII
digit.

=for apidoc Am|bool|isUPPER|char ch
Returns a boolean indicating whether the C C<char> is an uppercase
character.

=for apidoc Am|bool|isLOWER|char ch
Returns a boolean indicating whether the C C<char> is a lowercase
character.

=for apidoc Am|char|toUPPER|char ch
Converts the specified character to uppercase.

=for apidoc Am|char|toLOWER|char ch
Converts the specified character to lowercase.

=cut
*/

#define isALNUM(c)	(isALPHA(c) || isDIGIT(c) || (c) == '_')
#define isIDFIRST(c)	(isALPHA(c) || (c) == '_')
#define isALPHA(c)	(isUPPER(c) || isLOWER(c))
#define isSPACE(c) \
	((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) =='\r' || (c) == '\f')
#define isPSXSPC(c)	(isSPACE(c) || (c) == '\v')
#define isBLANK(c)	((c) == ' ' || (c) == '\t')
#define isDIGIT(c)	((c) >= '0' && (c) <= '9')
#ifdef EBCDIC
    /* In EBCDIC we do not do locales: therefore() isupper() is fine. */
#   define isUPPER(c)	isupper(c)
#   define isLOWER(c)	islower(c)
#   define isALNUMC(c)	isalnum(c)
#   define isASCII(c)	isascii(c)
#   define isCNTRL(c)	iscntrl(c)
#   define isGRAPH(c)	isgraph(c)
#   define isPRINT(c)	isprint(c)
#   define isPUNCT(c)	ispunct(c)
#   define isXDIGIT(c)	isxdigit(c)
#   define toUPPER(c)	toupper(c)
#   define toLOWER(c)	tolower(c)
#else
#   define isUPPER(c)	((c) >= 'A' && (c) <= 'Z')
#   define isLOWER(c)	((c) >= 'a' && (c) <= 'z')
#   define isALNUMC(c)	(isALPHA(c) || isDIGIT(c))
#   define isASCII(c)	((c) <= 127)
#   define isCNTRL(c)	((c) < ' ' || (c) == 127)
#   define isGRAPH(c)	(isALNUM(c) || isPUNCT(c))
#   define isPRINT(c)	(((c) >= 32 && (c) < 127))
#   define isPUNCT(c)	(((c) >= 33 && (c) <= 47) || ((c) >= 58 && (c) <= 64)  || ((c) >= 91 && (c) <= 96) || ((c) >= 123 && (c) <= 126))
#   define isXDIGIT(c)  (isDIGIT(c) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
#   define toUPPER(c)	(isLOWER(c) ? (c) - ('a' - 'A') : (c))
#   define toLOWER(c)	(isUPPER(c) ? (c) + ('a' - 'A') : (c))
#endif

#ifdef USE_NEXT_CTYPE

#  define isALNUM_LC(c) \
	(NXIsAlNum((unsigned int)(c)) || (char)(c) == '_')
#  define isIDFIRST_LC(c) \
	(NXIsAlpha((unsigned int)(c)) || (char)(c) == '_')
#  define isALPHA_LC(c)		NXIsAlpha((unsigned int)(c))
#  define isSPACE_LC(c)		NXIsSpace((unsigned int)(c))
#  define isDIGIT_LC(c)		NXIsDigit((unsigned int)(c))
#  define isUPPER_LC(c)		NXIsUpper((unsigned int)(c))
#  define isLOWER_LC(c)		NXIsLower((unsigned int)(c))
#  define isALNUMC_LC(c)	NXIsAlNum((unsigned int)(c))
#  define isCNTRL_LC(c)		NXIsCntrl((unsigned int)(c))
#  define isGRAPH_LC(c)		NXIsGraph((unsigned int)(c))
#  define isPRINT_LC(c)		NXIsPrint((unsigned int)(c))
#  define isPUNCT_LC(c)		NXIsPunct((unsigned int)(c))
#  define toUPPER_LC(c)		NXToUpper((unsigned int)(c))
#  define toLOWER_LC(c)		NXToLower((unsigned int)(c))

#else /* !USE_NEXT_CTYPE */

#  if defined(CTYPE256) || (!defined(isascii) && !defined(HAS_ISASCII))

#    define isALNUM_LC(c)   (isalnum((unsigned char)(c)) || (char)(c) == '_')
#    define isIDFIRST_LC(c) (isalpha((unsigned char)(c)) || (char)(c) == '_')
#    define isALPHA_LC(c)	isalpha((unsigned char)(c))
#    define isSPACE_LC(c)	isspace((unsigned char)(c))
#    define isDIGIT_LC(c)	isdigit((unsigned char)(c))
#    define isUPPER_LC(c)	isupper((unsigned char)(c))
#    define isLOWER_LC(c)	islower((unsigned char)(c))
#    define isALNUMC_LC(c)	isalnum((unsigned char)(c))
#    define isCNTRL_LC(c)	iscntrl((unsigned char)(c))
#    define isGRAPH_LC(c)	isgraph((unsigned char)(c))
#    define isPRINT_LC(c)	isprint((unsigned char)(c))
#    define isPUNCT_LC(c)	ispunct((unsigned char)(c))
#    define toUPPER_LC(c)	toupper((unsigned char)(c))
#    define toLOWER_LC(c)	tolower((unsigned char)(c))

#  else

#    define isALNUM_LC(c)	(isascii(c) && (isalnum(c) || (c) == '_'))
#    define isIDFIRST_LC(c)	(isascii(c) && (isalpha(c) || (c) == '_'))
#    define isALPHA_LC(c)	(isascii(c) && isalpha(c))
#    define isSPACE_LC(c)	(isascii(c) && isspace(c))
#    define isDIGIT_LC(c)	(isascii(c) && isdigit(c))
#    define isUPPER_LC(c)	(isascii(c) && isupper(c))
#    define isLOWER_LC(c)	(isascii(c) && islower(c))
#    define isALNUMC_LC(c)	(isascii(c) && isalnum(c))
#    define isCNTRL_LC(c)	(isascii(c) && iscntrl(c))
#    define isGRAPH_LC(c)	(isascii(c) && isgraph(c))
#    define isPRINT_LC(c)	(isascii(c) && isprint(c))
#    define isPUNCT_LC(c)	(isascii(c) && ispunct(c))
#    define toUPPER_LC(c)	toupper(c)
#    define toLOWER_LC(c)	tolower(c)

#  endif
#endif /* USE_NEXT_CTYPE */

#define isPSXSPC_LC(c)		(isSPACE_LC(c) || (c) == '\v')
#define isBLANK_LC(c)		isBLANK(c) /* could be wrong */

#define isALNUM_uni(c)		is_uni_alnum(c)
#define isIDFIRST_uni(c)	is_uni_idfirst(c)
#define isALPHA_uni(c)		is_uni_alpha(c)
#define isSPACE_uni(c)		is_uni_space(c)
#define isDIGIT_uni(c)		is_uni_digit(c)
#define isUPPER_uni(c)		is_uni_upper(c)
#define isLOWER_uni(c)		is_uni_lower(c)
#define isALNUMC_uni(c)		is_uni_alnumc(c)
#define isASCII_uni(c)		is_uni_ascii(c)
#define isCNTRL_uni(c)		is_uni_cntrl(c)
#define isGRAPH_uni(c)		is_uni_graph(c)
#define isPRINT_uni(c)		is_uni_print(c)
#define isPUNCT_uni(c)		is_uni_punct(c)
#define isXDIGIT_uni(c)		is_uni_xdigit(c)
#define toUPPER_uni(c,s,l)	to_uni_upper(c,s,l)
#define toTITLE_uni(c,s,l)	to_uni_title(c,s,l)
#define toLOWER_uni(c,s,l)	to_uni_lower(c,s,l)
#define toFOLD_uni(c,s,l)	to_uni_fold(c,s,l)

#define isPSXSPC_uni(c)		(isSPACE_uni(c) ||(c) == '\f')
#define isBLANK_uni(c)		isBLANK(c) /* could be wrong */

#define isALNUM_LC_uvchr(c)	(c < 256 ? isALNUM_LC(c) : is_uni_alnum_lc(c))
#define isIDFIRST_LC_uvchr(c)	(c < 256 ? isIDFIRST_LC(c) : is_uni_idfirst_lc(c))
#define isALPHA_LC_uvchr(c)	(c < 256 ? isALPHA_LC(c) : is_uni_alpha_lc(c))
#define isSPACE_LC_uvchr(c)	(c < 256 ? isSPACE_LC(c) : is_uni_space_lc(c))
#define isDIGIT_LC_uvchr(c)	(c < 256 ? isDIGIT_LC(c) : is_uni_digit_lc(c))
#define isUPPER_LC_uvchr(c)	(c < 256 ? isUPPER_LC(c) : is_uni_upper_lc(c))
#define isLOWER_LC_uvchr(c)	(c < 256 ? isLOWER_LC(c) : is_uni_lower_lc(c))
#define isALNUMC_LC_uvchr(c)	(c < 256 ? isALNUMC_LC(c) : is_uni_alnumc_lc(c))
#define isCNTRL_LC_uvchr(c)	(c < 256 ? isCNTRL_LC(c) : is_uni_cntrl_lc(c))
#define isGRAPH_LC_uvchr(c)	(c < 256 ? isGRAPH_LC(c) : is_uni_graph_lc(c))
#define isPRINT_LC_uvchr(c)	(c < 256 ? isPRINT_LC(c) : is_uni_print_lc(c))
#define isPUNCT_LC_uvchr(c)	(c < 256 ? isPUNCT_LC(c) : is_uni_punct_lc(c))

#define isPSXSPC_LC_uni(c)	(isSPACE_LC_uni(c) ||(c) == '\f')
#define isBLANK_LC_uni(c)	isBLANK(c) /* could be wrong */

#define isALNUM_utf8(p)		is_utf8_alnum(p)
/* The ID_Start of Unicode is quite limiting: it assumes a L-class
 * character (meaning that you cannot have, say, a CJK character).
 * Instead, let's allow ID_Continue but not digits. */
#define isIDFIRST_utf8(p)	(is_utf8_idcont(p) && !is_utf8_digit(p))
#define isALPHA_utf8(p)		is_utf8_alpha(p)
#define isSPACE_utf8(p)		is_utf8_space(p)
#define isDIGIT_utf8(p)		is_utf8_digit(p)
#define isUPPER_utf8(p)		is_utf8_upper(p)
#define isLOWER_utf8(p)		is_utf8_lower(p)
#define isALNUMC_utf8(p)	is_utf8_alnumc(p)
#define isASCII_utf8(p)		is_utf8_ascii(p)
#define isCNTRL_utf8(p)		is_utf8_cntrl(p)
#define isGRAPH_utf8(p)		is_utf8_graph(p)
#define isPRINT_utf8(p)		is_utf8_print(p)
#define isPUNCT_utf8(p)		is_utf8_punct(p)
#define isXDIGIT_utf8(p)	is_utf8_xdigit(p)
#define toUPPER_utf8(p,s,l)	to_utf8_upper(p,s,l)
#define toTITLE_utf8(p,s,l)	to_utf8_title(p,s,l)
#define toLOWER_utf8(p,s,l)	to_utf8_lower(p,s,l)

#define isPSXSPC_utf8(c)	(isSPACE_utf8(c) ||(c) == '\f')
#define isBLANK_utf8(c)		isBLANK(c) /* could be wrong */

#define isALNUM_LC_utf8(p)	isALNUM_LC_uvchr(utf8_to_uvchr(p,  0))
#define isIDFIRST_LC_utf8(p)	isIDFIRST_LC_uvchr(utf8_to_uvchr(p,  0))
#define isALPHA_LC_utf8(p)	isALPHA_LC_uvchr(utf8_to_uvchr(p,  0))
#define isSPACE_LC_utf8(p)	isSPACE_LC_uvchr(utf8_to_uvchr(p,  0))
#define isDIGIT_LC_utf8(p)	isDIGIT_LC_uvchr(utf8_to_uvchr(p,  0))
#define isUPPER_LC_utf8(p)	isUPPER_LC_uvchr(utf8_to_uvchr(p,  0))
#define isLOWER_LC_utf8(p)	isLOWER_LC_uvchr(utf8_to_uvchr(p,  0))
#define isALNUMC_LC_utf8(p)	isALNUMC_LC_uvchr(utf8_to_uvchr(p,  0))
#define isCNTRL_LC_utf8(p)	isCNTRL_LC_uvchr(utf8_to_uvchr(p,  0))
#define isGRAPH_LC_utf8(p)	isGRAPH_LC_uvchr(utf8_to_uvchr(p,  0))
#define isPRINT_LC_utf8(p)	isPRINT_LC_uvchr(utf8_to_uvchr(p,  0))
#define isPUNCT_LC_utf8(p)	isPUNCT_LC_uvchr(utf8_to_uvchr(p,  0))

#define isPSXSPC_LC_utf8(c)	(isSPACE_LC_utf8(c) ||(c) == '\f')
#define isBLANK_LC_utf8(c)	isBLANK(c) /* could be wrong */

#ifdef EBCDIC
#  ifdef PERL_IMPLICIT_CONTEXT
#    define toCTRL(c)     Perl_ebcdic_control(aTHX_ c)
#  else
#    define toCTRL        Perl_ebcdic_control
#  endif
#else
  /* This conversion works both ways, strangely enough. */
#  define toCTRL(c)    (toUPPER(c) ^ 64)
#endif

/* Line numbers are unsigned, 32 bits. */
typedef U32 line_t;
#define NOLINE ((line_t) 4294967295UL)


/*
=head1 Memory Management

=for apidoc Am|void|Newx|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.

In 5.9.3, Newx() and friends replace the older New() API, and drops
the first parameter, I<x>, a debug aid which allowed callers to identify
themselves.  This aid has been superseded by a new build option,
PERL_MEM_LOG (see L<perlhack/PERL_MEM_LOG>).  The older API is still
there for use in XS modules supporting older perls.

=for apidoc Am|void|Newxc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<malloc> function, with
cast.  See also C<Newx>.

=for apidoc Am|void|Newxz|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<malloc> function.  The allocated
memory is zeroed with C<memzero>.  See also C<Newx>.

=for apidoc Am|void|Renew|void* ptr|int nitems|type
The XSUB-writer's interface to the C C<realloc> function.

=for apidoc Am|void|Renewc|void* ptr|int nitems|type|cast
The XSUB-writer's interface to the C C<realloc> function, with
cast.

=for apidoc Am|void|Safefree|void* ptr
The XSUB-writer's interface to the C C<free> function.

=for apidoc Am|void|Move|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memmove> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and C<type> is
the type.  Can do overlapping moves.  See also C<Copy>.

=for apidoc Am|void *|MoveD|void* src|void* dest|int nitems|type
Like C<Move> but returns dest. Useful for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|Copy|void* src|void* dest|int nitems|type
The XSUB-writer's interface to the C C<memcpy> function.  The C<src> is the
source, C<dest> is the destination, C<nitems> is the number of items, and C<type> is
the type.  May fail on overlapping copies.  See also C<Move>.

=for apidoc Am|void *|CopyD|void* src|void* dest|int nitems|type

Like C<Copy> but returns dest. Useful for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|Zero|void* dest|int nitems|type

The XSUB-writer's interface to the C C<memzero> function.  The C<dest> is the
destination, C<nitems> is the number of items, and C<type> is the type.

=for apidoc Am|void *|ZeroD|void* dest|int nitems|type

Like C<Zero> but returns dest. Useful for encouraging compilers to tail-call
optimise.

=for apidoc Am|void|StructCopy|type src|type dest|type
This is an architecture-independent macro to copy one structure to another.

=for apidoc Am|void|PoisonWith|void* dest|int nitems|type|U8 byte

Fill up memory with a byte pattern (a byte repeated over and over
again) that hopefully catches attempts to access uninitialized memory.

=for apidoc Am|void|PoisonNew|void* dest|int nitems|type

PoisonWith(0xAB) for catching access to allocated but uninitialized memory.

=for apidoc Am|void|PoisonFree|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=for apidoc Am|void|Poison|void* dest|int nitems|type

PoisonWith(0xEF) for catching access to freed memory.

=cut */

/* Maintained for backwards-compatibility only. Use newSV() instead. */
#ifndef PERL_CORE
#define NEWSV(x,len)	newSV(len)
#endif

#define MEM_SIZE_MAX ((MEM_SIZE)~0)

/* The +0.0 in MEM_WRAP_CHECK_ is an attempt to foil
 * overly eager compilers that will bleat about e.g.
 * (U16)n > (size_t)~0/sizeof(U16) always being false. */
#ifdef PERL_MALLOC_WRAP
#define MEM_WRAP_CHECK(n,t) MEM_WRAP_CHECK_1(n,t,PL_memory_wrap)
#define MEM_WRAP_CHECK_1(n,t,a) \
	(void)(sizeof(t) > 1 && ((MEM_SIZE)(n)+0.0) > MEM_SIZE_MAX/sizeof(t) && (Perl_croak_nocontext(a),0))
#define MEM_WRAP_CHECK_(n,t) MEM_WRAP_CHECK(n,t),

#define PERL_STRLEN_ROUNDUP(n) ((void)(((n) > MEM_SIZE_MAX - 2 * PERL_STRLEN_ROUNDUP_QUANTUM) ? (Perl_croak_nocontext(PL_memory_wrap),0):0),((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))

#else

#define MEM_WRAP_CHECK(n,t)
#define MEM_WRAP_CHECK_1(n,t,a)
#define MEM_WRAP_CHECK_2(n,t,a,b)
#define MEM_WRAP_CHECK_(n,t)

#define PERL_STRLEN_ROUNDUP(n) (((n-1+PERL_STRLEN_ROUNDUP_QUANTUM)&~((MEM_SIZE)PERL_STRLEN_ROUNDUP_QUANTUM-1)))

#endif

#ifdef PERL_MEM_LOG
/*
 * If PERL_MEM_LOG is defined, all Newx()s, Renew()s, and Safefree()s
 * go through functions, which are handy for debugging breakpoints, but
 * which more importantly get the immediate calling environment (file and
 * line number, and C function name if available) passed in.  This info can
 * then be used for logging the calls, for which one gets a sample
 * implementation if PERL_MEM_LOG_STDERR is defined.
 *
 * Known problems:
 * - all memory allocs do not get logged, only those
 *   that go through Newx() and derivatives (while all
 *  Safefrees do get logged)
 * - __FILE__ and __LINE__ do not work everywhere
 * - __func__ or __FUNCTION__ even less so
 * - I think more goes on after the perlio frees but
 *   the thing is that STDERR gets closed (as do all
 *   the file descriptors)
 * - no deeper calling stack than the caller of the Newx()
 *   or the kind, but do I look like a C reflection/introspection
 *   utility to you?
 * - the function prototypes for the logging functions
 *   probably should maybe be somewhere else than handy.h
 * - one could consider inlining (macrofying) the logging
 *   for speed, but I am too lazy
 * - one could imagine recording the allocations in a hash,
 *   (keyed by the allocation address?), and maintain that
 *   through reallocs and frees, but how to do that without
 *   any News() happening...?
 */

Malloc_t Perl_mem_log_alloc(const UV n, const UV typesize, const char *typename, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

Malloc_t Perl_mem_log_realloc(const UV n, const UV typesize, const char *typename, Malloc_t oldalloc, Malloc_t newalloc, const char *filename, const int linenumber, const char *funcname);

Malloc_t Perl_mem_log_free(Malloc_t oldalloc, const char *filename, const int linenumber, const char *funcname);

#endif

#ifdef PERL_MEM_LOG
#define MEM_LOG_ALLOC(n,t,a)     Perl_mem_log_alloc(n,sizeof(t),STRINGIFY(t),a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_REALLOC(n,t,v,a) Perl_mem_log_realloc(n,sizeof(t),STRINGIFY(t),v,a,__FILE__,__LINE__,FUNCTION__)
#define MEM_LOG_FREE(a)          Perl_mem_log_free(a,__FILE__,__LINE__,FUNCTION__)
#endif

#ifndef MEM_LOG_ALLOC
#define MEM_LOG_ALLOC(n,t,a)     (a)
#endif
#ifndef MEM_LOG_REALLOC
#define MEM_LOG_REALLOC(n,t,v,a) (a)
#endif
#ifndef MEM_LOG_FREE
#define MEM_LOG_FREE(a)          (a)
#endif

#define Newx(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(t*)safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxc(v,n,t,c)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(c*)safemalloc((MEM_SIZE)((n)*sizeof(t))))))
#define Newxz(v,n,t)	(v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_ALLOC(n,t,(t*)safecalloc((n),sizeof(t)))))

#ifndef PERL_CORE
/* pre 5.9.x compatibility */
#define New(x,v,n,t)	Newx(v,n,t)
#define Newc(x,v,n,t,c)	Newxc(v,n,t,c)
#define Newz(x,v,n,t)	Newxz(v,n,t)
#endif

#define Renew(v,n,t) \
	  (v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_REALLOC(n,t,v,(t*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))
#define Renewc(v,n,t,c) \
	  (v = (MEM_WRAP_CHECK_(n,t) MEM_LOG_REALLOC(n,t,v,(c*)saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))

#ifdef PERL_POISON
#define Safefree(d) \
  ((d) ? (void)(safefree(MEM_LOG_FREE((Malloc_t)(d))), Poison(&(d), 1, Malloc_t)) : (void) 0)
#else
#define Safefree(d)	safefree(MEM_LOG_FREE((Malloc_t)(d)))
#endif

#define Move(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Copy(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define Zero(d,n,t)	(MEM_WRAP_CHECK_(n,t) (void)memzero((char*)(d), (n) * sizeof(t)))

#define MoveD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memmove((char*)(d),(const char*)(s), (n) * sizeof(t)))
#define CopyD(s,d,n,t)	(MEM_WRAP_CHECK_(n,t) memcpy((char*)(d),(const char*)(s), (n) * sizeof(t)))
#ifdef HAS_MEMSET
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)))
#else
/* Using bzero(), which returns void.  */
#define ZeroD(d,n,t)	(MEM_WRAP_CHECK_(n,t) memzero((char*)(d), (n) * sizeof(t)),d)
#endif

#define PoisonWith(d,n,t,b)	(MEM_WRAP_CHECK_(n,t) (void)memset((char*)(d), (U8)(b), (n) * sizeof(t)))
#define PoisonNew(d,n,t)	PoisonWith(d,n,t,0xAB)
#define PoisonFree(d,n,t)	PoisonWith(d,n,t,0xEF)
#define Poison(d,n,t)		PoisonFree(d,n,t)

#ifdef USE_STRUCT_COPY
#define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s)))
#else
#define StructCopy(s,d,t) Copy(s,d,1,t)
#endif

#define C_ARRAY_LENGTH(a)	(sizeof(a)/sizeof((a)[0]))

#ifdef NEED_VA_COPY
# ifdef va_copy
#  define Perl_va_copy(s, d) va_copy(d, s)
# else
#  if defined(__va_copy)
#   define Perl_va_copy(s, d) __va_copy(d, s)
#  else
#   define Perl_va_copy(s, d) Copy(s, d, 1, va_list)
#  endif
# endif
#endif

/* convenience debug macros */
#ifdef USE_ITHREADS
#define pTHX_FORMAT  "Perl interpreter: 0x%p"
#define pTHX__FORMAT ", Perl interpreter: 0x%p"
#define pTHX_VALUE_   (void *)my_perl,
#define pTHX_VALUE    (void *)my_perl
#define pTHX__VALUE_ ,(void *)my_perl,
#define pTHX__VALUE  ,(void *)my_perl
#else
#define pTHX_FORMAT
#define pTHX__FORMAT
#define pTHX_VALUE_
#define pTHX_VALUE
#define pTHX__VALUE_
#define pTHX__VALUE
#endif /* USE_ITHREADS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\keywords.h ===
/* -*- buffer-read-only: t -*-
 *
 *    keywords.h
 *
 *    Copyright (C) 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2005,
 *    2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by keywords.pl from its data.  Any changes made here
 *  will be lost!
 */
#define KEY_NULL		0
#define KEY___FILE__		1
#define KEY___LINE__		2
#define KEY___PACKAGE__		3
#define KEY___DATA__		4
#define KEY___END__		5
#define KEY_AUTOLOAD		6
#define KEY_BEGIN		7
#define KEY_UNITCHECK		8
#define KEY_CORE		9
#define KEY_DESTROY		10
#define KEY_END			11
#define KEY_INIT		12
#define KEY_CHECK		13
#define KEY_abs			14
#define KEY_accept		15
#define KEY_alarm		16
#define KEY_and			17
#define KEY_atan2		18
#define KEY_bind		19
#define KEY_binmode		20
#define KEY_bless		21
#define KEY_break		22
#define KEY_caller		23
#define KEY_chdir		24
#define KEY_chmod		25
#define KEY_chomp		26
#define KEY_chop		27
#define KEY_chown		28
#define KEY_chr			29
#define KEY_chroot		30
#define KEY_close		31
#define KEY_closedir		32
#define KEY_cmp			33
#define KEY_connect		34
#define KEY_continue		35
#define KEY_cos			36
#define KEY_crypt		37
#define KEY_dbmclose		38
#define KEY_dbmopen		39
#define KEY_default		40
#define KEY_defined		41
#define KEY_delete		42
#define KEY_die			43
#define KEY_do			44
#define KEY_dump		45
#define KEY_each		46
#define KEY_else		47
#define KEY_elsif		48
#define KEY_endgrent		49
#define KEY_endhostent		50
#define KEY_endnetent		51
#define KEY_endprotoent		52
#define KEY_endpwent		53
#define KEY_endservent		54
#define KEY_eof			55
#define KEY_eq			56
#define KEY_eval		57
#define KEY_exec		58
#define KEY_exists		59
#define KEY_exit		60
#define KEY_exp			61
#define KEY_fcntl		62
#define KEY_fileno		63
#define KEY_flock		64
#define KEY_for			65
#define KEY_foreach		66
#define KEY_fork		67
#define KEY_format		68
#define KEY_formline		69
#define KEY_ge			70
#define KEY_getc		71
#define KEY_getgrent		72
#define KEY_getgrgid		73
#define KEY_getgrnam		74
#define KEY_gethostbyaddr	75
#define KEY_gethostbyname	76
#define KEY_gethostent		77
#define KEY_getlogin		78
#define KEY_getnetbyaddr	79
#define KEY_getnetbyname	80
#define KEY_getnetent		81
#define KEY_getpeername		82
#define KEY_getpgrp		83
#define KEY_getppid		84
#define KEY_getpriority		85
#define KEY_getprotobyname	86
#define KEY_getprotobynumber	87
#define KEY_getprotoent		88
#define KEY_getpwent		89
#define KEY_getpwnam		90
#define KEY_getpwuid		91
#define KEY_getservbyname	92
#define KEY_getservbyport	93
#define KEY_getservent		94
#define KEY_getsockname		95
#define KEY_getsockopt		96
#define KEY_given		97
#define KEY_glob		98
#define KEY_gmtime		99
#define KEY_goto		100
#define KEY_grep		101
#define KEY_gt			102
#define KEY_hex			103
#define KEY_if			104
#define KEY_index		105
#define KEY_int			106
#define KEY_ioctl		107
#define KEY_join		108
#define KEY_keys		109
#define KEY_kill		110
#define KEY_last		111
#define KEY_lc			112
#define KEY_lcfirst		113
#define KEY_le			114
#define KEY_length		115
#define KEY_link		116
#define KEY_listen		117
#define KEY_local		118
#define KEY_localtime		119
#define KEY_lock		120
#define KEY_log			121
#define KEY_lstat		122
#define KEY_lt			123
#define KEY_m			124
#define KEY_map			125
#define KEY_mkdir		126
#define KEY_msgctl		127
#define KEY_msgget		128
#define KEY_msgrcv		129
#define KEY_msgsnd		130
#define KEY_my			131
#define KEY_ne			132
#define KEY_next		133
#define KEY_no			134
#define KEY_not			135
#define KEY_oct			136
#define KEY_open		137
#define KEY_opendir		138
#define KEY_or			139
#define KEY_ord			140
#define KEY_our			141
#define KEY_pack		142
#define KEY_package		143
#define KEY_pipe		144
#define KEY_pop			145
#define KEY_pos			146
#define KEY_print		147
#define KEY_printf		148
#define KEY_prototype		149
#define KEY_push		150
#define KEY_q			151
#define KEY_qq			152
#define KEY_qr			153
#define KEY_quotemeta		154
#define KEY_qw			155
#define KEY_qx			156
#define KEY_rand		157
#define KEY_read		158
#define KEY_readdir		159
#define KEY_readline		160
#define KEY_readlink		161
#define KEY_readpipe		162
#define KEY_recv		163
#define KEY_redo		164
#define KEY_ref			165
#define KEY_rename		166
#define KEY_require		167
#define KEY_reset		168
#define KEY_return		169
#define KEY_reverse		170
#define KEY_rewinddir		171
#define KEY_rindex		172
#define KEY_rmdir		173
#define KEY_s			174
#define KEY_say			175
#define KEY_scalar		176
#define KEY_seek		177
#define KEY_seekdir		178
#define KEY_select		179
#define KEY_semctl		180
#define KEY_semget		181
#define KEY_semop		182
#define KEY_send		183
#define KEY_setgrent		184
#define KEY_sethostent		185
#define KEY_setnetent		186
#define KEY_setpgrp		187
#define KEY_setpriority		188
#define KEY_setprotoent		189
#define KEY_setpwent		190
#define KEY_setservent		191
#define KEY_setsockopt		192
#define KEY_shift		193
#define KEY_shmctl		194
#define KEY_shmget		195
#define KEY_shmread		196
#define KEY_shmwrite		197
#define KEY_shutdown		198
#define KEY_sin			199
#define KEY_sleep		200
#define KEY_socket		201
#define KEY_socketpair		202
#define KEY_sort		203
#define KEY_splice		204
#define KEY_split		205
#define KEY_sprintf		206
#define KEY_sqrt		207
#define KEY_srand		208
#define KEY_stat		209
#define KEY_state		210
#define KEY_study		211
#define KEY_sub			212
#define KEY_substr		213
#define KEY_symlink		214
#define KEY_syscall		215
#define KEY_sysopen		216
#define KEY_sysread		217
#define KEY_sysseek		218
#define KEY_system		219
#define KEY_syswrite		220
#define KEY_tell		221
#define KEY_telldir		222
#define KEY_tie			223
#define KEY_tied		224
#define KEY_time		225
#define KEY_times		226
#define KEY_tr			227
#define KEY_truncate		228
#define KEY_uc			229
#define KEY_ucfirst		230
#define KEY_umask		231
#define KEY_undef		232
#define KEY_unless		233
#define KEY_unlink		234
#define KEY_unpack		235
#define KEY_unshift		236
#define KEY_untie		237
#define KEY_until		238
#define KEY_use			239
#define KEY_utime		240
#define KEY_values		241
#define KEY_vec			242
#define KEY_wait		243
#define KEY_waitpid		244
#define KEY_wantarray		245
#define KEY_warn		246
#define KEY_when		247
#define KEY_while		248
#define KEY_write		249
#define KEY_x			250
#define KEY_xor			251
#define KEY_y			252

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\intrpvar.h ===
/*   intrpvar.h 
 *
 *    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 *    2006, 2007
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
=head1 Per-Interpreter Variables
*/

/* These variables are per-interpreter in threaded/multiplicity builds,
 * global otherwise.

 * Don't forget to re-run embed.pl to propagate changes! */

/* New variables must be added to the very end for binary compatibility.
 * XSUB.h provides wrapper functions via perlapi.h that make this
 * irrelevant, but not all code may be expected to #include XSUB.h. */

/* Don't forget to add your variable also to perl_clone()! */

/* The 'I' prefix is only needed for vars that need appropriate #defines
 * generated when built with or without MULTIPLICITY.  It is also used
 * to generate the appropriate export list for win32.
 *
 * When building without MULTIPLICITY, these variables will be truly global.
 *
 * Important ones in the first cache line (if alignment is done right) */

PERLVAR(Istack_sp,	SV **)		/* top of the stack */
#ifdef OP_IN_REGISTER
PERLVAR(Iopsave,	OP *)
#else
PERLVAR(Iop,		OP *)		/* currently executing op */
#endif
PERLVAR(Icurpad,	SV **)		/* active pad (lexicals+tmps) */

PERLVAR(Istack_base,	SV **)
PERLVAR(Istack_max,	SV **)

PERLVAR(Iscopestack,	I32 *)		/* scopes we've ENTERed */
PERLVAR(Iscopestack_ix,	I32)
PERLVAR(Iscopestack_max,I32)

PERLVAR(Isavestack,	ANY *)		/* items that need to be restored when
					   LEAVEing scopes we've ENTERed */
PERLVAR(Isavestack_ix,	I32)
PERLVAR(Isavestack_max,	I32)

PERLVAR(Itmps_stack,	SV **)		/* mortals we've made */
PERLVARI(Itmps_ix,	I32,	-1)
PERLVARI(Itmps_floor,	I32,	-1)
PERLVAR(Itmps_max,	I32)
PERLVAR(Imodcount,	I32)		/* how much mod()ification in
					   assignment? */

PERLVAR(Imarkstack,	I32 *)		/* stack_sp locations we're
					   remembering */
PERLVAR(Imarkstack_ptr,	I32 *)
PERLVAR(Imarkstack_max,	I32 *)

PERLVAR(ISv,		SV *)		/* used to hold temporary values */
PERLVAR(IXpv,		XPV *)		/* used to hold temporary values */

/*
=for apidoc Amn|STRLEN|PL_na

A convenience variable which is typically used with C<SvPV> when one
doesn't care about the length of the string.  It is usually more efficient
to either declare a local variable and use that instead or to use the
C<SvPV_nolen> macro.

=cut
*/

PERLVAR(Ina,		STRLEN)		/* for use in SvPV when length is
					   Not Applicable */

/* stat stuff */
PERLVAR(Istatbuf,	Stat_t)
PERLVAR(Istatcache,	Stat_t)		/* _ */
PERLVAR(Istatgv,	GV *)
PERLVARI(Istatname,	SV *,	NULL)

#ifdef HAS_TIMES
PERLVAR(Itimesbuf,	struct tms)
#endif

/* Fields used by magic variables such as $@, $/ and so on */
PERLVAR(Icurpm,		PMOP *)		/* what to do \ interps in REs from */

/*
=for apidoc mn|SV*|PL_rs

The input record separator - C<$/> in Perl space.

=for apidoc mn|GV*|PL_last_in_gv

The GV which was last used for a filehandle input operation. (C<< <FH> >>)

=for apidoc mn|SV*|PL_ofs_sv

The output field separator - C<$,> in Perl space.

=cut
*/

PERLVAR(Irs,		SV *)		/* input record separator $/ */
PERLVAR(Ilast_in_gv,	GV *)		/* GV used in last <FH> */
PERLVAR(Iofs_sv,	SV *)		/* output field separator $, */
PERLVAR(Idefoutgv,	GV *)		/* default FH for output */
PERLVARI(Ichopset,	const char *, " \n-")	/* $: */
PERLVAR(Iformtarget,	SV *)
PERLVAR(Ibodytarget,	SV *)
PERLVAR(Itoptarget,	SV *)

/* Stashes */
PERLVAR(Idefstash,	HV *)		/* main symbol table */
PERLVAR(Icurstash,	HV *)		/* symbol table for current package */

PERLVAR(Irestartop,	OP *)		/* propagating an error from croak? */
PERLVAR(Icurcop,	COP * VOL)
PERLVAR(Icurstack,	AV *)		/* THE STACK */
PERLVAR(Icurstackinfo,	PERL_SI *)	/* current stack + context */
PERLVAR(Imainstack,	AV *)		/* the stack when nothing funny is
					   happening */

PERLVAR(Itop_env,	JMPENV *)	/* ptr to current sigjmp environment */
PERLVAR(Istart_env,	JMPENV)		/* empty startup sigjmp environment */
PERLVARI(Ierrors,	SV *,	NULL)	/* outstanding queued errors */

/* statics "owned" by various functions */
PERLVAR(Ihv_fetch_ent_mh, HE*)		/* owned by hv_fetch_ent() */

PERLVAR(Ilastgotoprobe,	OP*)		/* from pp_ctl.c */

/* sort stuff */
PERLVAR(Isortcop,	OP *)		/* user defined sort routine */
PERLVAR(Isortstash,	HV *)		/* which is in some package or other */
PERLVAR(Ifirstgv,	GV *)		/* $a */
PERLVAR(Isecondgv,	GV *)		/* $b */

/* float buffer */
PERLVAR(Iefloatbuf,	char *)
PERLVAR(Iefloatsize,	STRLEN)

/* regex stuff */

PERLVAR(Iscreamfirst,	I32 *)
PERLVAR(Iscreamnext,	I32 *)
PERLVAR(Ilastscream,	SV *)

PERLVAR(Ireg_state,	struct re_save_state)

PERLVAR(Iregdummy,	regnode)	/* from regcomp.c */

PERLVARI(Idumpindent,	U16,	4)	/* number of blanks per dump
					   indentation level */


PERLVAR(Iutf8locale,	bool)		/* utf8 locale detected */
PERLVARI(Irehash_seed_set, bool, FALSE)	/* 582 hash initialized? */

PERLVARA(Icolors,6,	char *)		/* from regcomp.c */

PERLVARI(Ipeepp,	peep_t, MEMBER_TO_FPTR(Perl_peep))
					/* Pointer to peephole optimizer */

PERLVARI(Imaxscream,	I32,	-1)
PERLVARI(Ireginterp_cnt,I32,	 0)	/* Whether "Regexp" was interpolated. */
PERLVARI(Iwatchaddr,	char **, 0)
PERLVAR(Iwatchok,	char *)

/* the currently active slab in a chain of slabs of regmatch states,
 * and the currently active state within that slab */

PERLVARI(Iregmatch_slab, regmatch_slab *,	NULL)
PERLVAR(Iregmatch_state, regmatch_state *)

/* Put anything new that is pointer aligned here. */

PERLVAR(Idelaymagic,	U16)		/* ($<,$>) = ... */
PERLVAR(Ilocalizing,	U8)		/* are we processing a local() list? */
PERLVAR(Icolorset,	bool)		/* from regcomp.c */
PERLVARI(Idirty,	bool, FALSE)	/* in the middle of tearing things
					   down? */
PERLVAR(Iin_eval,	VOL U8)		/* trap "fatal" errors? */
PERLVAR(Itainted,	bool)		/* using variables controlled by $< */

/* This value may be set when embedding for full cleanup  */
/* 0=none, 1=full, 2=full with checks */
/* mod_perl is special, and also assigns a meaning -1 */
PERLVARI(Iperl_destruct_level,	signed char,	0)

PERLVAR(Iperldb,	U32)

/* pseudo environmental stuff */
PERLVAR(Iorigargc,	int)
PERLVAR(Iorigargv,	char **)
PERLVAR(Ienvgv,		GV *)
PERLVAR(Iincgv,		GV *)
PERLVAR(Ihintgv,	GV *)
PERLVAR(Iorigfilename,	char *)
PERLVAR(Idiehook,	SV *)
PERLVAR(Iwarnhook,	SV *)

/* switches */
PERLVAR(Ipatchlevel,	SV *)
PERLVAR(Ilocalpatches,	const char * const *)
PERLVARI(Isplitstr,	const char *, " ")

PERLVAR(Iminus_c,	bool)
PERLVAR(Ipreprocess,	bool)
PERLVAR(Iminus_n,	bool)
PERLVAR(Iminus_p,	bool)
PERLVAR(Iminus_l,	bool)
PERLVAR(Iminus_a,	bool)
PERLVAR(Iminus_F,	bool)
PERLVAR(Idoswitches,	bool)

PERLVAR(Iminus_E,	bool)

/*

=for apidoc mn|bool|PL_dowarn

The C variable which corresponds to Perl's $^W warning variable.

=cut
*/

PERLVAR(Idowarn,	U8)
PERLVAR(Idoextract,	bool)
PERLVAR(Isawampersand,	bool)		/* must save all match strings */
PERLVAR(Iunsafe,	bool)
PERLVAR(Iexit_flags,	U8)		/* was exit() unexpected, etc. */
PERLVAR(Isrand_called,	bool)
/* Part of internal state, but makes the 16th 1 byte variable in a row.  */
PERLVAR(Itainting,	bool)		/* doing taint checks */
PERLVAR(Iinplace,	char *)
PERLVAR(Ie_script,	SV *)

/* magical thingies */
PERLVAR(Ibasetime,	Time_t)		/* $^T */
PERLVAR(Iformfeed,	SV *)		/* $^L */


PERLVARI(Imaxsysfd,	I32,	MAXSYSFD)
					/* top fd to pass to subprocesses */
PERLVAR(Istatusvalue,	I32)		/* $? */
#ifdef VMS
PERLVAR(Istatusvalue_vms,U32)
#else
PERLVAR(Istatusvalue_posix,I32)
#endif

PERLVARI(Isig_pending, int,0)           /* Number if highest signal pending */
PERLVAR(Ipsig_pend, int *)		/* per-signal "count" of pending */

/* shortcuts to various I/O objects */
PERLVAR(Istdingv,	GV *)
PERLVAR(Istderrgv,	GV *)
PERLVAR(Idefgv,		GV *)
PERLVAR(Iargvgv,	GV *)
PERLVAR(Iargvoutgv,	GV *)
PERLVAR(Iargvout_stack,	AV *)

/* shortcuts to regexp stuff */
PERLVAR(Ireplgv,	GV *)

/* shortcuts to misc objects */
PERLVAR(Ierrgv,		GV *)

/* shortcuts to debugging objects */
PERLVAR(IDBgv,		GV *)
PERLVAR(IDBline,	GV *)

/*
=for apidoc mn|GV *|PL_DBsub
When Perl is run in debugging mode, with the B<-d> switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's $DB::sub variable.  See
C<PL_DBsingle>.

=for apidoc mn|SV *|PL_DBsingle
When Perl is run in debugging mode, with the B<-d> switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's $DB::single variable.  See
C<PL_DBsub>.

=for apidoc mn|SV *|PL_DBtrace
Trace variable used when Perl is run in debugging mode, with the B<-d>
switch.  This is the C variable which corresponds to Perl's $DB::trace
variable.  See C<PL_DBsingle>.

=cut
*/

PERLVAR(IDBsub,		GV *)
PERLVAR(IDBsingle,	SV *)
PERLVAR(IDBtrace,	SV *)
PERLVAR(IDBsignal,	SV *)
PERLVAR(Idbargs,	AV *)		/* args to call listed by caller function */

/* symbol tables */
PERLVAR(Idebstash,	HV *)		/* symbol table for perldb package */
PERLVAR(Iglobalstash,	HV *)		/* global keyword overrides imported here */
PERLVAR(Icurstname,	SV *)		/* name of current package */
PERLVAR(Ibeginav,	AV *)		/* names of BEGIN subroutines */
PERLVAR(Iendav,		AV *)		/* names of END subroutines */
PERLVAR(Iunitcheckav,	AV *)		/* names of UNITCHECK subroutines */
PERLVAR(Icheckav,	AV *)		/* names of CHECK subroutines */
PERLVAR(Iinitav,	AV *)		/* names of INIT subroutines */
PERLVAR(Istrtab,	HV *)		/* shared string table */
PERLVARI(Isub_generation,U32,1)		/* incr to invalidate method cache */

/* funky return mechanisms */
PERLVAR(Iforkprocess,	int)		/* so do_open |- can return proc# */

/* memory management */
PERLVAR(Isv_count,	I32)		/* how many SV* are currently allocated */
PERLVAR(Isv_objcount,	I32)		/* how many objects are currently allocated */
PERLVAR(Isv_root,	SV*)		/* storage for SVs belonging to interp */
PERLVAR(Isv_arenaroot,	SV*)		/* list of areas for garbage collection */

/* subprocess state */
PERLVAR(Ifdpid,		AV *)		/* keep fd-to-pid mappings for my_popen */

/* internal state */
PERLVARI(Iop_mask,	char *,	NULL)	/* masked operations for safe evals */

/* current interpreter roots */
PERLVAR(Imain_cv,	CV *)
PERLVAR(Imain_root,	OP *)
PERLVAR(Imain_start,	OP *)
PERLVAR(Ieval_root,	OP *)
PERLVAR(Ieval_start,	OP *)

/* runtime control stuff */
PERLVARI(Icurcopdb,	COP *,	NULL)

PERLVAR(Ifilemode,	int)		/* so nextargv() can preserve mode */
PERLVAR(Ilastfd,	int)		/* what to preserve mode on */
PERLVAR(Ioldname,	char *)		/* what to preserve mode on */
PERLVAR(IArgv,		char **)	/* stuff to free from do_aexec, vfork safe */
PERLVAR(ICmd,		char *)		/* stuff to free from do_aexec, vfork safe */
/* Elements in this array have ';' appended and are injected as a single line
   into the tokeniser. You can't put any (literal) newlines into any program
   you stuff in into this array, as the point where it's injected is expecting
   a single physical line. */
PERLVAR(Ipreambleav,	AV *)
PERLVAR(Imess_sv,	SV *)
PERLVAR(Iors_sv,	SV *)		/* output record separator $\ */
/* statics moved here for shared library purposes */
PERLVARI(Igensym,	I32,	0)	/* next symbol for getsym() to define */
PERLVARI(Icv_has_eval, bool, FALSE) /* PL_compcv includes an entereval or similar */
PERLVAR(Itaint_warn,	bool)      /* taint warns instead of dying */
PERLVARI(Ilaststype,	U16,	OP_STAT)
PERLVARI(Ilaststatval,	int,	-1)

/* interpreter atexit processing */
PERLVARI(Iexitlistlen,	I32, 0)		/* length of same */
PERLVARI(Iexitlist,	PerlExitListEntry *, NULL)
					/* list of exit functions */

/*
=for apidoc Amn|HV*|PL_modglobal

C<PL_modglobal> is a general purpose, interpreter global HV for use by
extensions that need to keep information on a per-interpreter basis.
In a pinch, it can also be used as a symbol table for extensions
to share data among each other.  It is a good idea to use keys
prefixed by the package name of the extension that owns the data.

=cut
*/

PERLVAR(Imodglobal,	HV *)		/* per-interp module data */

/* these used to be in global before 5.004_68 */
PERLVARI(Iprofiledata,	U32 *,	NULL)	/* table of ops, counts */

PERLVAR(Icompiling,	COP)		/* compiling/done executing marker */

PERLVAR(Icompcv,	CV *)		/* currently compiling subroutine */
PERLVAR(Icomppad,	AV *)		/* storage for lexically scoped temporaries */
PERLVAR(Icomppad_name,	AV *)		/* variable names for "my" variables */
PERLVAR(Icomppad_name_fill,	I32)	/* last "introduced" variable offset */
PERLVAR(Icomppad_name_floor,	I32)	/* start of vars in innermost block */

#ifdef HAVE_INTERP_INTERN
PERLVAR(Isys_intern,	struct interp_intern)
					/* platform internals */
#endif

/* more statics moved here */
PERLVAR(IDBcv,		CV *)		/* from perl.c */
PERLVARI(Igeneration,	int,	100)	/* from op.c */

PERLVARI(Iin_clean_objs,bool,    FALSE)	/* from sv.c */
PERLVARI(Iin_clean_all,	bool,    FALSE)	/* from sv.c */
PERLVAR(Inomemok,	bool)		/* let malloc context handle nomem */
PERLVARI(Isavebegin,     bool,	FALSE)	/* save BEGINs for compiler	*/

PERLVAR(Iuid,		Uid_t)		/* current real user id */
PERLVAR(Ieuid,		Uid_t)		/* current effective user id */
PERLVAR(Igid,		Gid_t)		/* current real group id */
PERLVAR(Iegid,		Gid_t)		/* current effective group id */
PERLVARI(Ian,		U32,	0)	/* malloc sequence number */
PERLVARI(Icop_seqmax,	U32,	0)	/* statement sequence number */
PERLVARI(Ievalseq,	U32,	0)	/* eval sequence number */
PERLVAR(Iorigalen,	U32)
PERLVAR(Iorigenviron,	char **)
#ifdef PERL_USES_PL_PIDSTATUS
PERLVAR(Ipidstatus,	HV *)		/* pid-to-status mappings for waitpid */
#endif
PERLVAR(Iosname,	char *)		/* operating system */

PERLVAR(Isighandlerp,	Sighandler_t)

PERLVARA(Ibody_roots,	PERL_ARENA_ROOTS_SIZE, void*) /* array of body roots */

PERLVAR(Inice_chunk,	char *)		/* a nice chunk of memory to reuse */
PERLVAR(Inice_chunk_size,	U32)	/* how nice the chunk of memory is */

PERLVARI(Imaxo,	int,	MAXO)		/* maximum number of ops */

PERLVARI(Irunops,	runops_proc_t,	MEMBER_TO_FPTR(RUNOPS_DEFAULT))

/*
=for apidoc Amn|SV|PL_sv_undef
This is the C<undef> SV.  Always refer to this as C<&PL_sv_undef>.

=for apidoc Amn|SV|PL_sv_no
This is the C<false> SV.  See C<PL_sv_yes>.  Always refer to this as
C<&PL_sv_no>.

=for apidoc Amn|SV|PL_sv_yes
This is the C<true> SV.  See C<PL_sv_no>.  Always refer to this as
C<&PL_sv_yes>.

=cut
*/

PERLVAR(Isv_undef,	SV)
PERLVAR(Isv_no,		SV)
PERLVAR(Isv_yes,	SV)

PERLVAR(Isubname,	SV *)		/* name of current subroutine */

PERLVAR(Isubline,	I32)		/* line this subroutine began on */
PERLVAR(Imin_intro_pending,	I32)	/* start of vars to introduce */

PERLVAR(Imax_intro_pending,	I32)	/* end of vars to introduce */
PERLVAR(Ipadix,		I32)		/* max used index in current "register" pad */

PERLVAR(Ipadix_floor,	I32)		/* how low may inner block reset padix */
PERLVAR(Ipad_reset_pending,	I32)	/* reset pad on next attempted alloc */

PERLVAR(Ihints,		U32)		/* pragma-tic compile-time flags */

PERLVAR(Idebug,		VOL U32)	/* flags given to -D switch */

PERLVARI(Iamagic_generation,	long,	0)

#ifdef USE_LOCALE_COLLATE
PERLVAR(Icollation_name,char *)		/* Name of current collation */
PERLVAR(Icollxfrm_base,	Size_t)		/* Basic overhead in *xfrm() */
PERLVARI(Icollxfrm_mult,Size_t,	2)	/* Expansion factor in *xfrm() */
PERLVARI(Icollation_ix,	U32,	0)	/* Collation generation index */
PERLVARI(Icollation_standard, bool,	TRUE)
					/* Assume simple collation */
#endif /* USE_LOCALE_COLLATE */


#if defined (PERL_UTF8_CACHE_ASSERT) || defined (DEBUGGING)
#  define PERL___I -1
#else
#  define PERL___I 1
#endif
PERLVARI(Iutf8cache, I8, PERL___I)	/* Is the utf8 caching code enabled? */
#undef PERL___I


#ifdef USE_LOCALE_NUMERIC

PERLVARI(Inumeric_standard,	bool,	TRUE)
					/* Assume simple numerics */
PERLVARI(Inumeric_local,	bool,	TRUE)
					/* Assume local numerics */
PERLVAR(Inumeric_name,	char *)		/* Name of current numeric locale */
#endif /* !USE_LOCALE_NUMERIC */

/* utf8 character classes */
PERLVAR(Iutf8_alnum,	SV *)
PERLVAR(Iutf8_alnumc,	SV *)
PERLVAR(Iutf8_ascii,	SV *)
PERLVAR(Iutf8_alpha,	SV *)
PERLVAR(Iutf8_space,	SV *)
PERLVAR(Iutf8_cntrl,	SV *)
PERLVAR(Iutf8_graph,	SV *)
PERLVAR(Iutf8_digit,	SV *)
PERLVAR(Iutf8_upper,	SV *)
PERLVAR(Iutf8_lower,	SV *)
PERLVAR(Iutf8_print,	SV *)
PERLVAR(Iutf8_punct,	SV *)
PERLVAR(Iutf8_xdigit,	SV *)
PERLVAR(Iutf8_mark,	SV *)
PERLVAR(Iutf8_toupper,	SV *)
PERLVAR(Iutf8_totitle,	SV *)
PERLVAR(Iutf8_tolower,	SV *)
PERLVAR(Iutf8_tofold,	SV *)
PERLVAR(Ilast_swash_hv,	HV *)
PERLVAR(Ilast_swash_tmps,	U8 *)
PERLVAR(Ilast_swash_slen,	STRLEN)
PERLVARA(Ilast_swash_key,10,	U8)
PERLVAR(Ilast_swash_klen,	U8)	/* Only needs to store 0-10  */

#ifdef FCRYPT
PERLVARI(Icryptseen,	bool,	FALSE)	/* has fast crypt() been initialized? */
#endif

PERLVARI(Iglob_index,	int,	0)


PERLVAR(Iparser,	yy_parser *)	/* current parser state */

PERLVAR(Ibitcount,	char *)

PERLVAR(Ipsig_ptr, SV**)
PERLVAR(Ipsig_name, SV**)

#if defined(PERL_IMPLICIT_SYS)
PERLVAR(IMem,		struct IPerlMem*)
PERLVAR(IMemShared,	struct IPerlMem*)
PERLVAR(IMemParse,	struct IPerlMem*)
PERLVAR(IEnv,		struct IPerlEnv*)
PERLVAR(IStdIO,		struct IPerlStdIO*)
PERLVAR(ILIO,		struct IPerlLIO*)
PERLVAR(IDir,		struct IPerlDir*)
PERLVAR(ISock,		struct IPerlSock*)
PERLVAR(IProc,		struct IPerlProc*)
#endif

PERLVAR(Iptr_table,	PTR_TBL_t*)
PERLVARI(Ibeginav_save, AV*, NULL)	/* save BEGIN{}s when compiling */

PERLVAR(Ibody_arenas, void*) /* pointer to list of body-arenas */


#ifdef USE_LOCALE_NUMERIC

PERLVAR(Inumeric_radix_sv,	SV *)	/* The radix separator if not '.' */

#endif

#if defined(USE_ITHREADS)
PERLVAR(Iregex_pad,     SV**)		/* All regex objects */
PERLVAR(Iregex_padav,   AV*)		/* All regex objects */

#endif

#ifdef USE_REENTRANT_API
PERLVAR(Ireentrant_buffer, REENTR*)	/* here we store the _r buffers */
#endif

PERLVAR(Icustom_op_names, HV*)  /* Names of user defined ops */
PERLVAR(Icustom_op_descs, HV*)  /* Descriptions of user defined ops */

#ifdef PERLIO_LAYERS
PERLVARI(Iperlio, PerlIO *,NULL)
PERLVARI(Iknown_layers, PerlIO_list_t *,NULL)
PERLVARI(Idef_layerlist, PerlIO_list_t *,NULL)
#endif

PERLVARI(Iencoding,	SV*, NULL)		/* character encoding */

PERLVAR(Idebug_pad,	struct perl_debug_pad)	/* always needed because of the re extension */

PERLVAR(Iutf8_idstart,	SV *)
PERLVAR(Iutf8_idcont,	SV *)

PERLVAR(Isort_RealCmp,  SVCOMPARE_t)

PERLVARI(Icheckav_save, AV*, NULL)	/* save CHECK{}s when compiling */
PERLVARI(Iunitcheckav_save, AV*, NULL)	/* save UNITCHECK{}s when compiling */

PERLVARI(Iclocktick, long, 0)	/* this many times() ticks in a second */

PERLVARI(Iin_load_module, int, 0)	/* to prevent recursions in PerlIO_find_layer */

PERLVAR(Iunicode, U32)	/* Unicode features: $ENV{PERL_UNICODE} or -C */

PERLVAR(Isignals, U32)	/* Using which pre-5.8 signals */

PERLVAR(Ireentrant_retint, int)	/* Integer return value from reentrant functions */

PERLVAR(Istashcache,	HV *)		/* Cache to speed up S_method_common */

/* Hooks to shared SVs and locks. */
PERLVARI(Isharehook,	share_proc_t,	MEMBER_TO_FPTR(Perl_sv_nosharing))
PERLVARI(Ilockhook,	share_proc_t,	MEMBER_TO_FPTR(Perl_sv_nosharing))
#ifdef NO_MATHOMS
#  define PERL_UNLOCK_HOOK Perl_sv_nosharing
#else
/* This reference ensures that the mathoms are linked with perl */
#  define PERL_UNLOCK_HOOK Perl_sv_nounlocking
#endif
PERLVARI(Iunlockhook,	share_proc_t,	MEMBER_TO_FPTR(PERL_UNLOCK_HOOK))

PERLVARI(Ithreadhook,	thrhook_proc_t,	MEMBER_TO_FPTR(Perl_nothreadhook))

PERLVARI(Ihash_seed, UV, 0)		/* Hash initializer */

PERLVARI(Irehash_seed, UV, 0)		/* 582 hash initializer */

PERLVARI(Iisarev, HV*, NULL) /* Reverse map of @ISA dependencies */

/* The last unconditional member of the interpreter structure when 5.10.0 was
   released. The offset of the end of this is baked into a global variable in 
   any shared perl library which will allow a sanity test in future perl
   releases.  */
#define PERL_LAST_5_10_0_INTERP_MEMBER	Iisarev

#ifdef PERL_IMPLICIT_CONTEXT
PERLVARI(Imy_cxt_size, int, 0)		/* size of PL_my_cxt_list */
PERLVARI(Imy_cxt_list, void **, NULL) /* per-module array of MY_CXT pointers */
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
PERLVARI(Imy_cxt_keys, const char **, NULL) /* per-module array of pointers to MY_CXT_KEY constants */
#  endif
#endif

#ifdef PERL_TRACK_MEMPOOL
/* For use with the memory debugging code in util.c  */
PERLVAR(Imemory_debug_header, struct perl_memory_debug_header)
#endif

#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
/* File descriptor to talk to the child which dumps scalars.  */
PERLVARI(Idumper_fd, int, -1)
#endif

/* Stores the PPID */
#ifdef THREADS_HAVE_PIDS
PERLVARI(Ippid,		IV,		0)
#endif

#ifdef PERL_MAD
PERLVARI(Imadskills,	bool, FALSE)	/* preserve all syntactic info */
					/* (MAD = Misc Attribute Decoration) */
PERLVARI(Ixmlfp, PerlIO *,NULL)
#endif

#ifdef PL_OP_SLAB_ALLOC
PERLVAR(IOpPtr,I32 **)
PERLVARI(IOpSpace,I32,0)
PERLVAR(IOpSlab,I32 *)
#endif

#ifdef PERL_DEBUG_READONLY_OPS
PERLVARI(Islabs, I32**, NULL)	/* Array of slabs that have been allocated */
PERLVARI(Islab_count, U32, 0)	/* Size of the array */
#endif

/* Can shared object be destroyed */
PERLVARI(Idestroyhook, destroyable_proc_t, MEMBER_TO_FPTR(Perl_sv_destroyable))

/* If you are adding a U8 or U16, check to see if there are 'Space' comments
 * above on where there are gaps which currently will be structure padding.  */

/* Within a stable branch, new variables must be added to the very end, before
 * this comment, for binary compatibility (the offsets of the old members must
 *  not change).
 * (Don't forget to add your variable also to perl_clone()!)
 * XSUB.h provides wrapper functions via perlapi.h that make this
 * irrelevant, but not all code may be expected to #include XSUB.h.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\gv.h ===
/*    gv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct gp {
    SV *	gp_sv;		/* scalar value */
    struct io *	gp_io;		/* filehandle value */
    CV *	gp_cv;		/* subroutine value */
    U32		gp_cvgen;	/* generational validity of cached gv_cv */
    U32		gp_refcnt;	/* how many globs point to this? */
    HV *	gp_hv;		/* hash value */
    AV *	gp_av;		/* array value */
    CV *	gp_form;	/* format value */
    GV *	gp_egv;		/* effective gv, if *glob */
    line_t	gp_line;	/* line first declared at (for -w) */
    HEK *	gp_file_hek;	/* file first declared in (for -w) */
};

#define GvXPVGV(gv)	((XPVGV*)SvANY(gv))


#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__INTEL_COMPILER)
#  define GvGP(gv)							\
	(*({GV *const shplep = (GV *) (gv);				\
	    assert(SvTYPE(shplep) == SVt_PVGV || SvTYPE(shplep) == SVt_PVLV); \
	    assert(isGV_with_GP(shplep));				\
	    &((shplep)->sv_u.svu_gp);}))
#  define GvFLAGS(gv)							\
	(*({GV *const yaah  = (GV *) (gv);				\
	    assert(SvTYPE(yaah) == SVt_PVGV || SvTYPE(yaah) == SVt_PVLV); \
	    assert(isGV_with_GP(yaah));					\
	    &(GvXPVGV(yaah)->xpv_cur);}))
#  define GvSTASH(gv)							\
	(*({ GV * const _gv = (GV *) (gv);				\
	    assert(isGV_with_GP(_gv));					\
	    assert(SvTYPE(_gv) == SVt_PVGV || SvTYPE(_gv) >= SVt_PVLV);	\
	    &(GvXPVGV(_gv)->xnv_u.xgv_stash);				\
	 }))
#  define GvNAME_HEK(gv)						\
	(*({ GV * const zzzz = (GV *) (gv);				\
	   assert(isGV_with_GP(zzzz));					\
	   assert(SvTYPE(zzzz) == SVt_PVGV || SvTYPE(zzzz) >= SVt_PVLV); \
	   assert(!SvVALID(zzzz));					\
	   &(GvXPVGV(zzzz)->xiv_u.xivu_namehek);			\
	 }))
#  define GvNAME_get(gv)	({ assert(GvNAME_HEK(gv)); HEK_KEY(GvNAME_HEK(gv)); })
#  define GvNAMELEN_get(gv)	({ assert(GvNAME_HEK(gv)); HEK_LEN(GvNAME_HEK(gv)); })
#else
#  define GvGP(gv)	((gv)->sv_u.svu_gp)
#  define GvFLAGS(gv)	(GvXPVGV(gv)->xpv_cur)
#  define GvSTASH(gv)	(GvXPVGV(gv)->xnv_u.xgv_stash)
#  define GvNAME_HEK(gv)	(GvXPVGV(gv)->xiv_u.xivu_namehek)
#  define GvNAME_get(gv)	HEK_KEY(GvNAME_HEK(gv))
#  define GvNAMELEN_get(gv)	HEK_LEN(GvNAME_HEK(gv))
#endif

#define GvNAME(gv)	GvNAME_get(gv)
#define GvNAMELEN(gv)	GvNAMELEN_get(gv)

#define	GvASSIGN_GENERATION(gv)		(0 + ((XPV*) SvANY(gv))->xpv_len)
#define	GvASSIGN_GENERATION_set(gv,val)			\
	STMT_START { assert(SvTYPE(gv) == SVt_PVGV);	\
		(((XPV*) SvANY(gv))->xpv_len = (val)); } STMT_END

/*
=head1 GV Functions

=for apidoc Am|SV*|GvSV|GV* gv

Return the SV from the GV.

=cut
*/

#define GvSV(gv)	(GvGP(gv)->gp_sv)
#ifdef PERL_DONT_CREATE_GVSV
#define GvSVn(gv)	(*(GvGP(gv)->gp_sv ? \
			 &(GvGP(gv)->gp_sv) : \
			 &(GvGP(gv_SVadd(gv))->gp_sv)))
#else
#define GvSVn(gv)	GvSV(gv)
#endif

#define GvREFCNT(gv)	(GvGP(gv)->gp_refcnt)
#define GvIO(gv)	((gv) && SvTYPE((SV*)gv) == SVt_PVGV && GvGP(gv) ? GvIOp(gv) : NULL)
#define GvIOp(gv)	(GvGP(gv)->gp_io)
#define GvIOn(gv)	(GvIO(gv) ? GvIOp(gv) : GvIOp(gv_IOadd(gv)))

#define GvFORM(gv)	(GvGP(gv)->gp_form)
#define GvAV(gv)	(GvGP(gv)->gp_av)

/* This macro is deprecated.  Do not use! */
#define GvREFCNT_inc(gv) ((GV*)SvREFCNT_inc(gv))	/* DO NOT USE */

#define GvAVn(gv)	(GvGP(gv)->gp_av ? \
			 GvGP(gv)->gp_av : \
			 GvGP(gv_AVadd(gv))->gp_av)
#define GvHV(gv)	((GvGP(gv))->gp_hv)

#define GvHVn(gv)	(GvGP(gv)->gp_hv ? \
			 GvGP(gv)->gp_hv : \
			 GvGP(gv_HVadd(gv))->gp_hv)

#define GvCV(gv)	(GvGP(gv)->gp_cv)
#define GvCVGEN(gv)	(GvGP(gv)->gp_cvgen)
#define GvCVu(gv)	(GvGP(gv)->gp_cvgen ? NULL : GvGP(gv)->gp_cv)

#define GvLINE(gv)	(GvGP(gv)->gp_line)
#define GvFILE_HEK(gv)	(GvGP(gv)->gp_file_hek)
#define GvFILE(gv)	(GvFILE_HEK(gv) ? HEK_KEY(GvFILE_HEK(gv)) : NULL)
#define GvFILEGV(gv)	(gv_fetchfile(GvFILE(gv)))

#define GvEGV(gv)	(GvGP(gv)->gp_egv)
#define GvENAME(gv)	GvNAME(GvEGV(gv) ? GvEGV(gv) : gv)
#define GvESTASH(gv)	GvSTASH(GvEGV(gv) ? GvEGV(gv) : gv)

#define GVf_INTRO	0x01
#define GVf_MULTI	0x02
#define GVf_ASSUMECV	0x04
#define GVf_IN_PAD	0x08
#define GVf_IMPORTED	0xF0
#define GVf_IMPORTED_SV	  0x10
#define GVf_IMPORTED_AV	  0x20
#define GVf_IMPORTED_HV	  0x40
#define GVf_IMPORTED_CV	  0x80

#define GvINTRO(gv)		(GvFLAGS(gv) & GVf_INTRO)
#define GvINTRO_on(gv)		(GvFLAGS(gv) |= GVf_INTRO)
#define GvINTRO_off(gv)		(GvFLAGS(gv) &= ~GVf_INTRO)

#define GvMULTI(gv)		(GvFLAGS(gv) & GVf_MULTI)
#define GvMULTI_on(gv)		(GvFLAGS(gv) |= GVf_MULTI)
#define GvMULTI_off(gv)		(GvFLAGS(gv) &= ~GVf_MULTI)

#define GvASSUMECV(gv)		(GvFLAGS(gv) & GVf_ASSUMECV)
#define GvASSUMECV_on(gv)	(GvFLAGS(gv) |= GVf_ASSUMECV)
#define GvASSUMECV_off(gv)	(GvFLAGS(gv) &= ~GVf_ASSUMECV)

#define GvIMPORTED(gv)		(GvFLAGS(gv) & GVf_IMPORTED)
#define GvIMPORTED_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED)
#define GvIMPORTED_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED)

#define GvIMPORTED_SV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_SV)
#define GvIMPORTED_SV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_SV)
#define GvIMPORTED_SV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_SV)

#define GvIMPORTED_AV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_AV)
#define GvIMPORTED_AV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_AV)
#define GvIMPORTED_AV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_AV)

#define GvIMPORTED_HV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_HV)
#define GvIMPORTED_HV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_HV)
#define GvIMPORTED_HV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_HV)

#define GvIMPORTED_CV(gv)	(GvFLAGS(gv) & GVf_IMPORTED_CV)
#define GvIMPORTED_CV_on(gv)	(GvFLAGS(gv) |= GVf_IMPORTED_CV)
#define GvIMPORTED_CV_off(gv)	(GvFLAGS(gv) &= ~GVf_IMPORTED_CV)

#define GvIN_PAD(gv)		(GvFLAGS(gv) & GVf_IN_PAD)
#define GvIN_PAD_on(gv)		(GvFLAGS(gv) |= GVf_IN_PAD)
#define GvIN_PAD_off(gv)	(GvFLAGS(gv) &= ~GVf_IN_PAD)

#define GvUNIQUE(gv)            0
#define GvUNIQUE_on(gv)         NOOP
#define GvUNIQUE_off(gv)        NOOP

#ifdef USE_ITHREADS
#define GV_UNIQUE_CHECK
#else
#undef  GV_UNIQUE_CHECK
#endif

#define Nullgv Null(GV*)

#define DM_UID   0x003
#define DM_RUID   0x001
#define DM_EUID   0x002
#define DM_ARRAY 0x004
#define DM_GID   0x030
#define DM_RGID   0x010
#define DM_EGID   0x020
#define DM_DELAY 0x100

/*
 * symbol creation flags, for use in gv_fetchpv() and get_*v()
 */
#define GV_ADD		0x01	/* add, if symbol not already there
				   For gv_name_set, adding a HEK for the first
				   time, so don't try to free what's there.  */
#define GV_ADDMULTI	0x02	/* add, pretending it has been added already */
#define GV_ADDWARN	0x04	/* add, but warn if symbol wasn't already there */
#define GV_ADDINEVAL	0x08	/* add, as though we're doing so within an eval */
#define GV_NOINIT	0x10	/* add, but don't init symbol, if type != PVGV */
/* This is used by toke.c to avoid turing placeholder constants in the symbol
   table into full PVGVs with attached constant subroutines.  */
#define GV_NOADD_NOINIT	0x20	/* Don't add the symbol if it's not there.
				   Don't init it if it is there but ! PVGV */
#define GV_NOEXPAND	0x40	/* Don't expand SvOK() entries to PVGV */
#define GV_NOTQUAL	0x80	/* A plain symbol name, not qualified with a
				   package (so skip checks for :: and ')  */

/*      SVf_UTF8 (more accurately the return value from SvUTF8) is also valid
	as a flag to gv_fetch_pvn_flags, so ensure it lies outside this range.
*/

#define GV_NOADD_MASK	(SVf_UTF8|GV_NOADD_NOINIT|GV_NOEXPAND|GV_NOTQUAL)
/* The bit flags that don't cause gv_fetchpv() to add a symbol if not found */

#define gv_fullname3(sv,gv,prefix) gv_fullname4(sv,gv,prefix,TRUE)
#define gv_efullname3(sv,gv,prefix) gv_efullname4(sv,gv,prefix,TRUE)
#define gv_fetchmethod(stash, name) gv_fetchmethod_autoload(stash, name, TRUE)

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\iperlsys.h ===
/*
 * iperlsys.h - Perl's interface to the system
 *
 * This file defines the system level functionality that perl needs.
 *
 * When using C, this definition is in the form of a set of macros
 * that can be #defined to the system-level function (or a wrapper
 * provided elsewhere).
 *
 * GSAR 21-JUN-98
 */

#ifndef __Inc__IPerl___
#define __Inc__IPerl___

/*
 *	PerlXXX_YYY explained - DickH and DougL @ ActiveState.com
 *
 * XXX := functional group
 * YYY := stdlib/OS function name
 *
 * Continuing with the theme of PerlIO, all OS functionality was
 * encapsulated into one of several interfaces.
 *
 * PerlIO - stdio
 * PerlLIO - low level I/O
 * PerlMem - malloc, realloc, free
 * PerlDir - directory related
 * PerlEnv - process environment handling
 * PerlProc - process control
 * PerlSock - socket functions
 *
 *
 * The features of this are:
 * 1. All OS dependant code is in the Perl Host and not the Perl Core.
 *    (At least this is the holy grail goal of this work)
 * 2. The Perl Host (see perl.h for description) can provide a new and
 *    improved interface to OS functionality if required.
 * 3. Developers can easily hook into the OS calls for instrumentation
 *    or diagnostic purposes.
 *
 * What was changed to do this:
 * 1. All calls to OS functions were replaced with PerlXXX_YYY
 *
 */

/*
    Interface for perl stdio functions, or whatever we are Configure-d
    to use.
*/
#include "perlio.h"

#ifndef Sighandler_t
#  if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
typedef Signal_t (*Sighandler_t) (int, siginfo_t*, void*);
#  else
typedef Signal_t (*Sighandler_t) (int);
#  endif
#endif

#if defined(PERL_IMPLICIT_SYS)

/* IPerlStdIO		*/
struct IPerlStdIO;
struct IPerlStdIOInfo;
typedef FILE*		(*LPStdin)(struct IPerlStdIO*);
typedef FILE*		(*LPStdout)(struct IPerlStdIO*);
typedef FILE*		(*LPStderr)(struct IPerlStdIO*);
typedef FILE*		(*LPOpen)(struct IPerlStdIO*, const char*,
			    const char*);
typedef int		(*LPClose)(struct IPerlStdIO*, FILE*);
typedef int		(*LPEof)(struct IPerlStdIO*, FILE*);
typedef int		(*LPError)(struct IPerlStdIO*, FILE*);
typedef void		(*LPClearerr)(struct IPerlStdIO*, FILE*);
typedef int		(*LPGetc)(struct IPerlStdIO*, FILE*);
typedef char*		(*LPGetBase)(struct IPerlStdIO*, FILE*);
typedef int		(*LPGetBufsiz)(struct IPerlStdIO*, FILE*);
typedef int		(*LPGetCnt)(struct IPerlStdIO*, FILE*);
typedef char*		(*LPGetPtr)(struct IPerlStdIO*, FILE*);
typedef char*		(*LPGets)(struct IPerlStdIO*, FILE*, char*, int);
typedef int		(*LPPutc)(struct IPerlStdIO*, FILE*, int);
typedef int		(*LPPuts)(struct IPerlStdIO*, FILE*, const char*);
typedef int		(*LPFlush)(struct IPerlStdIO*, FILE*);
typedef int		(*LPUngetc)(struct IPerlStdIO*, int,FILE*);
typedef int		(*LPFileno)(struct IPerlStdIO*, FILE*);
typedef FILE*		(*LPFdopen)(struct IPerlStdIO*, int, const char*);
typedef FILE*		(*LPReopen)(struct IPerlStdIO*, const char*,
			    const char*, FILE*);
typedef SSize_t		(*LPRead)(struct IPerlStdIO*, void*, Size_t, Size_t, FILE *);
typedef SSize_t		(*LPWrite)(struct IPerlStdIO*, const void*, Size_t, Size_t, FILE *);
typedef void		(*LPSetBuf)(struct IPerlStdIO*, FILE*, char*);
typedef int		(*LPSetVBuf)(struct IPerlStdIO*, FILE*, char*, int,
			    Size_t);
typedef void		(*LPSetCnt)(struct IPerlStdIO*, FILE*, int);

#ifndef NETWARE
typedef void		(*LPSetPtr)(struct IPerlStdIO*, FILE*, char*);
#elif defined(NETWARE)
typedef void		(*LPSetPtr)(struct IPerlStdIO*, FILE*, char*, int);
#endif

typedef void		(*LPSetlinebuf)(struct IPerlStdIO*, FILE*);
typedef int		(*LPPrintf)(struct IPerlStdIO*, FILE*, const char*,
			    ...);
typedef int		(*LPVprintf)(struct IPerlStdIO*, FILE*, const char*,
			    va_list);
typedef Off_t		(*LPTell)(struct IPerlStdIO*, FILE*);
typedef int		(*LPSeek)(struct IPerlStdIO*, FILE*, Off_t, int);
typedef void		(*LPRewind)(struct IPerlStdIO*, FILE*);
typedef FILE*		(*LPTmpfile)(struct IPerlStdIO*);
typedef int		(*LPGetpos)(struct IPerlStdIO*, FILE*, Fpos_t*);
typedef int		(*LPSetpos)(struct IPerlStdIO*, FILE*,
			    const Fpos_t*);
typedef void		(*LPInit)(struct IPerlStdIO*);
typedef void		(*LPInitOSExtras)(struct IPerlStdIO*);
typedef FILE*		(*LPFdupopen)(struct IPerlStdIO*, FILE*);

struct IPerlStdIO
{
    LPStdin		pStdin;
    LPStdout		pStdout;
    LPStderr		pStderr;
    LPOpen		pOpen;
    LPClose		pClose;
    LPEof		pEof;
    LPError		pError;
    LPClearerr		pClearerr;
    LPGetc		pGetc;
    LPGetBase		pGetBase;
    LPGetBufsiz		pGetBufsiz;
    LPGetCnt		pGetCnt;
    LPGetPtr		pGetPtr;
    LPGets		pGets;
    LPPutc		pPutc;
    LPPuts		pPuts;
    LPFlush		pFlush;
    LPUngetc		pUngetc;
    LPFileno		pFileno;
    LPFdopen		pFdopen;
    LPReopen		pReopen;
    LPRead		pRead;
    LPWrite		pWrite;
    LPSetBuf		pSetBuf;
    LPSetVBuf		pSetVBuf;
    LPSetCnt		pSetCnt;
    LPSetPtr		pSetPtr;
    LPSetlinebuf	pSetlinebuf;
    LPPrintf		pPrintf;
    LPVprintf		pVprintf;
    LPTell		pTell;
    LPSeek		pSeek;
    LPRewind		pRewind;
    LPTmpfile		pTmpfile;
    LPGetpos		pGetpos;
    LPSetpos		pSetpos;
    LPInit		pInit;
    LPInitOSExtras	pInitOSExtras;
    LPFdupopen		pFdupopen;
};

struct IPerlStdIOInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlStdIO	perlStdIOList;
};

/* These do not belong here ... NI-S, 14 Nov 2000 */

#ifdef USE_STDIO_PTR
#  define PerlSIO_has_cntptr(f)		1
#  ifdef STDIO_PTR_LVALUE
#    ifdef  STDIO_CNT_LVALUE
#      define PerlSIO_canset_cnt(f)	1
#      ifdef STDIO_PTR_LVAL_NOCHANGE_CNT
#        define PerlSIO_fast_gets(f)	1
#      endif
#    else /* STDIO_CNT_LVALUE */
#      define PerlSIO_canset_cnt(f)	0
#    endif
#  else /* STDIO_PTR_LVALUE */
#    ifdef STDIO_PTR_LVAL_SETS_CNT
#      define PerlSIO_fast_gets(f)	1
#    endif
#  endif
#else  /* USE_STDIO_PTR */
#  define PerlSIO_has_cntptr(f)		0
#  define PerlSIO_canset_cnt(f)		0
#endif /* USE_STDIO_PTR */

#ifndef PerlSIO_fast_gets
#define PerlSIO_fast_gets(f)		0
#endif

#ifdef FILE_base
#define PerlSIO_has_base(f)		1
#else
#define PerlSIO_has_base(f)		0
#endif

/* Now take FILE * via function table */

#define PerlSIO_stdin							\
	(*PL_StdIO->pStdin)(PL_StdIO)
#define PerlSIO_stdout							\
	(*PL_StdIO->pStdout)(PL_StdIO)
#define PerlSIO_stderr							\
	(*PL_StdIO->pStderr)(PL_StdIO)
#define PerlSIO_fopen(x,y)						\
	(*PL_StdIO->pOpen)(PL_StdIO, (x),(y))
#define PerlSIO_fclose(f)						\
	(*PL_StdIO->pClose)(PL_StdIO, (f))
#define PerlSIO_feof(f)							\
	(*PL_StdIO->pEof)(PL_StdIO, (f))
#define PerlSIO_ferror(f)						\
	(*PL_StdIO->pError)(PL_StdIO, (f))
#define PerlSIO_clearerr(f)						\
	(*PL_StdIO->pClearerr)(PL_StdIO, (f))
#define PerlSIO_fgetc(f)						\
	(*PL_StdIO->pGetc)(PL_StdIO, (f))
#define PerlSIO_get_base(f)						\
	(*PL_StdIO->pGetBase)(PL_StdIO, (f))
#define PerlSIO_get_bufsiz(f)						\
	(*PL_StdIO->pGetBufsiz)(PL_StdIO, (f))
#define PerlSIO_get_cnt(f)						\
	(*PL_StdIO->pGetCnt)(PL_StdIO, (f))
#define PerlSIO_get_ptr(f)						\
	(*PL_StdIO->pGetPtr)(PL_StdIO, (f))
#define PerlSIO_fputc(f,c)						\
	(*PL_StdIO->pPutc)(PL_StdIO, (f),(c))
#define PerlSIO_fputs(f,s)						\
	(*PL_StdIO->pPuts)(PL_StdIO, (f),(s))
#define PerlSIO_fflush(f)						\
	(*PL_StdIO->pFlush)(PL_StdIO, (f))
#define PerlSIO_fgets(s, n, fp)						\
	(*PL_StdIO->pGets)(PL_StdIO, (fp), s, n)
#define PerlSIO_ungetc(c,f)						\
	(*PL_StdIO->pUngetc)(PL_StdIO, (c),(f))
#define PerlSIO_fileno(f)						\
	(*PL_StdIO->pFileno)(PL_StdIO, (f))
#define PerlSIO_fdopen(f, s)						\
	(*PL_StdIO->pFdopen)(PL_StdIO, (f),(s))
#define PerlSIO_freopen(p, m, f)					\
	(*PL_StdIO->pReopen)(PL_StdIO, (p), (m), (f))
#define PerlSIO_fread(buf,sz,count,f)					\
	(*PL_StdIO->pRead)(PL_StdIO, (buf), (sz), (count), (f))
#define PerlSIO_fwrite(buf,sz,count,f)					\
	(*PL_StdIO->pWrite)(PL_StdIO, (buf), (sz), (count), (f))
#define PerlSIO_setbuf(f,b)						\
	(*PL_StdIO->pSetBuf)(PL_StdIO, (f), (b))
#define PerlSIO_setvbuf(f,b,t,s)					\
	(*PL_StdIO->pSetVBuf)(PL_StdIO, (f),(b),(t),(s))
#define PerlSIO_set_cnt(f,c)						\
	(*PL_StdIO->pSetCnt)(PL_StdIO, (f), (c))
#define PerlSIO_set_ptr(f,p)						\
	(*PL_StdIO->pSetPtr)(PL_StdIO, (f), (p))
#define PerlSIO_setlinebuf(f)						\
	(*PL_StdIO->pSetlinebuf)(PL_StdIO, (f))
#define PerlSIO_printf		Perl_fprintf_nocontext
#define PerlSIO_stdoutf		Perl_printf_nocontext
#define PerlSIO_vprintf(f,fmt,a)						\
	(*PL_StdIO->pVprintf)(PL_StdIO, (f),(fmt),a)
#define PerlSIO_ftell(f)							\
	(*PL_StdIO->pTell)(PL_StdIO, (f))
#define PerlSIO_fseek(f,o,w)						\
	(*PL_StdIO->pSeek)(PL_StdIO, (f),(o),(w))
#define PerlSIO_fgetpos(f,p)						\
	(*PL_StdIO->pGetpos)(PL_StdIO, (f),(p))
#define PerlSIO_fsetpos(f,p)						\
	(*PL_StdIO->pSetpos)(PL_StdIO, (f),(p))
#define PerlSIO_rewind(f)						\
	(*PL_StdIO->pRewind)(PL_StdIO, (f))
#define PerlSIO_tmpfile()						\
	(*PL_StdIO->pTmpfile)(PL_StdIO)
#define PerlSIO_init()							\
	(*PL_StdIO->pInit)(PL_StdIO)
#undef 	init_os_extras
#define init_os_extras()						\
	(*PL_StdIO->pInitOSExtras)(PL_StdIO)
#define PerlSIO_fdupopen(f)						\
	(*PL_StdIO->pFdupopen)(PL_StdIO, (f))

#else	/* PERL_IMPLICIT_SYS */

#define PerlSIO_stdin			stdin
#define PerlSIO_stdout			stdout
#define PerlSIO_stderr			stderr
#define PerlSIO_fopen(x,y)		fopen(x,y)
#ifdef __VOS__
/* Work around VOS bug posix-979, wrongly setting errno when at end of file. */
#define PerlSIO_fclose(f)		(((errno==1025)?errno=0:0),fclose(f))
#define PerlSIO_feof(f)			(((errno==1025)?errno=0:0),feof(f))
#define PerlSIO_ferror(f)		(((errno==1025)?errno=0:0),ferror(f))
#else
#define PerlSIO_fclose(f)		fclose(f)
#define PerlSIO_feof(f)			feof(f)
#define PerlSIO_ferror(f)		ferror(f)
#endif
#define PerlSIO_clearerr(f)		clearerr(f)
#define PerlSIO_fgetc(f)			fgetc(f)
#ifdef FILE_base
#define PerlSIO_get_base(f)		FILE_base(f)
#define PerlSIO_get_bufsiz(f)		FILE_bufsiz(f)
#else
#define PerlSIO_get_base(f)		NULL
#define PerlSIO_get_bufsiz(f)		0
#endif
#ifdef USE_STDIO_PTR
#define PerlSIO_get_cnt(f)		FILE_cnt(f)
#define PerlSIO_get_ptr(f)		FILE_ptr(f)
#else
#define PerlSIO_get_cnt(f)		0
#define PerlSIO_get_ptr(f)		NULL
#endif
#define PerlSIO_fputc(f,c)		fputc(c,f)
#define PerlSIO_fputs(f,s)		fputs(s,f)
#define PerlSIO_fflush(f)		Fflush(f)
#define PerlSIO_fgets(s, n, fp)		fgets(s,n,fp)
#if defined(VMS) && defined(__DECC)
     /* Unusual definition of ungetc() here to accomodate fast_sv_gets()'
      * belief that it can mix getc/ungetc with reads from stdio buffer */
     int decc$ungetc(int __c, FILE *__stream);
#    define PerlSIO_ungetc(c,f) ((c) == EOF ? EOF : \
            ((*(f) && !((*(f))->_flag & _IONBF) && \
            ((*(f))->_ptr > (*(f))->_base)) ? \
            ((*(f))->_cnt++, *(--(*(f))->_ptr) = (c)) : decc$ungetc(c,f)))
#else
#  define PerlSIO_ungetc(c,f)          ungetc(c,f)
#endif
#define PerlSIO_fileno(f)		fileno(f)
#define PerlSIO_fdopen(f, s)		fdopen(f,s)
#define PerlSIO_freopen(p, m, f)	freopen(p,m,f)
#define PerlSIO_fread(buf,sz,count,f)	fread(buf,sz,count,f)
#define PerlSIO_fwrite(buf,sz,count,f)	fwrite(buf,sz,count,f)
#define PerlSIO_setbuf(f,b)		setbuf(f,b)
#define PerlSIO_setvbuf(f,b,t,s)	setvbuf(f,b,t,s)
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE)
#define PerlSIO_set_cnt(f,c)		FILE_cnt(f) = (c)
#else
#define PerlSIO_set_cnt(f,c)		PerlIOProc_abort()
#endif
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE)
#define PerlSIO_set_ptr(f,p)		(FILE_ptr(f) = (p))
#else
#define PerlSIO_set_ptr(f,p)		PerlIOProc_abort()
#endif
#define PerlSIO_setlinebuf(f)		setlinebuf(f)
#define PerlSIO_printf			fprintf
#define PerlSIO_stdoutf			printf
#define PerlSIO_vprintf(f,fmt,a)	vfprintf(f,fmt,a)
#define PerlSIO_ftell(f)		ftell(f)
#define PerlSIO_fseek(f,o,w)		fseek(f,o,w)
#define PerlSIO_fgetpos(f,p)		fgetpos(f,p)
#define PerlSIO_fsetpos(f,p)		fsetpos(f,p)
#define PerlSIO_rewind(f)		rewind(f)
#define PerlSIO_tmpfile()		tmpfile()
#define PerlSIO_fdupopen(f)		(f)

#endif	/* PERL_IMPLICIT_SYS */

/*
 *   Interface for directory functions
 */

#if defined(PERL_IMPLICIT_SYS)

/* IPerlDir		*/
struct IPerlDir;
struct IPerlDirInfo;
typedef int		(*LPMakedir)(struct IPerlDir*, const char*, int);
typedef int		(*LPChdir)(struct IPerlDir*, const char*);
typedef int		(*LPRmdir)(struct IPerlDir*, const char*);
typedef int		(*LPDirClose)(struct IPerlDir*, DIR*);
typedef DIR*		(*LPDirOpen)(struct IPerlDir*, const char*);
typedef struct direct*	(*LPDirRead)(struct IPerlDir*, DIR*);
typedef void		(*LPDirRewind)(struct IPerlDir*, DIR*);
typedef void		(*LPDirSeek)(struct IPerlDir*, DIR*, long);
typedef long		(*LPDirTell)(struct IPerlDir*, DIR*);
#ifdef WIN32
typedef char*		(*LPDirMapPathA)(struct IPerlDir*, const char*);
typedef WCHAR*		(*LPDirMapPathW)(struct IPerlDir*, const WCHAR*);
#endif

struct IPerlDir
{
    LPMakedir		pMakedir;
    LPChdir		pChdir;
    LPRmdir		pRmdir;
    LPDirClose		pClose;
    LPDirOpen		pOpen;
    LPDirRead		pRead;
    LPDirRewind		pRewind;
    LPDirSeek		pSeek;
    LPDirTell		pTell;
#ifdef WIN32
    LPDirMapPathA	pMapPathA;
    LPDirMapPathW	pMapPathW;
#endif
};

struct IPerlDirInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlDir	perlDirList;
};

#define PerlDir_mkdir(name, mode)				\
	(*PL_Dir->pMakedir)(PL_Dir, (name), (mode))
#define PerlDir_chdir(name)					\
	(*PL_Dir->pChdir)(PL_Dir, (name))
#define PerlDir_rmdir(name)					\
	(*PL_Dir->pRmdir)(PL_Dir, (name))
#define PerlDir_close(dir)					\
	(*PL_Dir->pClose)(PL_Dir, (dir))
#define PerlDir_open(name)					\
	(*PL_Dir->pOpen)(PL_Dir, (name))
#define PerlDir_read(dir)					\
	(*PL_Dir->pRead)(PL_Dir, (dir))
#define PerlDir_rewind(dir)					\
	(*PL_Dir->pRewind)(PL_Dir, (dir))
#define PerlDir_seek(dir, loc)					\
	(*PL_Dir->pSeek)(PL_Dir, (dir), (loc))
#define PerlDir_tell(dir)					\
	(*PL_Dir->pTell)(PL_Dir, (dir))
#ifdef WIN32
#define PerlDir_mapA(dir)					\
	(*PL_Dir->pMapPathA)(PL_Dir, (dir))
#define PerlDir_mapW(dir)					\
	(*PL_Dir->pMapPathW)(PL_Dir, (dir))
#endif

#else	/* PERL_IMPLICIT_SYS */

#define PerlDir_mkdir(name, mode)	Mkdir((name), (mode))
#ifdef VMS
#  define PerlDir_chdir(n)		Chdir((n))
#else
#  define PerlDir_chdir(name)		chdir((name))
#endif
#define PerlDir_rmdir(name)		rmdir((name))
#define PerlDir_close(dir)		closedir((dir))
#define PerlDir_open(name)		opendir((name))
#define PerlDir_read(dir)		readdir((dir))
#define PerlDir_rewind(dir)		rewinddir((dir))
#define PerlDir_seek(dir, loc)		seekdir((dir), (loc))
#define PerlDir_tell(dir)		telldir((dir))
#ifdef WIN32
#define PerlDir_mapA(dir)		dir
#define PerlDir_mapW(dir)		dir
#endif

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl environment functions
*/

#if defined(PERL_IMPLICIT_SYS)

/* IPerlEnv		*/
struct IPerlEnv;
struct IPerlEnvInfo;
typedef char*		(*LPEnvGetenv)(struct IPerlEnv*, const char*);
typedef int		(*LPEnvPutenv)(struct IPerlEnv*, const char*);
typedef char*		(*LPEnvGetenv_len)(struct IPerlEnv*,
				    const char *varname, unsigned long *len);
typedef int		(*LPEnvUname)(struct IPerlEnv*, struct utsname *name);
typedef void		(*LPEnvClearenv)(struct IPerlEnv*);
typedef void*		(*LPEnvGetChildenv)(struct IPerlEnv*);
typedef void		(*LPEnvFreeChildenv)(struct IPerlEnv*, void* env);
typedef char*		(*LPEnvGetChilddir)(struct IPerlEnv*);
typedef void		(*LPEnvFreeChilddir)(struct IPerlEnv*, char* dir);
#ifdef HAS_ENVGETENV
typedef char*		(*LPENVGetenv)(struct IPerlEnv*, const char *varname);
typedef char*		(*LPENVGetenv_len)(struct IPerlEnv*,
				    const char *varname, unsigned long *len);
#endif
#ifdef WIN32
typedef unsigned long	(*LPEnvOsID)(struct IPerlEnv*);
typedef char*		(*LPEnvLibPath)(struct IPerlEnv*, const char*);
typedef char*		(*LPEnvSiteLibPath)(struct IPerlEnv*, const char*);
typedef char*		(*LPEnvVendorLibPath)(struct IPerlEnv*, const char*);
typedef void		(*LPEnvGetChildIO)(struct IPerlEnv*, child_IO_table*);
#endif

struct IPerlEnv
{
    LPEnvGetenv		pGetenv;
    LPEnvPutenv		pPutenv;
    LPEnvGetenv_len	pGetenv_len;
    LPEnvUname		pEnvUname;
    LPEnvClearenv	pClearenv;
    LPEnvGetChildenv	pGetChildenv;
    LPEnvFreeChildenv	pFreeChildenv;
    LPEnvGetChilddir	pGetChilddir;
    LPEnvFreeChilddir	pFreeChilddir;
#ifdef HAS_ENVGETENV
    LPENVGetenv		pENVGetenv;
    LPENVGetenv_len	pENVGetenv_len;
#endif
#ifdef WIN32
    LPEnvOsID		pEnvOsID;
    LPEnvLibPath	pLibPath;
    LPEnvSiteLibPath	pSiteLibPath;
    LPEnvVendorLibPath	pVendorLibPath;
    LPEnvGetChildIO	pGetChildIO;
#endif
};

struct IPerlEnvInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlEnv	perlEnvList;
};

#define PerlEnv_putenv(str)					\
	(*PL_Env->pPutenv)(PL_Env,(str))
#define PerlEnv_getenv(str)					\
	(*PL_Env->pGetenv)(PL_Env,(str))
#define PerlEnv_getenv_len(str,l)				\
	(*PL_Env->pGetenv_len)(PL_Env,(str), (l))
#define PerlEnv_clearenv()					\
	(*PL_Env->pClearenv)(PL_Env)
#define PerlEnv_get_childenv()					\
	(*PL_Env->pGetChildenv)(PL_Env)
#define PerlEnv_free_childenv(e)				\
	(*PL_Env->pFreeChildenv)(PL_Env, (e))
#define PerlEnv_get_childdir()					\
	(*PL_Env->pGetChilddir)(PL_Env)
#define PerlEnv_free_childdir(d)				\
	(*PL_Env->pFreeChilddir)(PL_Env, (d))
#ifdef HAS_ENVGETENV
#  define PerlEnv_ENVgetenv(str)				\
	(*PL_Env->pENVGetenv)(PL_Env,(str))
#  define PerlEnv_ENVgetenv_len(str,l)				\
	(*PL_Env->pENVGetenv_len)(PL_Env,(str), (l))
#else
#  define PerlEnv_ENVgetenv(str)				\
	PerlEnv_getenv((str))
#  define PerlEnv_ENVgetenv_len(str,l)				\
	PerlEnv_getenv_len((str),(l))
#endif
#define PerlEnv_uname(name)					\
	(*PL_Env->pEnvUname)(PL_Env,(name))
#ifdef WIN32
#define PerlEnv_os_id()						\
	(*PL_Env->pEnvOsID)(PL_Env)
#define PerlEnv_lib_path(str)					\
	(*PL_Env->pLibPath)(PL_Env,(str))
#define PerlEnv_sitelib_path(str)				\
	(*PL_Env->pSiteLibPath)(PL_Env,(str))
#define PerlEnv_vendorlib_path(str)				\
	(*PL_Env->pVendorLibPath)(PL_Env,(str))
#define PerlEnv_get_child_IO(ptr)				\
	(*PL_Env->pGetChildIO)(PL_Env, ptr)
#endif

#else	/* PERL_IMPLICIT_SYS */

#define PerlEnv_putenv(str)		putenv((str))
#define PerlEnv_getenv(str)		getenv((str))
#define PerlEnv_getenv_len(str,l)	getenv_len((str), (l))
#ifdef HAS_ENVGETENV
#  define PerlEnv_ENVgetenv(str)	ENVgetenv((str))
#  define PerlEnv_ENVgetenv_len(str,l)	ENVgetenv_len((str), (l))
#else
#  define PerlEnv_ENVgetenv(str)	PerlEnv_getenv((str))
#  define PerlEnv_ENVgetenv_len(str,l)	PerlEnv_getenv_len((str), (l))
#endif
#define PerlEnv_uname(name)		uname((name))

#ifdef WIN32
#define PerlEnv_os_id()			win32_os_id()
#define PerlEnv_lib_path(str)		win32_get_privlib(str)
#define PerlEnv_sitelib_path(str)	win32_get_sitelib(str)
#define PerlEnv_vendorlib_path(str)	win32_get_vendorlib(str)
#define PerlEnv_get_child_IO(ptr)	win32_get_child_IO(ptr)
#define PerlEnv_clearenv()		win32_clearenv()
#define PerlEnv_get_childenv()		win32_get_childenv()
#define PerlEnv_free_childenv(e)	win32_free_childenv((e))
#define PerlEnv_get_childdir()		win32_get_childdir()
#define PerlEnv_free_childdir(d)	win32_free_childdir((d))
#else
#define PerlEnv_clearenv()		clearenv()
#define PerlEnv_get_childenv()		get_childenv()
#define PerlEnv_free_childenv(e)	free_childenv((e))
#define PerlEnv_get_childdir()		get_childdir()
#define PerlEnv_free_childdir(d)	free_childdir((d))
#endif

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl low-level IO functions
*/

#if defined(PERL_IMPLICIT_SYS)

/* IPerlLIO		*/
struct IPerlLIO;
struct IPerlLIOInfo;
typedef int		(*LPLIOAccess)(struct IPerlLIO*, const char*, int);
typedef int		(*LPLIOChmod)(struct IPerlLIO*, const char*, int);
typedef int		(*LPLIOChown)(struct IPerlLIO*, const char*, uid_t,
			    gid_t);
typedef int		(*LPLIOChsize)(struct IPerlLIO*, int, Off_t);
typedef int		(*LPLIOClose)(struct IPerlLIO*, int);
typedef int		(*LPLIODup)(struct IPerlLIO*, int);
typedef int		(*LPLIODup2)(struct IPerlLIO*, int, int);
typedef int		(*LPLIOFlock)(struct IPerlLIO*, int, int);
typedef int		(*LPLIOFileStat)(struct IPerlLIO*, int, Stat_t*);
typedef int		(*LPLIOIOCtl)(struct IPerlLIO*, int, unsigned int,
			    char*);
typedef int		(*LPLIOIsatty)(struct IPerlLIO*, int);
typedef int		(*LPLIOLink)(struct IPerlLIO*, const char*,
				     const char *);
typedef Off_t		(*LPLIOLseek)(struct IPerlLIO*, int, Off_t, int);
typedef int		(*LPLIOLstat)(struct IPerlLIO*, const char*,
			    Stat_t*);
typedef char*		(*LPLIOMktemp)(struct IPerlLIO*, char*);
typedef int		(*LPLIOOpen)(struct IPerlLIO*, const char*, int);	
typedef int		(*LPLIOOpen3)(struct IPerlLIO*, const char*, int, int);	
typedef int		(*LPLIORead)(struct IPerlLIO*, int, void*, unsigned int);
typedef int		(*LPLIORename)(struct IPerlLIO*, const char*,
			    const char*);
#ifdef NETWARE
typedef int		(*LPLIOSetmode)(struct IPerlLIO*, FILE*, int);
#else
typedef int		(*LPLIOSetmode)(struct IPerlLIO*, int, int);
#endif	/* NETWARE */
typedef int		(*LPLIONameStat)(struct IPerlLIO*, const char*,
			    Stat_t*);
typedef char*		(*LPLIOTmpnam)(struct IPerlLIO*, char*);
typedef int		(*LPLIOUmask)(struct IPerlLIO*, int);
typedef int		(*LPLIOUnlink)(struct IPerlLIO*, const char*);
typedef int		(*LPLIOUtime)(struct IPerlLIO*, const char*, struct utimbuf*);
typedef int		(*LPLIOWrite)(struct IPerlLIO*, int, const void*,
			    unsigned int);

struct IPerlLIO
{
    LPLIOAccess		pAccess;
    LPLIOChmod		pChmod;
    LPLIOChown		pChown;
    LPLIOChsize		pChsize;
    LPLIOClose		pClose;
    LPLIODup		pDup;
    LPLIODup2		pDup2;
    LPLIOFlock		pFlock;
    LPLIOFileStat	pFileStat;
    LPLIOIOCtl		pIOCtl;
    LPLIOIsatty		pIsatty;
    LPLIOLink		pLink;
    LPLIOLseek		pLseek;
    LPLIOLstat		pLstat;
    LPLIOMktemp		pMktemp;
    LPLIOOpen		pOpen;
    LPLIOOpen3		pOpen3;
    LPLIORead		pRead;
    LPLIORename		pRename;
    LPLIOSetmode	pSetmode;
    LPLIONameStat	pNameStat;
    LPLIOTmpnam		pTmpnam;
    LPLIOUmask		pUmask;
    LPLIOUnlink		pUnlink;
    LPLIOUtime		pUtime;
    LPLIOWrite		pWrite;
};

struct IPerlLIOInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlLIO	perlLIOList;
};

#define PerlLIO_access(file, mode)					\
	(*PL_LIO->pAccess)(PL_LIO, (file), (mode))
#define PerlLIO_chmod(file, mode)					\
	(*PL_LIO->pChmod)(PL_LIO, (file), (mode))
#define PerlLIO_chown(file, owner, group)				\
	(*PL_LIO->pChown)(PL_LIO, (file), (owner), (group))
#define PerlLIO_chsize(fd, size)					\
	(*PL_LIO->pChsize)(PL_LIO, (fd), (size))
#define PerlLIO_close(fd)						\
	(*PL_LIO->pClose)(PL_LIO, (fd))
#define PerlLIO_dup(fd)							\
	(*PL_LIO->pDup)(PL_LIO, (fd))
#define PerlLIO_dup2(fd1, fd2)						\
	(*PL_LIO->pDup2)(PL_LIO, (fd1), (fd2))
#define PerlLIO_flock(fd, op)						\
	(*PL_LIO->pFlock)(PL_LIO, (fd), (op))
#define PerlLIO_fstat(fd, buf)						\
	(*PL_LIO->pFileStat)(PL_LIO, (fd), (buf))
#define PerlLIO_ioctl(fd, u, buf)					\
	(*PL_LIO->pIOCtl)(PL_LIO, (fd), (u), (buf))
#define PerlLIO_isatty(fd)						\
	(*PL_LIO->pIsatty)(PL_LIO, (fd))
#define PerlLIO_link(oldname, newname)					\
	(*PL_LIO->pLink)(PL_LIO, (oldname), (newname))
#define PerlLIO_lseek(fd, offset, mode)					\
	(*PL_LIO->pLseek)(PL_LIO, (fd), (offset), (mode))
#define PerlLIO_lstat(name, buf)					\
	(*PL_LIO->pLstat)(PL_LIO, (name), (buf))
#define PerlLIO_mktemp(file)						\
	(*PL_LIO->pMktemp)(PL_LIO, (file))
#define PerlLIO_open(file, flag)					\
	(*PL_LIO->pOpen)(PL_LIO, (file), (flag))
#define PerlLIO_open3(file, flag, perm)					\
	(*PL_LIO->pOpen3)(PL_LIO, (file), (flag), (perm))
#define PerlLIO_read(fd, buf, count)					\
	(*PL_LIO->pRead)(PL_LIO, (fd), (buf), (count))
#define PerlLIO_rename(oname, newname)					\
	(*PL_LIO->pRename)(PL_LIO, (oname), (newname))
#define PerlLIO_setmode(fd, mode)					\
	(*PL_LIO->pSetmode)(PL_LIO, (fd), (mode))
#define PerlLIO_stat(name, buf)						\
	(*PL_LIO->pNameStat)(PL_LIO, (name), (buf))
#define PerlLIO_tmpnam(str)						\
	(*PL_LIO->pTmpnam)(PL_LIO, (str))
#define PerlLIO_umask(mode)						\
	(*PL_LIO->pUmask)(PL_LIO, (mode))
#define PerlLIO_unlink(file)						\
	(*PL_LIO->pUnlink)(PL_LIO, (file))
#define PerlLIO_utime(file, time)					\
	(*PL_LIO->pUtime)(PL_LIO, (file), (time))
#define PerlLIO_write(fd, buf, count)					\
	(*PL_LIO->pWrite)(PL_LIO, (fd), (buf), (count))

#else	/* PERL_IMPLICIT_SYS */

#define PerlLIO_access(file, mode)	access((file), (mode))
#define PerlLIO_chmod(file, mode)	chmod((file), (mode))
#define PerlLIO_chown(file, owner, grp)	chown((file), (owner), (grp))
#if defined(HAS_TRUNCATE)
#  define PerlLIO_chsize(fd, size)	ftruncate((fd), (size))
#elif defined(HAS_CHSIZE)
#  define PerlLIO_chsize(fd, size)	chsize((fd), (size))
#else
#  define PerlLIO_chsize(fd, size)	my_chsize((fd), (size))
#endif
#define PerlLIO_close(fd)		close((fd))
#define PerlLIO_dup(fd)			dup((fd))
#define PerlLIO_dup2(fd1, fd2)		dup2((fd1), (fd2))
#define PerlLIO_flock(fd, op)		FLOCK((fd), (op))
#define PerlLIO_fstat(fd, buf)		Fstat((fd), (buf))
#define PerlLIO_ioctl(fd, u, buf)	ioctl((fd), (u), (buf))
#define PerlLIO_isatty(fd)		isatty((fd))
#define PerlLIO_link(oldname, newname)	link((oldname), (newname))
#define PerlLIO_lseek(fd, offset, mode)	lseek((fd), (offset), (mode))
#define PerlLIO_stat(name, buf)		Stat((name), (buf))
#ifdef HAS_LSTAT
#  define PerlLIO_lstat(name, buf)	lstat((name), (buf))
#else
#  define PerlLIO_lstat(name, buf)	PerlLIO_stat((name), (buf))
#endif
#define PerlLIO_mktemp(file)		mktemp((file))
#define PerlLIO_mkstemp(file)		mkstemp((file))
#define PerlLIO_open(file, flag)	open((file), (flag))
#define PerlLIO_open3(file, flag, perm)	open((file), (flag), (perm))
#define PerlLIO_read(fd, buf, count)	read((fd), (buf), (count))
#define PerlLIO_rename(old, new)	rename((old), (new))
#define PerlLIO_setmode(fd, mode)	setmode((fd), (mode))
#define PerlLIO_tmpnam(str)		tmpnam((str))
#define PerlLIO_umask(mode)		umask((mode))
#define PerlLIO_unlink(file)		unlink((file))
#define PerlLIO_utime(file, time)	utime((file), (time))
#define PerlLIO_write(fd, buf, count)	write((fd), (buf), (count))

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl memory allocation
*/

#if defined(PERL_IMPLICIT_SYS)

/* IPerlMem		*/
struct IPerlMem;
struct IPerlMemInfo;
typedef void*		(*LPMemMalloc)(struct IPerlMem*, size_t);
typedef void*		(*LPMemRealloc)(struct IPerlMem*, void*, size_t);
typedef void		(*LPMemFree)(struct IPerlMem*, void*);
typedef void*		(*LPMemCalloc)(struct IPerlMem*, size_t, size_t);
typedef void		(*LPMemGetLock)(struct IPerlMem*);
typedef void		(*LPMemFreeLock)(struct IPerlMem*);
typedef int		(*LPMemIsLocked)(struct IPerlMem*);

struct IPerlMem
{
    LPMemMalloc		pMalloc;
    LPMemRealloc	pRealloc;
    LPMemFree		pFree;
    LPMemCalloc		pCalloc;
    LPMemGetLock	pGetLock;
    LPMemFreeLock	pFreeLock;
    LPMemIsLocked	pIsLocked;
};

struct IPerlMemInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlMem	perlMemList;
};

/* Interpreter specific memory macros */
#define PerlMem_malloc(size)				    \
	(*PL_Mem->pMalloc)(PL_Mem, (size))
#define PerlMem_realloc(buf, size)			    \
	(*PL_Mem->pRealloc)(PL_Mem, (buf), (size))
#define PerlMem_free(buf)				    \
	(*PL_Mem->pFree)(PL_Mem, (buf))
#define PerlMem_calloc(num, size)			    \
	(*PL_Mem->pCalloc)(PL_Mem, (num), (size))
#define PerlMem_get_lock()				    \
	(*PL_Mem->pGetLock)(PL_Mem)
#define PerlMem_free_lock()				    \
	(*PL_Mem->pFreeLock)(PL_Mem)
#define PerlMem_is_locked()				    \
	(*PL_Mem->pIsLocked)(PL_Mem)

/* Shared memory macros */
#ifdef NETWARE

#define PerlMemShared_malloc(size)			    \
	(*PL_Mem->pMalloc)(PL_Mem, (size))
#define PerlMemShared_realloc(buf, size)		    \
	(*PL_Mem->pRealloc)(PL_Mem, (buf), (size))
#define PerlMemShared_free(buf)				    \
	(*PL_Mem->pFree)(PL_Mem, (buf))
#define PerlMemShared_calloc(num, size)			    \
	(*PL_Mem->pCalloc)(PL_Mem, (num), (size))
#define PerlMemShared_get_lock()			    \
	(*PL_Mem->pGetLock)(PL_Mem)
#define PerlMemShared_free_lock()			    \
	(*PL_Mem->pFreeLock)(PL_Mem)
#define PerlMemShared_is_locked()			    \
	(*PL_Mem->pIsLocked)(PL_Mem)

#else

#define PerlMemShared_malloc(size)			    \
	(*PL_MemShared->pMalloc)(PL_MemShared, (size))
#define PerlMemShared_realloc(buf, size)		    \
	(*PL_MemShared->pRealloc)(PL_MemShared, (buf), (size))
#define PerlMemShared_free(buf)				    \
	(*PL_MemShared->pFree)(PL_MemShared, (buf))
#define PerlMemShared_calloc(num, size)			    \
	(*PL_MemShared->pCalloc)(PL_MemShared, (num), (size))
#define PerlMemShared_get_lock()			    \
	(*PL_MemShared->pGetLock)(PL_MemShared)
#define PerlMemShared_free_lock()			    \
	(*PL_MemShared->pFreeLock)(PL_MemShared)
#define PerlMemShared_is_locked()			    \
	(*PL_MemShared->pIsLocked)(PL_MemShared)

#endif

/* Parse tree memory macros */
#define PerlMemParse_malloc(size)			    \
	(*PL_MemParse->pMalloc)(PL_MemParse, (size))
#define PerlMemParse_realloc(buf, size)			    \
	(*PL_MemParse->pRealloc)(PL_MemParse, (buf), (size))
#define PerlMemParse_free(buf)				    \
	(*PL_MemParse->pFree)(PL_MemParse, (buf))
#define PerlMemParse_calloc(num, size)			    \
	(*PL_MemParse->pCalloc)(PL_MemParse, (num), (size))
#define PerlMemParse_get_lock()				    \
	(*PL_MemParse->pGetLock)(PL_MemParse)
#define PerlMemParse_free_lock()			    \
	(*PL_MemParse->pFreeLock)(PL_MemParse)
#define PerlMemParse_is_locked()			    \
	(*PL_MemParse->pIsLocked)(PL_MemParse)


#else	/* PERL_IMPLICIT_SYS */

/* Interpreter specific memory macros */
#define PerlMem_malloc(size)		malloc((size))
#define PerlMem_realloc(buf, size)	realloc((buf), (size))
#define PerlMem_free(buf)		free((buf))
#define PerlMem_calloc(num, size)	calloc((num), (size))
#define PerlMem_get_lock()		
#define PerlMem_free_lock()
#define PerlMem_is_locked()		0

/* Shared memory macros */
#define PerlMemShared_malloc(size)		malloc((size))
#define PerlMemShared_realloc(buf, size)	realloc((buf), (size))
#define PerlMemShared_free(buf)			free((buf))
#define PerlMemShared_calloc(num, size)		calloc((num), (size))
#define PerlMemShared_get_lock()		
#define PerlMemShared_free_lock()
#define PerlMemShared_is_locked()		0

/* Parse tree memory macros */
#define PerlMemParse_malloc(size)	malloc((size))
#define PerlMemParse_realloc(buf, size)	realloc((buf), (size))
#define PerlMemParse_free(buf)		free((buf))
#define PerlMemParse_calloc(num, size)	calloc((num), (size))
#define PerlMemParse_get_lock()		
#define PerlMemParse_free_lock()
#define PerlMemParse_is_locked()	0

#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl process functions
*/


#if defined(PERL_IMPLICIT_SYS)

#ifndef jmp_buf
#include <setjmp.h>
#endif

/* IPerlProc		*/
struct IPerlProc;
struct IPerlProcInfo;
typedef void		(*LPProcAbort)(struct IPerlProc*);
typedef char*		(*LPProcCrypt)(struct IPerlProc*, const char*,
			    const char*);
typedef void		(*LPProcExit)(struct IPerlProc*, int)
			    __attribute__noreturn__;
typedef void		(*LPProc_Exit)(struct IPerlProc*, int)
			    __attribute__noreturn__;
typedef int		(*LPProcExecl)(struct IPerlProc*, const char*,
			    const char*, const char*, const char*,
			    const char*);
typedef int		(*LPProcExecv)(struct IPerlProc*, const char*,
			    const char*const*);
typedef int		(*LPProcExecvp)(struct IPerlProc*, const char*,
			    const char*const*);
typedef uid_t		(*LPProcGetuid)(struct IPerlProc*);
typedef uid_t		(*LPProcGeteuid)(struct IPerlProc*);
typedef gid_t		(*LPProcGetgid)(struct IPerlProc*);
typedef gid_t		(*LPProcGetegid)(struct IPerlProc*);
typedef char*		(*LPProcGetlogin)(struct IPerlProc*);
typedef int		(*LPProcKill)(struct IPerlProc*, int, int);
typedef int		(*LPProcKillpg)(struct IPerlProc*, int, int);
typedef int		(*LPProcPauseProc)(struct IPerlProc*);
typedef PerlIO*		(*LPProcPopen)(struct IPerlProc*, const char*,
			    const char*);
typedef PerlIO*		(*LPProcPopenList)(struct IPerlProc*, const char*,
			    IV narg, SV **args);
typedef int		(*LPProcPclose)(struct IPerlProc*, PerlIO*);
typedef int		(*LPProcPipe)(struct IPerlProc*, int*);
typedef int		(*LPProcSetuid)(struct IPerlProc*, uid_t);
typedef int		(*LPProcSetgid)(struct IPerlProc*, gid_t);
typedef int		(*LPProcSleep)(struct IPerlProc*, unsigned int);
typedef int		(*LPProcTimes)(struct IPerlProc*, struct tms*);
typedef int		(*LPProcWait)(struct IPerlProc*, int*);
typedef int		(*LPProcWaitpid)(struct IPerlProc*, int, int*, int);
typedef Sighandler_t	(*LPProcSignal)(struct IPerlProc*, int, Sighandler_t);
typedef int		(*LPProcFork)(struct IPerlProc*);
typedef int		(*LPProcGetpid)(struct IPerlProc*);
#ifdef WIN32
typedef void*		(*LPProcDynaLoader)(struct IPerlProc*, const char*);
typedef void		(*LPProcGetOSError)(struct IPerlProc*,
			    SV* sv, DWORD dwErr);
typedef int		(*LPProcSpawnvp)(struct IPerlProc*, int, const char*,
			    const char*const*);
#endif
typedef int		(*LPProcLastHost)(struct IPerlProc*);
typedef int		(*LPProcGetTimeOfDay)(struct IPerlProc*,
					      struct timeval*, void*);

struct IPerlProc
{
    LPProcAbort		pAbort;
    LPProcCrypt		pCrypt;
    LPProcExit		pExit;
    LPProc_Exit		p_Exit;
    LPProcExecl		pExecl;
    LPProcExecv		pExecv;
    LPProcExecvp	pExecvp;
    LPProcGetuid	pGetuid;
    LPProcGeteuid	pGeteuid;
    LPProcGetgid	pGetgid;
    LPProcGetegid	pGetegid;
    LPProcGetlogin	pGetlogin;
    LPProcKill		pKill;
    LPProcKillpg	pKillpg;
    LPProcPauseProc	pPauseProc;
    LPProcPopen		pPopen;
    LPProcPclose	pPclose;
    LPProcPipe		pPipe;
    LPProcSetuid	pSetuid;
    LPProcSetgid	pSetgid;
    LPProcSleep		pSleep;
    LPProcTimes		pTimes;
    LPProcWait		pWait;
    LPProcWaitpid	pWaitpid;
    LPProcSignal	pSignal;
    LPProcFork		pFork;
    LPProcGetpid	pGetpid;
#ifdef WIN32
    LPProcDynaLoader	pDynaLoader;
    LPProcGetOSError	pGetOSError;
    LPProcSpawnvp	pSpawnvp;
#endif
    LPProcLastHost      pLastHost;
    LPProcPopenList	pPopenList;
    LPProcGetTimeOfDay	pGetTimeOfDay;
};

struct IPerlProcInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlProc	perlProcList;
};

#define PerlProc_abort()						\
	(*PL_Proc->pAbort)(PL_Proc)
#define PerlProc_crypt(c,s)						\
	(*PL_Proc->pCrypt)(PL_Proc, (c), (s))
#define PerlProc_exit(s)						\
	(*PL_Proc->pExit)(PL_Proc, (s))
#define PerlProc__exit(s)						\
	(*PL_Proc->p_Exit)(PL_Proc, (s))
#define PerlProc_execl(c, w, x, y, z)					\
	(*PL_Proc->pExecl)(PL_Proc, (c), (w), (x), (y), (z))
#define PerlProc_execv(c, a)						\
	(*PL_Proc->pExecv)(PL_Proc, (c), (a))
#define PerlProc_execvp(c, a)						\
	(*PL_Proc->pExecvp)(PL_Proc, (c), (a))
#define PerlProc_getuid()						\
	(*PL_Proc->pGetuid)(PL_Proc)
#define PerlProc_geteuid()						\
	(*PL_Proc->pGeteuid)(PL_Proc)
#define PerlProc_getgid()						\
	(*PL_Proc->pGetgid)(PL_Proc)
#define PerlProc_getegid()						\
	(*PL_Proc->pGetegid)(PL_Proc)
#define PerlProc_getlogin()						\
	(*PL_Proc->pGetlogin)(PL_Proc)
#define PerlProc_kill(i, a)						\
	(*PL_Proc->pKill)(PL_Proc, (i), (a))
#define PerlProc_killpg(i, a)						\
	(*PL_Proc->pKillpg)(PL_Proc, (i), (a))
#define PerlProc_pause()						\
	(*PL_Proc->pPauseProc)(PL_Proc)
#define PerlProc_popen(c, m)						\
	(*PL_Proc->pPopen)(PL_Proc, (c), (m))
#define PerlProc_popen_list(m, n, a)					\
	(*PL_Proc->pPopenList)(PL_Proc, (m), (n), (a))
#define PerlProc_pclose(f)						\
	(*PL_Proc->pPclose)(PL_Proc, (f))
#define PerlProc_pipe(fd)						\
	(*PL_Proc->pPipe)(PL_Proc, (fd))
#define PerlProc_setuid(u)						\
	(*PL_Proc->pSetuid)(PL_Proc, (u))
#define PerlProc_setgid(g)						\
	(*PL_Proc->pSetgid)(PL_Proc, (g))
#define PerlProc_sleep(t)						\
	(*PL_Proc->pSleep)(PL_Proc, (t))
#define PerlProc_times(t)						\
	(*PL_Proc->pTimes)(PL_Proc, (t))
#define PerlProc_wait(t)						\
	(*PL_Proc->pWait)(PL_Proc, (t))
#define PerlProc_waitpid(p,s,f)						\
	(*PL_Proc->pWaitpid)(PL_Proc, (p), (s), (f))
#define PerlProc_signal(n, h)						\
	(*PL_Proc->pSignal)(PL_Proc, (n), (h))
#define PerlProc_fork()							\
	(*PL_Proc->pFork)(PL_Proc)
#define PerlProc_getpid()						\
	(*PL_Proc->pGetpid)(PL_Proc)
#define PerlProc_setjmp(b, n) Sigsetjmp((b), (n))
#define PerlProc_longjmp(b, n) Siglongjmp((b), (n))

#ifdef WIN32
#define PerlProc_DynaLoad(f)						\
	(*PL_Proc->pDynaLoader)(PL_Proc, (f))
#define PerlProc_GetOSError(s,e)					\
	(*PL_Proc->pGetOSError)(PL_Proc, (s), (e))
#define PerlProc_spawnvp(m, c, a)					\
	(*PL_Proc->pSpawnvp)(PL_Proc, (m), (c), (a))
#endif
#define PerlProc_lasthost()						\
	(*PL_Proc->pLastHost)(PL_Proc)
#define PerlProc_gettimeofday(t,z)					\
	(*PL_Proc->pGetTimeOfDay)(PL_Proc,(t),(z))

#else	/* PERL_IMPLICIT_SYS */

#define PerlProc_abort()	abort()
#define PerlProc_crypt(c,s)	crypt((c), (s))
#define PerlProc_exit(s)	exit((s))
#define PerlProc__exit(s)	_exit((s))
#define PerlProc_execl(c,w,x,y,z)					\
	execl((c), (w), (x), (y), (z))
#define PerlProc_execv(c, a)	execv((c), (a))
#define PerlProc_execvp(c, a)	execvp((c), (a))
#define PerlProc_getuid()	getuid()
#define PerlProc_geteuid()	geteuid()
#define PerlProc_getgid()	getgid()
#define PerlProc_getegid()	getegid()
#define PerlProc_getlogin()	getlogin()
#define PerlProc_kill(i, a)	kill((i), (a))
#define PerlProc_killpg(i, a)	killpg((i), (a))
#define PerlProc_pause()	Pause()
#define PerlProc_popen(c, m)	my_popen((c), (m))
#define PerlProc_popen_list(m,n,a)	my_popen_list((m),(n),(a))
#define PerlProc_pclose(f)	my_pclose((f))
#define PerlProc_pipe(fd)	pipe((fd))
#define PerlProc_setuid(u)	setuid((u))
#define PerlProc_setgid(g)	setgid((g))
#define PerlProc_sleep(t)	sleep((t))
#define PerlProc_times(t)	times((t))
#define PerlProc_wait(t)	wait((t))
#define PerlProc_waitpid(p,s,f)	waitpid((p), (s), (f))
#define PerlProc_setjmp(b, n)	Sigsetjmp((b), (n))
#define PerlProc_longjmp(b, n)	Siglongjmp((b), (n))
#define PerlProc_signal(n, h)	signal((n), (h))
#define PerlProc_fork()		my_fork()
#define PerlProc_getpid()	getpid()
#define PerlProc_gettimeofday(t,z)	gettimeofday((t),(z))

#ifdef WIN32
#define PerlProc_DynaLoad(f)						\
	win32_dynaload((f))
#define PerlProc_GetOSError(s,e)					\
	win32_str_os_error((s), (e))
#define PerlProc_spawnvp(m, c, a)					\
	win32_spawnvp((m), (c), (a))
#undef PerlProc_signal
#define PerlProc_signal(n, h) win32_signal((n), (h))
#endif
#endif	/* PERL_IMPLICIT_SYS */

/*
    Interface for perl socket functions
*/

#if defined(PERL_IMPLICIT_SYS)

/* PerlSock		*/
struct IPerlSock;
struct IPerlSockInfo;
typedef u_long		(*LPHtonl)(struct IPerlSock*, u_long);
typedef u_short		(*LPHtons)(struct IPerlSock*, u_short);
typedef u_long		(*LPNtohl)(struct IPerlSock*, u_long);
typedef u_short		(*LPNtohs)(struct IPerlSock*, u_short);
typedef SOCKET		(*LPAccept)(struct IPerlSock*, SOCKET,
			    struct sockaddr*, int*);
typedef int		(*LPBind)(struct IPerlSock*, SOCKET,
			    const struct sockaddr*, int);
typedef int		(*LPConnect)(struct IPerlSock*, SOCKET,
			    const struct sockaddr*, int);
typedef void		(*LPEndhostent)(struct IPerlSock*);
typedef void		(*LPEndnetent)(struct IPerlSock*);
typedef void		(*LPEndprotoent)(struct IPerlSock*);
typedef void		(*LPEndservent)(struct IPerlSock*);
typedef int		(*LPGethostname)(struct IPerlSock*, char*, int);
typedef int		(*LPGetpeername)(struct IPerlSock*, SOCKET,
			    struct sockaddr*, int*);
typedef struct hostent*	(*LPGethostbyaddr)(struct IPerlSock*, const char*,
			    int, int);
typedef struct hostent*	(*LPGethostbyname)(struct IPerlSock*, const char*);
typedef struct hostent*	(*LPGethostent)(struct IPerlSock*);
typedef struct netent*	(*LPGetnetbyaddr)(struct IPerlSock*, long, int);
typedef struct netent*	(*LPGetnetbyname)(struct IPerlSock*, const char*);
typedef struct netent*	(*LPGetnetent)(struct IPerlSock*);
typedef struct protoent*(*LPGetprotobyname)(struct IPerlSock*, const char*);
typedef struct protoent*(*LPGetprotobynumber)(struct IPerlSock*, int);
typedef struct protoent*(*LPGetprotoent)(struct IPerlSock*);
typedef struct servent*	(*LPGetservbyname)(struct IPerlSock*, const char*,
			    const char*);
typedef struct servent*	(*LPGetservbyport)(struct IPerlSock*, int,
			    const char*);
typedef struct servent*	(*LPGetservent)(struct IPerlSock*);
typedef int		(*LPGetsockname)(struct IPerlSock*, SOCKET,
			    struct sockaddr*, int*);
typedef int		(*LPGetsockopt)(struct IPerlSock*, SOCKET, int, int,
			    char*, int*);
typedef unsigned long	(*LPInetAddr)(struct IPerlSock*, const char*);
typedef char*		(*LPInetNtoa)(struct IPerlSock*, struct in_addr);
typedef int		(*LPListen)(struct IPerlSock*, SOCKET, int);
typedef int		(*LPRecv)(struct IPerlSock*, SOCKET, char*, int, int);
typedef int		(*LPRecvfrom)(struct IPerlSock*, SOCKET, char*, int,
			    int, struct sockaddr*, int*);
typedef int		(*LPSelect)(struct IPerlSock*, int, char*, char*,
			    char*, const struct timeval*);
typedef int		(*LPSend)(struct IPerlSock*, SOCKET, const char*, int,
			    int);
typedef int		(*LPSendto)(struct IPerlSock*, SOCKET, const char*,
			    int, int, const struct sockaddr*, int);
typedef void		(*LPSethostent)(struct IPerlSock*, int);
typedef void		(*LPSetnetent)(struct IPerlSock*, int);
typedef void		(*LPSetprotoent)(struct IPerlSock*, int);
typedef void		(*LPSetservent)(struct IPerlSock*, int);
typedef int		(*LPSetsockopt)(struct IPerlSock*, SOCKET, int, int,
			    const char*, int);
typedef int		(*LPShutdown)(struct IPerlSock*, SOCKET, int);
typedef SOCKET		(*LPSocket)(struct IPerlSock*, int, int, int);
typedef int		(*LPSocketpair)(struct IPerlSock*, int, int, int,
			    int*);
#ifdef WIN32
typedef int		(*LPClosesocket)(struct IPerlSock*, SOCKET s);
#endif

struct IPerlSock
{
    LPHtonl		pHtonl;
    LPHtons		pHtons;
    LPNtohl		pNtohl;
    LPNtohs		pNtohs;
    LPAccept		pAccept;
    LPBind		pBind;
    LPConnect		pConnect;
    LPEndhostent	pEndhostent;
    LPEndnetent		pEndnetent;
    LPEndprotoent	pEndprotoent;
    LPEndservent	pEndservent;
    LPGethostname	pGethostname;
    LPGetpeername	pGetpeername;
    LPGethostbyaddr	pGethostbyaddr;
    LPGethostbyname	pGethostbyname;
    LPGethostent	pGethostent;
    LPGetnetbyaddr	pGetnetbyaddr;
    LPGetnetbyname	pGetnetbyname;
    LPGetnetent		pGetnetent;
    LPGetprotobyname	pGetprotobyname;
    LPGetprotobynumber	pGetprotobynumber;
    LPGetprotoent	pGetprotoent;
    LPGetservbyname	pGetservbyname;
    LPGetservbyport	pGetservbyport;
    LPGetservent	pGetservent;
    LPGetsockname	pGetsockname;
    LPGetsockopt	pGetsockopt;
    LPInetAddr		pInetAddr;
    LPInetNtoa		pInetNtoa;
    LPListen		pListen;
    LPRecv		pRecv;
    LPRecvfrom		pRecvfrom;
    LPSelect		pSelect;
    LPSend		pSend;
    LPSendto		pSendto;
    LPSethostent	pSethostent;
    LPSetnetent		pSetnetent;
    LPSetprotoent	pSetprotoent;
    LPSetservent	pSetservent;
    LPSetsockopt	pSetsockopt;
    LPShutdown		pShutdown;
    LPSocket		pSocket;
    LPSocketpair	pSocketpair;
#ifdef WIN32
    LPClosesocket	pClosesocket;
#endif
};

struct IPerlSockInfo
{
    unsigned long	nCount;	    /* number of entries expected */
    struct IPerlSock	perlSockList;
};

#define PerlSock_htonl(x)						\
	(*PL_Sock->pHtonl)(PL_Sock, x)
#define PerlSock_htons(x)						\
	(*PL_Sock->pHtons)(PL_Sock, x)
#define PerlSock_ntohl(x)						\
	(*PL_Sock->pNtohl)(PL_Sock, x)
#define PerlSock_ntohs(x)						\
	(*PL_Sock->pNtohs)(PL_Sock, x)
#define PerlSock_accept(s, a, l)					\
	(*PL_Sock->pAccept)(PL_Sock, s, a, l)
#define PerlSock_bind(s, n, l)						\
	(*PL_Sock->pBind)(PL_Sock, s, n, l)
#define PerlSock_connect(s, n, l)					\
	(*PL_Sock->pConnect)(PL_Sock, s, n, l)
#define PerlSock_endhostent()						\
	(*PL_Sock->pEndhostent)(PL_Sock)
#define PerlSock_endnetent()						\
	(*PL_Sock->pEndnetent)(PL_Sock)
#define PerlSock_endprotoent()						\
	(*PL_Sock->pEndprotoent)(PL_Sock)
#define PerlSock_endservent()						\
	(*PL_Sock->pEndservent)(PL_Sock)
#define PerlSock_gethostbyaddr(a, l, t)					\
	(*PL_Sock->pGethostbyaddr)(PL_Sock, a, l, t)
#define PerlSock_gethostbyname(n)					\
	(*PL_Sock->pGethostbyname)(PL_Sock, n)
#define PerlSock_gethostent()						\
	(*PL_Sock->pGethostent)(PL_Sock)
#define PerlSock_gethostname(n, l)					\
	(*PL_Sock->pGethostname)(PL_Sock, n, l)
#define PerlSock_getnetbyaddr(n, t)					\
	(*PL_Sock->pGetnetbyaddr)(PL_Sock, n, t)
#define PerlSock_getnetbyname(c)					\
	(*PL_Sock->pGetnetbyname)(PL_Sock, c)
#define PerlSock_getnetent()						\
	(*PL_Sock->pGetnetent)(PL_Sock)
#define PerlSock_getpeername(s, n, l)					\
	(*PL_Sock->pGetpeername)(PL_Sock, s, n, l)
#define PerlSock_getprotobyname(n)					\
	(*PL_Sock->pGetprotobyname)(PL_Sock, n)
#define PerlSock_getprotobynumber(n)					\
	(*PL_Sock->pGetprotobynumber)(PL_Sock, n)
#define PerlSock_getprotoent()						\
	(*PL_Sock->pGetprotoent)(PL_Sock)
#define PerlSock_getservbyname(n, p)					\
	(*PL_Sock->pGetservbyname)(PL_Sock, n, p)
#define PerlSock_getservbyport(port, p)					\
	(*PL_Sock->pGetservbyport)(PL_Sock, port, p)
#define PerlSock_getservent()						\
	(*PL_Sock->pGetservent)(PL_Sock)
#define PerlSock_getsockname(s, n, l)					\
	(*PL_Sock->pGetsockname)(PL_Sock, s, n, l)
#define PerlSock_getsockopt(s,l,n,v,i)					\
	(*PL_Sock->pGetsockopt)(PL_Sock, s, l, n, v, i)
#define PerlSock_inet_addr(c)						\
	(*PL_Sock->pInetAddr)(PL_Sock, c)
#define PerlSock_inet_ntoa(i)						\
	(*PL_Sock->pInetNtoa)(PL_Sock, i)
#define PerlSock_listen(s, b)						\
	(*PL_Sock->pListen)(PL_Sock, s, b)
#define PerlSock_recv(s, b, l, f)					\
	(*PL_Sock->pRecv)(PL_Sock, s, b, l, f)
#define PerlSock_recvfrom(s,b,l,f,from,fromlen)				\
	(*PL_Sock->pRecvfrom)(PL_Sock, s, b, l, f, from, fromlen)
#define PerlSock_select(n, r, w, e, t)					\
	(*PL_Sock->pSelect)(PL_Sock, n, (char*)r, (char*)w, (char*)e, t)
#define PerlSock_send(s, b, l, f)					\
	(*PL_Sock->pSend)(PL_Sock, s, b, l, f)
#define PerlSock_sendto(s, b, l, f, t, tlen)				\
	(*PL_Sock->pSendto)(PL_Sock, s, b, l, f, t, tlen)
#define PerlSock_sethostent(f)						\
	(*PL_Sock->pSethostent)(PL_Sock, f)
#define PerlSock_setnetent(f)						\
	(*PL_Sock->pSetnetent)(PL_Sock, f)
#define PerlSock_setprotoent(f)						\
	(*PL_Sock->pSetprotoent)(PL_Sock, f)
#define PerlSock_setservent(f)						\
	(*PL_Sock->pSetservent)(PL_Sock, f)
#define PerlSock_setsockopt(s, l, n, v, len)				\
	(*PL_Sock->pSetsockopt)(PL_Sock, s, l, n, v, len)
#define PerlSock_shutdown(s, h)						\
	(*PL_Sock->pShutdown)(PL_Sock, s, h)
#define PerlSock_socket(a, t, p)					\
	(*PL_Sock->pSocket)(PL_Sock, a, t, p)
#define PerlSock_socketpair(a, t, p, f)					\
	(*PL_Sock->pSocketpair)(PL_Sock, a, t, p, f)

#ifdef WIN32
#define	PerlSock_closesocket(s)						\
	(*PL_Sock->pClosesocket)(PL_Sock, s)
#endif

#else	/* PERL_IMPLICIT_SYS */

#define PerlSock_htonl(x)		htonl(x)
#define PerlSock_htons(x)		htons(x)
#define PerlSock_ntohl(x)		ntohl(x)
#define PerlSock_ntohs(x)		ntohs(x)
#define PerlSock_accept(s, a, l)	accept(s, a, l)
#define PerlSock_bind(s, n, l)		bind(s, n, l)
#define PerlSock_connect(s, n, l)	connect(s, n, l)

#define PerlSock_gethostbyaddr(a, l, t)	gethostbyaddr(a, l, t)
#define PerlSock_gethostbyname(n)	gethostbyname(n)
#define PerlSock_gethostent		gethostent
#define PerlSock_endhostent		endhostent
#define PerlSock_gethostname(n, l)	gethostname(n, l)

#define PerlSock_getnetbyaddr(n, t)	getnetbyaddr(n, t)
#define PerlSock_getnetbyname(n)	getnetbyname(n)
#define PerlSock_getnetent		getnetent
#define PerlSock_endnetent		endnetent
#define PerlSock_getpeername(s, n, l)	getpeername(s, n, l)

#define PerlSock_getprotobyname(n)	getprotobyname(n)
#define PerlSock_getprotobynumber(n)	getprotobynumber(n)
#define PerlSock_getprotoent		getprotoent
#define PerlSock_endprotoent		endprotoent

#define PerlSock_getservbyname(n, p)	getservbyname(n, p)
#define PerlSock_getservbyport(port, p)	getservbyport(port, p)
#define PerlSock_getservent		getservent
#define PerlSock_endservent		endservent

#define PerlSock_getsockname(s, n, l)	getsockname(s, n, l)
#define PerlSock_getsockopt(s,l,n,v,i)	getsockopt(s, l, n, v, i)
#define PerlSock_inet_addr(c)		inet_addr(c)
#define PerlSock_inet_ntoa(i)		inet_ntoa(i)
#define PerlSock_listen(s, b)		listen(s, b)
#define PerlSock_recv(s, b, l, f)	recv(s, b, l, f)
#define PerlSock_recvfrom(s, b, l, f, from, fromlen)			\
	recvfrom(s, b, l, f, from, fromlen)
#define PerlSock_select(n, r, w, e, t)	select(n, r, w, e, t)
#define PerlSock_send(s, b, l, f)	send(s, b, l, f)
#define PerlSock_sendto(s, b, l, f, t, tlen)				\
	sendto(s, b, l, f, t, tlen)
#define PerlSock_sethostent(f)		sethostent(f)
#define PerlSock_setnetent(f)		setnetent(f)
#define PerlSock_setprotoent(f)		setprotoent(f)
#define PerlSock_setservent(f)		setservent(f)
#define PerlSock_setsockopt(s, l, n, v, len)				\
	setsockopt(s, l, n, v, len)
#define PerlSock_shutdown(s, h)		shutdown(s, h)
#define PerlSock_socket(a, t, p)	socket(a, t, p)
#define PerlSock_socketpair(a, t, p, f)	socketpair(a, t, p, f)

#ifdef WIN32
#define PerlSock_closesocket(s)		closesocket(s)
#endif

#endif	/* PERL_IMPLICIT_SYS */

#endif	/* __Inc__IPerl___ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\malloc_ctl.h ===
#ifndef MALLOC_CTL_H
#  define MALLOC_CTL_H

struct perl_mstats {
    UV *nfree;
    UV *ntotal;
    IV topbucket, topbucket_ev, topbucket_odd, totfree, total, total_chain;
    IV total_sbrk, sbrks, sbrk_good, sbrk_slack, start_slack, sbrked_remains;
    IV minbucket;
    /* Level 1 info */
    UV *bucket_mem_size;
    UV *bucket_available_size;
    UV nbuckets;
};
typedef struct perl_mstats perl_mstats_t;

START_EXTERN_C
Malloc_t Perl_malloc (MEM_SIZE nbytes);
Malloc_t Perl_calloc (MEM_SIZE elements, MEM_SIZE size);
Malloc_t Perl_realloc (Malloc_t where, MEM_SIZE nbytes);
/* 'mfree' rather than 'free', since there is already a 'perl_free'
 * that causes clashes with case-insensitive linkers */
Free_t   Perl_mfree (Malloc_t where);
END_EXTERN_C

#ifndef NO_MALLOC_DYNAMIC_CFG

/* IV configuration data */
enum {
  MallocCfg_FIRST_SBRK,
  MallocCfg_MIN_SBRK,
  MallocCfg_MIN_SBRK_FRAC1000,
  MallocCfg_SBRK_ALLOW_FAILURES,
  MallocCfg_SBRK_FAILURE_PRICE,
  MallocCfg_sbrk_goodness,

  MallocCfg_filldead,
  MallocCfg_fillalive,
  MallocCfg_fillcheck,

  MallocCfg_skip_cfg_env,
  MallocCfg_cfg_env_read,

  MallocCfg_emergency_buffer_size,
  MallocCfg_emergency_buffer_last_req,

  MallocCfg_emergency_buffer_prepared_size,

  MallocCfg_last
};
/* char* configuration data */
enum {
  MallocCfgP_emergency_buffer,
  MallocCfgP_emergency_buffer_prepared,
  MallocCfgP_last
};
START_EXTERN_C
extern IV *MallocCfg_ptr;
extern char **MallocCfgP_ptr;
END_EXTERN_C

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\hv.h ===
/*    hv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* entry in hash value chain */
struct he {
    /* Keep hent_next first in this structure, because sv_free_arenas take
       advantage of this to share code between the he arenas and the SV
       body arenas  */
    HE		*hent_next;	/* next entry in chain */
    HEK		*hent_hek;	/* hash key */
    union {
	SV	*hent_val;	/* scalar value that was hashed */
	Size_t	hent_refcount;	/* references for this shared hash key */
    } he_valu;
};

/* hash key -- defined separately for use as shared pointer */
struct hek {
    U32		hek_hash;	/* hash of key */
    I32		hek_len;	/* length of hash key */
    char	hek_key[1];	/* variable-length hash key */
    /* the hash-key is \0-terminated */
    /* after the \0 there is a byte for flags, such as whether the key
       is UTF-8 */
};

struct shared_he {
    struct he shared_he_he;
    struct hek shared_he_hek;
};

/* Subject to change.
   Don't access this directly.
   Use the funcs in mro.c
*/


/* structure may change, so not public yet */
struct mro_alg;

struct mro_meta {
    AV      *mro_linear_dfs; /* cached dfs @ISA linearization */
    AV      *mro_linear_c3;  /* cached c3 @ISA linearization */
    HV      *mro_nextmethod; /* next::method caching */
    U32     cache_gen;       /* Bumping this invalidates our method cache */
    U32     pkg_gen;         /* Bumps when local methods/@ISA change */
    const struct mro_alg *mro_which; /* which mro alg is in use? */
};

/* Subject to change.
   Don't access this directly.
*/

struct xpvhv_aux {
    HEK		*xhv_name;	/* name, if a symbol table */
    AV		*xhv_backreferences; /* back references for weak references */
    HE		*xhv_eiter;	/* current entry of iterator */
    I32		xhv_riter;	/* current root of iterator */
    struct mro_meta *xhv_mro_meta;
};

/* hash structure: */
/* This structure must match the beginning of struct xpvmg in sv.h. */
struct xpvhv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xhv_fill;	/* how full xhv_array currently is */
    STRLEN	xhv_max;	/* subscript of last element of xhv_array */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
};

#define xhv_keys xiv_u.xivu_iv

typedef struct {
    STRLEN	xhv_fill;	/* how full xhv_array currently is */
    STRLEN	xhv_max;	/* subscript of last element of xhv_array */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
} xpvhv_allocated;

/* hash a key */
/* FYI: This is the "One-at-a-Time" algorithm by Bob Jenkins
 * from requirements by Colin Plumb.
 * (http://burtleburtle.net/bob/hash/doobs.html) */
/* The use of a temporary pointer and the casting games
 * is needed to serve the dual purposes of
 * (a) the hashed data being interpreted as "unsigned char" (new since 5.8,
 *     a "char" can be either signed or unsigned, depending on the compiler)
 * (b) catering for old code that uses a "char"
 *
 * The "hash seed" feature was added in Perl 5.8.1 to perturb the results
 * to avoid "algorithmic complexity attacks".
 *
 * If USE_HASH_SEED is defined, hash randomisation is done by default
 * If USE_HASH_SEED_EXPLICIT is defined, hash randomisation is done
 * only if the environment variable PERL_HASH_SEED is set.
 * For maximal control, one can define PERL_HASH_SEED.
 * (see also perl.c:perl_parse()).
 */
#ifndef PERL_HASH_SEED
#   if defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT)
#       define PERL_HASH_SEED	PL_hash_seed
#   else
#       define PERL_HASH_SEED	0
#   endif
#endif
#define PERL_HASH(hash,str,len) \
     STMT_START	{ \
	register const char * const s_PeRlHaSh_tmp = str; \
	register const unsigned char *s_PeRlHaSh = (const unsigned char *)s_PeRlHaSh_tmp; \
	register I32 i_PeRlHaSh = len; \
	register U32 hash_PeRlHaSh = PERL_HASH_SEED; \
	while (i_PeRlHaSh--) { \
	    hash_PeRlHaSh += *s_PeRlHaSh++; \
	    hash_PeRlHaSh += (hash_PeRlHaSh << 10); \
	    hash_PeRlHaSh ^= (hash_PeRlHaSh >> 6); \
	} \
	hash_PeRlHaSh += (hash_PeRlHaSh << 3); \
	hash_PeRlHaSh ^= (hash_PeRlHaSh >> 11); \
	(hash) = (hash_PeRlHaSh + (hash_PeRlHaSh << 15)); \
    } STMT_END

/* Only hv.c and mod_perl should be doing this.  */
#ifdef PERL_HASH_INTERNAL_ACCESS
#define PERL_HASH_INTERNAL(hash,str,len) \
     STMT_START	{ \
	register const char * const s_PeRlHaSh_tmp = str; \
	register const unsigned char *s_PeRlHaSh = (const unsigned char *)s_PeRlHaSh_tmp; \
	register I32 i_PeRlHaSh = len; \
	register U32 hash_PeRlHaSh = PL_rehash_seed; \
	while (i_PeRlHaSh--) { \
	    hash_PeRlHaSh += *s_PeRlHaSh++; \
	    hash_PeRlHaSh += (hash_PeRlHaSh << 10); \
	    hash_PeRlHaSh ^= (hash_PeRlHaSh >> 6); \
	} \
	hash_PeRlHaSh += (hash_PeRlHaSh << 3); \
	hash_PeRlHaSh ^= (hash_PeRlHaSh >> 11); \
	(hash) = (hash_PeRlHaSh + (hash_PeRlHaSh << 15)); \
    } STMT_END
#endif

/*
=head1 Hash Manipulation Functions

=for apidoc AmU||HEf_SVKEY
This flag, used in the length slot of hash entries and magic structures,
specifies the structure contains an C<SV*> pointer where a C<char*> pointer
is to be expected. (For information only--not to be used).

=head1 Handy Values

=for apidoc AmU||Nullhv
Null HV pointer.

=head1 Hash Manipulation Functions

=for apidoc Am|char*|HvNAME|HV* stash
Returns the package name of a stash, or NULL if C<stash> isn't a stash.
See C<SvSTASH>, C<CvSTASH>.

=for apidoc Am|void*|HeKEY|HE* he
Returns the actual pointer stored in the key slot of the hash entry. The
pointer may be either C<char*> or C<SV*>, depending on the value of
C<HeKLEN()>.  Can be assigned to.  The C<HePV()> or C<HeSVKEY()> macros are
usually preferable for finding the value of a key.

=for apidoc Am|STRLEN|HeKLEN|HE* he
If this is negative, and amounts to C<HEf_SVKEY>, it indicates the entry
holds an C<SV*> key.  Otherwise, holds the actual length of the key.  Can
be assigned to. The C<HePV()> macro is usually preferable for finding key
lengths.

=for apidoc Am|SV*|HeVAL|HE* he
Returns the value slot (type C<SV*>) stored in the hash entry.

=for apidoc Am|U32|HeHASH|HE* he
Returns the computed hash stored in the hash entry.

=for apidoc Am|char*|HePV|HE* he|STRLEN len
Returns the key slot of the hash entry as a C<char*> value, doing any
necessary dereferencing of possibly C<SV*> keys.  The length of the string
is placed in C<len> (this is a macro, so do I<not> use C<&len>).  If you do
not care about what the length of the key is, you may use the global
variable C<PL_na>, though this is rather less efficient than using a local
variable.  Remember though, that hash keys in perl are free to contain
embedded nulls, so using C<strlen()> or similar is not a good way to find
the length of hash keys. This is very similar to the C<SvPV()> macro
described elsewhere in this document.

=for apidoc Am|SV*|HeSVKEY|HE* he
Returns the key as an C<SV*>, or C<NULL> if the hash entry does not
contain an C<SV*> key.

=for apidoc Am|SV*|HeSVKEY_force|HE* he
Returns the key as an C<SV*>.  Will create and return a temporary mortal
C<SV*> if the hash entry contains only a C<char*> key.

=for apidoc Am|SV*|HeSVKEY_set|HE* he|SV* sv
Sets the key to a given C<SV*>, taking care to set the appropriate flags to
indicate the presence of an C<SV*> key, and returns the same
C<SV*>.

=cut
*/

/* these hash entry flags ride on hent_klen (for use only in magic/tied HVs) */
#define HEf_SVKEY	-2	/* hent_key is an SV* */


#define Nullhv Null(HV*)
#define HvARRAY(hv)	((hv)->sv_u.svu_hash)
#define HvFILL(hv)	((XPVHV*)  SvANY(hv))->xhv_fill
#define HvMAX(hv)	((XPVHV*)  SvANY(hv))->xhv_max
/* This quite intentionally does no flag checking first. That's your
   responsibility.  */
#define HvAUX(hv)	((struct xpvhv_aux*)&(HvARRAY(hv)[HvMAX(hv)+1]))
#define HvRITER(hv)	(*Perl_hv_riter_p(aTHX_ (HV*)(hv)))
#define HvEITER(hv)	(*Perl_hv_eiter_p(aTHX_ (HV*)(hv)))
#define HvRITER_set(hv,r)	Perl_hv_riter_set(aTHX_ (HV*)(hv), r)
#define HvEITER_set(hv,e)	Perl_hv_eiter_set(aTHX_ (HV*)(hv), e)
#define HvRITER_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_riter : -1)
#define HvEITER_get(hv)	(SvOOK(hv) ? HvAUX(hv)->xhv_eiter : NULL)
#define HvNAME(hv)	HvNAME_get(hv)

/* Checking that hv is a valid package stash is the
   caller's responsibility */
#define HvMROMETA(hv) (HvAUX(hv)->xhv_mro_meta \
                       ? HvAUX(hv)->xhv_mro_meta \
                       : mro_meta_init(hv))

/* FIXME - all of these should use a UTF8 aware API, which should also involve
   getting the length. */
/* This macro may go away without notice.  */
#define HvNAME_HEK(hv) (SvOOK(hv) ? HvAUX(hv)->xhv_name : NULL)
#define HvNAME_get(hv)	((SvOOK(hv) && (HvAUX(hv)->xhv_name)) \
			 ? HEK_KEY(HvAUX(hv)->xhv_name) : NULL)
#define HvNAMELEN_get(hv)	((SvOOK(hv) && (HvAUX(hv)->xhv_name)) \
				 ? HEK_LEN(HvAUX(hv)->xhv_name) : 0)

/* the number of keys (including any placeholers) */
#define XHvTOTALKEYS(xhv)	((xhv)->xhv_keys)

/*
 * HvKEYS gets the number of keys that actually exist(), and is provided
 * for backwards compatibility with old XS code. The core uses HvUSEDKEYS
 * (keys, excluding placeholdes) and HvTOTALKEYS (including placeholders)
 */
#define HvKEYS(hv)		HvUSEDKEYS(hv)
#define HvUSEDKEYS(hv)		(HvTOTALKEYS(hv) - HvPLACEHOLDERS_get(hv))
#define HvTOTALKEYS(hv)		XHvTOTALKEYS((XPVHV*)  SvANY(hv))
#define HvPLACEHOLDERS(hv)	(*Perl_hv_placeholders_p(aTHX_ (HV*)hv))
#define HvPLACEHOLDERS_get(hv)	(SvMAGIC(hv) ? Perl_hv_placeholders_get(aTHX_ (HV*)hv) : 0)
#define HvPLACEHOLDERS_set(hv,p)	Perl_hv_placeholders_set(aTHX_ (HV*)hv, p)

#define HvSHAREKEYS(hv)		(SvFLAGS(hv) & SVphv_SHAREKEYS)
#define HvSHAREKEYS_on(hv)	(SvFLAGS(hv) |= SVphv_SHAREKEYS)
#define HvSHAREKEYS_off(hv)	(SvFLAGS(hv) &= ~SVphv_SHAREKEYS)

/* This is an optimisation flag. It won't be set if all hash keys have a 0
 * flag. Currently the only flags relate to utf8.
 * Hence it won't be set if all keys are 8 bit only. It will be set if any key
 * is utf8 (including 8 bit keys that were entered as utf8, and need upgrading
 * when retrieved during iteration. It may still be set when there are no longer
 * any utf8 keys.
 * See HVhek_ENABLEHVKFLAGS for the trigger.
 */
#define HvHASKFLAGS(hv)		(SvFLAGS(hv) & SVphv_HASKFLAGS)
#define HvHASKFLAGS_on(hv)	(SvFLAGS(hv) |= SVphv_HASKFLAGS)
#define HvHASKFLAGS_off(hv)	(SvFLAGS(hv) &= ~SVphv_HASKFLAGS)

#define HvLAZYDEL(hv)		(SvFLAGS(hv) & SVphv_LAZYDEL)
#define HvLAZYDEL_on(hv)	(SvFLAGS(hv) |= SVphv_LAZYDEL)
#define HvLAZYDEL_off(hv)	(SvFLAGS(hv) &= ~SVphv_LAZYDEL)

#define HvREHASH(hv)		(SvFLAGS(hv) & SVphv_REHASH)
#define HvREHASH_on(hv)		(SvFLAGS(hv) |= SVphv_REHASH)
#define HvREHASH_off(hv)	(SvFLAGS(hv) &= ~SVphv_REHASH)

#define Nullhe Null(HE*)
#define HeNEXT(he)		(he)->hent_next
#define HeKEY_hek(he)		(he)->hent_hek
#define HeKEY(he)		HEK_KEY(HeKEY_hek(he))
#define HeKEY_sv(he)		(*(SV**)HeKEY(he))
#define HeKLEN(he)		HEK_LEN(HeKEY_hek(he))
#define HeKUTF8(he)  HEK_UTF8(HeKEY_hek(he))
#define HeKWASUTF8(he)  HEK_WASUTF8(HeKEY_hek(he))
#define HeKREHASH(he)  HEK_REHASH(HeKEY_hek(he))
#define HeKLEN_UTF8(he)  (HeKUTF8(he) ? -HeKLEN(he) : HeKLEN(he))
#define HeKFLAGS(he)  HEK_FLAGS(HeKEY_hek(he))
#define HeVAL(he)		(he)->he_valu.hent_val
#define HeHASH(he)		HEK_HASH(HeKEY_hek(he))
#define HePV(he,lp)		((HeKLEN(he) == HEf_SVKEY) ?		\
				 SvPV(HeKEY_sv(he),lp) :		\
				 ((lp = HeKLEN(he)), HeKEY(he)))

#define HeSVKEY(he)		((HeKEY(he) && 				\
				  HeKLEN(he) == HEf_SVKEY) ?		\
				 HeKEY_sv(he) : NULL)

#define HeSVKEY_force(he)	(HeKEY(he) ?				\
				 ((HeKLEN(he) == HEf_SVKEY) ?		\
				  HeKEY_sv(he) :			\
				  sv_2mortal(newSVpvn(HeKEY(he),	\
						     HeKLEN(he)))) :	\
				 &PL_sv_undef)
#define HeSVKEY_set(he,sv)	((HeKLEN(he) = HEf_SVKEY), (HeKEY_sv(he) = sv))

#define Nullhek Null(HEK*)
#define HEK_BASESIZE		STRUCT_OFFSET(HEK, hek_key[0])
#define HEK_HASH(hek)		(hek)->hek_hash
#define HEK_LEN(hek)		(hek)->hek_len
#define HEK_KEY(hek)		(hek)->hek_key
#define HEK_FLAGS(hek)	(*((unsigned char *)(HEK_KEY(hek))+HEK_LEN(hek)+1))

#define HVhek_UTF8	0x01 /* Key is utf8 encoded. */
#define HVhek_WASUTF8	0x02 /* Key is bytes here, but was supplied as utf8. */
#define HVhek_REHASH	0x04 /* This key is in an hv using a custom HASH . */
#define HVhek_UNSHARED	0x08 /* This key isn't a shared hash key. */
#define HVhek_FREEKEY	0x100 /* Internal flag to say key is malloc()ed.  */
#define HVhek_PLACEHOLD	0x200 /* Internal flag to create placeholder.
                               * (may change, but Storable is a core module) */
#define HVhek_MASK	0xFF

/* Which flags enable HvHASKFLAGS? Somewhat a hack on a hack, as
   HVhek_REHASH is only needed because the rehash flag has to be duplicated
   into all keys as hv_iternext has no access to the hash flags. At this
   point Storable's tests get upset, because sometimes hashes are "keyed"
   and sometimes not, depending on the order of data insertion, and whether
   it triggered rehashing. So currently HVhek_REHASH is exempt.
   Similarly UNSHARED
*/
   
#define HVhek_ENABLEHVKFLAGS	(HVhek_MASK & ~(HVhek_REHASH|HVhek_UNSHARED))

#define HEK_UTF8(hek)		(HEK_FLAGS(hek) & HVhek_UTF8)
#define HEK_UTF8_on(hek)	(HEK_FLAGS(hek) |= HVhek_UTF8)
#define HEK_UTF8_off(hek)	(HEK_FLAGS(hek) &= ~HVhek_UTF8)
#define HEK_WASUTF8(hek)	(HEK_FLAGS(hek) & HVhek_WASUTF8)
#define HEK_WASUTF8_on(hek)	(HEK_FLAGS(hek) |= HVhek_WASUTF8)
#define HEK_WASUTF8_off(hek)	(HEK_FLAGS(hek) &= ~HVhek_WASUTF8)
#define HEK_REHASH(hek)		(HEK_FLAGS(hek) & HVhek_REHASH)
#define HEK_REHASH_on(hek)	(HEK_FLAGS(hek) |= HVhek_REHASH)

/* calculate HV array allocation */
#ifndef PERL_USE_LARGE_HV_ALLOC
/* Default to allocating the correct size - default to assuming that malloc()
   is not broken and is efficient at allocating blocks sized at powers-of-two.
*/   
#  define PERL_HV_ARRAY_ALLOC_BYTES(size) ((size) * sizeof(HE*))
#else
#  define MALLOC_OVERHEAD 16
#  define PERL_HV_ARRAY_ALLOC_BYTES(size) \
			(((size) < 64)					\
			 ? (size) * sizeof(HE*)				\
			 : (size) * sizeof(HE*) * 2 - MALLOC_OVERHEAD)
#endif

/* Flags for hv_iternext_flags.  */
#define HV_ITERNEXT_WANTPLACEHOLDERS	0x01	/* Don't skip placeholders.  */

#define hv_iternext(hv)	hv_iternext_flags(hv, 0)
#define hv_magic(hv, gv, how) sv_magic((SV*)(hv), (SV*)(gv), how, NULL, 0)

/* available as a function in hv.c */
#define Perl_sharepvn(sv, len, hash) HEK_KEY(share_hek(sv, len, hash))
#define sharepvn(sv, len, hash)	     Perl_sharepvn(sv, len, hash)

#define share_hek_hek(hek)						\
    (++(((struct shared_he *)(((char *)hek)				\
			      - STRUCT_OFFSET(struct shared_he,		\
					      shared_he_hek)))		\
	->shared_he_he.he_valu.hent_refcount),				\
     hek)

#define hv_store_ent(zlonk, awk, touche, zgruppp)			\
    ((HE *) hv_common((zlonk), (awk), NULL, 0, 0, HV_FETCH_ISSTORE,	\
		      (touche), (zgruppp)))

#define hv_exists_ent(zlonk, awk, zgruppp)				\
    (hv_common((zlonk), (awk), NULL, 0, 0, HV_FETCH_ISEXISTS, 0, (zgruppp))\
     ? TRUE : FALSE)
#define hv_fetch_ent(zlonk, awk, touche, zgruppp)			\
    ((HE *) hv_common((zlonk), (awk), NULL, 0, 0,			\
		      ((touche) ? HV_FETCH_LVALUE : 0), NULL, (zgruppp)))
#define hv_delete_ent(zlonk, awk, touche, zgruppp)			\
    ((SV *) hv_common((zlonk), (awk), NULL, 0, 0, (touche) | HV_DELETE,	\
		      NULL, (zgruppp)))

#define hv_store_flags(urkk, zamm, clunk, thwape, sploosh, eee_yow)	\
    ((SV**) hv_common((urkk), NULL, (zamm), (clunk), (eee_yow),		\
		      (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV), (thwape),	\
		      (sploosh)))

#define hv_store(urkk, zamm, clunk, thwape, sploosh)			\
    ((SV**) hv_common_key_len((urkk), (zamm), (clunk),			\
			      (HV_FETCH_ISSTORE|HV_FETCH_JUST_SV),	\
			      (thwape), (sploosh)))

#define hv_exists(urkk, zamm, clunk)					\
    (hv_common_key_len((urkk), (zamm), (clunk), HV_FETCH_ISEXISTS, NULL, 0) \
     ? TRUE : FALSE)

#define hv_fetch(urkk, zamm, clunk, pam)				\
    ((SV**) hv_common_key_len((urkk), (zamm), (clunk), (pam)		\
			      ? (HV_FETCH_JUST_SV | HV_FETCH_LVALUE)	\
			      : HV_FETCH_JUST_SV, NULL, 0))

#define hv_delete(urkk, zamm, clunk, pam)				\
    ((SV*) hv_common_key_len((urkk), (zamm), (clunk),			\
			     (pam) | HV_DELETE, NULL, 0))

/* This refcounted he structure is used for storing the hints used for lexical
   pragmas. Without threads, it's basically struct he + refcount.
   With threads, life gets more complex as the structure needs to be shared
   between threads (because it hangs from OPs, which are shared), hence the
   alternate definition and mutex.  */

struct refcounted_he;

#ifdef PERL_CORE

/* Gosh. This really isn't a good name any longer.  */
struct refcounted_he {
    struct refcounted_he *refcounted_he_next;	/* next entry in chain */
#ifdef USE_ITHREADS
    U32                   refcounted_he_hash;
    U32                   refcounted_he_keylen;
#else
    HEK                  *refcounted_he_hek;	/* hint key */
#endif
    union {
	IV                refcounted_he_u_iv;
	UV                refcounted_he_u_uv;
	STRLEN            refcounted_he_u_len;
	void		 *refcounted_he_u_ptr;	/* Might be useful in future */
    } refcounted_he_val;
    U32	                  refcounted_he_refcnt;	/* reference count */
    /* First byte is flags. Then NUL-terminated value. Then for ithreads,
       non-NUL terminated key.  */
    char                  refcounted_he_data[1];
};

/* Flag bits are HVhek_UTF8, HVhek_WASUTF8, then */
#define HVrhek_undef	0x00 /* Value is undef. */
#define HVrhek_delete	0x10 /* Value is placeholder - signifies delete. */
#define HVrhek_IV	0x20 /* Value is IV. */
#define HVrhek_UV	0x30 /* Value is UV. */
#define HVrhek_PV	0x40 /* Value is a (byte) string. */
#define HVrhek_PV_UTF8	0x50 /* Value is a (utf8) string. */
/* Two spare. As these have to live in the optree, you can't store anything
   interpreter specific, such as SVs. :-( */
#define HVrhek_typemask 0x70

#ifdef USE_ITHREADS
/* A big expression to find the key offset */
#define REF_HE_KEY(chain)						\
	((((chain->refcounted_he_data[0] & 0x60) == 0x40)		\
	    ? chain->refcounted_he_val.refcounted_he_u_len + 1 : 0)	\
	 + 1 + chain->refcounted_he_data)
#endif

#  ifdef USE_ITHREADS
#    define HINTS_REFCNT_LOCK		MUTEX_LOCK(&PL_hints_mutex)
#    define HINTS_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_hints_mutex)
#  else
#    define HINTS_REFCNT_LOCK		NOOP
#    define HINTS_REFCNT_UNLOCK		NOOP
#  endif
#endif

#ifdef USE_ITHREADS
#  define HINTS_REFCNT_INIT		MUTEX_INIT(&PL_hints_mutex)
#  define HINTS_REFCNT_TERM		MUTEX_DESTROY(&PL_hints_mutex)
#else
#  define HINTS_REFCNT_INIT		NOOP
#  define HINTS_REFCNT_TERM		NOOP
#endif

/* Hash actions
 * Passed in PERL_MAGIC_uvar calls
 */
#define HV_DISABLE_UVAR_XKEY	0x01
/* We need to ensure that these don't clash with G_DISCARD, which is 2, as it
   is documented as being passed to hv_delete().  */
#define HV_FETCH_ISSTORE	0x04
#define HV_FETCH_ISEXISTS	0x08
#define HV_FETCH_LVALUE		0x10
#define HV_FETCH_JUST_SV	0x20
#define HV_DELETE		0x40

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\INTERN.h ===
/*    INTERN.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1995, 1996, 1998, 2000, 2001,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * EXT  designates a global var which is defined in perl.h
 * dEXT designates a global var which is defined in another
 *      file, so we can't count on finding it in perl.h
 *      (this practice should be avoided).
 */
#undef EXT
#undef dEXT
#undef EXTCONST
#undef dEXTCONST
#if defined(VMS) && !defined(__GNUC__)
    /* Suppress portability warnings from DECC for VMS-specific extensions */
#  ifdef __DECC
#    pragma message disable (GLOBALEXT,NOSHAREEXT,READONLYEXT)
#  endif
#  define EXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define dEXT globaldef {"$GLOBAL_RW_VARS"} noshare
#  define EXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#  define dEXTCONST globaldef {"$GLOBAL_RO_VARS"} readonly
#else
#  if (defined(WIN32) && defined(__MINGW32__)) || defined(__SYMBIAN32__)
#    define EXT		__declspec(dllexport)
#    define dEXT
#    define EXTCONST	__declspec(dllexport) const
#    define dEXTCONST	const
#  else
#    ifdef __cplusplus
#      define EXT
#      define dEXT
#      define EXTCONST extern const
#      define dEXTCONST const
#    else
#      define EXT
#      define dEXT
#      define EXTCONST const
#      define dEXTCONST const
#    endif
#  endif
#endif

#undef INIT
#define INIT(x) = x

#define DOINIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\netdb.h ===
/* netdb.h */

/* djl */
/* Provide UNIX compatibility */


#ifndef  _INC_NETDB
#define  _INC_NETDB

#include <sys/socket.h>

#endif /* _INC_NETDB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\nostdio.h ===
/*    nostdio.h
 *
 *    Copyright (C) 1996, 2000, 2001, 2005, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Strong denial of stdio - make all stdio calls (we can think of) errors
 */
/* This is a 1st attempt to stop other include files pulling
   in real <stdio.h>.
   A more ambitious set of possible symbols can be found in
   sfio.h (inside an _cplusplus gard).
   It is completely pointless as we have already included it ourselves.
*/

#if !defined(_STDIO_H) && !defined(FILE) && !defined(_STDIO_INCLUDED) && !defined(__STDIO_LOADED)
#define _STDIO_H
#define _STDIO_INCLUDED
#define __STDIO_LOADED
struct _FILE;
#define FILE struct _FILE
#endif

#define _CANNOT "CANNOT"

#undef clearerr
#undef fclose
#undef fdopen
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fileno
#undef flockfile
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef ftrylockfile
#undef funlockfile
#undef fwrite
#undef getc
#undef getc_unlocked
#undef getw
#undef pclose
#undef popen
#undef putc
#undef putc_unlocked
#undef putw
#undef rewind
#undef setbuf
#undef setvbuf
#undef stderr
#undef stdin
#undef stdout
#undef tmpfile
#undef ungetc
#undef vfprintf
#undef printf

#define fprintf    _CANNOT _fprintf_
#define printf     _CANNOT _printf_
#define stdin      _CANNOT _stdin_
#define stdout     _CANNOT _stdout_
#define stderr     _CANNOT _stderr_
#ifndef OS2
#define tmpfile()  _CANNOT _tmpfile_
#endif
#define fclose(f)  _CANNOT _fclose_
#define fflush(f)  _CANNOT _fflush_
#define fopen(p,m)  _CANNOT _fopen_
#define freopen(p,m,f)  _CANNOT _freopen_
#define setbuf(f,b)  _CANNOT _setbuf_
#define setvbuf(f,b,x,s)  _CANNOT _setvbuf_
#define fscanf  _CANNOT _fscanf_
#define vfprintf(f,fmt,a)  _CANNOT _vfprintf_
#define fgetc(f)  _CANNOT _fgetc_
#define fgets(s,n,f)  _CANNOT _fgets_
#define fputc(c,f)  _CANNOT _fputc_
#define fputs(s,f)  _CANNOT _fputs_
#define getc(f)  _CANNOT _getc_
#define putc(c,f)  _CANNOT _putc_
#ifndef OS2
#define ungetc(c,f)  _CANNOT _ungetc_
#endif
#define fread(b,s,c,f)  _CANNOT _fread_
#define fwrite(b,s,c,f)  _CANNOT _fwrite_
#define fgetpos(f,p)  _CANNOT _fgetpos_
#define fseek(f,o,w)  _CANNOT _fseek_
#define fsetpos(f,p)  _CANNOT _fsetpos_
#define ftell(f)  _CANNOT _ftell_
#define rewind(f)  _CANNOT _rewind_
#define clearerr(f)  _CANNOT _clearerr_
#define feof(f)  _CANNOT _feof_
#define ferror(f)  _CANNOT _ferror_
#define __filbuf(f)  _CANNOT __filbuf_
#define __flsbuf(c,f)  _CANNOT __flsbuf_
#define _filbuf(f)  _CANNOT _filbuf_
#define _flsbuf(c,f)  _CANNOT _flsbuf_
#define fdopen(fd,p)  _CANNOT _fdopen_
#define fileno(f)  _CANNOT _fileno_
#if defined(SFIO_VERSION) && SFIO_VERSION < 20000101L
#define flockfile(f)  _CANNOT _flockfile_
#define ftrylockfile(f)  _CANNOT _ftrylockfile_
#define funlockfile(f)  _CANNOT _funlockfile_
#endif
#define getc_unlocked(f)  _CANNOT _getc_unlocked_
#define putc_unlocked(c,f)  _CANNOT _putc_unlocked_
#define popen(c,m)  _CANNOT _popen_
#define getw(f)  _CANNOT _getw_
#define putw(v,f)  _CANNOT _putw_
#ifndef OS2
#define pclose(f)  _CANNOT _pclose_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\opcode.h ===
/* -*- buffer-read-only: t -*-
 *
 *    opcode.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by opcode.pl from its data.  Any changes made here
 *  will be lost!
 */

#ifndef PERL_GLOBAL_STRUCT_INIT

#define Perl_pp_i_preinc Perl_pp_preinc
#define Perl_pp_i_predec Perl_pp_predec
#define Perl_pp_i_postinc Perl_pp_postinc
#define Perl_pp_i_postdec Perl_pp_postdec

PERL_PPDEF(Perl_unimplemented_op)

START_EXTERN_C

#define OP_NAME(o) ((o)->op_type == OP_CUSTOM ? custom_op_name(o) : \
                    PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM ? custom_op_desc(o) : \
                    PL_op_desc[(o)->op_type])

#ifndef DOINIT
EXTCONST char* const PL_op_name[];
#else
EXTCONST char* const PL_op_name[] = {
	"null",
	"stub",
	"scalar",
	"pushmark",
	"wantarray",
	"const",
	"gvsv",
	"gv",
	"gelem",
	"padsv",
	"padav",
	"padhv",
	"padany",
	"pushre",
	"rv2gv",
	"rv2sv",
	"av2arylen",
	"rv2cv",
	"anoncode",
	"prototype",
	"refgen",
	"srefgen",
	"ref",
	"bless",
	"backtick",
	"glob",
	"readline",
	"rcatline",
	"regcmaybe",
	"regcreset",
	"regcomp",
	"match",
	"qr",
	"subst",
	"substcont",
	"trans",
	"sassign",
	"aassign",
	"chop",
	"schop",
	"chomp",
	"schomp",
	"defined",
	"undef",
	"study",
	"pos",
	"preinc",
	"i_preinc",
	"predec",
	"i_predec",
	"postinc",
	"i_postinc",
	"postdec",
	"i_postdec",
	"pow",
	"multiply",
	"i_multiply",
	"divide",
	"i_divide",
	"modulo",
	"i_modulo",
	"repeat",
	"add",
	"i_add",
	"subtract",
	"i_subtract",
	"concat",
	"stringify",
	"left_shift",
	"right_shift",
	"lt",
	"i_lt",
	"gt",
	"i_gt",
	"le",
	"i_le",
	"ge",
	"i_ge",
	"eq",
	"i_eq",
	"ne",
	"i_ne",
	"ncmp",
	"i_ncmp",
	"slt",
	"sgt",
	"sle",
	"sge",
	"seq",
	"sne",
	"scmp",
	"bit_and",
	"bit_xor",
	"bit_or",
	"negate",
	"i_negate",
	"not",
	"complement",
	"smartmatch",
	"atan2",
	"sin",
	"cos",
	"rand",
	"srand",
	"exp",
	"log",
	"sqrt",
	"int",
	"hex",
	"oct",
	"abs",
	"length",
	"substr",
	"vec",
	"index",
	"rindex",
	"sprintf",
	"formline",
	"ord",
	"chr",
	"crypt",
	"ucfirst",
	"lcfirst",
	"uc",
	"lc",
	"quotemeta",
	"rv2av",
	"aelemfast",
	"aelem",
	"aslice",
	"each",
	"values",
	"keys",
	"delete",
	"exists",
	"rv2hv",
	"helem",
	"hslice",
	"unpack",
	"pack",
	"split",
	"join",
	"list",
	"lslice",
	"anonlist",
	"anonhash",
	"splice",
	"push",
	"pop",
	"shift",
	"unshift",
	"sort",
	"reverse",
	"grepstart",
	"grepwhile",
	"mapstart",
	"mapwhile",
	"range",
	"flip",
	"flop",
	"and",
	"or",
	"xor",
	"dor",
	"cond_expr",
	"andassign",
	"orassign",
	"dorassign",
	"method",
	"entersub",
	"leavesub",
	"leavesublv",
	"caller",
	"warn",
	"die",
	"reset",
	"lineseq",
	"nextstate",
	"dbstate",
	"unstack",
	"enter",
	"leave",
	"scope",
	"enteriter",
	"iter",
	"enterloop",
	"leaveloop",
	"return",
	"last",
	"next",
	"redo",
	"dump",
	"goto",
	"exit",
	"setstate",
	"method_named",
	"entergiven",
	"leavegiven",
	"enterwhen",
	"leavewhen",
	"break",
	"continue",
	"open",
	"close",
	"pipe_op",
	"fileno",
	"umask",
	"binmode",
	"tie",
	"untie",
	"tied",
	"dbmopen",
	"dbmclose",
	"sselect",
	"select",
	"getc",
	"read",
	"enterwrite",
	"leavewrite",
	"prtf",
	"print",
	"say",
	"sysopen",
	"sysseek",
	"sysread",
	"syswrite",
	"send",
	"recv",
	"eof",
	"tell",
	"seek",
	"truncate",
	"fcntl",
	"ioctl",
	"flock",
	"socket",
	"sockpair",
	"bind",
	"connect",
	"listen",
	"accept",
	"shutdown",
	"gsockopt",
	"ssockopt",
	"getsockname",
	"getpeername",
	"lstat",
	"stat",
	"ftrread",
	"ftrwrite",
	"ftrexec",
	"fteread",
	"ftewrite",
	"fteexec",
	"ftis",
	"ftsize",
	"ftmtime",
	"ftatime",
	"ftctime",
	"ftrowned",
	"fteowned",
	"ftzero",
	"ftsock",
	"ftchr",
	"ftblk",
	"ftfile",
	"ftdir",
	"ftpipe",
	"ftsuid",
	"ftsgid",
	"ftsvtx",
	"ftlink",
	"fttty",
	"fttext",
	"ftbinary",
	"chdir",
	"chown",
	"chroot",
	"unlink",
	"chmod",
	"utime",
	"rename",
	"link",
	"symlink",
	"readlink",
	"mkdir",
	"rmdir",
	"open_dir",
	"readdir",
	"telldir",
	"seekdir",
	"rewinddir",
	"closedir",
	"fork",
	"wait",
	"waitpid",
	"system",
	"exec",
	"kill",
	"getppid",
	"getpgrp",
	"setpgrp",
	"getpriority",
	"setpriority",
	"time",
	"tms",
	"localtime",
	"gmtime",
	"alarm",
	"sleep",
	"shmget",
	"shmctl",
	"shmread",
	"shmwrite",
	"msgget",
	"msgctl",
	"msgsnd",
	"msgrcv",
	"semop",
	"semget",
	"semctl",
	"require",
	"dofile",
	"entereval",
	"leaveeval",
	"entertry",
	"leavetry",
	"ghbyname",
	"ghbyaddr",
	"ghostent",
	"gnbyname",
	"gnbyaddr",
	"gnetent",
	"gpbyname",
	"gpbynumber",
	"gprotoent",
	"gsbyname",
	"gsbyport",
	"gservent",
	"shostent",
	"snetent",
	"sprotoent",
	"sservent",
	"ehostent",
	"enetent",
	"eprotoent",
	"eservent",
	"gpwnam",
	"gpwuid",
	"gpwent",
	"spwent",
	"epwent",
	"ggrnam",
	"ggrgid",
	"ggrent",
	"sgrent",
	"egrent",
	"getlogin",
	"syscall",
	"lock",
	"once",
	"custom",
};
#endif

#ifndef DOINIT
EXTCONST char* const PL_op_desc[];
#else
EXTCONST char* const PL_op_desc[] = {
	"null operation",
	"stub",
	"scalar",
	"pushmark",
	"wantarray",
	"constant item",
	"scalar variable",
	"glob value",
	"glob elem",
	"private variable",
	"private array",
	"private hash",
	"private value",
	"push regexp",
	"ref-to-glob cast",
	"scalar dereference",
	"array length",
	"subroutine dereference",
	"anonymous subroutine",
	"subroutine prototype",
	"reference constructor",
	"single ref constructor",
	"reference-type operator",
	"bless",
	"quoted execution (``, qx)",
	"glob",
	"<HANDLE>",
	"append I/O operator",
	"regexp internal guard",
	"regexp internal reset",
	"regexp compilation",
	"pattern match (m//)",
	"pattern quote (qr//)",
	"substitution (s///)",
	"substitution iterator",
	"transliteration (tr///)",
	"scalar assignment",
	"list assignment",
	"chop",
	"scalar chop",
	"chomp",
	"scalar chomp",
	"defined operator",
	"undef operator",
	"study",
	"match position",
	"preincrement (++)",
	"integer preincrement (++)",
	"predecrement (--)",
	"integer predecrement (--)",
	"postincrement (++)",
	"integer postincrement (++)",
	"postdecrement (--)",
	"integer postdecrement (--)",
	"exponentiation (**)",
	"multiplication (*)",
	"integer multiplication (*)",
	"division (/)",
	"integer division (/)",
	"modulus (%)",
	"integer modulus (%)",
	"repeat (x)",
	"addition (+)",
	"integer addition (+)",
	"subtraction (-)",
	"integer subtraction (-)",
	"concatenation (.) or string",
	"string",
	"left bitshift (<<)",
	"right bitshift (>>)",
	"numeric lt (<)",
	"integer lt (<)",
	"numeric gt (>)",
	"integer gt (>)",
	"numeric le (<=)",
	"integer le (<=)",
	"numeric ge (>=)",
	"integer ge (>=)",
	"numeric eq (==)",
	"integer eq (==)",
	"numeric ne (!=)",
	"integer ne (!=)",
	"numeric comparison (<=>)",
	"integer comparison (<=>)",
	"string lt",
	"string gt",
	"string le",
	"string ge",
	"string eq",
	"string ne",
	"string comparison (cmp)",
	"bitwise and (&)",
	"bitwise xor (^)",
	"bitwise or (|)",
	"negation (-)",
	"integer negation (-)",
	"not",
	"1's complement (~)",
	"smart match",
	"atan2",
	"sin",
	"cos",
	"rand",
	"srand",
	"exp",
	"log",
	"sqrt",
	"int",
	"hex",
	"oct",
	"abs",
	"length",
	"substr",
	"vec",
	"index",
	"rindex",
	"sprintf",
	"formline",
	"ord",
	"chr",
	"crypt",
	"ucfirst",
	"lcfirst",
	"uc",
	"lc",
	"quotemeta",
	"array dereference",
	"constant array element",
	"array element",
	"array slice",
	"each",
	"values",
	"keys",
	"delete",
	"exists",
	"hash dereference",
	"hash element",
	"hash slice",
	"unpack",
	"pack",
	"split",
	"join or string",
	"list",
	"list slice",
	"anonymous list ([])",
	"anonymous hash ({})",
	"splice",
	"push",
	"pop",
	"shift",
	"unshift",
	"sort",
	"reverse",
	"grep",
	"grep iterator",
	"map",
	"map iterator",
	"flipflop",
	"range (or flip)",
	"range (or flop)",
	"logical and (&&)",
	"logical or (||)",
	"logical xor",
	"defined or (//)",
	"conditional expression",
	"logical and assignment (&&=)",
	"logical or assignment (||=)",
	"defined or assignment (//=)",
	"method lookup",
	"subroutine entry",
	"subroutine exit",
	"lvalue subroutine return",
	"caller",
	"warn",
	"die",
	"symbol reset",
	"line sequence",
	"next statement",
	"debug next statement",
	"iteration finalizer",
	"block entry",
	"block exit",
	"block",
	"foreach loop entry",
	"foreach loop iterator",
	"loop entry",
	"loop exit",
	"return",
	"last",
	"next",
	"redo",
	"dump",
	"goto",
	"exit",
	"set statement info",
	"method with known name",
	"given()",
	"leave given block",
	"when()",
	"leave when block",
	"break",
	"continue",
	"open",
	"close",
	"pipe",
	"fileno",
	"umask",
	"binmode",
	"tie",
	"untie",
	"tied",
	"dbmopen",
	"dbmclose",
	"select system call",
	"select",
	"getc",
	"read",
	"write",
	"write exit",
	"printf",
	"print",
	"say",
	"sysopen",
	"sysseek",
	"sysread",
	"syswrite",
	"send",
	"recv",
	"eof",
	"tell",
	"seek",
	"truncate",
	"fcntl",
	"ioctl",
	"flock",
	"socket",
	"socketpair",
	"bind",
	"connect",
	"listen",
	"accept",
	"shutdown",
	"getsockopt",
	"setsockopt",
	"getsockname",
	"getpeername",
	"lstat",
	"stat",
	"-R",
	"-W",
	"-X",
	"-r",
	"-w",
	"-x",
	"-e",
	"-s",
	"-M",
	"-A",
	"-C",
	"-O",
	"-o",
	"-z",
	"-S",
	"-c",
	"-b",
	"-f",
	"-d",
	"-p",
	"-u",
	"-g",
	"-k",
	"-l",
	"-t",
	"-T",
	"-B",
	"chdir",
	"chown",
	"chroot",
	"unlink",
	"chmod",
	"utime",
	"rename",
	"link",
	"symlink",
	"readlink",
	"mkdir",
	"rmdir",
	"opendir",
	"readdir",
	"telldir",
	"seekdir",
	"rewinddir",
	"closedir",
	"fork",
	"wait",
	"waitpid",
	"system",
	"exec",
	"kill",
	"getppid",
	"getpgrp",
	"setpgrp",
	"getpriority",
	"setpriority",
	"time",
	"times",
	"localtime",
	"gmtime",
	"alarm",
	"sleep",
	"shmget",
	"shmctl",
	"shmread",
	"shmwrite",
	"msgget",
	"msgctl",
	"msgsnd",
	"msgrcv",
	"semop",
	"semget",
	"semctl",
	"require",
	"do \"file\"",
	"eval \"string\"",
	"eval \"string\" exit",
	"eval {block}",
	"eval {block} exit",
	"gethostbyname",
	"gethostbyaddr",
	"gethostent",
	"getnetbyname",
	"getnetbyaddr",
	"getnetent",
	"getprotobyname",
	"getprotobynumber",
	"getprotoent",
	"getservbyname",
	"getservbyport",
	"getservent",
	"sethostent",
	"setnetent",
	"setprotoent",
	"setservent",
	"endhostent",
	"endnetent",
	"endprotoent",
	"endservent",
	"getpwnam",
	"getpwuid",
	"getpwent",
	"setpwent",
	"endpwent",
	"getgrnam",
	"getgrgid",
	"getgrent",
	"setgrent",
	"endgrent",
	"getlogin",
	"syscall",
	"lock",
	"once",
	"unknown custom operator",
};
#endif

END_EXTERN_C

#endif /* !PERL_GLOBAL_STRUCT_INIT */

START_EXTERN_C

#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_PPADDR_INITED
static const Perl_ppaddr_t Gppaddr[]
#else
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_PPADDR_INITED
EXT Perl_ppaddr_t PL_ppaddr[] /* or perlvars.h */
#  endif
#endif /* PERL_GLOBAL_STRUCT */
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_PPADDR_INITED
= {
	MEMBER_TO_FPTR(Perl_pp_null),
	MEMBER_TO_FPTR(Perl_pp_stub),
	MEMBER_TO_FPTR(Perl_pp_null),	/* Perl_pp_scalar */
	MEMBER_TO_FPTR(Perl_pp_pushmark),
	MEMBER_TO_FPTR(Perl_pp_wantarray),
	MEMBER_TO_FPTR(Perl_pp_const),
	MEMBER_TO_FPTR(Perl_pp_gvsv),
	MEMBER_TO_FPTR(Perl_pp_gv),
	MEMBER_TO_FPTR(Perl_pp_gelem),
	MEMBER_TO_FPTR(Perl_pp_padsv),
	MEMBER_TO_FPTR(Perl_pp_padav),
	MEMBER_TO_FPTR(Perl_pp_padhv),
	MEMBER_TO_FPTR(Perl_unimplemented_op),	/* Perl_pp_padany */
	MEMBER_TO_FPTR(Perl_pp_pushre),
	MEMBER_TO_FPTR(Perl_pp_rv2gv),
	MEMBER_TO_FPTR(Perl_pp_rv2sv),
	MEMBER_TO_FPTR(Perl_pp_av2arylen),
	MEMBER_TO_FPTR(Perl_pp_rv2cv),
	MEMBER_TO_FPTR(Perl_pp_anoncode),
	MEMBER_TO_FPTR(Perl_pp_prototype),
	MEMBER_TO_FPTR(Perl_pp_refgen),
	MEMBER_TO_FPTR(Perl_pp_srefgen),
	MEMBER_TO_FPTR(Perl_pp_ref),
	MEMBER_TO_FPTR(Perl_pp_bless),
	MEMBER_TO_FPTR(Perl_pp_backtick),
	MEMBER_TO_FPTR(Perl_pp_glob),
	MEMBER_TO_FPTR(Perl_pp_readline),
	MEMBER_TO_FPTR(Perl_pp_rcatline),
	MEMBER_TO_FPTR(Perl_pp_null),	/* Perl_pp_regcmaybe */
	MEMBER_TO_FPTR(Perl_pp_regcreset),
	MEMBER_TO_FPTR(Perl_pp_regcomp),
	MEMBER_TO_FPTR(Perl_pp_match),
	MEMBER_TO_FPTR(Perl_pp_qr),
	MEMBER_TO_FPTR(Perl_pp_subst),
	MEMBER_TO_FPTR(Perl_pp_substcont),
	MEMBER_TO_FPTR(Perl_pp_trans),
	MEMBER_TO_FPTR(Perl_pp_sassign),
	MEMBER_TO_FPTR(Perl_pp_aassign),
	MEMBER_TO_FPTR(Perl_pp_chop),
	MEMBER_TO_FPTR(Perl_pp_schop),
	MEMBER_TO_FPTR(Perl_pp_chomp),
	MEMBER_TO_FPTR(Perl_pp_schomp),
	MEMBER_TO_FPTR(Perl_pp_defined),
	MEMBER_TO_FPTR(Perl_pp_undef),
	MEMBER_TO_FPTR(Perl_pp_study),
	MEMBER_TO_FPTR(Perl_pp_pos),
	MEMBER_TO_FPTR(Perl_pp_preinc),
	MEMBER_TO_FPTR(Perl_pp_i_preinc),
	MEMBER_TO_FPTR(Perl_pp_predec),
	MEMBER_TO_FPTR(Perl_pp_i_predec),
	MEMBER_TO_FPTR(Perl_pp_postinc),
	MEMBER_TO_FPTR(Perl_pp_i_postinc),
	MEMBER_TO_FPTR(Perl_pp_postdec),
	MEMBER_TO_FPTR(Perl_pp_i_postdec),
	MEMBER_TO_FPTR(Perl_pp_pow),
	MEMBER_TO_FPTR(Perl_pp_multiply),
	MEMBER_TO_FPTR(Perl_pp_i_multiply),
	MEMBER_TO_FPTR(Perl_pp_divide),
	MEMBER_TO_FPTR(Perl_pp_i_divide),
	MEMBER_TO_FPTR(Perl_pp_modulo),
	MEMBER_TO_FPTR(Perl_pp_i_modulo),
	MEMBER_TO_FPTR(Perl_pp_repeat),
	MEMBER_TO_FPTR(Perl_pp_add),
	MEMBER_TO_FPTR(Perl_pp_i_add),
	MEMBER_TO_FPTR(Perl_pp_subtract),
	MEMBER_TO_FPTR(Perl_pp_i_subtract),
	MEMBER_TO_FPTR(Perl_pp_concat),
	MEMBER_TO_FPTR(Perl_pp_stringify),
	MEMBER_TO_FPTR(Perl_pp_left_shift),
	MEMBER_TO_FPTR(Perl_pp_right_shift),
	MEMBER_TO_FPTR(Perl_pp_lt),
	MEMBER_TO_FPTR(Perl_pp_i_lt),
	MEMBER_TO_FPTR(Perl_pp_gt),
	MEMBER_TO_FPTR(Perl_pp_i_gt),
	MEMBER_TO_FPTR(Perl_pp_le),
	MEMBER_TO_FPTR(Perl_pp_i_le),
	MEMBER_TO_FPTR(Perl_pp_ge),
	MEMBER_TO_FPTR(Perl_pp_i_ge),
	MEMBER_TO_FPTR(Perl_pp_eq),
	MEMBER_TO_FPTR(Perl_pp_i_eq),
	MEMBER_TO_FPTR(Perl_pp_ne),
	MEMBER_TO_FPTR(Perl_pp_i_ne),
	MEMBER_TO_FPTR(Perl_pp_ncmp),
	MEMBER_TO_FPTR(Perl_pp_i_ncmp),
	MEMBER_TO_FPTR(Perl_pp_sle),	/* Perl_pp_slt */
	MEMBER_TO_FPTR(Perl_pp_sle),	/* Perl_pp_sgt */
	MEMBER_TO_FPTR(Perl_pp_sle),
	MEMBER_TO_FPTR(Perl_pp_sle),	/* Perl_pp_sge */
	MEMBER_TO_FPTR(Perl_pp_seq),
	MEMBER_TO_FPTR(Perl_pp_sne),
	MEMBER_TO_FPTR(Perl_pp_scmp),
	MEMBER_TO_FPTR(Perl_pp_bit_and),
	MEMBER_TO_FPTR(Perl_pp_bit_or),	/* Perl_pp_bit_xor */
	MEMBER_TO_FPTR(Perl_pp_bit_or),
	MEMBER_TO_FPTR(Perl_pp_negate),
	MEMBER_TO_FPTR(Perl_pp_i_negate),
	MEMBER_TO_FPTR(Perl_pp_not),
	MEMBER_TO_FPTR(Perl_pp_complement),
	MEMBER_TO_FPTR(Perl_pp_smartmatch),
	MEMBER_TO_FPTR(Perl_pp_atan2),
	MEMBER_TO_FPTR(Perl_pp_sin),
	MEMBER_TO_FPTR(Perl_pp_sin),	/* Perl_pp_cos */
	MEMBER_TO_FPTR(Perl_pp_rand),
	MEMBER_TO_FPTR(Perl_pp_srand),
	MEMBER_TO_FPTR(Perl_pp_sin),	/* Perl_pp_exp */
	MEMBER_TO_FPTR(Perl_pp_sin),	/* Perl_pp_log */
	MEMBER_TO_FPTR(Perl_pp_sin),	/* Perl_pp_sqrt */
	MEMBER_TO_FPTR(Perl_pp_int),
	MEMBER_TO_FPTR(Perl_pp_oct),	/* Perl_pp_hex */
	MEMBER_TO_FPTR(Perl_pp_oct),
	MEMBER_TO_FPTR(Perl_pp_abs),
	MEMBER_TO_FPTR(Perl_pp_length),
	MEMBER_TO_FPTR(Perl_pp_substr),
	MEMBER_TO_FPTR(Perl_pp_vec),
	MEMBER_TO_FPTR(Perl_pp_index),
	MEMBER_TO_FPTR(Perl_pp_index),	/* Perl_pp_rindex */
	MEMBER_TO_FPTR(Perl_pp_sprintf),
	MEMBER_TO_FPTR(Perl_pp_formline),
	MEMBER_TO_FPTR(Perl_pp_ord),
	MEMBER_TO_FPTR(Perl_pp_chr),
	MEMBER_TO_FPTR(Perl_pp_crypt),
	MEMBER_TO_FPTR(Perl_pp_ucfirst),
	MEMBER_TO_FPTR(Perl_pp_ucfirst),	/* Perl_pp_lcfirst */
	MEMBER_TO_FPTR(Perl_pp_uc),
	MEMBER_TO_FPTR(Perl_pp_lc),
	MEMBER_TO_FPTR(Perl_pp_quotemeta),
	MEMBER_TO_FPTR(Perl_pp_rv2av),
	MEMBER_TO_FPTR(Perl_pp_aelemfast),
	MEMBER_TO_FPTR(Perl_pp_aelem),
	MEMBER_TO_FPTR(Perl_pp_aslice),
	MEMBER_TO_FPTR(Perl_pp_each),
	MEMBER_TO_FPTR(Perl_do_kv),	/* Perl_pp_values */
	MEMBER_TO_FPTR(Perl_do_kv),	/* Perl_pp_keys */
	MEMBER_TO_FPTR(Perl_pp_delete),
	MEMBER_TO_FPTR(Perl_pp_exists),
	MEMBER_TO_FPTR(Perl_pp_rv2av),	/* Perl_pp_rv2hv */
	MEMBER_TO_FPTR(Perl_pp_helem),
	MEMBER_TO_FPTR(Perl_pp_hslice),
	MEMBER_TO_FPTR(Perl_pp_unpack),
	MEMBER_TO_FPTR(Perl_pp_pack),
	MEMBER_TO_FPTR(Perl_pp_split),
	MEMBER_TO_FPTR(Perl_pp_join),
	MEMBER_TO_FPTR(Perl_pp_list),
	MEMBER_TO_FPTR(Perl_pp_lslice),
	MEMBER_TO_FPTR(Perl_pp_anonlist),
	MEMBER_TO_FPTR(Perl_pp_anonhash),
	MEMBER_TO_FPTR(Perl_pp_splice),
	MEMBER_TO_FPTR(Perl_pp_push),
	MEMBER_TO_FPTR(Perl_pp_shift),	/* Perl_pp_pop */
	MEMBER_TO_FPTR(Perl_pp_shift),
	MEMBER_TO_FPTR(Perl_pp_unshift),
	MEMBER_TO_FPTR(Perl_pp_sort),
	MEMBER_TO_FPTR(Perl_pp_reverse),
	MEMBER_TO_FPTR(Perl_pp_grepstart),
	MEMBER_TO_FPTR(Perl_pp_grepwhile),
	MEMBER_TO_FPTR(Perl_unimplemented_op),	/* Perl_pp_mapstart */
	MEMBER_TO_FPTR(Perl_pp_mapwhile),
	MEMBER_TO_FPTR(Perl_pp_range),
	MEMBER_TO_FPTR(Perl_pp_flip),
	MEMBER_TO_FPTR(Perl_pp_flop),
	MEMBER_TO_FPTR(Perl_pp_and),
	MEMBER_TO_FPTR(Perl_pp_or),
	MEMBER_TO_FPTR(Perl_pp_xor),
	MEMBER_TO_FPTR(Perl_pp_defined),	/* Perl_pp_dor */
	MEMBER_TO_FPTR(Perl_pp_cond_expr),
	MEMBER_TO_FPTR(Perl_pp_and),	/* Perl_pp_andassign */
	MEMBER_TO_FPTR(Perl_pp_or),	/* Perl_pp_orassign */
	MEMBER_TO_FPTR(Perl_pp_defined),	/* Perl_pp_dorassign */
	MEMBER_TO_FPTR(Perl_pp_method),
	MEMBER_TO_FPTR(Perl_pp_entersub),
	MEMBER_TO_FPTR(Perl_pp_leavesub),
	MEMBER_TO_FPTR(Perl_pp_leavesublv),
	MEMBER_TO_FPTR(Perl_pp_caller),
	MEMBER_TO_FPTR(Perl_pp_warn),
	MEMBER_TO_FPTR(Perl_pp_die),
	MEMBER_TO_FPTR(Perl_pp_reset),
	MEMBER_TO_FPTR(Perl_pp_null),	/* Perl_pp_lineseq */
	MEMBER_TO_FPTR(Perl_pp_nextstate),
	MEMBER_TO_FPTR(Perl_pp_dbstate),
	MEMBER_TO_FPTR(Perl_pp_unstack),
	MEMBER_TO_FPTR(Perl_pp_enter),
	MEMBER_TO_FPTR(Perl_pp_leave),
	MEMBER_TO_FPTR(Perl_pp_null),	/* Perl_pp_scope */
	MEMBER_TO_FPTR(Perl_pp_enteriter),
	MEMBER_TO_FPTR(Perl_pp_iter),
	MEMBER_TO_FPTR(Perl_pp_enterloop),
	MEMBER_TO_FPTR(Perl_pp_leaveloop),
	MEMBER_TO_FPTR(Perl_pp_return),
	MEMBER_TO_FPTR(Perl_pp_last),
	MEMBER_TO_FPTR(Perl_pp_next),
	MEMBER_TO_FPTR(Perl_pp_redo),
	MEMBER_TO_FPTR(Perl_pp_goto),	/* Perl_pp_dump */
	MEMBER_TO_FPTR(Perl_pp_goto),
	MEMBER_TO_FPTR(Perl_pp_exit),
	MEMBER_TO_FPTR(Perl_pp_setstate),
	MEMBER_TO_FPTR(Perl_pp_method_named),
	MEMBER_TO_FPTR(Perl_pp_entergiven),
	MEMBER_TO_FPTR(Perl_pp_leavegiven),
	MEMBER_TO_FPTR(Perl_pp_enterwhen),
	MEMBER_TO_FPTR(Perl_pp_leavewhen),
	MEMBER_TO_FPTR(Perl_pp_break),
	MEMBER_TO_FPTR(Perl_pp_continue),
	MEMBER_TO_FPTR(Perl_pp_open),
	MEMBER_TO_FPTR(Perl_pp_close),
	MEMBER_TO_FPTR(Perl_pp_pipe_op),
	MEMBER_TO_FPTR(Perl_pp_fileno),
	MEMBER_TO_FPTR(Perl_pp_umask),
	MEMBER_TO_FPTR(Perl_pp_binmode),
	MEMBER_TO_FPTR(Perl_pp_tie),
	MEMBER_TO_FPTR(Perl_pp_untie),
	MEMBER_TO_FPTR(Perl_pp_tied),
	MEMBER_TO_FPTR(Perl_pp_dbmopen),
	MEMBER_TO_FPTR(Perl_pp_untie),	/* Perl_pp_dbmclose */
	MEMBER_TO_FPTR(Perl_pp_sselect),
	MEMBER_TO_FPTR(Perl_pp_select),
	MEMBER_TO_FPTR(Perl_pp_getc),
	MEMBER_TO_FPTR(Perl_pp_sysread),	/* Perl_pp_read */
	MEMBER_TO_FPTR(Perl_pp_enterwrite),
	MEMBER_TO_FPTR(Perl_pp_leavewrite),
	MEMBER_TO_FPTR(Perl_pp_prtf),
	MEMBER_TO_FPTR(Perl_pp_print),
	MEMBER_TO_FPTR(Perl_pp_print),	/* Perl_pp_say */
	MEMBER_TO_FPTR(Perl_pp_sysopen),
	MEMBER_TO_FPTR(Perl_pp_sysseek),
	MEMBER_TO_FPTR(Perl_pp_sysread),
	MEMBER_TO_FPTR(Perl_pp_send),	/* Perl_pp_syswrite */
	MEMBER_TO_FPTR(Perl_pp_send),
	MEMBER_TO_FPTR(Perl_pp_sysread),	/* Perl_pp_recv */
	MEMBER_TO_FPTR(Perl_pp_eof),
	MEMBER_TO_FPTR(Perl_pp_tell),
	MEMBER_TO_FPTR(Perl_pp_sysseek),	/* Perl_pp_seek */
	MEMBER_TO_FPTR(Perl_pp_truncate),
	MEMBER_TO_FPTR(Perl_pp_ioctl),	/* Perl_pp_fcntl */
	MEMBER_TO_FPTR(Perl_pp_ioctl),
	MEMBER_TO_FPTR(Perl_pp_flock),
	MEMBER_TO_FPTR(Perl_pp_socket),
	MEMBER_TO_FPTR(Perl_pp_sockpair),
	MEMBER_TO_FPTR(Perl_pp_bind),
	MEMBER_TO_FPTR(Perl_pp_connect),
	MEMBER_TO_FPTR(Perl_pp_listen),
	MEMBER_TO_FPTR(Perl_pp_accept),
	MEMBER_TO_FPTR(Perl_pp_shutdown),
	MEMBER_TO_FPTR(Perl_pp_ssockopt),	/* Perl_pp_gsockopt */
	MEMBER_TO_FPTR(Perl_pp_ssockopt),
	MEMBER_TO_FPTR(Perl_pp_getpeername),	/* Perl_pp_getsockname */
	MEMBER_TO_FPTR(Perl_pp_getpeername),
	MEMBER_TO_FPTR(Perl_pp_stat),	/* Perl_pp_lstat */
	MEMBER_TO_FPTR(Perl_pp_stat),
	MEMBER_TO_FPTR(Perl_pp_ftrread),
	MEMBER_TO_FPTR(Perl_pp_ftrread),	/* Perl_pp_ftrwrite */
	MEMBER_TO_FPTR(Perl_pp_ftrread),	/* Perl_pp_ftrexec */
	MEMBER_TO_FPTR(Perl_pp_ftrread),	/* Perl_pp_fteread */
	MEMBER_TO_FPTR(Perl_pp_ftrread),	/* Perl_pp_ftewrite */
	MEMBER_TO_FPTR(Perl_pp_ftrread),	/* Perl_pp_fteexec */
	MEMBER_TO_FPTR(Perl_pp_ftis),
	MEMBER_TO_FPTR(Perl_pp_ftis),	/* Perl_pp_ftsize */
	MEMBER_TO_FPTR(Perl_pp_ftis),	/* Perl_pp_ftmtime */
	MEMBER_TO_FPTR(Perl_pp_ftis),	/* Perl_pp_ftatime */
	MEMBER_TO_FPTR(Perl_pp_ftis),	/* Perl_pp_ftctime */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_fteowned */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftzero */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftsock */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftchr */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftblk */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftfile */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftdir */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftpipe */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftsuid */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftsgid */
	MEMBER_TO_FPTR(Perl_pp_ftrowned),	/* Perl_pp_ftsvtx */
	MEMBER_TO_FPTR(Perl_pp_ftlink),
	MEMBER_TO_FPTR(Perl_pp_fttty),
	MEMBER_TO_FPTR(Perl_pp_fttext),
	MEMBER_TO_FPTR(Perl_pp_fttext),	/* Perl_pp_ftbinary */
	MEMBER_TO_FPTR(Perl_pp_chdir),
	MEMBER_TO_FPTR(Perl_pp_chown),
	MEMBER_TO_FPTR(Perl_pp_chroot),
	MEMBER_TO_FPTR(Perl_pp_chown),	/* Perl_pp_unlink */
	MEMBER_TO_FPTR(Perl_pp_chown),	/* Perl_pp_chmod */
	MEMBER_TO_FPTR(Perl_pp_chown),	/* Perl_pp_utime */
	MEMBER_TO_FPTR(Perl_pp_rename),
	MEMBER_TO_FPTR(Perl_pp_link),
	MEMBER_TO_FPTR(Perl_pp_link),	/* Perl_pp_symlink */
	MEMBER_TO_FPTR(Perl_pp_readlink),
	MEMBER_TO_FPTR(Perl_pp_mkdir),
	MEMBER_TO_FPTR(Perl_pp_rmdir),
	MEMBER_TO_FPTR(Perl_pp_open_dir),
	MEMBER_TO_FPTR(Perl_pp_readdir),
	MEMBER_TO_FPTR(Perl_pp_telldir),
	MEMBER_TO_FPTR(Perl_pp_seekdir),
	MEMBER_TO_FPTR(Perl_pp_rewinddir),
	MEMBER_TO_FPTR(Perl_pp_closedir),
	MEMBER_TO_FPTR(Perl_pp_fork),
	MEMBER_TO_FPTR(Perl_pp_wait),
	MEMBER_TO_FPTR(Perl_pp_waitpid),
	MEMBER_TO_FPTR(Perl_pp_system),
	MEMBER_TO_FPTR(Perl_pp_exec),
	MEMBER_TO_FPTR(Perl_pp_chown),	/* Perl_pp_kill */
	MEMBER_TO_FPTR(Perl_pp_getppid),
	MEMBER_TO_FPTR(Perl_pp_getpgrp),
	MEMBER_TO_FPTR(Perl_pp_setpgrp),
	MEMBER_TO_FPTR(Perl_pp_getpriority),
	MEMBER_TO_FPTR(Perl_pp_setpriority),
	MEMBER_TO_FPTR(Perl_pp_time),
	MEMBER_TO_FPTR(Perl_pp_tms),
	MEMBER_TO_FPTR(Perl_pp_gmtime),	/* Perl_pp_localtime */
	MEMBER_TO_FPTR(Perl_pp_gmtime),
	MEMBER_TO_FPTR(Perl_pp_alarm),
	MEMBER_TO_FPTR(Perl_pp_sleep),
	MEMBER_TO_FPTR(Perl_pp_semget),	/* Perl_pp_shmget */
	MEMBER_TO_FPTR(Perl_pp_semctl),	/* Perl_pp_shmctl */
	MEMBER_TO_FPTR(Perl_pp_shmwrite),	/* Perl_pp_shmread */
	MEMBER_TO_FPTR(Perl_pp_shmwrite),
	MEMBER_TO_FPTR(Perl_pp_semget),	/* Perl_pp_msgget */
	MEMBER_TO_FPTR(Perl_pp_semctl),	/* Perl_pp_msgctl */
	MEMBER_TO_FPTR(Perl_pp_shmwrite),	/* Perl_pp_msgsnd */
	MEMBER_TO_FPTR(Perl_pp_shmwrite),	/* Perl_pp_msgrcv */
	MEMBER_TO_FPTR(Perl_pp_shmwrite),	/* Perl_pp_semop */
	MEMBER_TO_FPTR(Perl_pp_semget),
	MEMBER_TO_FPTR(Perl_pp_semctl),
	MEMBER_TO_FPTR(Perl_pp_require),
	MEMBER_TO_FPTR(Perl_pp_require),	/* Perl_pp_dofile */
	MEMBER_TO_FPTR(Perl_pp_entereval),
	MEMBER_TO_FPTR(Perl_pp_leaveeval),
	MEMBER_TO_FPTR(Perl_pp_entertry),
	MEMBER_TO_FPTR(Perl_pp_leavetry),
	MEMBER_TO_FPTR(Perl_pp_ghostent),	/* Perl_pp_ghbyname */
	MEMBER_TO_FPTR(Perl_pp_ghostent),	/* Perl_pp_ghbyaddr */
	MEMBER_TO_FPTR(Perl_pp_ghostent),
	MEMBER_TO_FPTR(Perl_pp_gnetent),	/* Perl_pp_gnbyname */
	MEMBER_TO_FPTR(Perl_pp_gnetent),	/* Perl_pp_gnbyaddr */
	MEMBER_TO_FPTR(Perl_pp_gnetent),
	MEMBER_TO_FPTR(Perl_pp_gprotoent),	/* Perl_pp_gpbyname */
	MEMBER_TO_FPTR(Perl_pp_gprotoent),	/* Perl_pp_gpbynumber */
	MEMBER_TO_FPTR(Perl_pp_gprotoent),
	MEMBER_TO_FPTR(Perl_pp_gservent),	/* Perl_pp_gsbyname */
	MEMBER_TO_FPTR(Perl_pp_gservent),	/* Perl_pp_gsbyport */
	MEMBER_TO_FPTR(Perl_pp_gservent),
	MEMBER_TO_FPTR(Perl_pp_shostent),
	MEMBER_TO_FPTR(Perl_pp_snetent),
	MEMBER_TO_FPTR(Perl_pp_sprotoent),
	MEMBER_TO_FPTR(Perl_pp_sservent),
	MEMBER_TO_FPTR(Perl_pp_ehostent),
	MEMBER_TO_FPTR(Perl_pp_enetent),
	MEMBER_TO_FPTR(Perl_pp_eprotoent),
	MEMBER_TO_FPTR(Perl_pp_eservent),
	MEMBER_TO_FPTR(Perl_pp_gpwent),	/* Perl_pp_gpwnam */
	MEMBER_TO_FPTR(Perl_pp_gpwent),	/* Perl_pp_gpwuid */
	MEMBER_TO_FPTR(Perl_pp_gpwent),
	MEMBER_TO_FPTR(Perl_pp_spwent),
	MEMBER_TO_FPTR(Perl_pp_epwent),
	MEMBER_TO_FPTR(Perl_pp_ggrent),	/* Perl_pp_ggrnam */
	MEMBER_TO_FPTR(Perl_pp_ggrent),	/* Perl_pp_ggrgid */
	MEMBER_TO_FPTR(Perl_pp_ggrent),
	MEMBER_TO_FPTR(Perl_pp_sgrent),
	MEMBER_TO_FPTR(Perl_pp_egrent),
	MEMBER_TO_FPTR(Perl_pp_getlogin),
	MEMBER_TO_FPTR(Perl_pp_syscall),
	MEMBER_TO_FPTR(Perl_pp_lock),
	MEMBER_TO_FPTR(Perl_pp_once),
	MEMBER_TO_FPTR(Perl_unimplemented_op),	/* Perl_pp_custom */
}
#endif
#ifdef PERL_PPADDR_INITED
;
#endif

#ifdef PERL_GLOBAL_STRUCT_INIT
#  define PERL_CHECK_INITED
static const Perl_check_t Gcheck[]
#else
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_CHECK_INITED
EXT Perl_check_t PL_check[] /* or perlvars.h */
#  endif
#endif
#if (defined(DOINIT) && !defined(PERL_GLOBAL_STRUCT)) || defined(PERL_GLOBAL_STRUCT_INIT)
#  define PERL_CHECK_INITED
= {
	MEMBER_TO_FPTR(Perl_ck_null),	/* null */
	MEMBER_TO_FPTR(Perl_ck_null),	/* stub */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* scalar */
	MEMBER_TO_FPTR(Perl_ck_null),	/* pushmark */
	MEMBER_TO_FPTR(Perl_ck_null),	/* wantarray */
	MEMBER_TO_FPTR(Perl_ck_svconst),	/* const */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gvsv */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gv */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gelem */
	MEMBER_TO_FPTR(Perl_ck_null),	/* padsv */
	MEMBER_TO_FPTR(Perl_ck_null),	/* padav */
	MEMBER_TO_FPTR(Perl_ck_null),	/* padhv */
	MEMBER_TO_FPTR(Perl_ck_null),	/* padany */
	MEMBER_TO_FPTR(Perl_ck_null),	/* pushre */
	MEMBER_TO_FPTR(Perl_ck_rvconst),	/* rv2gv */
	MEMBER_TO_FPTR(Perl_ck_rvconst),	/* rv2sv */
	MEMBER_TO_FPTR(Perl_ck_null),	/* av2arylen */
	MEMBER_TO_FPTR(Perl_ck_rvconst),	/* rv2cv */
	MEMBER_TO_FPTR(Perl_ck_anoncode),	/* anoncode */
	MEMBER_TO_FPTR(Perl_ck_null),	/* prototype */
	MEMBER_TO_FPTR(Perl_ck_spair),	/* refgen */
	MEMBER_TO_FPTR(Perl_ck_null),	/* srefgen */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ref */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* bless */
	MEMBER_TO_FPTR(Perl_ck_open),	/* backtick */
	MEMBER_TO_FPTR(Perl_ck_glob),	/* glob */
	MEMBER_TO_FPTR(Perl_ck_readline),	/* readline */
	MEMBER_TO_FPTR(Perl_ck_null),	/* rcatline */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* regcmaybe */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* regcreset */
	MEMBER_TO_FPTR(Perl_ck_null),	/* regcomp */
	MEMBER_TO_FPTR(Perl_ck_match),	/* match */
	MEMBER_TO_FPTR(Perl_ck_match),	/* qr */
	MEMBER_TO_FPTR(Perl_ck_match),	/* subst */
	MEMBER_TO_FPTR(Perl_ck_null),	/* substcont */
	MEMBER_TO_FPTR(Perl_ck_match),	/* trans */
	MEMBER_TO_FPTR(Perl_ck_sassign),	/* sassign */
	MEMBER_TO_FPTR(Perl_ck_null),	/* aassign */
	MEMBER_TO_FPTR(Perl_ck_spair),	/* chop */
	MEMBER_TO_FPTR(Perl_ck_null),	/* schop */
	MEMBER_TO_FPTR(Perl_ck_spair),	/* chomp */
	MEMBER_TO_FPTR(Perl_ck_null),	/* schomp */
	MEMBER_TO_FPTR(Perl_ck_defined),	/* defined */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* undef */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* study */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* pos */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* preinc */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* i_preinc */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* predec */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* i_predec */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* postinc */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* i_postinc */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* postdec */
	MEMBER_TO_FPTR(Perl_ck_lfun),	/* i_postdec */
	MEMBER_TO_FPTR(Perl_ck_null),	/* pow */
	MEMBER_TO_FPTR(Perl_ck_null),	/* multiply */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_multiply */
	MEMBER_TO_FPTR(Perl_ck_null),	/* divide */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_divide */
	MEMBER_TO_FPTR(Perl_ck_null),	/* modulo */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_modulo */
	MEMBER_TO_FPTR(Perl_ck_repeat),	/* repeat */
	MEMBER_TO_FPTR(Perl_ck_null),	/* add */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_add */
	MEMBER_TO_FPTR(Perl_ck_null),	/* subtract */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_subtract */
	MEMBER_TO_FPTR(Perl_ck_concat),	/* concat */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* stringify */
	MEMBER_TO_FPTR(Perl_ck_bitop),	/* left_shift */
	MEMBER_TO_FPTR(Perl_ck_bitop),	/* right_shift */
	MEMBER_TO_FPTR(Perl_ck_null),	/* lt */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_lt */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gt */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_gt */
	MEMBER_TO_FPTR(Perl_ck_null),	/* le */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_le */
	MEMBER_TO_FPTR(Perl_ck_null),	/* ge */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_ge */
	MEMBER_TO_FPTR(Perl_ck_null),	/* eq */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_eq */
	MEMBER_TO_FPTR(Perl_ck_null),	/* ne */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_ne */
	MEMBER_TO_FPTR(Perl_ck_null),	/* ncmp */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_ncmp */
	MEMBER_TO_FPTR(Perl_ck_null),	/* slt */
	MEMBER_TO_FPTR(Perl_ck_null),	/* sgt */
	MEMBER_TO_FPTR(Perl_ck_null),	/* sle */
	MEMBER_TO_FPTR(Perl_ck_null),	/* sge */
	MEMBER_TO_FPTR(Perl_ck_null),	/* seq */
	MEMBER_TO_FPTR(Perl_ck_null),	/* sne */
	MEMBER_TO_FPTR(Perl_ck_null),	/* scmp */
	MEMBER_TO_FPTR(Perl_ck_bitop),	/* bit_and */
	MEMBER_TO_FPTR(Perl_ck_bitop),	/* bit_xor */
	MEMBER_TO_FPTR(Perl_ck_bitop),	/* bit_or */
	MEMBER_TO_FPTR(Perl_ck_null),	/* negate */
	MEMBER_TO_FPTR(Perl_ck_null),	/* i_negate */
	MEMBER_TO_FPTR(Perl_ck_null),	/* not */
	MEMBER_TO_FPTR(Perl_ck_bitop),	/* complement */
	MEMBER_TO_FPTR(Perl_ck_smartmatch),	/* smartmatch */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* atan2 */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sin */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* cos */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* rand */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* srand */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* exp */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* log */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sqrt */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* int */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* hex */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* oct */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* abs */
	MEMBER_TO_FPTR(Perl_ck_lengthconst),	/* length */
	MEMBER_TO_FPTR(Perl_ck_substr),	/* substr */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* vec */
	MEMBER_TO_FPTR(Perl_ck_index),	/* index */
	MEMBER_TO_FPTR(Perl_ck_index),	/* rindex */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sprintf */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* formline */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ord */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* chr */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* crypt */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ucfirst */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* lcfirst */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* uc */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* lc */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* quotemeta */
	MEMBER_TO_FPTR(Perl_ck_rvconst),	/* rv2av */
	MEMBER_TO_FPTR(Perl_ck_null),	/* aelemfast */
	MEMBER_TO_FPTR(Perl_ck_null),	/* aelem */
	MEMBER_TO_FPTR(Perl_ck_null),	/* aslice */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* each */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* values */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* keys */
	MEMBER_TO_FPTR(Perl_ck_delete),	/* delete */
	MEMBER_TO_FPTR(Perl_ck_exists),	/* exists */
	MEMBER_TO_FPTR(Perl_ck_rvconst),	/* rv2hv */
	MEMBER_TO_FPTR(Perl_ck_null),	/* helem */
	MEMBER_TO_FPTR(Perl_ck_null),	/* hslice */
	MEMBER_TO_FPTR(Perl_ck_unpack),	/* unpack */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* pack */
	MEMBER_TO_FPTR(Perl_ck_split),	/* split */
	MEMBER_TO_FPTR(Perl_ck_join),	/* join */
	MEMBER_TO_FPTR(Perl_ck_null),	/* list */
	MEMBER_TO_FPTR(Perl_ck_null),	/* lslice */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* anonlist */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* anonhash */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* splice */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* push */
	MEMBER_TO_FPTR(Perl_ck_shift),	/* pop */
	MEMBER_TO_FPTR(Perl_ck_shift),	/* shift */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* unshift */
	MEMBER_TO_FPTR(Perl_ck_sort),	/* sort */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* reverse */
	MEMBER_TO_FPTR(Perl_ck_grep),	/* grepstart */
	MEMBER_TO_FPTR(Perl_ck_null),	/* grepwhile */
	MEMBER_TO_FPTR(Perl_ck_grep),	/* mapstart */
	MEMBER_TO_FPTR(Perl_ck_null),	/* mapwhile */
	MEMBER_TO_FPTR(Perl_ck_null),	/* range */
	MEMBER_TO_FPTR(Perl_ck_null),	/* flip */
	MEMBER_TO_FPTR(Perl_ck_null),	/* flop */
	MEMBER_TO_FPTR(Perl_ck_null),	/* and */
	MEMBER_TO_FPTR(Perl_ck_null),	/* or */
	MEMBER_TO_FPTR(Perl_ck_null),	/* xor */
	MEMBER_TO_FPTR(Perl_ck_null),	/* dor */
	MEMBER_TO_FPTR(Perl_ck_null),	/* cond_expr */
	MEMBER_TO_FPTR(Perl_ck_null),	/* andassign */
	MEMBER_TO_FPTR(Perl_ck_null),	/* orassign */
	MEMBER_TO_FPTR(Perl_ck_null),	/* dorassign */
	MEMBER_TO_FPTR(Perl_ck_method),	/* method */
	MEMBER_TO_FPTR(Perl_ck_subr),	/* entersub */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leavesub */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leavesublv */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* caller */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* warn */
	MEMBER_TO_FPTR(Perl_ck_die),	/* die */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* reset */
	MEMBER_TO_FPTR(Perl_ck_null),	/* lineseq */
	MEMBER_TO_FPTR(Perl_ck_null),	/* nextstate */
	MEMBER_TO_FPTR(Perl_ck_null),	/* dbstate */
	MEMBER_TO_FPTR(Perl_ck_null),	/* unstack */
	MEMBER_TO_FPTR(Perl_ck_null),	/* enter */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leave */
	MEMBER_TO_FPTR(Perl_ck_null),	/* scope */
	MEMBER_TO_FPTR(Perl_ck_null),	/* enteriter */
	MEMBER_TO_FPTR(Perl_ck_null),	/* iter */
	MEMBER_TO_FPTR(Perl_ck_null),	/* enterloop */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leaveloop */
	MEMBER_TO_FPTR(Perl_ck_return),	/* return */
	MEMBER_TO_FPTR(Perl_ck_null),	/* last */
	MEMBER_TO_FPTR(Perl_ck_null),	/* next */
	MEMBER_TO_FPTR(Perl_ck_null),	/* redo */
	MEMBER_TO_FPTR(Perl_ck_null),	/* dump */
	MEMBER_TO_FPTR(Perl_ck_null),	/* goto */
	MEMBER_TO_FPTR(Perl_ck_exit),	/* exit */
	MEMBER_TO_FPTR(Perl_ck_null),	/* setstate */
	MEMBER_TO_FPTR(Perl_ck_null),	/* method_named */
	MEMBER_TO_FPTR(Perl_ck_null),	/* entergiven */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leavegiven */
	MEMBER_TO_FPTR(Perl_ck_null),	/* enterwhen */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leavewhen */
	MEMBER_TO_FPTR(Perl_ck_null),	/* break */
	MEMBER_TO_FPTR(Perl_ck_null),	/* continue */
	MEMBER_TO_FPTR(Perl_ck_open),	/* open */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* close */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* pipe_op */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* fileno */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* umask */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* binmode */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* tie */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* untie */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* tied */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* dbmopen */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* dbmclose */
	MEMBER_TO_FPTR(Perl_ck_select),	/* sselect */
	MEMBER_TO_FPTR(Perl_ck_select),	/* select */
	MEMBER_TO_FPTR(Perl_ck_eof),	/* getc */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* read */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* enterwrite */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leavewrite */
	MEMBER_TO_FPTR(Perl_ck_listiob),	/* prtf */
	MEMBER_TO_FPTR(Perl_ck_listiob),	/* print */
	MEMBER_TO_FPTR(Perl_ck_listiob),	/* say */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sysopen */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sysseek */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sysread */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* syswrite */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* send */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* recv */
	MEMBER_TO_FPTR(Perl_ck_eof),	/* eof */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* tell */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* seek */
	MEMBER_TO_FPTR(Perl_ck_trunc),	/* truncate */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* fcntl */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ioctl */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* flock */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* socket */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sockpair */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* bind */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* connect */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* listen */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* accept */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* shutdown */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gsockopt */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ssockopt */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* getsockname */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* getpeername */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* lstat */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* stat */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftrread */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftrwrite */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftrexec */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* fteread */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftewrite */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* fteexec */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftis */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftsize */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftmtime */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftatime */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftctime */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftrowned */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* fteowned */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftzero */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftsock */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftchr */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftblk */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftfile */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftdir */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftpipe */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftsuid */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftsgid */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftsvtx */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftlink */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* fttty */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* fttext */
	MEMBER_TO_FPTR(Perl_ck_ftst),	/* ftbinary */
	MEMBER_TO_FPTR(Perl_ck_chdir),	/* chdir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* chown */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* chroot */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* unlink */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* chmod */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* utime */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* rename */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* link */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* symlink */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* readlink */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* mkdir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* rmdir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* open_dir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* readdir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* telldir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* seekdir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* rewinddir */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* closedir */
	MEMBER_TO_FPTR(Perl_ck_null),	/* fork */
	MEMBER_TO_FPTR(Perl_ck_null),	/* wait */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* waitpid */
	MEMBER_TO_FPTR(Perl_ck_exec),	/* system */
	MEMBER_TO_FPTR(Perl_ck_exec),	/* exec */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* kill */
	MEMBER_TO_FPTR(Perl_ck_null),	/* getppid */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* getpgrp */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* setpgrp */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* getpriority */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* setpriority */
	MEMBER_TO_FPTR(Perl_ck_null),	/* time */
	MEMBER_TO_FPTR(Perl_ck_null),	/* tms */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* localtime */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gmtime */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* alarm */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sleep */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* shmget */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* shmctl */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* shmread */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* shmwrite */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* msgget */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* msgctl */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* msgsnd */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* msgrcv */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* semop */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* semget */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* semctl */
	MEMBER_TO_FPTR(Perl_ck_require),	/* require */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* dofile */
	MEMBER_TO_FPTR(Perl_ck_eval),	/* entereval */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leaveeval */
	MEMBER_TO_FPTR(Perl_ck_null),	/* entertry */
	MEMBER_TO_FPTR(Perl_ck_null),	/* leavetry */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ghbyname */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ghbyaddr */
	MEMBER_TO_FPTR(Perl_ck_null),	/* ghostent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gnbyname */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gnbyaddr */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gnetent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gpbyname */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gpbynumber */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gprotoent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gsbyname */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gsbyport */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gservent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* shostent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* snetent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sprotoent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* sservent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* ehostent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* enetent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* eprotoent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* eservent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gpwnam */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* gpwuid */
	MEMBER_TO_FPTR(Perl_ck_null),	/* gpwent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* spwent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* epwent */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ggrnam */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* ggrgid */
	MEMBER_TO_FPTR(Perl_ck_null),	/* ggrent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* sgrent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* egrent */
	MEMBER_TO_FPTR(Perl_ck_null),	/* getlogin */
	MEMBER_TO_FPTR(Perl_ck_fun),	/* syscall */
	MEMBER_TO_FPTR(Perl_ck_rfun),	/* lock */
	MEMBER_TO_FPTR(Perl_ck_null),	/* once */
	MEMBER_TO_FPTR(Perl_ck_null),	/* custom */
}
#endif
#ifdef PERL_CHECK_INITED
;
#endif /* #ifdef PERL_CHECK_INITED */

#ifndef PERL_GLOBAL_STRUCT_INIT

#ifndef DOINIT
EXTCONST U32 PL_opargs[];
#else
EXTCONST U32 PL_opargs[] = {
	0x00000000,	/* null */
	0x00000000,	/* stub */
	0x00003604,	/* scalar */
	0x00000004,	/* pushmark */
	0x00000014,	/* wantarray */
	0x00000c04,	/* const */
	0x00000c44,	/* gvsv */
	0x00000c44,	/* gv */
	0x00022440,	/* gelem */
	0x00000044,	/* padsv */
	0x00000040,	/* padav */
	0x00000040,	/* padhv */
	0x00000040,	/* padany */
	0x00000a40,	/* pushre */
	0x00000244,	/* rv2gv */
	0x00000244,	/* rv2sv */
	0x00000214,	/* av2arylen */
	0x00000240,	/* rv2cv */
	0x00000c00,	/* anoncode */
	0x00003604,	/* prototype */
	0x00004201,	/* refgen */
	0x00002206,	/* srefgen */
	0x0001368c,	/* ref */
	0x00122804,	/* bless */
	0x00013688,	/* backtick */
	0x00012808,	/* glob */
	0x0001d608,	/* readline */
	0x00000c08,	/* rcatline */
	0x00002204,	/* regcmaybe */
	0x00002204,	/* regcreset */
	0x00002604,	/* regcomp */
	0x00000a40,	/* match */
	0x00000a04,	/* qr */
	0x00002a54,	/* subst */
	0x00000654,	/* substcont */
	0x00003014,	/* trans */
	0x00000004,	/* sassign */
	0x00044408,	/* aassign */
	0x0000560d,	/* chop */
	0x0001368c,	/* schop */
	0x0000570d,	/* chomp */
	0x0001378c,	/* schomp */
	0x00013694,	/* defined */
	0x00013604,	/* undef */
	0x00013684,	/* study */
	0x0001368c,	/* pos */
	0x00002264,	/* preinc */
	0x00002254,	/* i_preinc */
	0x00002264,	/* predec */
	0x00002254,	/* i_predec */
	0x0000226c,	/* postinc */
	0x0000235c,	/* i_postinc */
	0x0000226c,	/* postdec */
	0x0000235c,	/* i_postdec */
	0x0002250e,	/* pow */
	0x0002252e,	/* multiply */
	0x0002251e,	/* i_multiply */
	0x0002252e,	/* divide */
	0x0002251e,	/* i_divide */
	0x0002253e,	/* modulo */
	0x0002251e,	/* i_modulo */
	0x00024409,	/* repeat */
	0x0002252e,	/* add */
	0x0002251e,	/* i_add */
	0x0002252e,	/* subtract */
	0x0002251e,	/* i_subtract */
	0x0002250e,	/* concat */
	0x0000290e,	/* stringify */
	0x0002250e,	/* left_shift */
	0x0002250e,	/* right_shift */
	0x00022436,	/* lt */
	0x00022416,	/* i_lt */
	0x00022436,	/* gt */
	0x00022416,	/* i_gt */
	0x00022436,	/* le */
	0x00022416,	/* i_le */
	0x00022436,	/* ge */
	0x00022416,	/* i_ge */
	0x00022436,	/* eq */
	0x00022416,	/* i_eq */
	0x00022436,	/* ne */
	0x00022416,	/* i_ne */
	0x0002243e,	/* ncmp */
	0x0002241e,	/* i_ncmp */
	0x00022416,	/* slt */
	0x00022416,	/* sgt */
	0x00022416,	/* sle */
	0x00022416,	/* sge */
	0x00022416,	/* seq */
	0x00022416,	/* sne */
	0x0002241e,	/* scmp */
	0x0002240e,	/* bit_and */
	0x0002240e,	/* bit_xor */
	0x0002240e,	/* bit_or */
	0x0000222e,	/* negate */
	0x0000231e,	/* i_negate */
	0x00002216,	/* not */
	0x0000220e,	/* complement */
	0x00000404,	/* smartmatch */
	0x0002290e,	/* atan2 */
	0x0001378e,	/* sin */
	0x0001378e,	/* cos */
	0x0001370c,	/* rand */
	0x00013604,	/* srand */
	0x0001378e,	/* exp */
	0x0001378e,	/* log */
	0x0001378e,	/* sqrt */
	0x0001378e,	/* int */
	0x0001378e,	/* hex */
	0x0001378e,	/* oct */
	0x0001378e,	/* abs */
	0x0001379c,	/* length */
	0x1322280c,	/* substr */
	0x0022281c,	/* vec */
	0x0122291c,	/* index */
	0x0122291c,	/* rindex */
	0x0004280d,	/* sprintf */
	0x00042805,	/* formline */
	0x0001379e,	/* ord */
	0x0001378e,	/* chr */
	0x0002290e,	/* crypt */
	0x0001368e,	/* ucfirst */
	0x0001368e,	/* lcfirst */
	0x0001368e,	/* uc */
	0x0001368e,	/* lc */
	0x0001368e,	/* quotemeta */
	0x00000248,	/* rv2av */
	0x00026c04,	/* aelemfast */
	0x00026404,	/* aelem */
	0x00046801,	/* aslice */
	0x00009600,	/* each */
	0x00009608,	/* values */
	0x00009608,	/* keys */
	0x00003600,	/* delete */
	0x00003614,	/* exists */
	0x00000248,	/* rv2hv */
	0x00028404,	/* helem */
	0x00048801,	/* hslice */
	0x00122800,	/* unpack */
	0x0004280d,	/* pack */
	0x00222808,	/* split */
	0x0004280d,	/* join */
	0x00004801,	/* list */
	0x00448400,	/* lslice */
	0x00004805,	/* anonlist */
	0x00004805,	/* anonhash */
	0x05326801,	/* splice */
	0x0004691d,	/* push */
	0x00017604,	/* pop */
	0x00017604,	/* shift */
	0x0004691d,	/* unshift */
	0x0005a841,	/* sort */
	0x00004809,	/* reverse */
	0x0004a841,	/* grepstart */
	0x00000648,	/* grepwhile */
	0x0004a841,	/* mapstart */
	0x00000648,	/* mapwhile */
	0x00022600,	/* range */
	0x00022200,	/* flip */
	0x00000200,	/* flop */
	0x00000600,	/* and */
	0x00000600,	/* or */
	0x00022406,	/* xor */
	0x00000600,	/* dor */
	0x00000640,	/* cond_expr */
	0x00000604,	/* andassign */
	0x00000604,	/* orassign */
	0x00000604,	/* dorassign */
	0x00000240,	/* method */
	0x00004249,	/* entersub */
	0x00000200,	/* leavesub */
	0x00000200,	/* leavesublv */
	0x00013608,	/* caller */
	0x0000481d,	/* warn */
	0x0000485d,	/* die */
	0x00013614,	/* reset */
	0x00000800,	/* lineseq */
	0x00001404,	/* nextstate */
	0x00001404,	/* dbstate */
	0x00000004,	/* unstack */
	0x00000000,	/* enter */
	0x00000800,	/* leave */
	0x00000800,	/* scope */
	0x00001240,	/* enteriter */
	0x00000000,	/* iter */
	0x00001240,	/* enterloop */
	0x00000400,	/* leaveloop */
	0x00004841,	/* return */
	0x00001a44,	/* last */
	0x00001a44,	/* next */
	0x00001a44,	/* redo */
	0x00001a44,	/* dump */
	0x00001a44,	/* goto */
	0x00013644,	/* exit */
	0x00001404,	/* setstate */
	0x00000c40,	/* method_named */
	0x00000640,	/* entergiven */
	0x00000200,	/* leavegiven */
	0x00000640,	/* enterwhen */
	0x00000200,	/* leavewhen */
	0x00000000,	/* break */
	0x00000000,	/* continue */
	0x0052c81d,	/* open */
	0x0001d614,	/* close */
	0x000cc814,	/* pipe_op */
	0x0000d61c,	/* fileno */
	0x0001361c,	/* umask */
	0x0012c804,	/* binmode */
	0x0042e855,	/* tie */
	0x0000f614,	/* untie */
	0x0000f604,	/* tied */
	0x00228814,	/* dbmopen */
	0x00009614,	/* dbmclose */
	0x02222808,	/* sselect */
	0x0001c80c,	/* select */
	0x0001d60c,	/* getc */
	0x122ec81d,	/* read */
	0x0001d654,	/* enterwrite */
	0x00000200,	/* leavewrite */
	0x0005c815,	/* prtf */
	0x0005c815,	/* print */
	0x0005c815,	/* say */
	0x1222c804,	/* sysopen */
	0x0022c804,	/* sysseek */
	0x122ec81d,	/* sysread */
	0x1322c81d,	/* syswrite */
	0x1222c81d,	/* send */
	0x022ec81d,	/* recv */
	0x0001d614,	/* eof */
	0x0001d60c,	/* tell */
	0x0022c804,	/* seek */
	0x00022814,	/* truncate */
	0x0022c80c,	/* fcntl */
	0x0022c80c,	/* ioctl */
	0x0002c91c,	/* flock */
	0x0222c814,	/* socket */
	0x222cc814,	/* sockpair */
	0x0002c814,	/* bind */
	0x0002c814,	/* connect */
	0x0002c814,	/* listen */
	0x000cc81c,	/* accept */
	0x0002c81c,	/* shutdown */
	0x0022c814,	/* gsockopt */
	0x0222c814,	/* ssockopt */
	0x0000d614,	/* getsockname */
	0x0000d614,	/* getpeername */
	0x0000d880,	/* lstat */
	0x0000d880,	/* stat */
	0x0000d894,	/* ftrread */
	0x0000d894,	/* ftrwrite */
	0x0000d894,	/* ftrexec */
	0x0000d894,	/* fteread */
	0x0000d894,	/* ftewrite */
	0x0000d894,	/* fteexec */
	0x0000d894,	/* ftis */
	0x0000d89c,	/* ftsize */
	0x0000d88c,	/* ftmtime */
	0x0000d88c,	/* ftatime */
	0x0000d88c,	/* ftctime */
	0x0000d894,	/* ftrowned */
	0x0000d894,	/* fteowned */
	0x0000d894,	/* ftzero */
	0x0000d894,	/* ftsock */
	0x0000d894,	/* ftchr */
	0x0000d894,	/* ftblk */
	0x0000d894,	/* ftfile */
	0x0000d894,	/* ftdir */
	0x0000d894,	/* ftpipe */
	0x0000d894,	/* ftsuid */
	0x0000d894,	/* ftsgid */
	0x0000d894,	/* ftsvtx */
	0x0000d894,	/* ftlink */
	0x0000d814,	/* fttty */
	0x0000d894,	/* fttext */
	0x0000d894,	/* ftbinary */
	0x0001371c,	/* chdir */
	0x0000491d,	/* chown */
	0x0001379c,	/* chroot */
	0x0000499d,	/* unlink */
	0x0000491d,	/* chmod */
	0x0000491d,	/* utime */
	0x0002291c,	/* rename */
	0x0002291c,	/* link */
	0x0002291c,	/* symlink */
	0x0001368c,	/* readlink */
	0x0013299c,	/* mkdir */
	0x0001379c,	/* rmdir */
	0x0002c814,	/* open_dir */
	0x0000d600,	/* readdir */
	0x0000d60c,	/* telldir */
	0x0002c804,	/* seekdir */
	0x0000d604,	/* rewinddir */
	0x0000d614,	/* closedir */
	0x0000001c,	/* fork */
	0x0000011c,	/* wait */
	0x0002291c,	/* waitpid */
	0x0005291d,	/* system */
	0x0005295d,	/* exec */
	0x0000495d,	/* kill */
	0x0000011c,	/* getppid */
	0x0001371c,	/* getpgrp */
	0x0013291c,	/* setpgrp */
	0x0002291c,	/* getpriority */
	0x0022291c,	/* setpriority */
	0x0000011c,	/* time */
	0x00000000,	/* tms */
	0x00013608,	/* localtime */
	0x00013608,	/* gmtime */
	0x0001369c,	/* alarm */
	0x0001371c,	/* sleep */
	0x0022281d,	/* shmget */
	0x0022281d,	/* shmctl */
	0x0222281d,	/* shmread */
	0x0222281d,	/* shmwrite */
	0x0002281d,	/* msgget */
	0x0022281d,	/* msgctl */
	0x0022281d,	/* msgsnd */
	0x2222281d,	/* msgrcv */
	0x0002281d,	/* semop */
	0x0022281d,	/* semget */
	0x0222281d,	/* semctl */
	0x000136c0,	/* require */
	0x00002240,	/* dofile */
	0x00003640,	/* entereval */
	0x00002200,	/* leaveeval */
	0x00000600,	/* entertry */
	0x00000800,	/* leavetry */
	0x00003600,	/* ghbyname */
	0x00022800,	/* ghbyaddr */
	0x00000000,	/* ghostent */
	0x00003600,	/* gnbyname */
	0x00022800,	/* gnbyaddr */
	0x00000000,	/* gnetent */
	0x00003600,	/* gpbyname */
	0x00002800,	/* gpbynumber */
	0x00000000,	/* gprotoent */
	0x00022800,	/* gsbyname */
	0x00022800,	/* gsbyport */
	0x00000000,	/* gservent */
	0x00003614,	/* shostent */
	0x00003614,	/* snetent */
	0x00003614,	/* sprotoent */
	0x00003614,	/* sservent */
	0x00000014,	/* ehostent */
	0x00000014,	/* enetent */
	0x00000014,	/* eprotoent */
	0x00000014,	/* eservent */
	0x00003600,	/* gpwnam */
	0x00003600,	/* gpwuid */
	0x00000000,	/* gpwent */
	0x00000014,	/* spwent */
	0x00000014,	/* epwent */
	0x00003600,	/* ggrnam */
	0x00003600,	/* ggrgid */
	0x00000000,	/* ggrent */
	0x00000014,	/* sgrent */
	0x00000014,	/* egrent */
	0x0000000c,	/* getlogin */
	0x0004281d,	/* syscall */
	0x0000f604,	/* lock */
	0x00000600,	/* once */
	0x00000000,	/* custom */
};
#endif

#endif /* !PERL_GLOBAL_STRUCT_INIT */

END_EXTERN_C

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\mg.h ===
/*    mg.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2002, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef STRUCT_MGVTBL_DEFINITION
STRUCT_MGVTBL_DEFINITION;
#else
struct mgvtbl {
    int		(CPERLscope(*svt_get))	(pTHX_ SV *sv, MAGIC* mg);
    int		(CPERLscope(*svt_set))	(pTHX_ SV *sv, MAGIC* mg);
    U32		(CPERLscope(*svt_len))	(pTHX_ SV *sv, MAGIC* mg);
    int		(CPERLscope(*svt_clear))(pTHX_ SV *sv, MAGIC* mg);
    int		(CPERLscope(*svt_free))	(pTHX_ SV *sv, MAGIC* mg);
    int		(CPERLscope(*svt_copy))	(pTHX_ SV *sv, MAGIC* mg,
    					SV *nsv, const char *name, int namlen);
    int		(CPERLscope(*svt_dup))	(pTHX_ MAGIC *mg, CLONE_PARAMS *param);
    int		(CPERLscope(*svt_local))(pTHX_ SV *nsv, MAGIC *mg);
};
#endif

struct magic {
    MAGIC*	mg_moremagic;
    MGVTBL*	mg_virtual;	/* pointer to magic functions */
    U16		mg_private;
    char	mg_type;
    U8		mg_flags;
    I32		mg_len;
    SV*		mg_obj;
    char*	mg_ptr;
};

#define MGf_TAINTEDDIR 1        /* PERL_MAGIC_envelem only */
#define MGf_MINMATCH   1        /* PERL_MAGIC_regex_global only */
#define MGf_REFCOUNTED 2
#define MGf_GSKIP      4
#define MGf_COPY       8	/* has an svt_copy  MGVTBL entry */
#define MGf_DUP     0x10 	/* has an svt_dup   MGVTBL entry */
#define MGf_LOCAL   0x20	/* has an svt_local MGVTBL entry */

#define MgTAINTEDDIR(mg)	(mg->mg_flags & MGf_TAINTEDDIR)
#define MgTAINTEDDIR_on(mg)	(mg->mg_flags |= MGf_TAINTEDDIR)
#define MgTAINTEDDIR_off(mg)	(mg->mg_flags &= ~MGf_TAINTEDDIR)

#define MgPV(mg,lp)		((((int)(lp = (mg)->mg_len)) == HEf_SVKEY) ?   \
				 SvPV((SV*)((mg)->mg_ptr),lp) :		\
				 (mg)->mg_ptr)
#define MgPV_const(mg,lp)	((((int)(lp = (mg)->mg_len)) == HEf_SVKEY) ? \
				 SvPV_const((SV*)((mg)->mg_ptr),lp) :        \
				 (const char*)(mg)->mg_ptr)
#define MgPV_nolen_const(mg)	(((((int)(mg)->mg_len)) == HEf_SVKEY) ?   \
				 SvPV_nolen_const((SV*)((mg)->mg_ptr)) :  \
				 (const char*)(mg)->mg_ptr)

#define SvTIED_mg(sv,how) (SvRMAGICAL(sv) ? mg_find((sv),(how)) : NULL)
#define SvTIED_obj(sv,mg) \
    ((mg)->mg_obj ? (mg)->mg_obj : sv_2mortal(newRV(sv)))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\op.h ===
/*    op.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * The fields of BASEOP are:
 *	op_next		Pointer to next ppcode to execute after this one.
 *			(Top level pre-grafted op points to first op,
 *			but this is replaced when op is grafted in, when
 *			this op will point to the real next op, and the new
 *			parent takes over role of remembering starting op.)
 *	op_ppaddr	Pointer to current ppcode's function.
 *	op_type		The type of the operation.
 *	op_opt		Whether or not the op has been optimised by the
 *			peephole optimiser.
 *
 *			See the comments in S_clear_yystack() for more
 *			details on the following three flags:
 *
 *	op_latefree	tell op_free() to clear this op (and free any kids)
 *			but not yet deallocate the struct. This means that
 *			the op may be safely op_free()d multiple times
 *	op_latefreed	an op_latefree op has been op_free()d
 *	op_attached	this op (sub)tree has been attached to a CV
 *
 *	op_spare	three spare bits!
 *	op_flags	Flags common to all operations.  See OPf_* below.
 *	op_private	Flags peculiar to a particular operation (BUT,
 *			by default, set to the number of children until
 *			the operation is privatized by a check routine,
 *			which may or may not check number of children).
 */

#define OPCODE U16

#ifdef PERL_MAD
#  define MADPROP_IN_BASEOP	MADPROP*	op_madprop;
#else
#  define MADPROP_IN_BASEOP
#endif

#ifdef BASEOP_DEFINITION
#define BASEOP BASEOP_DEFINITION
#else
#define BASEOP				\
    OP*		op_next;		\
    OP*		op_sibling;		\
    OP*		(CPERLscope(*op_ppaddr))(pTHX);		\
    MADPROP_IN_BASEOP			\
    PADOFFSET	op_targ;		\
    unsigned	op_type:9;		\
    unsigned	op_opt:1;		\
    unsigned	op_latefree:1;		\
    unsigned	op_latefreed:1;		\
    unsigned	op_attached:1;		\
    unsigned	op_spare:3;		\
    U8		op_flags;		\
    U8		op_private;
#endif

#define OP_GIMME(op,dfl) \
	(((op)->op_flags & OPf_WANT) == OPf_WANT_VOID   ? G_VOID   : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_SCALAR ? G_SCALAR : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_LIST   ? G_ARRAY   : \
	 dfl)

/*
=head1 "Gimme" Values

=for apidoc Amn|U32|GIMME_V
The XSUB-writer's equivalent to Perl's C<wantarray>.  Returns C<G_VOID>,
C<G_SCALAR> or C<G_ARRAY> for void, scalar or list context,
respectively.

=for apidoc Amn|U32|GIMME
A backward-compatible version of C<GIMME_V> which can only return
C<G_SCALAR> or C<G_ARRAY>; in a void context, it returns C<G_SCALAR>.
Deprecated.  Use C<GIMME_V> instead.

=cut
*/

#define GIMME_V		OP_GIMME(PL_op, block_gimme())

/* Public flags */

#define OPf_WANT	3	/* Mask for "want" bits: */
#define  OPf_WANT_VOID	 1	/*   Want nothing */
#define  OPf_WANT_SCALAR 2	/*   Want single value */
#define  OPf_WANT_LIST	 3	/*   Want list of any length */
#define OPf_KIDS	4	/* There is a firstborn child. */
#define OPf_PARENS	8	/* This operator was parenthesized. */
				/*  (Or block needs explicit scope entry.) */
#define OPf_REF		16	/* Certified reference. */
				/*  (Return container, not containee). */
#define OPf_MOD		32	/* Will modify (lvalue). */
#define OPf_STACKED	64	/* Some arg is arriving on the stack. */
#define OPf_SPECIAL	128	/* Do something weird for this op: */
				/*  On local LVAL, don't init local value. */
				/*  On OP_CONST, value is the hints hash for
				    eval, so return a copy from pp_const() */
				/*  On OP_SORT, subroutine is inlined. */
				/*  On OP_NOT, inversion was implicit. */
				/*  On OP_LEAVE, don't restore curpm. */
				/*  On truncate, we truncate filehandle */
				/*  On control verbs, we saw no label */
				/*  On flipflop, we saw ... instead of .. */
				/*  On UNOPs, saw bare parens, e.g. eof(). */
				/*  On OP_ENTERSUB || OP_NULL, saw a "do". */
				/*  On OP_EXISTS, treat av as av, not avhv.  */
				/*  On OP_(ENTER|LEAVE)EVAL, don't clear $@ */
				/*  On OP_ENTERITER, loop var is per-thread */
				/*  On pushre, rx is used as part of split, e.g. split " " */
				/*  On regcomp, "use re 'eval'" was in scope */
				/*  On OP_READLINE, was <$filehandle> */
				/*  On RV2[ACGHS]V, don't create GV--in
				    defined()*/
				/*  On OP_DBSTATE, indicates breakpoint
				 *    (runtime property) */
				/*  On OP_AELEMFAST, indiciates pad var */
				/*  On OP_REQUIRE, was seen as CORE::require */
				/*  On OP_ENTERWHEN, there's no condition */
				/*  On OP_BREAK, an implicit break */
				/*  On OP_SMARTMATCH, an implicit smartmatch */
				/*  On OP_ANONHASH and OP_ANONLIST, create a
				    reference to the new anon hash or array */

/* old names; don't use in new code, but don't break them, either */
#define OPf_LIST	OPf_WANT_LIST
#define OPf_KNOW	OPf_WANT

#define GIMME \
	  (PL_op->op_flags & OPf_WANT					\
	   ? ((PL_op->op_flags & OPf_WANT) == OPf_WANT_LIST		\
	      ? G_ARRAY							\
	      : G_SCALAR)						\
	   : dowantarray())

/* NOTE: OP_NEXTSTATE, OP_DBSTATE, and OP_SETSTATE (i.e. COPs) carry lower
 * bits of PL_hints in op_private */

/* Private for lvalues */
#define OPpLVAL_INTRO	128	/* Lvalue must be localized or lvalue sub */

/* Private for OP_LEAVE, OP_LEAVESUB, OP_LEAVESUBLV and OP_LEAVEWRITE */
#define OPpREFCOUNTED		64	/* op_targ carries a refcount */

/* Private for OP_AASSIGN */
#define OPpASSIGN_COMMON	64	/* Left & right have syms in common. */

/* Private for OP_SASSIGN */
#define OPpASSIGN_BACKWARDS	64	/* Left & right switched. */
#define OPpASSIGN_CV_TO_GV	128	/* Possible optimisation for constants. */

/* Private for OP_MATCH and OP_SUBST{,CONST} */
#define OPpRUNTIME		64	/* Pattern coming in on the stack */

/* Private for OP_TRANS */
#define OPpTRANS_FROM_UTF	1
#define OPpTRANS_TO_UTF		2
#define OPpTRANS_IDENTICAL	4	/* right side is same as left */
#define OPpTRANS_SQUASH		8
    /* 16 is used for OPpTARGET_MY */
#define OPpTRANS_COMPLEMENT	32
#define OPpTRANS_GROWS		64
#define OPpTRANS_DELETE		128
#define OPpTRANS_ALL	(OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|OPpTRANS_SQUASH|OPpTRANS_COMPLEMENT|OPpTRANS_GROWS|OPpTRANS_DELETE)

/* Private for OP_REPEAT */
#define OPpREPEAT_DOLIST	64	/* List replication. */

/* Private for OP_RV2GV, OP_RV2SV, OP_AELEM, OP_HELEM, OP_PADSV */
#define OPpDEREF		(32|64)	/* autovivify: Want ref to something: */
#define OPpDEREF_AV		32	/*   Want ref to AV. */
#define OPpDEREF_HV		64	/*   Want ref to HV. */
#define OPpDEREF_SV		(32|64)	/*   Want ref to SV. */
  /* OP_ENTERSUB only */
#define OPpENTERSUB_DB		16	/* Debug subroutine. */
#define OPpENTERSUB_HASTARG	32	/* Called from OP tree. */
#define OPpENTERSUB_NOMOD	64	/* Immune to mod() for :attrlist. */
  /* OP_RV2CV only */
#define OPpENTERSUB_AMPER	8	/* Used & form to call. */
#define OPpENTERSUB_NOPAREN	128	/* bare sub call (without parens) */
#define OPpENTERSUB_INARGS	4	/* Lval used as arg to a sub. */
  /* OP_GV only */
#define OPpEARLY_CV		32	/* foo() called before sub foo was parsed */
  /* OP_?ELEM only */
#define OPpLVAL_DEFER		16	/* Defer creation of array/hash elem */
  /* OP_RV2?V, OP_GVSV, OP_ENTERITER only */
#define OPpOUR_INTRO		16	/* Variable was in an our() */
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM */
#define OPpMAYBE_LVSUB		8	/* We might be an lvalue to return */
  /* OP_PADSV only */
#define OPpPAD_STATE		16	/* is a "state" pad */
  /* for OP_RV2?V, lower bits carry hints (currently only HINT_STRICT_REFS) */

  /* OP_RV2GV only */
#define OPpDONT_INIT_GV		4	/* Call gv_fetchpv with GV_NOINIT */
/* (Therefore will return whatever is currently in the symbol table, not
   guaranteed to be a PVGV)  */

  /* OP_RV2CV only */
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */

/* Private for OP_ENTERITER and OP_ITER */
#define OPpITER_REVERSED	4	/* for (reverse ...) */
#define OPpITER_DEF		8	/* for $_ or for my $_ */

/* Private for OP_CONST */
#define	OPpCONST_NOVER		2	/* no 6; */
#define	OPpCONST_SHORTCIRCUIT	4	/* eg the constant 5 in (5 || foo) */
#define	OPpCONST_STRICT		8	/* bearword subject to strict 'subs' */
#define OPpCONST_ENTERED	16	/* Has been entered as symbol. */
#define OPpCONST_ARYBASE	32	/* Was a $[ translated to constant. */
#define OPpCONST_BARE		64	/* Was a bare word (filehandle?). */
#define OPpCONST_WARNING	128	/* Was a $^W translated to constant. */

/* Private for OP_FLIP/FLOP */
#define OPpFLIP_LINENUM		64	/* Range arg potentially a line num. */

/* Private for OP_LIST */
#define OPpLIST_GUESSED		64	/* Guessed that pushmark was needed. */

/* Private for OP_DELETE */
#define OPpSLICE		64	/* Operating on a list of keys */

/* Private for OP_EXISTS */
#define OPpEXISTS_SUB		64	/* Checking for &sub, not {} or [].  */

/* Private for OP_SORT */
#define OPpSORT_NUMERIC		1	/* Optimized away { $a <=> $b } */
#define OPpSORT_INTEGER		2	/* Ditto while under "use integer" */
#define OPpSORT_REVERSE		4	/* Reversed sort */
#define OPpSORT_INPLACE		8	/* sort in-place; eg @a = sort @a */
#define OPpSORT_DESCEND		16	/* Descending sort */
#define OPpSORT_QSORT		32	/* Use quicksort (not mergesort) */
#define OPpSORT_STABLE		64	/* Use a stable algorithm */

/* Private for OP_THREADSV */
#define OPpDONE_SVREF		64	/* Been through newSVREF once */

/* Private for OP_OPEN and OP_BACKTICK */
#define OPpOPEN_IN_RAW		16	/* binmode(F,":raw") on input fh */
#define OPpOPEN_IN_CRLF		32	/* binmode(F,":crlf") on input fh */
#define OPpOPEN_OUT_RAW		64	/* binmode(F,":raw") on output fh */
#define OPpOPEN_OUT_CRLF	128	/* binmode(F,":crlf") on output fh */

/* Private for OP_EXIT, HUSH also for OP_DIE */
#define OPpHUSH_VMSISH		64	/* hush DCL exit msg vmsish mode*/
#define OPpEXIT_VMSISH		128	/* exit(0) vs. exit(1) vmsish mode*/

/* Private for OP_FTXXX */
#define OPpFT_ACCESS		2	/* use filetest 'access' */
#define OPpFT_STACKED		4	/* stacked filetest, as in "-f -x $f" */
#define OP_IS_FILETEST_ACCESS(op) 		\
	(((op)->op_type) == OP_FTRREAD  ||	\
	 ((op)->op_type) == OP_FTRWRITE ||	\
	 ((op)->op_type) == OP_FTREXEC  ||	\
	 ((op)->op_type) == OP_FTEREAD  ||	\
	 ((op)->op_type) == OP_FTEWRITE ||	\
	 ((op)->op_type) == OP_FTEEXEC)

/* Private for OP_(MAP|GREP)(WHILE|START) */
#define OPpGREP_LEX		2	/* iterate over lexical $_ */
    
/* Private for OP_ENTEREVAL */
#define OPpEVAL_HAS_HH		2	/* Does it have a copy of %^H */
    
struct op {
    BASEOP
};

struct unop {
    BASEOP
    OP *	op_first;
};

struct binop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct logop {
    BASEOP
    OP *	op_first;
    OP *	op_other;
};

struct listop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct pmop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
#ifdef USE_ITHREADS
    IV          op_pmoffset;
#else
    REGEXP *    op_pmregexp;            /* compiled expression */
#endif
    U32         op_pmflags;
    union {
	OP *	op_pmreplroot;		/* For OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET  op_pmtargetoff;	/* For OP_PUSHRE */
#else
	GV *	op_pmtargetgv;
#endif
    }	op_pmreplrootu;
    union {
	OP *	op_pmreplstart;	/* Only used in OP_SUBST */
#ifdef USE_ITHREADS
	char *	op_pmstashpv;	/* Only used in OP_MATCH, with PMf_ONCE set */
#else
	HV *	op_pmstash;
#endif
    }		op_pmstashstartu;
};

#ifdef USE_ITHREADS
#define PM_GETRE(o)     (INT2PTR(REGEXP*,SvIVX(PL_regex_pad[(o)->op_pmoffset])))
#define PM_SETRE(o,r)   STMT_START { \
                            SV* const sv = PL_regex_pad[(o)->op_pmoffset]; \
                            sv_setiv(sv, PTR2IV(r)); \
                        } STMT_END
#define PM_GETRE_SAFE(o) (PL_regex_pad ? PM_GETRE(o) : (REGEXP*)0)
#define PM_SETRE_SAFE(o,r) if (PL_regex_pad) PM_SETRE(o,r)
#else
#define PM_GETRE(o)     ((o)->op_pmregexp)
#define PM_SETRE(o,r)   ((o)->op_pmregexp = (r))
#define PM_GETRE_SAFE PM_GETRE
#define PM_SETRE_SAFE PM_SETRE
#endif


#define PMf_RETAINT	0x0001		/* taint $1 etc. if target tainted */
#define PMf_ONCE	0x0002		/* match successfully only once per
                                           reset, with related flag RXf_USED
                                           in re->extflags holding state.
					   This is used only for ?? matches,
					   and only on OP_MATCH and OP_QR */

#define PMf_UNUSED	0x0004		/* free for use */
#define PMf_MAYBE_CONST	0x0008		/* replacement contains variables */

#define PMf_USED        0x0010          /* PMf_ONCE has matched successfully.
                                           Not used under threading. */

#define PMf_CONST	0x0040		/* subst replacement is constant */
#define PMf_KEEP	0x0080		/* keep 1st runtime pattern forever */
#define PMf_GLOBAL	0x0100		/* pattern had a g modifier */
#define PMf_CONTINUE	0x0200		/* don't reset pos() if //g fails */
#define PMf_EVAL	0x0400		/* evaluating replacement as expr */

/* The following flags have exact equivalents in regcomp.h with the prefix RXf_
 * which are stored in the regexp->extflags member.
 */
#define PMf_LOCALE	0x00800		/* use locale for character types */
#define PMf_MULTILINE	0x01000		/* assume multiple lines */
#define PMf_SINGLELINE	0x02000		/* assume single line */
#define PMf_FOLD	0x04000		/* case insensitivity */
#define PMf_EXTENDED	0x08000		/* chuck embedded whitespace */
#define PMf_KEEPCOPY	0x10000		/* copy the string when matching */

/* mask of bits that need to be transfered to re->extflags */
#define PMf_COMPILETIME	(PMf_MULTILINE|PMf_SINGLELINE|PMf_LOCALE|PMf_FOLD|PMf_EXTENDED|PMf_KEEPCOPY)

#ifdef USE_ITHREADS

#  define PmopSTASHPV(o)						\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstashpv : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASHPV_set(o,pv)	({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstashpv = savesharedpv(pv));	\
    })
#  else
#    define PmopSTASHPV_set(o,pv)					\
    ((o)->op_pmstashstartu.op_pmstashpv = savesharedpv(pv))
#  endif
#  define PmopSTASH(o)		(PmopSTASHPV(o) \
				 ? gv_stashpv((o)->op_pmstashstartu.op_pmstashpv,GV_ADD) : NULL)
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME_get(hv) : NULL))
#  define PmopSTASH_free(o)	PerlMemShared_free(PmopSTASHPV(o))

#else
#  define PmopSTASH(o)							\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstash : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASH_set(o,hv)		({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstash = (hv));			\
    })
#  else
#    define PmopSTASH_set(o,hv)	((o)->op_pmstashstartu.op_pmstash = (hv))
#  endif
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
   /* op_pmstashstartu.op_pmstash is not refcounted */
#  define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))
/* Note that if this becomes non-empty, then S_forget_pmop in op.c will need
   changing */
#  define PmopSTASH_free(o)    
#endif

struct svop {
    BASEOP
    SV *	op_sv;
};

struct padop {
    BASEOP
    PADOFFSET	op_padix;
};

struct pvop {
    BASEOP
    char *	op_pv;
};

struct loop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    OP *	op_redoop;
    OP *	op_nextop;
    OP *	op_lastop;
};

#define cUNOPx(o)	((UNOP*)o)
#define cBINOPx(o)	((BINOP*)o)
#define cLISTOPx(o)	((LISTOP*)o)
#define cLOGOPx(o)	((LOGOP*)o)
#define cPMOPx(o)	((PMOP*)o)
#define cSVOPx(o)	((SVOP*)o)
#define cPADOPx(o)	((PADOP*)o)
#define cPVOPx(o)	((PVOP*)o)
#define cCOPx(o)	((COP*)o)
#define cLOOPx(o)	((LOOP*)o)

#define cUNOP		cUNOPx(PL_op)
#define cBINOP		cBINOPx(PL_op)
#define cLISTOP		cLISTOPx(PL_op)
#define cLOGOP		cLOGOPx(PL_op)
#define cPMOP		cPMOPx(PL_op)
#define cSVOP		cSVOPx(PL_op)
#define cPADOP		cPADOPx(PL_op)
#define cPVOP		cPVOPx(PL_op)
#define cCOP		cCOPx(PL_op)
#define cLOOP		cLOOPx(PL_op)

#define cUNOPo		cUNOPx(o)
#define cBINOPo		cBINOPx(o)
#define cLISTOPo	cLISTOPx(o)
#define cLOGOPo		cLOGOPx(o)
#define cPMOPo		cPMOPx(o)
#define cSVOPo		cSVOPx(o)
#define cPADOPo		cPADOPx(o)
#define cPVOPo		cPVOPx(o)
#define cCOPo		cCOPx(o)
#define cLOOPo		cLOOPx(o)

#define kUNOP		cUNOPx(kid)
#define kBINOP		cBINOPx(kid)
#define kLISTOP		cLISTOPx(kid)
#define kLOGOP		cLOGOPx(kid)
#define kPMOP		cPMOPx(kid)
#define kSVOP		cSVOPx(kid)
#define kPADOP		cPADOPx(kid)
#define kPVOP		cPVOPx(kid)
#define kCOP		cCOPx(kid)
#define kLOOP		cLOOPx(kid)


#ifdef USE_ITHREADS
#  define	cGVOPx_gv(o)	((GV*)PAD_SVl(cPADOPx(o)->op_padix))
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && isGV_with_GP(v) \
				 && GvIN_PAD(v))
#  define	IS_PADCONST(v)	(v && SvREADONLY(v))
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv \
				 ? cSVOPx(v)->op_sv : PAD_SVl((v)->op_targ))
#  define	cSVOPx_svp(v)	(cSVOPx(v)->op_sv \
				 ? &cSVOPx(v)->op_sv : &PAD_SVl((v)->op_targ))
#else
#  define	cGVOPx_gv(o)	((GV*)cSVOPx(o)->op_sv)
#  define	IS_PADGV(v)	FALSE
#  define	IS_PADCONST(v)	FALSE
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv)
#  define	cSVOPx_svp(v)	(&cSVOPx(v)->op_sv)
#endif

#define	cGVOP_gv		cGVOPx_gv(PL_op)
#define	cGVOPo_gv		cGVOPx_gv(o)
#define	kGVOP_gv		cGVOPx_gv(kid)
#define cSVOP_sv		cSVOPx_sv(PL_op)
#define cSVOPo_sv		cSVOPx_sv(o)
#define kSVOP_sv		cSVOPx_sv(kid)

#define Nullop Null(OP*)

/* Lowest byte-and-a-bit of PL_opargs */
#define OA_MARK 1
#define OA_FOLDCONST 2
#define OA_RETSCALAR 4
#define OA_TARGET 8
#define OA_RETINTEGER 16
#define OA_OTHERINT 32
#define OA_DANGEROUS 64
#define OA_DEFGV 128
#define OA_TARGLEX 256

/* The next 4 bits encode op class information */
#define OCSHIFT 9

#define OA_CLASS_MASK (15 << OCSHIFT)

#define OA_BASEOP (0 << OCSHIFT)
#define OA_UNOP (1 << OCSHIFT)
#define OA_BINOP (2 << OCSHIFT)
#define OA_LOGOP (3 << OCSHIFT)
#define OA_LISTOP (4 << OCSHIFT)
#define OA_PMOP (5 << OCSHIFT)
#define OA_SVOP (6 << OCSHIFT)
#define OA_PADOP (7 << OCSHIFT)
#define OA_PVOP_OR_SVOP (8 << OCSHIFT)
#define OA_LOOP (9 << OCSHIFT)
#define OA_COP (10 << OCSHIFT)
#define OA_BASEOP_OR_UNOP (11 << OCSHIFT)
#define OA_FILESTATOP (12 << OCSHIFT)
#define OA_LOOPEXOP (13 << OCSHIFT)

#define OASHIFT 13

/* Remaining nybbles of PL_opargs */
#define OA_SCALAR 1
#define OA_LIST 2
#define OA_AVREF 3
#define OA_HVREF 4
#define OA_CVREF 5
#define OA_FILEREF 6
#define OA_SCALARREF 7
#define OA_OPTIONAL 8

/* Op_REFCNT is a reference count at the head of each op tree: needed
 * since the tree is shared between threads, and between cloned closure
 * copies in the same thread. OP_REFCNT_LOCK/UNLOCK is used when modifying
 * this count.
 * The same mutex is used to protect the refcounts of the reg_trie_data
 * and reg_ac_data structures, which are shared between duplicated
 * regexes.
 */

#ifdef USE_ITHREADS
#  define OP_REFCNT_INIT		MUTEX_INIT(&PL_op_mutex)
#  ifdef PERL_CORE
#    define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#    define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
#  else
#    define OP_REFCNT_LOCK		op_refcnt_lock()
#    define OP_REFCNT_UNLOCK		op_refcnt_unlock()
#  endif
#  define OP_REFCNT_TERM		MUTEX_DESTROY(&PL_op_mutex)
#else
#  define OP_REFCNT_INIT		NOOP
#  define OP_REFCNT_LOCK		NOOP
#  define OP_REFCNT_UNLOCK		NOOP
#  define OP_REFCNT_TERM		NOOP
#endif

#define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#ifdef PERL_DEBUG_READONLY_OPS
#  define OpREFCNT_inc(o)		Perl_op_refcnt_inc(aTHX_ o)
#  define OpREFCNT_dec(o)		Perl_op_refcnt_dec(aTHX_ o)
#else
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : NULL)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
#endif

/* flags used by Perl_load_module() */
#define PERL_LOADMOD_DENY		0x1
#define PERL_LOADMOD_NOIMPORT		0x2
#define PERL_LOADMOD_IMPORT_OPS		0x4

#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C)
#define ref(o, type) doref(o, type, TRUE)
#endif

/* no longer used anywhere in core */
#ifndef PERL_CORE
#define cv_ckproto(cv, gv, p) \
   cv_ckproto_len((cv), (gv), (p), (p) ? strlen(p) : 0)
#endif

#ifdef USE_REENTRANT_API
#include "reentr.h"
#endif

#if defined(PL_OP_SLAB_ALLOC)
#define NewOp(m,var,c,type)	\
	(var = (type *) Perl_Slab_Alloc(aTHX_ c*sizeof(type)))
#define NewOpSz(m,var,size)	\
	(var = (OP *) Perl_Slab_Alloc(aTHX_ size))
#define FreeOp(p) Perl_Slab_Free(aTHX_ p)
#else
#define NewOp(m, var, c, type)	\
	(var = (MEM_WRAP_CHECK_(c,type) \
	 (type*)PerlMemShared_calloc(c, sizeof(type))))
#define NewOpSz(m, var, size)	\
	(var = (OP*)PerlMemShared_calloc(1, size))
#define FreeOp(p) PerlMemShared_free(p)
#endif

#ifdef PERL_MAD
#  define MAD_NULL 1
#  define MAD_PV 2
#  define MAD_OP 3
#  define MAD_SV 4

struct madprop {
    MADPROP* mad_next;
    const void *mad_val;
    U32 mad_vlen;
/*    short mad_count; */
    char mad_key;
    char mad_type;
};

struct token {
    I32 tk_type;
    YYSTYPE tk_lval;
    MADPROP* tk_mad;
};
#endif

/*
 * Values that can be held by mad_key :
 * ^       unfilled head spot
 * ,       literal ,
 * ;       literal ; (blank if implicit ; at end of block)
 * :       literal : from ?: or attr list
 * +       unary +
 * ?       literal ? from ?:
 * (       literal (
 * )       literal )
 * [       literal [
 * ]       literal ]
 * {       literal {
 * }       literal }
 * @       literal @ sigil
 * $       literal $ sigil
 * *       literal * sigil
 * !       use is source filtered
 * &       & or sub
 * #       whitespace/comment following ; or }
 * #       $# sigil
 * 1       1st ; from for(;;)
 * 1       retired protasis
 * 2       2nd ; from for(;;)
 * 2       retired apodosis
 * 3       C-style for list
 * a       sub or var attributes
 * a       non-method arrow operator
 * A       method arrow operator
 * A       use import args
 * b       format block
 * B       retired stub block
 * C       constant conditional op
 * d       declarator
 * D       do block
 * e       unreached "else" (see C)
 * e       expression producing E
 * E       tr/E/R/, /E/
 * f       folded constant op
 * F       peg op for format
 * g       op was forced to be a word
 * i       if/unless modifier
 * I       if/elsif/unless statement
 * k       local declarator
 * K       retired kid op
 * l       last index of array ($#foo)
 * L       label
 * m       modifier on regex
 * n       sub or format name
 * o       current operator/declarator name
 * o       else/continue
 * O       generic optimized op
 * p       peg to hold extra whitespace at statement level
 * P       peg op for package declaration
 * q       opening quote
 * =       quoted material
 * Q       closing quote
 * Q       optimized qw//
 * r       expression producing R
 * R       tr/E/R/ s/E/R/
 * s       sub signature
 * S       use import stub (no import)
 * S       retired sort block
 * t       unreached "then" (see C)
 * U       use import op
 * v       private sv of for loop
 * V       use version
 * w       while/until modifier
 * W       while/for statement
 * x       optimized qw
 * X       random thing
 * _       whitespace/comments preceding anything else
 * ~       =~ operator
 */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\opnames.h ===
/* -*- buffer-read-only: t -*-
 *
 *    opnames.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by opcode.pl from its data.  Any changes made here
 *  will be lost!
 */

typedef enum opcode {
	OP_NULL,	/* 0 */
	OP_STUB,	/* 1 */
	OP_SCALAR,	/* 2 */
	OP_PUSHMARK,	/* 3 */
	OP_WANTARRAY,	/* 4 */
	OP_CONST,	/* 5 */
	OP_GVSV,	/* 6 */
	OP_GV,		/* 7 */
	OP_GELEM,	/* 8 */
	OP_PADSV,	/* 9 */
	OP_PADAV,	/* 10 */
	OP_PADHV,	/* 11 */
	OP_PADANY,	/* 12 */
	OP_PUSHRE,	/* 13 */
	OP_RV2GV,	/* 14 */
	OP_RV2SV,	/* 15 */
	OP_AV2ARYLEN,	/* 16 */
	OP_RV2CV,	/* 17 */
	OP_ANONCODE,	/* 18 */
	OP_PROTOTYPE,	/* 19 */
	OP_REFGEN,	/* 20 */
	OP_SREFGEN,	/* 21 */
	OP_REF,		/* 22 */
	OP_BLESS,	/* 23 */
	OP_BACKTICK,	/* 24 */
	OP_GLOB,	/* 25 */
	OP_READLINE,	/* 26 */
	OP_RCATLINE,	/* 27 */
	OP_REGCMAYBE,	/* 28 */
	OP_REGCRESET,	/* 29 */
	OP_REGCOMP,	/* 30 */
	OP_MATCH,	/* 31 */
	OP_QR,		/* 32 */
	OP_SUBST,	/* 33 */
	OP_SUBSTCONT,	/* 34 */
	OP_TRANS,	/* 35 */
	OP_SASSIGN,	/* 36 */
	OP_AASSIGN,	/* 37 */
	OP_CHOP,	/* 38 */
	OP_SCHOP,	/* 39 */
	OP_CHOMP,	/* 40 */
	OP_SCHOMP,	/* 41 */
	OP_DEFINED,	/* 42 */
	OP_UNDEF,	/* 43 */
	OP_STUDY,	/* 44 */
	OP_POS,		/* 45 */
	OP_PREINC,	/* 46 */
	OP_I_PREINC,	/* 47 */
	OP_PREDEC,	/* 48 */
	OP_I_PREDEC,	/* 49 */
	OP_POSTINC,	/* 50 */
	OP_I_POSTINC,	/* 51 */
	OP_POSTDEC,	/* 52 */
	OP_I_POSTDEC,	/* 53 */
	OP_POW,		/* 54 */
	OP_MULTIPLY,	/* 55 */
	OP_I_MULTIPLY,	/* 56 */
	OP_DIVIDE,	/* 57 */
	OP_I_DIVIDE,	/* 58 */
	OP_MODULO,	/* 59 */
	OP_I_MODULO,	/* 60 */
	OP_REPEAT,	/* 61 */
	OP_ADD,		/* 62 */
	OP_I_ADD,	/* 63 */
	OP_SUBTRACT,	/* 64 */
	OP_I_SUBTRACT,	/* 65 */
	OP_CONCAT,	/* 66 */
	OP_STRINGIFY,	/* 67 */
	OP_LEFT_SHIFT,	/* 68 */
	OP_RIGHT_SHIFT,	/* 69 */
	OP_LT,		/* 70 */
	OP_I_LT,	/* 71 */
	OP_GT,		/* 72 */
	OP_I_GT,	/* 73 */
	OP_LE,		/* 74 */
	OP_I_LE,	/* 75 */
	OP_GE,		/* 76 */
	OP_I_GE,	/* 77 */
	OP_EQ,		/* 78 */
	OP_I_EQ,	/* 79 */
	OP_NE,		/* 80 */
	OP_I_NE,	/* 81 */
	OP_NCMP,	/* 82 */
	OP_I_NCMP,	/* 83 */
	OP_SLT,		/* 84 */
	OP_SGT,		/* 85 */
	OP_SLE,		/* 86 */
	OP_SGE,		/* 87 */
	OP_SEQ,		/* 88 */
	OP_SNE,		/* 89 */
	OP_SCMP,	/* 90 */
	OP_BIT_AND,	/* 91 */
	OP_BIT_XOR,	/* 92 */
	OP_BIT_OR,	/* 93 */
	OP_NEGATE,	/* 94 */
	OP_I_NEGATE,	/* 95 */
	OP_NOT,		/* 96 */
	OP_COMPLEMENT,	/* 97 */
	OP_SMARTMATCH,	/* 98 */
	OP_ATAN2,	/* 99 */
	OP_SIN,		/* 100 */
	OP_COS,		/* 101 */
	OP_RAND,	/* 102 */
	OP_SRAND,	/* 103 */
	OP_EXP,		/* 104 */
	OP_LOG,		/* 105 */
	OP_SQRT,	/* 106 */
	OP_INT,		/* 107 */
	OP_HEX,		/* 108 */
	OP_OCT,		/* 109 */
	OP_ABS,		/* 110 */
	OP_LENGTH,	/* 111 */
	OP_SUBSTR,	/* 112 */
	OP_VEC,		/* 113 */
	OP_INDEX,	/* 114 */
	OP_RINDEX,	/* 115 */
	OP_SPRINTF,	/* 116 */
	OP_FORMLINE,	/* 117 */
	OP_ORD,		/* 118 */
	OP_CHR,		/* 119 */
	OP_CRYPT,	/* 120 */
	OP_UCFIRST,	/* 121 */
	OP_LCFIRST,	/* 122 */
	OP_UC,		/* 123 */
	OP_LC,		/* 124 */
	OP_QUOTEMETA,	/* 125 */
	OP_RV2AV,	/* 126 */
	OP_AELEMFAST,	/* 127 */
	OP_AELEM,	/* 128 */
	OP_ASLICE,	/* 129 */
	OP_EACH,	/* 130 */
	OP_VALUES,	/* 131 */
	OP_KEYS,	/* 132 */
	OP_DELETE,	/* 133 */
	OP_EXISTS,	/* 134 */
	OP_RV2HV,	/* 135 */
	OP_HELEM,	/* 136 */
	OP_HSLICE,	/* 137 */
	OP_UNPACK,	/* 138 */
	OP_PACK,	/* 139 */
	OP_SPLIT,	/* 140 */
	OP_JOIN,	/* 141 */
	OP_LIST,	/* 142 */
	OP_LSLICE,	/* 143 */
	OP_ANONLIST,	/* 144 */
	OP_ANONHASH,	/* 145 */
	OP_SPLICE,	/* 146 */
	OP_PUSH,	/* 147 */
	OP_POP,		/* 148 */
	OP_SHIFT,	/* 149 */
	OP_UNSHIFT,	/* 150 */
	OP_SORT,	/* 151 */
	OP_REVERSE,	/* 152 */
	OP_GREPSTART,	/* 153 */
	OP_GREPWHILE,	/* 154 */
	OP_MAPSTART,	/* 155 */
	OP_MAPWHILE,	/* 156 */
	OP_RANGE,	/* 157 */
	OP_FLIP,	/* 158 */
	OP_FLOP,	/* 159 */
	OP_AND,		/* 160 */
	OP_OR,		/* 161 */
	OP_XOR,		/* 162 */
	OP_DOR,		/* 163 */
	OP_COND_EXPR,	/* 164 */
	OP_ANDASSIGN,	/* 165 */
	OP_ORASSIGN,	/* 166 */
	OP_DORASSIGN,	/* 167 */
	OP_METHOD,	/* 168 */
	OP_ENTERSUB,	/* 169 */
	OP_LEAVESUB,	/* 170 */
	OP_LEAVESUBLV,	/* 171 */
	OP_CALLER,	/* 172 */
	OP_WARN,	/* 173 */
	OP_DIE,		/* 174 */
	OP_RESET,	/* 175 */
	OP_LINESEQ,	/* 176 */
	OP_NEXTSTATE,	/* 177 */
	OP_DBSTATE,	/* 178 */
	OP_UNSTACK,	/* 179 */
	OP_ENTER,	/* 180 */
	OP_LEAVE,	/* 181 */
	OP_SCOPE,	/* 182 */
	OP_ENTERITER,	/* 183 */
	OP_ITER,	/* 184 */
	OP_ENTERLOOP,	/* 185 */
	OP_LEAVELOOP,	/* 186 */
	OP_RETURN,	/* 187 */
	OP_LAST,	/* 188 */
	OP_NEXT,	/* 189 */
	OP_REDO,	/* 190 */
	OP_DUMP,	/* 191 */
	OP_GOTO,	/* 192 */
	OP_EXIT,	/* 193 */
	OP_SETSTATE,	/* 194 */
	OP_METHOD_NAMED,/* 195 */
	OP_ENTERGIVEN,	/* 196 */
	OP_LEAVEGIVEN,	/* 197 */
	OP_ENTERWHEN,	/* 198 */
	OP_LEAVEWHEN,	/* 199 */
	OP_BREAK,	/* 200 */
	OP_CONTINUE,	/* 201 */
	OP_OPEN,	/* 202 */
	OP_CLOSE,	/* 203 */
	OP_PIPE_OP,	/* 204 */
	OP_FILENO,	/* 205 */
	OP_UMASK,	/* 206 */
	OP_BINMODE,	/* 207 */
	OP_TIE,		/* 208 */
	OP_UNTIE,	/* 209 */
	OP_TIED,	/* 210 */
	OP_DBMOPEN,	/* 211 */
	OP_DBMCLOSE,	/* 212 */
	OP_SSELECT,	/* 213 */
	OP_SELECT,	/* 214 */
	OP_GETC,	/* 215 */
	OP_READ,	/* 216 */
	OP_ENTERWRITE,	/* 217 */
	OP_LEAVEWRITE,	/* 218 */
	OP_PRTF,	/* 219 */
	OP_PRINT,	/* 220 */
	OP_SAY,		/* 221 */
	OP_SYSOPEN,	/* 222 */
	OP_SYSSEEK,	/* 223 */
	OP_SYSREAD,	/* 224 */
	OP_SYSWRITE,	/* 225 */
	OP_SEND,	/* 226 */
	OP_RECV,	/* 227 */
	OP_EOF,		/* 228 */
	OP_TELL,	/* 229 */
	OP_SEEK,	/* 230 */
	OP_TRUNCATE,	/* 231 */
	OP_FCNTL,	/* 232 */
	OP_IOCTL,	/* 233 */
	OP_FLOCK,	/* 234 */
	OP_SOCKET,	/* 235 */
	OP_SOCKPAIR,	/* 236 */
	OP_BIND,	/* 237 */
	OP_CONNECT,	/* 238 */
	OP_LISTEN,	/* 239 */
	OP_ACCEPT,	/* 240 */
	OP_SHUTDOWN,	/* 241 */
	OP_GSOCKOPT,	/* 242 */
	OP_SSOCKOPT,	/* 243 */
	OP_GETSOCKNAME,	/* 244 */
	OP_GETPEERNAME,	/* 245 */
	OP_LSTAT,	/* 246 */
	OP_STAT,	/* 247 */
	OP_FTRREAD,	/* 248 */
	OP_FTRWRITE,	/* 249 */
	OP_FTREXEC,	/* 250 */
	OP_FTEREAD,	/* 251 */
	OP_FTEWRITE,	/* 252 */
	OP_FTEEXEC,	/* 253 */
	OP_FTIS,	/* 254 */
	OP_FTSIZE,	/* 255 */
	OP_FTMTIME,	/* 256 */
	OP_FTATIME,	/* 257 */
	OP_FTCTIME,	/* 258 */
	OP_FTROWNED,	/* 259 */
	OP_FTEOWNED,	/* 260 */
	OP_FTZERO,	/* 261 */
	OP_FTSOCK,	/* 262 */
	OP_FTCHR,	/* 263 */
	OP_FTBLK,	/* 264 */
	OP_FTFILE,	/* 265 */
	OP_FTDIR,	/* 266 */
	OP_FTPIPE,	/* 267 */
	OP_FTSUID,	/* 268 */
	OP_FTSGID,	/* 269 */
	OP_FTSVTX,	/* 270 */
	OP_FTLINK,	/* 271 */
	OP_FTTTY,	/* 272 */
	OP_FTTEXT,	/* 273 */
	OP_FTBINARY,	/* 274 */
	OP_CHDIR,	/* 275 */
	OP_CHOWN,	/* 276 */
	OP_CHROOT,	/* 277 */
	OP_UNLINK,	/* 278 */
	OP_CHMOD,	/* 279 */
	OP_UTIME,	/* 280 */
	OP_RENAME,	/* 281 */
	OP_LINK,	/* 282 */
	OP_SYMLINK,	/* 283 */
	OP_READLINK,	/* 284 */
	OP_MKDIR,	/* 285 */
	OP_RMDIR,	/* 286 */
	OP_OPEN_DIR,	/* 287 */
	OP_READDIR,	/* 288 */
	OP_TELLDIR,	/* 289 */
	OP_SEEKDIR,	/* 290 */
	OP_REWINDDIR,	/* 291 */
	OP_CLOSEDIR,	/* 292 */
	OP_FORK,	/* 293 */
	OP_WAIT,	/* 294 */
	OP_WAITPID,	/* 295 */
	OP_SYSTEM,	/* 296 */
	OP_EXEC,	/* 297 */
	OP_KILL,	/* 298 */
	OP_GETPPID,	/* 299 */
	OP_GETPGRP,	/* 300 */
	OP_SETPGRP,	/* 301 */
	OP_GETPRIORITY,	/* 302 */
	OP_SETPRIORITY,	/* 303 */
	OP_TIME,	/* 304 */
	OP_TMS,		/* 305 */
	OP_LOCALTIME,	/* 306 */
	OP_GMTIME,	/* 307 */
	OP_ALARM,	/* 308 */
	OP_SLEEP,	/* 309 */
	OP_SHMGET,	/* 310 */
	OP_SHMCTL,	/* 311 */
	OP_SHMREAD,	/* 312 */
	OP_SHMWRITE,	/* 313 */
	OP_MSGGET,	/* 314 */
	OP_MSGCTL,	/* 315 */
	OP_MSGSND,	/* 316 */
	OP_MSGRCV,	/* 317 */
	OP_SEMOP,	/* 318 */
	OP_SEMGET,	/* 319 */
	OP_SEMCTL,	/* 320 */
	OP_REQUIRE,	/* 321 */
	OP_DOFILE,	/* 322 */
	OP_ENTEREVAL,	/* 323 */
	OP_LEAVEEVAL,	/* 324 */
	OP_ENTERTRY,	/* 325 */
	OP_LEAVETRY,	/* 326 */
	OP_GHBYNAME,	/* 327 */
	OP_GHBYADDR,	/* 328 */
	OP_GHOSTENT,	/* 329 */
	OP_GNBYNAME,	/* 330 */
	OP_GNBYADDR,	/* 331 */
	OP_GNETENT,	/* 332 */
	OP_GPBYNAME,	/* 333 */
	OP_GPBYNUMBER,	/* 334 */
	OP_GPROTOENT,	/* 335 */
	OP_GSBYNAME,	/* 336 */
	OP_GSBYPORT,	/* 337 */
	OP_GSERVENT,	/* 338 */
	OP_SHOSTENT,	/* 339 */
	OP_SNETENT,	/* 340 */
	OP_SPROTOENT,	/* 341 */
	OP_SSERVENT,	/* 342 */
	OP_EHOSTENT,	/* 343 */
	OP_ENETENT,	/* 344 */
	OP_EPROTOENT,	/* 345 */
	OP_ESERVENT,	/* 346 */
	OP_GPWNAM,	/* 347 */
	OP_GPWUID,	/* 348 */
	OP_GPWENT,	/* 349 */
	OP_SPWENT,	/* 350 */
	OP_EPWENT,	/* 351 */
	OP_GGRNAM,	/* 352 */
	OP_GGRGID,	/* 353 */
	OP_GGRENT,	/* 354 */
	OP_SGRENT,	/* 355 */
	OP_EGRENT,	/* 356 */
	OP_GETLOGIN,	/* 357 */
	OP_SYSCALL,	/* 358 */
	OP_LOCK,	/* 359 */
	OP_ONCE,	/* 360 */
	OP_CUSTOM,	/* 361 */
	OP_max		
} opcode;

#define MAXO 362
#define OP_phoney_INPUT_ONLY -1
#define OP_phoney_OUTPUT_ONLY -2


#define OP_IS_SOCKET(op)	\
	((op) == OP_ACCEPT || \
	 (op) == OP_BIND || \
	 (op) == OP_CONNECT || \
	 (op) == OP_GETPEERNAME || \
	 (op) == OP_GETSOCKNAME || \
	 (op) == OP_GSOCKOPT || \
	 (op) == OP_LISTEN || \
	 (op) == OP_RECV || \
	 (op) == OP_SEND || \
	 (op) == OP_SHUTDOWN || \
	 (op) == OP_SOCKET || \
	 (op) == OP_SOCKPAIR || \
	 (op) == OP_SSOCKOPT)


#define OP_IS_FILETEST(op)	\
	((op) == OP_FTATIME || \
	 (op) == OP_FTBINARY || \
	 (op) == OP_FTBLK || \
	 (op) == OP_FTCHR || \
	 (op) == OP_FTCTIME || \
	 (op) == OP_FTDIR || \
	 (op) == OP_FTEEXEC || \
	 (op) == OP_FTEOWNED || \
	 (op) == OP_FTEREAD || \
	 (op) == OP_FTEWRITE || \
	 (op) == OP_FTFILE || \
	 (op) == OP_FTIS || \
	 (op) == OP_FTLINK || \
	 (op) == OP_FTMTIME || \
	 (op) == OP_FTPIPE || \
	 (op) == OP_FTREXEC || \
	 (op) == OP_FTROWNED || \
	 (op) == OP_FTRREAD || \
	 (op) == OP_FTRWRITE || \
	 (op) == OP_FTSGID || \
	 (op) == OP_FTSIZE || \
	 (op) == OP_FTSOCK || \
	 (op) == OP_FTSUID || \
	 (op) == OP_FTSVTX || \
	 (op) == OP_FTTEXT || \
	 (op) == OP_FTTTY || \
	 (op) == OP_FTZERO)

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\overload.h ===
/* -*- buffer-read-only: t -*-
 *
 *    overload.h
 *
 *    Copyright (C) 1997, 1998, 2000, 2001, 2005, 2006, 2007 by Larry Wall
 *    and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by overload.pl
 */

enum {
    fallback_amg,
    to_sv_amg,
    to_av_amg,
    to_hv_amg,
    to_gv_amg,
    to_cv_amg,
    inc_amg,
    dec_amg,
    bool__amg,
    numer_amg,
    string_amg,
    not_amg,
    copy_amg,
    abs_amg,
    neg_amg,
    iter_amg,
    int_amg,
    lt_amg,
    le_amg,
    gt_amg,
    ge_amg,
    eq_amg,
    ne_amg,
    slt_amg,
    sle_amg,
    sgt_amg,
    sge_amg,
    seq_amg,
    sne_amg,
    nomethod_amg,
    add_amg,
    add_ass_amg,
    subtr_amg,
    subtr_ass_amg,
    mult_amg,
    mult_ass_amg,
    div_amg,
    div_ass_amg,
    modulo_amg,
    modulo_ass_amg,
    pow_amg,
    pow_ass_amg,
    lshift_amg,
    lshift_ass_amg,
    rshift_amg,
    rshift_ass_amg,
    band_amg,
    band_ass_amg,
    bor_amg,
    bor_ass_amg,
    bxor_amg,
    bxor_ass_amg,
    ncmp_amg,
    scmp_amg,
    compl_amg,
    atan2_amg,
    cos_amg,
    sin_amg,
    exp_amg,
    log_amg,
    sqrt_amg,
    repeat_amg,
    repeat_ass_amg,
    concat_amg,
    concat_ass_amg,
    smart_amg,
    DESTROY_amg,
    max_amg_code
    /* Do not leave a trailing comma here.  C9X allows it, C89 doesn't. */
};

#define NofAMmeth max_amg_code
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\pad.h ===
/*    pad.h
 *
 *    Copyright (C) 2002, 2003, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * This file defines the types and macros associated with the API for
 * manipulating scratchpads, which are used by perl to store lexical
 * variables, op targets and constants.
 */




/* a padlist is currently just an AV; but that might change,
 * so hide the type. Ditto a pad.  */

typedef AV PADLIST;
typedef AV PAD;


/* offsets within a pad */

#if PTRSIZE == 4
typedef U32TYPE PADOFFSET;
#else
#   if PTRSIZE == 8
typedef U64TYPE PADOFFSET;
#   endif
#endif
#define NOT_IN_PAD ((PADOFFSET) -1)

/* B.xs needs these for the benefit of B::Deparse */ 
/* Low range end is exclusive (valid from the cop seq after this one) */
/* High range end is inclusive (valid up to this cop seq) */

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define COP_SEQ_RANGE_LOW(sv)						\
	(({ SV *const _svi = (SV *) (sv);				\
	  assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	  assert(SvTYPE(_svi) != SVt_PVAV);				\
	  assert(SvTYPE(_svi) != SVt_PVHV);				\
	  assert(SvTYPE(_svi) != SVt_PVCV);				\
	  assert(SvTYPE(_svi) != SVt_PVFM);				\
	  assert(!isGV_with_GP(_svi));					\
	  ((XPVNV*) SvANY(_svi))->xnv_u.xpad_cop_seq.xlow;		\
	 }))
#  define COP_SEQ_RANGE_HIGH(sv)					\
	(({ SV *const _svi = (SV *) (sv);				\
	  assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	  assert(SvTYPE(_svi) != SVt_PVAV);				\
	  assert(SvTYPE(_svi) != SVt_PVHV);				\
	  assert(SvTYPE(_svi) != SVt_PVCV);				\
	  assert(SvTYPE(_svi) != SVt_PVFM);				\
	  assert(!isGV_with_GP(_svi));					\
	  ((XPVNV*) SvANY(_svi))->xnv_u.xpad_cop_seq.xhigh;		\
	 }))
#  define PARENT_PAD_INDEX(sv)						\
	(({ SV *const _svi = (SV *) (sv);				\
	  assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	  assert(SvTYPE(_svi) != SVt_PVAV);				\
	  assert(SvTYPE(_svi) != SVt_PVHV);				\
	  assert(SvTYPE(_svi) != SVt_PVCV);				\
	  assert(SvTYPE(_svi) != SVt_PVFM);				\
	  assert(!isGV_with_GP(_svi));					\
	  ((XPVNV*) SvANY(_svi))->xnv_u.xpad_cop_seq.xlow;		\
	 }))
#  define PARENT_FAKELEX_FLAGS(sv)					\
	(({ SV *const _svi = (SV *) (sv);				\
	  assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	  assert(SvTYPE(_svi) != SVt_PVAV);				\
	  assert(SvTYPE(_svi) != SVt_PVHV);				\
	  assert(SvTYPE(_svi) != SVt_PVCV);				\
	  assert(SvTYPE(_svi) != SVt_PVFM);				\
	  assert(!isGV_with_GP(_svi));					\
	  ((XPVNV*) SvANY(_svi))->xnv_u.xpad_cop_seq.xhigh;		\
	 }))
#else
#  define COP_SEQ_RANGE_LOW(sv)		\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xlow))
#  define COP_SEQ_RANGE_HIGH(sv)	\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xhigh))


#  define PARENT_PAD_INDEX(sv)		\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xlow))
#  define PARENT_FAKELEX_FLAGS(sv)	\
	(0 + (((XPVNV*) SvANY(sv))->xnv_u.xpad_cop_seq.xhigh))
#endif

/* Flags set in the SvIVX field of FAKE namesvs */
    
#define PAD_FAKELEX_ANON   1 /* the lex is declared in an ANON, or ... */
#define PAD_FAKELEX_MULTI  2 /* the lex can be instantiated multiple times */

/* flags for the pad_new() function */

#define padnew_CLONE	1	/* this pad is for a cloned CV */
#define padnew_SAVE	2	/* save old globals */
#define padnew_SAVESUB	4	/* also save extra stuff for start of sub */

/* values for the pad_tidy() function */

typedef enum {
	padtidy_SUB,		/* tidy up a pad for a sub, */
	padtidy_SUBCLONE,	/* a cloned sub, */
	padtidy_FORMAT		/* or a format */
} padtidy_type;

/* ASSERT_CURPAD_LEGAL and ASSERT_CURPAD_ACTIVE respectively determine
 * whether PL_comppad and PL_curpad are consistent and whether they have
 * active values */

#ifndef PERL_MAD
#  define pad_peg(label)
#endif

#ifdef DEBUGGING
#  define ASSERT_CURPAD_LEGAL(label) \
    pad_peg(label); \
    if (PL_comppad ? (AvARRAY(PL_comppad) != PL_curpad) : (PL_curpad != 0))  \
	Perl_croak(aTHX_ "panic: illegal pad in %s: 0x%"UVxf"[0x%"UVxf"]",\
	    label, PTR2UV(PL_comppad), PTR2UV(PL_curpad));


#  define ASSERT_CURPAD_ACTIVE(label) \
    pad_peg(label); \
    if (!PL_comppad || (AvARRAY(PL_comppad) != PL_curpad))		  \
	Perl_croak(aTHX_ "panic: invalid pad in %s: 0x%"UVxf"[0x%"UVxf"]",\
	    label, PTR2UV(PL_comppad), PTR2UV(PL_curpad));
#else
#  define ASSERT_CURPAD_LEGAL(label)
#  define ASSERT_CURPAD_ACTIVE(label)
#endif



/* Note: the following three macros are actually defined in scope.h, but
 * they are documented here for completeness, since they directly or
 * indirectly affect pads.

=for apidoc m|void|SAVEPADSV	|PADOFFSET po
Save a pad slot (used to restore after an iteration)

XXX DAPM it would make more sense to make the arg a PADOFFSET
=for apidoc m|void|SAVECLEARSV	|SV **svp
Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')

=for apidoc m|void|SAVECOMPPAD
save PL_comppad and PL_curpad





=for apidoc m|SV *|PAD_SETSV	|PADOFFSET po|SV* sv
Set the slot at offset C<po> in the current pad to C<sv>

=for apidoc m|void|PAD_SV	|PADOFFSET po
Get the value at offset C<po> in the current pad

=for apidoc m|SV *|PAD_SVl	|PADOFFSET po
Lightweight and lvalue version of C<PAD_SV>.
Get or set the value at offset C<po> in the current pad.
Unlike C<PAD_SV>, does not print diagnostics with -DX.
For internal use only.

=for apidoc m|SV *|PAD_BASE_SV	|PADLIST padlist|PADOFFSET po
Get the value from slot C<po> in the base (DEPTH=1) pad of a padlist

=for apidoc m|void|PAD_SET_CUR	|PADLIST padlist|I32 n
Set the current pad to be pad C<n> in the padlist, saving
the previous current pad. NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with

    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


=for apidoc m|void|PAD_SET_CUR_NOSAVE	|PADLIST padlist|I32 n
like PAD_SET_CUR, but without the save

=for apidoc m|void|PAD_SAVE_SETNULLPAD
Save the current pad then set it to null.

=for apidoc m|void|PAD_SAVE_LOCAL|PAD *opad|PAD *npad
Save the current pad to the local variable opad, then make the
current pad equal to npad

=for apidoc m|void|PAD_RESTORE_LOCAL|PAD *opad
Restore the old pad saved into the local variable opad by PAD_SAVE_LOCAL()

=cut
*/

#ifdef DEBUGGING
#  define PAD_SV(po)	   pad_sv(po)
#  define PAD_SETSV(po,sv) pad_setsv(po,sv)
#else
#  define PAD_SV(po)       (PL_curpad[po])
#  define PAD_SETSV(po,sv) PL_curpad[po] = (sv)
#endif

#define PAD_SVl(po)       (PL_curpad[po])

#define PAD_BASE_SV(padlist, po) \
	(AvARRAY(padlist)[1]) 	\
	    ? AvARRAY((AV*)(AvARRAY(padlist)[1]))[po] : NULL;
    

#define PAD_SET_CUR_NOSAVE(padlist,nth) \
	PL_comppad = (PAD*) (AvARRAY(padlist)[nth]);		\
	PL_curpad = AvARRAY(PL_comppad);			\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,			\
	      "Pad 0x%"UVxf"[0x%"UVxf"] set_cur    depth=%d\n",	\
	      PTR2UV(PL_comppad), PTR2UV(PL_curpad), (int)(nth)));


#define PAD_SET_CUR(padlist,nth) \
	SAVECOMPPAD();						\
	PAD_SET_CUR_NOSAVE(padlist,nth);


#define PAD_SAVE_SETNULLPAD()	SAVECOMPPAD(); \
	PL_comppad = NULL; PL_curpad = NULL;	\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log, "Pad set_null\n"));

#define PAD_SAVE_LOCAL(opad,npad) \
	opad = PL_comppad;					\
	PL_comppad = (npad);					\
	PL_curpad =  PL_comppad ? AvARRAY(PL_comppad) : NULL;	\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,			\
	      "Pad 0x%"UVxf"[0x%"UVxf"] save_local\n",		\
	      PTR2UV(PL_comppad), PTR2UV(PL_curpad)));

#define PAD_RESTORE_LOCAL(opad) \
	PL_comppad = opad;					\
	PL_curpad =  PL_comppad ? AvARRAY(PL_comppad) : NULL;	\
	DEBUG_Xv(PerlIO_printf(Perl_debug_log,			\
	      "Pad 0x%"UVxf"[0x%"UVxf"] restore_local\n",	\
	      PTR2UV(PL_comppad), PTR2UV(PL_curpad)));


/*
=for apidoc m|void|CX_CURPAD_SAVE|struct context
Save the current pad in the given context block structure.

=for apidoc m|SV *|CX_CURPAD_SV|struct context|PADOFFSET po
Access the SV at offset po in the saved current pad in the given
context block structure (can be used as an lvalue).

=cut
*/

#define CX_CURPAD_SAVE(block)  (block).oldcomppad = PL_comppad
#define CX_CURPAD_SV(block,po) (AvARRAY((AV*)((block).oldcomppad))[po])


/*
=for apidoc m|U32|PAD_COMPNAME_FLAGS|PADOFFSET po
Return the flags for the current compiling pad name
at offset C<po>. Assumes a valid slot entry.

=for apidoc m|char *|PAD_COMPNAME_PV|PADOFFSET po
Return the name of the current compiling pad name
at offset C<po>. Assumes a valid slot entry.

=for apidoc m|HV *|PAD_COMPNAME_TYPE|PADOFFSET po
Return the type (stash) of the current compiling pad name at offset
C<po>. Must be a valid name. Returns null if not typed.

=for apidoc m|HV *|PAD_COMPNAME_OURSTASH|PADOFFSET po
Return the stash associated with an C<our> variable.
Assumes the slot entry is a valid C<our> lexical.

=for apidoc m|STRLEN|PAD_COMPNAME_GEN|PADOFFSET po
The generation number of the name at offset C<po> in the current
compiling pad (lvalue). Note that C<SvUVX> is hijacked for this purpose.

=for apidoc m|STRLEN|PAD_COMPNAME_GEN_set|PADOFFSET po|int gen
Sets the generation number of the name at offset C<po> in the current
ling pad (lvalue) to C<gen>.  Note that C<SvUV_set> is hijacked for this purpose.

=cut

*/

#define PAD_COMPNAME_SV(po) (*av_fetch(PL_comppad_name, (po), FALSE))
#define PAD_COMPNAME_FLAGS(po) SvFLAGS(PAD_COMPNAME_SV(po))
#define PAD_COMPNAME_FLAGS_isOUR(po) \
  ((PAD_COMPNAME_FLAGS(po) & (SVpad_NAME|SVpad_OUR)) == (SVpad_NAME|SVpad_OUR))
#define PAD_COMPNAME_PV(po) SvPV_nolen(PAD_COMPNAME_SV(po))

#define PAD_COMPNAME_TYPE(po) pad_compname_type(po)

#define PAD_COMPNAME_OURSTASH(po) \
    (SvOURSTASH(PAD_COMPNAME_SV(po)))

#define PAD_COMPNAME_GEN(po) ((STRLEN)SvUVX(AvARRAY(PL_comppad_name)[po]))

#define PAD_COMPNAME_GEN_set(po, gen) SvUV_set(AvARRAY(PL_comppad_name)[po], (UV)(gen))


/*
=for apidoc m|void|PAD_DUP|PADLIST dstpad|PADLIST srcpad|CLONE_PARAMS* param
Clone a padlist.

=for apidoc m|void|PAD_CLONE_VARS|PerlInterpreter *proto_perl \
|CLONE_PARAMS* param
Clone the state variables associated with running and compiling pads.

=cut
*/


#define PAD_DUP(dstpad, srcpad, param)				\
    if ((srcpad) && !AvREAL(srcpad)) {				\
	/* XXX padlists are real, but pretend to be not */ 	\
	AvREAL_on(srcpad);					\
	(dstpad) = av_dup_inc((srcpad), param);			\
	AvREAL_off(srcpad);					\
	AvREAL_off(dstpad);					\
    }								\
    else							\
	(dstpad) = av_dup_inc((srcpad), param);			

/* NB - we set PL_comppad to null unless it points at a value that
 * has already been dup'ed, ie it points to part of an active padlist.
 * Otherwise PL_comppad ends up being a leaked scalar in code like
 * the following:
 *     threads->create(sub { threads->create(sub {...} ) } );
 * where the second thread dups the outer sub's comppad but not the
 * sub's CV or padlist. */

#define PAD_CLONE_VARS(proto_perl, param)				\
    PL_comppad = (AV *) ptr_table_fetch(PL_ptr_table, proto_perl->Icomppad); \
    PL_curpad = PL_comppad ?  AvARRAY(PL_comppad) : NULL;		\
    PL_comppad_name		= av_dup(proto_perl->Icomppad_name, param); \
    PL_comppad_name_fill	= proto_perl->Icomppad_name_fill;	\
    PL_comppad_name_floor	= proto_perl->Icomppad_name_floor;	\
    PL_min_intro_pending	= proto_perl->Imin_intro_pending;	\
    PL_max_intro_pending	= proto_perl->Imax_intro_pending;	\
    PL_padix			= proto_perl->Ipadix;			\
    PL_padix_floor		= proto_perl->Ipadix_floor;		\
    PL_pad_reset_pending	= proto_perl->Ipad_reset_pending;	\
    PL_cop_seqmax		= proto_perl->Icop_seqmax;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\patchlevel.h ===
/*    patchlevel.h
 *
 *    Copyright (C) 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef __PATCHLEVEL_H_INCLUDED__

#include "BuildInfo.h"

/* do not adjust the whitespace! Configure expects the numbers to be
 * exactly on the third column */

#define PERL_REVISION	5		/* age */
#define PERL_VERSION	10		/* epoch */
#define PERL_SUBVERSION	0		/* generation */

/* The following numbers describe the earliest compatible version of
   Perl ("compatibility" here being defined as sufficient binary/API
   compatibility to run XS code built with the older version).
   Normally this should not change across maintenance releases.

   Note that this only refers to an out-of-the-box build.  Many non-default
   options such as usemultiplicity tend to break binary compatibility
   more often.

   This is used by Configure et al to figure out 
   PERL_INC_VERSION_LIST, which lists version libraries
   to include in @INC.  See INSTALL for how this works.
*/
#define PERL_API_REVISION	5	/* Adjust manually as needed.  */
#define PERL_API_VERSION	10	/* Adjust manually as needed.  */
#define PERL_API_SUBVERSION	0	/* Adjust manually as needed.  */
/*
   XXX Note:  The selection of non-default Configure options, such
   as -Duselonglong may invalidate these settings.  Currently, Configure
   does not adequately test for this.   A.D.  Jan 13, 2000
*/

#define __PATCHLEVEL_H_INCLUDED__
#endif

/*
	local_patches -- list of locally applied less-than-subversion patches.
	If you're distributing such a patch, please give it a name and a
	one-line description, placed just before the last NULL in the array
	below.  If your patch fixes a bug in the perlbug database, please
	mention the bugid.  If your patch *IS* dependent on a prior patch,
	please place your applied patch line after its dependencies. This
	will help tracking of patch dependencies.

	Please either use 'diff --unified=0' if your diff supports
	that or edit the hunk of the diff output which adds your patch
	to this list, to remove context lines which would give patch
	problems. For instance, if the original context diff is

	   *** patchlevel.h.orig	<date here>
	   --- patchlevel.h	<date here>
	   *** 38,43 ***
	   --- 38,44 ---
	     	,"FOO1235 - some patch"
	     	,"BAR3141 - another patch"
	     	,"BAZ2718 - and another patch"
	   + 	,"MINE001 - my new patch"
	     	,NULL
	     };
	
	please change it to 
	   *** patchlevel.h.orig	<date here>
	   --- patchlevel.h	<date here>
	   *** 41,43 ***
	   --- 41,44 ---
	   + 	,"MINE001 - my new patch"
	     	,NULL
	     };
	
	(Note changes to line numbers as well as removal of context lines.)
	This will prevent patch from choking if someone has previously
	applied different patches than you.

        History has shown that nobody distributes patches that also
        modify patchlevel.h. Do it yourself. The following perl
        program can be used to add a comment to patchlevel.h:

#!perl
die "Usage: perl -x patchlevel.h comment ..." unless @ARGV;
open PLIN, "patchlevel.h" or die "Couldn't open patchlevel.h : $!";
open PLOUT, ">patchlevel.new" or die "Couldn't write on patchlevel.new : $!";
my $seen=0;
while (<PLIN>) {
    if (/\t,NULL/ and $seen) {
       while (my $c = shift @ARGV){
            print PLOUT qq{\t,"$c"\n};
       }
    }
    $seen++ if /local_patches\[\]/;
    print PLOUT;
}
close PLOUT or die "Couldn't close filehandle writing to patchlevel.new : $!";
close PLIN or die "Couldn't close filehandle reading from patchlevel.h : $!";
close DATA; # needed to allow unlink to work win32.
unlink "patchlevel.bak" or warn "Couldn't unlink patchlevel.bak : $!"
  if -e "patchlevel.bak";
rename "patchlevel.h", "patchlevel.bak" or
  die "Couldn't rename patchlevel.h to patchlevel.bak : $!";
rename "patchlevel.new", "patchlevel.h" or
  die "Couldn't rename patchlevel.new to patchlevel.h : $!";
__END__

Please keep empty lines below so that context diffs of this file do
not ever collect the lines belonging to local_patches() into the same
hunk.

 */

#if !defined(PERL_PATCHLEVEL_H_IMPLICIT) && !defined(LOCAL_PATCH_COUNT)
static const char * const local_patches[] = {
	NULL
	,ACTIVEPERL_LOCAL_PATCHES_ENTRY
        ,"32809 Load 'loadable object' with non-default file extension"
        ,"32728 64-bit fix for Time::Local"
	,NULL
};



/* Initial space prevents this variable from being inserted in config.sh  */
#  define	LOCAL_PATCH_COUNT	\
	((int)(sizeof(local_patches)/sizeof(local_patches[0])-2))

/* the old terms of reference, add them only when explicitly included */
#define PATCHLEVEL		PERL_VERSION
#undef  SUBVERSION		/* OS/390 has a SUBVERSION in a system header */
#define SUBVERSION		PERL_SUBVERSION
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\parser.h ===
/*    parser.h
 *
 *    Copyright (c) 2006, 2007, Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 * 
 * This file defines the layout of the parser object used by the parser
 * and lexer (perly.c, toke,c).
 */

#define YYEMPTY		(-2)

typedef struct {
    YYSTYPE val;    /* semantic value */
    short   state;
    I32     savestack_ix;	/* size of savestack at this state */
    AV	    *comppad; /* value of PL_comppad when this value was created */
#ifdef DEBUGGING
    const char  *name; /* token/rule name for -Dpv */
#endif
} yy_stack_frame;

typedef struct yy_parser {

    /* parser state */

    struct yy_parser *old_parser; /* previous value of PL_parser */
    YYSTYPE	    yylval;	/* value of lookahead symbol, set by yylex() */
    int		    yychar;	/* The lookahead symbol.  */

    /* Number of tokens to shift before error messages enabled.  */
    int		    yyerrstatus;

    int		    stack_size;
    int		    yylen;	/* length of active reduction */
    yy_stack_frame  *stack;	/* base of stack */
    yy_stack_frame  *ps;	/* current stack frame */

    /* lexer state */

    I32		lex_brackets;	/* bracket count */
    I32		lex_casemods;	/* casemod count */
    char	*lex_brackstack;/* what kind of brackets to pop */
    char	*lex_casestack;	/* what kind of case mods in effect */
    U8		lex_defer;	/* state after determined token */
    bool	lex_dojoin;	/* doing an array interpolation */
    U8		lex_expect;	/* expect after determined token */
    U8		expect;		/* how to interpret ambiguous tokens */
    I32		lex_formbrack;	/* bracket count at outer format level */
    OP		*lex_inpat;	/* in pattern $) and $| are special */
    OP		*lex_op;	/* extra info to pass back on op */
    SV		*lex_repl;	/* runtime replacement from s/// */
    U16		lex_inwhat;	/* what kind of quoting are we in */
    OPCODE	last_lop_op;	/* last list operator */
    I32		lex_starts;	/* how many interps done on level */
    SV		*lex_stuff;	/* runtime pattern from m// or s/// */
    I32		multi_start;	/* 1st line of multi-line string */
    I32		multi_end;	/* last line of multi-line string */
    char	multi_open;	/* delimiter of said string */
    char	multi_close;	/* delimiter of said string */
    char	pending_ident;	/* pending identifier lookup */
    bool	preambled;
    /* XXX I32 space */
    SUBLEXINFO	sublex_info;
    SV		*linestr;	/* current chunk of src text */
    char	*bufptr;	
    char	*oldbufptr;	
    char	*oldoldbufptr;	
    char	*bufend;	
    char	*linestart;	/* beginning of most recently read line */
    char	*last_uni;	/* position of last named-unary op */
    char	*last_lop;	/* position of last list operator */
    line_t	copline;	/* current line number */
    U16		in_my;		/* we're compiling a "my"/"our" declaration */
    U8		lex_state;	/* next token is determined */
    U8		error_count;	/* how many compile errors so far, max 10 */
    HV		*in_my_stash;	/* declared class of this "my" declaration */
    PerlIO	*rsfp;		/* current source file pointer */
    AV		*rsfp_filters;	/* holds chain of active source filters */

#ifdef PERL_MAD
    SV		*endwhite;
    I32		faketokens;
    I32		lasttoke;
    SV		*nextwhite;
    I32		realtokenstart;
    SV		*skipwhite;
    SV		*thisclose;
    MADPROP *	thismad;
    SV		*thisopen;
    SV		*thisstuff;
    SV		*thistoken;
    SV		*thiswhite;

/* What we know when we're in LEX_KNOWNEXT state. */
    NEXTTOKE	nexttoke[5];	/* value of next token, if any */
    I32		curforce;
#else
    YYSTYPE	nextval[5];	/* value of next token, if any */
    I32		nexttype[5];	/* type of next token */
    I32		nexttoke;
#endif

    COP		*saved_curcop;	/* the previous PL_curcop */
    char	tokenbuf[256];

} yy_parser;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perlhost.h ===
/* perlhost.h
 *
 * (c) 1999 Microsoft Corporation. All rights reserved.
 * Portions (c) 1999 ActiveState Tool Corp, http://www.ActiveState.com/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

#ifndef UNDER_CE
#define CHECK_HOST_INTERP
#endif

#ifndef ___PerlHost_H___
#define ___PerlHost_H___

#ifndef UNDER_CE
#include <signal.h>
#endif
#include "iperlsys.h"
#include "vmem.h"
#include "vdir.h"

#ifndef WC_NO_BEST_FIT_CHARS
#  define WC_NO_BEST_FIT_CHARS 0x00000400
#endif

START_EXTERN_C
extern char *		g_win32_get_privlib(const char *pl);
extern char *		g_win32_get_sitelib(const char *pl);
extern char *		g_win32_get_vendorlib(const char *pl);
extern char *		g_getlogin(void);
END_EXTERN_C

class CPerlHost
{
public:
    /* Constructors */
    CPerlHost(void);
    CPerlHost(struct IPerlMem** ppMem, struct IPerlMem** ppMemShared,
		 struct IPerlMem** ppMemParse, struct IPerlEnv** ppEnv,
		 struct IPerlStdIO** ppStdIO, struct IPerlLIO** ppLIO,
		 struct IPerlDir** ppDir, struct IPerlSock** ppSock,
		 struct IPerlProc** ppProc);
    CPerlHost(CPerlHost& host);
    ~CPerlHost(void);

    static CPerlHost* IPerlMem2Host(struct IPerlMem* piPerl);
    static CPerlHost* IPerlMemShared2Host(struct IPerlMem* piPerl);
    static CPerlHost* IPerlMemParse2Host(struct IPerlMem* piPerl);
    static CPerlHost* IPerlEnv2Host(struct IPerlEnv* piPerl);
    static CPerlHost* IPerlStdIO2Host(struct IPerlStdIO* piPerl);
    static CPerlHost* IPerlLIO2Host(struct IPerlLIO* piPerl);
    static CPerlHost* IPerlDir2Host(struct IPerlDir* piPerl);
    static CPerlHost* IPerlSock2Host(struct IPerlSock* piPerl);
    static CPerlHost* IPerlProc2Host(struct IPerlProc* piPerl);

    BOOL PerlCreate(void);
    int PerlParse(int argc, char** argv, char** env);
    int PerlRun(void);
    void PerlDestroy(void);

/* IPerlMem */
    /* Locks provided but should be unnecessary as this is private pool */
    inline void* Malloc(size_t size) { return m_pVMem->Malloc(size); };
    inline void* Realloc(void* ptr, size_t size) { return m_pVMem->Realloc(ptr, size); };
    inline void Free(void* ptr) { m_pVMem->Free(ptr); };
    inline void* Calloc(size_t num, size_t size)
    {
	size_t count = num*size;
	void* lpVoid = Malloc(count);
	if (lpVoid)
	    ZeroMemory(lpVoid, count);
	return lpVoid;
    };
    inline void GetLock(void) { m_pVMem->GetLock(); };
    inline void FreeLock(void) { m_pVMem->FreeLock(); };
    inline int IsLocked(void) { return m_pVMem->IsLocked(); };

/* IPerlMemShared */
    /* Locks used to serialize access to the pool */
    inline void GetLockShared(void) { m_pVMemShared->GetLock(); };
    inline void FreeLockShared(void) { m_pVMemShared->FreeLock(); };
    inline int IsLockedShared(void) { return m_pVMemShared->IsLocked(); };
    inline void* MallocShared(size_t size)
    {
	void *result;
	GetLockShared();
	result = m_pVMemShared->Malloc(size);
	FreeLockShared();
	return result;
    };
    inline void* ReallocShared(void* ptr, size_t size)
    {
	void *result;
	GetLockShared();
	result = m_pVMemShared->Realloc(ptr, size);
	FreeLockShared();
	return result;
    };
    inline void FreeShared(void* ptr)
    {
	GetLockShared();
	m_pVMemShared->Free(ptr);
	FreeLockShared();
    };
    inline void* CallocShared(size_t num, size_t size)
    {
	size_t count = num*size;
	void* lpVoid = MallocShared(count);
	if (lpVoid)
	    ZeroMemory(lpVoid, count);
	return lpVoid;
    };

/* IPerlMemParse */
    /* Assume something else is using locks to mangaging serialize
       on a batch basis
     */
    inline void GetLockParse(void) { m_pVMemParse->GetLock(); };
    inline void FreeLockParse(void) { m_pVMemParse->FreeLock(); };
    inline int IsLockedParse(void) { return m_pVMemParse->IsLocked(); };
    inline void* MallocParse(size_t size) { return m_pVMemParse->Malloc(size); };
    inline void* ReallocParse(void* ptr, size_t size) { return m_pVMemParse->Realloc(ptr, size); };
    inline void FreeParse(void* ptr) { m_pVMemParse->Free(ptr); };
    inline void* CallocParse(size_t num, size_t size)
    {
	size_t count = num*size;
	void* lpVoid = MallocParse(count);
	if (lpVoid)
	    ZeroMemory(lpVoid, count);
	return lpVoid;
    };

/* IPerlEnv */
    char *Getenv(const char *varname);
    int Putenv(const char *envstring);
    inline char *Getenv(const char *varname, unsigned long *len)
    {
	*len = 0;
	char *e = Getenv(varname);
	if (e)
	    *len = strlen(e);
	return e;
    }
    void* CreateChildEnv(void) { return CreateLocalEnvironmentStrings(*m_pvDir); };
    void FreeChildEnv(void* pStr) { FreeLocalEnvironmentStrings((char*)pStr); };
    char* GetChildDir(void);
    void FreeChildDir(char* pStr);
    void Reset(void);
    void Clearenv(void);

    inline LPSTR GetIndex(DWORD &dwIndex)
    {
	if(dwIndex < m_dwEnvCount)
	{
	    ++dwIndex;
	    return m_lppEnvList[dwIndex-1];
	}
	return NULL;
    };

protected:
    LPSTR Find(LPCSTR lpStr);
    void Add(LPCSTR lpStr);

    LPSTR CreateLocalEnvironmentStrings(VDir &vDir);
    void FreeLocalEnvironmentStrings(LPSTR lpStr);
    LPSTR* Lookup(LPCSTR lpStr);
    DWORD CalculateEnvironmentSpace(void);

public:

/* IPerlDIR */
    virtual int Chdir(const char *dirname);

/* IPerllProc */
    void Abort(void);
    void Exit(int status);
    void _Exit(int status);
    int Execl(const char *cmdname, const char *arg0, const char *arg1, const char *arg2, const char *arg3);
    int Execv(const char *cmdname, const char *const *argv);
    int Execvp(const char *cmdname, const char *const *argv);

    inline VMem* GetMemShared(void) { m_pVMemShared->AddRef(); return m_pVMemShared; };
    inline VMem* GetMemParse(void) { m_pVMemParse->AddRef(); return m_pVMemParse; };
    inline VDir* GetDir(void) { return m_pvDir; };

public:

    struct IPerlMem	    m_hostperlMem;
    struct IPerlMem	    m_hostperlMemShared;
    struct IPerlMem	    m_hostperlMemParse;
    struct IPerlEnv	    m_hostperlEnv;
    struct IPerlStdIO	    m_hostperlStdIO;
    struct IPerlLIO	    m_hostperlLIO;
    struct IPerlDir	    m_hostperlDir;
    struct IPerlSock	    m_hostperlSock;
    struct IPerlProc	    m_hostperlProc;

    struct IPerlMem*	    m_pHostperlMem;
    struct IPerlMem*	    m_pHostperlMemShared;
    struct IPerlMem*	    m_pHostperlMemParse;
    struct IPerlEnv*	    m_pHostperlEnv;
    struct IPerlStdIO*	    m_pHostperlStdIO;
    struct IPerlLIO*	    m_pHostperlLIO;
    struct IPerlDir*	    m_pHostperlDir;
    struct IPerlSock*	    m_pHostperlSock;
    struct IPerlProc*	    m_pHostperlProc;

    inline char* MapPathA(const char *pInName) { return m_pvDir->MapPathA(pInName); };
    inline WCHAR* MapPathW(const WCHAR *pInName) { return m_pvDir->MapPathW(pInName); };
protected:

    VDir*   m_pvDir;
    VMem*   m_pVMem;
    VMem*   m_pVMemShared;
    VMem*   m_pVMemParse;

    DWORD   m_dwEnvCount;
    LPSTR*  m_lppEnvList;
    BOOL    m_bTopLevel;	// is this a toplevel host?
    static long num_hosts;
public:
    inline  int LastHost(void) { return num_hosts == 1L; };
    struct interpreter *host_perl;
};

long CPerlHost::num_hosts = 0L;

extern "C" void win32_checkTLS(struct interpreter *host_perl);

#define STRUCT2RAWPTR(x, y) (CPerlHost*)(((LPBYTE)x)-offsetof(CPerlHost, y))
#ifdef CHECK_HOST_INTERP
inline CPerlHost* CheckInterp(CPerlHost *host)
{
 win32_checkTLS(host->host_perl);
 return host;
}
#define STRUCT2PTR(x, y) CheckInterp(STRUCT2RAWPTR(x, y))
#else
#define STRUCT2PTR(x, y) STRUCT2RAWPTR(x, y)
#endif

inline CPerlHost* IPerlMem2Host(struct IPerlMem* piPerl)
{
    return STRUCT2RAWPTR(piPerl, m_hostperlMem);
}

inline CPerlHost* IPerlMemShared2Host(struct IPerlMem* piPerl)
{
    return STRUCT2RAWPTR(piPerl, m_hostperlMemShared);
}

inline CPerlHost* IPerlMemParse2Host(struct IPerlMem* piPerl)
{
    return STRUCT2RAWPTR(piPerl, m_hostperlMemParse);
}

inline CPerlHost* IPerlEnv2Host(struct IPerlEnv* piPerl)
{
    return STRUCT2PTR(piPerl, m_hostperlEnv);
}

inline CPerlHost* IPerlStdIO2Host(struct IPerlStdIO* piPerl)
{
    return STRUCT2PTR(piPerl, m_hostperlStdIO);
}

inline CPerlHost* IPerlLIO2Host(struct IPerlLIO* piPerl)
{
    return STRUCT2PTR(piPerl, m_hostperlLIO);
}

inline CPerlHost* IPerlDir2Host(struct IPerlDir* piPerl)
{
    return STRUCT2PTR(piPerl, m_hostperlDir);
}

inline CPerlHost* IPerlSock2Host(struct IPerlSock* piPerl)
{
    return STRUCT2PTR(piPerl, m_hostperlSock);
}

inline CPerlHost* IPerlProc2Host(struct IPerlProc* piPerl)
{
    return STRUCT2PTR(piPerl, m_hostperlProc);
}



#undef IPERL2HOST
#define IPERL2HOST(x) IPerlMem2Host(x)

/* IPerlMem */
void*
PerlMemMalloc(struct IPerlMem* piPerl, size_t size)
{
    return IPERL2HOST(piPerl)->Malloc(size);
}
void*
PerlMemRealloc(struct IPerlMem* piPerl, void* ptr, size_t size)
{
    return IPERL2HOST(piPerl)->Realloc(ptr, size);
}
void
PerlMemFree(struct IPerlMem* piPerl, void* ptr)
{
    IPERL2HOST(piPerl)->Free(ptr);
}
void*
PerlMemCalloc(struct IPerlMem* piPerl, size_t num, size_t size)
{
    return IPERL2HOST(piPerl)->Calloc(num, size);
}

void
PerlMemGetLock(struct IPerlMem* piPerl)
{
    IPERL2HOST(piPerl)->GetLock();
}

void
PerlMemFreeLock(struct IPerlMem* piPerl)
{
    IPERL2HOST(piPerl)->FreeLock();
}

int
PerlMemIsLocked(struct IPerlMem* piPerl)
{
    return IPERL2HOST(piPerl)->IsLocked();
}

struct IPerlMem perlMem =
{
    PerlMemMalloc,
    PerlMemRealloc,
    PerlMemFree,
    PerlMemCalloc,
    PerlMemGetLock,
    PerlMemFreeLock,
    PerlMemIsLocked,
};

#undef IPERL2HOST
#define IPERL2HOST(x) IPerlMemShared2Host(x)

/* IPerlMemShared */
void*
PerlMemSharedMalloc(struct IPerlMem* piPerl, size_t size)
{
    return IPERL2HOST(piPerl)->MallocShared(size);
}
void*
PerlMemSharedRealloc(struct IPerlMem* piPerl, void* ptr, size_t size)
{
    return IPERL2HOST(piPerl)->ReallocShared(ptr, size);
}
void
PerlMemSharedFree(struct IPerlMem* piPerl, void* ptr)
{
    IPERL2HOST(piPerl)->FreeShared(ptr);
}
void*
PerlMemSharedCalloc(struct IPerlMem* piPerl, size_t num, size_t size)
{
    return IPERL2HOST(piPerl)->CallocShared(num, size);
}

void
PerlMemSharedGetLock(struct IPerlMem* piPerl)
{
    IPERL2HOST(piPerl)->GetLockShared();
}

void
PerlMemSharedFreeLock(struct IPerlMem* piPerl)
{
    IPERL2HOST(piPerl)->FreeLockShared();
}

int
PerlMemSharedIsLocked(struct IPerlMem* piPerl)
{
    return IPERL2HOST(piPerl)->IsLockedShared();
}

struct IPerlMem perlMemShared =
{
    PerlMemSharedMalloc,
    PerlMemSharedRealloc,
    PerlMemSharedFree,
    PerlMemSharedCalloc,
    PerlMemSharedGetLock,
    PerlMemSharedFreeLock,
    PerlMemSharedIsLocked,
};

#undef IPERL2HOST
#define IPERL2HOST(x) IPerlMemParse2Host(x)

/* IPerlMemParse */
void*
PerlMemParseMalloc(struct IPerlMem* piPerl, size_t size)
{
    return IPERL2HOST(piPerl)->MallocParse(size);
}
void*
PerlMemParseRealloc(struct IPerlMem* piPerl, void* ptr, size_t size)
{
    return IPERL2HOST(piPerl)->ReallocParse(ptr, size);
}
void
PerlMemParseFree(struct IPerlMem* piPerl, void* ptr)
{
    IPERL2HOST(piPerl)->FreeParse(ptr);
}
void*
PerlMemParseCalloc(struct IPerlMem* piPerl, size_t num, size_t size)
{
    return IPERL2HOST(piPerl)->CallocParse(num, size);
}

void
PerlMemParseGetLock(struct IPerlMem* piPerl)
{
    IPERL2HOST(piPerl)->GetLockParse();
}

void
PerlMemParseFreeLock(struct IPerlMem* piPerl)
{
    IPERL2HOST(piPerl)->FreeLockParse();
}

int
PerlMemParseIsLocked(struct IPerlMem* piPerl)
{
    return IPERL2HOST(piPerl)->IsLockedParse();
}

struct IPerlMem perlMemParse =
{
    PerlMemParseMalloc,
    PerlMemParseRealloc,
    PerlMemParseFree,
    PerlMemParseCalloc,
    PerlMemParseGetLock,
    PerlMemParseFreeLock,
    PerlMemParseIsLocked,
};


#undef IPERL2HOST
#define IPERL2HOST(x) IPerlEnv2Host(x)

/* IPerlEnv */
char*
PerlEnvGetenv(struct IPerlEnv* piPerl, const char *varname)
{
    return IPERL2HOST(piPerl)->Getenv(varname);
};

int
PerlEnvPutenv(struct IPerlEnv* piPerl, const char *envstring)
{
    return IPERL2HOST(piPerl)->Putenv(envstring);
};

char*
PerlEnvGetenv_len(struct IPerlEnv* piPerl, const char* varname, unsigned long* len)
{
    return IPERL2HOST(piPerl)->Getenv(varname, len);
}

int
PerlEnvUname(struct IPerlEnv* piPerl, struct utsname *name)
{
    return win32_uname(name);
}

void
PerlEnvClearenv(struct IPerlEnv* piPerl)
{
    IPERL2HOST(piPerl)->Clearenv();
}

void*
PerlEnvGetChildenv(struct IPerlEnv* piPerl)
{
    return IPERL2HOST(piPerl)->CreateChildEnv();
}

void
PerlEnvFreeChildenv(struct IPerlEnv* piPerl, void* childEnv)
{
    IPERL2HOST(piPerl)->FreeChildEnv(childEnv);
}

char*
PerlEnvGetChilddir(struct IPerlEnv* piPerl)
{
    return IPERL2HOST(piPerl)->GetChildDir();
}

void
PerlEnvFreeChilddir(struct IPerlEnv* piPerl, char* childDir)
{
    IPERL2HOST(piPerl)->FreeChildDir(childDir);
}

unsigned long
PerlEnvOsId(struct IPerlEnv* piPerl)
{
    return win32_os_id();
}

char*
PerlEnvLibPath(struct IPerlEnv* piPerl, const char *pl)
{
    return g_win32_get_privlib(pl);
}

char*
PerlEnvSiteLibPath(struct IPerlEnv* piPerl, const char *pl)
{
    return g_win32_get_sitelib(pl);
}

char*
PerlEnvVendorLibPath(struct IPerlEnv* piPerl, const char *pl)
{
    return g_win32_get_vendorlib(pl);
}

void
PerlEnvGetChildIO(struct IPerlEnv* piPerl, child_IO_table* ptr)
{
    win32_get_child_IO(ptr);
}

struct IPerlEnv perlEnv =
{
    PerlEnvGetenv,
    PerlEnvPutenv,
    PerlEnvGetenv_len,
    PerlEnvUname,
    PerlEnvClearenv,
    PerlEnvGetChildenv,
    PerlEnvFreeChildenv,
    PerlEnvGetChilddir,
    PerlEnvFreeChilddir,
    PerlEnvOsId,
    PerlEnvLibPath,
    PerlEnvSiteLibPath,
    PerlEnvVendorLibPath,
    PerlEnvGetChildIO,
};

#undef IPERL2HOST
#define IPERL2HOST(x) IPerlStdIO2Host(x)

/* PerlStdIO */
FILE*
PerlStdIOStdin(struct IPerlStdIO* piPerl)
{
    return win32_stdin();
}

FILE*
PerlStdIOStdout(struct IPerlStdIO* piPerl)
{
    return win32_stdout();
}

FILE*
PerlStdIOStderr(struct IPerlStdIO* piPerl)
{
    return win32_stderr();
}

FILE*
PerlStdIOOpen(struct IPerlStdIO* piPerl, const char *path, const char *mode)
{
    return win32_fopen(path, mode);
}

int
PerlStdIOClose(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_fclose((pf));
}

int
PerlStdIOEof(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_feof(pf);
}

int
PerlStdIOError(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_ferror(pf);
}

void
PerlStdIOClearerr(struct IPerlStdIO* piPerl, FILE* pf)
{
    win32_clearerr(pf);
}

int
PerlStdIOGetc(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_getc(pf);
}

char*
PerlStdIOGetBase(struct IPerlStdIO* piPerl, FILE* pf)
{
#ifdef FILE_base
    FILE *f = pf;
    return FILE_base(f);
#else
    return Nullch;
#endif
}

int
PerlStdIOGetBufsiz(struct IPerlStdIO* piPerl, FILE* pf)
{
#ifdef FILE_bufsiz
    FILE *f = pf;
    return FILE_bufsiz(f);
#else
    return (-1);
#endif
}

int
PerlStdIOGetCnt(struct IPerlStdIO* piPerl, FILE* pf)
{
#ifdef USE_STDIO_PTR
    FILE *f = pf;
    return FILE_cnt(f);
#else
    return (-1);
#endif
}

char*
PerlStdIOGetPtr(struct IPerlStdIO* piPerl, FILE* pf)
{
#ifdef USE_STDIO_PTR
    FILE *f = pf;
    return FILE_ptr(f);
#else
    return Nullch;
#endif
}

char*
PerlStdIOGets(struct IPerlStdIO* piPerl, FILE* pf, char* s, int n)
{
    return win32_fgets(s, n, pf);
}

int
PerlStdIOPutc(struct IPerlStdIO* piPerl, FILE* pf, int c)
{
    return win32_fputc(c, pf);
}

int
PerlStdIOPuts(struct IPerlStdIO* piPerl, FILE* pf, const char *s)
{
    return win32_fputs(s, pf);
}

int
PerlStdIOFlush(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_fflush(pf);
}

int
PerlStdIOUngetc(struct IPerlStdIO* piPerl,int c, FILE* pf)
{
    return win32_ungetc(c, pf);
}

int
PerlStdIOFileno(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_fileno(pf);
}

FILE*
PerlStdIOFdopen(struct IPerlStdIO* piPerl, int fd, const char *mode)
{
    return win32_fdopen(fd, mode);
}

FILE*
PerlStdIOReopen(struct IPerlStdIO* piPerl, const char*path, const char*mode, FILE* pf)
{
    return win32_freopen(path, mode, (FILE*)pf);
}

SSize_t
PerlStdIORead(struct IPerlStdIO* piPerl, void *buffer, Size_t size, Size_t count, FILE* pf)
{
    return win32_fread(buffer, size, count, pf);
}

SSize_t
PerlStdIOWrite(struct IPerlStdIO* piPerl, const void *buffer, Size_t size, Size_t count, FILE* pf)
{
    return win32_fwrite(buffer, size, count, pf);
}

void
PerlStdIOSetBuf(struct IPerlStdIO* piPerl, FILE* pf, char* buffer)
{
    win32_setbuf(pf, buffer);
}

int
PerlStdIOSetVBuf(struct IPerlStdIO* piPerl, FILE* pf, char* buffer, int type, Size_t size)
{
    return win32_setvbuf(pf, buffer, type, size);
}

void
PerlStdIOSetCnt(struct IPerlStdIO* piPerl, FILE* pf, int n)
{
#ifdef STDIO_CNT_LVALUE
    FILE *f = pf;
    FILE_cnt(f) = n;
#endif
}

void
PerlStdIOSetPtr(struct IPerlStdIO* piPerl, FILE* pf, char * ptr)
{
#ifdef STDIO_PTR_LVALUE
    FILE *f = pf;
    FILE_ptr(f) = ptr;
#endif
}

void
PerlStdIOSetlinebuf(struct IPerlStdIO* piPerl, FILE* pf)
{
    win32_setvbuf(pf, NULL, _IOLBF, 0);
}

int
PerlStdIOPrintf(struct IPerlStdIO* piPerl, FILE* pf, const char *format,...)
{
    va_list(arglist);
    va_start(arglist, format);
    return win32_vfprintf(pf, format, arglist);
}

int
PerlStdIOVprintf(struct IPerlStdIO* piPerl, FILE* pf, const char *format, va_list arglist)
{
    return win32_vfprintf(pf, format, arglist);
}

Off_t
PerlStdIOTell(struct IPerlStdIO* piPerl, FILE* pf)
{
    return win32_ftell(pf);
}

int
PerlStdIOSeek(struct IPerlStdIO* piPerl, FILE* pf, Off_t offset, int origin)
{
    return win32_fseek(pf, offset, origin);
}

void
PerlStdIORewind(struct IPerlStdIO* piPerl, FILE* pf)
{
    win32_rewind(pf);
}

FILE*
PerlStdIOTmpfile(struct IPerlStdIO* piPerl)
{
    return win32_tmpfile();
}

int
PerlStdIOGetpos(struct IPerlStdIO* piPerl, FILE* pf, Fpos_t *p)
{
    return win32_fgetpos(pf, p);
}

int
PerlStdIOSetpos(struct IPerlStdIO* piPerl, FILE* pf, const Fpos_t *p)
{
    return win32_fsetpos(pf, p);
}
void
PerlStdIOInit(struct IPerlStdIO* piPerl)
{
}

void
PerlStdIOInitOSExtras(struct IPerlStdIO* piPerl)
{
    Perl_init_os_extras();
}

int
PerlStdIOOpenOSfhandle(struct IPerlStdIO* piPerl, intptr_t osfhandle, int flags)
{
    return win32_open_osfhandle(osfhandle, flags);
}

intptr_t
PerlStdIOGetOSfhandle(struct IPerlStdIO* piPerl, int filenum)
{
    return win32_get_osfhandle(filenum);
}

FILE*
PerlStdIOFdupopen(struct IPerlStdIO* piPerl, FILE* pf)
{
#ifndef UNDER_CE
    FILE* pfdup;
    fpos_t pos;
    char mode[3];
    int fileno = win32_dup(win32_fileno(pf));

    /* open the file in the same mode */
#ifdef __BORLANDC__
    if((pf)->flags & _F_READ) {
	mode[0] = 'r';
	mode[1] = 0;
    }
    else if((pf)->flags & _F_WRIT) {
	mode[0] = 'a';
	mode[1] = 0;
    }
    else if((pf)->flags & _F_RDWR) {
	mode[0] = 'r';
	mode[1] = '+';
	mode[2] = 0;
    }
#else
    if((pf)->_flag & _IOREAD) {
	mode[0] = 'r';
	mode[1] = 0;
    }
    else if((pf)->_flag & _IOWRT) {
	mode[0] = 'a';
	mode[1] = 0;
    }
    else if((pf)->_flag & _IORW) {
	mode[0] = 'r';
	mode[1] = '+';
	mode[2] = 0;
    }
#endif

    /* it appears that the binmode is attached to the
     * file descriptor so binmode files will be handled
     * correctly
     */
    pfdup = win32_fdopen(fileno, mode);

    /* move the file pointer to the same position */
    if (!fgetpos(pf, &pos)) {
	fsetpos(pfdup, &pos);
    }
    return pfdup;
#else
    return 0;
#endif
}

struct IPerlStdIO perlStdIO =
{
    PerlStdIOStdin,
    PerlStdIOStdout,
    PerlStdIOStderr,
    PerlStdIOOpen,
    PerlStdIOClose,
    PerlStdIOEof,
    PerlStdIOError,
    PerlStdIOClearerr,
    PerlStdIOGetc,
    PerlStdIOGetBase,
    PerlStdIOGetBufsiz,
    PerlStdIOGetCnt,
    PerlStdIOGetPtr,
    PerlStdIOGets,
    PerlStdIOPutc,
    PerlStdIOPuts,
    PerlStdIOFlush,
    PerlStdIOUngetc,
    PerlStdIOFileno,
    PerlStdIOFdopen,
    PerlStdIOReopen,
    PerlStdIORead,
    PerlStdIOWrite,
    PerlStdIOSetBuf,
    PerlStdIOSetVBuf,
    PerlStdIOSetCnt,
    PerlStdIOSetPtr,
    PerlStdIOSetlinebuf,
    PerlStdIOPrintf,
    PerlStdIOVprintf,
    PerlStdIOTell,
    PerlStdIOSeek,
    PerlStdIORewind,
    PerlStdIOTmpfile,
    PerlStdIOGetpos,
    PerlStdIOSetpos,
    PerlStdIOInit,
    PerlStdIOInitOSExtras,
    PerlStdIOFdupopen,
};


#undef IPERL2HOST
#define IPERL2HOST(x) IPerlLIO2Host(x)

/* IPerlLIO */
int
PerlLIOAccess(struct IPerlLIO* piPerl, const char *path, int mode)
{
    return win32_access(path, mode);
}

int
PerlLIOChmod(struct IPerlLIO* piPerl, const char *filename, int pmode)
{
    return win32_chmod(filename, pmode);
}

int
PerlLIOChown(struct IPerlLIO* piPerl, const char *filename, uid_t owner, gid_t group)
{
    return chown(filename, owner, group);
}

int
PerlLIOChsize(struct IPerlLIO* piPerl, int handle, Off_t size)
{
    return win32_chsize(handle, size);
}

int
PerlLIOClose(struct IPerlLIO* piPerl, int handle)
{
    return win32_close(handle);
}

int
PerlLIODup(struct IPerlLIO* piPerl, int handle)
{
    return win32_dup(handle);
}

int
PerlLIODup2(struct IPerlLIO* piPerl, int handle1, int handle2)
{
    return win32_dup2(handle1, handle2);
}

int
PerlLIOFlock(struct IPerlLIO* piPerl, int fd, int oper)
{
    return win32_flock(fd, oper);
}

int
PerlLIOFileStat(struct IPerlLIO* piPerl, int handle, Stat_t *buffer)
{
    return win32_fstat(handle, buffer);
}

int
PerlLIOIOCtl(struct IPerlLIO* piPerl, int i, unsigned int u, char *data)
{
    u_long u_long_arg;
    int retval;

    /* mauke says using memcpy avoids alignment issues */
    memcpy(&u_long_arg, data, sizeof u_long_arg); 
    retval = win32_ioctlsocket((SOCKET)i, (long)u, &u_long_arg);
    memcpy(data, &u_long_arg, sizeof u_long_arg);
    return retval;
}

int
PerlLIOIsatty(struct IPerlLIO* piPerl, int fd)
{
    return isatty(fd);
}

int
PerlLIOLink(struct IPerlLIO* piPerl, const char*oldname, const char *newname)
{
    return win32_link(oldname, newname);
}

Off_t
PerlLIOLseek(struct IPerlLIO* piPerl, int handle, Off_t offset, int origin)
{
    return win32_lseek(handle, offset, origin);
}

int
PerlLIOLstat(struct IPerlLIO* piPerl, const char *path, Stat_t *buffer)
{
    return win32_stat(path, buffer);
}

char*
PerlLIOMktemp(struct IPerlLIO* piPerl, char *Template)
{
    return mktemp(Template);
}

int
PerlLIOOpen(struct IPerlLIO* piPerl, const char *filename, int oflag)
{
    return win32_open(filename, oflag);
}

int
PerlLIOOpen3(struct IPerlLIO* piPerl, const char *filename, int oflag, int pmode)
{
    return win32_open(filename, oflag, pmode);
}

int
PerlLIORead(struct IPerlLIO* piPerl, int handle, void *buffer, unsigned int count)
{
    return win32_read(handle, buffer, count);
}

int
PerlLIORename(struct IPerlLIO* piPerl, const char *OldFileName, const char *newname)
{
    return win32_rename(OldFileName, newname);
}

int
PerlLIOSetmode(struct IPerlLIO* piPerl, int handle, int mode)
{
    return win32_setmode(handle, mode);
}

int
PerlLIONameStat(struct IPerlLIO* piPerl, const char *path, Stat_t *buffer)
{
    return win32_stat(path, buffer);
}

char*
PerlLIOTmpnam(struct IPerlLIO* piPerl, char *string)
{
    return tmpnam(string);
}

int
PerlLIOUmask(struct IPerlLIO* piPerl, int pmode)
{
    return umask(pmode);
}

int
PerlLIOUnlink(struct IPerlLIO* piPerl, const char *filename)
{
    return win32_unlink(filename);
}

int
PerlLIOUtime(struct IPerlLIO* piPerl, const char *filename, struct utimbuf *times)
{
    return win32_utime(filename, times);
}

int
PerlLIOWrite(struct IPerlLIO* piPerl, int handle, const void *buffer, unsigned int count)
{
    return win32_write(handle, buffer, count);
}

struct IPerlLIO perlLIO =
{
    PerlLIOAccess,
    PerlLIOChmod,
    PerlLIOChown,
    PerlLIOChsize,
    PerlLIOClose,
    PerlLIODup,
    PerlLIODup2,
    PerlLIOFlock,
    PerlLIOFileStat,
    PerlLIOIOCtl,
    PerlLIOIsatty,
    PerlLIOLink,
    PerlLIOLseek,
    PerlLIOLstat,
    PerlLIOMktemp,
    PerlLIOOpen,
    PerlLIOOpen3,
    PerlLIORead,
    PerlLIORename,
    PerlLIOSetmode,
    PerlLIONameStat,
    PerlLIOTmpnam,
    PerlLIOUmask,
    PerlLIOUnlink,
    PerlLIOUtime,
    PerlLIOWrite,
};


#undef IPERL2HOST
#define IPERL2HOST(x) IPerlDir2Host(x)

/* IPerlDIR */
int
PerlDirMakedir(struct IPerlDir* piPerl, const char *dirname, int mode)
{
    return win32_mkdir(dirname, mode);
}

int
PerlDirChdir(struct IPerlDir* piPerl, const char *dirname)
{
    return IPERL2HOST(piPerl)->Chdir(dirname);
}

int
PerlDirRmdir(struct IPerlDir* piPerl, const char *dirname)
{
    return win32_rmdir(dirname);
}

int
PerlDirClose(struct IPerlDir* piPerl, DIR *dirp)
{
    return win32_closedir(dirp);
}

DIR*
PerlDirOpen(struct IPerlDir* piPerl, const char *filename)
{
    return win32_opendir(filename);
}

struct direct *
PerlDirRead(struct IPerlDir* piPerl, DIR *dirp)
{
    return win32_readdir(dirp);
}

void
PerlDirRewind(struct IPerlDir* piPerl, DIR *dirp)
{
    win32_rewinddir(dirp);
}

void
PerlDirSeek(struct IPerlDir* piPerl, DIR *dirp, long loc)
{
    win32_seekdir(dirp, loc);
}

long
PerlDirTell(struct IPerlDir* piPerl, DIR *dirp)
{
    return win32_telldir(dirp);
}

char*
PerlDirMapPathA(struct IPerlDir* piPerl, const char* path)
{
    return IPERL2HOST(piPerl)->MapPathA(path);
}

WCHAR*
PerlDirMapPathW(struct IPerlDir* piPerl, const WCHAR* path)
{
    return IPERL2HOST(piPerl)->MapPathW(path);
}

struct IPerlDir perlDir =
{
    PerlDirMakedir,
    PerlDirChdir,
    PerlDirRmdir,
    PerlDirClose,
    PerlDirOpen,
    PerlDirRead,
    PerlDirRewind,
    PerlDirSeek,
    PerlDirTell,
    PerlDirMapPathA,
    PerlDirMapPathW,
};


/* IPerlSock */
u_long
PerlSockHtonl(struct IPerlSock* piPerl, u_long hostlong)
{
    return win32_htonl(hostlong);
}

u_short
PerlSockHtons(struct IPerlSock* piPerl, u_short hostshort)
{
    return win32_htons(hostshort);
}

u_long
PerlSockNtohl(struct IPerlSock* piPerl, u_long netlong)
{
    return win32_ntohl(netlong);
}

u_short
PerlSockNtohs(struct IPerlSock* piPerl, u_short netshort)
{
    return win32_ntohs(netshort);
}

SOCKET PerlSockAccept(struct IPerlSock* piPerl, SOCKET s, struct sockaddr* addr, int* addrlen)
{
    return win32_accept(s, addr, addrlen);
}

int
PerlSockBind(struct IPerlSock* piPerl, SOCKET s, const struct sockaddr* name, int namelen)
{
    return win32_bind(s, name, namelen);
}

int
PerlSockConnect(struct IPerlSock* piPerl, SOCKET s, const struct sockaddr* name, int namelen)
{
    return win32_connect(s, name, namelen);
}

void
PerlSockEndhostent(struct IPerlSock* piPerl)
{
    win32_endhostent();
}

void
PerlSockEndnetent(struct IPerlSock* piPerl)
{
    win32_endnetent();
}

void
PerlSockEndprotoent(struct IPerlSock* piPerl)
{
    win32_endprotoent();
}

void
PerlSockEndservent(struct IPerlSock* piPerl)
{
    win32_endservent();
}

struct hostent*
PerlSockGethostbyaddr(struct IPerlSock* piPerl, const char* addr, int len, int type)
{
    return win32_gethostbyaddr(addr, len, type);
}

struct hostent*
PerlSockGethostbyname(struct IPerlSock* piPerl, const char* name)
{
    return win32_gethostbyname(name);
}

struct hostent*
PerlSockGethostent(struct IPerlSock* piPerl)
{
    dTHX;
    Perl_croak(aTHX_ "gethostent not implemented!\n");
    return NULL;
}

int
PerlSockGethostname(struct IPerlSock* piPerl, char* name, int namelen)
{
    return win32_gethostname(name, namelen);
}

struct netent *
PerlSockGetnetbyaddr(struct IPerlSock* piPerl, long net, int type)
{
    return win32_getnetbyaddr(net, type);
}

struct netent *
PerlSockGetnetbyname(struct IPerlSock* piPerl, const char *name)
{
    return win32_getnetbyname((char*)name);
}

struct netent *
PerlSockGetnetent(struct IPerlSock* piPerl)
{
    return win32_getnetent();
}

int PerlSockGetpeername(struct IPerlSock* piPerl, SOCKET s, struct sockaddr* name, int* namelen)
{
    return win32_getpeername(s, name, namelen);
}

struct protoent*
PerlSockGetprotobyname(struct IPerlSock* piPerl, const char* name)
{
    return win32_getprotobyname(name);
}

struct protoent*
PerlSockGetprotobynumber(struct IPerlSock* piPerl, int number)
{
    return win32_getprotobynumber(number);
}

struct protoent*
PerlSockGetprotoent(struct IPerlSock* piPerl)
{
    return win32_getprotoent();
}

struct servent*
PerlSockGetservbyname(struct IPerlSock* piPerl, const char* name, const char* proto)
{
    return win32_getservbyname(name, proto);
}

struct servent*
PerlSockGetservbyport(struct IPerlSock* piPerl, int port, const char* proto)
{
    return win32_getservbyport(port, proto);
}

struct servent*
PerlSockGetservent(struct IPerlSock* piPerl)
{
    return win32_getservent();
}

int
PerlSockGetsockname(struct IPerlSock* piPerl, SOCKET s, struct sockaddr* name, int* namelen)
{
    return win32_getsockname(s, name, namelen);
}

int
PerlSockGetsockopt(struct IPerlSock* piPerl, SOCKET s, int level, int optname, char* optval, int* optlen)
{
    return win32_getsockopt(s, level, optname, optval, optlen);
}

unsigned long
PerlSockInetAddr(struct IPerlSock* piPerl, const char* cp)
{
    return win32_inet_addr(cp);
}

char*
PerlSockInetNtoa(struct IPerlSock* piPerl, struct in_addr in)
{
    return win32_inet_ntoa(in);
}

int
PerlSockListen(struct IPerlSock* piPerl, SOCKET s, int backlog)
{
    return win32_listen(s, backlog);
}

int
PerlSockRecv(struct IPerlSock* piPerl, SOCKET s, char* buffer, int len, int flags)
{
    return win32_recv(s, buffer, len, flags);
}

int
PerlSockRecvfrom(struct IPerlSock* piPerl, SOCKET s, char* buffer, int len, int flags, struct sockaddr* from, int* fromlen)
{
    return win32_recvfrom(s, buffer, len, flags, from, fromlen);
}

int
PerlSockSelect(struct IPerlSock* piPerl, int nfds, char* readfds, char* writefds, char* exceptfds, const struct timeval* timeout)
{
    return win32_select(nfds, (Perl_fd_set*)readfds, (Perl_fd_set*)writefds, (Perl_fd_set*)exceptfds, timeout);
}

int
PerlSockSend(struct IPerlSock* piPerl, SOCKET s, const char* buffer, int len, int flags)
{
    return win32_send(s, buffer, len, flags);
}

int
PerlSockSendto(struct IPerlSock* piPerl, SOCKET s, const char* buffer, int len, int flags, const struct sockaddr* to, int tolen)
{
    return win32_sendto(s, buffer, len, flags, to, tolen);
}

void
PerlSockSethostent(struct IPerlSock* piPerl, int stayopen)
{
    win32_sethostent(stayopen);
}

void
PerlSockSetnetent(struct IPerlSock* piPerl, int stayopen)
{
    win32_setnetent(stayopen);
}

void
PerlSockSetprotoent(struct IPerlSock* piPerl, int stayopen)
{
    win32_setprotoent(stayopen);
}

void
PerlSockSetservent(struct IPerlSock* piPerl, int stayopen)
{
    win32_setservent(stayopen);
}

int
PerlSockSetsockopt(struct IPerlSock* piPerl, SOCKET s, int level, int optname, const char* optval, int optlen)
{
    return win32_setsockopt(s, level, optname, optval, optlen);
}

int
PerlSockShutdown(struct IPerlSock* piPerl, SOCKET s, int how)
{
    return win32_shutdown(s, how);
}

SOCKET
PerlSockSocket(struct IPerlSock* piPerl, int af, int type, int protocol)
{
    return win32_socket(af, type, protocol);
}

int
PerlSockSocketpair(struct IPerlSock* piPerl, int domain, int type, int protocol, int* fds)
{
    return Perl_my_socketpair(domain, type, protocol, fds);
}

int
PerlSockClosesocket(struct IPerlSock* piPerl, SOCKET s)
{
    return win32_closesocket(s);
}

int
PerlSockIoctlsocket(struct IPerlSock* piPerl, SOCKET s, long cmd, u_long *argp)
{
    return win32_ioctlsocket(s, cmd, argp);
}

struct IPerlSock perlSock =
{
    PerlSockHtonl,
    PerlSockHtons,
    PerlSockNtohl,
    PerlSockNtohs,
    PerlSockAccept,
    PerlSockBind,
    PerlSockConnect,
    PerlSockEndhostent,
    PerlSockEndnetent,
    PerlSockEndprotoent,
    PerlSockEndservent,
    PerlSockGethostname,
    PerlSockGetpeername,
    PerlSockGethostbyaddr,
    PerlSockGethostbyname,
    PerlSockGethostent,
    PerlSockGetnetbyaddr,
    PerlSockGetnetbyname,
    PerlSockGetnetent,
    PerlSockGetprotobyname,
    PerlSockGetprotobynumber,
    PerlSockGetprotoent,
    PerlSockGetservbyname,
    PerlSockGetservbyport,
    PerlSockGetservent,
    PerlSockGetsockname,
    PerlSockGetsockopt,
    PerlSockInetAddr,
    PerlSockInetNtoa,
    PerlSockListen,
    PerlSockRecv,
    PerlSockRecvfrom,
    PerlSockSelect,
    PerlSockSend,
    PerlSockSendto,
    PerlSockSethostent,
    PerlSockSetnetent,
    PerlSockSetprotoent,
    PerlSockSetservent,
    PerlSockSetsockopt,
    PerlSockShutdown,
    PerlSockSocket,
    PerlSockSocketpair,
    PerlSockClosesocket,
};


/* IPerlProc */

#define EXECF_EXEC 1
#define EXECF_SPAWN 2

void
PerlProcAbort(struct IPerlProc* piPerl)
{
    win32_abort();
}

char *
PerlProcCrypt(struct IPerlProc* piPerl, const char* clear, const char* salt)
{
    return win32_crypt(clear, salt);
}

void
PerlProcExit(struct IPerlProc* piPerl, int status)
{
    exit(status);
}

void
PerlProc_Exit(struct IPerlProc* piPerl, int status)
{
    _exit(status);
}

int
PerlProcExecl(struct IPerlProc* piPerl, const char *cmdname, const char *arg0, const char *arg1, const char *arg2, const char *arg3)
{
    return execl(cmdname, arg0, arg1, arg2, arg3);
}

int
PerlProcExecv(struct IPerlProc* piPerl, const char *cmdname, const char *const *argv)
{
    return win32_execvp(cmdname, argv);
}

int
PerlProcExecvp(struct IPerlProc* piPerl, const char *cmdname, const char *const *argv)
{
    return win32_execvp(cmdname, argv);
}

uid_t
PerlProcGetuid(struct IPerlProc* piPerl)
{
    return getuid();
}

uid_t
PerlProcGeteuid(struct IPerlProc* piPerl)
{
    return geteuid();
}

gid_t
PerlProcGetgid(struct IPerlProc* piPerl)
{
    return getgid();
}

gid_t
PerlProcGetegid(struct IPerlProc* piPerl)
{
    return getegid();
}

char *
PerlProcGetlogin(struct IPerlProc* piPerl)
{
    return g_getlogin();
}

int
PerlProcKill(struct IPerlProc* piPerl, int pid, int sig)
{
    return win32_kill(pid, sig);
}

int
PerlProcKillpg(struct IPerlProc* piPerl, int pid, int sig)
{
    return win32_kill(pid, -sig);
}

int
PerlProcPauseProc(struct IPerlProc* piPerl)
{
    return win32_sleep((32767L << 16) + 32767);
}

PerlIO*
PerlProcPopen(struct IPerlProc* piPerl, const char *command, const char *mode)
{
    dTHX;
    PERL_FLUSHALL_FOR_CHILD;
    return win32_popen(command, mode);
}

PerlIO*
PerlProcPopenList(struct IPerlProc* piPerl, const char *mode, IV narg, SV **args)
{
    dTHX;
    PERL_FLUSHALL_FOR_CHILD;
    return win32_popenlist(mode, narg, args);
}

int
PerlProcPclose(struct IPerlProc* piPerl, PerlIO *stream)
{
    return win32_pclose(stream);
}

int
PerlProcPipe(struct IPerlProc* piPerl, int *phandles)
{
    return win32_pipe(phandles, 512, O_BINARY);
}

int
PerlProcSetuid(struct IPerlProc* piPerl, uid_t u)
{
    return setuid(u);
}

int
PerlProcSetgid(struct IPerlProc* piPerl, gid_t g)
{
    return setgid(g);
}

int
PerlProcSleep(struct IPerlProc* piPerl, unsigned int s)
{
    return win32_sleep(s);
}

int
PerlProcTimes(struct IPerlProc* piPerl, struct tms *timebuf)
{
    return win32_times(timebuf);
}

int
PerlProcWait(struct IPerlProc* piPerl, int *status)
{
    return win32_wait(status);
}

int
PerlProcWaitpid(struct IPerlProc* piPerl, int pid, int *status, int flags)
{
    return win32_waitpid(pid, status, flags);
}

Sighandler_t
PerlProcSignal(struct IPerlProc* piPerl, int sig, Sighandler_t subcode)
{
    return win32_signal(sig, subcode);
}

int
PerlProcGetTimeOfDay(struct IPerlProc* piPerl, struct timeval *t, void *z)
{
    return win32_gettimeofday(t, z);
}

#ifdef USE_ITHREADS
static THREAD_RET_TYPE
win32_start_child(LPVOID arg)
{
    PerlInterpreter *my_perl = (PerlInterpreter*)arg;
    GV *tmpgv;
    int status;
    HWND parent_message_hwnd;
#ifdef PERL_SYNC_FORK
    static long sync_fork_id = 0;
    long id = ++sync_fork_id;
#endif


    PERL_SET_THX(my_perl);
    win32_checkTLS(my_perl);

    /* set $$ to pseudo id */
#ifdef PERL_SYNC_FORK
    w32_pseudo_id = id;
#else
    w32_pseudo_id = GetCurrentThreadId();
    if (IsWin95()) {
	int pid = (int)w32_pseudo_id;
	if (pid < 0)
	    w32_pseudo_id = -pid;
    }
#endif
    if (tmpgv = gv_fetchpv("$", TRUE, SVt_PV)) {
	SV *sv = GvSV(tmpgv);
	SvREADONLY_off(sv);
	sv_setiv(sv, -(IV)w32_pseudo_id);
	SvREADONLY_on(sv);
    }
#ifdef PERL_USES_PL_PIDSTATUS    
    hv_clear(PL_pidstatus);
#endif    

    /* create message window and tell parent about it */
    parent_message_hwnd = w32_message_hwnd;
    w32_message_hwnd = win32_create_message_window();
    if (parent_message_hwnd != NULL)
        PostMessage(parent_message_hwnd, WM_USER_MESSAGE, w32_pseudo_id, (LONG)w32_message_hwnd);

    /* push a zero on the stack (we are the child) */
    {
	dSP;
	dTARGET;
	PUSHi(0);
	PUTBACK;
    }

    /* continue from next op */
    PL_op = PL_op->op_next;

    {
	dJMPENV;
	volatile int oldscope = PL_scopestack_ix;

restart:
	JMPENV_PUSH(status);
	switch (status) {
	case 0:
	    CALLRUNOPS(aTHX);
	    status = 0;
	    break;
	case 2:
	    while (PL_scopestack_ix > oldscope)
		LEAVE;
	    FREETMPS;
	    PL_curstash = PL_defstash;
	    if (PL_endav && !PL_minus_c)
		call_list(oldscope, PL_endav);
	    status = STATUS_EXIT;
	    break;
	case 3:
	    if (PL_restartop) {
		POPSTACK_TO(PL_mainstack);
		PL_op = PL_restartop;
		PL_restartop = Nullop;
		goto restart;
	    }
	    PerlIO_printf(Perl_error_log, "panic: restartop\n");
	    FREETMPS;
	    status = 1;
	    break;
	}
	JMPENV_POP;

	/* XXX hack to avoid perl_destruct() freeing optree */
        win32_checkTLS(my_perl);
	PL_main_root = Nullop;
    }

    win32_checkTLS(my_perl);
    /* close the std handles to avoid fd leaks */
    {
	do_close(PL_stdingv, FALSE);
	do_close(gv_fetchpv("STDOUT", TRUE, SVt_PVIO), FALSE); /* PL_stdoutgv - ISAGN */
	do_close(PL_stderrgv, FALSE);
    }

    /* destroy everything (waits for any pseudo-forked children) */
    win32_checkTLS(my_perl);
    perl_destruct(my_perl);
    win32_checkTLS(my_perl);
    perl_free(my_perl);

#ifdef PERL_SYNC_FORK
    return id;
#else
    return (DWORD)status;
#endif
}
#endif /* USE_ITHREADS */

int
PerlProcFork(struct IPerlProc* piPerl)
{
    dTHX;
#ifdef USE_ITHREADS
    DWORD id;
    HANDLE handle;
    CPerlHost *h;

    if (w32_num_pseudo_children >= MAXIMUM_WAIT_OBJECTS) {
	errno = EAGAIN;
	return -1;
    }
    h = new CPerlHost(*(CPerlHost*)w32_internal_host);
    PerlInterpreter *new_perl = perl_clone_using((PerlInterpreter*)aTHX, 1,
						 h->m_pHostperlMem,
						 h->m_pHostperlMemShared,
						 h->m_pHostperlMemParse,
						 h->m_pHostperlEnv,
						 h->m_pHostperlStdIO,
						 h->m_pHostperlLIO,
						 h->m_pHostperlDir,
						 h->m_pHostperlSock,
						 h->m_pHostperlProc
						 );
    new_perl->Isys_intern.internal_host = h;
    h->host_perl = new_perl;
#  ifdef PERL_SYNC_FORK
    id = win32_start_child((LPVOID)new_perl);
    PERL_SET_THX(aTHX);
#  else
    if (w32_message_hwnd == INVALID_HANDLE_VALUE)
        w32_message_hwnd = win32_create_message_window();
    new_perl->Isys_intern.message_hwnd = w32_message_hwnd;
    w32_pseudo_child_message_hwnds[w32_num_pseudo_children] =
        (w32_message_hwnd == NULL) ? (HWND)NULL : (HWND)INVALID_HANDLE_VALUE;
#    ifdef USE_RTL_THREAD_API
    handle = (HANDLE)_beginthreadex((void*)NULL, 0, win32_start_child,
				    (void*)new_perl, 0, (unsigned*)&id);
#    else
    handle = CreateThread(NULL, 0, win32_start_child,
			  (LPVOID)new_perl, 0, &id);
#    endif
    PERL_SET_THX(aTHX);	/* XXX perl_clone*() set TLS */
    if (!handle) {
	errno = EAGAIN;
	return -1;
    }
    if (IsWin95()) {
	int pid = (int)id;
	if (pid < 0)
	    id = -pid;
    }
    w32_pseudo_child_handles[w32_num_pseudo_children] = handle;
    w32_pseudo_child_pids[w32_num_pseudo_children] = id;
    ++w32_num_pseudo_children;
#  endif
    return -(int)id;
#else
    Perl_croak(aTHX_ "fork() not implemented!\n");
    return -1;
#endif /* USE_ITHREADS */
}

int
PerlProcGetpid(struct IPerlProc* piPerl)
{
    return win32_getpid();
}

void*
PerlProcDynaLoader(struct IPerlProc* piPerl, const char* filename)
{
    return win32_dynaload(filename);
}

void
PerlProcGetOSError(struct IPerlProc* piPerl, SV* sv, DWORD dwErr)
{
    win32_str_os_error(sv, dwErr);
}

int
PerlProcSpawnvp(struct IPerlProc* piPerl, int mode, const char *cmdname, const char *const *argv)
{
    return win32_spawnvp(mode, cmdname, argv);
}

int
PerlProcLastHost(struct IPerlProc* piPerl)
{
 dTHX;
 CPerlHost *h = (CPerlHost*)w32_internal_host;
 return h->LastHost();
}

struct IPerlProc perlProc =
{
    PerlProcAbort,
    PerlProcCrypt,
    PerlProcExit,
    PerlProc_Exit,
    PerlProcExecl,
    PerlProcExecv,
    PerlProcExecvp,
    PerlProcGetuid,
    PerlProcGeteuid,
    PerlProcGetgid,
    PerlProcGetegid,
    PerlProcGetlogin,
    PerlProcKill,
    PerlProcKillpg,
    PerlProcPauseProc,
    PerlProcPopen,
    PerlProcPclose,
    PerlProcPipe,
    PerlProcSetuid,
    PerlProcSetgid,
    PerlProcSleep,
    PerlProcTimes,
    PerlProcWait,
    PerlProcWaitpid,
    PerlProcSignal,
    PerlProcFork,
    PerlProcGetpid,
    PerlProcDynaLoader,
    PerlProcGetOSError,
    PerlProcSpawnvp,
    PerlProcLastHost,
    PerlProcPopenList,
    PerlProcGetTimeOfDay
};


/*
 * CPerlHost
 */

CPerlHost::CPerlHost(void)
{
    /* Construct a host from scratch */
    InterlockedIncrement(&num_hosts);
    m_pvDir = new VDir();
    m_pVMem = new VMem();
    m_pVMemShared = new VMem();
    m_pVMemParse =  new VMem();

    m_pvDir->Init(NULL, m_pVMem);

    m_dwEnvCount = 0;
    m_lppEnvList = NULL;
    m_bTopLevel = TRUE;

    CopyMemory(&m_hostperlMem, &perlMem, sizeof(perlMem));
    CopyMemory(&m_hostperlMemShared, &perlMemShared, sizeof(perlMemShared));
    CopyMemory(&m_hostperlMemParse, &perlMemParse, sizeof(perlMemParse));
    CopyMemory(&m_hostperlEnv, &perlEnv, sizeof(perlEnv));
    CopyMemory(&m_hostperlStdIO, &perlStdIO, sizeof(perlStdIO));
    CopyMemory(&m_hostperlLIO, &perlLIO, sizeof(perlLIO));
    CopyMemory(&m_hostperlDir, &perlDir, sizeof(perlDir));
    CopyMemory(&m_hostperlSock, &perlSock, sizeof(perlSock));
    CopyMemory(&m_hostperlProc, &perlProc, sizeof(perlProc));

    m_pHostperlMem	    = &m_hostperlMem;
    m_pHostperlMemShared    = &m_hostperlMemShared;
    m_pHostperlMemParse	    = &m_hostperlMemParse;
    m_pHostperlEnv	    = &m_hostperlEnv;
    m_pHostperlStdIO	    = &m_hostperlStdIO;
    m_pHostperlLIO	    = &m_hostperlLIO;
    m_pHostperlDir	    = &m_hostperlDir;
    m_pHostperlSock	    = &m_hostperlSock;
    m_pHostperlProc	    = &m_hostperlProc;
}

#define SETUPEXCHANGE(xptr, iptr, table) \
    STMT_START {				\
	if (xptr) {				\
	    iptr = *xptr;			\
	    *xptr = &table;			\
	}					\
	else {					\
	    iptr = &table;			\
	}					\
    } STMT_END

CPerlHost::CPerlHost(struct IPerlMem** ppMem, struct IPerlMem** ppMemShared,
		 struct IPerlMem** ppMemParse, struct IPerlEnv** ppEnv,
		 struct IPerlStdIO** ppStdIO, struct IPerlLIO** ppLIO,
		 struct IPerlDir** ppDir, struct IPerlSock** ppSock,
		 struct IPerlProc** ppProc)
{
    InterlockedIncrement(&num_hosts);
    m_pvDir = new VDir(0);
    m_pVMem = new VMem();
    m_pVMemShared = new VMem();
    m_pVMemParse =  new VMem();

    m_pvDir->Init(NULL, m_pVMem);

    m_dwEnvCount = 0;
    m_lppEnvList = NULL;
    m_bTopLevel = FALSE;

    CopyMemory(&m_hostperlMem, &perlMem, sizeof(perlMem));
    CopyMemory(&m_hostperlMemShared, &perlMemShared, sizeof(perlMemShared));
    CopyMemory(&m_hostperlMemParse, &perlMemParse, sizeof(perlMemParse));
    CopyMemory(&m_hostperlEnv, &perlEnv, sizeof(perlEnv));
    CopyMemory(&m_hostperlStdIO, &perlStdIO, sizeof(perlStdIO));
    CopyMemory(&m_hostperlLIO, &perlLIO, sizeof(perlLIO));
    CopyMemory(&m_hostperlDir, &perlDir, sizeof(perlDir));
    CopyMemory(&m_hostperlSock, &perlSock, sizeof(perlSock));
    CopyMemory(&m_hostperlProc, &perlProc, sizeof(perlProc));

    SETUPEXCHANGE(ppMem,	m_pHostperlMem,		m_hostperlMem);
    SETUPEXCHANGE(ppMemShared,	m_pHostperlMemShared,	m_hostperlMemShared);
    SETUPEXCHANGE(ppMemParse,	m_pHostperlMemParse,	m_hostperlMemParse);
    SETUPEXCHANGE(ppEnv,	m_pHostperlEnv,		m_hostperlEnv);
    SETUPEXCHANGE(ppStdIO,	m_pHostperlStdIO,	m_hostperlStdIO);
    SETUPEXCHANGE(ppLIO,	m_pHostperlLIO,		m_hostperlLIO);
    SETUPEXCHANGE(ppDir,	m_pHostperlDir,		m_hostperlDir);
    SETUPEXCHANGE(ppSock,	m_pHostperlSock,	m_hostperlSock);
    SETUPEXCHANGE(ppProc,	m_pHostperlProc,	m_hostperlProc);
}
#undef SETUPEXCHANGE

CPerlHost::CPerlHost(CPerlHost& host)
{
    /* Construct a host from another host */
    InterlockedIncrement(&num_hosts);
    m_pVMem = new VMem();
    m_pVMemShared = host.GetMemShared();
    m_pVMemParse =  host.GetMemParse();

    /* duplicate directory info */
    m_pvDir = new VDir(0);
    m_pvDir->Init(host.GetDir(), m_pVMem);

    CopyMemory(&m_hostperlMem, &perlMem, sizeof(perlMem));
    CopyMemory(&m_hostperlMemShared, &perlMemShared, sizeof(perlMemShared));
    CopyMemory(&m_hostperlMemParse, &perlMemParse, sizeof(perlMemParse));
    CopyMemory(&m_hostperlEnv, &perlEnv, sizeof(perlEnv));
    CopyMemory(&m_hostperlStdIO, &perlStdIO, sizeof(perlStdIO));
    CopyMemory(&m_hostperlLIO, &perlLIO, sizeof(perlLIO));
    CopyMemory(&m_hostperlDir, &perlDir, sizeof(perlDir));
    CopyMemory(&m_hostperlSock, &perlSock, sizeof(perlSock));
    CopyMemory(&m_hostperlProc, &perlProc, sizeof(perlProc));
    m_pHostperlMem	    = &m_hostperlMem;
    m_pHostperlMemShared    = &m_hostperlMemShared;
    m_pHostperlMemParse	    = &m_hostperlMemParse;
    m_pHostperlEnv	    = &m_hostperlEnv;
    m_pHostperlStdIO	    = &m_hostperlStdIO;
    m_pHostperlLIO	    = &m_hostperlLIO;
    m_pHostperlDir	    = &m_hostperlDir;
    m_pHostperlSock	    = &m_hostperlSock;
    m_pHostperlProc	    = &m_hostperlProc;

    m_dwEnvCount = 0;
    m_lppEnvList = NULL;
    m_bTopLevel = FALSE;

    /* duplicate environment info */
    LPSTR lpPtr;
    DWORD dwIndex = 0;
    while(lpPtr = host.GetIndex(dwIndex))
	Add(lpPtr);
}

CPerlHost::~CPerlHost(void)
{
    Reset();
    InterlockedDecrement(&num_hosts);
    delete m_pvDir;
    m_pVMemParse->Release();
    m_pVMemShared->Release();
    m_pVMem->Release();
}

LPSTR
CPerlHost::Find(LPCSTR lpStr)
{
    LPSTR lpPtr;
    LPSTR* lppPtr = Lookup(lpStr);
    if(lppPtr != NULL) {
	for(lpPtr = *lppPtr; *lpPtr != '\0' && *lpPtr != '='; ++lpPtr)
	    ;

	if(*lpPtr == '=')
	    ++lpPtr;

	return lpPtr;
    }
    return NULL;
}

int
lookup(const void *arg1, const void *arg2)
{   // Compare strings
    char*ptr1, *ptr2;
    char c1,c2;

    ptr1 = *(char**)arg1;
    ptr2 = *(char**)arg2;
    for(;;) {
	c1 = *ptr1++;
	c2 = *ptr2++;
	if(c1 == '\0' || c1 == '=') {
	    if(c2 == '\0' || c2 == '=')
		break;

	    return -1; // string 1 < string 2
	}
	else if(c2 == '\0' || c2 == '=')
	    return 1; // string 1 > string 2
	else if(c1 != c2) {
	    c1 = toupper(c1);
	    c2 = toupper(c2);
	    if(c1 != c2) {
		if(c1 < c2)
		    return -1; // string 1 < string 2

		return 1; // string 1 > string 2
	    }
	}
    }
    return 0;
}

LPSTR*
CPerlHost::Lookup(LPCSTR lpStr)
{
#ifdef UNDER_CE
    if (!m_lppEnvList || !m_dwEnvCount)
	return NULL;
#endif
    if (!lpStr)
	return NULL;
    return (LPSTR*)bsearch(&lpStr, m_lppEnvList, m_dwEnvCount, sizeof(LPSTR), lookup);
}

int
compare(const void *arg1, const void *arg2)
{   // Compare strings
    char*ptr1, *ptr2;
    char c1,c2;

    ptr1 = *(char**)arg1;
    ptr2 = *(char**)arg2;
    for(;;) {
	c1 = *ptr1++;
	c2 = *ptr2++;
	if(c1 == '\0' || c1 == '=') {
	    if(c1 == c2)
		break;

	    return -1; // string 1 < string 2
	}
	else if(c2 == '\0' || c2 == '=')
	    return 1; // string 1 > string 2
	else if(c1 != c2) {
	    c1 = toupper(c1);
	    c2 = toupper(c2);
	    if(c1 != c2) {
		if(c1 < c2)
		    return -1; // string 1 < string 2

		return 1; // string 1 > string 2
	    }
	}
    }
    return 0;
}

void
CPerlHost::Add(LPCSTR lpStr)
{
    dTHX;
    char szBuffer[1024];
    LPSTR *lpPtr;
    int index, length = strlen(lpStr)+1;

    for(index = 0; lpStr[index] != '\0' && lpStr[index] != '='; ++index)
	szBuffer[index] = lpStr[index];

    szBuffer[index] = '\0';

    // replacing ?
    lpPtr = Lookup(szBuffer);
    if (lpPtr != NULL) {
	// must allocate things via host memory allocation functions 
	// rather than perl's Renew() et al, as the perl interpreter
	// may either not be initialized enough when we allocate these,
	// or may already be dead when we go to free these
	*lpPtr = (char*)Realloc(*lpPtr, length * sizeof(char));
	strcpy(*lpPtr, lpStr);
    }
    else {
	m_lppEnvList = (LPSTR*)Realloc(m_lppEnvList, (m_dwEnvCount+1) * sizeof(LPSTR));
	if (m_lppEnvList) {
	    m_lppEnvList[m_dwEnvCount] = (char*)Malloc(length * sizeof(char));
	    if (m_lppEnvList[m_dwEnvCount] != NULL) {
		strcpy(m_lppEnvList[m_dwEnvCount], lpStr);
		++m_dwEnvCount;
		qsort(m_lppEnvList, m_dwEnvCount, sizeof(LPSTR), compare);
	    }
	}
    }
}

DWORD
CPerlHost::CalculateEnvironmentSpace(void)
{
    DWORD index;
    DWORD dwSize = 0;
    for(index = 0; index < m_dwEnvCount; ++index)
	dwSize += strlen(m_lppEnvList[index]) + 1;

    return dwSize;
}

void
CPerlHost::FreeLocalEnvironmentStrings(LPSTR lpStr)
{
    dTHX;
    Safefree(lpStr);
}

char*
CPerlHost::GetChildDir(void)
{
    dTHX;
    char* ptr;
    size_t length;

    Newx(ptr, MAX_PATH+1, char);
    m_pvDir->GetCurrentDirectoryA(MAX_PATH+1, ptr);
    length = strlen(ptr);
    if (length > 3) {
        if ((ptr[length-1] == '\\') || (ptr[length-1] == '/'))
            ptr[length-1] = 0;
    }
    return ptr;
}

void
CPerlHost::FreeChildDir(char* pStr)
{
    dTHX;
    Safefree(pStr);
}

LPSTR
CPerlHost::CreateLocalEnvironmentStrings(VDir &vDir)
{
    dTHX;
    LPSTR lpStr, lpPtr, lpEnvPtr, lpTmp, lpLocalEnv, lpAllocPtr;
    DWORD dwSize, dwEnvIndex;
    int nLength, compVal;

    // get the process environment strings
    lpAllocPtr = lpTmp = (LPSTR)GetEnvironmentStrings();

    // step over current directory stuff
    while(*lpTmp == '=')
	lpTmp += strlen(lpTmp) + 1;

    // save the start of the environment strings
    lpEnvPtr = lpTmp;
    for(dwSize = 1; *lpTmp != '\0'; lpTmp += strlen(lpTmp) + 1) {
	// calculate the size of the environment strings
	dwSize += strlen(lpTmp) + 1;
    }

    // add the size of current directories
    dwSize += vDir.CalculateEnvironmentSpace();

    // add the additional space used by changes made to the environment
    dwSize += CalculateEnvironmentSpace();

    Newx(lpStr, dwSize, char);
    lpPtr = lpStr;
    if(lpStr != NULL) {
	// build the local environment
	lpStr = vDir.BuildEnvironmentSpace(lpStr);

	dwEnvIndex = 0;
	lpLocalEnv = GetIndex(dwEnvIndex);
	while(*lpEnvPtr != '\0') {
	    if(!lpLocalEnv) {
		// all environment overrides have been added
		// so copy string into place
		strcpy(lpStr, lpEnvPtr);
		nLength = strlen(lpEnvPtr) + 1;
		lpStr += nLength;
		lpEnvPtr += nLength;
	    }
	    else {
		// determine which string to copy next
		compVal = compare(&lpEnvPtr, &lpLocalEnv);
		if(compVal < 0) {
		    strcpy(lpStr, lpEnvPtr);
		    nLength = strlen(lpEnvPtr) + 1;
		    lpStr += nLength;
		    lpEnvPtr += nLength;
		}
		else {
		    char *ptr = strchr(lpLocalEnv, '=');
		    if(ptr && ptr[1]) {
			strcpy(lpStr, lpLocalEnv);
			lpStr += strlen(lpLocalEnv) + 1;
		    }
		    lpLocalEnv = GetIndex(dwEnvIndex);
		    if(compVal == 0) {
			// this string was replaced
			lpEnvPtr += strlen(lpEnvPtr) + 1;
		    }
		}
	    }
	}

	while(lpLocalEnv) {
	    // still have environment overrides to add
	    // so copy the strings into place if not an override
	    char *ptr = strchr(lpLocalEnv, '=');
	    if(ptr && ptr[1]) {
		strcpy(lpStr, lpLocalEnv);
		lpStr += strlen(lpLocalEnv) + 1;
	    }
	    lpLocalEnv = GetIndex(dwEnvIndex);
	}

	// add final NULL
	*lpStr = '\0';
    }

    // release the process environment strings
    FreeEnvironmentStrings(lpAllocPtr);

    return lpPtr;
}

void
CPerlHost::Reset(void)
{
    dTHX;
    if(m_lppEnvList != NULL) {
	for(DWORD index = 0; index < m_dwEnvCount; ++index) {
	    Free(m_lppEnvList[index]);
	    m_lppEnvList[index] = NULL;
	}
    }
    m_dwEnvCount = 0;
    Free(m_lppEnvList);
    m_lppEnvList = NULL;
}

void
CPerlHost::Clearenv(void)
{
    dTHX;
    char ch;
    LPSTR lpPtr, lpStr, lpEnvPtr;
    if (m_lppEnvList != NULL) {
	/* set every entry to an empty string */
	for(DWORD index = 0; index < m_dwEnvCount; ++index) {
	    char* ptr = strchr(m_lppEnvList[index], '=');
	    if(ptr) {
		*++ptr = 0;
	    }
	}
    }

    /* get the process environment strings */
    lpStr = lpEnvPtr = (LPSTR)GetEnvironmentStrings();

    /* step over current directory stuff */
    while(*lpStr == '=')
	lpStr += strlen(lpStr) + 1;

    while(*lpStr) {
	lpPtr = strchr(lpStr, '=');
	if(lpPtr) {
	    ch = *++lpPtr;
	    *lpPtr = 0;
	    Add(lpStr);
	    if (m_bTopLevel)
		(void)win32_putenv(lpStr);
	    *lpPtr = ch;
	}
	lpStr += strlen(lpStr) + 1;
    }

    FreeEnvironmentStrings(lpEnvPtr);
}


char*
CPerlHost::Getenv(const char *varname)
{
    dTHX;
    if (!m_bTopLevel) {
	char *pEnv = Find(varname);
	if (pEnv && *pEnv)
	    return pEnv;
    }
    return win32_getenv(varname);
}

int
CPerlHost::Putenv(const char *envstring)
{
    dTHX;
    Add(envstring);
    if (m_bTopLevel)
	return win32_putenv(envstring);

    return 0;
}

int
CPerlHost::Chdir(const char *dirname)
{
    dTHX;
    int ret;
    if (!dirname) {
	errno = ENOENT;
	return -1;
    }
    ret = m_pvDir->SetCurrentDirectoryA((char*)dirname);
    if(ret < 0) {
	errno = ENOENT;
    }
    return ret;
}

#endif /* ___PerlHost_H___ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perlapi.h ===
/*  -*- buffer-read-only: t -*-
 *
 *    perlapi.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by embed.pl from data in embed.fnc, embed.pl,
 * pp.sym, intrpvar.h, and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

/* declare accessor functions for Perl variables */
#ifndef __perlapi_h__
#define __perlapi_h__

#if defined (MULTIPLICITY)

START_EXTERN_C

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC
#define PERLVAR(v,t)	EXTERN_C t* Perl_##v##_ptr(pTHX);
#define PERLVARA(v,n,t)	typedef t PL_##v##_t[n];			\
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHX);
#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v, const t)
#define PERLVARISC(v,i)	typedef const char PL_##v##_t[sizeof(i)];	\
			EXTERN_C PL_##v##_t* Perl_##v##_ptr(pTHX);

#include "intrpvar.h"
#include "perlvars.h"

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC

#ifndef PERL_GLOBAL_STRUCT
EXTERN_C Perl_ppaddr_t** Perl_Gppaddr_ptr(pTHX);
EXTERN_C Perl_check_t**  Perl_Gcheck_ptr(pTHX);
EXTERN_C unsigned char** Perl_Gfold_locale_ptr(pTHX);
#define Perl_ppaddr_ptr      Perl_Gppaddr_ptr
#define Perl_check_ptr       Perl_Gcheck_ptr
#define Perl_fold_locale_ptr Perl_Gfold_locale_ptr
#endif

END_EXTERN_C

#if defined(PERL_CORE)

/* accessor functions for Perl variables (provide binary compatibility) */

/* these need to be mentioned here, or most linkers won't put them in
   the perl executable */

#ifndef PERL_NO_FORCE_LINK

START_EXTERN_C

#ifndef DOINIT
EXTCONST void * const PL_force_link_funcs[];
#else
EXTCONST void * const PL_force_link_funcs[] = {
#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#define PERLVAR(v,t)	(void*)Perl_##v##_ptr,
#define PERLVARA(v,n,t)	PERLVAR(v,t)
#define PERLVARI(v,t,i)	PERLVAR(v,t)
#define PERLVARIC(v,t,i) PERLVAR(v,t)
#define PERLVARISC(v,i) PERLVAR(v,char)

/* In Tru64 (__DEC && __osf__) the cc option -std1 causes that one
 * cannot cast between void pointers and function pointers without
 * info level warnings.  The PL_force_link_funcs[] would cause a few
 * hundred of those warnings.  In code one can circumnavigate this by using
 * unions that overlay the different pointers, but in declarations one
 * cannot use this trick.  Therefore we just disable the warning here
 * for the duration of the PL_force_link_funcs[] declaration. */

#if defined(__DECC) && defined(__osf__)
#pragma message save
#pragma message disable (nonstandcast)
#endif

#include "intrpvar.h"
#include "perlvars.h"

#if defined(__DECC) && defined(__osf__)
#pragma message restore
#endif

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC
};
#endif	/* DOINIT */

END_EXTERN_C

#endif	/* PERL_NO_FORCE_LINK */

#else	/* !PERL_CORE */

#undef  PL_Argv
#define PL_Argv			(*Perl_IArgv_ptr(aTHX))
#undef  PL_Cmd
#define PL_Cmd			(*Perl_ICmd_ptr(aTHX))
#undef  PL_DBcv
#define PL_DBcv			(*Perl_IDBcv_ptr(aTHX))
#undef  PL_DBgv
#define PL_DBgv			(*Perl_IDBgv_ptr(aTHX))
#undef  PL_DBline
#define PL_DBline		(*Perl_IDBline_ptr(aTHX))
#undef  PL_DBsignal
#define PL_DBsignal		(*Perl_IDBsignal_ptr(aTHX))
#undef  PL_DBsingle
#define PL_DBsingle		(*Perl_IDBsingle_ptr(aTHX))
#undef  PL_DBsub
#define PL_DBsub		(*Perl_IDBsub_ptr(aTHX))
#undef  PL_DBtrace
#define PL_DBtrace		(*Perl_IDBtrace_ptr(aTHX))
#undef  PL_Dir
#define PL_Dir			(*Perl_IDir_ptr(aTHX))
#undef  PL_Env
#define PL_Env			(*Perl_IEnv_ptr(aTHX))
#undef  PL_LIO
#define PL_LIO			(*Perl_ILIO_ptr(aTHX))
#undef  PL_Mem
#define PL_Mem			(*Perl_IMem_ptr(aTHX))
#undef  PL_MemParse
#define PL_MemParse		(*Perl_IMemParse_ptr(aTHX))
#undef  PL_MemShared
#define PL_MemShared		(*Perl_IMemShared_ptr(aTHX))
#undef  PL_OpPtr
#define PL_OpPtr		(*Perl_IOpPtr_ptr(aTHX))
#undef  PL_OpSlab
#define PL_OpSlab		(*Perl_IOpSlab_ptr(aTHX))
#undef  PL_OpSpace
#define PL_OpSpace		(*Perl_IOpSpace_ptr(aTHX))
#undef  PL_Proc
#define PL_Proc			(*Perl_IProc_ptr(aTHX))
#undef  PL_Sock
#define PL_Sock			(*Perl_ISock_ptr(aTHX))
#undef  PL_StdIO
#define PL_StdIO		(*Perl_IStdIO_ptr(aTHX))
#undef  PL_Sv
#define PL_Sv			(*Perl_ISv_ptr(aTHX))
#undef  PL_Xpv
#define PL_Xpv			(*Perl_IXpv_ptr(aTHX))
#undef  PL_amagic_generation
#define PL_amagic_generation	(*Perl_Iamagic_generation_ptr(aTHX))
#undef  PL_an
#define PL_an			(*Perl_Ian_ptr(aTHX))
#undef  PL_argvgv
#define PL_argvgv		(*Perl_Iargvgv_ptr(aTHX))
#undef  PL_argvout_stack
#define PL_argvout_stack	(*Perl_Iargvout_stack_ptr(aTHX))
#undef  PL_argvoutgv
#define PL_argvoutgv		(*Perl_Iargvoutgv_ptr(aTHX))
#undef  PL_basetime
#define PL_basetime		(*Perl_Ibasetime_ptr(aTHX))
#undef  PL_beginav
#define PL_beginav		(*Perl_Ibeginav_ptr(aTHX))
#undef  PL_beginav_save
#define PL_beginav_save		(*Perl_Ibeginav_save_ptr(aTHX))
#undef  PL_bitcount
#define PL_bitcount		(*Perl_Ibitcount_ptr(aTHX))
#undef  PL_body_arenas
#define PL_body_arenas		(*Perl_Ibody_arenas_ptr(aTHX))
#undef  PL_body_roots
#define PL_body_roots		(*Perl_Ibody_roots_ptr(aTHX))
#undef  PL_bodytarget
#define PL_bodytarget		(*Perl_Ibodytarget_ptr(aTHX))
#undef  PL_checkav
#define PL_checkav		(*Perl_Icheckav_ptr(aTHX))
#undef  PL_checkav_save
#define PL_checkav_save		(*Perl_Icheckav_save_ptr(aTHX))
#undef  PL_chopset
#define PL_chopset		(*Perl_Ichopset_ptr(aTHX))
#undef  PL_clocktick
#define PL_clocktick		(*Perl_Iclocktick_ptr(aTHX))
#undef  PL_collation_ix
#define PL_collation_ix		(*Perl_Icollation_ix_ptr(aTHX))
#undef  PL_collation_name
#define PL_collation_name	(*Perl_Icollation_name_ptr(aTHX))
#undef  PL_collation_standard
#define PL_collation_standard	(*Perl_Icollation_standard_ptr(aTHX))
#undef  PL_collxfrm_base
#define PL_collxfrm_base	(*Perl_Icollxfrm_base_ptr(aTHX))
#undef  PL_collxfrm_mult
#define PL_collxfrm_mult	(*Perl_Icollxfrm_mult_ptr(aTHX))
#undef  PL_colors
#define PL_colors		(*Perl_Icolors_ptr(aTHX))
#undef  PL_colorset
#define PL_colorset		(*Perl_Icolorset_ptr(aTHX))
#undef  PL_compcv
#define PL_compcv		(*Perl_Icompcv_ptr(aTHX))
#undef  PL_compiling
#define PL_compiling		(*Perl_Icompiling_ptr(aTHX))
#undef  PL_comppad
#define PL_comppad		(*Perl_Icomppad_ptr(aTHX))
#undef  PL_comppad_name
#define PL_comppad_name		(*Perl_Icomppad_name_ptr(aTHX))
#undef  PL_comppad_name_fill
#define PL_comppad_name_fill	(*Perl_Icomppad_name_fill_ptr(aTHX))
#undef  PL_comppad_name_floor
#define PL_comppad_name_floor	(*Perl_Icomppad_name_floor_ptr(aTHX))
#undef  PL_cop_seqmax
#define PL_cop_seqmax		(*Perl_Icop_seqmax_ptr(aTHX))
#undef  PL_cryptseen
#define PL_cryptseen		(*Perl_Icryptseen_ptr(aTHX))
#undef  PL_curcop
#define PL_curcop		(*Perl_Icurcop_ptr(aTHX))
#undef  PL_curcopdb
#define PL_curcopdb		(*Perl_Icurcopdb_ptr(aTHX))
#undef  PL_curpad
#define PL_curpad		(*Perl_Icurpad_ptr(aTHX))
#undef  PL_curpm
#define PL_curpm		(*Perl_Icurpm_ptr(aTHX))
#undef  PL_curstack
#define PL_curstack		(*Perl_Icurstack_ptr(aTHX))
#undef  PL_curstackinfo
#define PL_curstackinfo		(*Perl_Icurstackinfo_ptr(aTHX))
#undef  PL_curstash
#define PL_curstash		(*Perl_Icurstash_ptr(aTHX))
#undef  PL_curstname
#define PL_curstname		(*Perl_Icurstname_ptr(aTHX))
#undef  PL_custom_op_descs
#define PL_custom_op_descs	(*Perl_Icustom_op_descs_ptr(aTHX))
#undef  PL_custom_op_names
#define PL_custom_op_names	(*Perl_Icustom_op_names_ptr(aTHX))
#undef  PL_cv_has_eval
#define PL_cv_has_eval		(*Perl_Icv_has_eval_ptr(aTHX))
#undef  PL_dbargs
#define PL_dbargs		(*Perl_Idbargs_ptr(aTHX))
#undef  PL_debstash
#define PL_debstash		(*Perl_Idebstash_ptr(aTHX))
#undef  PL_debug
#define PL_debug		(*Perl_Idebug_ptr(aTHX))
#undef  PL_debug_pad
#define PL_debug_pad		(*Perl_Idebug_pad_ptr(aTHX))
#undef  PL_def_layerlist
#define PL_def_layerlist	(*Perl_Idef_layerlist_ptr(aTHX))
#undef  PL_defgv
#define PL_defgv		(*Perl_Idefgv_ptr(aTHX))
#undef  PL_defoutgv
#define PL_defoutgv		(*Perl_Idefoutgv_ptr(aTHX))
#undef  PL_defstash
#define PL_defstash		(*Perl_Idefstash_ptr(aTHX))
#undef  PL_delaymagic
#define PL_delaymagic		(*Perl_Idelaymagic_ptr(aTHX))
#undef  PL_destroyhook
#define PL_destroyhook		(*Perl_Idestroyhook_ptr(aTHX))
#undef  PL_diehook
#define PL_diehook		(*Perl_Idiehook_ptr(aTHX))
#undef  PL_dirty
#define PL_dirty		(*Perl_Idirty_ptr(aTHX))
#undef  PL_doextract
#define PL_doextract		(*Perl_Idoextract_ptr(aTHX))
#undef  PL_doswitches
#define PL_doswitches		(*Perl_Idoswitches_ptr(aTHX))
#undef  PL_dowarn
#define PL_dowarn		(*Perl_Idowarn_ptr(aTHX))
#undef  PL_dumper_fd
#define PL_dumper_fd		(*Perl_Idumper_fd_ptr(aTHX))
#undef  PL_dumpindent
#define PL_dumpindent		(*Perl_Idumpindent_ptr(aTHX))
#undef  PL_e_script
#define PL_e_script		(*Perl_Ie_script_ptr(aTHX))
#undef  PL_efloatbuf
#define PL_efloatbuf		(*Perl_Iefloatbuf_ptr(aTHX))
#undef  PL_efloatsize
#define PL_efloatsize		(*Perl_Iefloatsize_ptr(aTHX))
#undef  PL_egid
#define PL_egid			(*Perl_Iegid_ptr(aTHX))
#undef  PL_encoding
#define PL_encoding		(*Perl_Iencoding_ptr(aTHX))
#undef  PL_endav
#define PL_endav		(*Perl_Iendav_ptr(aTHX))
#undef  PL_envgv
#define PL_envgv		(*Perl_Ienvgv_ptr(aTHX))
#undef  PL_errgv
#define PL_errgv		(*Perl_Ierrgv_ptr(aTHX))
#undef  PL_errors
#define PL_errors		(*Perl_Ierrors_ptr(aTHX))
#undef  PL_euid
#define PL_euid			(*Perl_Ieuid_ptr(aTHX))
#undef  PL_eval_root
#define PL_eval_root		(*Perl_Ieval_root_ptr(aTHX))
#undef  PL_eval_start
#define PL_eval_start		(*Perl_Ieval_start_ptr(aTHX))
#undef  PL_evalseq
#define PL_evalseq		(*Perl_Ievalseq_ptr(aTHX))
#undef  PL_exit_flags
#define PL_exit_flags		(*Perl_Iexit_flags_ptr(aTHX))
#undef  PL_exitlist
#define PL_exitlist		(*Perl_Iexitlist_ptr(aTHX))
#undef  PL_exitlistlen
#define PL_exitlistlen		(*Perl_Iexitlistlen_ptr(aTHX))
#undef  PL_fdpid
#define PL_fdpid		(*Perl_Ifdpid_ptr(aTHX))
#undef  PL_filemode
#define PL_filemode		(*Perl_Ifilemode_ptr(aTHX))
#undef  PL_firstgv
#define PL_firstgv		(*Perl_Ifirstgv_ptr(aTHX))
#undef  PL_forkprocess
#define PL_forkprocess		(*Perl_Iforkprocess_ptr(aTHX))
#undef  PL_formfeed
#define PL_formfeed		(*Perl_Iformfeed_ptr(aTHX))
#undef  PL_formtarget
#define PL_formtarget		(*Perl_Iformtarget_ptr(aTHX))
#undef  PL_generation
#define PL_generation		(*Perl_Igeneration_ptr(aTHX))
#undef  PL_gensym
#define PL_gensym		(*Perl_Igensym_ptr(aTHX))
#undef  PL_gid
#define PL_gid			(*Perl_Igid_ptr(aTHX))
#undef  PL_glob_index
#define PL_glob_index		(*Perl_Iglob_index_ptr(aTHX))
#undef  PL_globalstash
#define PL_globalstash		(*Perl_Iglobalstash_ptr(aTHX))
#undef  PL_hash_seed
#define PL_hash_seed		(*Perl_Ihash_seed_ptr(aTHX))
#undef  PL_hintgv
#define PL_hintgv		(*Perl_Ihintgv_ptr(aTHX))
#undef  PL_hints
#define PL_hints		(*Perl_Ihints_ptr(aTHX))
#undef  PL_hv_fetch_ent_mh
#define PL_hv_fetch_ent_mh	(*Perl_Ihv_fetch_ent_mh_ptr(aTHX))
#undef  PL_in_clean_all
#define PL_in_clean_all		(*Perl_Iin_clean_all_ptr(aTHX))
#undef  PL_in_clean_objs
#define PL_in_clean_objs	(*Perl_Iin_clean_objs_ptr(aTHX))
#undef  PL_in_eval
#define PL_in_eval		(*Perl_Iin_eval_ptr(aTHX))
#undef  PL_in_load_module
#define PL_in_load_module	(*Perl_Iin_load_module_ptr(aTHX))
#undef  PL_incgv
#define PL_incgv		(*Perl_Iincgv_ptr(aTHX))
#undef  PL_initav
#define PL_initav		(*Perl_Iinitav_ptr(aTHX))
#undef  PL_inplace
#define PL_inplace		(*Perl_Iinplace_ptr(aTHX))
#undef  PL_isarev
#define PL_isarev		(*Perl_Iisarev_ptr(aTHX))
#undef  PL_known_layers
#define PL_known_layers		(*Perl_Iknown_layers_ptr(aTHX))
#undef  PL_last_in_gv
#define PL_last_in_gv		(*Perl_Ilast_in_gv_ptr(aTHX))
#undef  PL_last_swash_hv
#define PL_last_swash_hv	(*Perl_Ilast_swash_hv_ptr(aTHX))
#undef  PL_last_swash_key
#define PL_last_swash_key	(*Perl_Ilast_swash_key_ptr(aTHX))
#undef  PL_last_swash_klen
#define PL_last_swash_klen	(*Perl_Ilast_swash_klen_ptr(aTHX))
#undef  PL_last_swash_slen
#define PL_last_swash_slen	(*Perl_Ilast_swash_slen_ptr(aTHX))
#undef  PL_last_swash_tmps
#define PL_last_swash_tmps	(*Perl_Ilast_swash_tmps_ptr(aTHX))
#undef  PL_lastfd
#define PL_lastfd		(*Perl_Ilastfd_ptr(aTHX))
#undef  PL_lastgotoprobe
#define PL_lastgotoprobe	(*Perl_Ilastgotoprobe_ptr(aTHX))
#undef  PL_lastscream
#define PL_lastscream		(*Perl_Ilastscream_ptr(aTHX))
#undef  PL_laststatval
#define PL_laststatval		(*Perl_Ilaststatval_ptr(aTHX))
#undef  PL_laststype
#define PL_laststype		(*Perl_Ilaststype_ptr(aTHX))
#undef  PL_localizing
#define PL_localizing		(*Perl_Ilocalizing_ptr(aTHX))
#undef  PL_localpatches
#define PL_localpatches		(*Perl_Ilocalpatches_ptr(aTHX))
#undef  PL_lockhook
#define PL_lockhook		(*Perl_Ilockhook_ptr(aTHX))
#undef  PL_madskills
#define PL_madskills		(*Perl_Imadskills_ptr(aTHX))
#undef  PL_main_cv
#define PL_main_cv		(*Perl_Imain_cv_ptr(aTHX))
#undef  PL_main_root
#define PL_main_root		(*Perl_Imain_root_ptr(aTHX))
#undef  PL_main_start
#define PL_main_start		(*Perl_Imain_start_ptr(aTHX))
#undef  PL_mainstack
#define PL_mainstack		(*Perl_Imainstack_ptr(aTHX))
#undef  PL_markstack
#define PL_markstack		(*Perl_Imarkstack_ptr(aTHX))
#undef  PL_markstack_max
#define PL_markstack_max	(*Perl_Imarkstack_max_ptr(aTHX))
#undef  PL_markstack_ptr
#define PL_markstack_ptr	(*Perl_Imarkstack_ptr_ptr(aTHX))
#undef  PL_max_intro_pending
#define PL_max_intro_pending	(*Perl_Imax_intro_pending_ptr(aTHX))
#undef  PL_maxo
#define PL_maxo			(*Perl_Imaxo_ptr(aTHX))
#undef  PL_maxscream
#define PL_maxscream		(*Perl_Imaxscream_ptr(aTHX))
#undef  PL_maxsysfd
#define PL_maxsysfd		(*Perl_Imaxsysfd_ptr(aTHX))
#undef  PL_memory_debug_header
#define PL_memory_debug_header	(*Perl_Imemory_debug_header_ptr(aTHX))
#undef  PL_mess_sv
#define PL_mess_sv		(*Perl_Imess_sv_ptr(aTHX))
#undef  PL_min_intro_pending
#define PL_min_intro_pending	(*Perl_Imin_intro_pending_ptr(aTHX))
#undef  PL_minus_E
#define PL_minus_E		(*Perl_Iminus_E_ptr(aTHX))
#undef  PL_minus_F
#define PL_minus_F		(*Perl_Iminus_F_ptr(aTHX))
#undef  PL_minus_a
#define PL_minus_a		(*Perl_Iminus_a_ptr(aTHX))
#undef  PL_minus_c
#define PL_minus_c		(*Perl_Iminus_c_ptr(aTHX))
#undef  PL_minus_l
#define PL_minus_l		(*Perl_Iminus_l_ptr(aTHX))
#undef  PL_minus_n
#define PL_minus_n		(*Perl_Iminus_n_ptr(aTHX))
#undef  PL_minus_p
#define PL_minus_p		(*Perl_Iminus_p_ptr(aTHX))
#undef  PL_modcount
#define PL_modcount		(*Perl_Imodcount_ptr(aTHX))
#undef  PL_modglobal
#define PL_modglobal		(*Perl_Imodglobal_ptr(aTHX))
#undef  PL_my_cxt_keys
#define PL_my_cxt_keys		(*Perl_Imy_cxt_keys_ptr(aTHX))
#undef  PL_my_cxt_list
#define PL_my_cxt_list		(*Perl_Imy_cxt_list_ptr(aTHX))
#undef  PL_my_cxt_size
#define PL_my_cxt_size		(*Perl_Imy_cxt_size_ptr(aTHX))
#undef  PL_na
#define PL_na			(*Perl_Ina_ptr(aTHX))
#undef  PL_nice_chunk
#define PL_nice_chunk		(*Perl_Inice_chunk_ptr(aTHX))
#undef  PL_nice_chunk_size
#define PL_nice_chunk_size	(*Perl_Inice_chunk_size_ptr(aTHX))
#undef  PL_nomemok
#define PL_nomemok		(*Perl_Inomemok_ptr(aTHX))
#undef  PL_numeric_local
#define PL_numeric_local	(*Perl_Inumeric_local_ptr(aTHX))
#undef  PL_numeric_name
#define PL_numeric_name		(*Perl_Inumeric_name_ptr(aTHX))
#undef  PL_numeric_radix_sv
#define PL_numeric_radix_sv	(*Perl_Inumeric_radix_sv_ptr(aTHX))
#undef  PL_numeric_standard
#define PL_numeric_standard	(*Perl_Inumeric_standard_ptr(aTHX))
#undef  PL_ofs_sv
#define PL_ofs_sv		(*Perl_Iofs_sv_ptr(aTHX))
#undef  PL_oldname
#define PL_oldname		(*Perl_Ioldname_ptr(aTHX))
#undef  PL_op
#define PL_op			(*Perl_Iop_ptr(aTHX))
#undef  PL_op_mask
#define PL_op_mask		(*Perl_Iop_mask_ptr(aTHX))
#undef  PL_opsave
#define PL_opsave		(*Perl_Iopsave_ptr(aTHX))
#undef  PL_origalen
#define PL_origalen		(*Perl_Iorigalen_ptr(aTHX))
#undef  PL_origargc
#define PL_origargc		(*Perl_Iorigargc_ptr(aTHX))
#undef  PL_origargv
#define PL_origargv		(*Perl_Iorigargv_ptr(aTHX))
#undef  PL_origenviron
#define PL_origenviron		(*Perl_Iorigenviron_ptr(aTHX))
#undef  PL_origfilename
#define PL_origfilename		(*Perl_Iorigfilename_ptr(aTHX))
#undef  PL_ors_sv
#define PL_ors_sv		(*Perl_Iors_sv_ptr(aTHX))
#undef  PL_osname
#define PL_osname		(*Perl_Iosname_ptr(aTHX))
#undef  PL_pad_reset_pending
#define PL_pad_reset_pending	(*Perl_Ipad_reset_pending_ptr(aTHX))
#undef  PL_padix
#define PL_padix		(*Perl_Ipadix_ptr(aTHX))
#undef  PL_padix_floor
#define PL_padix_floor		(*Perl_Ipadix_floor_ptr(aTHX))
#undef  PL_parser
#define PL_parser		(*Perl_Iparser_ptr(aTHX))
#undef  PL_patchlevel
#define PL_patchlevel		(*Perl_Ipatchlevel_ptr(aTHX))
#undef  PL_peepp
#define PL_peepp		(*Perl_Ipeepp_ptr(aTHX))
#undef  PL_perl_destruct_level
#define PL_perl_destruct_level	(*Perl_Iperl_destruct_level_ptr(aTHX))
#undef  PL_perldb
#define PL_perldb		(*Perl_Iperldb_ptr(aTHX))
#undef  PL_perlio
#define PL_perlio		(*Perl_Iperlio_ptr(aTHX))
#undef  PL_pidstatus
#define PL_pidstatus		(*Perl_Ipidstatus_ptr(aTHX))
#undef  PL_ppid
#define PL_ppid			(*Perl_Ippid_ptr(aTHX))
#undef  PL_preambleav
#define PL_preambleav		(*Perl_Ipreambleav_ptr(aTHX))
#undef  PL_preprocess
#define PL_preprocess		(*Perl_Ipreprocess_ptr(aTHX))
#undef  PL_profiledata
#define PL_profiledata		(*Perl_Iprofiledata_ptr(aTHX))
#undef  PL_psig_name
#define PL_psig_name		(*Perl_Ipsig_name_ptr(aTHX))
#undef  PL_psig_pend
#define PL_psig_pend		(*Perl_Ipsig_pend_ptr(aTHX))
#undef  PL_psig_ptr
#define PL_psig_ptr		(*Perl_Ipsig_ptr_ptr(aTHX))
#undef  PL_ptr_table
#define PL_ptr_table		(*Perl_Iptr_table_ptr(aTHX))
#undef  PL_reentrant_buffer
#define PL_reentrant_buffer	(*Perl_Ireentrant_buffer_ptr(aTHX))
#undef  PL_reentrant_retint
#define PL_reentrant_retint	(*Perl_Ireentrant_retint_ptr(aTHX))
#undef  PL_reg_state
#define PL_reg_state		(*Perl_Ireg_state_ptr(aTHX))
#undef  PL_regdummy
#define PL_regdummy		(*Perl_Iregdummy_ptr(aTHX))
#undef  PL_regex_pad
#define PL_regex_pad		(*Perl_Iregex_pad_ptr(aTHX))
#undef  PL_regex_padav
#define PL_regex_padav		(*Perl_Iregex_padav_ptr(aTHX))
#undef  PL_reginterp_cnt
#define PL_reginterp_cnt	(*Perl_Ireginterp_cnt_ptr(aTHX))
#undef  PL_regmatch_slab
#define PL_regmatch_slab	(*Perl_Iregmatch_slab_ptr(aTHX))
#undef  PL_regmatch_state
#define PL_regmatch_state	(*Perl_Iregmatch_state_ptr(aTHX))
#undef  PL_rehash_seed
#define PL_rehash_seed		(*Perl_Irehash_seed_ptr(aTHX))
#undef  PL_rehash_seed_set
#define PL_rehash_seed_set	(*Perl_Irehash_seed_set_ptr(aTHX))
#undef  PL_replgv
#define PL_replgv		(*Perl_Ireplgv_ptr(aTHX))
#undef  PL_restartop
#define PL_restartop		(*Perl_Irestartop_ptr(aTHX))
#undef  PL_rs
#define PL_rs			(*Perl_Irs_ptr(aTHX))
#undef  PL_runops
#define PL_runops		(*Perl_Irunops_ptr(aTHX))
#undef  PL_savebegin
#define PL_savebegin		(*Perl_Isavebegin_ptr(aTHX))
#undef  PL_savestack
#define PL_savestack		(*Perl_Isavestack_ptr(aTHX))
#undef  PL_savestack_ix
#define PL_savestack_ix		(*Perl_Isavestack_ix_ptr(aTHX))
#undef  PL_savestack_max
#define PL_savestack_max	(*Perl_Isavestack_max_ptr(aTHX))
#undef  PL_sawampersand
#define PL_sawampersand		(*Perl_Isawampersand_ptr(aTHX))
#undef  PL_scopestack
#define PL_scopestack		(*Perl_Iscopestack_ptr(aTHX))
#undef  PL_scopestack_ix
#define PL_scopestack_ix	(*Perl_Iscopestack_ix_ptr(aTHX))
#undef  PL_scopestack_max
#define PL_scopestack_max	(*Perl_Iscopestack_max_ptr(aTHX))
#undef  PL_screamfirst
#define PL_screamfirst		(*Perl_Iscreamfirst_ptr(aTHX))
#undef  PL_screamnext
#define PL_screamnext		(*Perl_Iscreamnext_ptr(aTHX))
#undef  PL_secondgv
#define PL_secondgv		(*Perl_Isecondgv_ptr(aTHX))
#undef  PL_sharehook
#define PL_sharehook		(*Perl_Isharehook_ptr(aTHX))
#undef  PL_sig_pending
#define PL_sig_pending		(*Perl_Isig_pending_ptr(aTHX))
#undef  PL_sighandlerp
#define PL_sighandlerp		(*Perl_Isighandlerp_ptr(aTHX))
#undef  PL_signals
#define PL_signals		(*Perl_Isignals_ptr(aTHX))
#undef  PL_slab_count
#define PL_slab_count		(*Perl_Islab_count_ptr(aTHX))
#undef  PL_slabs
#define PL_slabs		(*Perl_Islabs_ptr(aTHX))
#undef  PL_sort_RealCmp
#define PL_sort_RealCmp		(*Perl_Isort_RealCmp_ptr(aTHX))
#undef  PL_sortcop
#define PL_sortcop		(*Perl_Isortcop_ptr(aTHX))
#undef  PL_sortstash
#define PL_sortstash		(*Perl_Isortstash_ptr(aTHX))
#undef  PL_splitstr
#define PL_splitstr		(*Perl_Isplitstr_ptr(aTHX))
#undef  PL_srand_called
#define PL_srand_called		(*Perl_Isrand_called_ptr(aTHX))
#undef  PL_stack_base
#define PL_stack_base		(*Perl_Istack_base_ptr(aTHX))
#undef  PL_stack_max
#define PL_stack_max		(*Perl_Istack_max_ptr(aTHX))
#undef  PL_stack_sp
#define PL_stack_sp		(*Perl_Istack_sp_ptr(aTHX))
#undef  PL_start_env
#define PL_start_env		(*Perl_Istart_env_ptr(aTHX))
#undef  PL_stashcache
#define PL_stashcache		(*Perl_Istashcache_ptr(aTHX))
#undef  PL_statbuf
#define PL_statbuf		(*Perl_Istatbuf_ptr(aTHX))
#undef  PL_statcache
#define PL_statcache		(*Perl_Istatcache_ptr(aTHX))
#undef  PL_statgv
#define PL_statgv		(*Perl_Istatgv_ptr(aTHX))
#undef  PL_statname
#define PL_statname		(*Perl_Istatname_ptr(aTHX))
#undef  PL_statusvalue
#define PL_statusvalue		(*Perl_Istatusvalue_ptr(aTHX))
#undef  PL_statusvalue_posix
#define PL_statusvalue_posix	(*Perl_Istatusvalue_posix_ptr(aTHX))
#undef  PL_statusvalue_vms
#define PL_statusvalue_vms	(*Perl_Istatusvalue_vms_ptr(aTHX))
#undef  PL_stderrgv
#define PL_stderrgv		(*Perl_Istderrgv_ptr(aTHX))
#undef  PL_stdingv
#define PL_stdingv		(*Perl_Istdingv_ptr(aTHX))
#undef  PL_strtab
#define PL_strtab		(*Perl_Istrtab_ptr(aTHX))
#undef  PL_sub_generation
#define PL_sub_generation	(*Perl_Isub_generation_ptr(aTHX))
#undef  PL_subline
#define PL_subline		(*Perl_Isubline_ptr(aTHX))
#undef  PL_subname
#define PL_subname		(*Perl_Isubname_ptr(aTHX))
#undef  PL_sv_arenaroot
#define PL_sv_arenaroot		(*Perl_Isv_arenaroot_ptr(aTHX))
#undef  PL_sv_count
#define PL_sv_count		(*Perl_Isv_count_ptr(aTHX))
#undef  PL_sv_no
#define PL_sv_no		(*Perl_Isv_no_ptr(aTHX))
#undef  PL_sv_objcount
#define PL_sv_objcount		(*Perl_Isv_objcount_ptr(aTHX))
#undef  PL_sv_root
#define PL_sv_root		(*Perl_Isv_root_ptr(aTHX))
#undef  PL_sv_undef
#define PL_sv_undef		(*Perl_Isv_undef_ptr(aTHX))
#undef  PL_sv_yes
#define PL_sv_yes		(*Perl_Isv_yes_ptr(aTHX))
#undef  PL_sys_intern
#define PL_sys_intern		(*Perl_Isys_intern_ptr(aTHX))
#undef  PL_taint_warn
#define PL_taint_warn		(*Perl_Itaint_warn_ptr(aTHX))
#undef  PL_tainted
#define PL_tainted		(*Perl_Itainted_ptr(aTHX))
#undef  PL_tainting
#define PL_tainting		(*Perl_Itainting_ptr(aTHX))
#undef  PL_threadhook
#define PL_threadhook		(*Perl_Ithreadhook_ptr(aTHX))
#undef  PL_timesbuf
#define PL_timesbuf		(*Perl_Itimesbuf_ptr(aTHX))
#undef  PL_tmps_floor
#define PL_tmps_floor		(*Perl_Itmps_floor_ptr(aTHX))
#undef  PL_tmps_ix
#define PL_tmps_ix		(*Perl_Itmps_ix_ptr(aTHX))
#undef  PL_tmps_max
#define PL_tmps_max		(*Perl_Itmps_max_ptr(aTHX))
#undef  PL_tmps_stack
#define PL_tmps_stack		(*Perl_Itmps_stack_ptr(aTHX))
#undef  PL_top_env
#define PL_top_env		(*Perl_Itop_env_ptr(aTHX))
#undef  PL_toptarget
#define PL_toptarget		(*Perl_Itoptarget_ptr(aTHX))
#undef  PL_uid
#define PL_uid			(*Perl_Iuid_ptr(aTHX))
#undef  PL_unicode
#define PL_unicode		(*Perl_Iunicode_ptr(aTHX))
#undef  PL_unitcheckav
#define PL_unitcheckav		(*Perl_Iunitcheckav_ptr(aTHX))
#undef  PL_unitcheckav_save
#define PL_unitcheckav_save	(*Perl_Iunitcheckav_save_ptr(aTHX))
#undef  PL_unlockhook
#define PL_unlockhook		(*Perl_Iunlockhook_ptr(aTHX))
#undef  PL_unsafe
#define PL_unsafe		(*Perl_Iunsafe_ptr(aTHX))
#undef  PL_utf8_alnum
#define PL_utf8_alnum		(*Perl_Iutf8_alnum_ptr(aTHX))
#undef  PL_utf8_alnumc
#define PL_utf8_alnumc		(*Perl_Iutf8_alnumc_ptr(aTHX))
#undef  PL_utf8_alpha
#define PL_utf8_alpha		(*Perl_Iutf8_alpha_ptr(aTHX))
#undef  PL_utf8_ascii
#define PL_utf8_ascii		(*Perl_Iutf8_ascii_ptr(aTHX))
#undef  PL_utf8_cntrl
#define PL_utf8_cntrl		(*Perl_Iutf8_cntrl_ptr(aTHX))
#undef  PL_utf8_digit
#define PL_utf8_digit		(*Perl_Iutf8_digit_ptr(aTHX))
#undef  PL_utf8_graph
#define PL_utf8_graph		(*Perl_Iutf8_graph_ptr(aTHX))
#undef  PL_utf8_idcont
#define PL_utf8_idcont		(*Perl_Iutf8_idcont_ptr(aTHX))
#undef  PL_utf8_idstart
#define PL_utf8_idstart		(*Perl_Iutf8_idstart_ptr(aTHX))
#undef  PL_utf8_lower
#define PL_utf8_lower		(*Perl_Iutf8_lower_ptr(aTHX))
#undef  PL_utf8_mark
#define PL_utf8_mark		(*Perl_Iutf8_mark_ptr(aTHX))
#undef  PL_utf8_print
#define PL_utf8_print		(*Perl_Iutf8_print_ptr(aTHX))
#undef  PL_utf8_punct
#define PL_utf8_punct		(*Perl_Iutf8_punct_ptr(aTHX))
#undef  PL_utf8_space
#define PL_utf8_space		(*Perl_Iutf8_space_ptr(aTHX))
#undef  PL_utf8_tofold
#define PL_utf8_tofold		(*Perl_Iutf8_tofold_ptr(aTHX))
#undef  PL_utf8_tolower
#define PL_utf8_tolower		(*Perl_Iutf8_tolower_ptr(aTHX))
#undef  PL_utf8_totitle
#define PL_utf8_totitle		(*Perl_Iutf8_totitle_ptr(aTHX))
#undef  PL_utf8_toupper
#define PL_utf8_toupper		(*Perl_Iutf8_toupper_ptr(aTHX))
#undef  PL_utf8_upper
#define PL_utf8_upper		(*Perl_Iutf8_upper_ptr(aTHX))
#undef  PL_utf8_xdigit
#define PL_utf8_xdigit		(*Perl_Iutf8_xdigit_ptr(aTHX))
#undef  PL_utf8cache
#define PL_utf8cache		(*Perl_Iutf8cache_ptr(aTHX))
#undef  PL_utf8locale
#define PL_utf8locale		(*Perl_Iutf8locale_ptr(aTHX))
#undef  PL_warnhook
#define PL_warnhook		(*Perl_Iwarnhook_ptr(aTHX))
#undef  PL_watchaddr
#define PL_watchaddr		(*Perl_Iwatchaddr_ptr(aTHX))
#undef  PL_watchok
#define PL_watchok		(*Perl_Iwatchok_ptr(aTHX))
#undef  PL_xmlfp
#define PL_xmlfp		(*Perl_Ixmlfp_ptr(aTHX))
#undef  PL_No
#define PL_No			(*Perl_GNo_ptr(NULL))
#undef  PL_Yes
#define PL_Yes			(*Perl_GYes_ptr(NULL))
#undef  PL_appctx
#define PL_appctx		(*Perl_Gappctx_ptr(NULL))
#undef  PL_check
#define PL_check		(*Perl_Gcheck_ptr(NULL))
#undef  PL_csighandlerp
#define PL_csighandlerp		(*Perl_Gcsighandlerp_ptr(NULL))
#undef  PL_curinterp
#define PL_curinterp		(*Perl_Gcurinterp_ptr(NULL))
#undef  PL_do_undump
#define PL_do_undump		(*Perl_Gdo_undump_ptr(NULL))
#undef  PL_dollarzero_mutex
#define PL_dollarzero_mutex	(*Perl_Gdollarzero_mutex_ptr(NULL))
#undef  PL_fold_locale
#define PL_fold_locale		(*Perl_Gfold_locale_ptr(NULL))
#undef  PL_global_struct_size
#define PL_global_struct_size	(*Perl_Gglobal_struct_size_ptr(NULL))
#undef  PL_hexdigit
#define PL_hexdigit		(*Perl_Ghexdigit_ptr(NULL))
#undef  PL_hints_mutex
#define PL_hints_mutex		(*Perl_Ghints_mutex_ptr(NULL))
#undef  PL_interp_size
#define PL_interp_size		(*Perl_Ginterp_size_ptr(NULL))
#undef  PL_interp_size_5_10_0
#define PL_interp_size_5_10_0	(*Perl_Ginterp_size_5_10_0_ptr(NULL))
#undef  PL_malloc_mutex
#define PL_malloc_mutex		(*Perl_Gmalloc_mutex_ptr(NULL))
#undef  PL_mmap_page_size
#define PL_mmap_page_size	(*Perl_Gmmap_page_size_ptr(NULL))
#undef  PL_my_ctx_mutex
#define PL_my_ctx_mutex		(*Perl_Gmy_ctx_mutex_ptr(NULL))
#undef  PL_my_cxt_index
#define PL_my_cxt_index		(*Perl_Gmy_cxt_index_ptr(NULL))
#undef  PL_op_mutex
#define PL_op_mutex		(*Perl_Gop_mutex_ptr(NULL))
#undef  PL_op_seq
#define PL_op_seq		(*Perl_Gop_seq_ptr(NULL))
#undef  PL_op_sequence
#define PL_op_sequence		(*Perl_Gop_sequence_ptr(NULL))
#undef  PL_patleave
#define PL_patleave		(*Perl_Gpatleave_ptr(NULL))
#undef  PL_perlio_debug_fd
#define PL_perlio_debug_fd	(*Perl_Gperlio_debug_fd_ptr(NULL))
#undef  PL_perlio_fd_refcnt
#define PL_perlio_fd_refcnt	(*Perl_Gperlio_fd_refcnt_ptr(NULL))
#undef  PL_perlio_fd_refcnt_size
#define PL_perlio_fd_refcnt_size	(*Perl_Gperlio_fd_refcnt_size_ptr(NULL))
#undef  PL_perlio_mutex
#define PL_perlio_mutex		(*Perl_Gperlio_mutex_ptr(NULL))
#undef  PL_ppaddr
#define PL_ppaddr		(*Perl_Gppaddr_ptr(NULL))
#undef  PL_revision
#define PL_revision		(*Perl_Grevision_ptr(NULL))
#undef  PL_runops_dbg
#define PL_runops_dbg		(*Perl_Grunops_dbg_ptr(NULL))
#undef  PL_runops_std
#define PL_runops_std		(*Perl_Grunops_std_ptr(NULL))
#undef  PL_sh_path
#define PL_sh_path		(*Perl_Gsh_path_ptr(NULL))
#undef  PL_sig_defaulting
#define PL_sig_defaulting	(*Perl_Gsig_defaulting_ptr(NULL))
#undef  PL_sig_handlers_initted
#define PL_sig_handlers_initted	(*Perl_Gsig_handlers_initted_ptr(NULL))
#undef  PL_sig_ignoring
#define PL_sig_ignoring		(*Perl_Gsig_ignoring_ptr(NULL))
#undef  PL_sig_sv
#define PL_sig_sv		(*Perl_Gsig_sv_ptr(NULL))
#undef  PL_sig_trapped
#define PL_sig_trapped		(*Perl_Gsig_trapped_ptr(NULL))
#undef  PL_sigfpe_saved
#define PL_sigfpe_saved		(*Perl_Gsigfpe_saved_ptr(NULL))
#undef  PL_subversion
#define PL_subversion		(*Perl_Gsubversion_ptr(NULL))
#undef  PL_sv_placeholder
#define PL_sv_placeholder	(*Perl_Gsv_placeholder_ptr(NULL))
#undef  PL_thr_key
#define PL_thr_key		(*Perl_Gthr_key_ptr(NULL))
#undef  PL_timesbase
#define PL_timesbase		(*Perl_Gtimesbase_ptr(NULL))
#undef  PL_use_safe_putenv
#define PL_use_safe_putenv	(*Perl_Guse_safe_putenv_ptr(NULL))
#undef  PL_version
#define PL_version		(*Perl_Gversion_ptr(NULL))
#undef  PL_veto_cleanup
#define PL_veto_cleanup		(*Perl_Gveto_cleanup_ptr(NULL))
#undef  PL_watch_pvx
#define PL_watch_pvx		(*Perl_Gwatch_pvx_ptr(NULL))

#endif /* !PERL_CORE */
#endif /* MULTIPLICITY */

#endif /* __perlapi_h__ */

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perl.h ===
/*    perl.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef H_PERL
#define H_PERL 1

#ifdef PERL_FOR_X2P
/*
 * This file is being used for x2p stuff.
 * Above symbol is defined via -D in 'x2p/Makefile.SH'
 * Decouple x2p stuff from some of perls more extreme eccentricities.
 */
#undef MULTIPLICITY
#undef USE_STDIO
#define USE_STDIO
#endif /* PERL_FOR_X2P */

#if defined(DGUX)
#include <sys/fcntl.h>
#endif

#ifdef VOIDUSED
#   undef VOIDUSED
#endif 
#define VOIDUSED 1

#ifdef PERL_MICRO
#   include "uconfig.h"
#else
#   ifndef USE_CROSS_COMPILE
#       include "config.h"
#   else
#       include "xconfig.h"
#   endif
#endif

/* See L<perlguts/"The Perl API"> for detailed notes on
 * PERL_IMPLICIT_CONTEXT and PERL_IMPLICIT_SYS */

/* Note that from here --> to <-- the same logic is
 * repeated in makedef.pl, so be certain to update
 * both places when editing. */

#ifdef PERL_IMPLICIT_SYS
/* PERL_IMPLICIT_SYS implies PerlMemShared != PerlMem
   so use slab allocator to avoid lots of MUTEX overhead
 */
#  ifndef PL_OP_SLAB_ALLOC
#    define PL_OP_SLAB_ALLOC
#  endif
#endif

#ifdef USE_ITHREADS
#  if !defined(MULTIPLICITY)
#    define MULTIPLICITY
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  ifndef PERL_GLOBAL_STRUCT
#    define PERL_GLOBAL_STRUCT
#  endif
#endif

#ifdef PERL_GLOBAL_STRUCT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#endif

#ifdef MULTIPLICITY
#  ifndef PERL_IMPLICIT_CONTEXT
#    define PERL_IMPLICIT_CONTEXT
#  endif
#endif

/* undef WIN32 when building on Cygwin (for libwin32) - gph */
#ifdef __CYGWIN__
#   undef WIN32
#   undef _WIN32
#endif

#if defined(__SYMBIAN32__) || (defined(__VC32__) && defined(WINS))
#   ifndef SYMBIAN
#       define SYMBIAN
#   endif
#endif

#ifdef __SYMBIAN32__
#  include "symbian/symbian_proto.h"
#endif

/* Any stack-challenged places.  The limit varies (and often
 * is configurable), but using more than a kilobyte of stack
 * is usually dubious in these systems. */
#if defined(EPOC) || defined(__SYMBIAN32__)
/* EPOC/Symbian: need to work around the SDK features. *
 * On WINS: MS VC5 generates calls to _chkstk,         *
 * if a "large" stack frame is allocated.              *
 * gcc on MARM does not generate calls like these.     */
#   define USE_HEAP_INSTEAD_OF_STACK
#endif

#/* Use the reentrant APIs like localtime_r and getpwent_r */
/* Win32 has naturally threadsafe libraries, no need to use any _r variants. */
#if defined(USE_ITHREADS) && !defined(USE_REENTRANT_API) && !defined(NETWARE) && !defined(WIN32) && !defined(PERL_DARWIN)
#   define USE_REENTRANT_API
#endif

/* <--- here ends the logic shared by perl.h and makedef.pl */

/*
 * PERL_DARWIN for MacOSX (__APPLE__ exists but is not officially sanctioned)
 * (The -DPERL_DARWIN comes from the hints/darwin.sh.)
 * __bsdi__ for BSD/OS
 */
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(PERL_DARWIN) || defined(__bsdi__) || defined(BSD41) || defined(BSD42) || defined(BSD43) || defined(BSD44)
#   ifndef BSDish
#       define BSDish
#   endif
#endif

#ifdef PERL_GLOBAL_STRUCT
#  ifndef PERL_GET_VARS
#    ifdef PERL_GLOBAL_STRUCT_PRIVATE
       extern struct perl_vars* Perl_GetVarsPrivate();
#      define PERL_GET_VARS() Perl_GetVarsPrivate() /* see miniperlmain.c */
#      ifndef PERLIO_FUNCS_CONST
#        define PERLIO_FUNCS_CONST /* Can't have these lying around. */
#      endif
#    else
#      define PERL_GET_VARS() PL_VarsPtr
#    endif
#  endif
#endif

#define pVAR    register struct perl_vars* my_vars PERL_UNUSED_DECL

#ifdef PERL_GLOBAL_STRUCT
#  define dVAR		pVAR    = (struct perl_vars*)PERL_GET_VARS()
#else
#  define dVAR		dNOOP
#endif

#ifdef PERL_IMPLICIT_CONTEXT
#  ifndef MULTIPLICITY
#    define MULTIPLICITY
#  endif
#  define tTHX	PerlInterpreter*
#  define pTHX  register tTHX my_perl PERL_UNUSED_DECL
#  define aTHX	my_perl
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHXa(a)	dVAR; pTHX = (tTHX)a
#  else
#    define dTHXa(a)	pTHX = (tTHX)a
#  endif
#  ifdef PERL_GLOBAL_STRUCT
#    define dTHX		dVAR; pTHX = PERL_GET_THX
#  else
#    define dTHX		pTHX = PERL_GET_THX
#  endif
#  define pTHX_		pTHX,
#  define aTHX_		aTHX,
#  define pTHX_1	2
#  define pTHX_2	3
#  define pTHX_3	4
#  define pTHX_4	5
#  define pTHX_5	6
#  define pTHX_6	7
#  define pTHX_7	8
#  define pTHX_8	9
#  define pTHX_9	10
#  if defined(DEBUGGING) && !defined(PERL_TRACK_MEMPOOL)
#    define PERL_TRACK_MEMPOOL
#  endif
#else
#  undef PERL_TRACK_MEMPOOL
#endif

#define STATIC static
#define CPERLscope(x) x
#define CPERLarg void
#define CPERLarg_
#define _CPERLarg
#define PERL_OBJECT_THIS
#define _PERL_OBJECT_THIS
#define PERL_OBJECT_THIS_
#define CALL_FPTR(fptr) (*fptr)

#define CALLRUNOPS  CALL_FPTR(PL_runops)

#define CALLREGCOMP(sv, flags) Perl_pregcomp(aTHX_ (sv),(flags))

#define CALLREGCOMP_ENG(prog, sv, flags) \
    CALL_FPTR(((prog)->comp))(aTHX_ sv, flags)
#define CALLREGEXEC(prog,stringarg,strend,strbeg,minend,screamer,data,flags) \
    CALL_FPTR((prog)->engine->exec)(aTHX_ (prog),(stringarg),(strend), \
        (strbeg),(minend),(screamer),(data),(flags))
#define CALLREG_INTUIT_START(prog,sv,strpos,strend,flags,data) \
    CALL_FPTR((prog)->engine->intuit)(aTHX_ (prog), (sv), (strpos), \
        (strend),(flags),(data))
#define CALLREG_INTUIT_STRING(prog) \
    CALL_FPTR((prog)->engine->checkstr)(aTHX_ (prog))

#define CALLREG_AS_STR(mg,lp,flags,haseval) \
        Perl_reg_stringify(aTHX_ (mg), (lp), (flags), (haseval))
#define CALLREG_STRINGIFY(mg,lp,flags) CALLREG_AS_STR(mg,lp,flags,0)

#define CALLREGFREE(prog) \
    Perl_pregfree(aTHX_ (prog))

#define CALLREGFREE_PVT(prog) \
    if(prog) CALL_FPTR((prog)->engine->free)(aTHX_ (prog))

#define CALLREG_NUMBUF_FETCH(rx,paren,usesv)                                \
    CALL_FPTR((rx)->engine->numbered_buff_FETCH)(aTHX_ (rx),(paren),(usesv))

#define CALLREG_NUMBUF_STORE(rx,paren,value) \
    CALL_FPTR((rx)->engine->numbered_buff_STORE)(aTHX_ (rx),(paren),(value))

#define CALLREG_NUMBUF_LENGTH(rx,sv,paren)                              \
    CALL_FPTR((rx)->engine->numbered_buff_LENGTH)(aTHX_ (rx),(sv),(paren))

#define CALLREG_NAMED_BUFF_FETCH(rx, key, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_FETCH))

#define CALLREG_NAMED_BUFF_STORE(rx, key, value, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), (value), ((flags) | RXapif_STORE))

#define CALLREG_NAMED_BUFF_DELETE(rx, key, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx),(key), NULL, ((flags) | RXapif_DELETE))

#define CALLREG_NAMED_BUFF_CLEAR(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_CLEAR))

#define CALLREG_NAMED_BUFF_EXISTS(rx, key, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), (key), NULL, ((flags) | RXapif_EXISTS))

#define CALLREG_NAMED_BUFF_FIRSTKEY(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff_iter)(aTHX_ (rx), NULL, ((flags) | RXapif_FIRSTKEY))

#define CALLREG_NAMED_BUFF_NEXTKEY(rx, lastkey, flags) \
    CALL_FPTR((rx)->engine->named_buff_iter)(aTHX_ (rx), (lastkey), ((flags) | RXapif_NEXTKEY))

#define CALLREG_NAMED_BUFF_SCALAR(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, ((flags) | RXapif_SCALAR))

#define CALLREG_NAMED_BUFF_COUNT(rx) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, RXapif_REGNAMES_COUNT)

#define CALLREG_NAMED_BUFF_ALL(rx, flags) \
    CALL_FPTR((rx)->engine->named_buff)(aTHX_ (rx), NULL, NULL, flags)

#define CALLREG_PACKAGE(rx) \
    CALL_FPTR((rx)->engine->qr_package)(aTHX_ (rx))

#if defined(USE_ITHREADS)         
#define CALLREGDUPE(prog,param) \
    Perl_re_dup(aTHX_ (prog),(param))

#define CALLREGDUPE_PVT(prog,param) \
    (prog ? CALL_FPTR((prog)->engine->dupe)(aTHX_ (prog),(param)) \
          : (REGEXP *)NULL) 
#endif





/*
 * Because of backward compatibility reasons the PERL_UNUSED_DECL
 * cannot be changed from postfix to PERL_UNUSED_DECL(x).  Sigh.
 *
 * Note that there are C compilers such as MetroWerks CodeWarrior
 * which do not have an "inlined" way (like the gcc __attribute__) of
 * marking unused variables (they need e.g. a #pragma) and therefore
 * cpp macros like PERL_UNUSED_DECL cannot work for this purpose, even
 * if it were PERL_UNUSED_DECL(x), which it cannot be (see above).
 *
 */

#if defined(__SYMBIAN32__) && defined(__GNUC__)
#  ifdef __cplusplus
#    define PERL_UNUSED_DECL
#  else
#    define PERL_UNUSED_DECL __attribute__((unused))
#  endif
#endif

#ifndef PERL_UNUSED_DECL
#  if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#    define PERL_UNUSED_DECL __attribute__unused__
#  else
#    define PERL_UNUSED_DECL
#  endif
#endif
 
/* gcc -Wall:
 * for silencing unused variables that are actually used most of the time,
 * but we cannot quite get rid of, such as "ax" in PPCODE+noargs xsubs
 */
#ifndef PERL_UNUSED_ARG
#  if defined(lint) && defined(S_SPLINT_S) /* www.splint.org */
#    include <note.h>
#    define PERL_UNUSED_ARG(x) NOTE(ARGUNUSED(x))
#  else
#    define PERL_UNUSED_ARG(x) ((void)x)
#  endif
#endif
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(x) ((void)x)
#endif

#ifdef USE_ITHREADS
#  define PERL_UNUSED_CONTEXT PERL_UNUSED_ARG(my_perl)
#else
#  define PERL_UNUSED_CONTEXT
#endif

#define NOOP /*EMPTY*/(void)0
#if !defined(HASATTRIBUTE_UNUSED) && defined(__cplusplus)
#define dNOOP /*EMPTY*/(void)0 /* Older g++ has no __attribute((unused))__ */
#else
#define dNOOP extern int /*@unused@*/ Perl___notused PERL_UNUSED_DECL
#endif

#ifndef pTHX
/* Don't bother defining tTHX and sTHX; using them outside
 * code guarded by PERL_IMPLICIT_CONTEXT is an error.
 */
#  define pTHX		void
#  define pTHX_
#  define aTHX
#  define aTHX_
#  define dTHXa(a)	dNOOP
#  define dTHX		dNOOP
#  define pTHX_1	1	
#  define pTHX_2	2
#  define pTHX_3	3
#  define pTHX_4	4
#  define pTHX_5	5
#  define pTHX_6	6
#  define pTHX_7	7
#  define pTHX_8	8
#  define pTHX_9	9
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif

/* these are only defined for compatibility; should not be used internally */
#if !defined(pTHXo) && !defined(PERL_CORE)
#  define pTHXo		pTHX
#  define pTHXo_	pTHX_
#  define aTHXo		aTHX
#  define aTHXo_	aTHX_
#  define dTHXo		dTHX
#  define dTHXoa(x)	dTHXa(x)
#endif

#ifndef pTHXx
#  define pTHXx		register PerlInterpreter *my_perl
#  define pTHXx_	pTHXx,
#  define aTHXx		my_perl
#  define aTHXx_	aTHXx,
#  define dTHXx		dTHX
#endif

/* Under PERL_IMPLICIT_SYS (used in Windows for fork emulation)
 * PerlIO_foo() expands to PL_StdIO->pFOO(PL_StdIO, ...).
 * dTHXs is therefore needed for all functions using PerlIO_foo(). */
#ifdef PERL_IMPLICIT_SYS
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR; dTHX
#  else
#    define dTHXs		dTHX
#  endif
#else
#  ifdef PERL_GLOBAL_STRUCT_PRIVATE
#    define dTHXs		dVAR
#  else
#    define dTHXs		dNOOP
#  endif
#endif

#undef START_EXTERN_C
#undef END_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C extern
#endif

/* Some platforms require marking function declarations
 * for them to be exportable.  Used in perlio.h, proto.h
 * is handled either by the makedef.pl or by defining the
 * PERL_CALLCONV to be something special.  See also the
 * definition of XS() in XSUB.h. */
#ifndef PERL_EXPORT_C
#  ifdef __cplusplus
#    define PERL_EXPORT_C extern "C"
#  else
#    define PERL_EXPORT_C extern
#  endif
#endif
#ifndef PERL_XS_EXPORT_C
#  ifdef __cplusplus
#    define PERL_XS_EXPORT_C extern "C"
#  else
#    define PERL_XS_EXPORT_C
#  endif
#endif

#ifdef OP_IN_REGISTER
#  ifdef __GNUC__
#    define stringify_immed(s) #s
#    define stringify(s) stringify_immed(s)
register struct op *Perl_op asm(stringify(OP_IN_REGISTER));
#  endif
#endif

/* gcc (-ansi) -pedantic doesn't allow gcc statement expressions,
 * g++ allows them but seems to have problems with them
 * (insane errors ensue). */
#if defined(PERL_GCC_PEDANTIC) || (defined(__GNUC__) && defined(__cplusplus))
#  ifndef PERL_GCC_BRACE_GROUPS_FORBIDDEN
#    define PERL_GCC_BRACE_GROUPS_FORBIDDEN
#  endif
#endif

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN) && !defined(__cplusplus)
#  ifndef PERL_USE_GCC_BRACE_GROUPS
#    define PERL_USE_GCC_BRACE_GROUPS
#  endif
#endif

/*
 * STMT_START { statements; } STMT_END;
 * can be used as a single statement, as in
 * if (x) STMT_START { ... } STMT_END; else ...
 *
 * Trying to select a version that gives no warnings...
 */
#if !(defined(STMT_START) && defined(STMT_END))
# ifdef PERL_USE_GCC_BRACE_GROUPS
#   define STMT_START	(void)(	/* gcc supports "({ STATEMENTS; })" */
#   define STMT_END	)
# else
   /* Now which other defined()s do we need here ??? */
#  if (VOIDFLAGS) && (defined(sun) || defined(__sun__)) && !defined(__GNUC__)
#   define STMT_START	if (1)
#   define STMT_END	else (void)0
#  else
#   define STMT_START	do
#   define STMT_END	while (0)
#  endif
# endif
#endif

#define WITH_THX(s) STMT_START { dTHX; s; } STMT_END
#define WITH_THR(s) WITH_THX(s)

#ifndef BYTEORDER  /* Should never happen -- byteorder is in config.h */
#   define BYTEORDER 0x1234
#endif

/* Overall memory policy? */
#ifndef CONSERVATIVE
#   define LIBERAL 1
#endif

#if 'A' == 65 && 'I' == 73 && 'J' == 74 && 'Z' == 90
#define ASCIIish
#else
#undef  ASCIIish
#endif

/*
 * The following contortions are brought to you on behalf of all the
 * standards, semi-standards, de facto standards, not-so-de-facto standards
 * of the world, as well as all the other botches anyone ever thought of.
 * The basic theory is that if we work hard enough here, the rest of the
 * code can be a lot prettier.  Well, so much for theory.  Sorry, Henry...
 */

/* define this once if either system, instead of cluttering up the src */
#if defined(MSDOS) || defined(atarist) || defined(WIN32) || defined(NETWARE)
#define DOSISH 1
#endif

#if defined(__STDC__) || defined(_AIX) || defined(__stdc__) || defined(__cplusplus) || defined(EPOC) || defined(NETWARE) || defined(__SYMBIAN32__)
# define STANDARD_C 1
#endif

#if defined(__cplusplus) || defined(WIN32) || defined(__sgi) || defined(__EMX__) || defined(__DGUX) || defined(EPOC) || defined(__QNX__) || defined(NETWARE) || defined(PERL_MICRO)
# define DONT_DECLARE_STD 1
#endif

#if defined(HASVOLATILE) || defined(STANDARD_C)
#   ifdef __cplusplus
#	define VOL		/* to temporarily suppress warnings */
#   else
#	define VOL volatile
#   endif
#else
#   define VOL
#endif

#define TAINT		(PL_tainted = TRUE)
#define TAINT_NOT	(PL_tainted = FALSE)
#define TAINT_IF(c)	if (c) { PL_tainted = TRUE; }
#define TAINT_ENV()	if (PL_tainting) { taint_env(); }
#define TAINT_PROPER(s)	if (PL_tainting) { taint_proper(NULL, s); }

/* XXX All process group stuff is handled in pp_sys.c.  Should these
   defines move there?  If so, I could simplify this a lot. --AD  9/96.
*/
/* Process group stuff changed from traditional BSD to POSIX.
   perlfunc.pod documents the traditional BSD-style syntax, so we'll
   try to preserve that, if possible.
*/
#ifdef HAS_SETPGID
#  define BSD_SETPGRP(pid, pgrp)	setpgid((pid), (pgrp))
#else
#  if defined(HAS_SETPGRP) && defined(USE_BSD_SETPGRP)
#    define BSD_SETPGRP(pid, pgrp)	setpgrp((pid), (pgrp))
#  else
#    ifdef HAS_SETPGRP2  /* DG/UX */
#      define BSD_SETPGRP(pid, pgrp)	setpgrp2((pid), (pgrp))
#    endif
#  endif
#endif
#if defined(BSD_SETPGRP) && !defined(HAS_SETPGRP)
#  define HAS_SETPGRP  /* Well, effectively it does . . . */
#endif

/* getpgid isn't POSIX, but at least Solaris and Linux have it, and it makes
    our life easier :-) so we'll try it.
*/
#ifdef HAS_GETPGID
#  define BSD_GETPGRP(pid)		getpgid((pid))
#else
#  if defined(HAS_GETPGRP) && defined(USE_BSD_GETPGRP)
#    define BSD_GETPGRP(pid)		getpgrp((pid))
#  else
#    ifdef HAS_GETPGRP2  /* DG/UX */
#      define BSD_GETPGRP(pid)		getpgrp2((pid))
#    endif
#  endif
#endif
#if defined(BSD_GETPGRP) && !defined(HAS_GETPGRP)
#  define HAS_GETPGRP  /* Well, effectively it does . . . */
#endif

/* These are not exact synonyms, since setpgrp() and getpgrp() may
   have different behaviors, but perl.h used to define USE_BSDPGRP
   (prior to 5.003_05) so some extension might depend on it.
*/
#if defined(USE_BSD_SETPGRP) || defined(USE_BSD_GETPGRP)
#  ifndef USE_BSDPGRP
#    define USE_BSDPGRP
#  endif
#endif

/* HP-UX 10.X CMA (Common Multithreaded Architecure) insists that
   pthread.h must be included before all other header files.
*/
#if defined(USE_ITHREADS) && defined(PTHREAD_H_FIRST) && defined(I_PTHREAD)
#  include <pthread.h>
#endif

#ifndef _TYPES_		/* If types.h defines this it's easy. */
#   ifndef major		/* Does everyone's types.h define this? */
#	include <sys/types.h>
#   endif
#endif

#ifdef __cplusplus
#  ifndef I_STDARG
#    define I_STDARG 1
#  endif
#endif

#ifdef I_STDARG
#  include <stdarg.h>
#else
#  ifdef I_VARARGS
#    include <varargs.h>
#  endif
#endif

#ifdef USE_NEXT_CTYPE

#if NX_CURRENT_COMPILER_RELEASE >= 500
#  include <bsd/ctypes.h>
#else
#  if NX_CURRENT_COMPILER_RELEASE >= 400
#    include <objc/NXCType.h>
#  else /*  NX_CURRENT_COMPILER_RELEASE < 400 */
#    include <appkit/NXCType.h>
#  endif /*  NX_CURRENT_COMPILER_RELEASE >= 400 */
#endif /*  NX_CURRENT_COMPILER_RELEASE >= 500 */

#else /* !USE_NEXT_CTYPE */
#include <ctype.h>
#endif /* USE_NEXT_CTYPE */

#ifdef METHOD 	/* Defined by OSF/1 v3.0 by ctype.h */
#undef METHOD
#endif

#ifdef PERL_MICRO
#   define NO_LOCALE
#endif

#ifdef I_LOCALE
#   include <locale.h>
#endif

#if !defined(NO_LOCALE) && defined(HAS_SETLOCALE)
#   define USE_LOCALE
#   if !defined(NO_LOCALE_COLLATE) && defined(LC_COLLATE) \
       && defined(HAS_STRXFRM)
#	define USE_LOCALE_COLLATE
#   endif
#   if !defined(NO_LOCALE_CTYPE) && defined(LC_CTYPE)
#	define USE_LOCALE_CTYPE
#   endif
#   if !defined(NO_LOCALE_NUMERIC) && defined(LC_NUMERIC)
#	define USE_LOCALE_NUMERIC
#   endif
#endif /* !NO_LOCALE && HAS_SETLOCALE */

#include <setjmp.h>

#ifdef I_SYS_PARAM
#   ifdef PARAM_NEEDS_TYPES
#	include <sys/types.h>
#   endif
#   include <sys/param.h>
#endif

/* Use all the "standard" definitions? */
#if defined(STANDARD_C) && defined(I_STDLIB)
#   include <stdlib.h>
#endif

/* If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#   include <unistd.h>
#endif

#ifdef __SYMBIAN32__
#   undef _SC_ARG_MAX /* Symbian has _SC_ARG_MAX but no sysconf() */
#endif

#if defined(HAS_SYSCALL) && !defined(HAS_SYSCALL_PROTO) && !defined(PERL_MICRO)
EXTERN_C int syscall(int, ...);
#endif

#if defined(HAS_USLEEP) && !defined(HAS_USLEEP_PROTO) && !defined(PERL_MICRO)
EXTERN_C int usleep(unsigned int);
#endif

/* Funky places that do not have socket stuff. */
#if defined(__LIBCATAMOUNT__)
#  define MYSWAP
#endif

#ifdef PERL_MICRO /* Last chance to export Perl_my_swap */
#  define MYSWAP
#endif

#ifdef PERL_CORE

/* macros for correct constant construction */
# if INTSIZE >= 2
#  define U16_CONST(x) ((U16)x##U)
# else
#  define U16_CONST(x) ((U16)x##UL)
# endif

# if INTSIZE >= 4
#  define U32_CONST(x) ((U32)x##U)
# else
#  define U32_CONST(x) ((U32)x##UL)
# endif

# ifdef HAS_QUAD
#  if INTSIZE >= 8
#   define U64_CONST(x) ((U64)x##U)
#  elif LONGSIZE >= 8
#   define U64_CONST(x) ((U64)x##UL)
#  elif QUADKIND == QUAD_IS_LONG_LONG
#   define U64_CONST(x) ((U64)x##ULL)
#  else /* best guess we can make */
#   define U64_CONST(x) ((U64)x##UL)
#  endif
# endif

/* byte-swapping functions for big-/little-endian conversion */
# define _swab_16_(x) ((U16)( \
         (((U16)(x) & U16_CONST(0x00ff)) << 8) | \
         (((U16)(x) & U16_CONST(0xff00)) >> 8) ))

# define _swab_32_(x) ((U32)( \
         (((U32)(x) & U32_CONST(0x000000ff)) << 24) | \
         (((U32)(x) & U32_CONST(0x0000ff00)) <<  8) | \
         (((U32)(x) & U32_CONST(0x00ff0000)) >>  8) | \
         (((U32)(x) & U32_CONST(0xff000000)) >> 24) ))

# ifdef HAS_QUAD
#  define _swab_64_(x) ((U64)( \
          (((U64)(x) & U64_CONST(0x00000000000000ff)) << 56) | \
          (((U64)(x) & U64_CONST(0x000000000000ff00)) << 40) | \
          (((U64)(x) & U64_CONST(0x0000000000ff0000)) << 24) | \
          (((U64)(x) & U64_CONST(0x00000000ff000000)) <<  8) | \
          (((U64)(x) & U64_CONST(0x000000ff00000000)) >>  8) | \
          (((U64)(x) & U64_CONST(0x0000ff0000000000)) >> 24) | \
          (((U64)(x) & U64_CONST(0x00ff000000000000)) >> 40) | \
          (((U64)(x) & U64_CONST(0xff00000000000000)) >> 56) ))
# endif

/*----------------------------------------------------------------------------*/
# if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678  /*     little-endian     */
/*----------------------------------------------------------------------------*/
#  define my_htole16(x)		(x)
#  define my_letoh16(x)		(x)
#  define my_htole32(x)		(x)
#  define my_letoh32(x)		(x)
#  define my_htobe16(x)		_swab_16_(x)
#  define my_betoh16(x)		_swab_16_(x)
#  define my_htobe32(x)		_swab_32_(x)
#  define my_betoh32(x)		_swab_32_(x)
#  ifdef HAS_QUAD
#   define my_htole64(x)	(x)
#   define my_letoh64(x)	(x)
#   define my_htobe64(x)	_swab_64_(x)
#   define my_betoh64(x)	_swab_64_(x)
#  endif
#  define my_htoles(x)		(x)
#  define my_letohs(x)		(x)
#  define my_htolei(x)		(x)
#  define my_letohi(x)		(x)
#  define my_htolel(x)		(x)
#  define my_letohl(x)		(x)
#  if SHORTSIZE == 1
#   define my_htobes(x)		(x)
#   define my_betohs(x)		(x)
#  elif SHORTSIZE == 2
#   define my_htobes(x)		_swab_16_(x)
#   define my_betohs(x)		_swab_16_(x)
#  elif SHORTSIZE == 4
#   define my_htobes(x)		_swab_32_(x)
#   define my_betohs(x)		_swab_32_(x)
#  elif SHORTSIZE == 8
#   define my_htobes(x)		_swab_64_(x)
#   define my_betohs(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBES
#   define PERL_NEED_MY_BETOHS
#  endif
#  if INTSIZE == 1
#   define my_htobei(x)		(x)
#   define my_betohi(x)		(x)
#  elif INTSIZE == 2
#   define my_htobei(x)		_swab_16_(x)
#   define my_betohi(x)		_swab_16_(x)
#  elif INTSIZE == 4
#   define my_htobei(x)		_swab_32_(x)
#   define my_betohi(x)		_swab_32_(x)
#  elif INTSIZE == 8
#   define my_htobei(x)		_swab_64_(x)
#   define my_betohi(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBEI
#   define PERL_NEED_MY_BETOHI
#  endif
#  if LONGSIZE == 1
#   define my_htobel(x)		(x)
#   define my_betohl(x)		(x)
#  elif LONGSIZE == 2
#   define my_htobel(x)		_swab_16_(x)
#   define my_betohl(x)		_swab_16_(x)
#  elif LONGSIZE == 4
#   define my_htobel(x)		_swab_32_(x)
#   define my_betohl(x)		_swab_32_(x)
#  elif LONGSIZE == 8
#   define my_htobel(x)		_swab_64_(x)
#   define my_betohl(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOBEL
#   define PERL_NEED_MY_BETOHL
#  endif
#  define my_htolen(p,n)	NOOP
#  define my_letohn(p,n)	NOOP
#  define my_htoben(p,n)	my_swabn(p,n)
#  define my_betohn(p,n)	my_swabn(p,n)
/*----------------------------------------------------------------------------*/
# elif BYTEORDER == 0x4321 || BYTEORDER == 0x87654321  /*     big-endian      */
/*----------------------------------------------------------------------------*/
#  define my_htobe16(x)		(x)
#  define my_betoh16(x)		(x)
#  define my_htobe32(x)		(x)
#  define my_betoh32(x)		(x)
#  define my_htole16(x)		_swab_16_(x)
#  define my_letoh16(x)		_swab_16_(x)
#  define my_htole32(x)		_swab_32_(x)
#  define my_letoh32(x)		_swab_32_(x)
#  ifdef HAS_QUAD
#   define my_htobe64(x)	(x)
#   define my_betoh64(x)	(x)
#   define my_htole64(x)	_swab_64_(x)
#   define my_letoh64(x)	_swab_64_(x)
#  endif
#  define my_htobes(x)		(x)
#  define my_betohs(x)		(x)
#  define my_htobei(x)		(x)
#  define my_betohi(x)		(x)
#  define my_htobel(x)		(x)
#  define my_betohl(x)		(x)
#  if SHORTSIZE == 1
#   define my_htoles(x)		(x)
#   define my_letohs(x)		(x)
#  elif SHORTSIZE == 2
#   define my_htoles(x)		_swab_16_(x)
#   define my_letohs(x)		_swab_16_(x)
#  elif SHORTSIZE == 4
#   define my_htoles(x)		_swab_32_(x)
#   define my_letohs(x)		_swab_32_(x)
#  elif SHORTSIZE == 8
#   define my_htoles(x)		_swab_64_(x)
#   define my_letohs(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLES
#   define PERL_NEED_MY_LETOHS
#  endif
#  if INTSIZE == 1
#   define my_htolei(x)		(x)
#   define my_letohi(x)		(x)
#  elif INTSIZE == 2
#   define my_htolei(x)		_swab_16_(x)
#   define my_letohi(x)		_swab_16_(x)
#  elif INTSIZE == 4
#   define my_htolei(x)		_swab_32_(x)
#   define my_letohi(x)		_swab_32_(x)
#  elif INTSIZE == 8
#   define my_htolei(x)		_swab_64_(x)
#   define my_letohi(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLEI
#   define PERL_NEED_MY_LETOHI
#  endif
#  if LONGSIZE == 1
#   define my_htolel(x)		(x)
#   define my_letohl(x)		(x)
#  elif LONGSIZE == 2
#   define my_htolel(x)		_swab_16_(x)
#   define my_letohl(x)		_swab_16_(x)
#  elif LONGSIZE == 4
#   define my_htolel(x)		_swab_32_(x)
#   define my_letohl(x)		_swab_32_(x)
#  elif LONGSIZE == 8
#   define my_htolel(x)		_swab_64_(x)
#   define my_letohl(x)		_swab_64_(x)
#  else
#   define PERL_NEED_MY_HTOLEL
#   define PERL_NEED_MY_LETOHL
#  endif
#  define my_htolen(p,n)	my_swabn(p,n)
#  define my_letohn(p,n)	my_swabn(p,n)
#  define my_htoben(p,n)	NOOP
#  define my_betohn(p,n)	NOOP
/*----------------------------------------------------------------------------*/
# else /*                       all other byte-orders                         */
/*----------------------------------------------------------------------------*/
#  define PERL_NEED_MY_HTOLE16
#  define PERL_NEED_MY_LETOH16
#  define PERL_NEED_MY_HTOBE16
#  define PERL_NEED_MY_BETOH16
#  define PERL_NEED_MY_HTOLE32
#  define PERL_NEED_MY_LETOH32
#  define PERL_NEED_MY_HTOBE32
#  define PERL_NEED_MY_BETOH32
#  ifdef HAS_QUAD
#   define PERL_NEED_MY_HTOLE64
#   define PERL_NEED_MY_LETOH64
#   define PERL_NEED_MY_HTOBE64
#   define PERL_NEED_MY_BETOH64
#  endif
#  define PERL_NEED_MY_HTOLES
#  define PERL_NEED_MY_LETOHS
#  define PERL_NEED_MY_HTOBES
#  define PERL_NEED_MY_BETOHS
#  define PERL_NEED_MY_HTOLEI
#  define PERL_NEED_MY_LETOHI
#  define PERL_NEED_MY_HTOBEI
#  define PERL_NEED_MY_BETOHI
#  define PERL_NEED_MY_HTOLEL
#  define PERL_NEED_MY_LETOHL
#  define PERL_NEED_MY_HTOBEL
#  define PERL_NEED_MY_BETOHL
/*----------------------------------------------------------------------------*/
# endif /*                     end of byte-order macros                       */
/*----------------------------------------------------------------------------*/

/* The old value was hard coded at 1008. (4096-16) seems to be a bit faster,
   at least on FreeBSD.  YMMV, so experiment.  */
#ifndef PERL_ARENA_SIZE
#define PERL_ARENA_SIZE 4080
#endif

#endif /* PERL_CORE */

/* We no longer default to creating a new SV for GvSV.
   Do this before embed.  */
#ifndef PERL_CREATE_GVSV
#  ifndef PERL_DONT_CREATE_GVSV
#    define PERL_DONT_CREATE_GVSV
#  endif
#endif

#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
#define PERL_USES_PL_PIDSTATUS
#endif

#if !defined(OS2) && !defined(WIN32) && !defined(DJGPP) && !defined(EPOC) && !defined(__SYMBIAN32__) && !defined(MACOS_TRADITIONAL)
#define PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#endif

/* Cannot include embed.h here on Win32 as win32.h has not 
   yet been included and defines some config variables e.g. HAVE_INTERP_INTERN
 */
#if !defined(PERL_FOR_X2P) && !(defined(WIN32)||defined(VMS))
#  include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
#endif

#define MEM_SIZE Size_t

/* Round all values passed to malloc up, by default to a multiple of
   sizeof(size_t)
*/
#ifndef PERL_STRLEN_ROUNDUP_QUANTUM
#define PERL_STRLEN_ROUNDUP_QUANTUM Size_t_size
#endif

#if defined(STANDARD_C) && defined(I_STDDEF)
#   include <stddef.h>
#   define STRUCT_OFFSET(s,m)  offsetof(s,m)
#else
#   define STRUCT_OFFSET(s,m)  (Size_t)(&(((s *)0)->m))
#endif

#ifndef __SYMBIAN32__
#  if defined(I_STRING) || defined(__cplusplus)
#     include <string.h>
#  else
#     include <strings.h>
#  endif
#endif

/* This comes after <stdlib.h> so we don't try to change the standard
 * library prototypes; we'll use our own in proto.h instead. */

#ifdef MYMALLOC
#  ifdef PERL_POLLUTE_MALLOC
#   ifndef PERL_EXTMALLOC_DEF
#    define Perl_malloc		malloc
#    define Perl_calloc		calloc
#    define Perl_realloc	realloc
#    define Perl_mfree		free
#   endif
#  else
#    define EMBEDMYMALLOC	/* for compatibility */
#  endif

#  define safemalloc  Perl_malloc
#  define safecalloc  Perl_calloc
#  define saferealloc Perl_realloc
#  define safefree    Perl_mfree
#  define CHECK_MALLOC_TOO_LATE_FOR_(code)	STMT_START {		\
	if (!PL_tainting && MallocCfg_ptr[MallocCfg_cfg_env_read])	\
		code;							\
    } STMT_END
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)				\
	CHECK_MALLOC_TOO_LATE_FOR_(MALLOC_TOO_LATE_FOR(ch))
#  define panic_write2(s)		write(2, s, strlen(s))
#  define CHECK_MALLOC_TAINT(newval)				\
	CHECK_MALLOC_TOO_LATE_FOR_(				\
		if (newval) {					\
		  panic_write2("panic: tainting with $ENV{PERL_MALLOC_OPT}\n");\
		  exit(1); })
#  define MALLOC_CHECK_TAINT(argc,argv,env)	STMT_START {	\
	if (doing_taint(argc,argv,env)) {			\
		MallocCfg_ptr[MallocCfg_skip_cfg_env] = 1;	\
    }} STMT_END;
#else  /* MYMALLOC */
#  define safemalloc  safesysmalloc
#  define safecalloc  safesyscalloc
#  define saferealloc safesysrealloc
#  define safefree    safesysfree
#  define CHECK_MALLOC_TOO_LATE_FOR(ch)		((void)0)
#  define CHECK_MALLOC_TAINT(newval)		((void)0)
#  define MALLOC_CHECK_TAINT(argc,argv,env)
#endif /* MYMALLOC */

#define TOO_LATE_FOR_(ch,what)	Perl_croak(aTHX_ "\"-%c\" is on the #! line, it must also be used on the command line%s", (char)(ch), what)
#define TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, "")
#define MALLOC_TOO_LATE_FOR(ch)	TOO_LATE_FOR_(ch, " with $ENV{PERL_MALLOC_OPT}")
#define MALLOC_CHECK_TAINT2(argc,argv)	MALLOC_CHECK_TAINT(argc,argv,NULL)

#if !defined(HAS_STRCHR) && defined(HAS_INDEX) && !defined(strchr)
#define strchr index
#define strrchr rindex
#endif

#ifdef I_MEMORY
#  include <memory.h>
#endif

#ifdef HAS_MEMCPY
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcpy
        extern char * memcpy (char*, char*, int);
#    endif
#  endif
#else
#   ifndef memcpy
#	ifdef HAS_BCOPY
#	    define memcpy(d,s,l) bcopy(s,d,l)
#	else
#	    define memcpy(d,s,l) my_bcopy(s,d,l)
#	endif
#   endif
#endif /* HAS_MEMCPY */

#ifdef HAS_MEMSET
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memset
	extern char *memset (char*, int, int);
#    endif
#  endif
#else
#  undef  memset
#  define memset(d,c,l) my_memset(d,c,l)
#endif /* HAS_MEMSET */

#if !defined(HAS_MEMMOVE) && !defined(memmove)
#   if defined(HAS_BCOPY) && defined(HAS_SAFE_BCOPY)
#	define memmove(d,s,l) bcopy(s,d,l)
#   else
#	if defined(HAS_MEMCPY) && defined(HAS_SAFE_MEMCPY)
#	    define memmove(d,s,l) memcpy(d,s,l)
#	else
#	    define memmove(d,s,l) my_bcopy(s,d,l)
#	endif
#   endif
#endif

#if defined(mips) && defined(ultrix) && !defined(__STDC__)
#   undef HAS_MEMCMP
#endif

#if defined(HAS_MEMCMP) && defined(HAS_SANE_MEMCMP)
#  if !defined(STANDARD_C) && !defined(I_STRING) && !defined(I_MEMORY)
#    ifndef memcmp
	extern int memcmp (char*, char*, int);
#    endif
#  endif
#  ifdef BUGGY_MSC
#    pragma function(memcmp)
#  endif
#else
#   ifndef memcmp
#	define memcmp 	my_memcmp
#   endif
#endif /* HAS_MEMCMP && HAS_SANE_MEMCMP */

#ifndef memzero
#   ifdef HAS_MEMSET
#	define memzero(d,l) memset(d,0,l)
#   else
#	ifdef HAS_BZERO
#	    define memzero(d,l) bzero(d,l)
#	else
#	    define memzero(d,l) my_bzero(d,l)
#	endif
#   endif
#endif

#ifndef PERL_MICRO
#ifndef memchr
#   ifndef HAS_MEMCHR
#       define memchr(s,c,n) ninstr((char*)(s), ((char*)(s)) + n, &(c), &(c) + 1)
#   endif
#endif
#endif

#ifndef HAS_BCMP
#   ifndef bcmp
#	define bcmp(s1,s2,l) memcmp(s1,s2,l)
#   endif
#endif /* !HAS_BCMP */

#ifdef I_NETINET_IN
#   include <netinet/in.h>
#endif

#ifdef I_ARPA_INET
#   include <arpa/inet.h>
#endif

#if defined(SF_APPEND) && defined(USE_SFIO) && defined(I_SFIO)
/* <sfio.h> defines SF_APPEND and <sys/stat.h> might define SF_APPEND
 * (the neo-BSD seem to do this).  */
#   undef SF_APPEND
#endif

#ifdef I_SYS_STAT
#   include <sys/stat.h>
#endif

/* The stat macros for Amdahl UTS, Unisoft System V/88 (and derivatives
   like UTekV) are broken, sometimes giving false positives.  Undefine
   them here and let the code below set them to proper values.

   The ghs macro stands for GreenHills Software C-1.8.5 which
   is the C compiler for sysV88 and the various derivatives.
   This header file bug is corrected in gcc-2.5.8 and later versions.
   --Kaveh Ghazi (ghazi@noc.rutgers.edu) 10/3/94.  */

#if defined(uts) || (defined(m88k) && defined(ghs))
#   undef S_ISDIR
#   undef S_ISCHR
#   undef S_ISBLK
#   undef S_ISREG
#   undef S_ISFIFO
#   undef S_ISLNK
#endif

#ifdef I_TIME
#   include <time.h>
#endif

#ifdef I_SYS_TIME
#   ifdef I_SYS_TIME_KERNEL
#	define KERNEL
#   endif
#   include <sys/time.h>
#   ifdef I_SYS_TIME_KERNEL
#	undef KERNEL
#   endif
#endif

#if defined(HAS_TIMES) && defined(I_SYS_TIMES)
#    include <sys/times.h>
#endif

#if defined(HAS_STRERROR) && (!defined(HAS_MKDIR) || !defined(HAS_RMDIR))
#   undef HAS_STRERROR
#endif

#include <errno.h>

#if defined(WIN32) && defined(PERL_IMPLICIT_SYS)
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
#endif

/* In Tru64 use the 4.4BSD struct msghdr, not the 4.3 one.
 * This is important for using IPv6. 
 * For OSF/1 3.2, however, defining _SOCKADDR_LEN would be
 * a bad idea since it breaks send() and recv(). */
#if defined(__osf__) && defined(__alpha) && !defined(_SOCKADDR_LEN) && !defined(DEC_OSF1_3_X)
#   define _SOCKADDR_LEN
#endif

#if defined(HAS_SOCKET) && !defined(VMS) && !defined(WIN32) /* VMS/WIN32 handle sockets via vmsish.h/win32.h */
# include <sys/socket.h>
# if defined(USE_SOCKS) && defined(I_SOCKS)
#   if !defined(INCLUDE_PROTOTYPES)
#       define INCLUDE_PROTOTYPES /* for <socks.h> */
#       define PERL_SOCKS_NEED_PROTOTYPES
#   endif
#   include <socks.h>
#   ifdef PERL_SOCKS_NEED_PROTOTYPES /* keep cpp space clean */
#       undef INCLUDE_PROTOTYPES
#       undef PERL_SOCKS_NEED_PROTOTYPES
#   endif
# endif
# ifdef I_NETDB
#  ifdef NETWARE
#   include<stdio.h>
#  endif
#  include <netdb.h>
# endif
# ifndef ENOTSOCK
#  ifdef I_NET_ERRNO
#   include <net/errno.h>
#  endif
# endif
#endif

/* sockatmark() is so new (2001) that many places might have it hidden
 * behind some -D_BLAH_BLAH_SOURCE guard.  The __THROW magic is required
 * e.g. in Gentoo, see http://bugs.gentoo.org/show_bug.cgi?id=12605 */
#if defined(HAS_SOCKATMARK) && !defined(HAS_SOCKATMARK_PROTO)
# if defined(__THROW) && defined(__GLIBC__)
int sockatmark(int) __THROW;
# else
int sockatmark(int);
# endif
#endif

#if defined(__osf__) && defined(__cplusplus) && !defined(_XOPEN_SOURCE_EXTENDED) /* Tru64 "cxx" (C++), see hints/dec_osf.sh for why the _XOPEN_SOURCE_EXTENDED cannot be defined. */
EXTERN_C int fchdir(int);
EXTERN_C int flock(int, int);
EXTERN_C int fseeko(FILE *, off_t, int);
EXTERN_C off_t ftello(FILE *);
#endif

#if defined(__SUNPRO_CC) /* SUNWspro CC (C++) */
EXTERN_C char *crypt(const char *, const char *);
EXTERN_C char **environ;
#endif

#if defined(__cplusplus)
#  if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
EXTERN_C char **environ;
#  elif defined(__CYGWIN__)
EXTERN_C char *crypt(const char *, const char *);
#endif
#endif

#ifdef SETERRNO
# undef SETERRNO  /* SOCKS might have defined this */
#endif

#ifdef VMS
#   define SETERRNO(errcode,vmserrcode) \
	STMT_START {			\
	    set_errno(errcode);		\
	    set_vaxc_errno(vmserrcode);	\
	} STMT_END
#   define LIB_INVARG 		LIB$_INVARG
#   define RMS_DIR    		RMS$_DIR
#   define RMS_FAC    		RMS$_FAC
#   define RMS_FEX    		RMS$_FEX
#   define RMS_FNF    		RMS$_FNF
#   define RMS_IFI    		RMS$_IFI
#   define RMS_ISI    		RMS$_ISI
#   define RMS_PRV    		RMS$_PRV
#   define SS_ACCVIO      	SS$_ACCVIO
#   define SS_DEVOFFLINE	SS$_DEVOFFLINE
#   define SS_IVCHAN  		SS$_IVCHAN
#   define SS_NORMAL  		SS$_NORMAL
#else
#   define SETERRNO(errcode,vmserrcode) (errno = (errcode))
#   define LIB_INVARG 		0
#   define RMS_DIR    		0
#   define RMS_FAC    		0
#   define RMS_FEX    		0
#   define RMS_FNF    		0
#   define RMS_IFI    		0
#   define RMS_ISI    		0
#   define RMS_PRV    		0
#   define SS_ACCVIO      	0
#   define SS_DEVOFFLINE	0
#   define SS_IVCHAN  		0
#   define SS_NORMAL  		0
#endif

#define ERRSV GvSV(PL_errgv)
/* FIXME? Change the assignments to PL_defgv to instantiate GvSV?  */
#define DEFSV GvSVn(PL_defgv)
#define SAVE_DEFSV SAVESPTR(GvSV(PL_defgv))

#define ERRHV GvHV(PL_errgv)	/* XXX unused, here for compatibility */

#ifndef errno
	extern int errno;     /* ANSI allows errno to be an lvalue expr.
			       * For example in multithreaded environments
			       * something like this might happen:
			       * extern int *_errno(void);
			       * #define errno (*_errno()) */
#endif

#ifdef HAS_STRERROR
#       ifdef VMS
	char *strerror (int,...);
#       else
#ifndef DONT_DECLARE_STD
	char *strerror (int);
#endif
#       endif
#       ifndef Strerror
#           define Strerror strerror
#       endif
#else
#    ifdef HAS_SYS_ERRLIST
	extern int sys_nerr;
	extern char *sys_errlist[];
#       ifndef Strerror
#           define Strerror(e) \
		((e) < 0 || (e) >= sys_nerr ? "(unknown)" : sys_errlist[e])
#       endif
#   endif
#endif

#ifdef I_SYS_IOCTL
#   ifndef _IOCTL_
#	include <sys/ioctl.h>
#   endif
#endif

#if defined(mc300) || defined(mc500) || defined(mc700) || defined(mc6000)
#   ifdef HAS_SOCKETPAIR
#	undef HAS_SOCKETPAIR
#   endif
#   ifdef I_NDBM
#	undef I_NDBM
#   endif
#endif

#ifndef HAS_SOCKETPAIR
#   ifdef HAS_SOCKET
#	define socketpair Perl_my_socketpair
#   endif
#endif

#if INTSIZE == 2
#   define htoni htons
#   define ntohi ntohs
#else
#   define htoni htonl
#   define ntohi ntohl
#endif

/* Configure already sets Direntry_t */
#if defined(I_DIRENT)
#   include <dirent.h>
    /* NeXT needs dirent + sys/dir.h */
#   if  defined(I_SYS_DIR) && (defined(NeXT) || defined(__NeXT__))
#	include <sys/dir.h>
#   endif
#else
#   ifdef I_SYS_NDIR
#	include <sys/ndir.h>
#   else
#	ifdef I_SYS_DIR
#	    ifdef hp9000s500
#		include <ndir.h>	/* may be wrong in the future */
#	    else
#		include <sys/dir.h>
#	    endif
#	endif
#   endif
#endif

#ifdef PERL_MICRO
#   ifndef DIR
#      define DIR void
#   endif
#endif

#ifdef FPUTS_BOTCH
/* work around botch in SunOS 4.0.1 and 4.0.2 */
#   ifndef fputs
#	define fputs(sv,fp) fprintf(fp,"%s",sv)
#   endif
#endif

/*
 * The following gobbledygook brought to you on behalf of __STDC__.
 * (I could just use #ifndef __STDC__, but this is more bulletproof
 * in the face of half-implementations.)
 */

#if defined(I_SYSMODE) && !defined(PERL_MICRO)
#include <sys/mode.h>
#endif

#ifndef S_IFMT
#   ifdef _S_IFMT
#	define S_IFMT _S_IFMT
#   else
#	define S_IFMT 0170000
#   endif
#endif

#ifndef S_ISDIR
#   define S_ISDIR(m) ((m & S_IFMT) == S_IFDIR)
#endif

#ifndef S_ISCHR
#   define S_ISCHR(m) ((m & S_IFMT) == S_IFCHR)
#endif

#ifndef S_ISBLK
#   ifdef S_IFBLK
#	define S_ISBLK(m) ((m & S_IFMT) == S_IFBLK)
#   else
#	define S_ISBLK(m) (0)
#   endif
#endif

#ifndef S_ISREG
#   define S_ISREG(m) ((m & S_IFMT) == S_IFREG)
#endif

#ifndef S_ISFIFO
#   ifdef S_IFIFO
#	define S_ISFIFO(m) ((m & S_IFMT) == S_IFIFO)
#   else
#	define S_ISFIFO(m) (0)
#   endif
#endif

#ifndef S_ISLNK
#   ifdef _S_ISLNK
#	define S_ISLNK(m) _S_ISLNK(m)
#   else
#	ifdef _S_IFLNK
#	    define S_ISLNK(m) ((m & S_IFMT) == _S_IFLNK)
#	else
#	    ifdef S_IFLNK
#		define S_ISLNK(m) ((m & S_IFMT) == S_IFLNK)
#	    else
#		define S_ISLNK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_ISSOCK
#   ifdef _S_ISSOCK
#	define S_ISSOCK(m) _S_ISSOCK(m)
#   else
#	ifdef _S_IFSOCK
#	    define S_ISSOCK(m) ((m & S_IFMT) == _S_IFSOCK)
#	else
#	    ifdef S_IFSOCK
#		define S_ISSOCK(m) ((m & S_IFMT) == S_IFSOCK)
#	    else
#		define S_ISSOCK(m) (0)
#	    endif
#	endif
#   endif
#endif

#ifndef S_IRUSR
#   ifdef S_IREAD
#	define S_IRUSR S_IREAD
#	define S_IWUSR S_IWRITE
#	define S_IXUSR S_IEXEC
#   else
#	define S_IRUSR 0400
#	define S_IWUSR 0200
#	define S_IXUSR 0100
#   endif
#endif

#ifndef S_IRGRP
#   ifdef S_IRUSR
#       define S_IRGRP (S_IRUSR>>3)
#       define S_IWGRP (S_IWUSR>>3)
#       define S_IXGRP (S_IXUSR>>3)
#   else
#       define S_IRGRP 0040
#       define S_IWGRP 0020
#       define S_IXGRP 0010
#   endif
#endif

#ifndef S_IROTH
#   ifdef S_IRUSR
#       define S_IROTH (S_IRUSR>>6)
#       define S_IWOTH (S_IWUSR>>6)
#       define S_IXOTH (S_IXUSR>>6)
#   else
#       define S_IROTH 0040
#       define S_IWOTH 0020
#       define S_IXOTH 0010
#   endif
#endif

#ifndef S_ISUID
#   define S_ISUID 04000
#endif

#ifndef S_ISGID
#   define S_ISGID 02000
#endif

#ifndef S_IRWXU
#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
#endif

#ifndef S_IRWXG
#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
#endif

#ifndef S_IRWXO
#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
#endif

/* BeOS 5.0 seems to define S_IREAD and S_IWRITE in <posix/fcntl.h>
 * which would get included through <sys/file.h >, but that is 3000
 * lines in the future.  --jhi */

#if !defined(S_IREAD) && !defined(__BEOS__)
#   define S_IREAD S_IRUSR
#endif

#if !defined(S_IWRITE) && !defined(__BEOS__)
#   define S_IWRITE S_IWUSR
#endif

#ifndef S_IEXEC
#   define S_IEXEC S_IXUSR
#endif

#ifdef ff_next
#   undef ff_next
#endif

#if defined(cray) || defined(gould) || defined(i860) || defined(pyr)
#   define SLOPPYDIVIDE
#endif

#ifdef UV
#undef UV
#endif

#ifdef	SPRINTF_E_BUG
#  define sprintf UTS_sprintf_wrap
#endif

/* For the times when you want the return value of sprintf, and you want it
   to be the length. Can't have a thread variable passed in, because C89 has
   no varargs macros.
*/
#ifdef SPRINTF_RETURNS_STRLEN
#  define my_sprintf sprintf
#else
#  define my_sprintf Perl_my_sprintf
#endif

/*
 * If we have v?snprintf() and the C99 variadic macros, we can just
 * use just the v?snprintf().  It is nice to try to trap the buffer
 * overflow, however, so if we are DEBUGGING, and we cannot use the
 * gcc statement expressions, then use the function wrappers which try
 * to trap the overflow.  If we can use the gcc statement expressions,
 * we can try that even with the version that uses the C99 variadic
 * macros.
 */

/* Note that we do not check against snprintf()/vsnprintf() returning
 * negative values because that is non-standard behaviour and we use
 * snprintf/vsnprintf only iff HAS_VSNPRINTF has been defined, and
 * that should be true only if the snprintf()/vsnprintf() are true
 * to the standard. */

#if defined(HAS_SNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_snprintf(buffer, len, ...) ({ int __len__ = snprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: snprintf buffer overflow"); __len__; })
#      define PERL_MY_SNPRINTF_GUARDED
#  else
#    define my_snprintf(buffer, len, ...) snprintf(buffer, len, __VA_ARGS__)
#  endif
#else
#  define my_snprintf  Perl_my_snprintf
#  define PERL_MY_SNPRINTF_GUARDED
#endif

#if defined(HAS_VSNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
#  ifdef PERL_USE_GCC_BRACE_GROUPS
#      define my_vsnprintf(buffer, len, ...) ({ int __len__ = vsnprintf(buffer, len, __VA_ARGS__); if ((len) > 0 && (Size_t)__len__ >= (len)) Perl_croak_nocontext("panic: vsnprintf buffer overflow"); __len__; })
#      define PERL_MY_VSNPRINTF_GUARDED
#  else
#    define my_vsnprintf(buffer, len, ...) vsnprintf(buffer, len, __VA_ARGS__)
#  endif
#else
#  define my_vsnprintf Perl_my_vsnprintf
#  define PERL_MY_VSNPRINTF_GUARDED
#endif

#ifdef HAS_STRLCAT
#  define my_strlcat    strlcat
#else
#  define my_strlcat    Perl_my_strlcat
#endif

#ifdef HAS_STRLCPY
#  define my_strlcpy	strlcpy
#else
#  define my_strlcpy	Perl_my_strlcpy
#endif

/* Configure gets this right but the UTS compiler gets it wrong.
   -- Hal Morris <hom00@utsglobal.com> */
#ifdef UTS
#  undef  UVTYPE
#  define UVTYPE unsigned
#endif

/*
    The IV type is supposed to be long enough to hold any integral
    value or a pointer.
    --Andy Dougherty	August 1996
*/

typedef IVTYPE IV;
typedef UVTYPE UV;

#if defined(USE_64_BIT_INT) && defined(HAS_QUAD)
#  if QUADKIND == QUAD_IS_INT64_T && defined(INT64_MAX)
#    define IV_MAX INT64_MAX
#    define IV_MIN INT64_MIN
#    define UV_MAX UINT64_MAX
#    ifndef UINT64_MIN
#      define UINT64_MIN 0
#    endif
#    define UV_MIN UINT64_MIN
#  else
#    define IV_MAX PERL_QUAD_MAX
#    define IV_MIN PERL_QUAD_MIN
#    define UV_MAX PERL_UQUAD_MAX
#    define UV_MIN PERL_UQUAD_MIN
#  endif
#  define IV_IS_QUAD
#  define UV_IS_QUAD
#else
#  if defined(INT32_MAX) && IVSIZE == 4
#    define IV_MAX INT32_MAX
#    define IV_MIN INT32_MIN
#    ifndef UINT32_MAX_BROKEN /* e.g. HP-UX with gcc messes this up */
#        define UV_MAX UINT32_MAX
#    else
#        define UV_MAX 4294967295U
#    endif
#    ifndef UINT32_MIN
#      define UINT32_MIN 0
#    endif
#    define UV_MIN UINT32_MIN
#  else
#    define IV_MAX PERL_LONG_MAX
#    define IV_MIN PERL_LONG_MIN
#    define UV_MAX PERL_ULONG_MAX
#    define UV_MIN PERL_ULONG_MIN
#  endif
#  if IVSIZE == 8
#    define IV_IS_QUAD
#    define UV_IS_QUAD
#    ifndef HAS_QUAD
#      define HAS_QUAD
#    endif
#  else
#    undef IV_IS_QUAD
#    undef UV_IS_QUAD
#    undef HAS_QUAD
#  endif
#endif

#ifndef HAS_QUAD
# undef PERL_NEED_MY_HTOLE64
# undef PERL_NEED_MY_LETOH64
# undef PERL_NEED_MY_HTOBE64
# undef PERL_NEED_MY_BETOH64
#endif

#if defined(uts) || defined(UTS)
#	undef UV_MAX
#	define UV_MAX (4294967295u)
#endif

#define IV_DIG (BIT_DIGITS(IVSIZE * 8))
#define UV_DIG (BIT_DIGITS(UVSIZE * 8))

#ifndef NO_PERL_PRESERVE_IVUV
#define PERL_PRESERVE_IVUV	/* We like our integers to stay integers. */
#endif

/*
 *  The macros INT2PTR and NUM2PTR are (despite their names)
 *  bi-directional: they will convert int/float to or from pointers.
 *  However the conversion to int/float are named explicitly:
 *  PTR2IV, PTR2UV, PTR2NV.
 *
 *  For int conversions we do not need two casts if pointers are
 *  the same size as IV and UV.   Otherwise we need an explicit
 *  cast (PTRV) to avoid compiler warnings.
 */
#if (IVSIZE == PTRSIZE) && (UVSIZE == PTRSIZE)
#  define PTRV			UV
#  define INT2PTR(any,d)	(any)(d)
#else
#  if PTRSIZE == LONGSIZE
#    define PTRV		unsigned long
#    define PTR2ul(p)		(unsigned long)(p)
#  else
#    define PTRV		unsigned
#  endif
#endif

#ifndef INT2PTR
#  define INT2PTR(any,d)	(any)(PTRV)(d)
#endif

#ifndef PTR2ul
#  define PTR2ul(p)	INT2PTR(unsigned long,p)	
#endif

#define NUM2PTR(any,d)	(any)(PTRV)(d)
#define PTR2IV(p)	INT2PTR(IV,p)
#define PTR2UV(p)	INT2PTR(UV,p)
#define PTR2NV(p)	NUM2PTR(NV,p)
#define PTR2nat(p)	(PTRV)(p)	/* pointer to integer of PTRSIZE */

/* According to strict ANSI C89 one cannot freely cast between
 * data pointers and function (code) pointers.  There are at least
 * two ways around this.  One (used below) is to do two casts,
 * first the other pointer to an (unsigned) integer, and then
 * the integer to the other pointer.  The other way would be
 * to use unions to "overlay" the pointers.  For an example of
 * the latter technique, see union dirpu in struct xpvio in sv.h.
 * The only feasible use is probably temporarily storing
 * function pointers in a data pointer (such as a void pointer). */

#define DPTR2FPTR(t,p) ((t)PTR2nat(p))	/* data pointer to function pointer */
#define FPTR2DPTR(t,p) ((t)PTR2nat(p))	/* function pointer to data pointer */

#ifdef USE_LONG_DOUBLE
#  if defined(HAS_LONG_DOUBLE) && LONG_DOUBLESIZE == DOUBLESIZE
#      define LONG_DOUBLE_EQUALS_DOUBLE
#  endif
#  if !(defined(HAS_LONG_DOUBLE) && (LONG_DOUBLESIZE > DOUBLESIZE))
#     undef USE_LONG_DOUBLE /* Ouch! */
#  endif
#endif

#ifdef OVR_DBL_DIG
/* Use an overridden DBL_DIG */
# ifdef DBL_DIG
#  undef DBL_DIG
# endif
# define DBL_DIG OVR_DBL_DIG
#else
/* The following is all to get DBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert
   (see config.h). (It also has other uses, such as figuring out if
   a given precision of printing can be done with a double instead of
   a long double - Allen).
*/
#ifdef I_LIMITS
#include <limits.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifndef HAS_DBL_DIG
#define DBL_DIG	15   /* A guess that works lots of places */
#endif
#endif

#ifdef OVR_LDBL_DIG
/* Use an overridden LDBL_DIG */
# ifdef LDBL_DIG
#  undef LDBL_DIG
# endif
# define LDBL_DIG OVR_LDBL_DIG
#else
/* The following is all to get LDBL_DIG, in order to pick a nice
   default value for printing floating point numbers in Gconvert.
   (see config.h)
*/
# ifdef I_LIMITS
#   include <limits.h>
# endif
# ifdef I_FLOAT
#  include <float.h>
# endif
# ifndef HAS_LDBL_DIG
#  if LONG_DOUBLESIZE == 10
#   define LDBL_DIG 18 /* assume IEEE */
#  else
#   if LONG_DOUBLESIZE == 12
#    define LDBL_DIG 18 /* gcc? */
#   else
#    if LONG_DOUBLESIZE == 16
#     define LDBL_DIG 33 /* assume IEEE */
#    else
#     if LONG_DOUBLESIZE == DOUBLESIZE
#      define LDBL_DIG DBL_DIG /* bummer */
#     endif
#    endif
#   endif
#  endif
# endif
#endif

/*
 * This is for making sure we have a good DBL_MAX value, if possible,
 * either for usage as NV_MAX or for usage in figuring out if we can
 * fit a given long double into a double, if bug-fixing makes it
 * necessary to do so. - Allen <allens@cpan.org>
 */

#ifdef I_LIMITS
#  include <limits.h>
#endif

#ifdef I_VALUES
#  if !(defined(DBL_MIN) && defined(DBL_MAX) && defined(I_LIMITS))
#    include <values.h>
#    if defined(MAXDOUBLE) && !defined(DBL_MAX)
#      define DBL_MAX MAXDOUBLE
#    endif
#    if defined(MINDOUBLE) && !defined(DBL_MIN)
#      define DBL_MIN MINDOUBLE
#    endif
#  endif
#endif /* defined(I_VALUES) */

typedef NVTYPE NV;

#ifdef I_IEEEFP
#   include <ieeefp.h>
#endif

#ifdef USE_LONG_DOUBLE
#   ifdef I_SUNMATH
#       include <sunmath.h>
#   endif
#   define NV_DIG LDBL_DIG
#   ifdef LDBL_MANT_DIG
#       define NV_MANT_DIG LDBL_MANT_DIG
#   endif
#   ifdef LDBL_MIN
#       define NV_MIN LDBL_MIN
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
#   endif
#   ifdef LDBL_MIN_10_EXP
#       define NV_MIN_10_EXP LDBL_MIN_10_EXP
#   endif
#   ifdef LDBL_MAX_10_EXP
#       define NV_MAX_10_EXP LDBL_MAX_10_EXP
#   endif
#   ifdef LDBL_EPSILON
#       define NV_EPSILON LDBL_EPSILON
#   endif
#   ifdef LDBL_MAX
#       define NV_MAX LDBL_MAX
/* Having LDBL_MAX doesn't necessarily mean that we have LDBL_MIN... -Allen */
#   else
#       ifdef HUGE_VALL
#           define NV_MAX HUGE_VALL
#       else
#           ifdef HUGE_VAL
#               define NV_MAX ((NV)HUGE_VAL)
#           endif
#       endif
#   endif
#   ifdef HAS_SQRTL
#       define Perl_cos cosl
#       define Perl_sin sinl
#       define Perl_sqrt sqrtl
#       define Perl_exp expl
#       define Perl_log logl
#       define Perl_atan2 atan2l
#       define Perl_pow powl
#       define Perl_floor floorl
#       define Perl_ceil ceill
#       define Perl_fmod fmodl
#   endif
/* e.g. libsunmath doesn't have modfl and frexpl as of mid-March 2000 */
#   ifdef HAS_MODFL
#       define Perl_modf(x,y) modfl(x,y)
/* eg glibc 2.2 series seems to provide modfl on ppc and arm, but has no
   prototype in <math.h> */
#       ifndef HAS_MODFL_PROTO
EXTERN_C long double modfl(long double, long double *);
#	endif
#   else
#       if defined(HAS_AINTL) && defined(HAS_COPYSIGNL)
        extern long double Perl_my_modfl(long double x, long double *ip);
#           define Perl_modf(x,y) Perl_my_modfl(x,y)
#       endif
#   endif
#   ifdef HAS_FREXPL
#       define Perl_frexp(x,y) frexpl(x,y)
#   else
#       if defined(HAS_ILOGBL) && defined(HAS_SCALBNL)
        extern long double Perl_my_frexpl(long double x, int *e);
#           define Perl_frexp(x,y) Perl_my_frexpl(x,y)
#       endif
#   endif
#   ifndef Perl_isnan
#       ifdef HAS_ISNANL
#           define Perl_isnan(x) isnanl(x)
#       endif
#   endif
#   ifndef Perl_isinf
#       ifdef HAS_FINITEL
#           define Perl_isinf(x) !(finitel(x)||Perl_isnan(x))
#       endif
#   endif
#else
#   define NV_DIG DBL_DIG
#   ifdef DBL_MANT_DIG
#       define NV_MANT_DIG DBL_MANT_DIG
#   endif
#   ifdef DBL_MIN
#       define NV_MIN DBL_MIN
#   endif
#   ifdef DBL_MAX
#       define NV_MAX DBL_MAX
#   endif
#   ifdef DBL_MIN_10_EXP
#       define NV_MIN_10_EXP DBL_MIN_10_EXP
#   endif
#   ifdef DBL_MAX_10_EXP
#       define NV_MAX_10_EXP DBL_MAX_10_EXP
#   endif
#   ifdef DBL_EPSILON
#       define NV_EPSILON DBL_EPSILON
#   endif
#   ifdef DBL_MAX               /* XXX Does DBL_MAX imply having DBL_MIN? */
#       define NV_MAX DBL_MAX
#       define NV_MIN DBL_MIN
#   else
#       ifdef HUGE_VAL
#           define NV_MAX HUGE_VAL
#       endif
#   endif
#   define Perl_cos cos
#   define Perl_sin sin
#   define Perl_sqrt sqrt
#   define Perl_exp exp
#   define Perl_log log
#   define Perl_atan2 atan2
#   define Perl_pow pow
#   define Perl_floor floor
#   define Perl_ceil ceil
#   define Perl_fmod fmod
#   define Perl_modf(x,y) modf(x,y)
#   define Perl_frexp(x,y) frexp(x,y)
#endif

/* rumor has it that Win32 has _fpclass() */

/* SGI has fpclassl... but not with the same result values,
 * and it's via a typedef (not via #define), so will need to redo Configure
 * to use. Not worth the trouble, IMO, at least until the below is used
 * more places. Also has fp_class_l, BTW, via fp_class.h. Feel free to check
 * with me for the SGI manpages, SGI testing, etcetera, if you want to
 * try getting this to work with IRIX. - Allen <allens@cpan.org> */

#if !defined(Perl_fp_class) && (defined(HAS_FPCLASS)||defined(HAS_FPCLASSL))
#    ifdef I_IEEFP
#        include <ieeefp.h>
#    endif
#    ifdef I_FP
#        include <fp.h>
#    endif
#    if defined(USE_LONG_DOUBLE) && defined(HAS_FPCLASSL)
#        define Perl_fp_class()		fpclassl(x)
#    else
#        define Perl_fp_class()		fpclass(x)
#    endif
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_CLASS_SNAN||Perl_fp_class(x)==FP_CLASS_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_CLASS_NINF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_CLASS_NINF||Perl_fp_class(x)==FP_CLASS_PINF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_CLASS_NNORM||Perl_fp_class(x)==FP_CLASS_PNORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_CLASS_NDENORM||Perl_fp_class(x)==FP_CLASS_PDENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_CLASS_PZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_CLASS_NZERO||Perl_fp_class(x)==FP_CLASS_PZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FP_CLASS) && !defined(PERL_MICRO)
#    include <math.h>
#    if !defined(FP_SNAN) && defined(I_FP_CLASS)
#        include <fp_class.h>
#    endif
#    define Perl_fp_class(x)		fp_class(x)
#    define Perl_fp_class_snan(x)	(fp_class(x)==FP_SNAN)
#    define Perl_fp_class_qnan(x)	(fp_class(x)==FP_QNAN)
#    define Perl_fp_class_nan(x)	(fp_class(x)==FP_SNAN||fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(fp_class(x)==FP_NEG_INF)
#    define Perl_fp_class_pinf(x)	(fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_inf(x)	(fp_class(x)==FP_NEG_INF||fp_class(x)==FP_POS_INF)
#    define Perl_fp_class_nnorm(x)	(fp_class(x)==FP_NEG_NORM)
#    define Perl_fp_class_pnorm(x)	(fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_norm(x)	(fp_class(x)==FP_NEG_NORM||fp_class(x)==FP_POS_NORM)
#    define Perl_fp_class_ndenorm(x)	(fp_class(x)==FP_NEG_DENORM)
#    define Perl_fp_class_pdenorm(x)	(fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_denorm(x)	(fp_class(x)==FP_NEG_DENORM||fp_class(x)==FP_POS_DENORM)
#    define Perl_fp_class_nzero(x)	(fp_class(x)==FP_NEG_ZERO)
#    define Perl_fp_class_pzero(x)	(fp_class(x)==FP_POS_ZERO)
#    define Perl_fp_class_zero(x)	(fp_class(x)==FP_NEG_ZERO||fp_class(x)==FP_POS_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_FPCLASSIFY)
#    include <math.h>
#    define Perl_fp_class(x)		fpclassify(x)
#    define Perl_fp_class_nan(x)	(fp_classify(x)==FP_SNAN||fp_classify(x)==FP_QNAN)
#    define Perl_fp_class_inf(x)	(fp_classify(x)==FP_INFINITE)
#    define Perl_fp_class_norm(x)	(fp_classify(x)==FP_NORMAL)
#    define Perl_fp_class_denorm(x)	(fp_classify(x)==FP_SUBNORMAL)
#    define Perl_fp_class_zero(x)	(fp_classify(x)==FP_ZERO)
#endif

#if !defined(Perl_fp_class) && defined(HAS_CLASS)
#    include <math.h>
#    ifndef _cplusplus
#        define Perl_fp_class(x)	class(x)
#    else
#        define Perl_fp_class(x)	_class(x)
#    endif
#    define Perl_fp_class_snan(x)	(Perl_fp_class(x)==FP_NANS)
#    define Perl_fp_class_qnan(x)	(Perl_fp_class(x)==FP_NANQ)
#    define Perl_fp_class_nan(x)	(Perl_fp_class(x)==FP_SNAN||Perl_fp_class(x)==FP_QNAN)
#    define Perl_fp_class_ninf(x)	(Perl_fp_class(x)==FP_MINUS_INF)
#    define Perl_fp_class_pinf(x)	(Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_inf(x)	(Perl_fp_class(x)==FP_MINUS_INF||Perl_fp_class(x)==FP_PLUS_INF)
#    define Perl_fp_class_nnorm(x)	(Perl_fp_class(x)==FP_MINUS_NORM)
#    define Perl_fp_class_pnorm(x)	(Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_norm(x)	(Perl_fp_class(x)==FP_MINUS_NORM||Perl_fp_class(x)==FP_PLUS_NORM)
#    define Perl_fp_class_ndenorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM)
#    define Perl_fp_class_pdenorm(x)	(Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_denorm(x)	(Perl_fp_class(x)==FP_MINUS_DENORM||Perl_fp_class(x)==FP_PLUS_DENORM)
#    define Perl_fp_class_nzero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO)
#    define Perl_fp_class_pzero(x)	(Perl_fp_class(x)==FP_PLUS_ZERO)
#    define Perl_fp_class_zero(x)	(Perl_fp_class(x)==FP_MINUS_ZERO||Perl_fp_class(x)==FP_PLUS_ZERO)
#endif

/* rumor has it that Win32 has _isnan() */

#ifndef Perl_isnan
#   ifdef HAS_ISNAN
#       define Perl_isnan(x) isnan((NV)x)
#   else
#       ifdef Perl_fp_class_nan
#           define Perl_isnan(x) Perl_fp_class_nan(x)
#       else
#           ifdef HAS_UNORDERED
#               define Perl_isnan(x) unordered((x), 0.0)
#           else
#               define Perl_isnan(x) ((x)!=(x))
#           endif
#       endif
#   endif
#endif

#ifdef UNDER_CE
int isnan(double d);
#endif

#ifndef Perl_isinf
#   ifdef HAS_ISINF
#       define Perl_isinf(x) isinf((NV)x)
#   else
#       ifdef Perl_fp_class_inf
#           define Perl_isinf(x) Perl_fp_class_inf(x)
#       else
#           define Perl_isinf(x) ((x)==NV_INF)
#       endif
#   endif
#endif

#ifndef Perl_isfinite
#   ifdef HAS_FINITE
#       define Perl_isfinite(x) finite((NV)x)
#   else
#       ifdef HAS_ISFINITE
#           define Perl_isfinite(x) isfinite(x)
#       else
#           ifdef Perl_fp_class_finite
#               define Perl_isfinite(x) Perl_fp_class_finite(x)
#           else
#               define Perl_isfinite(x) !(Perl_is_inf(x)||Perl_is_nan(x))
#           endif
#       endif
#   endif
#endif

/* The default is to use Perl's own atof() implementation (in numeric.c).
 * Usually that is the one to use but for some platforms (e.g. UNICOS)
 * it is however best to use the native implementation of atof.
 * You can experiment with using your native one by -DUSE_PERL_ATOF=0.
 * Some good tests to try out with either setting are t/base/num.t,
 * t/op/numconvert.t, and t/op/pack.t. Note that if using long doubles
 * you may need to be using a different function than atof! */

#ifndef USE_PERL_ATOF
#   ifndef _UNICOS
#       define USE_PERL_ATOF
#   endif
#else
#   if USE_PERL_ATOF == 0
#       undef USE_PERL_ATOF
#   endif
#endif

#ifdef USE_PERL_ATOF
#   define Perl_atof(s) Perl_my_atof(s)
#   define Perl_atof2(s, n) Perl_my_atof2(aTHX_ (s), &(n))
#else
#   define Perl_atof(s) (NV)atof(s)
#   define Perl_atof2(s, n) ((n) = atof(s))
#endif

/* Previously these definitions used hardcoded figures.
 * It is hoped these formula are more portable, although
 * no data one way or another is presently known to me.
 * The "PERL_" names are used because these calculated constants
 * do not meet the ANSI requirements for LONG_MAX, etc., which
 * need to be constants acceptable to #if - kja
 *    define PERL_LONG_MAX        2147483647L
 *    define PERL_LONG_MIN        (-LONG_MAX - 1)
 *    define PERL ULONG_MAX       4294967295L
 */

#ifdef I_LIMITS  /* Needed for cast_xxx() functions below. */
#  include <limits.h>
#endif
/* Included values.h above if necessary; still including limits.h down here,
 * despite doing above, because math.h might have overriden... XXX - Allen */

/*
 * Try to figure out max and min values for the integral types.  THE CORRECT
 * SOLUTION TO THIS MESS: ADAPT enquire.c FROM GCC INTO CONFIGURE.  The
 * following hacks are used if neither limits.h or values.h provide them:
 * U<TYPE>_MAX: for types >= int: ~(unsigned TYPE)0
 *              for types <  int:  (unsigned TYPE)~(unsigned)0
 *	The argument to ~ must be unsigned so that later signed->unsigned
 *	conversion can't modify the value's bit pattern (e.g. -0 -> +0),
 *	and it must not be smaller than int because ~ does integral promotion.
 * <type>_MAX: (<type>) (U<type>_MAX >> 1)
 * <type>_MIN: -<type>_MAX - <is_twos_complement_architecture: (3 & -1) == 3>.
 *	The latter is a hack which happens to work on some machines but
 *	does *not* catch any random system, or things like integer types
 *	with NaN if that is possible.
 *
 * All of the types are explicitly cast to prevent accidental loss of
 * numeric range, and in the hope that they will be less likely to confuse
 * over-eager optimizers.
 *
 */

#define PERL_UCHAR_MIN ((unsigned char)0)

#ifdef UCHAR_MAX
#  define PERL_UCHAR_MAX ((unsigned char)UCHAR_MAX)
#else
#  ifdef MAXUCHAR
#    define PERL_UCHAR_MAX ((unsigned char)MAXUCHAR)
#  else
#    define PERL_UCHAR_MAX       ((unsigned char)~(unsigned)0)
#  endif
#endif

/*
 * CHAR_MIN and CHAR_MAX are not included here, as the (char) type may be
 * ambiguous. It may be equivalent to (signed char) or (unsigned char)
 * depending on local options. Until Configure detects this (or at least
 * detects whether the "signed" keyword is available) the CHAR ranges
 * will not be included. UCHAR functions normally.
 *                                                           - kja
 */

#define PERL_USHORT_MIN ((unsigned short)0)

#ifdef USHORT_MAX
#  define PERL_USHORT_MAX ((unsigned short)USHORT_MAX)
#else
#  ifdef MAXUSHORT
#    define PERL_USHORT_MAX ((unsigned short)MAXUSHORT)
#  else
#    ifdef USHRT_MAX
#      define PERL_USHORT_MAX ((unsigned short)USHRT_MAX)
#    else
#      define PERL_USHORT_MAX       ((unsigned short)~(unsigned)0)
#    endif
#  endif
#endif

#ifdef SHORT_MAX
#  define PERL_SHORT_MAX ((short)SHORT_MAX)
#else
#  ifdef MAXSHORT    /* Often used in <values.h> */
#    define PERL_SHORT_MAX ((short)MAXSHORT)
#  else
#    ifdef SHRT_MAX
#      define PERL_SHORT_MAX ((short)SHRT_MAX)
#    else
#      define PERL_SHORT_MAX      ((short) (PERL_USHORT_MAX >> 1))
#    endif
#  endif
#endif

#ifdef SHORT_MIN
#  define PERL_SHORT_MIN ((short)SHORT_MIN)
#else
#  ifdef MINSHORT
#    define PERL_SHORT_MIN ((short)MINSHORT)
#  else
#    ifdef SHRT_MIN
#      define PERL_SHORT_MIN ((short)SHRT_MIN)
#    else
#      define PERL_SHORT_MIN        (-PERL_SHORT_MAX - ((3 & -1) == 3))
#    endif
#  endif
#endif

#ifdef UINT_MAX
#  define PERL_UINT_MAX ((unsigned int)UINT_MAX)
#else
#  ifdef MAXUINT
#    define PERL_UINT_MAX ((unsigned int)MAXUINT)
#  else
#    define PERL_UINT_MAX       (~(unsigned int)0)
#  endif
#endif

#define PERL_UINT_MIN ((unsigned int)0)

#ifdef INT_MAX
#  define PERL_INT_MAX ((int)INT_MAX)
#else
#  ifdef MAXINT    /* Often used in <values.h> */
#    define PERL_INT_MAX ((int)MAXINT)
#  else
#    define PERL_INT_MAX        ((int)(PERL_UINT_MAX >> 1))
#  endif
#endif

#ifdef INT_MIN
#  define PERL_INT_MIN ((int)INT_MIN)
#else
#  ifdef MININT
#    define PERL_INT_MIN ((int)MININT)
#  else
#    define PERL_INT_MIN        (-PERL_INT_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef ULONG_MAX
#  define PERL_ULONG_MAX ((unsigned long)ULONG_MAX)
#else
#  ifdef MAXULONG
#    define PERL_ULONG_MAX ((unsigned long)MAXULONG)
#  else
#    define PERL_ULONG_MAX       (~(unsigned long)0)
#  endif
#endif

#define PERL_ULONG_MIN ((unsigned long)0L)

#ifdef LONG_MAX
#  define PERL_LONG_MAX ((long)LONG_MAX)
#else
#  ifdef MAXLONG    /* Often used in <values.h> */
#    define PERL_LONG_MAX ((long)MAXLONG)
#  else
#    define PERL_LONG_MAX        ((long) (PERL_ULONG_MAX >> 1))
#  endif
#endif

#ifdef LONG_MIN
#  define PERL_LONG_MIN ((long)LONG_MIN)
#else
#  ifdef MINLONG
#    define PERL_LONG_MIN ((long)MINLONG)
#  else
#    define PERL_LONG_MIN        (-PERL_LONG_MAX - ((3 & -1) == 3))
#  endif
#endif

#ifdef UV_IS_QUAD

#    define PERL_UQUAD_MAX	(~(UV)0)
#    define PERL_UQUAD_MIN	((UV)0)
#    define PERL_QUAD_MAX 	((IV) (PERL_UQUAD_MAX >> 1))
#    define PERL_QUAD_MIN 	(-PERL_QUAD_MAX - ((3 & -1) == 3))

#endif

#ifdef MYMALLOC
#  include "malloc_ctl.h"
#endif

struct RExC_state_t;
struct _reg_trie_data;

typedef MEM_SIZE STRLEN;

#ifdef PERL_MAD
typedef struct token TOKEN;
typedef struct madprop MADPROP;
typedef struct nexttoken NEXTTOKE;
#endif
typedef struct op OP;
typedef struct cop COP;
typedef struct unop UNOP;
typedef struct binop BINOP;
typedef struct listop LISTOP;
typedef struct logop LOGOP;
typedef struct pmop PMOP;
typedef struct svop SVOP;
typedef struct padop PADOP;
typedef struct pvop PVOP;
typedef struct loop LOOP;

typedef struct interpreter PerlInterpreter;

/* Amdahl's <ksync.h> has struct sv */
/* SGI's <sys/sema.h> has struct sv */
#if defined(UTS) || defined(__sgi)
#   define STRUCT_SV perl_sv
#else
#   define STRUCT_SV sv
#endif
typedef struct STRUCT_SV SV;
typedef struct av AV;
typedef struct hv HV;
typedef struct cv CV;
typedef struct regexp REGEXP;
typedef struct gp GP;
typedef struct gv GV;
typedef struct io IO;
typedef struct context PERL_CONTEXT;
typedef struct block BLOCK;

typedef struct magic MAGIC;
typedef struct xpv XPV;
typedef struct xpviv XPVIV;
typedef struct xpvuv XPVUV;
typedef struct xpvnv XPVNV;
typedef struct xpvmg XPVMG;
typedef struct xpvlv XPVLV;
typedef struct xpvav XPVAV;
typedef struct xpvhv XPVHV;
typedef struct xpvgv XPVGV;
typedef struct xpvcv XPVCV;
typedef struct xpvbm XPVBM;
typedef struct xpvfm XPVFM;
typedef struct xpvio XPVIO;
typedef struct mgvtbl MGVTBL;
typedef union any ANY;
typedef struct ptr_tbl_ent PTR_TBL_ENT_t;
typedef struct ptr_tbl PTR_TBL_t;
typedef struct clone_params CLONE_PARAMS;

#include "handy.h"

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_RAWIO)
#   if LSEEKSIZE == 8 && !defined(USE_64_BIT_RAWIO)
#       define USE_64_BIT_RAWIO	/* implicit */
#   endif
#endif

/* Notice the use of HAS_FSEEKO: now we are obligated to always use
 * fseeko/ftello if possible.  Don't go #defining ftell to ftello yourself,
 * however, because operating systems like to do that themself. */
#ifndef FSEEKSIZE
#   ifdef HAS_FSEEKO
#       define FSEEKSIZE LSEEKSIZE
#   else
#       define FSEEKSIZE LONGSIZE
#   endif
#endif

#if defined(USE_LARGE_FILES) && !defined(NO_64_BIT_STDIO)
#   if FSEEKSIZE == 8 && !defined(USE_64_BIT_STDIO)
#       define USE_64_BIT_STDIO /* implicit */
#   endif
#endif

#ifdef USE_64_BIT_RAWIO
#   ifdef HAS_OFF64_T
#       undef Off_t
#       define Off_t off64_t
#       undef LSEEKSIZE
#       define LSEEKSIZE 8
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not.  Therefore we have to explicitly mix and match. */
#   if defined(USE_OPEN64)
#       define open open64
#   endif
#   if defined(USE_LSEEK64)
#       define lseek lseek64
#   else
#       if defined(USE_LLSEEK)
#           define lseek llseek
#       endif
#   endif
#   if defined(USE_STAT64)
#       define stat stat64
#   endif
#   if defined(USE_FSTAT64)
#       define fstat fstat64
#   endif
#   if defined(USE_LSTAT64)
#       define lstat lstat64
#   endif
#   if defined(USE_FLOCK64)
#       define flock flock64
#   endif
#   if defined(USE_LOCKF64)
#       define lockf lockf64
#   endif
#   if defined(USE_FCNTL64)
#       define fcntl fcntl64
#   endif
#   if defined(USE_TRUNCATE64)
#       define truncate truncate64
#   endif
#   if defined(USE_FTRUNCATE64)
#       define ftruncate ftruncate64
#   endif
#endif

#ifdef USE_64_BIT_STDIO
#   ifdef HAS_FPOS64_T
#       undef Fpos_t
#       define Fpos_t fpos64_t
#   endif
/* Most 64-bit environments have defines like _LARGEFILE_SOURCE that
 * will trigger defines like the ones below.  Some 64-bit environments,
 * however, do not. */
#   if defined(USE_FOPEN64)
#       define fopen fopen64
#   endif
#   if defined(USE_FSEEK64)
#       define fseek fseek64 /* don't do fseeko here, see perlio.c */
#   endif
#   if defined(USE_FTELL64)
#       define ftell ftell64 /* don't do ftello here, see perlio.c */
#   endif
#   if defined(USE_FSETPOS64)
#       define fsetpos fsetpos64
#   endif
#   if defined(USE_FGETPOS64)
#       define fgetpos fgetpos64
#   endif
#   if defined(USE_TMPFILE64)
#       define tmpfile tmpfile64
#   endif
#   if defined(USE_FREOPEN64)
#       define freopen freopen64
#   endif
#endif

#if defined(OS2) || defined(MACOS_TRADITIONAL)
#  include "iperlsys.h"
#endif

#if defined(__OPEN_VM)
#   include "vmesa/vmesaish.h"
#   define ISHISH "vmesa"
#endif

#ifdef DOSISH
#   if defined(OS2)
#       include "os2ish.h"
#   else
#       include "dosish.h"
#   endif
#   define ISHISH "dos"
#endif

#if defined(VMS)
#   include "vmsish.h"
#   include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
#   define ISHISH "vms"
#endif

#if defined(PLAN9)
#   include "./plan9/plan9ish.h"
#   define ISHISH "plan9"
#endif

#if defined(MPE)
#  include "mpeix/mpeixish.h"
#  define ISHISH "mpeix"
#endif

#if defined(__VOS__)
#   ifdef __GNUC__
#     include "./vos/vosish.h"
#   else
#     include "vos/vosish.h"
#   endif
#   define ISHISH "vos"
#endif

#if defined(EPOC)
#   include "epocish.h"
#   define ISHISH "epoc"
#endif

#ifdef __SYMBIAN32__
#   include "symbian/symbianish.h"
#   include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
#   define ISHISH "symbian"
#endif

#if defined(MACOS_TRADITIONAL)
#   include "macos/macish.h"
#   ifndef NO_ENVIRON_ARRAY
#       define NO_ENVIRON_ARRAY
#   endif
#   define ISHISH "macos classic"
#endif

#if defined(__BEOS__)
#   include "beos/beosish.h"
#   define ISHISH "beos"
#endif

#ifndef ISHISH
#   include "unixish.h"
#   define ISHISH "unix"
#endif

/* NSIG logic from Configure --> */
/* Strange style to avoid deeply-nested #if/#else/#endif */
#ifndef NSIG
#  ifdef _NSIG
#    define NSIG (_NSIG)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGMAX
#    define NSIG (SIGMAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIG_MAX
#    define NSIG (SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef _SIG_MAX
#    define NSIG (_SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAXSIG
#    define NSIG (MAXSIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAX_SIG
#    define NSIG (MAX_SIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGARRAYSIZE
#    define NSIG SIGARRAYSIZE /* Assume ary[SIGARRAYSIZE] */
#  endif
#endif

#ifndef NSIG
#  ifdef _sys_nsig
#    define NSIG (_sys_nsig) /* Solaris 2.5 */
#  endif
#endif

/* Default to some arbitrary number that's big enough to get most
   of the common signals.
*/
#ifndef NSIG
#    define NSIG 50
#endif
/* <-- NSIG logic from Configure */

#ifndef NO_ENVIRON_ARRAY
#  define USE_ENVIRON_ARRAY
#endif

/*
 * initialise to avoid floating-point exceptions from overflow, etc
 */
#ifndef PERL_FPU_INIT
#  ifdef HAS_FPSETMASK
#    if HAS_FLOATINGPOINT_H
#      include <floatingpoint.h>
#    endif
#    define PERL_FPU_INIT fpsetmask(0)
#  else
#    if defined(SIGFPE) && defined(SIG_IGN) && !defined(PERL_MICRO)
#      define PERL_FPU_INIT       PL_sigfpe_saved = (Sighandler_t) signal(SIGFPE, SIG_IGN)
#      define PERL_FPU_PRE_EXEC   { Sigsave_t xfpe; rsignal_save(SIGFPE, PL_sigfpe_saved, &xfpe);
#      define PERL_FPU_POST_EXEC    rsignal_restore(SIGFPE, &xfpe); }
#    else
#      define PERL_FPU_INIT

#    endif
#  endif
#endif
#ifndef PERL_FPU_PRE_EXEC
#  define PERL_FPU_PRE_EXEC   {
#  define PERL_FPU_POST_EXEC  }
#endif

#ifndef PERL_SYS_INIT3_BODY
#  define PERL_SYS_INIT3_BODY(argvp,argcp,envp) PERL_SYS_INIT_BODY(argvp,argcp)
#endif

#define PERL_SYS_INIT(argc, argv)	Perl_sys_init(argc, argv)
#define PERL_SYS_INIT3(argc, argv, env)	Perl_sys_init3(argc, argv, env)
#define PERL_SYS_TERM()			Perl_sys_term()

#ifndef PERL_WRITE_MSG_TO_CONSOLE
#  define PERL_WRITE_MSG_TO_CONSOLE(io, msg, len) PerlIO_write(io, msg, len)
#endif

#ifndef MAXPATHLEN
#  ifdef PATH_MAX
#    ifdef _POSIX_PATH_MAX
#       if PATH_MAX > _POSIX_PATH_MAX
/* POSIX 1990 (and pre) was ambiguous about whether PATH_MAX
 * included the null byte or not.  Later amendments of POSIX,
 * XPG4, the Austin Group, and the Single UNIX Specification
 * all explicitly include the null byte in the PATH_MAX.
 * Ditto for _POSIX_PATH_MAX. */
#         define MAXPATHLEN PATH_MAX
#       else
#         define MAXPATHLEN _POSIX_PATH_MAX
#       endif
#    else
#      define MAXPATHLEN (PATH_MAX+1)
#    endif
#  else
#    ifdef _POSIX_PATH_MAX
#       define MAXPATHLEN _POSIX_PATH_MAX
#    else
#       define MAXPATHLEN 1024	/* Err on the large side. */
#    endif
#  endif
#endif

/* In case Configure was not used (we are using a "canned config"
 * such as Win32, or a cross-compilation setup, for example) try going
 * by the gcc major and minor versions.  One useful URL is
 * http://www.ohse.de/uwe/articles/gcc-attributes.html,
 * but contrary to this information warn_unused_result seems
 * not to be in gcc 3.3.5, at least. --jhi
 * Also, when building extensions with an installed perl, this allows
 * the user to upgrade gcc and get the right attributes, rather than
 * relying on the list generated at Configure time.  --AD
 * Set these up now otherwise we get confused when some of the <*thread.h>
 * includes below indirectly pull in <perlio.h> (which needs to know if we
 * have HASATTRIBUTE_FORMAT).
 */

#ifndef PERL_MICRO
#if defined __GNUC__ && !defined(__INTEL_COMPILER)
#  if __GNUC__ >= 3 /* 3.0 -> */ /* XXX Verify this version */
#    define HASATTRIBUTE_FORMAT
#    if defined __MINGW32__
#      define PRINTF_FORMAT_NULL_OK
#    endif
#  endif
#  if __GNUC__ >= 3 /* 3.0 -> */
#    define HASATTRIBUTE_MALLOC
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 3 || __GNUC__ > 3 /* 3.3 -> */
#    define HASATTRIBUTE_NONNULL
#  endif
#  if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 || __GNUC__ > 2 /* 2.5 -> */
#    define HASATTRIBUTE_NORETURN
#  endif
#  if __GNUC__ >= 3 /* gcc 3.0 -> */
#    define HASATTRIBUTE_PURE
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_UNUSED
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ == 3 && !defined(__cplusplus)
#    define HASATTRIBUTE_UNUSED /* gcc-3.3, but not g++-3.3. */
#  endif
#  if __GNUC__ == 3 && __GNUC_MINOR__ >= 4 || __GNUC__ > 3 /* 3.4 -> */
#    define HASATTRIBUTE_WARN_UNUSED_RESULT
#  endif
#endif
#endif /* #ifndef PERL_MICRO */ 

/* USE_5005THREADS needs to be after unixish.h as <pthread.h> includes
 * <sys/signal.h> which defines NSIG - which will stop inclusion of <signal.h>
 * this results in many functions being undeclared which bothers C++
 * May make sense to have threads after "*ish.h" anyway
 */

#if defined(USE_ITHREADS)
#  ifdef NETWARE
#   include <nw5thread.h>
#  else
#  ifdef FAKE_THREADS
#    include "fakethr.h"
#  else
#    ifdef WIN32
#      include <win32thread.h>
#    else
#      ifdef OS2
#        include "os2thread.h"
#      else
#        ifdef I_MACH_CTHREADS
#          include <mach/cthreads.h>
#          if (defined(NeXT) || defined(__NeXT__)) && defined(PERL_POLLUTE_MALLOC)
#            define MUTEX_INIT_CALLS_MALLOC
#          endif
typedef cthread_t	perl_os_thread;
typedef mutex_t		perl_mutex;
typedef condition_t	perl_cond;
typedef void *		perl_key;
#        else /* Posix threads */
#          ifdef I_PTHREAD
#            include <pthread.h>
#          endif
typedef pthread_t	perl_os_thread;
typedef pthread_mutex_t	perl_mutex;
typedef pthread_cond_t	perl_cond;
typedef pthread_key_t	perl_key;
#        endif /* I_MACH_CTHREADS */
#      endif /* OS2 */
#    endif /* WIN32 */
#  endif /* FAKE_THREADS */
#endif	/* NETWARE */
#endif /* USE_ITHREADS */

#if defined(WIN32)
#  include "win32.h"
#endif

#ifdef NETWARE
#  include "netware.h"
#endif

#define STATUS_UNIX	PL_statusvalue
#ifdef VMS
#   define STATUS_NATIVE	PL_statusvalue_vms
/*
 * vaxc$errno is only guaranteed to be valid if errno == EVMSERR, otherwise
 * its contents can not be trusted.  Unfortunately, Perl seems to check
 * it on exit, so it when PL_statusvalue_vms is updated, vaxc$errno should
 * be updated also.
 */
#  include <stsdef.h>
#  include <ssdef.h>
/* Presume this because if VMS changes it, it will require a new
 * set of APIs for waiting on children for binary compatibility.
 */
#  define child_offset_bits (8)
#  ifndef C_FAC_POSIX
#  define C_FAC_POSIX 0x35A000
#  endif

/*  STATUS_EXIT - validates and returns a NATIVE exit status code for the
 * platform from the existing UNIX or Native status values.
 */

#   define STATUS_EXIT \
	(((I32)PL_statusvalue_vms == -1 ? SS$_ABORT : PL_statusvalue_vms) | \
	   (VMSISH_HUSHED ? STS$M_INHIB_MSG : 0))


/* STATUS_NATIVE_CHILD_SET - Calculate UNIX status that matches the child
 * exit code and shifts the UNIX value over the correct number of bits to
 * be a child status.  Usually the number of bits is 8, but that could be
 * platform dependent.  The NATIVE status code is presumed to have either
 * from a child process.
 */

/* This is complicated.  The child processes return a true native VMS
   status which must be saved.  But there is an assumption in Perl that
   the UNIX child status has some relationship to errno values, so
   Perl tries to translate it to text in some of the tests.  
   In order to get the string translation correct, for the error, errno
   must be EVMSERR, but that generates a different text message
   than what the test programs are expecting.  So an errno value must
   be derived from the native status value when an error occurs.
   That will hide the true native status message.  With this version of
   perl, the true native child status can always be retrieved so that
   is not a problem.  But in this case, Pl_statusvalue and errno may
   have different values in them.
 */

#   define STATUS_NATIVE_CHILD_SET(n) \
	STMT_START {							\
	    I32 evalue = (I32)n;					\
	    if (evalue == EVMSERR) {					\
	      PL_statusvalue_vms = vaxc$errno;				\
	      PL_statusvalue = evalue;					\
	    } else {							\
	      PL_statusvalue_vms = evalue;				\
	      if (evalue == -1) {					\
		PL_statusvalue = -1;					\
		PL_statusvalue_vms = SS$_ABORT; /* Should not happen */ \
	      } else							\
		PL_statusvalue = Perl_vms_status_to_unix(evalue, 1);	\
	      set_vaxc_errno(evalue);					\
	      if ((PL_statusvalue_vms & C_FAC_POSIX) == C_FAC_POSIX)	\
		  set_errno(EVMSERR);					\
	      else set_errno(Perl_vms_status_to_unix(evalue, 0));	\
	      PL_statusvalue = PL_statusvalue << child_offset_bits;	\
	    }								\
	} STMT_END

#   ifdef VMSISH_STATUS
#	define STATUS_CURRENT	(VMSISH_STATUS ? STATUS_NATIVE : STATUS_UNIX)
#   else
#	define STATUS_CURRENT	STATUS_UNIX
#   endif

  /* STATUS_UNIX_SET - takes a UNIX/POSIX errno value and attempts to update
   * the NATIVE status to an equivalent value.  Can not be used to translate
   * exit code values as exit code values are not guaranteed to have any
   * relationship at all to errno values.
   * This is used when Perl is forcing errno to have a specific value.
   */
#   define STATUS_UNIX_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (PL_statusvalue != -1) {			\
		if (PL_statusvalue != EVMSERR) {	\
		  PL_statusvalue &= 0xFFFF;		\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms=PL_statusvalue ? SS$_ABORT : SS$_NORMAL;\
		  else PL_statusvalue_vms = Perl_unix_status_to_vms(evalue); \
		}					\
		else {					\
		  PL_statusvalue_vms = vaxc$errno;	\
		}					\
	    }						\
	    else PL_statusvalue_vms = SS$_ABORT;	\
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END

  /* STATUS_UNIX_EXIT_SET - Takes a UNIX/POSIX exit code and sets
   * the NATIVE error status based on it.  It does not assume that
   * the UNIX/POSIX exit codes have any relationship to errno, except
   * that 0 indicates a success.  When in the default mode to comply
   * with the Perl VMS documentation, any other code sets the NATIVE
   * status to a failure code of SS$_ABORT.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   * If the exit code is not clearly a UNIX parent or child exit status,
   * it will be passed through as a VMS status.
   */

#   define STATUS_UNIX_EXIT_SET(n)			\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (evalue != -1) {				\
	      if (evalue <= 0xFF00) {			\
		if (evalue > 0xFF)			\
		  evalue = (evalue >> child_offset_bits) & 0xFF; \
		if (evalue == 0)			\
		  PL_statusvalue_vms == SS$_NORMAL;	\
		else					\
		  if (MY_POSIX_EXIT)			\
		    PL_statusvalue_vms =	\
		       (C_FAC_POSIX | (evalue << 3 ) | (evalue == 1)? \
		        (STS$K_ERROR | STS$M_INHIB_MSG) : 1); \
		  else					\
		    PL_statusvalue_vms = SS$_ABORT; \
	      } else { /* forgive them Perl, for they have sinned */ \
		if (evalue != EVMSERR) PL_statusvalue_vms = evalue; \
		else PL_statusvalue_vms = vaxc$errno;		\
	        /* And obviously used a VMS status value instead of UNIX */ \
	        PL_statusvalue = EVMSERR;				\
	      }							\
	    }							\
	    else PL_statusvalue_vms = SS$_ABORT;		\
	    set_vaxc_errno(PL_statusvalue_vms);			\
	} STMT_END

  /* STATUS_EXIT_SET - Takes a NATIVE/UNIX/POSIX exit code
   * and sets the NATIVE error status based on it.  This special case
   * is needed to maintain compatibility with past VMS behavior.
   *
   * In the default mode on VMS, this number is passed through as
   * both the NATIVE and UNIX status.  Which makes it different
   * that the STATUS_UNIX_EXIT_SET.
   *
   * In the new POSIX EXIT mode, native status will be set so that the
   * actual exit code will can be retrieved by the calling program or
   * shell.
   *
   */

#   define STATUS_EXIT_SET(n)				\
	STMT_START {					\
	    I32 evalue = (I32)n;			\
	    PL_statusvalue = evalue;			\
	    if (MY_POSIX_EXIT)				\
		PL_statusvalue_vms =			\
		  (C_FAC_POSIX | (evalue << 3 ) | (evalue == 1)? \
		   (STS$K_ERROR | STS$M_INHIB_MSG) : 1); \
	    else					\
		PL_statusvalue_vms = evalue ? evalue : SS$_NORMAL; \
	    set_vaxc_errno(PL_statusvalue_vms);		\
	} STMT_END


 /* This macro forces a success status */
#   define STATUS_ALL_SUCCESS	\
	(PL_statusvalue = 0, PL_statusvalue_vms = SS$_NORMAL)

 /* This macro forces a failure status */
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, \
     vaxc$errno = PL_statusvalue_vms = MY_POSIX_EXIT ? \
	(C_FAC_POSIX | (1 << 3) | STS$K_ERROR | STS$M_INHIB_MSG) : SS$_ABORT)

#else
#   define STATUS_NATIVE	PL_statusvalue_posix
#   if defined(WCOREDUMP)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0) | \
                        (WIFSIGNALED(PL_statusvalue_posix) && WCOREDUMP(PL_statusvalue_posix) ? 0x80 : 0);  \
                }                                          \
            } STMT_END
#   elif defined(WIFEXITED)
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        (WIFEXITED(PL_statusvalue_posix) ? (WEXITSTATUS(PL_statusvalue_posix) << 8) : 0) |  \
                        (WIFSIGNALED(PL_statusvalue_posix) ? (WTERMSIG(PL_statusvalue_posix) & 0x7F) : 0);  \
                }                                          \
            } STMT_END
#   else
#       define STATUS_NATIVE_CHILD_SET(n)                  \
            STMT_START {                                   \
                PL_statusvalue_posix = (n);                \
                if (PL_statusvalue_posix == -1)            \
                    PL_statusvalue = -1;                   \
                else {                                     \
                    PL_statusvalue =                       \
                        PL_statusvalue_posix & 0xFFFF;     \
                }                                          \
            } STMT_END
#   endif
#   define STATUS_UNIX_SET(n)		\
	STMT_START {			\
	    PL_statusvalue = (n);		\
	    if (PL_statusvalue != -1)	\
		PL_statusvalue &= 0xFFFF;	\
	} STMT_END
#   define STATUS_UNIX_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_EXIT_SET(n) STATUS_UNIX_SET(n)
#   define STATUS_CURRENT STATUS_UNIX
#   define STATUS_EXIT STATUS_UNIX
#   define STATUS_ALL_SUCCESS	(PL_statusvalue = 0, PL_statusvalue_posix = 0)
#   define STATUS_ALL_FAILURE	(PL_statusvalue = 1, PL_statusvalue_posix = 1)
#endif

/* flags in PL_exit_flags for nature of exit() */
#define PERL_EXIT_EXPECTED	0x01
#define PERL_EXIT_DESTRUCT_END  0x02  /* Run END in perl_destruct */

#ifndef MEMBER_TO_FPTR
#  define MEMBER_TO_FPTR(name)		name
#endif

/* format to use for version numbers in file/directory names */
/* XXX move to Configure? */
#ifndef PERL_FS_VER_FMT
#  define PERL_FS_VER_FMT	"%d.%d.%d"
#endif

/* This defines a way to flush all output buffers.  This may be a
 * performance issue, so we allow people to disable it.  Also, if
 * we are using stdio, there are broken implementations of fflush(NULL)
 * out there, Solaris being the most prominent.
 */
#ifndef PERL_FLUSHALL_FOR_CHILD
# if defined(USE_PERLIO) || defined(FFLUSH_NULL) || defined(USE_SFIO)
#  define PERL_FLUSHALL_FOR_CHILD	PerlIO_flush((PerlIO*)NULL)
# else
#  ifdef FFLUSH_ALL
#   define PERL_FLUSHALL_FOR_CHILD	my_fflush_all()
#  else
#   define PERL_FLUSHALL_FOR_CHILD	NOOP
#  endif
# endif
#endif

#ifndef PERL_WAIT_FOR_CHILDREN
#  define PERL_WAIT_FOR_CHILDREN	NOOP
#endif

/* the traditional thread-unsafe notion of "current interpreter". */
#ifndef PERL_SET_INTERP
#  define PERL_SET_INTERP(i)		(PL_curinterp = (PerlInterpreter*)(i))
#endif

#ifndef PERL_GET_INTERP
#  define PERL_GET_INTERP		(PL_curinterp)
#endif

#if defined(PERL_IMPLICIT_CONTEXT) && !defined(PERL_GET_THX)
#  ifdef MULTIPLICITY
#    define PERL_GET_THX		((PerlInterpreter *)PERL_GET_CONTEXT)
#  endif
#  define PERL_SET_THX(t)		PERL_SET_CONTEXT(t)
#endif

/* 
    This replaces the previous %_ "hack" by the "%p" hacks.
    All that is required is that the perl source does not
    use "%-p" or "%-<number>p" or "%<number>p" formats.  
    These formats will still work in perl code.   
    See comments in sv.c for futher details.

    Robin Barker 2005-07-14

    No longer use %1p for VDf = %vd.  RMB 2007-10-19 
*/

#ifndef SVf_
#  define SVf_(n) "-" STRINGIFY(n) "p"
#endif

#ifndef SVf
#  define SVf "-p"
#endif

#ifndef SVf32
#  define SVf32 SVf_(32)
#endif

#ifndef SVf256
#  define SVf256 SVf_(256)
#endif

#define SVfARG(p) ((void*)(p))

#ifdef PERL_CORE
/* not used; but needed for backward compatibilty with XS code? - RMB */ 
#  undef VDf
#else
#  ifndef VDf
#    define VDf "vd"
#  endif
#endif

#ifdef PERL_CORE
/* not used; but needed for backward compatibilty with XS code? - RMB */ 
#  undef UVf
#else
#  ifndef UVf
#    define UVf UVuf
#  endif
#endif

#ifdef HASATTRIBUTE_FORMAT
#  define __attribute__format__(x,y,z)      __attribute__((format(x,y,z)))
#endif
#ifdef HASATTRIBUTE_MALLOC
#  define __attribute__malloc__             __attribute__((__malloc__))
#endif
#ifdef HASATTRIBUTE_NONNULL
#  define __attribute__nonnull__(a)         __attribute__((nonnull(a)))
#endif
#ifdef HASATTRIBUTE_NORETURN
#  define __attribute__noreturn__           __attribute__((noreturn))
#endif
#ifdef HASATTRIBUTE_PURE
#  define __attribute__pure__               __attribute__((pure))
#endif
#ifdef HASATTRIBUTE_UNUSED
#  define __attribute__unused__             __attribute__((unused))
#endif
#ifdef HASATTRIBUTE_WARN_UNUSED_RESULT
#  define __attribute__warn_unused_result__ __attribute__((warn_unused_result))
#endif

/* If we haven't defined the attributes yet, define them to blank. */
#ifndef __attribute__format__
#  define __attribute__format__(x,y,z)
#endif
#ifndef __attribute__malloc__
#  define __attribute__malloc__
#endif
#ifndef __attribute__nonnull__
#  define __attribute__nonnull__(a)
#endif
#ifndef __attribute__noreturn__
#  define __attribute__noreturn__
#endif
#ifndef __attribute__pure__
#  define __attribute__pure__
#endif
#ifndef __attribute__unused__
#  define __attribute__unused__
#endif
#ifndef __attribute__warn_unused_result__
#  define __attribute__warn_unused_result__
#endif

/* For functions that are marked as __attribute__noreturn__, it's not
   appropriate to call return.  In either case, include the lint directive.
 */
#ifdef HASATTRIBUTE_NORETURN
#  define NORETURN_FUNCTION_END /* NOTREACHED */
#else
#  define NORETURN_FUNCTION_END /* NOTREACHED */ return 0
#endif

/* Some OS warn on NULL format to printf */
#ifdef PRINTF_FORMAT_NULL_OK
#  define __attribute__format__null_ok__(x,y,z)  __attribute__format__(x,y,z)
#else
#  define __attribute__format__null_ok__(x,y,z)  
#endif

#ifdef HAS_BUILTIN_EXPECT
#  define EXPECT(expr,val)                  __builtin_expect(expr,val)
#else
#  define EXPECT(expr,val)                  (expr)
#endif
#define LIKELY(cond)                        EXPECT(cond,1)
#define UNLIKELY(cond)                      EXPECT(cond,0)
#ifdef HAS_BUILTIN_CHOOSE_EXPR
/* placeholder */
#endif

/* Some unistd.h's give a prototype for pause() even though
   HAS_PAUSE ends up undefined.  This causes the #define
   below to be rejected by the compiler.  Sigh.
*/
#ifdef HAS_PAUSE
#define Pause	pause
#else
#define Pause() sleep((32767<<16)+32767)
#endif

#ifndef IOCPARM_LEN
#   ifdef IOCPARM_MASK
	/* on BSDish systems we're safe */
#	define IOCPARM_LEN(x)  (((x) >> 16) & IOCPARM_MASK)
#   else
#	if defined(_IOC_SIZE) && defined(__GLIBC__)
	/* on Linux systems we're safe; except when we're not [perl #38223] */
#	    define IOCPARM_LEN(x) (_IOC_SIZE(x) < 256 ? 256 : _IOC_SIZE(x))
#	else
	/* otherwise guess at what's safe */
#	    define IOCPARM_LEN(x)	256
#	endif
#   endif
#endif

#if defined(__CYGWIN__)
/* USEMYBINMODE
 *   This symbol, if defined, indicates that the program should
 *   use the routine my_binmode(FILE *fp, char iotype, int mode) to insure
 *   that a file is in "binary" mode -- that is, that no translation
 *   of bytes occurs on read or write operations.
 */
#  define USEMYBINMODE /**/
#  include <io.h> /* for setmode() prototype */
#  define my_binmode(fp, iotype, mode) \
            (PerlLIO_setmode(fileno(fp), mode) != -1 ? TRUE : FALSE)
#endif

#ifdef __CYGWIN__
void init_os_extras(void);
#endif

#ifdef UNION_ANY_DEFINITION
UNION_ANY_DEFINITION;
#else
union any {
    void*	any_ptr;
    I32		any_i32;
    IV		any_iv;
    long	any_long;
    bool	any_bool;
    void	(*any_dptr) (void*);
    void	(*any_dxptr) (pTHX_ void*);
};
#endif

typedef I32 (*filter_t) (pTHX_ int, SV *, int);

#define FILTER_READ(idx, sv, len)  filter_read(idx, sv, len)
#define FILTER_DATA(idx) \
	    (PL_parser ? AvARRAY(PL_parser->rsfp_filters)[idx] : NULL)
#define FILTER_ISREADER(idx) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& idx >= AvFILLp(PL_parser->rsfp_filters))
#define PERL_FILTER_EXISTS(i) \
	    (PL_parser && PL_parser->rsfp_filters \
		&& (i) <= av_len(PL_parser->rsfp_filters))

#if defined(_AIX) && !defined(_AIX43)
#if defined(USE_REENTRANT) || defined(_REENTRANT) || defined(_THREAD_SAFE)
/* We cannot include <crypt.h> to get the struct crypt_data
 * because of setkey prototype problems when threading */
typedef        struct crypt_data {     /* straight from /usr/include/crypt.h */
    /* From OSF, Not needed in AIX
       char C[28], D[28];
    */
    char E[48];
    char KS[16][48];
    char block[66];
    char iobuf[16];
} CRYPTD;
#endif /* threading */
#endif /* AIX */

#if !defined(OS2) && !defined(MACOS_TRADITIONAL)
#  include "iperlsys.h"
#endif

#ifdef __LIBCATAMOUNT__
#undef HAS_PASSWD  /* unixish.h but not unixish enough. */ 
#undef HAS_GROUP
#define FAKE_BIT_BUCKET
#endif

/* [perl #22371] Algorimic Complexity Attack on Perl 5.6.1, 5.8.0.
 * Note that the USE_HASH_SEED and USE_HASH_SEED_EXPLICIT are *NOT*
 * defined by Configure, despite their names being similar to the
 * other defines like USE_ITHREADS.  Configure in fact knows nothing
 * about the randomised hashes.  Therefore to enable/disable the hash
 * randomisation defines use the Configure -Accflags=... instead. */
#if !defined(NO_HASH_SEED) && !defined(USE_HASH_SEED) && !defined(USE_HASH_SEED_EXPLICIT)
#  define USE_HASH_SEED
#endif

/* Win32 defines a type 'WORD' in windef.h. This conflicts with the enumerator
 * 'WORD' defined in perly.h. The yytokentype enum is only a debugging aid, so
 * it's not really needed.
 */
#if defined(WIN32)
#  define YYTOKENTYPE
#endif
#include "perly.h"

#ifdef PERL_MAD
struct nexttoken {
    YYSTYPE next_val;	/* value of next token, if any */
    I32 next_type;	/* type of next token */
    MADPROP *next_mad;	/* everything else about that token */
};
#endif

#include "regexp.h"
#include "sv.h"
#include "util.h"
#include "form.h"
#include "gv.h"
#include "pad.h"
#include "cv.h"
#include "opnames.h"
#include "op.h"
#include "hv.h"
#include "cop.h"
#include "av.h"
#include "mg.h"
#include "scope.h"
#include "warnings.h"
#include "utf8.h"


typedef struct _sublex_info SUBLEXINFO;
struct _sublex_info {
    U8 super_state;	/* lexer state to save */
    U16 sub_inwhat;	/* "lex_inwhat" to use */
    OP *sub_op;		/* "lex_op" to use */
    char *super_bufptr;	/* PL_parser->bufptr that was */
    char *super_bufend;	/* PL_parser->bufend that was */
};

#include "parser.h"

typedef struct magic_state MGS;	/* struct magic_state defined in mg.c */

struct scan_data_t;		/* Used in S_* functions in regcomp.c */
struct regnode_charclass_class;	/* Used in S_* functions in regcomp.c */

/* Keep next first in this structure, because sv_free_arenas take
   advantage of this to share code between the pte arenas and the SV
   body arenas  */
struct ptr_tbl_ent {
    struct ptr_tbl_ent*		next;
    const void*			oldval;
    void*			newval;
};

struct ptr_tbl {
    struct ptr_tbl_ent**	tbl_ary;
    UV				tbl_max;
    UV				tbl_items;
};

#if defined(iAPX286) || defined(M_I286) || defined(I80286)
#   define I286
#endif

#if defined(htonl) && !defined(HAS_HTONL)
#define HAS_HTONL
#endif
#if defined(htons) && !defined(HAS_HTONS)
#define HAS_HTONS
#endif
#if defined(ntohl) && !defined(HAS_NTOHL)
#define HAS_NTOHL
#endif
#if defined(ntohs) && !defined(HAS_NTOHS)
#define HAS_NTOHS
#endif
#ifndef HAS_HTONL
#if (BYTEORDER & 0xffff) != 0x4321
#define HAS_HTONS
#define HAS_HTONL
#define HAS_NTOHS
#define HAS_NTOHL
#define MYSWAP
#define htons my_swap
#define htonl my_htonl
#define ntohs my_swap
#define ntohl my_ntohl
#endif
#else
#if (BYTEORDER & 0xffff) == 0x4321
#undef HAS_HTONS
#undef HAS_HTONL
#undef HAS_NTOHS
#undef HAS_NTOHL
#endif
#endif

/*
 * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.
 * -DWS
 */
#if BYTEORDER != 0x1234
# define HAS_VTOHL
# define HAS_VTOHS
# define HAS_HTOVL
# define HAS_HTOVS
# if BYTEORDER == 0x4321 || BYTEORDER == 0x87654321
#  define vtohl(x)	((((x)&0xFF)<<24)	\
			+(((x)>>24)&0xFF)	\
			+(((x)&0x0000FF00)<<8)	\
			+(((x)&0x00FF0000)>>8)	)
#  define vtohs(x)	((((x)&0xFF)<<8) + (((x)>>8)&0xFF))
#  define htovl(x)	vtohl(x)
#  define htovs(x)	vtohs(x)
# endif
	/* otherwise default to functions in util.c */
#ifndef htovs
short htovs(short n);
short vtohs(short n);
long htovl(long n);
long vtohl(long n);
#endif
#endif

/* *MAX Plus 1. A floating point value.
   Hopefully expressed in a way that dodgy floating point can't mess up.
   >> 2 rather than 1, so that value is safely less than I32_MAX after 1
   is added to it
   May find that some broken compiler will want the value cast to I32.
   [after the shift, as signed >> may not be as secure as unsigned >>]
*/
#define I32_MAX_P1 (2.0 * (1 + (((U32)I32_MAX) >> 1)))
#define U32_MAX_P1 (4.0 * (1 + ((U32_MAX) >> 2)))
/* For compilers that can't correctly cast NVs over 0x7FFFFFFF (or
   0x7FFFFFFFFFFFFFFF) to an unsigned integer. In the future, sizeof(UV)
   may be greater than sizeof(IV), so don't assume that half max UV is max IV.
*/
#define U32_MAX_P1_HALF (2.0 * (1 + ((U32_MAX) >> 2)))

#define UV_MAX_P1 (4.0 * (1 + ((UV_MAX) >> 2)))
#define IV_MAX_P1 (2.0 * (1 + (((UV)IV_MAX) >> 1)))
#define UV_MAX_P1_HALF (2.0 * (1 + ((UV_MAX) >> 2)))

/* This may look like unnecessary jumping through hoops, but converting
   out of range floating point values to integers *is* undefined behaviour,
   and it is starting to bite.
*/
#ifndef CAST_INLINE
#define I_32(what) (cast_i32((NV)(what)))
#define U_32(what) (cast_ulong((NV)(what)))
#define I_V(what) (cast_iv((NV)(what)))
#define U_V(what) (cast_uv((NV)(what)))
#else
#define I_32(n) ((n) < I32_MAX_P1 ? ((n) < I32_MIN ? I32_MIN : (I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (I32)(U32) (n) \
                     : ((n) > 0 ? (I32) U32_MAX : 0 /* NaN */)))
#define U_32(n) ((n) < 0.0 ? ((n) < I32_MIN ? (UV) I32_MIN : (U32)(I32) (n)) \
                  : ((n) < U32_MAX_P1 ? (U32) (n) \
                     : ((n) > 0 ? U32_MAX : 0 /* NaN */)))
#define I_V(n) ((n) < IV_MAX_P1 ? ((n) < IV_MIN ? IV_MIN : (IV) (n)) \
                  : ((n) < UV_MAX_P1 ? (IV)(UV) (n) \
                     : ((n) > 0 ? (IV)UV_MAX : 0 /* NaN */)))
#define U_V(n) ((n) < 0.0 ? ((n) < IV_MIN ? (UV) IV_MIN : (UV)(IV) (n)) \
                  : ((n) < UV_MAX_P1 ? (UV) (n) \
                     : ((n) > 0 ? UV_MAX : 0 /* NaN */)))
#endif

#define U_S(what) ((U16)U_32(what))
#define U_I(what) ((unsigned int)U_32(what))
#define U_L(what) U_32(what)

#ifdef HAS_SIGNBIT
#  define Perl_signbit signbit
#endif

/* These do not care about the fractional part, only about the range. */
#define NV_WITHIN_IV(nv) (I_V(nv) >= IV_MIN && I_V(nv) <= IV_MAX)
#define NV_WITHIN_UV(nv) ((nv)>=0.0 && U_V(nv) >= UV_MIN && U_V(nv) <= UV_MAX)

/* Used with UV/IV arguments: */
					/* XXXX: need to speed it up */
#define CLUMP_2UV(iv)	((iv) < 0 ? 0 : (UV)(iv))
#define CLUMP_2IV(uv)	((uv) > (UV)IV_MAX ? IV_MAX : (IV)(uv))

#ifndef MAXSYSFD
#   define MAXSYSFD 2
#endif

#ifndef __cplusplus
#if !(defined(UNDER_CE) || defined(SYMBIAN))
Uid_t getuid (void);
Uid_t geteuid (void);
Gid_t getgid (void);
Gid_t getegid (void);
#endif
#endif

#ifndef Perl_debug_log
#  define Perl_debug_log	PerlIO_stderr()
#endif

#ifndef Perl_error_log
#  define Perl_error_log	(PL_stderrgv			\
				 && isGV(PL_stderrgv)		\
				 && GvIOp(PL_stderrgv)          \
				 && IoOFP(GvIOp(PL_stderrgv))	\
				 ? IoOFP(GvIOp(PL_stderrgv))	\
				 : PerlIO_stderr())
#endif


#define DEBUG_p_FLAG		0x00000001 /*      1 */
#define DEBUG_s_FLAG		0x00000002 /*      2 */
#define DEBUG_l_FLAG		0x00000004 /*      4 */
#define DEBUG_t_FLAG		0x00000008 /*      8 */
#define DEBUG_o_FLAG		0x00000010 /*     16 */
#define DEBUG_c_FLAG		0x00000020 /*     32 */
#define DEBUG_P_FLAG		0x00000040 /*     64 */
#define DEBUG_m_FLAG		0x00000080 /*    128 */
#define DEBUG_f_FLAG		0x00000100 /*    256 */
#define DEBUG_r_FLAG		0x00000200 /*    512 */
#define DEBUG_x_FLAG		0x00000400 /*   1024 */
#define DEBUG_u_FLAG		0x00000800 /*   2048 */
/* U is reserved for Unofficial, exploratory hacking */
#define DEBUG_U_FLAG		0x00001000 /*   4096 */
#define DEBUG_H_FLAG		0x00002000 /*   8192 */
#define DEBUG_X_FLAG		0x00004000 /*  16384 */
#define DEBUG_D_FLAG		0x00008000 /*  32768 */
#define DEBUG_S_FLAG		0x00010000 /*  65536 */
#define DEBUG_T_FLAG		0x00020000 /* 131072 */
#define DEBUG_R_FLAG		0x00040000 /* 262144 */
#define DEBUG_J_FLAG		0x00080000 /* 524288 */
#define DEBUG_v_FLAG		0x00100000 /*1048576 */
#define DEBUG_C_FLAG		0x00200000 /*2097152 */
#define DEBUG_A_FLAG		0x00400000 /*4194304 */
#define DEBUG_q_FLAG		0x00800000 /*8388608 */
#define DEBUG_MASK		0x00FFEFFF /* mask of all the standard flags */

#define DEBUG_DB_RECURSE_FLAG	0x40000000
#define DEBUG_TOP_FLAG		0x80000000 /* XXX what's this for ??? Signal
					      that something was done? */

#  define DEBUG_p_TEST_ (PL_debug & DEBUG_p_FLAG)
#  define DEBUG_s_TEST_ (PL_debug & DEBUG_s_FLAG)
#  define DEBUG_l_TEST_ (PL_debug & DEBUG_l_FLAG)
#  define DEBUG_t_TEST_ (PL_debug & DEBUG_t_FLAG)
#  define DEBUG_o_TEST_ (PL_debug & DEBUG_o_FLAG)
#  define DEBUG_c_TEST_ (PL_debug & DEBUG_c_FLAG)
#  define DEBUG_P_TEST_ (PL_debug & DEBUG_P_FLAG)
#  define DEBUG_m_TEST_ (PL_debug & DEBUG_m_FLAG)
#  define DEBUG_f_TEST_ (PL_debug & DEBUG_f_FLAG)
#  define DEBUG_r_TEST_ (PL_debug & DEBUG_r_FLAG)
#  define DEBUG_x_TEST_ (PL_debug & DEBUG_x_FLAG)
#  define DEBUG_u_TEST_ (PL_debug & DEBUG_u_FLAG)
#  define DEBUG_U_TEST_ (PL_debug & DEBUG_U_FLAG)
#  define DEBUG_H_TEST_ (PL_debug & DEBUG_H_FLAG)
#  define DEBUG_X_TEST_ (PL_debug & DEBUG_X_FLAG)
#  define DEBUG_D_TEST_ (PL_debug & DEBUG_D_FLAG)
#  define DEBUG_S_TEST_ (PL_debug & DEBUG_S_FLAG)
#  define DEBUG_T_TEST_ (PL_debug & DEBUG_T_FLAG)
#  define DEBUG_R_TEST_ (PL_debug & DEBUG_R_FLAG)
#  define DEBUG_J_TEST_ (PL_debug & DEBUG_J_FLAG)
#  define DEBUG_v_TEST_ (PL_debug & DEBUG_v_FLAG)
#  define DEBUG_C_TEST_ (PL_debug & DEBUG_C_FLAG)
#  define DEBUG_A_TEST_ (PL_debug & DEBUG_A_FLAG)
#  define DEBUG_q_TEST_ (PL_debug & DEBUG_q_FLAG)
#  define DEBUG_Xv_TEST_ (DEBUG_X_TEST_ && DEBUG_v_TEST_)
#  define DEBUG_Uv_TEST_ (DEBUG_U_TEST_ && DEBUG_v_TEST_)

#ifdef DEBUGGING

#  define DEBUG_p_TEST DEBUG_p_TEST_
#  define DEBUG_s_TEST DEBUG_s_TEST_
#  define DEBUG_l_TEST DEBUG_l_TEST_
#  define DEBUG_t_TEST DEBUG_t_TEST_
#  define DEBUG_o_TEST DEBUG_o_TEST_
#  define DEBUG_c_TEST DEBUG_c_TEST_
#  define DEBUG_P_TEST DEBUG_P_TEST_
#  define DEBUG_m_TEST DEBUG_m_TEST_
#  define DEBUG_f_TEST DEBUG_f_TEST_
#  define DEBUG_r_TEST DEBUG_r_TEST_
#  define DEBUG_x_TEST DEBUG_x_TEST_
#  define DEBUG_u_TEST DEBUG_u_TEST_
#  define DEBUG_U_TEST DEBUG_U_TEST_
#  define DEBUG_H_TEST DEBUG_H_TEST_
#  define DEBUG_X_TEST DEBUG_X_TEST_
#  define DEBUG_D_TEST DEBUG_D_TEST_
#  define DEBUG_S_TEST DEBUG_S_TEST_
#  define DEBUG_T_TEST DEBUG_T_TEST_
#  define DEBUG_R_TEST DEBUG_R_TEST_
#  define DEBUG_J_TEST DEBUG_J_TEST_
#  define DEBUG_v_TEST DEBUG_v_TEST_
#  define DEBUG_C_TEST DEBUG_C_TEST_
#  define DEBUG_A_TEST DEBUG_A_TEST_
#  define DEBUG_q_TEST DEBUG_q_TEST_
#  define DEBUG_Xv_TEST DEBUG_Xv_TEST_
#  define DEBUG_Uv_TEST DEBUG_Uv_TEST_

#  define PERL_DEB(a)                  a
#  define PERL_DEBUG(a) if (PL_debug)  a
#  define DEBUG_p(a) if (DEBUG_p_TEST) a
#  define DEBUG_s(a) if (DEBUG_s_TEST) a
#  define DEBUG_l(a) if (DEBUG_l_TEST) a
#  define DEBUG_t(a) if (DEBUG_t_TEST) a
#  define DEBUG_o(a) if (DEBUG_o_TEST) a
#  define DEBUG_c(a) if (DEBUG_c_TEST) a
#  define DEBUG_P(a) if (DEBUG_P_TEST) a

     /* Temporarily turn off memory debugging in case the a
      * does memory allocation, either directly or indirectly. */
#  define DEBUG_m(a)  \
    STMT_START {							\
        if (PERL_GET_INTERP) { dTHX; if (DEBUG_m_TEST) {PL_debug&=~DEBUG_m_FLAG; a; PL_debug|=DEBUG_m_FLAG;} } \
    } STMT_END

#  define DEBUG__(t, a) \
	STMT_START { \
		if (t) STMT_START {a;} STMT_END; \
	} STMT_END

#  define DEBUG_f(a) DEBUG__(DEBUG_f_TEST, a)
#ifndef PERL_EXT_RE_BUILD
#  define DEBUG_r(a) DEBUG__(DEBUG_r_TEST, a)
#else
#  define DEBUG_r(a) STMT_START {a;} STMT_END
#endif /* PERL_EXT_RE_BUILD */
#  define DEBUG_x(a) DEBUG__(DEBUG_x_TEST, a)
#  define DEBUG_u(a) DEBUG__(DEBUG_u_TEST, a)
#  define DEBUG_U(a) DEBUG__(DEBUG_U_TEST, a)
#  define DEBUG_H(a) DEBUG__(DEBUG_H_TEST, a)
#  define DEBUG_X(a) DEBUG__(DEBUG_X_TEST, a)
#  define DEBUG_D(a) DEBUG__(DEBUG_D_TEST, a)
#  define DEBUG_Xv(a) DEBUG__(DEBUG_Xv_TEST, a)
#  define DEBUG_Uv(a) DEBUG__(DEBUG_Uv_TEST, a)

#  define DEBUG_S(a)

#  define DEBUG_T(a) DEBUG__(DEBUG_T_TEST, a)
#  define DEBUG_R(a) DEBUG__(DEBUG_R_TEST, a)
#  define DEBUG_v(a) DEBUG__(DEBUG_v_TEST, a)
#  define DEBUG_C(a) DEBUG__(DEBUG_C_TEST, a)
#  define DEBUG_A(a) DEBUG__(DEBUG_A_TEST, a)
#  define DEBUG_q(a) DEBUG__(DEBUG_q_TEST, a)

#else /* DEBUGGING */

#  define DEBUG_p_TEST (0)
#  define DEBUG_s_TEST (0)
#  define DEBUG_l_TEST (0)
#  define DEBUG_t_TEST (0)
#  define DEBUG_o_TEST (0)
#  define DEBUG_c_TEST (0)
#  define DEBUG_P_TEST (0)
#  define DEBUG_m_TEST (0)
#  define DEBUG_f_TEST (0)
#  define DEBUG_r_TEST (0)
#  define DEBUG_x_TEST (0)
#  define DEBUG_u_TEST (0)
#  define DEBUG_U_TEST (0)
#  define DEBUG_H_TEST (0)
#  define DEBUG_X_TEST (0)
#  define DEBUG_D_TEST (0)
#  define DEBUG_S_TEST (0)
#  define DEBUG_T_TEST (0)
#  define DEBUG_R_TEST (0)
#  define DEBUG_J_TEST (0)
#  define DEBUG_v_TEST (0)
#  define DEBUG_C_TEST (0)
#  define DEBUG_A_TEST (0)
#  define DEBUG_q_TEST (0)
#  define DEBUG_Xv_TEST (0)
#  define DEBUG_Uv_TEST (0)

#  define PERL_DEB(a)
#  define PERL_DEBUG(a)
#  define DEBUG_p(a)
#  define DEBUG_s(a)
#  define DEBUG_l(a)
#  define DEBUG_t(a)
#  define DEBUG_o(a)
#  define DEBUG_c(a)
#  define DEBUG_P(a)
#  define DEBUG_m(a)
#  define DEBUG_f(a)
#  define DEBUG_r(a)
#  define DEBUG_x(a)
#  define DEBUG_u(a)
#  define DEBUG_U(a)
#  define DEBUG_H(a)
#  define DEBUG_X(a)
#  define DEBUG_D(a)
#  define DEBUG_S(a)
#  define DEBUG_T(a)
#  define DEBUG_R(a)
#  define DEBUG_v(a)
#  define DEBUG_C(a)
#  define DEBUG_A(a)
#  define DEBUG_q(a)
#  define DEBUG_Xv(a)
#  define DEBUG_Uv(a)
#endif /* DEBUGGING */


#define DEBUG_SCOPE(where) \
    DEBUG_l(WITH_THR(Perl_deb(aTHX_ "%s scope %ld at %s:%d\n",	\
		    where, (long)PL_scopestack_ix, __FILE__, __LINE__)));




/* These constants should be used in preference to raw characters
 * when using magic. Note that some perl guts still assume
 * certain character properties of these constants, namely that
 * isUPPER() and toLOWER() may do useful mappings.
 *
 * Update the magic_names table in dump.c when adding/amending these
 */

#define PERL_MAGIC_sv		  '\0' /* Special scalar variable */
#define PERL_MAGIC_overload	  'A' /* %OVERLOAD hash */
#define PERL_MAGIC_overload_elem  'a' /* %OVERLOAD hash element */
#define PERL_MAGIC_overload_table 'c' /* Holds overload table (AMT) on stash */
#define PERL_MAGIC_bm		  'B' /* Boyer-Moore (fast string search) */
#define PERL_MAGIC_regdata	  'D' /* Regex match position data
					(@+ and @- vars) */
#define PERL_MAGIC_regdatum	  'd' /* Regex match position data element */
#define PERL_MAGIC_env		  'E' /* %ENV hash */
#define PERL_MAGIC_envelem	  'e' /* %ENV hash element */
#define PERL_MAGIC_fm		  'f' /* Formline ('compiled' format) */
#define PERL_MAGIC_regex_global	  'g' /* m//g target / study()ed string */
#define PERL_MAGIC_hints	  'H' /* %^H hash */
#define PERL_MAGIC_hintselem	  'h' /* %^H hash element */
#define PERL_MAGIC_isa		  'I' /* @ISA array */
#define PERL_MAGIC_isaelem	  'i' /* @ISA array element */
#define PERL_MAGIC_nkeys	  'k' /* scalar(keys()) lvalue */
#define PERL_MAGIC_dbfile	  'L' /* Debugger %_<filename */
#define PERL_MAGIC_dbline	  'l' /* Debugger %_<filename element */
#define PERL_MAGIC_shared	  'N' /* Shared between threads */
#define PERL_MAGIC_shared_scalar  'n' /* Shared between threads */
#define PERL_MAGIC_collxfrm	  'o' /* Locale transformation */
#define PERL_MAGIC_tied		  'P' /* Tied array or hash */
#define PERL_MAGIC_tiedelem	  'p' /* Tied array or hash element */
#define PERL_MAGIC_tiedscalar	  'q' /* Tied scalar or handle */
#define PERL_MAGIC_qr		  'r' /* precompiled qr// regex */
#define PERL_MAGIC_sig		  'S' /* %SIG hash */
#define PERL_MAGIC_sigelem	  's' /* %SIG hash element */
#define PERL_MAGIC_taint	  't' /* Taintedness */
#define PERL_MAGIC_uvar		  'U' /* Available for use by extensions */
#define PERL_MAGIC_uvar_elem	  'u' /* Reserved for use by extensions */
#define PERL_MAGIC_vec		  'v' /* vec() lvalue */
#define PERL_MAGIC_vstring	  'V' /* SV was vstring literal */
#define PERL_MAGIC_utf8		  'w' /* Cached UTF-8 information */
#define PERL_MAGIC_substr	  'x' /* substr() lvalue */
#define PERL_MAGIC_defelem	  'y' /* Shadow "foreach" iterator variable /
					smart parameter vivification */
#define PERL_MAGIC_arylen	  '#' /* Array length ($#ary) */
#define PERL_MAGIC_pos		  '.' /* pos() lvalue */
#define PERL_MAGIC_backref	  '<' /* for weak ref data */
#define PERL_MAGIC_symtab	  ':' /* extra data for symbol tables */
#define PERL_MAGIC_rhash	  '%' /* extra data for restricted hashes */
#define PERL_MAGIC_arylen_p	  '@' /* to move arylen out of XPVAV */
#define PERL_MAGIC_ext		  '~' /* Available for use by extensions */


#ifndef assert  /* <assert.h> might have been included somehow */
#define assert(what)	PERL_DEB( 					\
	((what) ? ((void) 0) :						\
	    (Perl_croak_nocontext("Assertion %s failed: file \"" __FILE__ \
			"\", line %d", STRINGIFY(what), __LINE__),	\
	    (void) 0)))
#endif

struct ufuncs {
    I32 (*uf_val)(pTHX_ IV, SV*);
    I32 (*uf_set)(pTHX_ IV, SV*);
    IV uf_index;
};

/* In pre-5.7-Perls the PERL_MAGIC_uvar magic didn't get the thread context.
 * XS code wanting to be backward compatible can do something
 * like the following:

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(IV ix, SV *sv)
#endif

static PERL_MG_UFUNC(foo_get, index, val)
{
    sv_setsv(val, ...);
    return TRUE;
}

-- Doug MacEachern

*/

#ifndef PERL_MG_UFUNC
#define PERL_MG_UFUNC(name,ix,sv) I32 name(pTHX_ IV ix, SV *sv)
#endif

/* Fix these up for __STDC__ */
#ifndef DONT_DECLARE_STD
char *mktemp (char*);
#ifndef atof
double atof (const char*);
#endif
#endif

#ifndef STANDARD_C
/* All of these are in stdlib.h or time.h for ANSI C */
Time_t time();
struct tm *gmtime(), *localtime();
#if defined(OEMVS) || defined(__OPEN_VM)
char *(strchr)(), *(strrchr)();
char *(strcpy)(), *(strcat)();
#else
char *strchr(), *strrchr();
char *strcpy(), *strcat();
#endif
#endif /* ! STANDARD_C */


#ifdef I_MATH
#    include <math.h>
#else
START_EXTERN_C
	    double exp (double);
	    double log (double);
	    double log10 (double);
	    double sqrt (double);
	    double frexp (double,int*);
	    double ldexp (double,int);
	    double modf (double,double*);
	    double sin (double);
	    double cos (double);
	    double atan2 (double,double);
	    double pow (double,double);
END_EXTERN_C
#endif

#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(LDBL_INFINITY)
#  define NV_INF LDBL_INFINITY
#endif
#if !defined(NV_INF) && defined(DBL_INFINITY)
#  define NV_INF (NV)DBL_INFINITY
#endif
#if !defined(NV_INF) && defined(INFINITY)
#  define NV_INF (NV)INFINITY
#endif
#if !defined(NV_INF) && defined(INF)
#  define NV_INF (NV)INF
#endif
#if !defined(NV_INF) && defined(USE_LONG_DOUBLE) && defined(HUGE_VALL)
#  define NV_INF (NV)HUGE_VALL
#endif
#if !defined(NV_INF) && defined(HUGE_VAL)
#  define NV_INF (NV)HUGE_VAL
#endif

#if !defined(NV_NAN) && defined(USE_LONG_DOUBLE)
#   if !defined(NV_NAN) && defined(LDBL_NAN)
#       define NV_NAN LDBL_NAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_QNAN)
#       define NV_NAN LDBL_QNAN
#   endif
#   if !defined(NV_NAN) && defined(LDBL_SNAN)
#       define NV_NAN LDBL_SNAN
#   endif
#endif
#if !defined(NV_NAN) && defined(DBL_NAN)
#  define NV_NAN (NV)DBL_NAN
#endif
#if !defined(NV_NAN) && defined(DBL_QNAN)
#  define NV_NAN (NV)DBL_QNAN
#endif
#if !defined(NV_NAN) && defined(DBL_SNAN)
#  define NV_NAN (NV)DBL_SNAN
#endif
#if !defined(NV_NAN) && defined(QNAN)
#  define NV_NAN (NV)QNAN
#endif
#if !defined(NV_NAN) && defined(SNAN)
#  define NV_NAN (NV)SNAN
#endif
#if !defined(NV_NAN) && defined(NAN)
#  define NV_NAN (NV)NAN
#endif

#ifndef __cplusplus
#  if defined(NeXT) || defined(__NeXT__) /* or whatever catches all NeXTs */
char *crypt ();       /* Maybe more hosts will need the unprototyped version */
#  else
#    if !defined(WIN32) && !defined(VMS)
#ifndef crypt
char *crypt (const char*, const char*);
#endif
#    endif /* !WIN32 */
#  endif /* !NeXT && !__NeXT__ */
#  ifndef DONT_DECLARE_STD
#    ifndef getenv
char *getenv (const char*);
#    endif /* !getenv */
#    if !defined(HAS_LSEEK_PROTO) && !defined(EPOC) && !defined(__hpux)
#      ifdef _FILE_OFFSET_BITS
#        if _FILE_OFFSET_BITS == 64
Off_t lseek (int,Off_t,int);
#        endif
#      endif
#    endif
#  endif /* !DONT_DECLARE_STD */
#ifndef getlogin
char *getlogin (void);
#endif
#endif /* !__cplusplus */

/* Fixme on VMS.  This needs to be a run-time, not build time options */
/* Also rename() is affected by this */
#ifdef UNLINK_ALL_VERSIONS /* Currently only makes sense for VMS */
#define UNLINK unlnk
I32 unlnk (pTHX_ const char*);
#else
#define UNLINK PerlLIO_unlink
#endif

/* some versions of glibc are missing the setresuid() proto */
#if defined(HAS_SETRESUID) && !defined(HAS_SETRESUID_PROTO)
int setresuid(uid_t ruid, uid_t euid, uid_t suid);
#endif
/* some versions of glibc are missing the setresgid() proto */
#if defined(HAS_SETRESGID) && !defined(HAS_SETRESGID_PROTO)
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
#endif

#ifndef HAS_SETREUID
#  ifdef HAS_SETRESUID
#    define setreuid(r,e) setresuid(r,e,(Uid_t)-1)
#    define HAS_SETREUID
#  endif
#endif
#ifndef HAS_SETREGID
#  ifdef HAS_SETRESGID
#    define setregid(r,e) setresgid(r,e,(Gid_t)-1)
#    define HAS_SETREGID
#  endif
#endif

/* Sighandler_t defined in iperlsys.h */

#ifdef HAS_SIGACTION
typedef struct sigaction Sigsave_t;
#else
typedef Sighandler_t Sigsave_t;
#endif

#define SCAN_DEF 0
#define SCAN_TR 1
#define SCAN_REPL 2

#ifdef DEBUGGING
# ifndef register
#  define register
# endif
# define RUNOPS_DEFAULT Perl_runops_debug
#else
# define RUNOPS_DEFAULT Perl_runops_standard
#endif

#ifdef USE_PERLIO
EXTERN_C void PerlIO_teardown();
# ifdef USE_ITHREADS
#  define PERLIO_INIT MUTEX_INIT(&PL_perlio_mutex)
#  define PERLIO_TERM 				\
	STMT_START {				\
		PerlIO_teardown();		\
		MUTEX_DESTROY(&PL_perlio_mutex);\
	} STMT_END
# else
#  define PERLIO_INIT
#  define PERLIO_TERM	PerlIO_teardown()
# endif
#else
#  define PERLIO_INIT
#  define PERLIO_TERM
#endif

#ifdef MYMALLOC
#  ifdef MUTEX_INIT_CALLS_MALLOC
#    define MALLOC_INIT					\
	STMT_START {					\
		PL_malloc_mutex = NULL;			\
		MUTEX_INIT(&PL_malloc_mutex);		\
	} STMT_END
#    define MALLOC_TERM					\
	STMT_START {					\
		perl_mutex tmp = PL_malloc_mutex;	\
		PL_malloc_mutex = NULL;			\
		MUTEX_DESTROY(&tmp);			\
	} STMT_END
#  else
#    define MALLOC_INIT MUTEX_INIT(&PL_malloc_mutex)
#    define MALLOC_TERM MUTEX_DESTROY(&PL_malloc_mutex)
#  endif
#else
#  define MALLOC_INIT
#  define MALLOC_TERM
#endif

#if defined(PERL_IMPLICIT_CONTEXT)

struct perl_memory_debug_header;
struct perl_memory_debug_header {
  tTHX	interpreter;
#  ifdef PERL_POISON
  MEM_SIZE size;
#  endif
  struct perl_memory_debug_header *prev;
  struct perl_memory_debug_header *next;
};

#  define sTHX	(sizeof(struct perl_memory_debug_header) + \
	(MEM_ALIGNBYTES - sizeof(struct perl_memory_debug_header) \
	 %MEM_ALIGNBYTES) % MEM_ALIGNBYTES)

#endif

#ifdef PERL_TRACK_MEMPOOL
#  define INIT_TRACK_MEMPOOL(header, interp)			\
	STMT_START {						\
		(header).interpreter = (interp);		\
		(header).prev = (header).next = &(header);	\
	} STMT_END
#  else
#  define INIT_TRACK_MEMPOOL(header, interp)
#endif


typedef int (CPERLscope(*runops_proc_t)) (pTHX);
typedef void (CPERLscope(*share_proc_t)) (pTHX_ SV *sv);
typedef int  (CPERLscope(*thrhook_proc_t)) (pTHX);
typedef OP* (CPERLscope(*PPADDR_t)[]) (pTHX);
typedef bool (CPERLscope(*destroyable_proc_t)) (pTHX_ SV *sv);

/* _ (for $_) must be first in the following list (DEFSV requires it) */
#define THREADSV_NAMES "_123456789&`'+/.,\\\";^-%=|~:\001\005!@"

/* NeXT has problems with crt0.o globals */
#if defined(__DYNAMIC__) && \
    (defined(NeXT) || defined(__NeXT__) || defined(PERL_DARWIN))
#  if defined(NeXT) || defined(__NeXT)
#    include <mach-o/dyld.h>
#    define environ (*environ_pointer)
EXT char *** environ_pointer;
#  else
#    if defined(PERL_DARWIN) && defined(PERL_CORE)
#      include <crt_externs.h>	/* for the env array */
#      define environ (*_NSGetEnviron())
#    endif
#  endif
#else
   /* VMS and some other platforms don't use the environ array */
#  ifdef USE_ENVIRON_ARRAY
#    if !defined(DONT_DECLARE_STD) || \
        (defined(__svr4__) && defined(__GNUC__) && defined(sun)) || \
        defined(__sgi) || \
        defined(__DGUX)
extern char **	environ;	/* environment variables supplied via exec */
#    endif
#  endif
#endif

START_EXTERN_C

/* handy constants */
EXTCONST char PL_warn_uninit[]
  INIT("Use of uninitialized value%s%s%s");
EXTCONST char PL_warn_nosemi[]
  INIT("Semicolon seems to be missing");
EXTCONST char PL_warn_reserved[]
  INIT("Unquoted string \"%s\" may clash with future reserved word");
EXTCONST char PL_warn_nl[]
  INIT("Unsuccessful %s on filename containing newline");
EXTCONST char PL_no_wrongref[]
  INIT("Can't use %s ref as %s ref");
EXTCONST char PL_no_symref[]
  INIT("Can't use string (\"%.32s\") as %s ref while \"strict refs\" in use");
EXTCONST char PL_no_symref_sv[]
  INIT("Can't use string (\"%" SVf32 "\") as %s ref while \"strict refs\" in use");
EXTCONST char PL_no_usym[]
  INIT("Can't use an undefined value as %s reference");
EXTCONST char PL_no_aelem[]
  INIT("Modification of non-creatable array value attempted, subscript %d");
EXTCONST char PL_no_helem_sv[]
  INIT("Modification of non-creatable hash value attempted, subscript \"%"SVf"\"");
EXTCONST char PL_no_modify[]
  INIT("Modification of a read-only value attempted");
EXTCONST char PL_no_mem[]
  INIT("Out of memory!\n");
EXTCONST char PL_no_security[]
  INIT("Insecure dependency in %s%s");
EXTCONST char PL_no_sock_func[]
  INIT("Unsupported socket function \"%s\" called");
EXTCONST char PL_no_dir_func[]
  INIT("Unsupported directory function \"%s\" called");
EXTCONST char PL_no_func[]
  INIT("The %s function is unimplemented");
EXTCONST char PL_no_myglob[]
  INIT("\"%s\" variable %s can't be in a package");
EXTCONST char PL_no_localize_ref[]
  INIT("Can't localize through a reference");
EXTCONST char PL_memory_wrap[]
  INIT("panic: memory wrap");

#ifdef CSH
EXTCONST char PL_cshname[]
  INIT(CSH);
#  define PL_cshlen	(sizeof(CSH "") - 1)
#endif

EXTCONST char PL_uuemap[65]
  INIT("`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_");

#ifdef DOINIT
EXTCONST char PL_uudmap[256] =
#include "uudmap.h"
;
EXTCONST char* const PL_sig_name[] = { SIG_NAME };
EXTCONST int         PL_sig_num[]  = { SIG_NUM };
#else
EXTCONST char PL_uudmap[256];
EXTCONST char* const PL_sig_name[];
EXTCONST int         PL_sig_num[];
#endif

/* fast conversion and case folding tables */

#ifdef DOINIT
#ifdef EBCDIC
EXTCONST unsigned char PL_fold[] = { /* fast EBCDIC case folding table */
    0,      1,      2,      3,      4,      5,      6,      7,
    8,      9,      10,     11,     12,     13,     14,     15,
    16,     17,     18,     19,     20,     21,     22,     23,
    24,     25,     26,     27,     28,     29,     30,     31,
    32,     33,     34,     35,     36,     37,     38,     39,
    40,     41,     42,     43,     44,     45,     46,     47,
    48,     49,     50,     51,     52,     53,     54,     55,
    56,     57,     58,     59,     60,     61,     62,     63,
    64,     65,     66,     67,     68,     69,     70,     71,
    72,     73,     74,     75,     76,     77,     78,     79,
    80,     81,     82,     83,     84,     85,     86,     87,
    88,     89,     90,     91,     92,     93,     94,     95,
    96,     97,     98,     99,     100,    101,    102,    103,
    104,    105,    106,    107,    108,    109,    110,    111,
    112,    113,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    123,    124,    125,    126,    127,
    128,    'A',    'B',    'C',    'D',    'E',    'F',    'G',
    'H',    'I',    138,    139,    140,    141,    142,    143,
    144,    'J',    'K',    'L',    'M',    'N',    'O',    'P',
    'Q',    'R',    154,    155,    156,    157,    158,    159,
    160,    161,    'S',    'T',    'U',    'V',    'W',    'X',
    'Y',    'Z',    170,    171,    172,    173,    174,    175,
    176,    177,    178,    179,    180,    181,    182,    183,
    184,    185,    186,    187,    188,    189,    190,    191,
    192,    'a',    'b',    'c',    'd',    'e',    'f',    'g',
    'h',    'i',    202,    203,    204,    205,    206,    207,
    208,    'j',    'k',    'l',    'm',    'n',    'o',    'p',
    'q',    'r',    218,    219,    220,    221,    222,    223,
    224,    225,    's',    't',    'u',    'v',    'w',    'x',
    'y',    'z',    234,    235,    236,    237,    238,    239,
    240,    241,    242,    243,    244,    245,    246,    247,
    248,    249,    250,    251,    252,    253,    254,    255
};
#else   /* ascii rather than ebcdic */
EXTCONST  unsigned char PL_fold[] = {
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#endif  /* !EBCDIC */
#else
EXTCONST unsigned char PL_fold[];
#endif

#ifndef PERL_GLOBAL_STRUCT /* or perlvars.h */
#ifdef DOINIT
EXT unsigned char PL_fold_locale[] = { /* Unfortunately not EXTCONST. */
	0,	1,	2,	3,	4,	5,	6,	7,
	8,	9,	10,	11,	12,	13,	14,	15,
	16,	17,	18,	19,	20,	21,	22,	23,
	24,	25,	26,	27,	28,	29,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	40,	41,	42,	43,	44,	45,	46,	47,
	48,	49,	50,	51,	52,	53,	54,	55,
	56,	57,	58,	59,	60,	61,	62,	63,
	64,	'a',	'b',	'c',	'd',	'e',	'f',	'g',
	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
	'x',	'y',	'z',	91,	92,	93,	94,	95,
	96,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
	'X',	'Y',	'Z',	123,	124,	125,	126,	127,
	128,	129,	130,	131,	132,	133,	134,	135,
	136,	137,	138,	139,	140,	141,	142,	143,
	144,	145,	146,	147,	148,	149,	150,	151,
	152,	153,	154,	155,	156,	157,	158,	159,
	160,	161,	162,	163,	164,	165,	166,	167,
	168,	169,	170,	171,	172,	173,	174,	175,
	176,	177,	178,	179,	180,	181,	182,	183,
	184,	185,	186,	187,	188,	189,	190,	191,
	192,	193,	194,	195,	196,	197,	198,	199,
	200,	201,	202,	203,	204,	205,	206,	207,
	208,	209,	210,	211,	212,	213,	214,	215,
	216,	217,	218,	219,	220,	221,	222,	223,	
	224,	225,	226,	227,	228,	229,	230,	231,
	232,	233,	234,	235,	236,	237,	238,	239,
	240,	241,	242,	243,	244,	245,	246,	247,
	248,	249,	250,	251,	252,	253,	254,	255
};
#else
EXT unsigned char PL_fold_locale[]; /* Unfortunately not EXTCONST. */
#endif
#endif /* !PERL_GLOBAL_STRUCT */

#ifdef DOINIT
#ifdef EBCDIC
EXTCONST unsigned char PL_freq[] = {/* EBCDIC frequencies for mixed English/C */
    1,      2,      84,     151,    154,    155,    156,    157,
    165,    246,    250,    3,      158,    7,      18,     29,
    40,     51,     62,     73,     85,     96,     107,    118,
    129,    140,    147,    148,    149,    150,    152,    153,
    255,      6,      8,      9,     10,     11,     12,     13,
     14,     15,     24,     25,     26,     27,     28,    226,
     29,     30,     31,     32,     33,     43,     44,     45,
     46,     47,     48,     49,     50,     76,     77,     78,
     79,     80,     81,     82,     83,     84,     85,     86,
     87,     94,     95,    234,    181,    233,    187,    190,
    180,     96,     97,     98,     99,    100,    101,    102,
    104,    112,    182,    174,    236,    232,    229,    103,
    228,    226,    114,    115,    116,    117,    118,    119,
    120,    121,    122,    235,    176,    230,    194,    162,
    130,    131,    132,    133,    134,    135,    136,    137,
    138,    139,    201,    205,    163,    217,    220,    224,
    5,      248,    227,    244,    242,    255,    241,    231,
    240,    253,    16,     197,    19,     20,     21,     187,
    23,     169,    210,    245,    237,    249,    247,    239,
    168,    252,    34,     196,    36,     37,     38,     39,
    41,     42,     251,    254,    238,    223,    221,    213,
    225,    177,    52,     53,     54,     55,     56,     57,
    58,     59,     60,     61,     63,     64,     65,     66,
    67,     68,     69,     70,     71,     72,     74,     75,
    205,    208,    186,    202,    200,    218,    198,    179,
    178,    214,    88,     89,     90,     91,     92,     93,
    217,    166,    170,    207,    199,    209,    206,    204,
    160,    212,    105,    106,    108,    109,    110,    111,
    203,    113,    216,    215,    192,    175,    193,    243,
    172,    161,    123,    124,    125,    126,    127,    128,
    222,    219,    211,    195,    188,    193,    185,    184,
    191,    183,    141,    142,    143,    144,    145,    146
};
#else  /* ascii rather than ebcdic */
EXTCONST unsigned char PL_freq[] = {	/* letter frequencies for mixed English/C */
	1,	2,	84,	151,	154,	155,	156,	157,
	165,	246,	250,	3,	158,	7,	18,	29,
	40,	51,	62,	73,	85,	96,	107,	118,
	129,	140,	147,	148,	149,	150,	152,	153,
	255,	182,	224,	205,	174,	176,	180,	217,
	233,	232,	236,	187,	235,	228,	234,	226,
	222,	219,	211,	195,	188,	193,	185,	184,
	191,	183,	201,	229,	181,	220,	194,	162,
	163,	208,	186,	202,	200,	218,	198,	179,
	178,	214,	166,	170,	207,	199,	209,	206,
	204,	160,	212,	216,	215,	192,	175,	173,
	243,	172,	161,	190,	203,	189,	164,	230,
	167,	248,	227,	244,	242,	255,	241,	231,
	240,	253,	169,	210,	245,	237,	249,	247,
	239,	168,	252,	251,	254,	238,	223,	221,
	213,	225,	177,	197,	171,	196,	159,	4,
	5,	6,	8,	9,	10,	11,	12,	13,
	14,	15,	16,	17,	19,	20,	21,	22,
	23,	24,	25,	26,	27,	28,	30,	31,
	32,	33,	34,	35,	36,	37,	38,	39,
	41,	42,	43,	44,	45,	46,	47,	48,
	49,	50,	52,	53,	54,	55,	56,	57,
	58,	59,	60,	61,	63,	64,	65,	66,
	67,	68,	69,	70,	71,	72,	74,	75,
	76,	77,	78,	79,	80,	81,	82,	83,
	86,	87,	88,	89,	90,	91,	92,	93,
	94,	95,	97,	98,	99,	100,	101,	102,
	103,	104,	105,	106,	108,	109,	110,	111,
	112,	113,	114,	115,	116,	117,	119,	120,
	121,	122,	123,	124,	125,	126,	127,	128,
	130,	131,	132,	133,	134,	135,	136,	137,
	138,	139,	141,	142,	143,	144,	145,	146
};
#endif
#else
EXTCONST unsigned char PL_freq[];
#endif

#ifdef DEBUGGING
#ifdef DOINIT
EXTCONST char* const PL_block_type[] = {
	"NULL",
	"SUB",
	"EVAL",
	"LOOP",
	"SUBST",
	"BLOCK",
	"FORMAT",
	"GIVEN",
	"WHEN"
};
#else
EXTCONST char* PL_block_type[];
#endif
#endif

/* These are all the compile time options that affect binary compatibility.
   Other compile time options that are binary compatible are in perl.c
   Both are combined for the output of perl -V
   However, this string will be embedded in any shared perl library, which will
   allow us add a comparison check in perlmain.c in the near future.  */
#ifdef DOINIT
EXTCONST char PL_bincompat_options[] =
#  ifdef DEBUG_LEAKING_SCALARS
			     " DEBUG_LEAKING_SCALARS"
#  endif
#  ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
			     " DEBUG_LEAKING_SCALARS_FORK_DUMP"
#  endif
#  ifdef FAKE_THREADS
			     " FAKE_THREADS"
#  endif
#  ifdef MULTIPLICITY
			     " MULTIPLICITY"
#  endif
#  ifdef MYMALLOC
			     " MYMALLOC"
#  endif
#  ifdef PERL_DEBUG_READONLY_OPS
			     " PERL_DEBUG_READONLY_OPS"
#  endif
#  ifdef PERL_GLOBAL_STRUCT
			     " PERL_GLOBAL_STRUCT"
#  endif
#  ifdef PERL_IMPLICIT_CONTEXT
			     " PERL_IMPLICIT_CONTEXT"
#  endif
#  ifdef PERL_IMPLICIT_SYS
			     " PERL_IMPLICIT_SYS"
#  endif
#  ifdef PERL_MAD
			     " PERL_MAD"
#  endif
#  ifdef PERL_NEED_APPCTX
			     " PERL_NEED_APPCTX"
#  endif
#  ifdef PERL_NEED_TIMESBASE
			     " PERL_NEED_TIMESBASE"
#  endif
#  ifdef PERL_OLD_COPY_ON_WRITE
			     " PERL_OLD_COPY_ON_WRITE"
#  endif
#  ifdef PERL_POISON
			     " PERL_POISON"
#  endif
#  ifdef PERL_TRACK_MEMPOOL
			     " PERL_TRACK_MEMPOOL"
#  endif
#  ifdef PERL_USES_PL_PIDSTATUS
			     " PERL_USES_PL_PIDSTATUS"
#  endif
#  ifdef PL_OP_SLAB_ALLOC
			     " PL_OP_SLAB_ALLOC"
#  endif
#  ifdef THREADS_HAVE_PIDS
			     " THREADS_HAVE_PIDS"
#  endif
#  ifdef USE_64_BIT_ALL
			     " USE_64_BIT_ALL"
#  endif
#  ifdef USE_64_BIT_INT
			     " USE_64_BIT_INT"
#  endif
#  ifdef USE_IEEE
			     " USE_IEEE"
#  endif
#  ifdef USE_ITHREADS
			     " USE_ITHREADS"
#  endif
#  ifdef USE_LARGE_FILES
			     " USE_LARGE_FILES"
#  endif
#  ifdef USE_LONG_DOUBLE
			     " USE_LONG_DOUBLE"
#  endif
#  ifdef USE_PERLIO
			     " USE_PERLIO"
#  endif
#  ifdef USE_REENTRANT_API
			     " USE_REENTRANT_API"
#  endif
#  ifdef USE_SFIO
			     " USE_SFIO"
#  endif
#  ifdef USE_SOCKS
			     " USE_SOCKS"
#  endif
#  ifdef VMS_DO_SOCKETS
			     " VMS_DO_SOCKETS"
#    ifdef DECCRTL_SOCKETS
			     " DECCRTL_SOCKETS"
#    endif
#  endif
#  ifdef VMS_WE_ARE_CASE_SENSITIVE
			     " VMS_SYMBOL_CASE_AS_IS"
#  endif
  "";
#else
EXTCONST char PL_bincompat_options[];
#endif

END_EXTERN_C

/*****************************************************************************/
/* This lexer/parser stuff is currently global since yacc is hard to reenter */
/*****************************************************************************/
/* XXX This needs to be revisited, since BEGIN makes yacc re-enter... */

#ifdef __Lynx__
/* LynxOS defines these in scsi.h which is included via ioctl.h */
#ifdef FORMAT
#undef FORMAT
#endif
#ifdef SPACE
#undef SPACE
#endif
#endif

#define LEX_NOTPARSING		11	/* borrowed from toke.c */

typedef enum {
    XOPERATOR,
    XTERM,
    XREF,
    XSTATE,
    XBLOCK,
    XATTRBLOCK,
    XATTRTERM,
    XTERMBLOCK,
    XTERMORDORDOR /* evil hack */
    /* update exp_name[] in toke.c if adding to this enum */
} expectation;

enum {		/* pass one of these to get_vtbl */
    want_vtbl_sv,
    want_vtbl_env,
    want_vtbl_envelem,
    want_vtbl_sig,
    want_vtbl_sigelem,
    want_vtbl_pack,
    want_vtbl_packelem,
    want_vtbl_dbline,
    want_vtbl_isa,
    want_vtbl_isaelem,
    want_vtbl_arylen,
    want_vtbl_glob,
    want_vtbl_mglob,
    want_vtbl_nkeys,
    want_vtbl_taint,
    want_vtbl_substr,
    want_vtbl_vec,
    want_vtbl_pos,
    want_vtbl_bm,
    want_vtbl_fm,
    want_vtbl_uvar,
    want_vtbl_defelem,
    want_vtbl_regexp,
    want_vtbl_collxfrm,
    want_vtbl_amagic,
    want_vtbl_amagicelem,
    want_vtbl_regdata,
    want_vtbl_regdatum,
    want_vtbl_backref,
    want_vtbl_utf8,
    want_vtbl_symtab,
    want_vtbl_arylen_p,
    want_vtbl_hintselem
};


/* Hints are now stored in a dedicated U32, so the bottom 8 bits are no longer
   special and there is no need for HINT_PRIVATE_MASK for COPs
   However, bitops store HINT_INTEGER in their op_private.  */
#define HINT_INTEGER		0x00000001 /* integer pragma */
#define HINT_STRICT_REFS	0x00000002 /* strict pragma */
#define HINT_LOCALE		0x00000004 /* locale pragma */
#define HINT_BYTES		0x00000008 /* bytes pragma */
#define HINT_ARYBASE		0x00000010 /* $[ is non-zero */
				/* Note: 20,40,80 used for NATIVE_HINTS */
				/* currently defined by vms/vmsish.h */

#define HINT_BLOCK_SCOPE	0x00000100
#define HINT_STRICT_SUBS	0x00000200 /* strict pragma */
#define HINT_STRICT_VARS	0x00000400 /* strict pragma */

/* The HINT_NEW_* constants are used by the overload pragma */
#define HINT_NEW_INTEGER	0x00001000
#define HINT_NEW_FLOAT		0x00002000
#define HINT_NEW_BINARY		0x00004000
#define HINT_NEW_STRING		0x00008000
#define HINT_NEW_RE		0x00010000
#define HINT_LOCALIZE_HH	0x00020000 /* %^H needs to be copied */
#define HINT_LEXICAL_IO_IN	0x00040000 /* ${^OPEN} is set for input */
#define HINT_LEXICAL_IO_OUT	0x00080000 /* ${^OPEN} is set for output */

#define HINT_RE_TAINT		0x00100000 /* re pragma */
#define HINT_RE_EVAL		0x00200000 /* re pragma */

#define HINT_FILETEST_ACCESS	0x00400000 /* filetest pragma */
#define HINT_UTF8		0x00800000 /* utf8 pragma */

/* The following are stored in $^H{sort}, not in PL_hints */
#define HINT_SORT_SORT_BITS	0x000000FF /* allow 256 different ones */
#define HINT_SORT_QUICKSORT	0x00000001
#define HINT_SORT_MERGESORT	0x00000002
#define HINT_SORT_STABLE	0x00000100 /* sort styles (currently one) */

/* Various states of the input record separator SV (rs) */
#define RsSNARF(sv)   (! SvOK(sv))
#define RsSIMPLE(sv)  (SvOK(sv) && (! SvPOK(sv) || SvCUR(sv)))
#define RsPARA(sv)    (SvPOK(sv) && ! SvCUR(sv))
#define RsRECORD(sv)  (SvROK(sv) && (SvIV(SvRV(sv)) > 0))

/* A struct for keeping various DEBUGGING related stuff,
 * neatly packed.  Currently only scratch variables for
 * constructing debug output are included.  Needed always,
 * not just when DEBUGGING, though, because of the re extension. c*/
struct perl_debug_pad {
  SV pad[3];
};

#define PERL_DEBUG_PAD(i)	&(PL_debug_pad.pad[i])
#define PERL_DEBUG_PAD_ZERO(i)	(SvPVX(PERL_DEBUG_PAD(i))[0] = 0, \
	(((XPV*) SvANY(PERL_DEBUG_PAD(i)))->xpv_cur = 0), \
	PERL_DEBUG_PAD(i))

/* Enable variables which are pointers to functions */
typedef void (CPERLscope(*peep_t))(pTHX_ OP* o);
typedef regexp*(CPERLscope(*regcomp_t)) (pTHX_ char* exp, char* xend, PMOP* pm);
typedef I32 (CPERLscope(*regexec_t)) (pTHX_ regexp* prog, char* stringarg,
				      char* strend, char* strbeg, I32 minend,
				      SV* screamer, void* data, U32 flags);
typedef char* (CPERLscope(*re_intuit_start_t)) (pTHX_ regexp *prog, SV *sv,
						char *strpos, char *strend,
						U32 flags,
						re_scream_pos_data *d);
typedef SV*	(CPERLscope(*re_intuit_string_t)) (pTHX_ regexp *prog);
typedef void	(CPERLscope(*regfree_t)) (pTHX_ struct regexp* r);
typedef regexp*(CPERLscope(*regdupe_t)) (pTHX_ const regexp* r, CLONE_PARAMS *param);

typedef void (*DESTRUCTORFUNC_NOCONTEXT_t) (void*);
typedef void (*DESTRUCTORFUNC_t) (pTHX_ void*);
typedef void (*SVFUNC_t) (pTHX_ SV*);
typedef I32  (*SVCOMPARE_t) (pTHX_ SV*, SV*);
typedef void (*XSINIT_t) (pTHX);
typedef void (*ATEXIT_t) (pTHX_ void*);
typedef void (*XSUBADDR_t) (pTHX_ CV *);

/* Set up PERLVAR macros for populating structs */
#define PERLVAR(var,type) type var;
#define PERLVARA(var,n,type) type var[n];
#define PERLVARI(var,type,init) type var;
#define PERLVARIC(var,type,init) type var;
#define PERLVARISC(var,init) const char var[sizeof(init)];

typedef OP* (CPERLscope(*Perl_ppaddr_t))(pTHX);
typedef OP* (CPERLscope(*Perl_check_t)) (pTHX_ OP*);

/* Interpreter exitlist entry */
typedef struct exitlistentry {
    void (*fn) (pTHX_ void*);
    void *ptr;
} PerlExitListEntry;

/* if you only have signal() and it resets on each signal, FAKE_PERSISTENT_SIGNAL_HANDLERS fixes */
/* These have to be before perlvars.h */
#if !defined(HAS_SIGACTION) && defined(VMS)
#  define  FAKE_PERSISTENT_SIGNAL_HANDLERS
#endif
/* if we're doing kill() with sys$sigprc on VMS, FAKE_DEFAULT_SIGNAL_HANDLERS */
#if defined(KILL_BY_SIGPRC)
#  define  FAKE_DEFAULT_SIGNAL_HANDLERS
#endif

#define PERL_PATCHLEVEL_H_IMPLICIT
#include "patchlevel.h"
#undef PERL_PATCHLEVEL_H_IMPLICIT

#ifdef PERL_GLOBAL_STRUCT
struct perl_vars {
#  include "perlvars.h"
};

#  ifdef PERL_CORE
#    ifndef PERL_GLOBAL_STRUCT_PRIVATE
EXT struct perl_vars PL_Vars;
EXT struct perl_vars *PL_VarsPtr INIT(&PL_Vars);
#      undef PERL_GET_VARS
#      define PERL_GET_VARS() PL_VarsPtr
#    endif /* !PERL_GLOBAL_STRUCT_PRIVATE */
#  else /* PERL_CORE */
#    if !defined(__GNUC__) || !defined(WIN32)
EXT
#    endif /* WIN32 */
struct perl_vars *PL_VarsPtr;
#    define PL_Vars (*((PL_VarsPtr) \
		       ? PL_VarsPtr : (PL_VarsPtr = Perl_GetVars(aTHX))))
#  endif /* PERL_CORE */
#endif /* PERL_GLOBAL_STRUCT */

#if defined(MULTIPLICITY)
/* If we have multiple interpreters define a struct
   holding variables which must be per-interpreter
   If we don't have threads anything that would have
   be per-thread is per-interpreter.
*/

struct interpreter {
#  include "intrpvar.h"
};

#else
struct interpreter {
    char broiled;
};
#endif /* MULTIPLICITY */

/* Done with PERLVAR macros for now ... */
#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC
#undef PERLVARISC

struct tempsym; /* defined in pp_pack.c */

#include "thread.h"
#include "pp.h"

#ifndef PERL_CALLCONV
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C"
#  else
#    define PERL_CALLCONV
#  endif
#endif
#undef PERL_CKDEF
#undef PERL_PPDEF
#define PERL_CKDEF(s)	PERL_CALLCONV OP *s (pTHX_ OP *o);
#define PERL_PPDEF(s)	PERL_CALLCONV OP *s (pTHX);

#include "proto.h"

/* this has structure inits, so it cannot be included before here */
#include "opcode.h"

/* The following must follow proto.h as #defines mess up syntax */

#if !defined(PERL_FOR_X2P)
#  include "embedvar.h"
#endif
#ifndef PERL_MAD
#  undef PL_madskills
#  undef PL_xmlfp
#  define PL_madskills 0
#  define PL_xmlfp 0
#endif

/* Now include all the 'global' variables
 * If we don't have threads or multiple interpreters
 * these include variables that would have been their struct-s
 */

#define PERLVAR(var,type) EXT type PL_##var;
#define PERLVARA(var,n,type) EXT type PL_##var[n];
#define PERLVARI(var,type,init) EXT type  PL_##var INIT(init);
#define PERLVARIC(var,type,init) EXTCONST type PL_##var INIT(init);
#define PERLVARISC(var,init) EXTCONST char PL_##var[sizeof(init)] INIT(init);

#if !defined(MULTIPLICITY)
START_EXTERN_C
#  include "intrpvar.h"
END_EXTERN_C
#endif

#if defined(WIN32)
/* Now all the config stuff is setup we can include embed.h */
#  include "embed.h"
#  ifndef PERL_MAD
#    undef op_getmad
#    define op_getmad(arg,pegop,slot) NOOP
#  endif
#endif

#ifndef PERL_GLOBAL_STRUCT
START_EXTERN_C

#  include "perlvars.h"

END_EXTERN_C
#endif

#undef PERLVAR
#undef PERLVARA
#undef PERLVARI
#undef PERLVARIC

START_EXTERN_C

/* PERL_GLOBAL_STRUCT_PRIVATE wants to keep global data like the
 * magic vtables const, but this is incompatible with SWIG which
 * does want to modify the vtables. */
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
#  define EXT_MGVTBL EXTCONST MGVTBL
#else
#  define EXT_MGVTBL EXT MGVTBL
#endif

#ifdef DOINIT
#  define MGVTBL_SET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var = {a,b,c,d,e,f,g,h}
/* Like MGVTBL_SET but with the get magic having a const MG* */
#  define MGVTBL_SET_CONST_MAGIC_GET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var \
    = {(int (*)(pTHX_ SV *, MAGIC *))a,b,c,d,e,f,g,h}
#else
#  define MGVTBL_SET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var
#  define MGVTBL_SET_CONST_MAGIC_GET(var,a,b,c,d,e,f,g,h) EXT_MGVTBL var
#endif

/* These all need to be 0, not NULL, as NULL can be (void*)0, which is a
 * pointer to data, whereas we're assigning pointers to functions, which are
 * not the same beast. ANSI doesn't allow the assignment from one to the other.
 * (although most, but not all, compilers are prepared to do it)
 */
MGVTBL_SET(
    PL_vtbl_sv,
    MEMBER_TO_FPTR(Perl_magic_get),
    MEMBER_TO_FPTR(Perl_magic_set),
    MEMBER_TO_FPTR(Perl_magic_len),
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_env,
    0,
    MEMBER_TO_FPTR(Perl_magic_set_all_env),
    0,
    MEMBER_TO_FPTR(Perl_magic_clear_all_env),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_envelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setenv),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearenv),
    0,
    0,
    0,
    0
);

/* For now, hints magic will also use vtbl_sig, because it is all 0  */
MGVTBL_SET(
    PL_vtbl_sig,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);

#ifdef PERL_MICRO
MGVTBL_SET(
    PL_vtbl_sigelem,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);

#else
MGVTBL_SET(
    PL_vtbl_sigelem,
    MEMBER_TO_FPTR(Perl_magic_getsig),
    MEMBER_TO_FPTR(Perl_magic_setsig),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearsig),
    0,
    0,
    0,
    0
);
#endif

MGVTBL_SET(
    PL_vtbl_pack,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_sizepack),
    MEMBER_TO_FPTR(Perl_magic_wipepack),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_packelem,
    MEMBER_TO_FPTR(Perl_magic_getpack),
    MEMBER_TO_FPTR(Perl_magic_setpack),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearpack),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_dbline,
    0,
    MEMBER_TO_FPTR(Perl_magic_setdbline),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_isa,
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_isaelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setisa),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET_CONST_MAGIC_GET(
    PL_vtbl_arylen,
    MEMBER_TO_FPTR(Perl_magic_getarylen),
    MEMBER_TO_FPTR(Perl_magic_setarylen),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_arylen_p,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freearylen_p),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_mglob,
    0,
    MEMBER_TO_FPTR(Perl_magic_setmglob),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_nkeys,
    MEMBER_TO_FPTR(Perl_magic_getnkeys),
    MEMBER_TO_FPTR(Perl_magic_setnkeys),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_taint,
    MEMBER_TO_FPTR(Perl_magic_gettaint),
    MEMBER_TO_FPTR(Perl_magic_settaint),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_substr,
    MEMBER_TO_FPTR(Perl_magic_getsubstr),
    MEMBER_TO_FPTR(Perl_magic_setsubstr),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_vec,
    MEMBER_TO_FPTR(Perl_magic_getvec),
    MEMBER_TO_FPTR(Perl_magic_setvec),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_pos,
    MEMBER_TO_FPTR(Perl_magic_getpos),
    MEMBER_TO_FPTR(Perl_magic_setpos),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_bm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setbm),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_fm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setfm),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_uvar,
    MEMBER_TO_FPTR(Perl_magic_getuvar),
    MEMBER_TO_FPTR(Perl_magic_setuvar),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_defelem,
    MEMBER_TO_FPTR(Perl_magic_getdefelem),
    MEMBER_TO_FPTR(Perl_magic_setdefelem),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regexp,
    0,
    MEMBER_TO_FPTR(Perl_magic_setregexp),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freeregexp),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regdata,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_regdata_cnt),
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_regdatum,
    MEMBER_TO_FPTR(Perl_magic_regdatum_get),
    MEMBER_TO_FPTR(Perl_magic_regdatum_set),
    0,
    0,
    0,
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_amagic,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_amagicelem,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_setamagic),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_backref,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_killbackrefs),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_ovrld,
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(Perl_magic_freeovrld),
    0,
    0,
    0
);

MGVTBL_SET(
    PL_vtbl_utf8,
    0,
    MEMBER_TO_FPTR(Perl_magic_setutf8),
    0,
    0,
    0,
    0,
    0,
    0
);
#ifdef USE_LOCALE_COLLATE
MGVTBL_SET(
    PL_vtbl_collxfrm,
    0,
    MEMBER_TO_FPTR(Perl_magic_setcollxfrm),
    0,
    0,
    0,
    0,
    0,
    0
);
#endif

MGVTBL_SET(
    PL_vtbl_hintselem,
    0,
    MEMBER_TO_FPTR(Perl_magic_sethint),
    0,
    MEMBER_TO_FPTR(Perl_magic_clearhint),
    0,
    0,
    0,
    0
);

#include "overload.h"

END_EXTERN_C

struct am_table {
  U32 flags;
  U32 was_ok_sub;
  long was_ok_am;
  long fallback;
  CV* table[NofAMmeth];
};
struct am_table_short {
  U32 flags;
  U32 was_ok_sub;
  long was_ok_am;
};
typedef struct am_table AMT;
typedef struct am_table_short AMTS;

#define AMGfallNEVER	1
#define AMGfallNO	2
#define AMGfallYES	3

#define AMTf_AMAGIC		1
#define AMTf_OVERLOADED		2
#define AMT_AMAGIC(amt)		((amt)->flags & AMTf_AMAGIC)
#define AMT_AMAGIC_on(amt)	((amt)->flags |= AMTf_AMAGIC)
#define AMT_AMAGIC_off(amt)	((amt)->flags &= ~AMTf_AMAGIC)
#define AMT_OVERLOADED(amt)	((amt)->flags & AMTf_OVERLOADED)
#define AMT_OVERLOADED_on(amt)	((amt)->flags |= AMTf_OVERLOADED)
#define AMT_OVERLOADED_off(amt)	((amt)->flags &= ~AMTf_OVERLOADED)

#define StashHANDLER(stash,meth)	gv_handler((stash),CAT2(meth,_amg))

/*
 * some compilers like to redefine cos et alia as faster
 * (and less accurate?) versions called F_cos et cetera (Quidquid
 * latine dictum sit, altum viditur.)  This trick collides with
 * the Perl overloading (amg).  The following #defines fool both.
 */

#ifdef _FASTMATH
#   ifdef atan2
#       define F_atan2_amg  atan2_amg
#   endif
#   ifdef cos
#       define F_cos_amg    cos_amg
#   endif
#   ifdef exp
#       define F_exp_amg    exp_amg
#   endif
#   ifdef log
#       define F_log_amg    log_amg
#   endif
#   ifdef pow
#       define F_pow_amg    pow_amg
#   endif
#   ifdef sin
#       define F_sin_amg    sin_amg
#   endif
#   ifdef sqrt
#       define F_sqrt_amg   sqrt_amg
#   endif
#endif /* _FASTMATH */

#define PERLDB_ALL		(PERLDBf_SUB	| PERLDBf_LINE	|	\
				 PERLDBf_NOOPT	| PERLDBf_INTER	|	\
				 PERLDBf_SUBLINE| PERLDBf_SINGLE|	\
				 PERLDBf_NAMEEVAL| PERLDBf_NAMEANON )
					/* No _NONAME, _GOTO, _ASSERTION */
#define PERLDBf_SUB		0x01	/* Debug sub enter/exit */
#define PERLDBf_LINE		0x02	/* Keep line # */
#define PERLDBf_NOOPT		0x04	/* Switch off optimizations */
#define PERLDBf_INTER		0x08	/* Preserve more data for
					   later inspections  */
#define PERLDBf_SUBLINE		0x10	/* Keep subr source lines */
#define PERLDBf_SINGLE		0x20	/* Start with single-step on */
#define PERLDBf_NONAME		0x40	/* For _SUB: no name of the subr */
#define PERLDBf_GOTO		0x80	/* Report goto: call DB::goto */
#define PERLDBf_NAMEEVAL	0x100	/* Informative names for evals */
#define PERLDBf_NAMEANON	0x200	/* Informative names for anon subs */

#define PERLDB_SUB	(PL_perldb && (PL_perldb & PERLDBf_SUB))
#define PERLDB_LINE	(PL_perldb && (PL_perldb & PERLDBf_LINE))
#define PERLDB_NOOPT	(PL_perldb && (PL_perldb & PERLDBf_NOOPT))
#define PERLDB_INTER	(PL_perldb && (PL_perldb & PERLDBf_INTER))
#define PERLDB_SUBLINE	(PL_perldb && (PL_perldb & PERLDBf_SUBLINE))
#define PERLDB_SINGLE	(PL_perldb && (PL_perldb & PERLDBf_SINGLE))
#define PERLDB_SUB_NN	(PL_perldb && (PL_perldb & (PERLDBf_NONAME)))
#define PERLDB_GOTO	(PL_perldb && (PL_perldb & PERLDBf_GOTO))
#define PERLDB_NAMEEVAL	(PL_perldb && (PL_perldb & PERLDBf_NAMEEVAL))
#define PERLDB_NAMEANON	(PL_perldb && (PL_perldb & PERLDBf_NAMEANON))
#define PERLDB_ASSERTION (PL_perldb && (PL_perldb & PERLDBf_ASSERTION))

#ifdef USE_LOCALE_NUMERIC

#define SET_NUMERIC_STANDARD() \
	set_numeric_standard();

#define SET_NUMERIC_LOCAL() \
	set_numeric_local();

#define IN_LOCALE_RUNTIME	(CopHINTS_get(PL_curcop) & HINT_LOCALE)
#define IN_LOCALE_COMPILETIME	(PL_hints & HINT_LOCALE)

#define IN_LOCALE \
	(IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)

#define STORE_NUMERIC_LOCAL_SET_STANDARD() \
	bool was_local = PL_numeric_local && IN_LOCALE; \
	if (was_local) SET_NUMERIC_STANDARD();

#define STORE_NUMERIC_STANDARD_SET_LOCAL() \
	bool was_standard = PL_numeric_standard && IN_LOCALE; \
	if (was_standard) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_LOCAL() \
	if (was_local) SET_NUMERIC_LOCAL();

#define RESTORE_NUMERIC_STANDARD() \
	if (was_standard) SET_NUMERIC_STANDARD();

#define Atof				my_atof

#else /* !USE_LOCALE_NUMERIC */

#define SET_NUMERIC_STANDARD()  	/**/
#define SET_NUMERIC_LOCAL()     	/**/
#define IS_NUMERIC_RADIX(a, b)		(0)
#define STORE_NUMERIC_LOCAL_SET_STANDARD()	/**/
#define STORE_NUMERIC_STANDARD_SET_LOCAL()	/**/
#define RESTORE_NUMERIC_LOCAL()		/**/
#define RESTORE_NUMERIC_STANDARD()	/**/
#define Atof				my_atof
#define IN_LOCALE_RUNTIME		0

#endif /* !USE_LOCALE_NUMERIC */

#if !defined(Strtol) && defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG
#    ifdef __hpux
#        define strtoll __strtoll	/* secret handshake */
#    endif
#    ifdef WIN64
#        define strtoll _strtoi64	/* secret handshake */
#    endif
#   if !defined(Strtol) && defined(HAS_STRTOLL)
#       define Strtol	strtoll
#   endif
#    if !defined(Strtol) && defined(HAS_STRTOQ)
#       define Strtol	strtoq
#    endif
/* is there atoq() anywhere? */
#endif
#if !defined(Strtol) && defined(HAS_STRTOL)
#   define Strtol	strtol
#endif
#ifndef Atol
/* It would be more fashionable to use Strtol() to define atol()
 * (as is done for Atoul(), see below) but for backward compatibility
 * we just assume atol(). */
#   if defined(USE_64_BIT_INT) && defined(IV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG && defined(HAS_ATOLL)
#    ifdef WIN64
#       define atoll    _atoi64		/* secret handshake */
#    endif
#       define Atol	atoll
#   else
#       define Atol	atol
#   endif
#endif

#if !defined(Strtoul) && defined(USE_64_BIT_INT) && defined(UV_IS_QUAD) && QUADKIND == QUAD_IS_LONG_LONG
#    ifdef __hpux
#        define strtoull __strtoull	/* secret handshake */
#    endif
#    ifdef WIN64
#        define strtoull _strtoui64	/* secret handshake */
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOULL)
#       define Strtoul	strtoull
#    endif
#    if !defined(Strtoul) && defined(HAS_STRTOUQ)
#       define Strtoul	strtouq
#    endif
/* is there atouq() anywhere? */
#endif
#if !defined(Strtoul) && defined(HAS_STRTOUL)
#   define Strtoul	strtoul
#endif
#if !defined(Strtoul) && defined(HAS_STRTOL) /* Last resort. */
#   define Strtoul(s, e, b)	strchr((s), '-') ? ULONG_MAX : (unsigned long)strtol((s), (e), (b))
#endif
#ifndef Atoul
#   define Atoul(s)	Strtoul(s, NULL, 10)
#endif


/* if these never got defined, they need defaults */
#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(i)		PERL_SET_INTERP(i)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT		PERL_GET_INTERP
#endif

#ifndef PERL_GET_THX
#  define PERL_GET_THX			((void*)NULL)
#endif

#ifndef PERL_SET_THX
#  define PERL_SET_THX(t)		NOOP
#endif

#ifndef PERL_SCRIPT_MODE
#define PERL_SCRIPT_MODE "r"
#endif

/*
 * Some operating systems are stingy with stack allocation,
 * so perl may have to guard against stack overflow.
 */
#ifndef PERL_STACK_OVERFLOW_CHECK
#define PERL_STACK_OVERFLOW_CHECK()  NOOP
#endif

/*
 * Some nonpreemptive operating systems find it convenient to
 * check for asynchronous conditions after each op execution.
 * Keep this check simple, or it may slow down execution
 * massively.
 */

#ifndef PERL_MICRO
#	ifndef PERL_ASYNC_CHECK
#		define PERL_ASYNC_CHECK() if (PL_sig_pending) despatch_signals()
#	endif
#endif

#ifndef PERL_ASYNC_CHECK
#   define PERL_ASYNC_CHECK()  NOOP
#endif

/*
 * On some operating systems, a memory allocation may succeed,
 * but put the process too close to the system's comfort limit.
 * In this case, PERL_ALLOC_CHECK frees the pointer and sets
 * it to NULL.
 */
#ifndef PERL_ALLOC_CHECK
#define PERL_ALLOC_CHECK(p)  NOOP
#endif

#ifdef HAS_SEM
#   include <sys/ipc.h>
#   include <sys/sem.h>
#   ifndef HAS_UNION_SEMUN	/* Provide the union semun. */
    union semun {
	int		val;
	struct semid_ds	*buf;
	unsigned short	*array;
    };
#   endif
#   ifdef USE_SEMCTL_SEMUN
#	ifdef IRIX32_SEMUN_BROKEN_BY_GCC
            union gccbug_semun {
		int             val;
		struct semid_ds *buf;
		unsigned short  *array;
		char            __dummy[5];
	    };
#           define semun gccbug_semun
#	endif
#       define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun)
#   else
#       ifdef USE_SEMCTL_SEMID_DS
#           ifdef EXTRA_F_IN_SEMUN_BUF
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buff)
#           else
#               define Semctl(id, num, cmd, semun) semctl(id, num, cmd, semun.buf)
#           endif
#       endif
#   endif
#endif

/*
 * Boilerplate macros for initializing and accessing interpreter-local
 * data from C.  All statics in extensions should be reworked to use
 * this, if you want to make the extension thread-safe.  See
 * ext/XS/APItest/APItest.xs for an example of the use of these macros,
 * and perlxs.pod for more.
 *
 * Code that uses these macros is responsible for the following:
 * 1. #define MY_CXT_KEY to a unique string, e.g.
 *    "DynaLoader::_guts" XS_VERSION
 *    XXX in the current implementation, this string is ignored.
 * 2. Declare a typedef named my_cxt_t that is a structure that contains
 *    all the data that needs to be interpreter-local.
 * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.
 * 4. Use the MY_CXT_INIT macro such that it is called exactly once
 *    (typically put in the BOOT: section).
 * 5. Use the members of the my_cxt_t structure everywhere as
 *    MY_CXT.member.
 * 6. Use the dMY_CXT macro (a declaration) in all the functions that
 *    access MY_CXT.
 */

#if defined(PERL_IMPLICIT_CONTEXT)

#ifdef PERL_GLOBAL_STRUCT_PRIVATE

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT
#define MY_CXT_INDEX Perl_my_cxt_index(aTHX_ MY_CXT_KEY)

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ MY_CXT_KEY, sizeof(my_cxt_t))
#define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, MY_CXT_KEY, sizeof(my_cxt_t))

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT	\
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[MY_CXT_INDEX]
#define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[MY_CXT_INDEX]

/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(PL_my_cxt_list[MY_CXT_INDEX], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[MY_CXT_INDEX] = my_cxtp				\

#else /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */

/* This must appear in all extensions that define a my_cxt_t structure,
 * right after the definition (i.e. at file scope).  The non-threads
 * case below uses it to declare the data as static. */
#define START_MY_CXT static int my_cxt_index = -1;

/* This declaration should be used within all functions that use the
 * interpreter-local data. */
#define dMY_CXT	\
	my_cxt_t *my_cxtp = (my_cxt_t *)PL_my_cxt_list[my_cxt_index]
#define dMY_CXT_INTERP(my_perl)	\
	my_cxt_t *my_cxtp = (my_cxt_t *)(my_perl)->Imy_cxt_list[my_cxt_index]

/* Creates and zeroes the per-interpreter data.
 * (We allocate my_cxtp in a Perl SV so that it will be released when
 * the interpreter goes away.) */
#define MY_CXT_INIT \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(aTHX_ &my_cxt_index, sizeof(my_cxt_t))
#define MY_CXT_INIT_INTERP(my_perl) \
	my_cxt_t *my_cxtp = \
	    (my_cxt_t*)Perl_my_cxt_init(my_perl, &my_cxt_index, sizeof(my_cxt_t))

/* Clones the per-interpreter data. */
#define MY_CXT_CLONE \
	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
	Copy(PL_my_cxt_list[my_cxt_index], my_cxtp, 1, my_cxt_t);\
	PL_my_cxt_list[my_cxt_index] = my_cxtp				\

#endif /* #ifdef PERL_GLOBAL_STRUCT_PRIVATE */

/* This macro must be used to access members of the my_cxt_t structure.
 * e.g. MYCXT.some_data */
#define MY_CXT		(*my_cxtp)

/* Judicious use of these macros can reduce the number of times dMY_CXT
 * is used.  Use is similar to pTHX, aTHX etc. */
#define pMY_CXT		my_cxt_t *my_cxtp
#define pMY_CXT_	pMY_CXT,
#define _pMY_CXT	,pMY_CXT
#define aMY_CXT		my_cxtp
#define aMY_CXT_	aMY_CXT,
#define _aMY_CXT	,aMY_CXT

#else /* PERL_IMPLICIT_CONTEXT */

#define START_MY_CXT	static my_cxt_t my_cxt;
#define dMY_CXT_SV	dNOOP
#define dMY_CXT		dNOOP
#define MY_CXT_INIT	NOOP
#define MY_CXT_CLONE	NOOP
#define MY_CXT		my_cxt

#define pMY_CXT		void
#define pMY_CXT_
#define _pMY_CXT
#define aMY_CXT
#define aMY_CXT_
#define _aMY_CXT

#endif /* !defined(PERL_IMPLICIT_CONTEXT) */

#ifdef I_FCNTL
#  include <fcntl.h>
#endif

#ifdef __Lynx__
#  include <fcntl.h>
#endif

#ifdef I_SYS_FILE
#  include <sys/file.h>
#endif

#if defined(HAS_FLOCK) && !defined(HAS_FLOCK_PROTO)
int flock(int fd, int op);
#endif

#ifndef O_RDONLY
/* Assume UNIX defaults */
#    define O_RDONLY	0000
#    define O_WRONLY	0001
#    define O_RDWR	0002
#    define O_CREAT	0100
#endif

#ifndef O_BINARY
#  define O_BINARY 0
#endif

#ifndef O_TEXT
#  define O_TEXT 0
#endif

#if O_TEXT != O_BINARY
    /* If you have different O_TEXT and O_BINARY and you are a CLRF shop,
     * that is, you are somehow DOSish. */
#   if defined(__BEOS__) || defined(__VOS__) || defined(__CYGWIN__)
    /* BeOS has O_TEXT != O_BINARY but O_TEXT and O_BINARY have no effect;
     * BeOS is always UNIXoid (LF), not DOSish (CRLF). */
    /* VOS has O_TEXT != O_BINARY, and they have effect,
     * but VOS always uses LF, never CRLF. */
    /* If you have O_TEXT different from your O_BINARY but you still are
     * not a CRLF shop. */
#       undef PERLIO_USING_CRLF
#   else
    /* If you really are DOSish. */
#      define PERLIO_USING_CRLF 1
#   endif
#endif

#ifdef IAMSUID

#ifdef I_SYS_STATVFS
#   if defined(PERL_SCO) && !defined(_SVID3)
#       define _SVID3
#   endif
#   include <sys/statvfs.h>     /* for f?statvfs() */
#endif
#ifdef I_SYS_MOUNT
#   include <sys/mount.h>       /* for *BSD f?statfs() */
#endif
#ifdef I_MNTENT
#   include <mntent.h>          /* for getmntent() */
#endif
#ifdef I_SYS_STATFS
#   include <sys/statfs.h>      /* for some statfs() */
#endif
#ifdef I_SYS_VFS
#  ifdef __sgi
#    define sv IRIX_sv		/* kludge: IRIX has an sv of its own */
#  endif
#    include <sys/vfs.h>	/* for some statfs() */
#  ifdef __sgi
#    undef IRIX_sv
#  endif
#endif
#ifdef I_USTAT
#   include <ustat.h>           /* for ustat() */
#endif

#if !defined(PERL_MOUNT_NOSUID) && defined(MOUNT_NOSUID)
#    define PERL_MOUNT_NOSUID MOUNT_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(MNT_NOSUID)
#    define PERL_MOUNT_NOSUID MNT_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(MS_NOSUID)
#   define PERL_MOUNT_NOSUID MS_NOSUID
#endif
#if !defined(PERL_MOUNT_NOSUID) && defined(M_NOSUID)
#   define PERL_MOUNT_NOSUID M_NOSUID
#endif

#if !defined(PERL_MOUNT_NOEXEC) && defined(MOUNT_NOEXEC)
#    define PERL_MOUNT_NOEXEC MOUNT_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(MNT_NOEXEC)
#    define PERL_MOUNT_NOEXEC MNT_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(MS_NOEXEC)
#   define PERL_MOUNT_NOEXEC MS_NOEXEC
#endif
#if !defined(PERL_MOUNT_NOEXEC) && defined(M_NOEXEC)
#   define PERL_MOUNT_NOEXEC M_NOEXEC
#endif

#endif /* IAMSUID */

#ifdef I_LIBUTIL
#   include <libutil.h>		/* setproctitle() in some FreeBSDs */
#endif

#ifndef EXEC_ARGV_CAST
#define EXEC_ARGV_CAST(x) x
#endif

#define IS_NUMBER_IN_UV		      0x01 /* number within UV range (maybe not
					      int).  value returned in pointed-
					      to UV */
#define IS_NUMBER_GREATER_THAN_UV_MAX 0x02 /* pointed to UV undefined */
#define IS_NUMBER_NOT_INT	      0x04 /* saw . or E notation */
#define IS_NUMBER_NEG		      0x08 /* leading minus sign */
#define IS_NUMBER_INFINITY	      0x10 /* this is big */
#define IS_NUMBER_NAN                 0x20 /* this is not */

#define GROK_NUMERIC_RADIX(sp, send) grok_numeric_radix(sp, send)

/* Input flags: */
#define PERL_SCAN_ALLOW_UNDERSCORES   0x01 /* grok_??? accept _ in numbers */
#define PERL_SCAN_DISALLOW_PREFIX     0x02 /* grok_??? reject 0x in hex etc */
#define PERL_SCAN_SILENT_ILLDIGIT     0x04 /* grok_??? not warn about illegal digits */
/* Output flags: */
#define PERL_SCAN_GREATER_THAN_UV_MAX 0x02 /* should this merge with above? */

/* to let user control profiling */
#ifdef PERL_GPROF_CONTROL
extern void moncontrol(int);
#define PERL_GPROF_MONCONTROL(x) moncontrol(x)
#else
#define PERL_GPROF_MONCONTROL(x)
#endif

#ifdef UNDER_CE
#include "wince.h"
#endif

/* ISO 6429 NEL - C1 control NExt Line */
/* See http://www.unicode.org/unicode/reports/tr13/ */
#ifdef EBCDIC	/* In EBCDIC NEL is just an alias for LF */
#   if '^' == 95	/* CP 1047: MVS OpenEdition - OS/390 - z/OS */
#       define NEXT_LINE_CHAR	0x15
#   else		/* CDRA */
#       define NEXT_LINE_CHAR	0x25
#   endif
#else
#   define NEXT_LINE_CHAR	0x85
#endif

/* The UTF-8 bytes of the Unicode LS and PS, U+2028 and U+2029 */
#define UNICODE_LINE_SEPA_0	0xE2
#define UNICODE_LINE_SEPA_1	0x80
#define UNICODE_LINE_SEPA_2	0xA8
#define UNICODE_PARA_SEPA_0	0xE2
#define UNICODE_PARA_SEPA_1	0x80
#define UNICODE_PARA_SEPA_2	0xA9

#ifndef PIPESOCK_MODE
#  define PIPESOCK_MODE
#endif

#ifndef SOCKET_OPEN_MODE
#  define SOCKET_OPEN_MODE	PIPESOCK_MODE
#endif

#ifndef PIPE_OPEN_MODE
#  define PIPE_OPEN_MODE	PIPESOCK_MODE
#endif

#define PERL_MAGIC_UTF8_CACHESIZE	2

#define PERL_UNICODE_STDIN_FLAG			0x0001
#define PERL_UNICODE_STDOUT_FLAG		0x0002
#define PERL_UNICODE_STDERR_FLAG		0x0004
#define PERL_UNICODE_IN_FLAG			0x0008
#define PERL_UNICODE_OUT_FLAG			0x0010
#define PERL_UNICODE_ARGV_FLAG			0x0020
#define PERL_UNICODE_LOCALE_FLAG		0x0040
#define PERL_UNICODE_WIDESYSCALLS_FLAG		0x0080 /* for Sarathy */
#define PERL_UNICODE_UTF8CACHEASSERT_FLAG	0x0100

#define PERL_UNICODE_STD_FLAG		\
	(PERL_UNICODE_STDIN_FLAG	| \
	 PERL_UNICODE_STDOUT_FLAG	| \
	 PERL_UNICODE_STDERR_FLAG)

#define PERL_UNICODE_INOUT_FLAG		\
	(PERL_UNICODE_IN_FLAG	| \
	 PERL_UNICODE_OUT_FLAG)

#define PERL_UNICODE_DEFAULT_FLAGS	\
	(PERL_UNICODE_STD_FLAG		| \
	 PERL_UNICODE_INOUT_FLAG	| \
	 PERL_UNICODE_LOCALE_FLAG)

#define PERL_UNICODE_ALL_FLAGS			0x01ff

#define PERL_UNICODE_STDIN			'I'
#define PERL_UNICODE_STDOUT			'O'
#define PERL_UNICODE_STDERR			'E'
#define PERL_UNICODE_STD			'S'
#define PERL_UNICODE_IN				'i'
#define PERL_UNICODE_OUT			'o'
#define PERL_UNICODE_INOUT			'D'
#define PERL_UNICODE_ARGV			'A'
#define PERL_UNICODE_LOCALE			'L'
#define PERL_UNICODE_WIDESYSCALLS		'W'
#define PERL_UNICODE_UTF8CACHEASSERT		'a'

#define PERL_SIGNALS_UNSAFE_FLAG	0x0001

/* From sigaction(2) (FreeBSD man page):
 * | Signal routines normally execute with the signal that
 * | caused their invocation blocked, but other signals may
 * | yet occur.
 * Emulation of this behavior (from within Perl) is enabled
 * by defining PERL_BLOCK_SIGNALS.
 */
#define PERL_BLOCK_SIGNALS

#if defined(HAS_SIGPROCMASK) && defined(PERL_BLOCK_SIGNALS)
#   define PERL_BLOCKSIG_ADD(set,sig) \
	sigset_t set; sigemptyset(&(set)); sigaddset(&(set), sig)
#   define PERL_BLOCKSIG_BLOCK(set) \
	sigprocmask(SIG_BLOCK, &(set), NULL)
#   define PERL_BLOCKSIG_UNBLOCK(set) \
	sigprocmask(SIG_UNBLOCK, &(set), NULL)
#endif /* HAS_SIGPROCMASK && PERL_BLOCK_SIGNALS */

/* How about the old style of sigblock()? */

#ifndef PERL_BLOCKSIG_ADD
#   define PERL_BLOCKSIG_ADD(set, sig)	NOOP
#endif
#ifndef PERL_BLOCKSIG_BLOCK
#   define PERL_BLOCKSIG_BLOCK(set)	NOOP
#endif
#ifndef PERL_BLOCKSIG_UNBLOCK
#   define PERL_BLOCKSIG_UNBLOCK(set)	NOOP
#endif

/* Use instead of abs() since abs() forces its argument to be an int,
 * but also beware since this evaluates its argument twice, so no x++. */
#define PERL_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(__DECC) && defined(__osf__)
#pragma message disable (mainparm) /* Perl uses the envp in main(). */
#endif

#define do_open(g, n, l, a, rm, rp, sf) \
	do_openn(g, n, l, a, rm, rp, sf, (SV **) NULL, 0)
#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
#  define do_exec(cmd)			do_exec3(cmd,0,0)
#endif
#ifdef OS2
#  define do_aexec			Perl_do_aexec
#else
#  define do_aexec(really, mark,sp)	do_aexec5(really, mark, sp, 0, 0)
#endif

#if defined(OEMVS)
#define NO_ENV_ARRAY_IN_MAIN
#endif

/* These are used by Perl_pv_escape() and Perl_pv_pretty() 
 * are here so that they are available throughout the core 
 * NOTE that even though some are for _escape and some for _pretty
 * there must not be any clashes as the flags from _pretty are
 * passed straight through to _escape.
 */

#define PERL_PV_ESCAPE_QUOTE        0x0001
#define PERL_PV_PRETTY_QUOTE        PERL_PV_ESCAPE_QUOTE

#define PERL_PV_PRETTY_ELLIPSES     0x0002
#define PERL_PV_PRETTY_LTGT         0x0004

#define PERL_PV_ESCAPE_FIRSTCHAR    0x0008

#define PERL_PV_ESCAPE_UNI          0x0100     
#define PERL_PV_ESCAPE_UNI_DETECT   0x0200

#define PERL_PV_ESCAPE_ALL	    0x1000
#define PERL_PV_ESCAPE_NOBACKSLASH  0x2000
#define PERL_PV_ESCAPE_NOCLEAR      0x4000
#define PERL_PV_ESCAPE_RE           0x8000

#define PERL_PV_PRETTY_NOCLEAR      PERL_PV_ESCAPE_NOCLEAR

/* used by pv_display in dump.c*/
#define PERL_PV_PRETTY_DUMP  PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
#define PERL_PV_PRETTY_REGPROP PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE

/*

   (KEEP THIS LAST IN perl.h!)

   Mention

   NV_PRESERVES_UV

   HAS_MKSTEMP
   HAS_MKSTEMPS
   HAS_MKDTEMP

   HAS_GETCWD

   HAS_MMAP
   HAS_MPROTECT
   HAS_MSYNC
   HAS_MADVISE
   HAS_MUNMAP
   I_SYSMMAN
   Mmap_t

   NVef
   NVff
   NVgf

   HAS_UALARM
   HAS_USLEEP

   HAS_SETITIMER
   HAS_GETITIMER

   HAS_SENDMSG
   HAS_RECVMSG
   HAS_READV
   HAS_WRITEV
   I_SYSUIO
   HAS_STRUCT_MSGHDR
   HAS_STRUCT_CMSGHDR

   HAS_NL_LANGINFO

   HAS_DIRFD

   so that Configure picks them up.

   (KEEP THIS LAST IN perl.h!)

*/

#endif /* Include guard */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\PerlEz.h ===
//
//  PerlEz.h
//
//  Copyright (c) 1998-2003 ActiveState Corp.  All rights reserved. 
//


#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(PERLEZHANDLE);

enum
{
    plezNoError = 0,		// success
    plezMoreSpace,		// more space need to return result
    plezError,			// returned error string in buffer
    plezErrorMoreSpace,		// more space need to return error message
    plezErrorBadFormat,		// format string is invalid
    plezException,		// function call caused an exception
    plezInvalidHandle,		// hHandle was invalid
    plezCallbackAlreadySet,	// second call to PerlEzSetMagicFunction fails
    plezInvalidParams,		// invalid parameter was passed to a routine
    plezOutOfMemory,		// cannot allocate more memory
};


PERLEZHANDLE APIENTRY PerlEzCreate(LPCSTR lpFileName, LPCSTR lpOptions);
// Description:
//	Creates a Perl interpreter. The return value is required parameter
//	for all subsequent PerlEz calls.  Multiple interpreters can be created,
//	but only one will be executing at a time.
//	Call PerlEzDelete to release this handle.
//
// Parameters:
//	lpFileName a pointer to a ASCIIZ string that is the name of a file; can be NULL 
//	lpOptions a pointer to a ASCIIZ string that are the command line options that
//	    will be provided before the script; can be NULL.
//	    This parameter is used for setting @INC or debugging. 
//
// Returns:
//	A non zero handle to a Perl interpreter if successful; zero otherwise.


PERLEZHANDLE APIENTRY PerlEzCreateOpt(LPCSTR lpFileName, LPCSTR lpOptions, LPCSTR lpScriptOpts);
// Description:
//	Creates a Perl interpreter. The return value is required parameter
//	for all subsequent PerlEz calls.  Multiple interpreters can be created,
//	but only one will be executing at a time.
//	Call PerlEzDelete to release this handle.
//
// Parameters:
//	lpFileName a pointer to a ASCIIZ string that is the name of a file; can not be NULL 
//	lpOptions a pointer to a ASCIIZ string that are the command line options that
//	    will be provided before the script; can be NULL.
//	    This parameter is used for setting @INC or debugging. 
//	lpScriptOpts a pointer to a ASCIIZ string that are the command line options to be
//	    passed to the script.
//
// Returns:
//	A non zero handle to a Perl interpreter if successful; zero otherwise.


BOOL APIENTRY PerlEzDelete(PERLEZHANDLE hHandle);
// Description:
//	Deletes a previously created Perl interpreter.
//	Releases all resources allocated by PerlEzCreate.
//
// Parameters:
//	hHandle	a handle returned by the call to PerlEzCreate
//
// Returns:
//	True if no error false otherwise.


int APIENTRY PerlEzEvalString(PERLEZHANDLE hHandle, LPCSTR lpString, LPSTR lpBuffer, DWORD dwBufSize);
// Description:
//	Evaluates the string a returns the result in lpBuffer.
//	If there is an error $! is returned in lpBuffer.
//
// Parameters:
//	hHandle	a handle returned by the call to PerlEzCreate
//	lpString a pointer to the ASCIIZ string to evaluate
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace


int APIENTRY PerlEzCall1(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize, LPCSTR lpFormat, LPVOID lpVoid);
// Description:
//	Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//	hHandle	a handle returned by the call to PerlEzCreate
//	lpFunction a pointer name of the function to call
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//	lpFormat a pointer to the parameter specifier; can be NULL.
//	lpVoid a pointer to a parameter will be interpreted based on lpFormat
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace
//	plezErrorBadFormat


int APIENTRY PerlEzCall2(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize,
					LPCSTR lpFormat, LPVOID lpVoid1, LPVOID lpVoid2);
// Description:
//	Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//	hHandle	a handle returned by the call to PerlEzCreate
//	lpFunction a pointer name of the function to call
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//	lpFormat a pointer to the parameter specifier; can be NULL.
//	lpVoid1...2 pointers to parameters that will be interpreted based on lpFormat
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace
//	plezErrorBadFormat


int APIENTRY PerlEzCall4(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize,
				LPCSTR lpFormat, LPVOID lpVoid1, LPVOID lpVoid2, LPVOID lpVoid3, LPVOID lpVoid4);
// Description:
//	Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//	hHandle	a handle returned by the call to PerlEzCreate
//	lpFunction a pointer name of the function to call
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//	lpFormat a pointer to the parameter specifier; can be NULL.
//	lpVoid1...4 pointers to parameters that will be interpreted based on lpFormat
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace
//	plezErrorBadFormat


int APIENTRY PerlEzCall8(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize,
				LPCSTR lpFormat, LPVOID lpVoid1, LPVOID lpVoid2, LPVOID lpVoid3, LPVOID lpVoid4,
				LPVOID lpVoid5, LPVOID lpVoid6, LPVOID lpVoid7, LPVOID lpVoid8);
// Description:
//	Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//	hHandle	a handle returned by the call to PerlEzCreate
//	lpFunction a pointer name of the function to call
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//	lpFormat a pointer to the parameter specifier; can be NULL.
//	lpVoid1...8 pointers to parameters that will be interpreted based on lpFormat
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace
//	plezErrorBadFormat


int APIENTRY PerlEzCall(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPSTR lpBuffer, DWORD dwBufSize, LPCSTR lpFormat, ...);
// Description:
//	Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//	hHandle a handle returned by the call to PerlEzCreate
//	lpFunction a pointer name of the function to call
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//	lpFormat a pointer to the parameter specifier; can be NULL.
//	... parameters to be interpreted based on lpFormat
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace
//	plezErrorBadFormat


int APIENTRY PerlEzCallContext(PERLEZHANDLE hHandle, LPCSTR lpFunction, LPVOID lpContextInfo,
						LPSTR lpBuffer, DWORD dwBufSize, LPCSTR lpFormat, ...);
// Description:
//	Calls the function lpFunction and returns the result in the buffer lpBuffer.
//
// Parameters:
//	hHandle a handle returned by the call to PerlEzCreate
//	lpFunction a pointer name of the function to call
//	lpContextInfo context info for magic fetch and store functions
//	lpBuffer a pointer to the buffer where the result will be placed
//	dwBufSize the size in bytes of the space where lpBuffer points
//	lpFormat a pointer to the parameter specifier; can be NULL.
//	... parameters to be interpreted based on lpFormat
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace
//	plezErrorBadFormat


typedef LPCSTR (*LPFETCHVALUEFUNCTION)(LPVOID, LPCSTR);
typedef LPCSTR (*LPSTOREVALUEFUNCTION)(LPVOID, LPCSTR,LPCSTR);

int APIENTRY PerlEzSetMagicScalarFunctions(PERLEZHANDLE hHandle, LPFETCHVALUEFUNCTION lpfFetch, LPSTOREVALUEFUNCTION lpfStore);
// Description:
//	Sets the call back function pointers for magic scalar variables.
//
// Parameters:
//	hHandle a handle returned by the call to PerlEzCreate
//	lpfFetch a pointer to the call back function for fetching a string
//	    if lpfFetch is NULL, then the scalar is write only
//	lpfStore a pointer to the call back function for storinging a string
//	    if lpfStore is NULL, then the scalar is read only
//
//	if lpfFetch and lpfStore are both NULL, then it is an error
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezCallbackAlreadySet
//	plezInvalidParams


int APIENTRY PerlEzSetMagicScalarName(PERLEZHANDLE hHandle, LPCSTR pVariableName);
// Description:
//	Creates the variable if it does not exists and sets it to be tied to
//	    the call back function pointer for magic variables.
//
// Parameters:
//	hHandle a handle returned by the call to PerlEzCreate
//	pVariableName a pointer to the name of the variable
//
// Returns:
//	A zero if no error; otherwise error code.
//
// Possible Error returns
//	plezException
//	plezInvalidHandle
//	plezErrorMoreSpace

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perliol.h ===
#ifndef _PERLIOL_H
#define _PERLIOL_H

typedef struct {
    PerlIO_funcs *funcs;
    SV *arg;
} PerlIO_pair_t;

struct PerlIO_list_s {
    IV refcnt;
    IV cur;
    IV len;
    PerlIO_pair_t *array;
};

struct _PerlIO_funcs {
    Size_t fsize;
    const char *name;
    Size_t size;
    U32 kind;
    IV (*Pushed) (pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
    IV (*Popped) (pTHX_ PerlIO *f);
    PerlIO *(*Open) (pTHX_ PerlIO_funcs *tab,
		     PerlIO_list_t *layers, IV n,
		     const char *mode,
		     int fd, int imode, int perm,
		     PerlIO *old, int narg, SV **args);
    IV (*Binmode)(pTHX_ PerlIO *f);
    SV *(*Getarg) (pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags);
    IV (*Fileno) (pTHX_ PerlIO *f);
    PerlIO *(*Dup) (pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
    /* Unix-like functions - cf sfio line disciplines */
     SSize_t(*Read) (pTHX_ PerlIO *f, void *vbuf, Size_t count);
     SSize_t(*Unread) (pTHX_ PerlIO *f, const void *vbuf, Size_t count);
     SSize_t(*Write) (pTHX_ PerlIO *f, const void *vbuf, Size_t count);
    IV (*Seek) (pTHX_ PerlIO *f, Off_t offset, int whence);
     Off_t(*Tell) (pTHX_ PerlIO *f);
    IV (*Close) (pTHX_ PerlIO *f);
    /* Stdio-like buffered IO functions */
    IV (*Flush) (pTHX_ PerlIO *f);
    IV (*Fill) (pTHX_ PerlIO *f);
    IV (*Eof) (pTHX_ PerlIO *f);
    IV (*Error) (pTHX_ PerlIO *f);
    void (*Clearerr) (pTHX_ PerlIO *f);
    void (*Setlinebuf) (pTHX_ PerlIO *f);
    /* Perl's snooping functions */
    STDCHAR *(*Get_base) (pTHX_ PerlIO *f);
     Size_t(*Get_bufsiz) (pTHX_ PerlIO *f);
    STDCHAR *(*Get_ptr) (pTHX_ PerlIO *f);
     SSize_t(*Get_cnt) (pTHX_ PerlIO *f);
    void (*Set_ptrcnt) (pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
};

/*--------------------------------------------------------------------------------------*/
/* Kind values */
#define PERLIO_K_RAW		0x00000001
#define PERLIO_K_BUFFERED	0x00000002
#define PERLIO_K_CANCRLF	0x00000004
#define PERLIO_K_FASTGETS	0x00000008
#define PERLIO_K_DUMMY		0x00000010
#define PERLIO_K_UTF8		0x00008000
#define PERLIO_K_DESTRUCT	0x00010000
#define PERLIO_K_MULTIARG	0x00020000

/*--------------------------------------------------------------------------------------*/
struct _PerlIO {
    PerlIOl *next;		/* Lower layer */
    PerlIO_funcs *tab;		/* Functions for this layer */
    U32 flags;			/* Various flags for state */
};

/*--------------------------------------------------------------------------------------*/

/* Flag values */
#define PERLIO_F_EOF		0x00000100
#define PERLIO_F_CANWRITE	0x00000200
#define PERLIO_F_CANREAD	0x00000400
#define PERLIO_F_ERROR		0x00000800
#define PERLIO_F_TRUNCATE	0x00001000
#define PERLIO_F_APPEND		0x00002000
#define PERLIO_F_CRLF		0x00004000
#define PERLIO_F_UTF8		0x00008000
#define PERLIO_F_UNBUF		0x00010000
#define PERLIO_F_WRBUF		0x00020000
#define PERLIO_F_RDBUF		0x00040000
#define PERLIO_F_LINEBUF	0x00080000
#define PERLIO_F_TEMP		0x00100000
#define PERLIO_F_OPEN		0x00200000
#define PERLIO_F_FASTGETS	0x00400000
#define PERLIO_F_TTY		0x00800000
#define PERLIO_F_NOTREG         0x01000000   

#define PerlIOBase(f)      (*(f))
#define PerlIOSelf(f,type) ((type *)PerlIOBase(f))
#define PerlIONext(f)      (&(PerlIOBase(f)->next))
#define PerlIOValid(f)     ((f) && *(f))

/*--------------------------------------------------------------------------------------*/
/* Data exports - EXTCONST rather than extern is needed for Cygwin */
#undef EXTPERLIO 
#ifdef PERLIO_FUNCS_CONST
#define EXTPERLIO EXTCONST
#else
#define EXTPERLIO EXT
#endif
EXTPERLIO PerlIO_funcs PerlIO_unix;
EXTPERLIO PerlIO_funcs PerlIO_perlio;
EXTPERLIO PerlIO_funcs PerlIO_stdio;
EXTPERLIO PerlIO_funcs PerlIO_crlf;
EXTPERLIO PerlIO_funcs PerlIO_utf8;
EXTPERLIO PerlIO_funcs PerlIO_byte;
EXTPERLIO PerlIO_funcs PerlIO_raw;
EXTPERLIO PerlIO_funcs PerlIO_pending;
#ifdef HAS_MMAP
EXTPERLIO PerlIO_funcs PerlIO_mmap;
#endif
#ifdef WIN32
EXTPERLIO PerlIO_funcs PerlIO_win32;
#endif
PERL_EXPORT_C PerlIO *PerlIO_allocate(pTHX);
PERL_EXPORT_C SV *PerlIO_arg_fetch(PerlIO_list_t *av, IV n);
#define PerlIOArg PerlIO_arg_fetch(layers,n)

#ifdef PERLIO_USING_CRLF
#define PERLIO_STDTEXT "t"
#else
#define PERLIO_STDTEXT ""
#endif

/*--------------------------------------------------------------------------------------*/
/* perlio buffer layer
   As this is reasonably generic its struct and "methods" are declared here
   so they can be used to "inherit" from it.
*/

typedef struct {
    struct _PerlIO base;	/* Base "class" info */
    STDCHAR *buf;		/* Start of buffer */
    STDCHAR *end;		/* End of valid part of buffer */
    STDCHAR *ptr;		/* Current position in buffer */
    Off_t posn;			/* Offset of buf into the file */
    Size_t bufsiz;		/* Real size of buffer */
    IV oneword;			/* Emergency buffer */
} PerlIOBuf;

PERL_EXPORT_C int PerlIO_apply_layera(pTHX_ PerlIO *f, const char *mode,
		    PerlIO_list_t *layers, IV n, IV max);
PERL_EXPORT_C int PerlIO_parse_layers(pTHX_ PerlIO_list_t *av, const char *names);
PERL_EXPORT_C PerlIO_funcs *PerlIO_layer_fetch(pTHX_ PerlIO_list_t *av, IV n, PerlIO_funcs *def);


PERL_EXPORT_C SV *PerlIO_sv_dup(pTHX_ SV *arg, CLONE_PARAMS *param);
PERL_EXPORT_C void PerlIO_cleantable(pTHX_ PerlIO **tablep);
PERL_EXPORT_C SV * PerlIO_tab_sv(pTHX_ PerlIO_funcs *tab);
PERL_EXPORT_C void PerlIO_default_buffer(pTHX_ PerlIO_list_t *av);
PERL_EXPORT_C void PerlIO_stdstreams(pTHX);
PERL_EXPORT_C int PerlIO__close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO_list_t * PerlIO_resolve_layers(pTHX_ const char *layers, const char *mode, int narg, SV **args);
PERL_EXPORT_C PerlIO_funcs * PerlIO_default_layer(pTHX_ I32 n);
PERL_EXPORT_C PerlIO_list_t * PerlIO_default_layers(pTHX);
PERL_EXPORT_C PerlIO * PerlIO_reopen(const char *path, const char *mode, PerlIO *f);
PERL_EXPORT_C int PerlIO_vsprintf(char *s, int n, const char *fmt, va_list ap)
                __attribute__format__(__printf__,3,0);

PERL_EXPORT_C PerlIO_list_t *PerlIO_list_alloc(pTHX);
PERL_EXPORT_C PerlIO_list_t *PerlIO_clone_list(pTHX_ PerlIO_list_t *proto, CLONE_PARAMS *param);
PERL_EXPORT_C void PerlIO_list_free(pTHX_ PerlIO_list_t *list);
PERL_EXPORT_C void PerlIO_list_push(pTHX_ PerlIO_list_t *list, PerlIO_funcs *funcs, SV *arg);
PERL_EXPORT_C void PerlIO_list_free(pTHX_ PerlIO_list_t *list);

/* PerlIO_teardown doesn't need exporting, but the EXTERN_C is needed
 * for compiling as C++.  Must also match with what perl.h says. */
EXTERN_C void PerlIO_teardown();

/*--------------------------------------------------------------------------------------*/
/* Generic, or stub layer functions */

PERL_EXPORT_C IV        PerlIOBase_binmode(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOBase_clearerr(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBase_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOBase_eof(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_error(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C void      PerlIOBase_flush_linebuf(pTHX);
PERL_EXPORT_C IV        PerlIOBase_noop_fail(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_noop_ok(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_popped(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBase_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOBase_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C void      PerlIOBase_setlinebuf(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBase_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Buf */
PERL_EXPORT_C Size_t    PerlIOBuf_bufsiz(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBuf_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOBuf_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOBuf_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBuf_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOBuf_get_ptr(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOBuf_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *old, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOBuf_popped(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOBuf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOBuf_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOBuf_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOBuf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
PERL_EXPORT_C Off_t     PerlIOBuf_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOBuf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOBuf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Crlf */
PERL_EXPORT_C IV        PerlIOCrlf_binmode(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOCrlf_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOCrlf_get_cnt(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOCrlf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C void      PerlIOCrlf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);
PERL_EXPORT_C SSize_t   PerlIOCrlf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOCrlf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOCrlf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Mmap */
PERL_EXPORT_C IV        PerlIOMmap_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOMmap_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOMmap_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOMmap_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOMmap_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOMmap_map(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOMmap_unmap(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOMmap_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOMmap_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Pending */
PERL_EXPORT_C IV        PerlIOPending_close(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOPending_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOPending_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOPending_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOPending_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt);

/* Pop */
PERL_EXPORT_C IV        PerlIOPop_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

/* Raw */
PERL_EXPORT_C PerlIO *  PerlIORaw_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *old, int narg, SV **args);
PERL_EXPORT_C IV        PerlIORaw_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

/* Stdio */
PERL_EXPORT_C void      PerlIOStdio_clearerr(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOStdio_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOStdio_eof(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_error(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_fill(pTHX_ PerlIO *f);
PERL_EXPORT_C IV        PerlIOStdio_flush(pTHX_ PerlIO *f);
PERL_EXPORT_C STDCHAR * PerlIOStdio_get_base(pTHX_ PerlIO *f);
PERL_EXPORT_C char *    PerlIOStdio_mode(const char *mode, char *tmode);
PERL_EXPORT_C PerlIO *  PerlIOStdio_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOStdio_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOStdio_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C IV        PerlIOStdio_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C void      PerlIOStdio_setlinebuf(pTHX_ PerlIO *f);
PERL_EXPORT_C Off_t     PerlIOStdio_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOStdio_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
PERL_EXPORT_C SSize_t   PerlIOStdio_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Unix */
PERL_EXPORT_C IV        PerlIOUnix_close(pTHX_ PerlIO *f);
PERL_EXPORT_C PerlIO *  PerlIOUnix_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags);
PERL_EXPORT_C IV        PerlIOUnix_fileno(pTHX_ PerlIO *f);
PERL_EXPORT_C int       PerlIOUnix_oflags(const char *mode);
PERL_EXPORT_C PerlIO *  PerlIOUnix_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args);
PERL_EXPORT_C IV        PerlIOUnix_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);
PERL_EXPORT_C SSize_t   PerlIOUnix_read(pTHX_ PerlIO *f, void *vbuf, Size_t count);
PERL_EXPORT_C int       PerlIOUnix_refcnt_dec(int fd);
PERL_EXPORT_C void      PerlIOUnix_refcnt_inc(int fd);
PERL_EXPORT_C IV        PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence);
PERL_EXPORT_C Off_t     PerlIOUnix_tell(pTHX_ PerlIO *f);
PERL_EXPORT_C SSize_t   PerlIOUnix_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count);

/* Utf8 */
PERL_EXPORT_C IV        PerlIOUtf8_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab);

#endif				/* _PERLIOL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perlio.h ===
/*    perlio.h
 *
 *    Copyright (C) 1996, 1997, 1999, 2000, 2001, 2002, 2003,
 *    2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef _PERLIO_H
#define _PERLIO_H
/*
  Interface for perl to IO functions.
  There is a hierarchy of Configure determined #define controls:
   USE_STDIO   - forces PerlIO_xxx() to be #define-d onto stdio functions.
                 This is used for x2p subdirectory and for conservative
                 builds - "just like perl5.00X used to be".
                 This dominates over the others.

   USE_PERLIO  - The primary Configure variable that enables PerlIO.
                 If USE_PERLIO is _NOT_ set
                   then USE_STDIO above will be set to be conservative.
                 If USE_PERLIO is set
                   then there are two modes determined by USE_SFIO:

   USE_SFIO    - If set causes PerlIO_xxx() to be #define-d onto sfio functions.
                 A backward compatability mode for some specialist applications.

                 If USE_SFIO is not set then PerlIO_xxx() are real functions
                 defined in perlio.c which implement extra functionality
                 required for utf8 support.

   One further note - the table-of-functions scheme controlled
   by PERL_IMPLICIT_SYS turns on USE_PERLIO so that iperlsys.h can
   #define PerlIO_xxx() to go via the function table, without having
   to #undef them from (say) stdio forms.

*/

#if defined(PERL_IMPLICIT_SYS)
#ifndef USE_PERLIO
#ifndef NETWARE
/* # define USE_PERLIO */
#endif
#endif
#endif

#ifndef USE_PERLIO
# define USE_STDIO
#endif

#ifdef USE_STDIO
#  ifndef PERLIO_IS_STDIO
#      define PERLIO_IS_STDIO
#  endif
#endif

/* --------------------  End of Configure controls ---------------------------- */

/*
 * Although we may not want stdio to be used including <stdio.h> here
 * avoids issues where stdio.h has strange side effects
 */
#include <stdio.h>

#ifdef __BEOS__
int fseeko(FILE *stream, off_t offset, int whence);
off_t ftello(FILE *stream);
#endif

#if defined(USE_64_BIT_STDIO) && defined(HAS_FTELLO) && !defined(USE_FTELL64)
#define ftell ftello
#endif

#if defined(USE_64_BIT_STDIO) && defined(HAS_FSEEKO) && !defined(USE_FSEEK64)
#define fseek fseeko
#endif

/* BS2000 includes are sometimes a bit non standard :-( */
#if defined(POSIX_BC) && defined(O_BINARY) && !defined(O_TEXT)
#undef O_BINARY
#endif

#ifdef PERLIO_IS_STDIO
/* #define PerlIO_xxxx() as equivalent stdio function */
#include "perlsdio.h"
#else				/* PERLIO_IS_STDIO */
#ifdef USE_SFIO
/* #define PerlIO_xxxx() as equivalent sfio function */
#include "perlsfio.h"
#endif				/* USE_SFIO */
#endif				/* PERLIO_IS_STDIO */

#ifndef PerlIO
/* ----------- PerlIO implementation ---------- */
/* PerlIO not #define-d to something else - define the implementation */

typedef struct _PerlIO PerlIOl;
typedef struct _PerlIO_funcs PerlIO_funcs;
typedef PerlIOl *PerlIO;
#define PerlIO PerlIO
#define PERLIO_LAYERS 1

/* Making the big PerlIO_funcs vtables const is good (enables placing
 * them in the const section which is good for speed, security, and
 * embeddability) but this cannot be done by default because of
 * backward compatibility. */
#ifdef PERLIO_FUNCS_CONST
#define PERLIO_FUNCS_DECL(funcs) const PerlIO_funcs funcs
#define PERLIO_FUNCS_CAST(funcs) (PerlIO_funcs*)(funcs)
#else
#define PERLIO_FUNCS_DECL(funcs) PerlIO_funcs funcs
#define PERLIO_FUNCS_CAST(funcs) (funcs)
#endif

PERL_EXPORT_C void PerlIO_define_layer(pTHX_ PerlIO_funcs *tab);
PERL_EXPORT_C PerlIO_funcs *PerlIO_find_layer(pTHX_ const char *name,
                                              STRLEN len,
				              int load);
PERL_EXPORT_C PerlIO *PerlIO_push(pTHX_ PerlIO *f, PERLIO_FUNCS_DECL(*tab),
			          const char *mode, SV *arg);
PERL_EXPORT_C void PerlIO_pop(pTHX_ PerlIO *f);
PERL_EXPORT_C AV* PerlIO_get_layers(pTHX_ PerlIO *f);
PERL_EXPORT_C void PerlIO_clone(pTHX_ PerlInterpreter *proto,
                                CLONE_PARAMS *param);

#endif				/* PerlIO */

/* ----------- End of implementation choices  ---------- */

#ifndef PERLIO_IS_STDIO
/* Not using stdio _directly_ as PerlIO */

/* We now need to determine  what happens if source trys to use stdio.
 * There are three cases based on PERLIO_NOT_STDIO which XS code
 * can set how it wants.
 */

#ifdef PERL_CORE
/* Make a choice for perl core code
   - currently this is set to try and catch lingering raw stdio calls.
     This is a known issue with some non UNIX ports which still use
     "native" stdio features.
*/
#ifndef PERLIO_NOT_STDIO
#define PERLIO_NOT_STDIO 1
#endif
#else
#ifndef PERLIO_NOT_STDIO
#define PERLIO_NOT_STDIO 0
#endif
#endif

#ifdef PERLIO_NOT_STDIO
#if PERLIO_NOT_STDIO
/*
 * PERLIO_NOT_STDIO #define'd as 1
 * Case 1: Strong denial of stdio - make all stdio calls (we can think of) errors
 */
#include "nostdio.h"
#else				/* if PERLIO_NOT_STDIO */
/*
 * PERLIO_NOT_STDIO #define'd as 0
 * Case 2: Declares that both PerlIO and stdio can be used
 */
#endif				/* if PERLIO_NOT_STDIO */
#else				/* ifdef PERLIO_NOT_STDIO */
/*
 * PERLIO_NOT_STDIO not defined
 * Case 3: Try and fake stdio calls as PerlIO calls
 */
#include "fakesdio.h"
#endif				/* ifndef PERLIO_NOT_STDIO */
#endif				/* PERLIO_IS_STDIO */

/* ----------- fill in things that have not got #define'd  ---------- */

#ifndef Fpos_t
#define Fpos_t Off_t
#endif

#ifndef EOF
#define EOF (-1)
#endif

/* This is to catch case with no stdio */
#ifndef BUFSIZ
#define BUFSIZ 1024
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#ifndef SEEK_END
#define SEEK_END 2
#endif

#define PERLIO_DUP_CLONE	1
#define PERLIO_DUP_FD		2

/* --------------------- Now prototypes for functions --------------- */

START_EXTERN_C
#ifndef __attribute__format__
#  ifdef HASATTRIBUTE_FORMAT
#    define __attribute__format__(x,y,z) __attribute__((format(x,y,z)))
#  else
#    define __attribute__format__(x,y,z)
#  endif
#endif
#ifndef PerlIO_init
PERL_EXPORT_C void PerlIO_init(pTHX);
#endif
#ifndef PerlIO_stdoutf
PERL_EXPORT_C int PerlIO_stdoutf(const char *, ...)
    __attribute__format__(__printf__, 1, 2);
#endif
#ifndef PerlIO_puts
PERL_EXPORT_C int PerlIO_puts(PerlIO *, const char *);
#endif
#ifndef PerlIO_open
PERL_EXPORT_C PerlIO *PerlIO_open(const char *, const char *);
#endif
#ifndef PerlIO_openn
PERL_EXPORT_C PerlIO *PerlIO_openn(pTHX_ const char *layers, const char *mode,
				   int fd, int imode, int perm, PerlIO *old,
				   int narg, SV **arg);
#endif
#ifndef PerlIO_eof
PERL_EXPORT_C int PerlIO_eof(PerlIO *);
#endif
#ifndef PerlIO_error
PERL_EXPORT_C int PerlIO_error(PerlIO *);
#endif
#ifndef PerlIO_clearerr
PERL_EXPORT_C void PerlIO_clearerr(PerlIO *);
#endif
#ifndef PerlIO_getc
PERL_EXPORT_C int PerlIO_getc(PerlIO *);
#endif
#ifndef PerlIO_putc
PERL_EXPORT_C int PerlIO_putc(PerlIO *, int);
#endif
#ifndef PerlIO_ungetc
PERL_EXPORT_C int PerlIO_ungetc(PerlIO *, int);
#endif
#ifndef PerlIO_fdopen
PERL_EXPORT_C PerlIO *PerlIO_fdopen(int, const char *);
#endif
#ifndef PerlIO_importFILE
PERL_EXPORT_C PerlIO *PerlIO_importFILE(FILE *, const char *);
#endif
#ifndef PerlIO_exportFILE
PERL_EXPORT_C FILE *PerlIO_exportFILE(PerlIO *, const char *);
#endif
#ifndef PerlIO_findFILE
PERL_EXPORT_C FILE *PerlIO_findFILE(PerlIO *);
#endif
#ifndef PerlIO_releaseFILE
PERL_EXPORT_C void PerlIO_releaseFILE(PerlIO *, FILE *);
#endif
#ifndef PerlIO_read
PERL_EXPORT_C SSize_t PerlIO_read(PerlIO *, void *, Size_t);
#endif
#ifndef PerlIO_unread
PERL_EXPORT_C SSize_t PerlIO_unread(PerlIO *, const void *, Size_t);
#endif
#ifndef PerlIO_write
PERL_EXPORT_C SSize_t PerlIO_write(PerlIO *, const void *, Size_t);
#endif
#ifndef PerlIO_setlinebuf
PERL_EXPORT_C void PerlIO_setlinebuf(PerlIO *);
#endif
#ifndef PerlIO_printf
PERL_EXPORT_C int PerlIO_printf(PerlIO *, const char *, ...)
    __attribute__format__(__printf__, 2, 3);
#endif
#ifndef PerlIO_sprintf
PERL_EXPORT_C int PerlIO_sprintf(char *, int, const char *, ...)
    __attribute__format__(__printf__, 3, 4);
#endif
#ifndef PerlIO_vprintf
PERL_EXPORT_C int PerlIO_vprintf(PerlIO *, const char *, va_list);
#endif
#ifndef PerlIO_tell
PERL_EXPORT_C Off_t PerlIO_tell(PerlIO *);
#endif
#ifndef PerlIO_seek
PERL_EXPORT_C int PerlIO_seek(PerlIO *, Off_t, int);
#endif
#ifndef PerlIO_rewind
PERL_EXPORT_C void PerlIO_rewind(PerlIO *);
#endif
#ifndef PerlIO_has_base
PERL_EXPORT_C int PerlIO_has_base(PerlIO *);
#endif
#ifndef PerlIO_has_cntptr
PERL_EXPORT_C int PerlIO_has_cntptr(PerlIO *);
#endif
#ifndef PerlIO_fast_gets
PERL_EXPORT_C int PerlIO_fast_gets(PerlIO *);
#endif
#ifndef PerlIO_canset_cnt
PERL_EXPORT_C int PerlIO_canset_cnt(PerlIO *);
#endif
#ifndef PerlIO_get_ptr
PERL_EXPORT_C STDCHAR *PerlIO_get_ptr(PerlIO *);
#endif
#ifndef PerlIO_get_cnt
PERL_EXPORT_C int PerlIO_get_cnt(PerlIO *);
#endif
#ifndef PerlIO_set_cnt
PERL_EXPORT_C void PerlIO_set_cnt(PerlIO *, int);
#endif
#ifndef PerlIO_set_ptrcnt
PERL_EXPORT_C void PerlIO_set_ptrcnt(PerlIO *, STDCHAR *, int);
#endif
#ifndef PerlIO_get_base
PERL_EXPORT_C STDCHAR *PerlIO_get_base(PerlIO *);
#endif
#ifndef PerlIO_get_bufsiz
PERL_EXPORT_C int PerlIO_get_bufsiz(PerlIO *);
#endif
#ifndef PerlIO_tmpfile
PERL_EXPORT_C PerlIO *PerlIO_tmpfile(void);
#endif
#ifndef PerlIO_stdin
PERL_EXPORT_C PerlIO *PerlIO_stdin(void);
#endif
#ifndef PerlIO_stdout
PERL_EXPORT_C PerlIO *PerlIO_stdout(void);
#endif
#ifndef PerlIO_stderr
PERL_EXPORT_C PerlIO *PerlIO_stderr(void);
#endif
#ifndef PerlIO_getpos
PERL_EXPORT_C int PerlIO_getpos(PerlIO *, SV *);
#endif
#ifndef PerlIO_setpos
PERL_EXPORT_C int PerlIO_setpos(PerlIO *, SV *);
#endif
#ifndef PerlIO_fdupopen
PERL_EXPORT_C PerlIO *PerlIO_fdupopen(pTHX_ PerlIO *, CLONE_PARAMS *, int);
#endif
#if !defined(PerlIO_modestr) && !defined(PERLIO_IS_STDIO)
PERL_EXPORT_C char *PerlIO_modestr(PerlIO *, char *buf);
#endif
#ifndef PerlIO_isutf8
PERL_EXPORT_C int PerlIO_isutf8(PerlIO *);
#endif
#ifndef PerlIO_apply_layers
PERL_EXPORT_C int PerlIO_apply_layers(pTHX_ PerlIO *f, const char *mode,
				      const char *names);
#endif
#ifndef PerlIO_binmode
PERL_EXPORT_C int PerlIO_binmode(pTHX_ PerlIO *f, int iotype, int omode,
			  	 const char *names);
#endif
#ifndef PerlIO_getname
PERL_EXPORT_C char *PerlIO_getname(PerlIO *, char *);
#endif

PERL_EXPORT_C void PerlIO_destruct(pTHX);

PERL_EXPORT_C int PerlIO_intmode2str(int rawmode, char *mode, int *writing);

#ifdef PERLIO_LAYERS
PERL_EXPORT_C void PerlIO_cleanup(pTHX);

PERL_EXPORT_C void PerlIO_debug(const char *fmt, ...)
    __attribute__format__(__printf__, 1, 2);
typedef struct PerlIO_list_s PerlIO_list_t;


#endif

END_EXTERN_C
#endif				/* _PERLIO_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perlsdio.h ===
/*    perlsdio.h
 *
 *    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef PERLIO_IS_STDIO

#ifdef NETWARE
	#include "nwstdio.h"
#else

/*
 * This file #define-s the PerlIO_xxx abstraction onto stdio functions.
 * Make this as close to original stdio as possible.
 */
#define PerlIO				FILE
#define PerlIO_stderr()			PerlSIO_stderr
#define PerlIO_stdout()			PerlSIO_stdout
#define PerlIO_stdin()			PerlSIO_stdin

#define PerlIO_isutf8(f)		0

#define PerlIO_printf			PerlSIO_printf
#define PerlIO_stdoutf			PerlSIO_stdoutf
#define PerlIO_vprintf(f,fmt,a)		PerlSIO_vprintf(f,fmt,a)
#define PerlIO_write(f,buf,count)	PerlSIO_fwrite(buf,1,count,f)
#define PerlIO_unread(f,buf,count)	(-1)
#define PerlIO_open			PerlSIO_fopen
#define PerlIO_fdopen			PerlSIO_fdopen
#define PerlIO_reopen			PerlSIO_freopen
#define PerlIO_close(f)			PerlSIO_fclose(f)
#define PerlIO_puts(f,s)		PerlSIO_fputs(f,s)
#define PerlIO_putc(f,c)		PerlSIO_fputc(f,c)
#if defined(VMS)
#  if defined(__DECC)
     /* Unusual definition of ungetc() here to accomodate fast_sv_gets()'
      * belief that it can mix getc/ungetc with reads from stdio buffer */
     int decc$ungetc(int __c, FILE *__stream);
#    define PerlIO_ungetc(f,c) ((c) == EOF ? EOF : \
            ((*(f) && !((*(f))->_flag & _IONBF) && \
            ((*(f))->_ptr > (*(f))->_base)) ? \
            ((*(f))->_cnt++, *(--(*(f))->_ptr) = (c)) : decc$ungetc(c,f)))
#  else
#    define PerlIO_ungetc(f,c)		ungetc(c,f)
#  endif
   /* Work around bug in DECCRTL/AXP (DECC v5.x) and some versions of old
    * VAXCRTL which causes read from a pipe after EOF has been returned
    * once to hang.
    */
#  define PerlIO_getc(f) \
		(feof(f) ? EOF : getc(f))
#  define PerlIO_read(f,buf,count) \
		(feof(f) ? 0 : (SSize_t)fread(buf,1,count,f))
#  define PerlIO_tell(f)		ftell(f)
#else
#  define PerlIO_getc(f)		PerlSIO_fgetc(f)
#  define PerlIO_ungetc(f,c)		PerlSIO_ungetc(c,f)
#  define PerlIO_read(f,buf,count)	(SSize_t)PerlSIO_fread(buf,1,count,f)
#  define PerlIO_tell(f)		PerlSIO_ftell(f)
#endif
#define PerlIO_eof(f)			PerlSIO_feof(f)
#define PerlIO_getname(f,b)		fgetname(f,b)
#define PerlIO_error(f)			PerlSIO_ferror(f)
#define PerlIO_fileno(f)		PerlSIO_fileno(f)
#define PerlIO_clearerr(f)		PerlSIO_clearerr(f)
#define PerlIO_flush(f)			PerlSIO_fflush(f)
#if defined(VMS) && !defined(__DECC)
/* Old VAXC RTL doesn't reset EOF on seek; Perl folk seem to expect this */
#define PerlIO_seek(f,o,w)	(((f) && (*f) && ((*f)->_flag &= ~_IOEOF)),fseek(f,o,w))
#else
#  define PerlIO_seek(f,o,w)		PerlSIO_fseek(f,o,w)
#endif

#define PerlIO_rewind(f)		PerlSIO_rewind(f)
#define PerlIO_tmpfile()		PerlSIO_tmpfile()

#define PerlIO_importFILE(f,fl)		(f)
#define PerlIO_exportFILE(f,fl)		(f)
#define PerlIO_findFILE(f)		(f)
#define PerlIO_releaseFILE(p,f)		((void) 0)

#ifdef HAS_SETLINEBUF
#define PerlIO_setlinebuf(f)		PerlSIO_setlinebuf(f);
#else
#define PerlIO_setlinebuf(f)		PerlSIO_setvbuf(f, NULL, _IOLBF, 0);
#endif

/* Now our interface to Configure's FILE_xxx macros */

#ifdef USE_STDIO_PTR
#define PerlIO_has_cntptr(f)		1
#define PerlIO_get_ptr(f)		PerlSIO_get_ptr(f)
#define PerlIO_get_cnt(f)		PerlSIO_get_cnt(f)

#ifdef STDIO_CNT_LVALUE
#define PerlIO_canset_cnt(f)		1
#define PerlIO_set_cnt(f,c)		PerlSIO_set_cnt(f,c)
#ifdef STDIO_PTR_LVALUE
#ifdef STDIO_PTR_LVAL_NOCHANGE_CNT
#define PerlIO_fast_gets(f)		1
#endif
#endif /* STDIO_PTR_LVALUE */
#else /* STDIO_CNT_LVALUE */
#define PerlIO_canset_cnt(f)		0
#define PerlIO_set_cnt(f,c)		abort()
#endif

#ifdef STDIO_PTR_LVALUE
#ifdef STDIO_PTR_LVAL_NOCHANGE_CNT
#define PerlIO_set_ptrcnt(f,p,c)      STMT_START {PerlSIO_set_ptr(f,p), PerlIO_set_cnt(f,c);} STMT_END
#else
#ifdef STDIO_PTR_LVAL_SETS_CNT
/* assert() may pre-process to ""; potential syntax error (FILE_ptr(), ) */
#define PerlIO_set_ptrcnt(f,p,c)      STMT_START {PerlSIO_set_ptr(f,p); assert(PerlSIO_get_cnt(f) == (c));} STMT_END
#define PerlIO_fast_gets(f)		1
#else
#define PerlIO_set_ptrcnt(f,p,c)	abort()
#endif
#endif
#endif

#else  /* USE_STDIO_PTR */

#define PerlIO_has_cntptr(f)		0
#define PerlIO_canset_cnt(f)		0
#define PerlIO_get_cnt(f)		(abort(),0)
#define PerlIO_get_ptr(f)		(abort(),(void *)0)
#define PerlIO_set_cnt(f,c)		abort()
#define PerlIO_set_ptrcnt(f,p,c)	abort()

#endif /* USE_STDIO_PTR */

#ifndef PerlIO_fast_gets
#define PerlIO_fast_gets(f)		0
#endif


#ifdef FILE_base
#define PerlIO_has_base(f)		1
#define PerlIO_get_base(f)		PerlSIO_get_base(f)
#define PerlIO_get_bufsiz(f)		PerlSIO_get_bufsiz(f)
#else
#define PerlIO_has_base(f)		0
#define PerlIO_get_base(f)		(abort(),(void *)0)
#define PerlIO_get_bufsiz(f)		(abort(),0)
#endif

#endif	/* NETWARE */
#endif /* PERLIO_IS_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perlsfio.h ===
/*    perlsfio.h
 *
 *    Copyright (C) 1996, 1999, 2000, 2001, 2002, 2003, 2005, 2007,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* The next #ifdef should be redundant if Configure behaves ... */
#ifndef FILE
#define FILE FILE
#endif
#ifdef I_SFIO
#include <sfio.h>
#endif

/* sfio 2000 changed _stdopen to _stdfdopen */
#if SFIO_VERSION >= 20000101L
#define _stdopen _stdfdopen
#endif

extern Sfio_t*	_stdopen _ARG_((int, const char*));
extern int	_stdprintf _ARG_((const char*, ...));

#define PerlIO				Sfio_t
#define PerlIO_stderr()			sfstderr
#define PerlIO_stdout()			sfstdout
#define PerlIO_stdin()			sfstdin

#define PerlIO_isutf8(f)		0

#define PerlIO_printf			sfprintf
#define PerlIO_stdoutf			_stdprintf
#define PerlIO_vprintf(f,fmt,a)		sfvprintf(f,fmt,a)
#define PerlIO_read(f,buf,count)	sfread(f,buf,count)
#define PerlIO_write(f,buf,count)	sfwrite(f,buf,count)
#define PerlIO_open(path,mode)		sfopen(NULL,path,mode)
#define PerlIO_fdopen(fd,mode)		_stdopen(fd,mode)
#define PerlIO_reopen(path,mode,f)	sfopen(f,path,mode)
#define PerlIO_close(f)			sfclose(f)
#define PerlIO_puts(f,s)		sfputr(f,s,-1)
#define PerlIO_putc(f,c)		sfputc(f,c)
#define PerlIO_ungetc(f,c)		sfungetc(f,c)
#define PerlIO_sprintf			sfsprintf
#define PerlIO_getc(f)			sfgetc(f)
#define PerlIO_eof(f)			sfeof(f)
#define PerlIO_error(f)			sferror(f)
#define PerlIO_fileno(f)		sffileno(f)
#define PerlIO_clearerr(f)		sfclrerr(f)
#define PerlIO_flush(f)			sfsync(f)
#define PerlIO_tell(f)			sftell(f)
#define PerlIO_seek(f,o,w)		sfseek(f,o,w)
#define PerlIO_rewind(f)		(void) sfseek((f),0L,0)
#define PerlIO_tmpfile()		sftmp(0)
#define PerlIO_exportFILE(f,fl)		Perl_croak(aTHX_ "Export to FILE * unimplemented")
#define PerlIO_releaseFILE(p,f)		Perl_croak(aTHX_ "Release of FILE * unimplemented")

#define PerlIO_setlinebuf(f)		sfset(f,SF_LINE,1)

/* Now our interface to equivalent of Configure's FILE_xxx macros */

#define PerlIO_has_cntptr(f)		1
#define PerlIO_get_ptr(f)		((f)->next)
#define PerlIO_get_cnt(f)		((f)->endr - (f)->next)
#define PerlIO_canset_cnt(f)		1
#define PerlIO_fast_gets(f)		1
#define PerlIO_set_ptrcnt(f,p,c)	STMT_START {(f)->next = (unsigned char *)(p); assert(PerlIO_get_cnt(f) == (c));} STMT_END
#define PerlIO_set_cnt(f,c)		STMT_START {(f)->next = (f)->endr - (c);} STMT_END

#define PerlIO_has_base(f)		1
#define PerlIO_get_base(f)		((f)->data)
#define PerlIO_get_bufsiz(f)		((f)->endr - (f)->data)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perly.h ===
#ifdef PERL_CORE
/* A Bison parser, made by GNU Bison 2.3.  */

/* Skeleton interface for Bison's Yacc-like parsers in C

   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     WORD = 258,
     METHOD = 259,
     FUNCMETH = 260,
     THING = 261,
     PMFUNC = 262,
     PRIVATEREF = 263,
     FUNC0SUB = 264,
     UNIOPSUB = 265,
     LSTOPSUB = 266,
     LABEL = 267,
     FORMAT = 268,
     SUB = 269,
     ANONSUB = 270,
     PACKAGE = 271,
     USE = 272,
     WHILE = 273,
     UNTIL = 274,
     IF = 275,
     UNLESS = 276,
     ELSE = 277,
     ELSIF = 278,
     CONTINUE = 279,
     FOR = 280,
     GIVEN = 281,
     WHEN = 282,
     DEFAULT = 283,
     LOOPEX = 284,
     DOTDOT = 285,
     FUNC0 = 286,
     FUNC1 = 287,
     FUNC = 288,
     UNIOP = 289,
     LSTOP = 290,
     RELOP = 291,
     EQOP = 292,
     MULOP = 293,
     ADDOP = 294,
     DOLSHARP = 295,
     DO = 296,
     HASHBRACK = 297,
     NOAMP = 298,
     LOCAL = 299,
     MY = 300,
     MYSUB = 301,
     REQUIRE = 302,
     COLONATTR = 303,
     PREC_LOW = 304,
     DOROP = 305,
     OROP = 306,
     ANDOP = 307,
     NOTOP = 308,
     ASSIGNOP = 309,
     DORDOR = 310,
     OROR = 311,
     ANDAND = 312,
     BITOROP = 313,
     BITANDOP = 314,
     SHIFTOP = 315,
     MATCHOP = 316,
     REFGEN = 317,
     UMINUS = 318,
     POWOP = 319,
     POSTDEC = 320,
     POSTINC = 321,
     PREDEC = 322,
     PREINC = 323,
     ARROW = 324,
     PEG = 325
   };
#endif
/* Tokens.  */
#define WORD 258
#define METHOD 259
#define FUNCMETH 260
#define THING 261
#define PMFUNC 262
#define PRIVATEREF 263
#define FUNC0SUB 264
#define UNIOPSUB 265
#define LSTOPSUB 266
#define LABEL 267
#define FORMAT 268
#define SUB 269
#define ANONSUB 270
#define PACKAGE 271
#define USE 272
#define WHILE 273
#define UNTIL 274
#define IF 275
#define UNLESS 276
#define ELSE 277
#define ELSIF 278
#define CONTINUE 279
#define FOR 280
#define GIVEN 281
#define WHEN 282
#define DEFAULT 283
#define LOOPEX 284
#define DOTDOT 285
#define FUNC0 286
#define FUNC1 287
#define FUNC 288
#define UNIOP 289
#define LSTOP 290
#define RELOP 291
#define EQOP 292
#define MULOP 293
#define ADDOP 294
#define DOLSHARP 295
#define DO 296
#define HASHBRACK 297
#define NOAMP 298
#define LOCAL 299
#define MY 300
#define MYSUB 301
#define REQUIRE 302
#define COLONATTR 303
#define PREC_LOW 304
#define DOROP 305
#define OROP 306
#define ANDOP 307
#define NOTOP 308
#define ASSIGNOP 309
#define DORDOR 310
#define OROR 311
#define ANDAND 312
#define BITOROP 313
#define BITANDOP 314
#define SHIFTOP 315
#define MATCHOP 316
#define REFGEN 317
#define UMINUS 318
#define POWOP 319
#define POSTDEC 320
#define POSTINC 321
#define PREDEC 322
#define PREINC 323
#define ARROW 324
#define PEG 325




#endif /* PERL_CORE */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef union YYSTYPE
{
    I32	ival; /* __DEFAULT__ (marker for regen_perly.pl;
				must always be 1st union member) */
    char *pval;
    OP *opval;
    GV *gvval;
#ifdef PERL_IN_MADLY_C
    TOKEN* p_tkval;
    TOKEN* i_tkval;
#else
    char *p_tkval;
    I32	i_tkval;
#endif
#ifdef PERL_MAD
    TOKEN* tkval;
#endif
}
/* Line 1489 of yacc.c.  */
	YYSTYPE;
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
# define YYSTYPE_IS_TRIVIAL 1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\pp.h ===
/*    pp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define PP(s) OP * Perl_##s(pTHX)

/*
=head1 Stack Manipulation Macros

=for apidoc AmU||SP
Stack pointer.  This is usually handled by C<xsubpp>.  See C<dSP> and
C<SPAGAIN>.

=for apidoc AmU||MARK
Stack marker variable for the XSUB.  See C<dMARK>.

=for apidoc Am|void|PUSHMARK|SP
Opening bracket for arguments on a callback.  See C<PUTBACK> and
L<perlcall>.

=for apidoc Ams||dSP
Declares a local copy of perl's stack pointer for the XSUB, available via
the C<SP> macro.  See C<SP>.

=for apidoc ms||djSP

Declare Just C<SP>. This is actually identical to C<dSP>, and declares
a local copy of perl's stack pointer, available via the C<SP> macro.
See C<SP>.  (Available for backward source code compatibility with the
old (Perl 5.005) thread model.)

=for apidoc Ams||dMARK
Declare a stack marker variable, C<mark>, for the XSUB.  See C<MARK> and
C<dORIGMARK>.

=for apidoc Ams||dORIGMARK
Saves the original stack mark for the XSUB.  See C<ORIGMARK>.

=for apidoc AmU||ORIGMARK
The original stack mark for the XSUB.  See C<dORIGMARK>.

=for apidoc Ams||SPAGAIN
Refetch the stack pointer.  Used after a callback.  See L<perlcall>.

=cut */

#undef SP /* Solaris 2.7 i386 has this in /usr/include/sys/reg.h */
#define SP sp
#define MARK mark
#define TARG targ

#define PUSHMARK(p)	\
	STMT_START {					\
	    if (++PL_markstack_ptr == PL_markstack_max)	\
	    markstack_grow();				\
	    *PL_markstack_ptr = (I32)((p) - PL_stack_base);\
	} STMT_END

#define TOPMARK		(*PL_markstack_ptr)
#define POPMARK		(*PL_markstack_ptr--)

#define dSP		SV **sp = PL_stack_sp
#define djSP		dSP
#define dMARK		register SV **mark = PL_stack_base + POPMARK
#define dORIGMARK	const I32 origmark = (I32)(mark - PL_stack_base)
#define ORIGMARK	(PL_stack_base + origmark)

#define SPAGAIN		sp = PL_stack_sp
#define MSPAGAIN	STMT_START { sp = PL_stack_sp; mark = ORIGMARK; } STMT_END

#define GETTARGETSTACKED targ = (PL_op->op_flags & OPf_STACKED ? POPs : PAD_SV(PL_op->op_targ))
#define dTARGETSTACKED SV * GETTARGETSTACKED

#define GETTARGET targ = PAD_SV(PL_op->op_targ)
#define dTARGET SV * GETTARGET

#define GETATARGET targ = (PL_op->op_flags & OPf_STACKED ? sp[-1] : PAD_SV(PL_op->op_targ))
#define dATARGET SV * GETATARGET

#define dTARG SV *targ

#define NORMAL PL_op->op_next
#define DIE return Perl_die

/*
=for apidoc Ams||PUTBACK
Closing bracket for XSUB arguments.  This is usually handled by C<xsubpp>.
See C<PUSHMARK> and L<perlcall> for other uses.

=for apidoc Amn|SV*|POPs
Pops an SV off the stack.

=for apidoc Amn|char*|POPp
Pops a string off the stack. Deprecated. New code should use POPpx.

=for apidoc Amn|char*|POPpx
Pops a string off the stack.

=for apidoc Amn|char*|POPpbytex
Pops a string off the stack which must consist of bytes i.e. characters < 256.

=for apidoc Amn|NV|POPn
Pops a double off the stack.

=for apidoc Amn|IV|POPi
Pops an integer off the stack.

=for apidoc Amn|long|POPl
Pops a long off the stack.

=cut
*/

#define PUTBACK		PL_stack_sp = sp
#define RETURN		return (PUTBACK, NORMAL)
#define RETURNOP(o)	return (PUTBACK, o)
#define RETURNX(x)	return (x, PUTBACK, NORMAL)

#define POPs		(*sp--)
#define POPp		(SvPVx(POPs, PL_na))		/* deprecated */
#define POPpx		(SvPVx_nolen(POPs))
#define POPpconstx	(SvPVx_nolen_const(POPs))
#define POPpbytex	(SvPVbytex_nolen(POPs))
#define POPn		(SvNVx(POPs))
#define POPi		((IV)SvIVx(POPs))
#define POPu		((UV)SvUVx(POPs))
#define POPl		((long)SvIVx(POPs))
#define POPul		((unsigned long)SvIVx(POPs))
#ifdef HAS_QUAD
#define POPq		((Quad_t)SvIVx(POPs))
#define POPuq		((Uquad_t)SvUVx(POPs))
#endif

#define TOPs		(*sp)
#define TOPm1s		(*(sp-1))
#define TOPp1s		(*(sp+1))
#define TOPp		(SvPV(TOPs, PL_na))		/* deprecated */
#define TOPpx		(SvPV_nolen(TOPs))
#define TOPn		(SvNV(TOPs))
#define TOPi		((IV)SvIV(TOPs))
#define TOPu		((UV)SvUV(TOPs))
#define TOPl		((long)SvIV(TOPs))
#define TOPul		((unsigned long)SvUV(TOPs))
#ifdef HAS_QUAD
#define TOPq		((Quad_t)SvIV(TOPs))
#define TOPuq		((Uquad_t)SvUV(TOPs))
#endif

/* Go to some pains in the rare event that we must extend the stack. */

/*
=for apidoc Am|void|EXTEND|SP|int nitems
Used to extend the argument stack for an XSUB's return values. Once
used, guarantees that there is room for at least C<nitems> to be pushed
onto the stack.

=for apidoc Am|void|PUSHs|SV* sv
Push an SV onto the stack.  The stack must have room for this element.
Does not handle 'set' magic.  Does not use C<TARG>.  See also C<PUSHmortal>,
C<XPUSHs> and C<XPUSHmortal>.

=for apidoc Am|void|PUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  Uses
C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not
call multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<mPUSHp> instead.  See also C<XPUSHp> and C<mXPUSHp>.

=for apidoc Am|void|PUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<mPUSHn> instead.  See also C<XPUSHn> and
C<mXPUSHn>.

=for apidoc Am|void|PUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to 
return lists from XSUB's - see C<mPUSHi> instead.  See also C<XPUSHi> and
C<mXPUSHi>.

=for apidoc Am|void|PUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG>
should be called to declare it.  Do not call multiple C<TARG>-oriented
macros to return lists from XSUB's - see C<mPUSHu> instead.  See also
C<XPUSHu> and C<mXPUSHu>.

=for apidoc Am|void|XPUSHs|SV* sv
Push an SV onto the stack, extending the stack if necessary.  Does not
handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHmortal>,
C<PUSHs> and C<PUSHmortal>.

=for apidoc Am|void|XPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  Uses C<TARG>, so
C<dTARGET> or C<dXSTARG> should be called to declare it.  Do not call
multiple C<TARG>-oriented macros to return lists from XSUB's - see
C<mXPUSHp> instead.  See also C<PUSHp> and C<mPUSHp>.

=for apidoc Am|void|XPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<mXPUSHn> instead.  See also C<PUSHn> and C<mPUSHn>.

=for apidoc Am|void|XPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be called to
declare it.  Do not call multiple C<TARG>-oriented macros to return lists
from XSUB's - see C<mXPUSHi> instead.  See also C<PUSHi> and C<mPUSHi>.

=for apidoc Am|void|XPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Handles 'set' magic.  Uses C<TARG>, so C<dTARGET> or C<dXSTARG> should be
called to declare it.  Do not call multiple C<TARG>-oriented macros to
return lists from XSUB's - see C<mXPUSHu> instead.  See also C<PUSHu> and
C<mPUSHu>.

=for apidoc Am|void|PUSHmortal
Push a new mortal SV onto the stack.  The stack must have room for this
element.  Does not handle 'set' magic.  Does not use C<TARG>.  See also
C<PUSHs>, C<XPUSHmortal> and C<XPUSHs>.

=for apidoc Am|void|mPUSHp|char* str|STRLEN len
Push a string onto the stack.  The stack must have room for this element.
The C<len> indicates the length of the string.  Handles 'set' magic.  Does
not use C<TARG>.  See also C<PUSHp>, C<mXPUSHp> and C<XPUSHp>.

=for apidoc Am|void|mPUSHn|NV nv
Push a double onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHn>, C<mXPUSHn>
and C<XPUSHn>.

=for apidoc Am|void|mPUSHi|IV iv
Push an integer onto the stack.  The stack must have room for this element.
Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHi>, C<mXPUSHi>
and C<XPUSHi>.

=for apidoc Am|void|mPUSHu|UV uv
Push an unsigned integer onto the stack.  The stack must have room for this
element.  Handles 'set' magic.  Does not use C<TARG>.  See also C<PUSHu>,
C<mXPUSHu> and C<XPUSHu>.

=for apidoc Am|void|XPUSHmortal
Push a new mortal SV onto the stack, extending the stack if necessary.  Does
not handle 'set' magic.  Does not use C<TARG>.  See also C<XPUSHs>,
C<PUSHmortal> and C<PUSHs>.

=for apidoc Am|void|mXPUSHp|char* str|STRLEN len
Push a string onto the stack, extending the stack if necessary.  The C<len>
indicates the length of the string.  Handles 'set' magic.  Does not use
C<TARG>.  See also C<XPUSHp>, C<mPUSHp> and C<PUSHp>.

=for apidoc Am|void|mXPUSHn|NV nv
Push a double onto the stack, extending the stack if necessary.  Handles
'set' magic.  Does not use C<TARG>.  See also C<XPUSHn>, C<mPUSHn> and
C<PUSHn>.

=for apidoc Am|void|mXPUSHi|IV iv
Push an integer onto the stack, extending the stack if necessary.  Handles
'set' magic.  Does not use C<TARG>.  See also C<XPUSHi>, C<mPUSHi> and
C<PUSHi>.

=for apidoc Am|void|mXPUSHu|UV uv
Push an unsigned integer onto the stack, extending the stack if necessary.
Handles 'set' magic.  Does not use C<TARG>.  See also C<XPUSHu>, C<mPUSHu>
and C<PUSHu>.

=cut
*/

#define EXTEND(p,n)	STMT_START { if (PL_stack_max - p < (int)(n)) {		\
			    sp = stack_grow(sp,p, (int) (n));		\
			} } STMT_END

/* Same thing, but update mark register too. */
#define MEXTEND(p,n)	STMT_START {if (PL_stack_max - p < (int)(n)) {	\
			    const int markoff = mark - PL_stack_base;	\
			    sp = stack_grow(sp,p,(int) (n));		\
			    mark = PL_stack_base + markoff;		\
			} } STMT_END

#define PUSHs(s)	(*++sp = (s))
#define PUSHTARG	STMT_START { SvSETMAGIC(TARG); PUSHs(TARG); } STMT_END
#define PUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); PUSHTARG; } STMT_END
#define PUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); PUSHTARG; } STMT_END
#define PUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); PUSHTARG; } STMT_END
#define PUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG; } STMT_END

#define XPUSHs(s)	STMT_START { EXTEND(sp,1); (*++sp = (s)); } STMT_END
#define XPUSHTARG	STMT_START { SvSETMAGIC(TARG); XPUSHs(TARG); } STMT_END
#define XPUSHp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); XPUSHTARG; } STMT_END
#define XPUSHn(n)	STMT_START { sv_setnv(TARG, (NV)(n)); XPUSHTARG; } STMT_END
#define XPUSHi(i)	STMT_START { sv_setiv(TARG, (IV)(i)); XPUSHTARG; } STMT_END
#define XPUSHu(u)	STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
#define XPUSHundef	STMT_START { SvOK_off(TARG); XPUSHs(TARG); } STMT_END

#define PUSHmortal	PUSHs(sv_newmortal())
#define mPUSHp(p,l)	sv_setpvn_mg(PUSHmortal, (p), (l))
#define mPUSHn(n)	sv_setnv_mg(PUSHmortal, (NV)(n))
#define mPUSHi(i)	sv_setiv_mg(PUSHmortal, (IV)(i))
#define mPUSHu(u)	sv_setuv_mg(PUSHmortal, (UV)(u))

#define XPUSHmortal	XPUSHs(sv_newmortal())
#define mXPUSHp(p,l)	STMT_START { EXTEND(sp,1); sv_setpvn_mg(PUSHmortal, (p), (l)); } STMT_END
#define mXPUSHn(n)	STMT_START { EXTEND(sp,1); sv_setnv_mg(PUSHmortal, (NV)(n)); } STMT_END
#define mXPUSHi(i)	STMT_START { EXTEND(sp,1); sv_setiv_mg(PUSHmortal, (IV)(i)); } STMT_END
#define mXPUSHu(u)	STMT_START { EXTEND(sp,1); sv_setuv_mg(PUSHmortal, (UV)(u)); } STMT_END

#define SETs(s)		(*sp = s)
#define SETTARG		STMT_START { SvSETMAGIC(TARG); SETs(TARG); } STMT_END
#define SETp(p,l)	STMT_START { sv_setpvn(TARG, (p), (l)); SETTARG; } STMT_END
#define SETn(n)		STMT_START { sv_setnv(TARG, (NV)(n)); SETTARG; } STMT_END
#define SETi(i)		STMT_START { sv_setiv(TARG, (IV)(i)); SETTARG; } STMT_END
#define SETu(u)		STMT_START { sv_setuv(TARG, (UV)(u)); SETTARG; } STMT_END

#define dTOPss		SV *sv = TOPs
#define dPOPss		SV *sv = POPs
#define dTOPnv		NV value = TOPn
#define dPOPnv		NV value = POPn
#define dTOPiv		IV value = TOPi
#define dPOPiv		IV value = POPi
#define dTOPuv		UV value = TOPu
#define dPOPuv		UV value = POPu
#ifdef HAS_QUAD
#define dTOPqv		Quad_t value = TOPu
#define dPOPqv		Quad_t value = POPu
#define dTOPuqv		Uquad_t value = TOPuq
#define dPOPuqv		Uquad_t value = POPuq
#endif

#define dPOPXssrl(X)	SV *right = POPs; SV *left = CAT2(X,s)
#define dPOPXnnrl(X)	NV right = POPn; NV left = CAT2(X,n)
#define dPOPXiirl(X)	IV right = POPi; IV left = CAT2(X,i)

#define USE_LEFT(sv) \
	(SvOK(sv) || SvGMAGICAL(sv) || !(PL_op->op_flags & OPf_STACKED))
#define dPOPXnnrl_ul(X)	\
    NV right = POPn;				\
    SV *leftsv = CAT2(X,s);				\
    NV left = USE_LEFT(leftsv) ? SvNV(leftsv) : 0.0
#define dPOPXiirl_ul(X) \
    IV right = POPi;					\
    SV *leftsv = CAT2(X,s);				\
    IV left = USE_LEFT(leftsv) ? SvIV(leftsv) : 0

#define dPOPPOPssrl	dPOPXssrl(POP)
#define dPOPPOPnnrl	dPOPXnnrl(POP)
#define dPOPPOPnnrl_ul	dPOPXnnrl_ul(POP)
#define dPOPPOPiirl	dPOPXiirl(POP)
#define dPOPPOPiirl_ul	dPOPXiirl_ul(POP)

#define dPOPTOPssrl	dPOPXssrl(TOP)
#define dPOPTOPnnrl	dPOPXnnrl(TOP)
#define dPOPTOPnnrl_ul	dPOPXnnrl_ul(TOP)
#define dPOPTOPiirl	dPOPXiirl(TOP)
#define dPOPTOPiirl_ul	dPOPXiirl_ul(TOP)

#define RETPUSHYES	RETURNX(PUSHs(&PL_sv_yes))
#define RETPUSHNO	RETURNX(PUSHs(&PL_sv_no))
#define RETPUSHUNDEF	RETURNX(PUSHs(&PL_sv_undef))

#define RETSETYES	RETURNX(SETs(&PL_sv_yes))
#define RETSETNO	RETURNX(SETs(&PL_sv_no))
#define RETSETUNDEF	RETURNX(SETs(&PL_sv_undef))

#define ARGTARG		PL_op->op_targ

    /* See OPpTARGET_MY: */
#define MAXARG		(PL_op->op_private & 15)

#define SWITCHSTACK(f,t) \
    STMT_START {							\
	AvFILLp(f) = sp - PL_stack_base;				\
	PL_stack_base = AvARRAY(t);					\
	PL_stack_max = PL_stack_base + AvMAX(t);			\
	sp = PL_stack_sp = PL_stack_base + AvFILLp(t);			\
	PL_curstack = t;						\
    } STMT_END

#define EXTEND_MORTAL(n) \
    STMT_START {							\
	if (PL_tmps_ix + (n) >= PL_tmps_max)				\
	    tmps_grow(n);						\
    } STMT_END

#define AMGf_noright	1
#define AMGf_noleft	2
#define AMGf_assign	4
#define AMGf_unary	8

#define tryAMAGICbinW_var(meth_enum,assign,set) STMT_START { \
	    SV* const left = *(sp-1); \
	    SV* const right = *(sp); \
	    if ((SvAMAGIC(left)||SvAMAGIC(right))) {\
		SV * const tmpsv = amagic_call(left, \
				   right, \
				   (meth_enum), \
				   (assign)? AMGf_assign: 0); \
		if (tmpsv) { \
		    SPAGAIN; \
		    (void)POPs; set(tmpsv); RETURN; } \
		} \
	} STMT_END

#define tryAMAGICbinW(meth,assign,set) \
    tryAMAGICbinW_var(CAT2(meth,_amg),assign,set)

#define tryAMAGICbin_var(meth_enum,assign) \
		tryAMAGICbinW_var(meth_enum,assign,SETsv)
#define tryAMAGICbin(meth,assign) \
		tryAMAGICbin_var(CAT2(meth,_amg),assign)

#define tryAMAGICbinSET(meth,assign) tryAMAGICbinW(meth,assign,SETs)

#define tryAMAGICbinSET_var(meth_enum,assign) \
    tryAMAGICbinW_var(meth_enum,assign,SETs)

#define AMG_CALLun_var(sv,meth_enum) amagic_call(sv,&PL_sv_undef,  \
					meth_enum,AMGf_noright | AMGf_unary)
#define AMG_CALLun(sv,meth) AMG_CALLun_var(sv,CAT2(meth,_amg))

#define AMG_CALLbinL(left,right,meth) \
            amagic_call(left,right,CAT2(meth,_amg),AMGf_noright)

#define tryAMAGICunW_var(meth_enum,set,shift,ret) STMT_START { \
	    SV* tmpsv; \
	    SV* arg= sp[shift]; \
          if(0) goto am_again;  /* shut up unused warning */ \
	  am_again: \
	    if ((SvAMAGIC(arg))&&\
		(tmpsv=AMG_CALLun_var(arg,(meth_enum)))) {\
	       SPAGAIN; if (shift) sp += shift; \
	       set(tmpsv); ret; } \
	} STMT_END
#define tryAMAGICunW(meth,set,shift,ret) \
	tryAMAGICunW_var(CAT2(meth,_amg),set,shift,ret)

#define FORCE_SETs(sv) STMT_START { sv_setsv(TARG, (sv)); SETTARG; } STMT_END

#define tryAMAGICun_var(meth_enum) tryAMAGICunW_var(meth_enum,SETsvUN,0,RETURN)
#define tryAMAGICun(meth)	tryAMAGICun_var(CAT2(meth,_amg))
#define tryAMAGICunSET(meth)	tryAMAGICunW(meth,SETs,0,RETURN)
#define tryAMAGICunTARGET(meth, shift)					\
	STMT_START { dSP; sp--; 	/* get TARGET from below PL_stack_sp */		\
	    { dTARGETSTACKED; 						\
		{ dSP; tryAMAGICunW(meth,FORCE_SETs,shift,RETURN);}}} STMT_END

#define setAGAIN(ref)	\
    STMT_START {					\
	sv = ref;					\
	if (!SvROK(ref))				\
	    Perl_croak(aTHX_ "Overloaded dereference did not return a reference");	\
	if (ref != arg && SvRV(ref) != SvRV(arg)) {	\
	    arg = ref;					\
	    goto am_again;				\
	}						\
    } STMT_END

#define tryAMAGICunDEREF(meth) tryAMAGICunW(meth,setAGAIN,0,(void)0)
#define tryAMAGICunDEREF_var(meth_enum) \
	tryAMAGICunW_var(meth_enum,setAGAIN,0,(void)0)

#define opASSIGN (PL_op->op_flags & OPf_STACKED)
#define SETsv(sv)	STMT_START {					\
		if (opASSIGN || (SvFLAGS(TARG) & SVs_PADMY))		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END

#define SETsvUN(sv)	STMT_START {					\
		if (SvFLAGS(TARG) & SVs_PADMY)		\
		   { sv_setsv(TARG, (sv)); SETTARG; }			\
		else SETs(sv); } STMT_END

/* newSVsv does not behave as advertised, so we copy missing
 * information by hand */

/* SV* ref causes confusion with the member variable
   changed SV* ref to SV* tmpRef */
#define RvDEEPCP(rv) STMT_START { SV* tmpRef=SvRV(rv);      \
  if (SvREFCNT(tmpRef)>1) {                 \
    SvRV_set(rv, AMG_CALLun(rv,copy));	\
    SvREFCNT_dec(tmpRef);                   \
  } } STMT_END

/*
=for apidoc mU||LVRET
True if this op will be the return value of an lvalue subroutine

=cut */
#define LVRET ((PL_op->op_private & OPpMAYBE_LVSUB) && is_lvalue_sub())

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\pp_proto.h ===
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by opcode.pl from its data.  Any changes made here
   will be lost!
*/

PERL_CKDEF(Perl_ck_anoncode)
PERL_CKDEF(Perl_ck_bitop)
PERL_CKDEF(Perl_ck_chdir)
PERL_CKDEF(Perl_ck_concat)
PERL_CKDEF(Perl_ck_defined)
PERL_CKDEF(Perl_ck_delete)
PERL_CKDEF(Perl_ck_die)
PERL_CKDEF(Perl_ck_eof)
PERL_CKDEF(Perl_ck_eval)
PERL_CKDEF(Perl_ck_exec)
PERL_CKDEF(Perl_ck_exists)
PERL_CKDEF(Perl_ck_exit)
PERL_CKDEF(Perl_ck_ftst)
PERL_CKDEF(Perl_ck_fun)
PERL_CKDEF(Perl_ck_glob)
PERL_CKDEF(Perl_ck_grep)
PERL_CKDEF(Perl_ck_index)
PERL_CKDEF(Perl_ck_join)
PERL_CKDEF(Perl_ck_lengthconst)
PERL_CKDEF(Perl_ck_lfun)
PERL_CKDEF(Perl_ck_listiob)
PERL_CKDEF(Perl_ck_match)
PERL_CKDEF(Perl_ck_method)
PERL_CKDEF(Perl_ck_null)
PERL_CKDEF(Perl_ck_open)
PERL_CKDEF(Perl_ck_readline)
PERL_CKDEF(Perl_ck_repeat)
PERL_CKDEF(Perl_ck_require)
PERL_CKDEF(Perl_ck_return)
PERL_CKDEF(Perl_ck_rfun)
PERL_CKDEF(Perl_ck_rvconst)
PERL_CKDEF(Perl_ck_sassign)
PERL_CKDEF(Perl_ck_select)
PERL_CKDEF(Perl_ck_shift)
PERL_CKDEF(Perl_ck_smartmatch)
PERL_CKDEF(Perl_ck_sort)
PERL_CKDEF(Perl_ck_spair)
PERL_CKDEF(Perl_ck_split)
PERL_CKDEF(Perl_ck_subr)
PERL_CKDEF(Perl_ck_substr)
PERL_CKDEF(Perl_ck_svconst)
PERL_CKDEF(Perl_ck_trunc)
PERL_CKDEF(Perl_ck_unpack)


PERL_PPDEF(Perl_pp_null)
PERL_PPDEF(Perl_pp_stub)
PERL_PPDEF(Perl_pp_scalar)
PERL_PPDEF(Perl_pp_pushmark)
PERL_PPDEF(Perl_pp_wantarray)
PERL_PPDEF(Perl_pp_const)
PERL_PPDEF(Perl_pp_gvsv)
PERL_PPDEF(Perl_pp_gv)
PERL_PPDEF(Perl_pp_gelem)
PERL_PPDEF(Perl_pp_padsv)
PERL_PPDEF(Perl_pp_padav)
PERL_PPDEF(Perl_pp_padhv)
PERL_PPDEF(Perl_pp_padany)
PERL_PPDEF(Perl_pp_pushre)
PERL_PPDEF(Perl_pp_rv2gv)
PERL_PPDEF(Perl_pp_rv2sv)
PERL_PPDEF(Perl_pp_av2arylen)
PERL_PPDEF(Perl_pp_rv2cv)
PERL_PPDEF(Perl_pp_anoncode)
PERL_PPDEF(Perl_pp_prototype)
PERL_PPDEF(Perl_pp_refgen)
PERL_PPDEF(Perl_pp_srefgen)
PERL_PPDEF(Perl_pp_ref)
PERL_PPDEF(Perl_pp_bless)
PERL_PPDEF(Perl_pp_backtick)
PERL_PPDEF(Perl_pp_glob)
PERL_PPDEF(Perl_pp_readline)
PERL_PPDEF(Perl_pp_rcatline)
PERL_PPDEF(Perl_pp_regcmaybe)
PERL_PPDEF(Perl_pp_regcreset)
PERL_PPDEF(Perl_pp_regcomp)
PERL_PPDEF(Perl_pp_match)
PERL_PPDEF(Perl_pp_qr)
PERL_PPDEF(Perl_pp_subst)
PERL_PPDEF(Perl_pp_substcont)
PERL_PPDEF(Perl_pp_trans)
PERL_PPDEF(Perl_pp_sassign)
PERL_PPDEF(Perl_pp_aassign)
PERL_PPDEF(Perl_pp_chop)
PERL_PPDEF(Perl_pp_schop)
PERL_PPDEF(Perl_pp_chomp)
PERL_PPDEF(Perl_pp_schomp)
PERL_PPDEF(Perl_pp_defined)
PERL_PPDEF(Perl_pp_undef)
PERL_PPDEF(Perl_pp_study)
PERL_PPDEF(Perl_pp_pos)
PERL_PPDEF(Perl_pp_preinc)
PERL_PPDEF(Perl_pp_predec)
PERL_PPDEF(Perl_pp_postinc)
PERL_PPDEF(Perl_pp_postdec)
PERL_PPDEF(Perl_pp_pow)
PERL_PPDEF(Perl_pp_multiply)
PERL_PPDEF(Perl_pp_i_multiply)
PERL_PPDEF(Perl_pp_divide)
PERL_PPDEF(Perl_pp_i_divide)
PERL_PPDEF(Perl_pp_modulo)
PERL_PPDEF(Perl_pp_i_modulo)
PERL_PPDEF(Perl_pp_repeat)
PERL_PPDEF(Perl_pp_add)
PERL_PPDEF(Perl_pp_i_add)
PERL_PPDEF(Perl_pp_subtract)
PERL_PPDEF(Perl_pp_i_subtract)
PERL_PPDEF(Perl_pp_concat)
PERL_PPDEF(Perl_pp_stringify)
PERL_PPDEF(Perl_pp_left_shift)
PERL_PPDEF(Perl_pp_right_shift)
PERL_PPDEF(Perl_pp_lt)
PERL_PPDEF(Perl_pp_i_lt)
PERL_PPDEF(Perl_pp_gt)
PERL_PPDEF(Perl_pp_i_gt)
PERL_PPDEF(Perl_pp_le)
PERL_PPDEF(Perl_pp_i_le)
PERL_PPDEF(Perl_pp_ge)
PERL_PPDEF(Perl_pp_i_ge)
PERL_PPDEF(Perl_pp_eq)
PERL_PPDEF(Perl_pp_i_eq)
PERL_PPDEF(Perl_pp_ne)
PERL_PPDEF(Perl_pp_i_ne)
PERL_PPDEF(Perl_pp_ncmp)
PERL_PPDEF(Perl_pp_i_ncmp)
PERL_PPDEF(Perl_pp_slt)
PERL_PPDEF(Perl_pp_sgt)
PERL_PPDEF(Perl_pp_sle)
PERL_PPDEF(Perl_pp_sge)
PERL_PPDEF(Perl_pp_seq)
PERL_PPDEF(Perl_pp_sne)
PERL_PPDEF(Perl_pp_scmp)
PERL_PPDEF(Perl_pp_bit_and)
PERL_PPDEF(Perl_pp_bit_xor)
PERL_PPDEF(Perl_pp_bit_or)
PERL_PPDEF(Perl_pp_negate)
PERL_PPDEF(Perl_pp_i_negate)
PERL_PPDEF(Perl_pp_not)
PERL_PPDEF(Perl_pp_complement)
PERL_PPDEF(Perl_pp_smartmatch)
PERL_PPDEF(Perl_pp_atan2)
PERL_PPDEF(Perl_pp_sin)
PERL_PPDEF(Perl_pp_cos)
PERL_PPDEF(Perl_pp_rand)
PERL_PPDEF(Perl_pp_srand)
PERL_PPDEF(Perl_pp_exp)
PERL_PPDEF(Perl_pp_log)
PERL_PPDEF(Perl_pp_sqrt)
PERL_PPDEF(Perl_pp_int)
PERL_PPDEF(Perl_pp_hex)
PERL_PPDEF(Perl_pp_oct)
PERL_PPDEF(Perl_pp_abs)
PERL_PPDEF(Perl_pp_length)
PERL_PPDEF(Perl_pp_substr)
PERL_PPDEF(Perl_pp_vec)
PERL_PPDEF(Perl_pp_index)
PERL_PPDEF(Perl_pp_rindex)
PERL_PPDEF(Perl_pp_sprintf)
PERL_PPDEF(Perl_pp_formline)
PERL_PPDEF(Perl_pp_ord)
PERL_PPDEF(Perl_pp_chr)
PERL_PPDEF(Perl_pp_crypt)
PERL_PPDEF(Perl_pp_ucfirst)
PERL_PPDEF(Perl_pp_lcfirst)
PERL_PPDEF(Perl_pp_uc)
PERL_PPDEF(Perl_pp_lc)
PERL_PPDEF(Perl_pp_quotemeta)
PERL_PPDEF(Perl_pp_rv2av)
PERL_PPDEF(Perl_pp_aelemfast)
PERL_PPDEF(Perl_pp_aelem)
PERL_PPDEF(Perl_pp_aslice)
PERL_PPDEF(Perl_pp_each)
PERL_PPDEF(Perl_pp_values)
PERL_PPDEF(Perl_pp_keys)
PERL_PPDEF(Perl_pp_delete)
PERL_PPDEF(Perl_pp_exists)
PERL_PPDEF(Perl_pp_rv2hv)
PERL_PPDEF(Perl_pp_helem)
PERL_PPDEF(Perl_pp_hslice)
PERL_PPDEF(Perl_pp_unpack)
PERL_PPDEF(Perl_pp_pack)
PERL_PPDEF(Perl_pp_split)
PERL_PPDEF(Perl_pp_join)
PERL_PPDEF(Perl_pp_list)
PERL_PPDEF(Perl_pp_lslice)
PERL_PPDEF(Perl_pp_anonlist)
PERL_PPDEF(Perl_pp_anonhash)
PERL_PPDEF(Perl_pp_splice)
PERL_PPDEF(Perl_pp_push)
PERL_PPDEF(Perl_pp_pop)
PERL_PPDEF(Perl_pp_shift)
PERL_PPDEF(Perl_pp_unshift)
PERL_PPDEF(Perl_pp_sort)
PERL_PPDEF(Perl_pp_reverse)
PERL_PPDEF(Perl_pp_grepstart)
PERL_PPDEF(Perl_pp_grepwhile)
PERL_PPDEF(Perl_pp_mapstart)
PERL_PPDEF(Perl_pp_mapwhile)
PERL_PPDEF(Perl_pp_range)
PERL_PPDEF(Perl_pp_flip)
PERL_PPDEF(Perl_pp_flop)
PERL_PPDEF(Perl_pp_and)
PERL_PPDEF(Perl_pp_or)
PERL_PPDEF(Perl_pp_xor)
PERL_PPDEF(Perl_pp_dor)
PERL_PPDEF(Perl_pp_cond_expr)
PERL_PPDEF(Perl_pp_andassign)
PERL_PPDEF(Perl_pp_orassign)
PERL_PPDEF(Perl_pp_dorassign)
PERL_PPDEF(Perl_pp_method)
PERL_PPDEF(Perl_pp_entersub)
PERL_PPDEF(Perl_pp_leavesub)
PERL_PPDEF(Perl_pp_leavesublv)
PERL_PPDEF(Perl_pp_caller)
PERL_PPDEF(Perl_pp_warn)
PERL_PPDEF(Perl_pp_die)
PERL_PPDEF(Perl_pp_reset)
PERL_PPDEF(Perl_pp_lineseq)
PERL_PPDEF(Perl_pp_nextstate)
PERL_PPDEF(Perl_pp_dbstate)
PERL_PPDEF(Perl_pp_unstack)
PERL_PPDEF(Perl_pp_enter)
PERL_PPDEF(Perl_pp_leave)
PERL_PPDEF(Perl_pp_scope)
PERL_PPDEF(Perl_pp_enteriter)
PERL_PPDEF(Perl_pp_iter)
PERL_PPDEF(Perl_pp_enterloop)
PERL_PPDEF(Perl_pp_leaveloop)
PERL_PPDEF(Perl_pp_return)
PERL_PPDEF(Perl_pp_last)
PERL_PPDEF(Perl_pp_next)
PERL_PPDEF(Perl_pp_redo)
PERL_PPDEF(Perl_pp_dump)
PERL_PPDEF(Perl_pp_goto)
PERL_PPDEF(Perl_pp_exit)
PERL_PPDEF(Perl_pp_setstate)
PERL_PPDEF(Perl_pp_method_named)
PERL_PPDEF(Perl_pp_entergiven)
PERL_PPDEF(Perl_pp_leavegiven)
PERL_PPDEF(Perl_pp_enterwhen)
PERL_PPDEF(Perl_pp_leavewhen)
PERL_PPDEF(Perl_pp_break)
PERL_PPDEF(Perl_pp_continue)
PERL_PPDEF(Perl_pp_open)
PERL_PPDEF(Perl_pp_close)
PERL_PPDEF(Perl_pp_pipe_op)
PERL_PPDEF(Perl_pp_fileno)
PERL_PPDEF(Perl_pp_umask)
PERL_PPDEF(Perl_pp_binmode)
PERL_PPDEF(Perl_pp_tie)
PERL_PPDEF(Perl_pp_untie)
PERL_PPDEF(Perl_pp_tied)
PERL_PPDEF(Perl_pp_dbmopen)
PERL_PPDEF(Perl_pp_dbmclose)
PERL_PPDEF(Perl_pp_sselect)
PERL_PPDEF(Perl_pp_select)
PERL_PPDEF(Perl_pp_getc)
PERL_PPDEF(Perl_pp_read)
PERL_PPDEF(Perl_pp_enterwrite)
PERL_PPDEF(Perl_pp_leavewrite)
PERL_PPDEF(Perl_pp_prtf)
PERL_PPDEF(Perl_pp_print)
PERL_PPDEF(Perl_pp_say)
PERL_PPDEF(Perl_pp_sysopen)
PERL_PPDEF(Perl_pp_sysseek)
PERL_PPDEF(Perl_pp_sysread)
PERL_PPDEF(Perl_pp_syswrite)
PERL_PPDEF(Perl_pp_send)
PERL_PPDEF(Perl_pp_recv)
PERL_PPDEF(Perl_pp_eof)
PERL_PPDEF(Perl_pp_tell)
PERL_PPDEF(Perl_pp_seek)
PERL_PPDEF(Perl_pp_truncate)
PERL_PPDEF(Perl_pp_fcntl)
PERL_PPDEF(Perl_pp_ioctl)
PERL_PPDEF(Perl_pp_flock)
PERL_PPDEF(Perl_pp_socket)
PERL_PPDEF(Perl_pp_sockpair)
PERL_PPDEF(Perl_pp_bind)
PERL_PPDEF(Perl_pp_connect)
PERL_PPDEF(Perl_pp_listen)
PERL_PPDEF(Perl_pp_accept)
PERL_PPDEF(Perl_pp_shutdown)
PERL_PPDEF(Perl_pp_gsockopt)
PERL_PPDEF(Perl_pp_ssockopt)
PERL_PPDEF(Perl_pp_getsockname)
PERL_PPDEF(Perl_pp_getpeername)
PERL_PPDEF(Perl_pp_lstat)
PERL_PPDEF(Perl_pp_stat)
PERL_PPDEF(Perl_pp_ftrread)
PERL_PPDEF(Perl_pp_ftrwrite)
PERL_PPDEF(Perl_pp_ftrexec)
PERL_PPDEF(Perl_pp_fteread)
PERL_PPDEF(Perl_pp_ftewrite)
PERL_PPDEF(Perl_pp_fteexec)
PERL_PPDEF(Perl_pp_ftis)
PERL_PPDEF(Perl_pp_ftsize)
PERL_PPDEF(Perl_pp_ftmtime)
PERL_PPDEF(Perl_pp_ftatime)
PERL_PPDEF(Perl_pp_ftctime)
PERL_PPDEF(Perl_pp_ftrowned)
PERL_PPDEF(Perl_pp_fteowned)
PERL_PPDEF(Perl_pp_ftzero)
PERL_PPDEF(Perl_pp_ftsock)
PERL_PPDEF(Perl_pp_ftchr)
PERL_PPDEF(Perl_pp_ftblk)
PERL_PPDEF(Perl_pp_ftfile)
PERL_PPDEF(Perl_pp_ftdir)
PERL_PPDEF(Perl_pp_ftpipe)
PERL_PPDEF(Perl_pp_ftsuid)
PERL_PPDEF(Perl_pp_ftsgid)
PERL_PPDEF(Perl_pp_ftsvtx)
PERL_PPDEF(Perl_pp_ftlink)
PERL_PPDEF(Perl_pp_fttty)
PERL_PPDEF(Perl_pp_fttext)
PERL_PPDEF(Perl_pp_ftbinary)
PERL_PPDEF(Perl_pp_chdir)
PERL_PPDEF(Perl_pp_chown)
PERL_PPDEF(Perl_pp_chroot)
PERL_PPDEF(Perl_pp_unlink)
PERL_PPDEF(Perl_pp_chmod)
PERL_PPDEF(Perl_pp_utime)
PERL_PPDEF(Perl_pp_rename)
PERL_PPDEF(Perl_pp_link)
PERL_PPDEF(Perl_pp_symlink)
PERL_PPDEF(Perl_pp_readlink)
PERL_PPDEF(Perl_pp_mkdir)
PERL_PPDEF(Perl_pp_rmdir)
PERL_PPDEF(Perl_pp_open_dir)
PERL_PPDEF(Perl_pp_readdir)
PERL_PPDEF(Perl_pp_telldir)
PERL_PPDEF(Perl_pp_seekdir)
PERL_PPDEF(Perl_pp_rewinddir)
PERL_PPDEF(Perl_pp_closedir)
PERL_PPDEF(Perl_pp_fork)
PERL_PPDEF(Perl_pp_wait)
PERL_PPDEF(Perl_pp_waitpid)
PERL_PPDEF(Perl_pp_system)
PERL_PPDEF(Perl_pp_exec)
PERL_PPDEF(Perl_pp_kill)
PERL_PPDEF(Perl_pp_getppid)
PERL_PPDEF(Perl_pp_getpgrp)
PERL_PPDEF(Perl_pp_setpgrp)
PERL_PPDEF(Perl_pp_getpriority)
PERL_PPDEF(Perl_pp_setpriority)
PERL_PPDEF(Perl_pp_time)
PERL_PPDEF(Perl_pp_tms)
PERL_PPDEF(Perl_pp_localtime)
PERL_PPDEF(Perl_pp_gmtime)
PERL_PPDEF(Perl_pp_alarm)
PERL_PPDEF(Perl_pp_sleep)
PERL_PPDEF(Perl_pp_shmget)
PERL_PPDEF(Perl_pp_shmctl)
PERL_PPDEF(Perl_pp_shmread)
PERL_PPDEF(Perl_pp_shmwrite)
PERL_PPDEF(Perl_pp_msgget)
PERL_PPDEF(Perl_pp_msgctl)
PERL_PPDEF(Perl_pp_msgsnd)
PERL_PPDEF(Perl_pp_msgrcv)
PERL_PPDEF(Perl_pp_semop)
PERL_PPDEF(Perl_pp_semget)
PERL_PPDEF(Perl_pp_semctl)
PERL_PPDEF(Perl_pp_require)
PERL_PPDEF(Perl_pp_dofile)
PERL_PPDEF(Perl_pp_entereval)
PERL_PPDEF(Perl_pp_leaveeval)
PERL_PPDEF(Perl_pp_entertry)
PERL_PPDEF(Perl_pp_leavetry)
PERL_PPDEF(Perl_pp_ghbyname)
PERL_PPDEF(Perl_pp_ghbyaddr)
PERL_PPDEF(Perl_pp_ghostent)
PERL_PPDEF(Perl_pp_gnbyname)
PERL_PPDEF(Perl_pp_gnbyaddr)
PERL_PPDEF(Perl_pp_gnetent)
PERL_PPDEF(Perl_pp_gpbyname)
PERL_PPDEF(Perl_pp_gpbynumber)
PERL_PPDEF(Perl_pp_gprotoent)
PERL_PPDEF(Perl_pp_gsbyname)
PERL_PPDEF(Perl_pp_gsbyport)
PERL_PPDEF(Perl_pp_gservent)
PERL_PPDEF(Perl_pp_shostent)
PERL_PPDEF(Perl_pp_snetent)
PERL_PPDEF(Perl_pp_sprotoent)
PERL_PPDEF(Perl_pp_sservent)
PERL_PPDEF(Perl_pp_ehostent)
PERL_PPDEF(Perl_pp_enetent)
PERL_PPDEF(Perl_pp_eprotoent)
PERL_PPDEF(Perl_pp_eservent)
PERL_PPDEF(Perl_pp_gpwnam)
PERL_PPDEF(Perl_pp_gpwuid)
PERL_PPDEF(Perl_pp_gpwent)
PERL_PPDEF(Perl_pp_spwent)
PERL_PPDEF(Perl_pp_epwent)
PERL_PPDEF(Perl_pp_ggrnam)
PERL_PPDEF(Perl_pp_ggrgid)
PERL_PPDEF(Perl_pp_ggrent)
PERL_PPDEF(Perl_pp_sgrent)
PERL_PPDEF(Perl_pp_egrent)
PERL_PPDEF(Perl_pp_getlogin)
PERL_PPDEF(Perl_pp_syscall)
PERL_PPDEF(Perl_pp_lock)
PERL_PPDEF(Perl_pp_once)

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\perlvars.h ===
/*    perlvars.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/****************/
/* Truly global */
/****************/

/* Don't forget to re-run embed.pl to propagate changes! */

/* This file describes the "global" variables used by perl
 * This used to be in perl.h directly but we want to abstract out into
 * distinct files which are per-thread, per-interpreter or really global,
 * and how they're initialized.
 *
 * The 'G' prefix is only needed for vars that need appropriate #defines
 * generated in embed*.h.  Such symbols are also used to generate
 * the appropriate export list for win32. */

/* global state */
PERLVAR(Gcurinterp,	PerlInterpreter *)
					/* currently running interpreter
					 * (initial parent interpreter under
					 * useithreads) */
#if defined(USE_ITHREADS)
PERLVAR(Gthr_key,	perl_key)	/* key to retrieve per-thread struct */
#endif

/* constants (these are not literals to facilitate pointer comparisons)
 * (PERLVARISC really does create variables, despite its looks) */
PERLVARISC(GYes,	"1")
PERLVARISC(GNo,		"")
PERLVARISC(Ghexdigit,	"0123456789abcdef0123456789ABCDEF")
PERLVARISC(Gpatleave,	"\\.^$@dDwWsSbB+*?|()-nrtfeaxc0123456789[{]}")

/* XXX does anyone even use this? */
PERLVARI(Gdo_undump,	bool,	FALSE)	/* -u or dump seen? */

#if defined(MYMALLOC) && defined(USE_ITHREADS)
PERLVAR(Gmalloc_mutex,	perl_mutex)	/* Mutex for malloc */
#endif

#if defined(USE_ITHREADS)
PERLVAR(Gop_mutex,	perl_mutex)	/* Mutex for op refcounting */
#endif

#ifdef USE_ITHREADS
PERLVAR(Gdollarzero_mutex, perl_mutex)	/* Modifying $0 */
#endif


/* This is constant on most architectures, a global on OS/2 */
#ifdef OS2
#  define PERL___C
#else
#  define PERL___C const
#endif
PERLVARI(Gsh_path,	PERL___C char *, SH_PATH) /* full path of shell */
#undef PERL___C

#ifndef PERL_MICRO
/* If Perl has to ignore SIGPFE, this is its saved state.
 * See perl.h macros PERL_FPU_INIT and PERL_FPU_{PRE,POST}_EXEC. */
PERLVAR(Gsigfpe_saved,	Sighandler_t)
#endif

/* Restricted hashes placeholder value.
 * The contents are never used, only the address. */
PERLVAR(Gsv_placeholder, SV)

#ifndef PERL_MICRO
PERLVARI(Gcsighandlerp,	Sighandler_t, Perl_csighandler)	/* Pointer to C-level sighandler */
#endif

#ifndef PERL_USE_SAFE_PUTENV
PERLVARI(Guse_safe_putenv, int, 1)
#endif

#ifdef USE_PERLIO
PERLVARI(Gperlio_fd_refcnt, int*, 0) /* Pointer to array of fd refcounts.  */
PERLVARI(Gperlio_fd_refcnt_size, int, 0) /* Size of the array */
PERLVARI(Gperlio_debug_fd, int, 0) /* the fd to write perlio debug into, 0 means not set yet */
#endif

#ifdef HAS_MMAP
PERLVARI(Gmmap_page_size, IV, 0)
#endif

#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS)||defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
PERLVARI(Gsig_handlers_initted, int, 0)
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
PERLVARA(Gsig_ignoring, SIG_SIZE, int)	/* which signals we are ignoring */
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
PERLVARA(Gsig_defaulting, SIG_SIZE, int)
#endif

#ifndef PERL_IMPLICIT_CONTEXT
PERLVAR(Gsig_sv, SV*)
#endif

/* XXX signals are process-wide anyway, so we
 * ignore the implications of this for threading */
#ifndef HAS_SIGACTION
PERLVARI(Gsig_trapped, int, 0)
#endif

#ifdef DEBUGGING
PERLVAR(Gwatch_pvx, char*)
#endif

#ifdef PERL_GLOBAL_STRUCT 
PERLVAR(Gppaddr, Perl_ppaddr_t*) /* or opcode.h */
PERLVAR(Gcheck,  Perl_check_t *) /* or opcode.h */
PERLVARA(Gfold_locale, 256, unsigned char) /* or perl.h */
#endif

#ifdef PERL_NEED_APPCTX
PERLVAR(Gappctx, void*) /* the application context */
#endif

PERLVAR(Gop_sequence, HV*) /* dump.c */
PERLVARI(Gop_seq, UV, 0) /* dump.c */

#if defined(HAS_TIMES) && defined(PERL_NEED_TIMESBASE)
PERLVAR(Gtimesbase, struct tms)
#endif

/* allocate a unique index to every module that calls MY_CXT_INIT */

#ifdef PERL_IMPLICIT_CONTEXT
# ifdef USE_ITHREADS
PERLVAR(Gmy_ctx_mutex, perl_mutex)
# endif
PERLVARI(Gmy_cxt_index, int, 0)
#endif

#if defined(USE_ITHREADS)
PERLVAR(Ghints_mutex, perl_mutex)    /* Mutex for refcounted he refcounting */
#endif

#if defined(USE_ITHREADS)
PERLVAR(Gperlio_mutex, perl_mutex)    /* Mutex for perlio fd refcounts */
#endif

/* this is currently set without MUTEX protection, so keep it a type which
 * can be set atomically (ie not a bit field) */
PERLVARI(Gveto_cleanup,	int, FALSE)	/* exit without cleanup */

/* dummy variables that hold pointers to both runops functions, thus forcing
 * them *both* to get linked in (useful for Peek.xs, debugging etc) */

PERLVARI(Grunops_std,	runops_proc_t,	MEMBER_TO_FPTR(Perl_runops_standard))
PERLVARI(Grunops_dbg,	runops_proc_t,	MEMBER_TO_FPTR(Perl_runops_debug))


/* These are baked at compile time into any shared perl library.
   In future 5.10.x releases this will allow us in main() to sanity test the
   library we're linking against.  */

PERLVARI(Grevision,	U8,	PERL_REVISION)
PERLVARI(Gversion,	U8,	PERL_VERSION)
PERLVARI(Gsubversion,	U8,	PERL_SUBVERSION)

#if defined(MULTIPLICITY)
#  define PERL_INTERPRETER_SIZE_UPTO_MEMBER(member)			\
    STRUCT_OFFSET(struct interpreter, member) +				\
    sizeof(((struct interpreter*)0)->member)

/* These might be useful.  */
PERLVARI(Ginterp_size,	U16,	sizeof(struct interpreter))
#if defined(PERL_GLOBAL_STRUCT)
PERLVARI(Gglobal_struct_size,	U16,	sizeof(struct perl_vars))
#endif

/* This will be useful for subsequent releases, because this has to be the
   same in your libperl as in main(), else you have a mismatch and must abort.
*/
PERLVARI(Ginterp_size_5_10_0, U16,
	 PERL_INTERPRETER_SIZE_UPTO_MEMBER(PERL_LAST_5_10_0_INTERP_MEMBER))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\reentr.h ===
/* -*- buffer-read-only: t -*-
 *
 *    reentr.h
 *
 *    Copyright (C) 2002, 2003, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 *  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *  This file is built by reentr.pl from data in reentr.pl.
 */

#ifndef REENTR_H
#define REENTR_H

/* If compiling for a threaded perl, we will macro-wrap the system/library
 * interfaces (e.g. getpwent()) which have threaded versions
 * (e.g. getpwent_r()), which will handle things correctly for
 * the Perl interpreter, but otherwise (for XS) the wrapping does
 * not take place.  See L<perlxs/Thread-aware system interfaces>.
 */

#ifndef PERL_REENTR_API
# if defined(PERL_CORE) || defined(PERL_EXT)
#  define PERL_REENTR_API 1
# else
#  define PERL_REENTR_API 0
# endif
#endif

#ifdef USE_REENTRANT_API
 
/* Deprecations: some platforms have the said reentrant interfaces
 * but they are declared obsolete and are not to be used.  Often this
 * means that the platform has threadsafed the interfaces (hopefully).
 * All this is OS version dependent, so we are of course fooling ourselves.
 * If you know of more deprecations on some platforms, please add your own
 * (by editing reentr.pl, mind!) */

#ifdef __hpux
#   undef HAS_CRYPT_R
#   undef HAS_DRAND48_R
#   undef HAS_ENDGRENT_R
#   undef HAS_ENDPWENT_R
#   undef HAS_GETGRENT_R
#   undef HAS_GETPWENT_R
#   undef HAS_SETLOCALE_R
#   undef HAS_SRAND48_R
#   undef HAS_STRERROR_R
#   define NETDB_R_OBSOLETE
#endif

#if defined(__osf__) && defined(__alpha) /* Tru64 aka Digital UNIX */
#   undef HAS_CRYPT_R
#   undef HAS_STRERROR_R
#   define NETDB_R_OBSOLETE
#endif

/*
 * As of OpenBSD 3.7, reentrant functions are now working, they just are
 * incompatible with everyone else.  To make OpenBSD happy, we have to
 * memzero out certain structures before calling the functions.
 */
#if defined(__OpenBSD__)
#    define REENTR_MEMZERO(a,b) memzero(a,b)
#else
#    define REENTR_MEMZERO(a,b) 0
#endif 

#ifdef NETDB_R_OBSOLETE
#   undef HAS_ENDHOSTENT_R
#   undef HAS_ENDNETENT_R
#   undef HAS_ENDPROTOENT_R
#   undef HAS_ENDSERVENT_R
#   undef HAS_GETHOSTBYADDR_R
#   undef HAS_GETHOSTBYNAME_R
#   undef HAS_GETHOSTENT_R
#   undef HAS_GETNETBYADDR_R
#   undef HAS_GETNETBYNAME_R
#   undef HAS_GETNETENT_R
#   undef HAS_GETPROTOBYNAME_R
#   undef HAS_GETPROTOBYNUMBER_R
#   undef HAS_GETPROTOENT_R
#   undef HAS_GETSERVBYNAME_R
#   undef HAS_GETSERVBYPORT_R
#   undef HAS_GETSERVENT_R
#   undef HAS_SETHOSTENT_R
#   undef HAS_SETNETENT_R
#   undef HAS_SETPROTOENT_R
#   undef HAS_SETSERVENT_R
#endif

#ifdef I_PWD
#   include <pwd.h>
#endif
#ifdef I_GRP
#   include <grp.h>
#endif
#ifdef I_NETDB
#   include <netdb.h>
#endif
#ifdef I_STDLIB
#   include <stdlib.h>	/* drand48_data */
#endif
#ifdef I_CRYPT
#   ifdef I_CRYPT
#       include <crypt.h>
#   endif
#endif
#ifdef HAS_GETSPNAM_R
#   ifdef I_SHADOW
#       include <shadow.h>
#   endif
#endif

#define REENTRANT_PROTO_B_B	1
#define REENTRANT_PROTO_B_BI	2
#define REENTRANT_PROTO_B_BW	3
#define REENTRANT_PROTO_B_CCD	4
#define REENTRANT_PROTO_B_CCS	5
#define REENTRANT_PROTO_B_IBI	6
#define REENTRANT_PROTO_B_IBW	7
#define REENTRANT_PROTO_B_SB	8
#define REENTRANT_PROTO_B_SBI	9
#define REENTRANT_PROTO_I_BI	10
#define REENTRANT_PROTO_I_BW	11
#define REENTRANT_PROTO_I_CCSBWR	12
#define REENTRANT_PROTO_I_CCSD	13
#define REENTRANT_PROTO_I_CII	14
#define REENTRANT_PROTO_I_CIISD	15
#define REENTRANT_PROTO_I_CSBI	16
#define REENTRANT_PROTO_I_CSBIR	17
#define REENTRANT_PROTO_I_CSBWR	18
#define REENTRANT_PROTO_I_CSBWRE	19
#define REENTRANT_PROTO_I_CSD	20
#define REENTRANT_PROTO_I_CWISBWRE	21
#define REENTRANT_PROTO_I_CWISD	22
#define REENTRANT_PROTO_I_D	23
#define REENTRANT_PROTO_I_H	24
#define REENTRANT_PROTO_I_IBI	25
#define REENTRANT_PROTO_I_IBW	26
#define REENTRANT_PROTO_I_ICBI	27
#define REENTRANT_PROTO_I_ICSBWR	28
#define REENTRANT_PROTO_I_ICSD	29
#define REENTRANT_PROTO_I_ID	30
#define REENTRANT_PROTO_I_IISD	31
#define REENTRANT_PROTO_I_ISBWR	32
#define REENTRANT_PROTO_I_ISD	33
#define REENTRANT_PROTO_I_LISBI	34
#define REENTRANT_PROTO_I_LISD	35
#define REENTRANT_PROTO_I_LS	36
#define REENTRANT_PROTO_I_SB	37
#define REENTRANT_PROTO_I_SBI	38
#define REENTRANT_PROTO_I_SBIE	39
#define REENTRANT_PROTO_I_SBIH	40
#define REENTRANT_PROTO_I_SBIR	41
#define REENTRANT_PROTO_I_SBWR	42
#define REENTRANT_PROTO_I_SBWRE	43
#define REENTRANT_PROTO_I_SD	44
#define REENTRANT_PROTO_I_ST	45
#define REENTRANT_PROTO_I_St	46
#define REENTRANT_PROTO_I_TISD	47
#define REENTRANT_PROTO_I_TS	48
#define REENTRANT_PROTO_I_TSBI	49
#define REENTRANT_PROTO_I_TSBIR	50
#define REENTRANT_PROTO_I_TSBWR	51
#define REENTRANT_PROTO_I_TSR	52
#define REENTRANT_PROTO_I_TsISBWRE	53
#define REENTRANT_PROTO_I_UISBWRE	54
#define REENTRANT_PROTO_I_iS	55
#define REENTRANT_PROTO_I_lS	56
#define REENTRANT_PROTO_I_uISBWRE	57
#define REENTRANT_PROTO_S_CBI	58
#define REENTRANT_PROTO_S_CCSBI	59
#define REENTRANT_PROTO_S_CIISBIE	60
#define REENTRANT_PROTO_S_CSBI	61
#define REENTRANT_PROTO_S_CSBIE	62
#define REENTRANT_PROTO_S_CWISBIE	63
#define REENTRANT_PROTO_S_CWISBWIE	64
#define REENTRANT_PROTO_S_ICSBI	65
#define REENTRANT_PROTO_S_ISBI	66
#define REENTRANT_PROTO_S_LISBI	67
#define REENTRANT_PROTO_S_SBI	68
#define REENTRANT_PROTO_S_SBIE	69
#define REENTRANT_PROTO_S_SBW	70
#define REENTRANT_PROTO_S_TISBI	71
#define REENTRANT_PROTO_S_TS	72
#define REENTRANT_PROTO_S_TSBI	73
#define REENTRANT_PROTO_S_TSBIE	74
#define REENTRANT_PROTO_S_TWISBIE	75
#define REENTRANT_PROTO_V_D	76
#define REENTRANT_PROTO_V_H	77
#define REENTRANT_PROTO_V_ID	78

/* Defines for indicating which special features are supported. */

/* The getgrent getgrgid getgrnam using buffer? */

#if defined(HAS_GETGRENT_R) && (GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIR || GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBW || GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETGRENT_R_HAS_BUFFER
#else
#   undef  GETGRENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETGRGID_R) && (GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBWR || GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBIR || GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBI || GETGRGID_R_PROTO == REENTRANT_PROTO_S_TSBI)
#   define GETGRGID_R_HAS_BUFFER
#else
#   undef  GETGRGID_R_HAS_BUFFER
#endif
#if defined(HAS_GETGRNAM_R) && (GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR || GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CBI || GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBI || GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CSBI)
#   define GETGRNAM_R_HAS_BUFFER
#else
#   undef  GETGRNAM_R_HAS_BUFFER
#endif

/* Any of the getgrent getgrgid getgrnam using buffer? */

#if (defined(GETGRENT_R_HAS_BUFFER) || defined(GETGRGID_R_HAS_BUFFER) || defined(GETGRNAM_R_HAS_BUFFER))
#   define USE_GRENT_BUFFER
#else
#   undef  USE_GRENT_BUFFER
#endif

/* The getgrent getgrgid getgrnam using ptr? */

#if defined(HAS_GETGRENT_R) && (GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIR)
#   define GETGRENT_R_HAS_PTR
#else
#   undef  GETGRENT_R_HAS_PTR
#endif
#if defined(HAS_GETGRGID_R) && (GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBWR || GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBIR)
#   define GETGRGID_R_HAS_PTR
#else
#   undef  GETGRGID_R_HAS_PTR
#endif
#if defined(HAS_GETGRNAM_R) && (GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR)
#   define GETGRNAM_R_HAS_PTR
#else
#   undef  GETGRNAM_R_HAS_PTR
#endif

/* Any of the getgrent getgrgid getgrnam using ptr? */

#if (defined(GETGRENT_R_HAS_PTR) || defined(GETGRGID_R_HAS_PTR) || defined(GETGRNAM_R_HAS_PTR))
#   define USE_GRENT_PTR
#else
#   undef  USE_GRENT_PTR
#endif

/* The getpwent getpwnam getpwuid using ptr? */

#if defined(HAS_GETPWENT_R) && (GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIR)
#   define GETPWENT_R_HAS_PTR
#else
#   undef  GETPWENT_R_HAS_PTR
#endif
#if defined(HAS_GETPWNAM_R) && (GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR)
#   define GETPWNAM_R_HAS_PTR
#else
#   undef  GETPWNAM_R_HAS_PTR
#endif
#if defined(HAS_GETPWUID_R) && (GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBWR || GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBIR)
#   define GETPWUID_R_HAS_PTR
#else
#   undef  GETPWUID_R_HAS_PTR
#endif

/* Any of the getpwent getpwnam getpwuid using ptr? */

#if (defined(GETPWENT_R_HAS_PTR) || defined(GETPWNAM_R_HAS_PTR) || defined(GETPWUID_R_HAS_PTR))
#   define USE_PWENT_PTR
#else
#   undef  USE_PWENT_PTR
#endif

/* The getspent getspnam using ptr? */

#if defined(HAS_GETSPNAM_R) && (GETSPNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR)
#   define GETSPNAM_R_HAS_PTR
#else
#   undef  GETSPNAM_R_HAS_PTR
#endif

/* Any of the getspent getspnam using ptr? */

#if (defined(GETSPENT_R_HAS_PTR) || defined(GETSPNAM_R_HAS_PTR))
#   define USE_SPENT_PTR
#else
#   undef  USE_SPENT_PTR
#endif

/* The getgrent getgrgid getgrnam setgrent endgrent using fptr? */

#if defined(HAS_GETGRENT_R) && (GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETGRENT_R_HAS_FPTR
#else
#   undef  GETGRENT_R_HAS_FPTR
#endif
#if defined(HAS_SETGRENT_R) && (SETGRENT_R_PROTO == REENTRANT_PROTO_I_H || SETGRENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define SETGRENT_R_HAS_FPTR
#else
#   undef  SETGRENT_R_HAS_FPTR
#endif
#if defined(HAS_ENDGRENT_R) && (ENDGRENT_R_PROTO == REENTRANT_PROTO_I_H || ENDGRENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define ENDGRENT_R_HAS_FPTR
#else
#   undef  ENDGRENT_R_HAS_FPTR
#endif

/* Any of the getgrent getgrgid getgrnam setgrent endgrent using fptr? */

#if (defined(GETGRENT_R_HAS_FPTR) || defined(GETGRGID_R_HAS_FPTR) || defined(GETGRNAM_R_HAS_FPTR) || defined(SETGRENT_R_HAS_FPTR) || defined(ENDGRENT_R_HAS_FPTR))
#   define USE_GRENT_FPTR
#else
#   undef  USE_GRENT_FPTR
#endif

/* The getpwent getpwnam getpwuid setpwent endpwent using fptr? */

#if defined(HAS_GETPWENT_R) && (GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETPWENT_R_HAS_FPTR
#else
#   undef  GETPWENT_R_HAS_FPTR
#endif
#if defined(HAS_SETPWENT_R) && (SETPWENT_R_PROTO == REENTRANT_PROTO_I_H || SETPWENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define SETPWENT_R_HAS_FPTR
#else
#   undef  SETPWENT_R_HAS_FPTR
#endif
#if defined(HAS_ENDPWENT_R) && (ENDPWENT_R_PROTO == REENTRANT_PROTO_I_H || ENDPWENT_R_PROTO == REENTRANT_PROTO_V_H)
#   define ENDPWENT_R_HAS_FPTR
#else
#   undef  ENDPWENT_R_HAS_FPTR
#endif

/* Any of the getpwent getpwnam getpwuid setpwent endpwent using fptr? */

#if (defined(GETPWENT_R_HAS_FPTR) || defined(GETPWNAM_R_HAS_FPTR) || defined(GETPWUID_R_HAS_FPTR) || defined(SETPWENT_R_HAS_FPTR) || defined(ENDPWENT_R_HAS_FPTR))
#   define USE_PWENT_FPTR
#else
#   undef  USE_PWENT_FPTR
#endif

/* The getpwent getpwgid getpwnam using buffer? */

#if defined(HAS_GETPWENT_R) && (GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIR || GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBW || GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIH)
#   define GETPWENT_R_HAS_BUFFER
#else
#   undef  GETPWENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETPWNAM_R) && (GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR || GETPWNAM_R_PROTO == REENTRANT_PROTO_S_CSBI || GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBI)
#   define GETPWNAM_R_HAS_BUFFER
#else
#   undef  GETPWNAM_R_HAS_BUFFER
#endif

/* Any of the getpwent getpwgid getpwnam using buffer? */

#if (defined(GETPWENT_R_HAS_BUFFER) || defined(GETPWGID_R_HAS_BUFFER) || defined(GETPWNAM_R_HAS_BUFFER))
#   define USE_PWENT_BUFFER
#else
#   undef  USE_PWENT_BUFFER
#endif

/* The gethostent gethostbyaddr gethostbyname using ptr? */

#if defined(HAS_GETHOSTENT_R) && (GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE)
#   define GETHOSTENT_R_HAS_PTR
#else
#   undef  GETHOSTENT_R_HAS_PTR
#endif
#if defined(HAS_GETHOSTBYADDR_R) && (GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE)
#   define GETHOSTBYADDR_R_HAS_PTR
#else
#   undef  GETHOSTBYADDR_R_HAS_PTR
#endif
#if defined(HAS_GETHOSTBYNAME_R) && (GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE)
#   define GETHOSTBYNAME_R_HAS_PTR
#else
#   undef  GETHOSTBYNAME_R_HAS_PTR
#endif

/* Any of the gethostent gethostbyaddr gethostbyname using ptr? */

#if (defined(GETHOSTENT_R_HAS_PTR) || defined(GETHOSTBYADDR_R_HAS_PTR) || defined(GETHOSTBYNAME_R_HAS_PTR))
#   define USE_HOSTENT_PTR
#else
#   undef  USE_HOSTENT_PTR
#endif

/* The getnetent getnetbyaddr getnetbyname using ptr? */

#if defined(HAS_GETNETENT_R) && (GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE)
#   define GETNETENT_R_HAS_PTR
#else
#   undef  GETNETENT_R_HAS_PTR
#endif
#if defined(HAS_GETNETBYADDR_R) && (GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE)
#   define GETNETBYADDR_R_HAS_PTR
#else
#   undef  GETNETBYADDR_R_HAS_PTR
#endif
#if defined(HAS_GETNETBYNAME_R) && (GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE)
#   define GETNETBYNAME_R_HAS_PTR
#else
#   undef  GETNETBYNAME_R_HAS_PTR
#endif

/* Any of the getnetent getnetbyaddr getnetbyname using ptr? */

#if (defined(GETNETENT_R_HAS_PTR) || defined(GETNETBYADDR_R_HAS_PTR) || defined(GETNETBYNAME_R_HAS_PTR))
#   define USE_NETENT_PTR
#else
#   undef  USE_NETENT_PTR
#endif

/* The getprotoent getprotobyname getprotobynumber using ptr? */

#if defined(HAS_GETPROTOENT_R) && (GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBWR)
#   define GETPROTOENT_R_HAS_PTR
#else
#   undef  GETPROTOENT_R_HAS_PTR
#endif
#if defined(HAS_GETPROTOBYNAME_R) && (GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWR)
#   define GETPROTOBYNAME_R_HAS_PTR
#else
#   undef  GETPROTOBYNAME_R_HAS_PTR
#endif
#if defined(HAS_GETPROTOBYNUMBER_R) && (GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISBWR)
#   define GETPROTOBYNUMBER_R_HAS_PTR
#else
#   undef  GETPROTOBYNUMBER_R_HAS_PTR
#endif

/* Any of the getprotoent getprotobyname getprotobynumber using ptr? */

#if (defined(GETPROTOENT_R_HAS_PTR) || defined(GETPROTOBYNAME_R_HAS_PTR) || defined(GETPROTOBYNUMBER_R_HAS_PTR))
#   define USE_PROTOENT_PTR
#else
#   undef  USE_PROTOENT_PTR
#endif

/* The getservent getservbyname getservbyport using ptr? */

#if defined(HAS_GETSERVENT_R) && (GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBWR)
#   define GETSERVENT_R_HAS_PTR
#else
#   undef  GETSERVENT_R_HAS_PTR
#endif
#if defined(HAS_GETSERVBYNAME_R) && (GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSBWR)
#   define GETSERVBYNAME_R_HAS_PTR
#else
#   undef  GETSERVBYNAME_R_HAS_PTR
#endif
#if defined(HAS_GETSERVBYPORT_R) && (GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSBWR)
#   define GETSERVBYPORT_R_HAS_PTR
#else
#   undef  GETSERVBYPORT_R_HAS_PTR
#endif

/* Any of the getservent getservbyname getservbyport using ptr? */

#if (defined(GETSERVENT_R_HAS_PTR) || defined(GETSERVBYNAME_R_HAS_PTR) || defined(GETSERVBYPORT_R_HAS_PTR))
#   define USE_SERVENT_PTR
#else
#   undef  USE_SERVENT_PTR
#endif

/* The gethostent gethostbyaddr gethostbyname using buffer? */

#if defined(HAS_GETHOSTENT_R) && (GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBIE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBI)
#   define GETHOSTENT_R_HAS_BUFFER
#else
#   undef  GETHOSTENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETHOSTBYADDR_R) && (GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBWIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CIISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE)
#   define GETHOSTBYADDR_R_HAS_BUFFER
#else
#   undef  GETHOSTBYADDR_R_HAS_BUFFER
#endif
#if defined(HAS_GETHOSTBYNAME_R) && (GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE || GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBIE)
#   define GETHOSTBYNAME_R_HAS_BUFFER
#else
#   undef  GETHOSTBYNAME_R_HAS_BUFFER
#endif

/* Any of the gethostent gethostbyaddr gethostbyname using buffer? */

#if (defined(GETHOSTENT_R_HAS_BUFFER) || defined(GETHOSTBYADDR_R_HAS_BUFFER) || defined(GETHOSTBYNAME_R_HAS_BUFFER))
#   define USE_HOSTENT_BUFFER
#else
#   undef  USE_HOSTENT_BUFFER
#endif

/* The getnetent getnetbyaddr getnetbyname using buffer? */

#if defined(HAS_GETNETENT_R) && (GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBIE || GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBI || GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBI)
#   define GETNETENT_R_HAS_BUFFER
#else
#   undef  GETNETENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETNETBYADDR_R) && (GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_LISBI || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_TISBI || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_LISBI || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE)
#   define GETNETBYADDR_R_HAS_BUFFER
#else
#   undef  GETNETBYADDR_R_HAS_BUFFER
#endif
#if defined(HAS_GETNETBYNAME_R) && (GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE || GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBI || GETNETBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI)
#   define GETNETBYNAME_R_HAS_BUFFER
#else
#   undef  GETNETBYNAME_R_HAS_BUFFER
#endif

/* Any of the getnetent getnetbyaddr getnetbyname using buffer? */

#if (defined(GETNETENT_R_HAS_BUFFER) || defined(GETNETBYADDR_R_HAS_BUFFER) || defined(GETNETBYNAME_R_HAS_BUFFER))
#   define USE_NETENT_BUFFER
#else
#   undef  USE_NETENT_BUFFER
#endif

/* The getprotoent getprotobyname getprotobynumber using buffer? */

#if defined(HAS_GETPROTOENT_R) && (GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETPROTOENT_R_PROTO == REENTRANT_PROTO_S_SBI)
#   define GETPROTOENT_R_HAS_BUFFER
#else
#   undef  GETPROTOENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETPROTOBYNAME_R) && (GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWR || GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI)
#   define GETPROTOBYNAME_R_HAS_BUFFER
#else
#   undef  GETPROTOBYNAME_R_HAS_BUFFER
#endif
#if defined(HAS_GETPROTOBYNUMBER_R) && (GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISBWR || GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_S_ISBI)
#   define GETPROTOBYNUMBER_R_HAS_BUFFER
#else
#   undef  GETPROTOBYNUMBER_R_HAS_BUFFER
#endif

/* Any of the getprotoent getprotobyname getprotobynumber using buffer? */

#if (defined(GETPROTOENT_R_HAS_BUFFER) || defined(GETPROTOBYNAME_R_HAS_BUFFER) || defined(GETPROTOBYNUMBER_R_HAS_BUFFER))
#   define USE_PROTOENT_BUFFER
#else
#   undef  USE_PROTOENT_BUFFER
#endif

/* The getservent getservbyname getservbyport using buffer? */

#if defined(HAS_GETSERVENT_R) && (GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBWR || GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBI || GETSERVENT_R_PROTO == REENTRANT_PROTO_S_SBI)
#   define GETSERVENT_R_HAS_BUFFER
#else
#   undef  GETSERVENT_R_HAS_BUFFER
#endif
#if defined(HAS_GETSERVBYNAME_R) && (GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSBWR || GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_S_CCSBI)
#   define GETSERVBYNAME_R_HAS_BUFFER
#else
#   undef  GETSERVBYNAME_R_HAS_BUFFER
#endif
#if defined(HAS_GETSERVBYPORT_R) && (GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSBWR || GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_S_ICSBI)
#   define GETSERVBYPORT_R_HAS_BUFFER
#else
#   undef  GETSERVBYPORT_R_HAS_BUFFER
#endif

/* Any of the getservent getservbyname getservbyport using buffer? */

#if (defined(GETSERVENT_R_HAS_BUFFER) || defined(GETSERVBYNAME_R_HAS_BUFFER) || defined(GETSERVBYPORT_R_HAS_BUFFER))
#   define USE_SERVENT_BUFFER
#else
#   undef  USE_SERVENT_BUFFER
#endif

/* The gethostent gethostbyaddr gethostbyname using errno? */

#if defined(HAS_GETHOSTENT_R) && (GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBIE)
#   define GETHOSTENT_R_HAS_ERRNO
#else
#   undef  GETHOSTENT_R_HAS_ERRNO
#endif
#if defined(HAS_GETHOSTBYADDR_R) && (GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBWIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TWISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CIISBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TSBIE || GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE)
#   define GETHOSTBYADDR_R_HAS_ERRNO
#else
#   undef  GETHOSTBYADDR_R_HAS_ERRNO
#endif
#if defined(HAS_GETHOSTBYNAME_R) && (GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE || GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBIE)
#   define GETHOSTBYNAME_R_HAS_ERRNO
#else
#   undef  GETHOSTBYNAME_R_HAS_ERRNO
#endif

/* Any of the gethostent gethostbyaddr gethostbyname using errno? */

#if (defined(GETHOSTENT_R_HAS_ERRNO) || defined(GETHOSTBYADDR_R_HAS_ERRNO) || defined(GETHOSTBYNAME_R_HAS_ERRNO))
#   define USE_HOSTENT_ERRNO
#else
#   undef  USE_HOSTENT_ERRNO
#endif

/* The getnetent getnetbyaddr getnetbyname using errno? */

#if defined(HAS_GETNETENT_R) && (GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE || GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBIE || GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBIE)
#   define GETNETENT_R_HAS_ERRNO
#else
#   undef  GETNETENT_R_HAS_ERRNO
#endif
#if defined(HAS_GETNETBYADDR_R) && (GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE || GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE)
#   define GETNETBYADDR_R_HAS_ERRNO
#else
#   undef  GETNETBYADDR_R_HAS_ERRNO
#endif
#if defined(HAS_GETNETBYNAME_R) && (GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE)
#   define GETNETBYNAME_R_HAS_ERRNO
#else
#   undef  GETNETBYNAME_R_HAS_ERRNO
#endif

/* Any of the getnetent getnetbyaddr getnetbyname using errno? */

#if (defined(GETNETENT_R_HAS_ERRNO) || defined(GETNETBYADDR_R_HAS_ERRNO) || defined(GETNETBYNAME_R_HAS_ERRNO))
#   define USE_NETENT_ERRNO
#else
#   undef  USE_NETENT_ERRNO
#endif


typedef struct {
#ifdef HAS_ASCTIME_R
	char*	_asctime_buffer;
	size_t	_asctime_size;
#endif /* HAS_ASCTIME_R */
#ifdef HAS_CRYPT_R
#if CRYPT_R_PROTO == REENTRANT_PROTO_B_CCD
	CRYPTD* _crypt_data;
#else
	struct crypt_data *_crypt_struct_buffer;
#endif
#endif /* HAS_CRYPT_R */
#ifdef HAS_CTIME_R
	char*	_ctime_buffer;
	size_t	_ctime_size;
#endif /* HAS_CTIME_R */
#ifdef HAS_DRAND48_R
	struct drand48_data _drand48_struct;
	double	_drand48_double;
#endif /* HAS_DRAND48_R */
#ifdef HAS_GETGRNAM_R
	struct group	_grent_struct;
	char*	_grent_buffer;
	size_t	_grent_size;
#   ifdef USE_GRENT_PTR
	struct group*	_grent_ptr;
#   endif
#   ifdef USE_GRENT_FPTR
	FILE*	_grent_fptr;
#   endif
#endif /* HAS_GETGRNAM_R */
#ifdef HAS_GETHOSTBYNAME_R
	struct hostent	_hostent_struct;
#   if GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
	struct hostent_data	_hostent_data;
#   else
	char*	_hostent_buffer;
	size_t	_hostent_size;
#   endif
#   ifdef USE_HOSTENT_PTR
	struct hostent*	_hostent_ptr;
#   endif
#   ifdef USE_HOSTENT_ERRNO
	int	_hostent_errno;
#   endif 
#endif /* HAS_GETHOSTBYNAME_R */
#ifdef HAS_GETLOGIN_R
	char*	_getlogin_buffer;
	size_t	_getlogin_size;
#endif /* HAS_GETLOGIN_R */
#ifdef HAS_GETNETBYNAME_R
	struct netent	_netent_struct;
#   if GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
	struct netent_data	_netent_data;
#   else
	char*	_netent_buffer;
	size_t	_netent_size;
#   endif
#   ifdef USE_NETENT_PTR
	struct netent*	_netent_ptr;
#   endif
#   ifdef USE_NETENT_ERRNO
	int	_netent_errno;
#   endif 
#endif /* HAS_GETNETBYNAME_R */
#ifdef HAS_GETPROTOBYNAME_R
	struct protoent	_protoent_struct;
#   if GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
	struct protoent_data	_protoent_data;
#   else
	char*	_protoent_buffer;
	size_t	_protoent_size;
#   endif
#   ifdef USE_PROTOENT_PTR
	struct protoent*	_protoent_ptr;
#   endif
#   ifdef USE_PROTOENT_ERRNO
	int	_protoent_errno;
#   endif 
#endif /* HAS_GETPROTOBYNAME_R */
#ifdef HAS_GETPWNAM_R
	struct passwd	_pwent_struct;
	char*	_pwent_buffer;
	size_t	_pwent_size;
#   ifdef USE_PWENT_PTR
	struct passwd*	_pwent_ptr;
#   endif
#   ifdef USE_PWENT_FPTR
	FILE*	_pwent_fptr;
#   endif
#endif /* HAS_GETPWNAM_R */
#ifdef HAS_GETSERVBYNAME_R
	struct servent	_servent_struct;
#   if GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD
	struct servent_data	_servent_data;
#   else
	char*	_servent_buffer;
	size_t	_servent_size;
#   endif
#   ifdef USE_SERVENT_PTR
	struct servent*	_servent_ptr;
#   endif
#   ifdef USE_SERVENT_ERRNO
	int	_servent_errno;
#   endif 
#endif /* HAS_GETSERVBYNAME_R */
#ifdef HAS_GETSPNAM_R
	struct spwd	_spent_struct;
	char*	_spent_buffer;
	size_t	_spent_size;
#   ifdef USE_SPENT_PTR
	struct spwd*	_spent_ptr;
#   endif
#   ifdef USE_SPENT_FPTR
	FILE*	_spent_fptr;
#   endif
#endif /* HAS_GETSPNAM_R */
#ifdef HAS_GMTIME_R
	struct tm _gmtime_struct;
#endif /* HAS_GMTIME_R */
#ifdef HAS_LOCALTIME_R
	struct tm _localtime_struct;
#endif /* HAS_LOCALTIME_R */
#ifdef HAS_RANDOM_R
	struct random_data _random_struct;
#   if RANDOM_R_PROTO == REENTRANT_PROTO_I_iS
	int	_random_retval;
#   endif
#   if RANDOM_R_PROTO == REENTRANT_PROTO_I_lS
	long	_random_retval;
#   endif
#   if RANDOM_R_PROTO == REENTRANT_PROTO_I_St
	int32_t	_random_retval;
#   endif
#endif /* HAS_RANDOM_R */
#ifdef HAS_READDIR_R
	struct dirent*	_readdir_struct;
	size_t	_readdir_size;
#   if READDIR_R_PROTO == REENTRANT_PROTO_I_TSR
	struct dirent*	_readdir_ptr;
#   endif
#endif /* HAS_READDIR_R */
#ifdef HAS_READDIR64_R
	struct dirent64*	_readdir64_struct;
	size_t	_readdir64_size;
#   if READDIR64_R_PROTO == REENTRANT_PROTO_I_TSR
	struct dirent64*	_readdir64_ptr;
#   endif
#endif /* HAS_READDIR64_R */
#ifdef HAS_SETLOCALE_R
	char*	_setlocale_buffer;
	size_t	_setlocale_size;
#endif /* HAS_SETLOCALE_R */
#ifdef HAS_SRANDOM_R
	struct random_data _srandom_struct;
#endif /* HAS_SRANDOM_R */
#ifdef HAS_STRERROR_R
	char*	_strerror_buffer;
	size_t	_strerror_size;
#endif /* HAS_STRERROR_R */
#ifdef HAS_TTYNAME_R
	char*	_ttyname_buffer;
	size_t	_ttyname_size;
#endif /* HAS_TTYNAME_R */

    int dummy; /* cannot have empty structs */
} REENTR;

/* The wrappers. */

#ifdef HAS_ASCTIME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef asctime
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_B_SB
#       define asctime(a) asctime_r(a, PL_reentrant_buffer->_asctime_buffer)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_B_SBI
#       define asctime(a) asctime_r(a, PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_I_SB
#       define asctime(a) (asctime_r(a, PL_reentrant_buffer->_asctime_buffer) == 0 ? PL_reentrant_buffer->_asctime_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(asctime) && ASCTIME_R_PROTO == REENTRANT_PROTO_I_SBI
#       define asctime(a) (asctime_r(a, PL_reentrant_buffer->_asctime_buffer, PL_reentrant_buffer->_asctime_size) == 0 ? PL_reentrant_buffer->_asctime_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ASCTIME */
#endif /* HAS_ASCTIME_R */

#ifdef HAS_CRYPT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef crypt
#   if !defined(crypt) && CRYPT_R_PROTO == REENTRANT_PROTO_B_CCS
#       define crypt(a, b) crypt_r(a, b, PL_reentrant_buffer->_crypt_struct_buffer)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(crypt) && CRYPT_R_PROTO == REENTRANT_PROTO_B_CCD
#       define crypt(a, b) crypt_r(a, b, &PL_reentrant_buffer->_crypt_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_CRYPT */
#endif /* HAS_CRYPT_R */

#ifdef HAS_CTERMID_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef ctermid
#   if !defined(ctermid) && CTERMID_R_PROTO == REENTRANT_PROTO_B_B
#       define ctermid(a) ctermid_r(a)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_CTERMID */
#endif /* HAS_CTERMID_R */

#ifdef HAS_CTIME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef ctime
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_B_SB
#       define ctime(a) ctime_r(a, PL_reentrant_buffer->_ctime_buffer)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_B_SBI
#       define ctime(a) ctime_r(a, PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_I_SB
#       define ctime(a) (ctime_r(a, PL_reentrant_buffer->_ctime_buffer) == 0 ? PL_reentrant_buffer->_ctime_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(ctime) && CTIME_R_PROTO == REENTRANT_PROTO_I_SBI
#       define ctime(a) (ctime_r(a, PL_reentrant_buffer->_ctime_buffer, PL_reentrant_buffer->_ctime_size) == 0 ? PL_reentrant_buffer->_ctime_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_CTIME */
#endif /* HAS_CTIME_R */

#ifdef HAS_DRAND48_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef drand48
#   if !defined(drand48) && DRAND48_R_PROTO == REENTRANT_PROTO_I_ST
#       define drand48() (drand48_r(&PL_reentrant_buffer->_drand48_struct, &PL_reentrant_buffer->_drand48_double) == 0 ? PL_reentrant_buffer->_drand48_double : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_DRAND48 */
#endif /* HAS_DRAND48_R */

#ifdef HAS_ENDGRENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endgrent
#   if !defined(endgrent) && ENDGRENT_R_PROTO == REENTRANT_PROTO_I_H
#       define endgrent() (endgrent_r(&PL_reentrant_buffer->_grent_fptr) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(endgrent) && ENDGRENT_R_PROTO == REENTRANT_PROTO_V_H
#       define endgrent() endgrent_r(&PL_reentrant_buffer->_grent_fptr)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ENDGRENT */
#endif /* HAS_ENDGRENT_R */

#ifdef HAS_ENDHOSTENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endhostent
#   if !defined(endhostent) && ENDHOSTENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endhostent() (endhostent_r(&PL_reentrant_buffer->_hostent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(endhostent) && ENDHOSTENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endhostent() endhostent_r(&PL_reentrant_buffer->_hostent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ENDHOSTENT */
#endif /* HAS_ENDHOSTENT_R */

#ifdef HAS_ENDNETENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endnetent
#   if !defined(endnetent) && ENDNETENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endnetent() (endnetent_r(&PL_reentrant_buffer->_netent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(endnetent) && ENDNETENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endnetent() endnetent_r(&PL_reentrant_buffer->_netent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ENDNETENT */
#endif /* HAS_ENDNETENT_R */

#ifdef HAS_ENDPROTOENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endprotoent
#   if !defined(endprotoent) && ENDPROTOENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endprotoent() (endprotoent_r(&PL_reentrant_buffer->_protoent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(endprotoent) && ENDPROTOENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endprotoent() endprotoent_r(&PL_reentrant_buffer->_protoent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ENDPROTOENT */
#endif /* HAS_ENDPROTOENT_R */

#ifdef HAS_ENDPWENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endpwent
#   if !defined(endpwent) && ENDPWENT_R_PROTO == REENTRANT_PROTO_I_H
#       define endpwent() (endpwent_r(&PL_reentrant_buffer->_pwent_fptr) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(endpwent) && ENDPWENT_R_PROTO == REENTRANT_PROTO_V_H
#       define endpwent() endpwent_r(&PL_reentrant_buffer->_pwent_fptr)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ENDPWENT */
#endif /* HAS_ENDPWENT_R */

#ifdef HAS_ENDSERVENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef endservent
#   if !defined(endservent) && ENDSERVENT_R_PROTO == REENTRANT_PROTO_I_D
#       define endservent() (endservent_r(&PL_reentrant_buffer->_servent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(endservent) && ENDSERVENT_R_PROTO == REENTRANT_PROTO_V_D
#       define endservent() endservent_r(&PL_reentrant_buffer->_servent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_ENDSERVENT */
#endif /* HAS_ENDSERVENT_R */

#ifdef HAS_GETGRENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getgrent
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIR
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBW
#       define getgrent() (getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getgrent() (getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrent) && GETGRENT_R_PROTO == REENTRANT_PROTO_I_SBIH
#       define getgrent() ((PL_reentrant_retint = getgrent_r(&PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_fptr)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETGRENT */
#endif /* HAS_GETGRENT_R */

#ifdef HAS_GETGRGID_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getgrgid
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBWR
#       define getgrgid(a) ((PL_reentrant_retint = getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBIR
#       define getgrgid(a) ((PL_reentrant_retint = getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_I_TSBI
#       define getgrgid(a) ((PL_reentrant_retint = getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrgid) && GETGRGID_R_PROTO == REENTRANT_PROTO_S_TSBI
#       define getgrgid(a) (getgrgid_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrgid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETGRGID */
#endif /* HAS_GETGRGID_R */

#ifdef HAS_GETGRNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getgrnam
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getgrnam(a) ((PL_reentrant_retint = getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR
#       define getgrnam(a) ((PL_reentrant_retint = getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size, &PL_reentrant_buffer->_grent_ptr)) == 0 ? PL_reentrant_buffer->_grent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CBI
#       define getgrnam(a) (getgrnam_r(a, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? PL_reentrant_buffer->_grent_buffer : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_I_CSBI
#       define getgrnam(a) ((PL_reentrant_retint = getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size)) == 0 ? &PL_reentrant_buffer->_grent_struct : ((PL_reentrant_retint == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getgrnam) && GETGRNAM_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getgrnam(a) (getgrnam_r(a, &PL_reentrant_buffer->_grent_struct, PL_reentrant_buffer->_grent_buffer, PL_reentrant_buffer->_grent_size) ? &PL_reentrant_buffer->_grent_struct : ((errno == ERANGE) ? (struct group *) Perl_reentrant_retry("getgrnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETGRNAM */
#endif /* HAS_GETGRNAM_R */

#ifdef HAS_GETHOSTBYADDR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gethostbyaddr
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISBWRE
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBWIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CWISBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TWISBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CIISBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_CSBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? 1 : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_S_TSBIE
#       define gethostbyaddr(a, b, c) (gethostbyaddr_r(a, b, c, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? 1 : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CWISD
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CIISD
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_CII
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c)) == 0 ? 1 : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyaddr) && GETHOSTBYADDR_R_PROTO == REENTRANT_PROTO_I_TsISBWRE
#       define gethostbyaddr(a, b, c) ((PL_reentrant_retint = gethostbyaddr_r(a, b, c, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyaddr", a, b, c) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETHOSTBYADDR */
#endif /* HAS_GETHOSTBYADDR_R */

#ifdef HAS_GETHOSTBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gethostbyname
#   if !defined(gethostbyname) && GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE
#       define gethostbyname(a) ((PL_reentrant_retint = gethostbyname_r(a, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyname) && GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBIE
#       define gethostbyname(a) (gethostbyname_r(a, &PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostbyname) && GETHOSTBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
#       define gethostbyname(a) ((PL_reentrant_retint = gethostbyname_r(a, &PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETHOSTBYNAME */
#endif /* HAS_GETHOSTBYNAME_R */

#ifdef HAS_GETHOSTENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gethostent
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBWRE
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_ptr, &PL_reentrant_buffer->_hostent_errno)) == 0 ? PL_reentrant_buffer->_hostent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBIE
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBIE
#       define gethostent() (gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size, &PL_reentrant_buffer->_hostent_errno) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define gethostent() (gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size) ? &PL_reentrant_buffer->_hostent_struct : ((errno == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, PL_reentrant_buffer->_hostent_buffer, PL_reentrant_buffer->_hostent_size)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gethostent) && GETHOSTENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define gethostent() ((PL_reentrant_retint = gethostent_r(&PL_reentrant_buffer->_hostent_struct, &PL_reentrant_buffer->_hostent_data)) == 0 ? &PL_reentrant_buffer->_hostent_struct : ((PL_reentrant_retint == ERANGE) ? (struct hostent *) Perl_reentrant_retry("gethostent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETHOSTENT */
#endif /* HAS_GETHOSTENT_R */

#ifdef HAS_GETLOGIN_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getlogin
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_I_BW
#       define getlogin() ((PL_reentrant_retint = getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)) == 0 ? PL_reentrant_buffer->_getlogin_buffer : ((PL_reentrant_retint == ERANGE) ? (char *) Perl_reentrant_retry("getlogin") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_I_BI
#       define getlogin() ((PL_reentrant_retint = getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)) == 0 ? PL_reentrant_buffer->_getlogin_buffer : ((PL_reentrant_retint == ERANGE) ? (char *) Perl_reentrant_retry("getlogin") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_B_BW
#       define getlogin() getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getlogin) && GETLOGIN_R_PROTO == REENTRANT_PROTO_B_BI
#       define getlogin() getlogin_r(PL_reentrant_buffer->_getlogin_buffer, PL_reentrant_buffer->_getlogin_size)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETLOGIN */
#endif /* HAS_GETLOGIN_R */

#ifdef HAS_GETNETBYADDR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getnetbyaddr
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_UISBWRE
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_LISBI
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_TISBI
#       define getnetbyaddr(a, b) (getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_S_LISBI
#       define getnetbyaddr(a, b) (getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_TISD
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_LISD
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_IISD
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyaddr) && GETNETBYADDR_R_PROTO == REENTRANT_PROTO_I_uISBWRE
#       define getnetbyaddr(a, b) ((PL_reentrant_retint = getnetbyaddr_r(a, b, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyaddr", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETNETBYADDR */
#endif /* HAS_GETNETBYADDR_R */

#ifdef HAS_GETNETBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getnetbyname
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWRE
#       define getnetbyname(a) ((PL_reentrant_retint = getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBI
#       define getnetbyname(a) ((PL_reentrant_retint = getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getnetbyname(a) (getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetbyname) && GETNETBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
#       define getnetbyname(a) ((PL_reentrant_retint = getnetbyname_r(a, &PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetbyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETNETBYNAME */
#endif /* HAS_GETNETBYNAME_R */

#ifdef HAS_GETNETENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getnetent
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBWRE
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_ptr, &PL_reentrant_buffer->_netent_errno)) == 0 ? PL_reentrant_buffer->_netent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBIE
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_errno)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBIE
#       define getnetent() (getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size, &PL_reentrant_buffer->_netent_errno) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getnetent() (getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size) ? &PL_reentrant_buffer->_netent_struct : ((errno == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, PL_reentrant_buffer->_netent_buffer, PL_reentrant_buffer->_netent_size)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getnetent) && GETNETENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define getnetent() ((PL_reentrant_retint = getnetent_r(&PL_reentrant_buffer->_netent_struct, &PL_reentrant_buffer->_netent_data)) == 0 ? &PL_reentrant_buffer->_netent_struct : ((PL_reentrant_retint == ERANGE) ? (struct netent *) Perl_reentrant_retry("getnetent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETNETENT */
#endif /* HAS_GETNETENT_R */

#ifdef HAS_GETPROTOBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getprotobyname
#   if !defined(getprotobyname) && GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getprotobyname(a) ((PL_reentrant_retint = getprotobyname_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, &PL_reentrant_buffer->_protoent_ptr)) == 0 ? PL_reentrant_buffer->_protoent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotobyname) && GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getprotobyname(a) (getprotobyname_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size) ? &PL_reentrant_buffer->_protoent_struct : ((errno == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotobyname) && GETPROTOBYNAME_R_PROTO == REENTRANT_PROTO_I_CSD
#       define getprotobyname(a) (REENTR_MEMZERO(&PL_reentrant_buffer->_protoent_data, sizeof(PL_reentrant_buffer->_protoent_data)),(PL_reentrant_retint = getprotobyname_r(a, &PL_reentrant_buffer->_protoent_struct, &PL_reentrant_buffer->_protoent_data)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobyname", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETPROTOBYNAME */
#endif /* HAS_GETPROTOBYNAME_R */

#ifdef HAS_GETPROTOBYNUMBER_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getprotobynumber
#   if !defined(getprotobynumber) && GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISBWR
#       define getprotobynumber(a) ((PL_reentrant_retint = getprotobynumber_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, &PL_reentrant_buffer->_protoent_ptr)) == 0 ? PL_reentrant_buffer->_protoent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobynumber", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotobynumber) && GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_S_ISBI
#       define getprotobynumber(a) (getprotobynumber_r(a, &PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size) ? &PL_reentrant_buffer->_protoent_struct : ((errno == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobynumber", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotobynumber) && GETPROTOBYNUMBER_R_PROTO == REENTRANT_PROTO_I_ISD
#       define getprotobynumber(a) (REENTR_MEMZERO(&PL_reentrant_buffer->_protoent_data, sizeof(PL_reentrant_buffer->_protoent_data)),(PL_reentrant_retint = getprotobynumber_r(a, &PL_reentrant_buffer->_protoent_struct, &PL_reentrant_buffer->_protoent_data)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotobynumber", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETPROTOBYNUMBER */
#endif /* HAS_GETPROTOBYNUMBER_R */

#ifdef HAS_GETPROTOENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getprotoent
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getprotoent() ((PL_reentrant_retint = getprotoent_r(&PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size, &PL_reentrant_buffer->_protoent_ptr)) == 0 ? PL_reentrant_buffer->_protoent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getprotoent() ((PL_reentrant_retint = getprotoent_r(&PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getprotoent() (getprotoent_r(&PL_reentrant_buffer->_protoent_struct, PL_reentrant_buffer->_protoent_buffer, PL_reentrant_buffer->_protoent_size) ? &PL_reentrant_buffer->_protoent_struct : ((errno == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getprotoent) && GETPROTOENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define getprotoent() (REENTR_MEMZERO(&PL_reentrant_buffer->_protoent_data, sizeof(PL_reentrant_buffer->_protoent_data)),(PL_reentrant_retint = getprotoent_r(&PL_reentrant_buffer->_protoent_struct, &PL_reentrant_buffer->_protoent_data)) == 0 ? &PL_reentrant_buffer->_protoent_struct : ((PL_reentrant_retint == ERANGE) ? (struct protoent *) Perl_reentrant_retry("getprotoent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETPROTOENT */
#endif /* HAS_GETPROTOENT_R */

#ifdef HAS_GETPWENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getpwent
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIR
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBW
#       define getpwent() (getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getpwent() (getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwent) && GETPWENT_R_PROTO == REENTRANT_PROTO_I_SBIH
#       define getpwent() ((PL_reentrant_retint = getpwent_r(&PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_fptr)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETPWENT */
#endif /* HAS_GETPWENT_R */

#ifdef HAS_GETPWNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getpwnam
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getpwnam(a) ((PL_reentrant_retint = getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBIR
#       define getpwnam(a) ((PL_reentrant_retint = getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getpwnam(a) (getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwnam) && GETPWNAM_R_PROTO == REENTRANT_PROTO_I_CSBI
#       define getpwnam(a) ((PL_reentrant_retint = getpwnam_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETPWNAM */
#endif /* HAS_GETPWNAM_R */

#ifdef HAS_GETPWUID_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getpwuid
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBWR
#       define getpwuid(a) ((PL_reentrant_retint = getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBIR
#       define getpwuid(a) ((PL_reentrant_retint = getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size, &PL_reentrant_buffer->_pwent_ptr)) == 0 ? PL_reentrant_buffer->_pwent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_I_TSBI
#       define getpwuid(a) ((PL_reentrant_retint = getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size)) == 0 ? &PL_reentrant_buffer->_pwent_struct : ((PL_reentrant_retint == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getpwuid) && GETPWUID_R_PROTO == REENTRANT_PROTO_S_TSBI
#       define getpwuid(a) (getpwuid_r(a, &PL_reentrant_buffer->_pwent_struct, PL_reentrant_buffer->_pwent_buffer, PL_reentrant_buffer->_pwent_size) ? &PL_reentrant_buffer->_pwent_struct : ((errno == ERANGE) ? (struct passwd *) Perl_reentrant_retry("getpwuid", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETPWUID */
#endif /* HAS_GETPWUID_R */

#ifdef HAS_GETSERVBYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getservbyname
#   if !defined(getservbyname) && GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSBWR
#       define getservbyname(a, b) ((PL_reentrant_retint = getservbyname_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, &PL_reentrant_buffer->_servent_ptr)) == 0 ? PL_reentrant_buffer->_servent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyname", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservbyname) && GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_S_CCSBI
#       define getservbyname(a, b) (getservbyname_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size) ? &PL_reentrant_buffer->_servent_struct : ((errno == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyname", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservbyname) && GETSERVBYNAME_R_PROTO == REENTRANT_PROTO_I_CCSD
#       define getservbyname(a, b) (REENTR_MEMZERO(&PL_reentrant_buffer->_servent_data, sizeof(PL_reentrant_buffer->_servent_data)),(PL_reentrant_retint = getservbyname_r(a, b, &PL_reentrant_buffer->_servent_struct, &PL_reentrant_buffer->_servent_data)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyname", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETSERVBYNAME */
#endif /* HAS_GETSERVBYNAME_R */

#ifdef HAS_GETSERVBYPORT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getservbyport
#   if !defined(getservbyport) && GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSBWR
#       define getservbyport(a, b) ((PL_reentrant_retint = getservbyport_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, &PL_reentrant_buffer->_servent_ptr)) == 0 ? PL_reentrant_buffer->_servent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyport", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservbyport) && GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_S_ICSBI
#       define getservbyport(a, b) (getservbyport_r(a, b, &PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size) ? &PL_reentrant_buffer->_servent_struct : ((errno == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyport", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservbyport) && GETSERVBYPORT_R_PROTO == REENTRANT_PROTO_I_ICSD
#       define getservbyport(a, b) (REENTR_MEMZERO(&PL_reentrant_buffer->_servent_data, sizeof(PL_reentrant_buffer->_servent_data)),(PL_reentrant_retint = getservbyport_r(a, b, &PL_reentrant_buffer->_servent_struct, &PL_reentrant_buffer->_servent_data)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservbyport", a, b) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETSERVBYPORT */
#endif /* HAS_GETSERVBYPORT_R */

#ifdef HAS_GETSERVENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getservent
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBWR
#       define getservent() ((PL_reentrant_retint = getservent_r(&PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size, &PL_reentrant_buffer->_servent_ptr)) == 0 ? PL_reentrant_buffer->_servent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SBI
#       define getservent() ((PL_reentrant_retint = getservent_r(&PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_S_SBI
#       define getservent() (getservent_r(&PL_reentrant_buffer->_servent_struct, PL_reentrant_buffer->_servent_buffer, PL_reentrant_buffer->_servent_size) ? &PL_reentrant_buffer->_servent_struct : ((errno == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getservent) && GETSERVENT_R_PROTO == REENTRANT_PROTO_I_SD
#       define getservent() (REENTR_MEMZERO(&PL_reentrant_buffer->_servent_data, sizeof(PL_reentrant_buffer->_servent_data)),(PL_reentrant_retint = getservent_r(&PL_reentrant_buffer->_servent_struct, &PL_reentrant_buffer->_servent_data)) == 0 ? &PL_reentrant_buffer->_servent_struct : ((PL_reentrant_retint == ERANGE) ? (struct servent *) Perl_reentrant_retry("getservent") : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETSERVENT */
#endif /* HAS_GETSERVENT_R */

#ifdef HAS_GETSPNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef getspnam
#   if !defined(getspnam) && GETSPNAM_R_PROTO == REENTRANT_PROTO_I_CSBWR
#       define getspnam(a) ((PL_reentrant_retint = getspnam_r(a, &PL_reentrant_buffer->_spent_struct, PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size, &PL_reentrant_buffer->_spent_ptr)) == 0 ? PL_reentrant_buffer->_spent_ptr : ((PL_reentrant_retint == ERANGE) ? (struct spwd *) Perl_reentrant_retry("getspnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(getspnam) && GETSPNAM_R_PROTO == REENTRANT_PROTO_S_CSBI
#       define getspnam(a) (getspnam_r(a, &PL_reentrant_buffer->_spent_struct, PL_reentrant_buffer->_spent_buffer, PL_reentrant_buffer->_spent_size) ? &PL_reentrant_buffer->_spent_struct : ((errno == ERANGE) ? (struct spwd *) Perl_reentrant_retry("getspnam", a) : 0))
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GETSPNAM */
#endif /* HAS_GETSPNAM_R */

#ifdef HAS_GMTIME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef gmtime
#   if !defined(gmtime) && GMTIME_R_PROTO == REENTRANT_PROTO_S_TS
#       define gmtime(a) (gmtime_r(a, &PL_reentrant_buffer->_gmtime_struct) ? &PL_reentrant_buffer->_gmtime_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(gmtime) && GMTIME_R_PROTO == REENTRANT_PROTO_I_TS
#       define gmtime(a) (gmtime_r(a, &PL_reentrant_buffer->_gmtime_struct) == 0 ? &PL_reentrant_buffer->_gmtime_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_GMTIME */
#endif /* HAS_GMTIME_R */

#ifdef HAS_LOCALTIME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef localtime
#   if !defined(localtime) && LOCALTIME_R_PROTO == REENTRANT_PROTO_S_TS
#       define localtime(a) (L_R_TZSET localtime_r(a, &PL_reentrant_buffer->_localtime_struct) ? &PL_reentrant_buffer->_localtime_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(localtime) && LOCALTIME_R_PROTO == REENTRANT_PROTO_I_TS
#       define localtime(a) (L_R_TZSET localtime_r(a, &PL_reentrant_buffer->_localtime_struct) == 0 ? &PL_reentrant_buffer->_localtime_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_LOCALTIME */
#endif /* HAS_LOCALTIME_R */

#ifdef HAS_RANDOM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef random
#   if !defined(random) && RANDOM_R_PROTO == REENTRANT_PROTO_I_iS
#       define random() (random_r(&PL_reentrant_buffer->_random_retval, &PL_reentrant_buffer->_random_struct) == 0 ? PL_reentrant_buffer->_random_retval : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(random) && RANDOM_R_PROTO == REENTRANT_PROTO_I_lS
#       define random() (random_r(&PL_reentrant_buffer->_random_retval, &PL_reentrant_buffer->_random_struct) == 0 ? PL_reentrant_buffer->_random_retval : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(random) && RANDOM_R_PROTO == REENTRANT_PROTO_I_St
#       define random() (random_r(&PL_reentrant_buffer->_random_struct, &PL_reentrant_buffer->_random_retval) == 0 ? PL_reentrant_buffer->_random_retval : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_RANDOM */
#endif /* HAS_RANDOM_R */

#ifdef HAS_READDIR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef readdir
#   if !defined(readdir) && READDIR_R_PROTO == REENTRANT_PROTO_I_TSR
#       define readdir(a) (readdir_r(a, PL_reentrant_buffer->_readdir_struct, &PL_reentrant_buffer->_readdir_ptr) == 0 ? PL_reentrant_buffer->_readdir_ptr : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(readdir) && READDIR_R_PROTO == REENTRANT_PROTO_I_TS
#       define readdir(a) (readdir_r(a, PL_reentrant_buffer->_readdir_struct) == 0 ? PL_reentrant_buffer->_readdir_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_READDIR */
#endif /* HAS_READDIR_R */

#ifdef HAS_READDIR64_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef readdir64
#   if !defined(readdir64) && READDIR64_R_PROTO == REENTRANT_PROTO_I_TSR
#       define readdir64(a) (readdir64_r(a, PL_reentrant_buffer->_readdir64_struct, &PL_reentrant_buffer->_readdir64_ptr) == 0 ? PL_reentrant_buffer->_readdir64_ptr : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(readdir64) && READDIR64_R_PROTO == REENTRANT_PROTO_I_TS
#       define readdir64(a) (readdir64_r(a, PL_reentrant_buffer->_readdir64_struct) == 0 ? PL_reentrant_buffer->_readdir64_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_READDIR64 */
#endif /* HAS_READDIR64_R */

#ifdef HAS_SETGRENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setgrent
#   if !defined(setgrent) && SETGRENT_R_PROTO == REENTRANT_PROTO_I_H
#       define setgrent() (setgrent_r(&PL_reentrant_buffer->_grent_fptr) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(setgrent) && SETGRENT_R_PROTO == REENTRANT_PROTO_V_H
#       define setgrent() setgrent_r(&PL_reentrant_buffer->_grent_fptr)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETGRENT */
#endif /* HAS_SETGRENT_R */

#ifdef HAS_SETHOSTENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef sethostent
#   if !defined(sethostent) && SETHOSTENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define sethostent(a) (sethostent_r(a, &PL_reentrant_buffer->_hostent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(sethostent) && SETHOSTENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define sethostent(a) sethostent_r(a, &PL_reentrant_buffer->_hostent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETHOSTENT */
#endif /* HAS_SETHOSTENT_R */

#ifdef HAS_SETLOCALE_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setlocale
#   if !defined(setlocale) && SETLOCALE_R_PROTO == REENTRANT_PROTO_I_ICBI
#       define setlocale(a, b) (setlocale_r(a, b, PL_reentrant_buffer->_setlocale_buffer, PL_reentrant_buffer->_setlocale_size) == 0 ? PL_reentrant_buffer->_setlocale_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETLOCALE */
#endif /* HAS_SETLOCALE_R */

#ifdef HAS_SETNETENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setnetent
#   if !defined(setnetent) && SETNETENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define setnetent(a) (setnetent_r(a, &PL_reentrant_buffer->_netent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(setnetent) && SETNETENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define setnetent(a) setnetent_r(a, &PL_reentrant_buffer->_netent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETNETENT */
#endif /* HAS_SETNETENT_R */

#ifdef HAS_SETPROTOENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setprotoent
#   if !defined(setprotoent) && SETPROTOENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define setprotoent(a) (setprotoent_r(a, &PL_reentrant_buffer->_protoent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(setprotoent) && SETPROTOENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define setprotoent(a) setprotoent_r(a, &PL_reentrant_buffer->_protoent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETPROTOENT */
#endif /* HAS_SETPROTOENT_R */

#ifdef HAS_SETPWENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setpwent
#   if !defined(setpwent) && SETPWENT_R_PROTO == REENTRANT_PROTO_I_H
#       define setpwent() (setpwent_r(&PL_reentrant_buffer->_pwent_fptr) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(setpwent) && SETPWENT_R_PROTO == REENTRANT_PROTO_V_H
#       define setpwent() setpwent_r(&PL_reentrant_buffer->_pwent_fptr)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETPWENT */
#endif /* HAS_SETPWENT_R */

#ifdef HAS_SETSERVENT_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef setservent
#   if !defined(setservent) && SETSERVENT_R_PROTO == REENTRANT_PROTO_I_ID
#       define setservent(a) (setservent_r(a, &PL_reentrant_buffer->_servent_data) == 0 ? 1 : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(setservent) && SETSERVENT_R_PROTO == REENTRANT_PROTO_V_ID
#       define setservent(a) setservent_r(a, &PL_reentrant_buffer->_servent_data)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SETSERVENT */
#endif /* HAS_SETSERVENT_R */

#ifdef HAS_SRAND48_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef srand48
#   if !defined(srand48) && SRAND48_R_PROTO == REENTRANT_PROTO_I_LS
#       define srand48(a) (srand48_r(a, &PL_reentrant_buffer->_drand48_struct) == 0 ? &PL_reentrant_buffer->_drand48_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SRAND48 */
#endif /* HAS_SRAND48_R */

#ifdef HAS_SRANDOM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef srandom
#   if !defined(srandom) && SRANDOM_R_PROTO == REENTRANT_PROTO_I_TS
#       define srandom(a) (srandom_r(a, &PL_reentrant_buffer->_srandom_struct) == 0 ? &PL_reentrant_buffer->_srandom_struct : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_SRANDOM */
#endif /* HAS_SRANDOM_R */

#ifdef HAS_STRERROR_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef strerror
#   if !defined(strerror) && STRERROR_R_PROTO == REENTRANT_PROTO_I_IBW
#       define strerror(a) (strerror_r(a, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size) == 0 ? PL_reentrant_buffer->_strerror_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(strerror) && STRERROR_R_PROTO == REENTRANT_PROTO_I_IBI
#       define strerror(a) (strerror_r(a, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size) == 0 ? PL_reentrant_buffer->_strerror_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(strerror) && STRERROR_R_PROTO == REENTRANT_PROTO_B_IBW
#       define strerror(a) strerror_r(a, PL_reentrant_buffer->_strerror_buffer, PL_reentrant_buffer->_strerror_size)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_STRERROR */
#endif /* HAS_STRERROR_R */

#ifdef HAS_TMPNAM_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef tmpnam
#   if !defined(tmpnam) && TMPNAM_R_PROTO == REENTRANT_PROTO_B_B
#       define tmpnam(a) tmpnam_r(a)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_TMPNAM */
#endif /* HAS_TMPNAM_R */

#ifdef HAS_TTYNAME_R
#  if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1)
#   undef ttyname
#   if !defined(ttyname) && TTYNAME_R_PROTO == REENTRANT_PROTO_I_IBW
#       define ttyname(a) (ttyname_r(a, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size) == 0 ? PL_reentrant_buffer->_ttyname_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(ttyname) && TTYNAME_R_PROTO == REENTRANT_PROTO_I_IBI
#       define ttyname(a) (ttyname_r(a, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size) == 0 ? PL_reentrant_buffer->_ttyname_buffer : 0)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   if !defined(ttyname) && TTYNAME_R_PROTO == REENTRANT_PROTO_B_IBI
#       define ttyname(a) ttyname_r(a, PL_reentrant_buffer->_ttyname_buffer, PL_reentrant_buffer->_ttyname_size)
#  endif /* if defined(PERL_REENTR_API) && (PERL_REENTR_API+0 == 1) */
#   endif /* HAS_TTYNAME */
#endif /* HAS_TTYNAME_R */



#endif /* USE_REENTRANT_API */
 
#endif

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\regcharclass.h ===
/*  -*- buffer-read-only: t -*-
 *
 *    regcharclass.h
 *
 *    Copyright (C) 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by Porting/regcharclass.pl.
 * 
 * Any changes made here will be lost!
 *
 */

/*
	LNBREAK: Line Break: \R

	"\x0D\x0A"      # CRLF - Network (Windows) line ending
	0x0A            # LF  | LINE FEED
	0x0B            # VT  | VERTICAL TAB
	0x0C            # FF  | FORM FEED
	0x0D            # CR  | CARRIAGE RETURN
	0x85            # NEL | NEXT LINE
	0x2028          # LINE SEPARATOR
	0x2029          # PARAGRAPH SEPARATOR
*/
/*** GENERATED CODE ***/
#define is_LNBREAK(s,is_utf8)                                               \
( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                        \
: ( 0x0D == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                     \
: ( is_utf8 ) ?                                                             \
    ( ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xE2 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
    : 0 )                                                                   \
: ( 0x85 == ((U8*)s)[0] ) )

/*** GENERATED CODE ***/
#define is_LNBREAK_safe(s,e,is_utf8)                                        \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( is_utf8 ) ?                                                         \
	( ( 0xC2 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                             \
	: ( 0xE2 == ((U8*)s)[0] ) ?                                         \
	    ( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
	: 0 )                                                               \
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( is_utf8 ) ?                                                         \
	( ( ( 0xC2 == ((U8*)s)[0] ) && ( 0x85 == ((U8*)s)[1] ) ) ? 2 : 0 )  \
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( !( is_utf8 ) ) ?                                                    \
	( 0x85 == ((U8*)s)[0] )                                             \
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_utf8(s)                                                  \
( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                        \
: ( 0x0D == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                     \
: ( 0xC2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_utf8_safe(s,e)                                           \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xE2 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D )                          \
: 0 )

/*** GENERATED CODE ***/
#define is_LNBREAK_latin1(s)                                                \
( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                        \
: ( 0x0D == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                     \
: ( 0x85 == ((U8*)s)[0] ) )

/*** GENERATED CODE ***/
#define is_LNBREAK_latin1_safe(s,e)                                         \
( ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0C ) ? 1                    \
    : ( 0x0D == ((U8*)s)[0] ) ?                                             \
	( ( 0x0A == ((U8*)s)[1] ) ? 2 : 1 )                                 \
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x85 == ((U8*)s)[0] )\
: 0 )

/*
	HORIZWS: Horizontal Whitespace: \h \H

	0x09            # HT
	0x20            # SPACE
	0xa0            # NBSP
	0x1680          # OGHAM SPACE MARK
	0x180e          # MONGOLIAN VOWEL SEPARATOR
	0x2000          # EN QUAD
	0x2001          # EM QUAD
	0x2002          # EN SPACE
	0x2003          # EM SPACE
	0x2004          # THREE-PER-EM SPACE
	0x2005          # FOUR-PER-EM SPACE
	0x2006          # SIX-PER-EM SPACE
	0x2007          # FIGURE SPACE
	0x2008          # PUNCTUATION SPACE
	0x2009          # THIN SPACE
	0x200A          # HAIR SPACE
	0x202f          # NARROW NO-BREAK SPACE
	0x205f          # MEDIUM MATHEMATICAL SPACE
	0x3000          # IDEOGRAPHIC SPACE
*/
/*** GENERATED CODE ***/
#define is_HORIZWS(s,is_utf8)                                               \
( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                        \
: ( is_utf8 ) ?                                                             \
    ( ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0xA0 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xE1 == ((U8*)s)[0] ) ?                                             \
	( ( 0x9A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x80 == ((U8*)s)[2] ) ? 3 : 0 )                             \
	: ( 0xA0 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x8E == ((U8*)s)[2] ) ? 3 : 0 )                             \
	: 0 )                                                               \
    : ( 0xE2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x80 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0x80 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x8A ) || 0xAF == ((U8*)s)[2] ) ? 3 : 0 )\
	: ( 0x81 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x9F == ((U8*)s)[2] ) ? 3 : 0 )                             \
	: 0 )                                                               \
    : ( 0xE3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x80 == ((U8*)s)[1] ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : 0 )                                                                   \
: ( 0xA0 == ((U8*)s)[0] ) )

/*** GENERATED CODE ***/
#define is_HORIZWS_safe(s,e,is_utf8)                                        \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                    \
    : ( is_utf8 ) ?                                                         \
	( ( 0xC2 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0xA0 == ((U8*)s)[1] ) ? 2 : 0 )                             \
	: ( 0xE1 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x9A == ((U8*)s)[1] ) ?                                     \
		( ( 0x80 == ((U8*)s)[2] ) ? 3 : 0 )                         \
	    : ( 0xA0 == ((U8*)s)[1] ) ?                                     \
		( ( 0x8E == ((U8*)s)[2] ) ? 3 : 0 )                         \
	    : 0 )                                                           \
	: ( 0xE2 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x80 == ((U8*)s)[1] ) ?                                     \
		( ( ( 0x80 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x8A ) || 0xAF == ((U8*)s)[2] ) ? 3 : 0 )\
	    : ( 0x81 == ((U8*)s)[1] ) ?                                     \
		( ( 0x9F == ((U8*)s)[2] ) ? 3 : 0 )                         \
	    : 0 )                                                           \
	: ( 0xE3 == ((U8*)s)[0] ) ?                                         \
	    ( ( ( 0x80 == ((U8*)s)[1] ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )\
	: 0 )                                                               \
    : ( 0xA0 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                    \
    : ( is_utf8 ) ?                                                         \
	( ( ( 0xC2 == ((U8*)s)[0] ) && ( 0xA0 == ((U8*)s)[1] ) ) ? 2 : 0 )  \
    : ( 0xA0 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                    \
    : ( !( is_utf8 ) ) ?                                                    \
	( 0xA0 == ((U8*)s)[0] )                                             \
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_utf8(s)                                                  \
( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                        \
: ( 0xC2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0xA0 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xE1 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x9A == ((U8*)s)[1] ) ?                                             \
	( ( 0x80 == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : ( 0xA0 == ((U8*)s)[1] ) ?                                             \
	( ( 0x8E == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : 0 )                                                                   \
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x80 == ((U8*)s)[1] ) ?                                             \
	( ( ( 0x80 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x8A ) || 0xAF == ((U8*)s)[2] ) ? 3 : 0 )\
    : ( 0x81 == ((U8*)s)[1] ) ?                                             \
	( ( 0x9F == ((U8*)s)[2] ) ? 3 : 0 )                                 \
    : 0 )                                                                   \
: ( 0xE3 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x80 == ((U8*)s)[1] ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )      \
: 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_utf8_safe(s,e)                                           \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                    \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0xA0 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xE1 == ((U8*)s)[0] ) ?                                             \
	( ( 0x9A == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x80 == ((U8*)s)[2] ) ? 3 : 0 )                             \
	: ( 0xA0 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x8E == ((U8*)s)[2] ) ? 3 : 0 )                             \
	: 0 )                                                               \
    : ( 0xE2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x80 == ((U8*)s)[1] ) ?                                         \
	    ( ( ( 0x80 <= ((U8*)s)[2] && ((U8*)s)[2] <= 0x8A ) || 0xAF == ((U8*)s)[2] ) ? 3 : 0 )\
	: ( 0x81 == ((U8*)s)[1] ) ?                                         \
	    ( ( 0x9F == ((U8*)s)[2] ) ? 3 : 0 )                             \
	: 0 )                                                               \
    : ( 0xE3 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x80 == ((U8*)s)[1] ) && ( 0x80 == ((U8*)s)[2] ) ) ? 3 : 0 )  \
    : 0 )                                                                   \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] ) ? 1                    \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0xA0 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] )                          \
: 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_latin1(s)                                                \
( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] || 0xA0 == ((U8*)s)[0] )

/*** GENERATED CODE ***/
#define is_HORIZWS_latin1_safe(s,e)                                         \
( ((e)-(s) > 0) ?                                                           \
    ( 0x09 == ((U8*)s)[0] || 0x20 == ((U8*)s)[0] || 0xA0 == ((U8*)s)[0] )   \
: 0 )

/*** GENERATED CODE ***/
#define is_HORIZWS_cp(cp)                                                   \
( 0x09 == cp || ( 0x09 < cp &&                                              \
( 0x20 == cp || ( 0x20 < cp &&                                              \
( 0xA0 == cp || ( 0xA0 < cp &&                                              \
( 0x1680 == cp || ( 0x1680 < cp &&                                          \
( 0x180E == cp || ( 0x180E < cp &&                                          \
( ( 0x2000 <= cp && cp <= 0x200A ) || ( 0x200A < cp &&                      \
( 0x202F == cp || ( 0x202F < cp &&                                          \
( 0x205F == cp || ( 0x205F < cp &&                                          \
0x3000 == cp ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )

/*
	VERTWS: Vertical Whitespace: \v \V

	0x0A            # LF
	0x0B            # VT
	0x0C            # FF
	0x0D            # CR
	0x85            # NEL
	0x2028          # LINE SEPARATOR
	0x2029          # PARAGRAPH SEPARATOR
*/
/*** GENERATED CODE ***/
#define is_VERTWS(s,is_utf8)                                                \
( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                        \
: ( is_utf8 ) ?                                                             \
    ( ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xE2 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
    : 0 )                                                                   \
: ( 0x85 == ((U8*)s)[0] ) )

/*** GENERATED CODE ***/
#define is_VERTWS_safe(s,e,is_utf8)                                         \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( is_utf8 ) ?                                                         \
	( ( 0xC2 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                             \
	: ( 0xE2 == ((U8*)s)[0] ) ?                                         \
	    ( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
	: 0 )                                                               \
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( is_utf8 ) ?                                                         \
	( ( ( 0xC2 == ((U8*)s)[0] ) && ( 0x85 == ((U8*)s)[1] ) ) ? 2 : 0 )  \
    : ( 0x85 == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( !( is_utf8 ) ) ?                                                    \
	( 0x85 == ((U8*)s)[0] )                                             \
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_utf8(s)                                                   \
( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                        \
: ( 0xC2 == ((U8*)s)[0] ) ?                                                 \
    ( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                     \
: ( 0xE2 == ((U8*)s)[0] ) ?                                                 \
    ( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
: 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_utf8_safe(s,e)                                            \
( ((e)-(s) > 2) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xE2 == ((U8*)s)[0] ) ?                                             \
	( ( ( 0x80 == ((U8*)s)[1] ) && ( 0xA8 == ((U8*)s)[2] || 0xA9 == ((U8*)s)[2] ) ) ? 3 : 0 )\
    : 0 )                                                                   \
: ((e)-(s) > 1) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) ? 1                    \
    : ( 0xC2 == ((U8*)s)[0] ) ?                                             \
	( ( 0x85 == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : 0 )                                                                   \
: ((e)-(s) > 0) ?                                                           \
    ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D )                          \
: 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_latin1(s)                                                 \
( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x85 == ((U8*)s)[0] )

/*** GENERATED CODE ***/
#define is_VERTWS_latin1_safe(s,e)                                          \
( ((e)-(s) > 0) ?                                                           \
    ( ( 0x0A <= ((U8*)s)[0] && ((U8*)s)[0] <= 0x0D ) || 0x85 == ((U8*)s)[0] )\
: 0 )

/*** GENERATED CODE ***/
#define is_VERTWS_cp(cp)                                                    \
( ( 0x0A <= cp && cp <= 0x0D ) || ( 0x0D < cp &&                            \
( 0x85 == cp || ( 0x85 < cp &&                                              \
( 0x2028 == cp || ( 0x2028 < cp &&                                          \
0x2029 == cp ) ) ) ) ) )

/*
	TRICKYFOLD: Problematic fold case letters.

	0x00DF	# LATIN1 SMALL LETTER SHARP S
	0x0390	# GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
	0x03B0	# GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
*/
/*** GENERATED CODE ***/
#define is_TRICKYFOLD(s,is_utf8)                                            \
( ( is_utf8 ) ?                                                             \
    ( ( 0xC3 == ((U8*)s)[0] ) ?                                             \
	( ( 0x9F == ((U8*)s)[1] ) ? 2 : 0 )                                 \
    : ( 0xCE == ((U8*)s)[0] ) ?                                             \
	( ( 0x90 == ((U8*)s)[1] || 0xB0 == ((U8*)s)[1] ) ? 2 : 0 )          \
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] ) )

/*** GENERATED CODE ***/
#define is_TRICKYFOLD_safe(s,e,is_utf8)                                     \
( ((e)-(s) > 1) ?                                                           \
    ( ( is_utf8 ) ?                                                         \
	( ( 0xC3 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x9F == ((U8*)s)[1] ) ? 2 : 0 )                             \
	: ( 0xCE == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x90 == ((U8*)s)[1] || 0xB0 == ((U8*)s)[1] ) ? 2 : 0 )      \
	: 0 )                                                               \
    : ( 0xDF == ((U8*)s)[0] ) )                                             \
: ((e)-(s) > 0) ?                                                           \
    ( ( !( is_utf8 ) ) ?                                                    \
	( 0xDF == ((U8*)s)[0] )                                             \
    : 0 )                                                                   \
: 0 )

/*** GENERATED CODE ***/
#define is_TRICKYFOLD_cp(cp)                                                \
( 0xDF == cp || ( 0xDF < cp &&                                              \
( 0x390 == cp || ( 0x390 < cp &&                                            \
0x3B0 == cp ) ) ) )

/*** GENERATED CODE ***/
#define what_TRICKYFOLD(s,is_utf8)                                          \
( ( is_utf8 ) ?                                                             \
    ( ( 0xC3 == ((U8*)s)[0] ) ?                                             \
	( ( 0x9F == ((U8*)s)[1] ) ? 0xDF : 0 )                              \
    : ( 0xCE == ((U8*)s)[0] ) ?                                             \
	( ( 0x90 == ((U8*)s)[1] ) ? 0x390                                   \
	: ( 0xB0 == ((U8*)s)[1] ) ? 0x3B0 : 0 )                             \
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] ) ? 0xDF : 0 )

/*** GENERATED CODE ***/
#define what_TRICKYFOLD_safe(s,e,is_utf8)                                   \
( ((e)-(s) > 1) ?                                                           \
    ( ( is_utf8 ) ?                                                         \
	( ( 0xC3 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x9F == ((U8*)s)[1] ) ? 0xDF : 0 )                          \
	: ( 0xCE == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x90 == ((U8*)s)[1] ) ? 0x390                               \
	    : ( 0xB0 == ((U8*)s)[1] ) ? 0x3B0 : 0 )                         \
	: 0 )                                                               \
    : ( 0xDF == ((U8*)s)[0] ) ? 0xDF : 0 )                                  \
: ((e)-(s) > 0) ?                                                           \
    ( ( ( !( is_utf8 ) ) && ( 0xDF == ((U8*)s)[0] ) ) ? 0xDF : 0 )          \
: 0 )

/*** GENERATED CODE ***/
#define what_len_TRICKYFOLD(s,is_utf8,len)                                  \
( ( is_utf8 ) ?                                                             \
    ( ( 0xC3 == ((U8*)s)[0] ) ?                                             \
	( ( 0x9F == ((U8*)s)[1] ) ? len=2, 0xDF : 0 )                       \
    : ( 0xCE == ((U8*)s)[0] ) ?                                             \
	( ( 0x90 == ((U8*)s)[1] ) ? len=2, 0x390                            \
	: ( 0xB0 == ((U8*)s)[1] ) ? len=2, 0x3B0 : 0 )                      \
    : 0 )                                                                   \
: ( 0xDF == ((U8*)s)[0] ) ? len=1, 0xDF : 0 )

/*** GENERATED CODE ***/
#define what_len_TRICKYFOLD_safe(s,e,is_utf8,len)                           \
( ((e)-(s) > 1) ?                                                           \
    ( ( is_utf8 ) ?                                                         \
	( ( 0xC3 == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x9F == ((U8*)s)[1] ) ? len=2, 0xDF : 0 )                   \
	: ( 0xCE == ((U8*)s)[0] ) ?                                         \
	    ( ( 0x90 == ((U8*)s)[1] ) ? len=2, 0x390                        \
	    : ( 0xB0 == ((U8*)s)[1] ) ? len=2, 0x3B0 : 0 )                  \
	: 0 )                                                               \
    : ( 0xDF == ((U8*)s)[0] ) ? len=1, 0xDF : 0 )                           \
: ((e)-(s) > 0) ?                                                           \
    ( ( ( !( is_utf8 ) ) && ( 0xDF == ((U8*)s)[0] ) ) ? len=1, 0xDF : 0 )   \
: 0 )

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\regcomp.h ===
/*    regcomp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
#include "regcharclass.h"

typedef OP OP_4tree;			/* Will be redefined later. */


/* Convert branch sequences to more efficient trie ops? */
#define PERL_ENABLE_TRIE_OPTIMISATION 1

/* Be really agressive about optimising patterns with trie sequences? */
#define PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION 1

/* Should the optimiser take positive assertions into account? */
#define PERL_ENABLE_POSITIVE_ASSERTION_STUDY 0

/* Not for production use: */
#define PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS 0

/* Activate offsets code - set to if 1 to enable */
#ifdef DEBUGGING
#define RE_TRACK_PATTERN_OFFSETS
#endif

/* Unless the next line is uncommented it is illegal to combine lazy 
   matching with possessive matching. Frankly it doesn't make much sense 
   to allow it as X*?+ matches nothing, X+?+ matches a single char only, 
   and X{min,max}?+ matches min times only.
 */
/* #define REG_ALLOW_MINMOD_SUSPEND */

/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart	sv that must begin a match; NULL if none obvious
 * reganch	is the match anchored (at beginning-of-line only)?
 * regmust	string (pointer into program) that match must include, or NULL
 *  [regmust changed to SV* for bminstr()--law]
 * regmlen	length of regmust string
 *  [regmlen not used currently]
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that pregcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in pregexec() needs it and pregcomp() is computing
 * it anyway.
 * [regmust is now supplied always.  The tests that use regmust have a
 * heuristic that disables the test if it usually matches.]
 *
 * [In fact, we now use regmust in many cases to locate where the search
 * starts in the string, so if regback is >= 0, the regmust search is never
 * wasted effort.  The regback variable says how many characters back from
 * where regmust matched is the earliest possible start of the match.
 * For instance, /[a-z].foo/ has a regmust of 'foo' and a regback of 2.]
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are defined
 * in regnodes.h which is generated from regcomp.sym by regcomp.pl.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 *
 * [The "next" pointer is always aligned on an even
 * boundary, and reads the offset directly as a short.  Also, there is no
 * special test to reverse the sign of BACK pointers since the offset is
 * stored negative.]
 */

/* This is the stuff that used to live in regexp.h that was truly
   private to the engine itself. It now lives here. */



 typedef struct regexp_internal {
        int name_list_idx;	/* Optional data index of an array of paren names */
        union {
	    U32 *offsets;           /* offset annotations 20001228 MJD
                                       data about mapping the program to the
                                       string -
                                       offsets[0] is proglen when this is used
                                       */
            U32 proglen;
        } u;

        regnode *regstclass;    /* Optional startclass as identified or constructed
                                   by the optimiser */
        struct reg_data *data;	/* Additional miscellaneous data used by the program.
                                   Used to make it easier to clone and free arbitrary
                                   data that the regops need. Often the ARG field of
                                   a regop is an index into this structure */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
} regexp_internal;

#define RXi_SET(x,y) (x)->pprivate = (void*)(y)   
#define RXi_GET(x)   ((regexp_internal *)((x)->pprivate))
#define RXi_GET_DECL(r,ri) regexp_internal *ri = RXi_GET(r)
/*
 * Flags stored in regexp->intflags
 * These are used only internally to the regexp engine
 *
 * See regexp.h for flags used externally to the regexp engine
 */
#define PREGf_SKIP		0x00000001
#define PREGf_IMPLICIT		0x00000002 /* Converted .* to ^.* */
#define PREGf_NAUGHTY		0x00000004 /* how exponential is this pattern? */
#define PREGf_VERBARG_SEEN	0x00000008
#define PREGf_CUTGROUP_SEEN	0x00000010


/* this is where the old regcomp.h started */

struct regnode_string {
    U8	str_len;
    U8  type;
    U16 next_off;
    char string[1];
};

/* Argument bearing node - workhorse, 
   arg1 is often for the data field */
struct regnode_1 {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
};

/* Similar to a regnode_1 but with an extra signed argument */
struct regnode_2L {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
    I32 arg2;
};

/* 'Two field' -- Two 16 bit unsigned args */
struct regnode_2 {
    U8	flags;
    U8  type;
    U16 next_off;
    U16 arg1;
    U16 arg2;
};


#define ANYOF_BITMAP_SIZE	32	/* 256 b/(8 b/B) */
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 40 (8*5) named classes */

/* also used by trie */
struct regnode_charclass {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];	/* only compile-time */
};

struct regnode_charclass_class {	/* has [[:blah:]] classes */
    U8	flags;				/* should have ANYOF_CLASS here */
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];		/* both compile-time */
    char classflags[ANYOF_CLASSBITMAP_SIZE];	/* and run-time */
};

/* XXX fix this description.
   Impose a limit of REG_INFTY on various pattern matching operations
   to limit stack growth and to avoid "infinite" recursions.
*/
/* The default size for REG_INFTY is I16_MAX, which is the same as
   SHORT_MAX (see perl.h).  Unfortunately I16 isn't necessarily 16 bits
   (see handy.h).  On the Cray C90, sizeof(short)==4 and hence I16_MAX is
   ((1<<31)-1), while on the Cray T90, sizeof(short)==8 and I16_MAX is
   ((1<<63)-1).  To limit stack growth to reasonable sizes, supply a
   smaller default.
	--Andy Dougherty  11 June 1998
*/
#if SHORTSIZE > 2
#  ifndef REG_INFTY
#    define REG_INFTY ((1<<15)-1)
#  endif
#endif

#ifndef REG_INFTY
#  define REG_INFTY I16_MAX
#endif

#define ARG_VALUE(arg) (arg)
#define ARG__SET(arg,val) ((arg) = (val))

#undef ARG
#undef ARG1
#undef ARG2

#define ARG(p) ARG_VALUE(ARG_LOC(p))
#define ARG1(p) ARG_VALUE(ARG1_LOC(p))
#define ARG2(p) ARG_VALUE(ARG2_LOC(p))
#define ARG2L(p) ARG_VALUE(ARG2L_LOC(p))

#define ARG_SET(p, val) ARG__SET(ARG_LOC(p), (val))
#define ARG1_SET(p, val) ARG__SET(ARG1_LOC(p), (val))
#define ARG2_SET(p, val) ARG__SET(ARG2_LOC(p), (val))
#define ARG2L_SET(p, val) ARG__SET(ARG2L_LOC(p), (val))

#undef NEXT_OFF
#undef NODE_ALIGN

#define NEXT_OFF(p) ((p)->next_off)
#define NODE_ALIGN(node)
#define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */

#define SIZE_ALIGN NODE_ALIGN

#undef OP
#undef OPERAND
#undef MASK
#undef STRING

#define	OP(p)		((p)->type)
#define	OPERAND(p)	(((struct regnode_string *)p)->string)
#define MASK(p)		((char*)OPERAND(p))
#define	STR_LEN(p)	(((struct regnode_string *)p)->str_len)
#define	STRING(p)	(((struct regnode_string *)p)->string)
#define STR_SZ(l)	((l + sizeof(regnode) - 1) / sizeof(regnode))
#define NODE_SZ_STR(p)	(STR_SZ(STR_LEN(p))+1)

#undef NODE_ALIGN
#undef ARG_LOC
#undef NEXTOPER
#undef PREVOPER

#define	NODE_ALIGN(node)
#define	ARG_LOC(p)	(((struct regnode_1 *)p)->arg1)
#define	ARG1_LOC(p)	(((struct regnode_2 *)p)->arg1)
#define	ARG2_LOC(p)	(((struct regnode_2 *)p)->arg2)
#define ARG2L_LOC(p)	(((struct regnode_2L *)p)->arg2)

#define NODE_STEP_REGNODE	1	/* sizeof(regnode)/sizeof(regnode) */
#define EXTRA_STEP_2ARGS	EXTRA_SIZE(struct regnode_2)

#define NODE_STEP_B	4

#define	NEXTOPER(p)	((p) + NODE_STEP_REGNODE)
#define	PREVOPER(p)	((p) - NODE_STEP_REGNODE)

#define FILL_ADVANCE_NODE(ptr, op) STMT_START { \
    (ptr)->type = op;    (ptr)->next_off = 0;   (ptr)++; } STMT_END
#define FILL_ADVANCE_NODE_ARG(ptr, op, arg) STMT_START { \
    ARG_SET(ptr, arg);  FILL_ADVANCE_NODE(ptr, op); (ptr) += 1; } STMT_END

#define REG_MAGIC 0234

#define SIZE_ONLY (RExC_emit == &PL_regdummy)

/* Flags for node->flags of ANYOF */

#define ANYOF_CLASS		0x08	/* has [[:blah:]] classes */
#define ANYOF_INVERT		0x04
#define ANYOF_FOLD		0x02
#define ANYOF_LOCALE		0x01

/* Used for regstclass only */
#define ANYOF_EOS		0x10		/* Can match an empty string too */

/* There is a character or a range past 0xff */
#define ANYOF_UNICODE		0x20
#define ANYOF_UNICODE_ALL	0x40	/* Can match any char past 0xff */

/* size of node is large (includes class pointer) */
#define ANYOF_LARGE 		0x80

/* Are there any runtime flags on in this node? */
#define ANYOF_RUNTIME(s)	(ANYOF_FLAGS(s) & 0x0f)

#define ANYOF_FLAGS_ALL		0xff

/* Character classes for node->classflags of ANYOF */
/* Should be synchronized with a table in regprop() */
/* 2n should pair with 2n+1 */

#define ANYOF_ALNUM	 0	/* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
#define ANYOF_NALNUM	 1
#define ANYOF_SPACE	 2	/* \s */
#define ANYOF_NSPACE	 3
#define ANYOF_DIGIT	 4
#define ANYOF_NDIGIT	 5
#define ANYOF_ALNUMC	 6	/* isalnum(3), utf8::IsAlnum, ALNUMC */
#define ANYOF_NALNUMC	 7
#define ANYOF_ALPHA	 8
#define ANYOF_NALPHA	 9
#define ANYOF_ASCII	10
#define ANYOF_NASCII	11
#define ANYOF_CNTRL	12
#define ANYOF_NCNTRL	13
#define ANYOF_GRAPH	14
#define ANYOF_NGRAPH	15
#define ANYOF_LOWER	16
#define ANYOF_NLOWER	17
#define ANYOF_PRINT	18
#define ANYOF_NPRINT	19
#define ANYOF_PUNCT	20
#define ANYOF_NPUNCT	21
#define ANYOF_UPPER	22
#define ANYOF_NUPPER	23
#define ANYOF_XDIGIT	24
#define ANYOF_NXDIGIT	25
#define ANYOF_PSXSPC	26	/* POSIX space: \s plus the vertical tab */
#define ANYOF_NPSXSPC	27
#define ANYOF_BLANK	28	/* GNU extension: space and tab: non-vertical space */
#define ANYOF_NBLANK	29

#define ANYOF_MAX	32

/* pseudo classes, not stored in the class bitmap, but used as flags
   during compilation of char classes */

#define ANYOF_VERTWS	(ANYOF_MAX+1)
#define ANYOF_NVERTWS	(ANYOF_MAX+2)
#define ANYOF_HORIZWS	(ANYOF_MAX+3)
#define ANYOF_NHORIZWS	(ANYOF_MAX+4)

/* Backward source code compatibility. */

#define ANYOF_ALNUML	 ANYOF_ALNUM
#define ANYOF_NALNUML	 ANYOF_NALNUM
#define ANYOF_SPACEL	 ANYOF_SPACE
#define ANYOF_NSPACEL	 ANYOF_NSPACE

/* Utility macros for the bitmap and classes of ANYOF */

#define ANYOF_SIZE		(sizeof(struct regnode_charclass))
#define ANYOF_CLASS_SIZE	(sizeof(struct regnode_charclass_class))

#define ANYOF_FLAGS(p)		((p)->flags)

#define ANYOF_BIT(c)		(1 << ((c) & 7))

#define ANYOF_CLASS_BYTE(p, c)	(((struct regnode_charclass_class*)(p))->classflags[((c) >> 3) & 3])
#define ANYOF_CLASS_SET(p, c)	(ANYOF_CLASS_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_CLASS_CLEAR(p, c)	(ANYOF_CLASS_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_CLASS_TEST(p, c)	(ANYOF_CLASS_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_CLASS_ZERO(ret)	Zero(((struct regnode_charclass_class*)(ret))->classflags, ANYOF_CLASSBITMAP_SIZE, char)
#define ANYOF_BITMAP_ZERO(ret)	Zero(((struct regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)

#define ANYOF_BITMAP(p)		(((struct regnode_charclass*)(p))->bitmap)
#define ANYOF_BITMAP_BYTE(p, c)	(ANYOF_BITMAP(p)[(((U8)(c)) >> 3) & 31])
#define ANYOF_BITMAP_SET(p, c)	(ANYOF_BITMAP_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_BITMAP_CLEAR(p,c)	(ANYOF_BITMAP_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_BITMAP_TEST(p, c)	(ANYOF_BITMAP_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_BITMAP_SETALL(p)		\
	memset (ANYOF_BITMAP(p), 255, ANYOF_BITMAP_SIZE)
#define ANYOF_BITMAP_CLEARALL(p)	\
	Zero (ANYOF_BITMAP(p), ANYOF_BITMAP_SIZE)
/* Check that all 256 bits are all set.  Used in S_cl_is_anything()  */
#define ANYOF_BITMAP_TESTALLSET(p)	\
	memEQ (ANYOF_BITMAP(p), "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377", ANYOF_BITMAP_SIZE)

#define ANYOF_SKIP		((ANYOF_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_SKIP	((ANYOF_CLASS_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_ADD_SKIP	(ANYOF_CLASS_SKIP - ANYOF_SKIP)


/*
 * Utility definitions.
 */
#ifndef CHARMASK
#  define UCHARAT(p)	((int)*(const U8*)(p))
#else
#  define UCHARAT(p)	((int)*(p)&CHARMASK)
#endif

#define EXTRA_SIZE(guy) ((sizeof(guy)-1)/sizeof(struct regnode))

#define REG_SEEN_ZERO_LEN	0x00000001
#define REG_SEEN_LOOKBEHIND	0x00000002
#define REG_SEEN_GPOS		0x00000004
#define REG_SEEN_EVAL		0x00000008
#define REG_SEEN_CANY		0x00000010
#define REG_SEEN_SANY		REG_SEEN_CANY /* src bckwrd cmpt */
#define REG_SEEN_RECURSE        0x00000020
#define REG_TOP_LEVEL_BRANCHES  0x00000040
#define REG_SEEN_VERBARG        0x00000080
#define REG_SEEN_CUTGROUP       0x00000100
#define REG_SEEN_RUN_ON_COMMENT 0x00000200

START_EXTERN_C

#ifdef PLUGGABLE_RE_EXTENSION
#include "re_nodes.h"
#else
#include "regnodes.h"
#endif

/* The following have no fixed length. U8 so we can do strchr() on it. */
#ifndef DOINIT
EXTCONST U8 PL_varies[];
#else
EXTCONST U8 PL_varies[] = {
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL,
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, CLUMP,
    NREF, NREFF, NREFFL,
    0
};
#endif

/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
#ifndef DOINIT
EXTCONST U8 PL_simple[];
#else
EXTCONST U8 PL_simple[] = {
    REG_ANY,	SANY,	CANY,
    ANYOF,
    ALNUM,	ALNUML,
    NALNUM,	NALNUML,
    SPACE,	SPACEL,
    NSPACE,	NSPACEL,
    DIGIT,	NDIGIT,
    VERTWS,     NVERTWS,
    HORIZWS,    NHORIZWS,
    0
};
#endif

#ifndef PLUGGABLE_RE_EXTENSION
#ifndef DOINIT
EXTCONST regexp_engine PL_core_reg_engine;
#else /* DOINIT */
EXTCONST regexp_engine PL_core_reg_engine = { 
        Perl_re_compile,
        Perl_regexec_flags,
        Perl_re_intuit_start,
        Perl_re_intuit_string, 
        Perl_regfree_internal,
        Perl_reg_numbered_buff_fetch,
        Perl_reg_numbered_buff_store,
        Perl_reg_numbered_buff_length,
        Perl_reg_named_buff,
        Perl_reg_named_buff_iter,
        Perl_reg_qr_package,
#if defined(USE_ITHREADS)        
        Perl_regdupe_internal
#endif        
};
#endif /* DOINIT */
#endif /* PLUGGABLE_RE_EXTENSION */


END_EXTERN_C


/* .what is a character array with one character for each member of .data
 * The character describes the function of the corresponding .data item:
 *   f - start-class data for regstclass optimization
 *   n - Root of op tree for (?{EVAL}) item
 *   o - Start op for (?{EVAL}) item
 *   p - Pad for (?{EVAL}) item
 *   s - swash for Unicode-style character class, and the multicharacter
 *       strings resulting from casefolding the single-character entries
 *       in the character class
 *   t - trie struct
 *   u - trie struct's widecharmap (a HV, so can't share, must dup)
 *       also used for revcharmap and words under DEBUGGING
 *   T - aho-trie struct
 *   S - sv for named capture lookup
 * 20010712 mjd@plover.com
 * (Remember to update re_dup() and pregfree() if you add any items.)
 */
struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

/* Code in S_to_utf8_substr() and S_to_byte_substr() in regexec.c accesses
   anchored* and float* via array indexes 0 and 1.  */
#define anchored_substr substrs->data[0].substr
#define anchored_utf8 substrs->data[0].utf8_substr
#define anchored_offset substrs->data[0].min_offset
#define anchored_end_shift substrs->data[0].end_shift

#define float_substr substrs->data[1].substr
#define float_utf8 substrs->data[1].utf8_substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define float_end_shift substrs->data[1].end_shift

#define check_substr substrs->data[2].substr
#define check_utf8 substrs->data[2].utf8_substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset
#define check_end_shift substrs->data[2].end_shift



/* trie related stuff */

/* a transition record for the state machine. the
   check field determines which state "owns" the
   transition. the char the transition is for is
   determined by offset from the owning states base
   field.  the next field determines which state
   is to be transitioned to if any.
*/
struct _reg_trie_trans {
  U32 next;
  U32 check;
};

/* a transition list element for the list based representation */
struct _reg_trie_trans_list_elem {
    U16 forid;
    U32 newstate;
};
typedef struct _reg_trie_trans_list_elem reg_trie_trans_le;

/* a state for compressed nodes. base is an offset
  into an array of reg_trie_trans array. If wordnum is
  nonzero the state is accepting. if base is zero then
  the state has no children (and will be accepting)
*/
struct _reg_trie_state {
  U16 wordnum;
  union {
    U32                base;
    reg_trie_trans_le* list;
  } trans;
};



typedef struct _reg_trie_state    reg_trie_state;
typedef struct _reg_trie_trans    reg_trie_trans;


/* anything in here that needs to be freed later
   should be dealt with in pregfree.
   refcount is first in both this and _reg_ac_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_trie_data {
    U32             refcount;        /* number of times this trie is referenced */
    U32             lasttrans;       /* last valid transition element */
    U16             *charmap;        /* byte to charid lookup array */
    reg_trie_state  *states;         /* state data */
    reg_trie_trans  *trans;          /* array of transition elements */
    char            *bitmap;         /* stclass bitmap */
    U32             *wordlen;        /* array of lengths of words */
    U16 	    *jump;           /* optional 1 indexed array of offsets before tail 
                                        for the node following a given word. */
    U16	            *nextword;       /* optional 1 indexed array to support linked list
                                        of duplicate wordnums */
    U16             uniquecharcount; /* unique chars in trie (width of trans table) */
    U32             startstate;      /* initial state - used for common prefix optimisation */
    STRLEN          minlen;          /* minimum length of words in trie - build/opt only? */
    STRLEN          maxlen;          /* maximum length of words in trie - build/opt only? */
    U32             statecount;      /* Build only - number of states in the states array 
                                        (including the unused zero state) */
    U32             wordcount;       /* Build only */
#ifdef DEBUGGING
    STRLEN          charcount;       /* Build only */
#endif
};
/* There is one (3 under DEBUGGING) pointers that logically belong in this
   structure, but are held outside as they need duplication on thread cloning,
   whereas the rest of the structure can be read only:
    HV              *widecharmap;    code points > 255 to charid
#ifdef DEBUGGING
    AV              *words;          Array of words contained in trie, for dumping
    AV              *revcharmap;     Map of each charid back to its character representation
#endif
*/

#define TRIE_WORDS_OFFSET 2

typedef struct _reg_trie_data reg_trie_data;

/* refcount is first in both this and _reg_trie_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_ac_data {
    U32              refcount;
    U32              trie;
    U32              *fail;
    reg_trie_state   *states;
};
typedef struct _reg_ac_data reg_ac_data;

/* ANY_BIT doesnt use the structure, so we can borrow it here.
   This is simpler than refactoring all of it as wed end up with
   three different sets... */

#define TRIE_BITMAP(p)		(((reg_trie_data *)(p))->bitmap)
#define TRIE_BITMAP_BYTE(p, c)	(TRIE_BITMAP(p)[(((U8)(c)) >> 3) & 31])
#define TRIE_BITMAP_SET(p, c)	(TRIE_BITMAP_BYTE(p, c) |=  ANYOF_BIT((U8)c))
#define TRIE_BITMAP_CLEAR(p,c)	(TRIE_BITMAP_BYTE(p, c) &= ~ANYOF_BIT((U8)c))
#define TRIE_BITMAP_TEST(p, c)	(TRIE_BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

#define IS_ANYOF_TRIE(op) ((op)==TRIEC || (op)==AHOCORASICKC)
#define IS_TRIE_AC(op) ((op)>=AHOCORASICK)


#define BITMAP_BYTE(p, c)	(((U8*)p)[(((U8)(c)) >> 3) & 31])
#define BITMAP_TEST(p, c)	(BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

/* these defines assume uniquecharcount is the correct variable, and state may be evaluated twice */
#define TRIE_NODENUM(state) (((state)-1)/(trie->uniquecharcount)+1)
#define SAFE_TRIE_NODENUM(state) ((state) ? (((state)-1)/(trie->uniquecharcount)+1) : (state))
#define TRIE_NODEIDX(state) ((state) ? (((state)-1)*(trie->uniquecharcount)+1) : (state))

#ifdef DEBUGGING
#define TRIE_CHARCOUNT(trie) ((trie)->charcount)
#else
#define TRIE_CHARCOUNT(trie) (trie_charcount)
#endif

#define RE_TRIE_MAXBUF_INIT 65536
#define RE_TRIE_MAXBUF_NAME "\022E_TRIE_MAXBUF"
#define RE_DEBUG_FLAGS "\022E_DEBUG_FLAGS"

/*

RE_DEBUG_FLAGS is used to control what debug output is emitted
its divided into three groups of options, some of which interact.
The three groups are: Compile, Execute, Extra. There is room for a
further group, as currently only the low three bytes are used.

    Compile Options:
    
    PARSE
    PEEP
    TRIE
    PROGRAM
    OFFSETS

    Execute Options:

    INTUIT
    MATCH
    TRIE

    Extra Options

    TRIE
    OFFSETS

If you modify any of these make sure you make corresponding changes to
re.pm, especially to the documentation.

*/


/* Compile */
#define RE_DEBUG_COMPILE_MASK      0x0000FF
#define RE_DEBUG_COMPILE_PARSE     0x000001
#define RE_DEBUG_COMPILE_OPTIMISE  0x000002
#define RE_DEBUG_COMPILE_TRIE      0x000004
#define RE_DEBUG_COMPILE_DUMP      0x000008
#define RE_DEBUG_COMPILE_FLAGS     0x000010

/* Execute */
#define RE_DEBUG_EXECUTE_MASK      0x00FF00
#define RE_DEBUG_EXECUTE_INTUIT    0x000100
#define RE_DEBUG_EXECUTE_MATCH     0x000200
#define RE_DEBUG_EXECUTE_TRIE      0x000400

/* Extra */
#define RE_DEBUG_EXTRA_MASK        0xFF0000
#define RE_DEBUG_EXTRA_TRIE        0x010000
#define RE_DEBUG_EXTRA_OFFSETS     0x020000
#define RE_DEBUG_EXTRA_OFFDEBUG    0x040000
#define RE_DEBUG_EXTRA_STATE       0x080000
#define RE_DEBUG_EXTRA_OPTIMISE    0x100000
#define RE_DEBUG_EXTRA_BUFFERS     0x400000
/* combined */
#define RE_DEBUG_EXTRA_STACK       0x280000

#define RE_DEBUG_FLAG(x) (re_debug_flags & x)
/* Compile */
#define DEBUG_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_MASK) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_OPTIMISE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_OPTIMISE) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_DUMP_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_DUMP) x  )
#define DEBUG_TRIE_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_TRIE) x )
#define DEBUG_FLAGS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_FLAGS) x )
/* Execute */
#define DEBUG_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MASK) x  )
#define DEBUG_INTUIT_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_INTUIT) x  )
#define DEBUG_MATCH_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MATCH) x  )
#define DEBUG_TRIE_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_TRIE) x )

/* Extra */
#define DEBUG_EXTRA_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_MASK) x  )
#define DEBUG_OFFSETS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFSETS) x  )
#define DEBUG_STATE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STATE) x )
#define DEBUG_STACK_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STACK) x )
#define DEBUG_BUFFERS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_BUFFERS) x )

#define DEBUG_OPTIMISE_MORE_r(x) DEBUG_r( \
    if ((RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE) == \
         (re_debug_flags & (RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE)) ) x )
#define MJD_OFFSET_DEBUG(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFDEBUG) \
        Perl_warn_nocontext x )
#define DEBUG_TRIE_COMPILE_MORE_r(x) DEBUG_TRIE_COMPILE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )
#define DEBUG_TRIE_EXECUTE_MORE_r(x) DEBUG_TRIE_EXECUTE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )

#define DEBUG_TRIE_r(x) DEBUG_r( \
    if (re_debug_flags & (RE_DEBUG_COMPILE_TRIE \
        | RE_DEBUG_EXECUTE_TRIE )) x )

/* initialization */
/* get_sv() can return NULL during global destruction. */
#define GET_RE_DEBUG_FLAGS DEBUG_r({ \
        SV * re_debug_flags_sv = NULL; \
        re_debug_flags_sv = get_sv(RE_DEBUG_FLAGS, 1); \
        if (re_debug_flags_sv) { \
            if (!SvIOK(re_debug_flags_sv)) \
                sv_setuv(re_debug_flags_sv, RE_DEBUG_COMPILE_DUMP | RE_DEBUG_EXECUTE_MASK ); \
            re_debug_flags=SvIV(re_debug_flags_sv); \
        }\
})

#ifdef DEBUGGING

#define GET_RE_DEBUG_FLAGS_DECL IV re_debug_flags = 0; GET_RE_DEBUG_FLAGS;

#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2) \
    const char * const rpv =                          \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
            PERL_PV_ESCAPE_RE |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
    const int rlen = SvCUR(dsv)

#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m) \
    const char * const rpv =                          \
        pv_pretty((dsv), (SvPV_nolen_const(sv)), (SvCUR(sv)), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
            PERL_PV_ESCAPE_RE |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )

#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)                    \
    const char * const rpv =                                       \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[0], PL_colors[1], \
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_ELLIPSES | \
              ((isuni) ? PERL_PV_ESCAPE_UNI : 0))                  \
        )

#define RE_SV_DUMPLEN(ItEm) (SvCUR(ItEm) - (SvTAIL(ItEm)!=0))
#define RE_SV_TAIL(ItEm) (SvTAIL(ItEm) ? "$" : "")
    
#else /* if not DEBUGGING */

#define GET_RE_DEBUG_FLAGS_DECL
#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2)
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)
#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)
#define RE_SV_DUMPLEN(ItEm)
#define RE_SV_TAIL(ItEm)

#endif /* DEBUG RELATED DEFINES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\proto.h ===
/*  -*- buffer-read-only: t -*-
 *
 *    proto.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * This file is built by embed.pl from data in embed.fnc, embed.pl,
 * pp.sym, intrpvar.h, and perlvars.h.
 * Any changes made here will be lost!
 *
 * Edit those files and run 'make regen_headers' to effect changes.
 */

START_EXTERN_C

#if defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV PerlInterpreter*	perl_alloc_using(struct IPerlMem* m, struct IPerlMem* ms, struct IPerlMem* mp, struct IPerlEnv* e, struct IPerlStdIO* io, struct IPerlLIO* lio, struct IPerlDir* d, struct IPerlSock* s, struct IPerlProc* p)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4)
			__attribute__nonnull__(5)
			__attribute__nonnull__(6)
			__attribute__nonnull__(7)
			__attribute__nonnull__(8)
			__attribute__nonnull__(9);

#endif
PERL_CALLCONV PerlInterpreter*	perl_alloc(void);
PERL_CALLCONV void	perl_construct(PerlInterpreter* interp)
			__attribute__nonnull__(1);

PERL_CALLCONV int	perl_destruct(PerlInterpreter* interp)
			__attribute__nonnull__(1);

PERL_CALLCONV void	perl_free(PerlInterpreter* interp)
			__attribute__nonnull__(1);

PERL_CALLCONV int	perl_run(PerlInterpreter* interp)
			__attribute__nonnull__(1);

PERL_CALLCONV int	perl_parse(PerlInterpreter* interp, XSINIT_t xsinit, int argc, char** argv, char** env)
			__attribute__nonnull__(1);

PERL_CALLCONV bool	Perl_doing_taint(int argc, char** argv, char** env)
			__attribute__warn_unused_result__;

#if defined(USE_ITHREADS)
PERL_CALLCONV PerlInterpreter*	perl_clone(PerlInterpreter* interp, UV flags)
			__attribute__nonnull__(1);

#  if defined(PERL_IMPLICIT_SYS)
PERL_CALLCONV PerlInterpreter*	perl_clone_using(PerlInterpreter *interp, UV flags, struct IPerlMem* m, struct IPerlMem* ms, struct IPerlMem* mp, struct IPerlEnv* e, struct IPerlStdIO* io, struct IPerlLIO* lio, struct IPerlDir* d, struct IPerlSock* s, struct IPerlProc* p)
			__attribute__nonnull__(1)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4)
			__attribute__nonnull__(5)
			__attribute__nonnull__(6)
			__attribute__nonnull__(7)
			__attribute__nonnull__(8)
			__attribute__nonnull__(9)
			__attribute__nonnull__(10)
			__attribute__nonnull__(11);

#  endif
#endif

PERL_CALLCONV Malloc_t	Perl_malloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Malloc_t	Perl_calloc(MEM_SIZE elements, MEM_SIZE size)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Malloc_t	Perl_realloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Free_t	Perl_mfree(Malloc_t where);
#if defined(MYMALLOC)
PERL_CALLCONV MEM_SIZE	Perl_malloced_size(void *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

#endif

PERL_CALLCONV void*	Perl_get_context(void)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_set_context(void *thx)
			__attribute__nonnull__(1);


END_EXTERN_C

/* functions with flag 'n' should come before here */
START_EXTERN_C
#  include "pp_proto.h"
PERL_CALLCONV SV*	Perl_amagic_call(pTHX_ SV* left, SV* right, int method, int dir)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_Gv_AMupdate(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV CV*	Perl_gv_handler(pTHX_ HV* stash, I32 id)
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_append_elem(pTHX_ I32 optype, OP* first, OP* last);
PERL_CALLCONV OP*	Perl_append_list(pTHX_ I32 optype, LISTOP* first, LISTOP* last);
PERL_CALLCONV I32	Perl_apply(pTHX_ I32 type, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_apply_attrs_string(pTHX_ const char *stashpv, CV *cv, const char *attrstr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_av_clear(pTHX_ AV* ar)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_av_delete(pTHX_ AV* ar, I32 key, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_av_exists(pTHX_ AV* ar, I32 key)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_av_extend(pTHX_ AV* ar, I32 key)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV AV*	Perl_av_fake(pTHX_ I32 size, SV** svp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SV**	Perl_av_fetch(pTHX_ AV* ar, I32 key, I32 lval)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_av_fill(pTHX_ AV* ar, I32 fill)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_av_len(pTHX_ const AV* ar)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV AV*	Perl_av_make(pTHX_ I32 size, SV** svp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SV*	Perl_av_pop(pTHX_ AV* ar)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_av_create_and_push(pTHX_ AV **const avp, SV *const val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_av_push(pTHX_ AV* ar, SV* val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_av_reify(pTHX_ AV* ar)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_av_shift(pTHX_ AV* ar)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV**	Perl_av_store(pTHX_ AV* ar, I32 key, SV* val)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_av_undef(pTHX_ AV* ar)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV**	Perl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_av_unshift(pTHX_ AV* ar, I32 num)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV**	Perl_av_arylen_p(pTHX_ AV* av)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_bind_match(pTHX_ I32 type, OP* left, OP* pat)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV OP*	Perl_block_end(pTHX_ I32 floor, OP* seq)
			__attribute__warn_unused_result__;

PERL_CALLCONV I32	Perl_block_gimme(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_block_start(pTHX_ int full)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_boot_core_UNIVERSAL(pTHX);
PERL_CALLCONV void	Perl_boot_core_ActivePerl(pTHX);
PERL_CALLCONV void	Perl_boot_core_PerlIO(pTHX);
PERL_CALLCONV void	Perl_call_list(pTHX_ I32 oldscope, AV* av_list)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_cando(pTHX_ Mode_t mode, bool effective, const Stat_t* statbufp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV U32	Perl_cast_ulong(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV I32	Perl_cast_i32(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV IV	Perl_cast_iv(pTHX_ NV f)
			__attribute__warn_unused_result__;

PERL_CALLCONV UV	Perl_cast_uv(pTHX_ NV f)
			__attribute__warn_unused_result__;

#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
PERL_CALLCONV I32	Perl_my_chsize(pTHX_ int fd, Off_t length)
			__attribute__warn_unused_result__;

#endif
PERL_CALLCONV OP*	Perl_convert(pTHX_ I32 optype, I32 flags, OP* o)
			__attribute__warn_unused_result__;

PERL_CALLCONV PERL_CONTEXT*	Perl_create_eval_scope(pTHX_ U32 flags);
PERL_CALLCONV void	Perl_croak(pTHX_ const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);

PERL_CALLCONV void	Perl_vcroak(pTHX_ const char* pat, va_list* args)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1);

#if defined(PERL_IMPLICIT_CONTEXT)
PERL_CALLCONV void	Perl_croak_nocontext(const char* pat, ...)
			__attribute__noreturn__
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV OP*	Perl_die_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV void	Perl_deb_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV char*	Perl_form_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV void	Perl_load_module_nocontext(U32 flags, SV* name, SV* ver, ...)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);

PERL_CALLCONV SV*	Perl_mess_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV void	Perl_warn_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV void	Perl_warner_nocontext(U32 err, const char* pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(2);

PERL_CALLCONV SV*	Perl_newSVpvf_nocontext(const char* pat, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

PERL_CALLCONV void	Perl_sv_catpvf_nocontext(SV* sv, const char* pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

PERL_CALLCONV void	Perl_sv_setpvf_nocontext(SV* sv, const char* pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

PERL_CALLCONV void	Perl_sv_catpvf_mg_nocontext(SV* sv, const char* pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

PERL_CALLCONV void	Perl_sv_setpvf_mg_nocontext(SV* sv, const char* pat, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

PERL_CALLCONV int	Perl_fprintf_nocontext(PerlIO* stream, const char* fmt, ...)
			__attribute__format__(__printf__,2,3)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

PERL_CALLCONV int	Perl_printf_nocontext(const char* fmt, ...)
			__attribute__format__(__printf__,1,2)
			__attribute__nonnull__(1);

#endif
PERL_CALLCONV void	Perl_cv_ckproto(pTHX_ const CV* cv, const GV* gv, const char* p)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_cv_ckproto_len(pTHX_ const CV* cv, const GV* gv, const char* p, const STRLEN len)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV CV*	Perl_cv_clone(pTHX_ CV* proto)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_gv_const_sv(pTHX_ GV* gv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_cv_const_sv(pTHX_ CV* cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_op_const_sv(pTHX_ const OP* o, CV* cv)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_cv_undef(pTHX_ CV* cv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_cx_dump(pTHX_ PERL_CONTEXT* cx)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_filter_add(pTHX_ filter_t funcp, SV* datasv);
PERL_CALLCONV void	Perl_filter_del(pTHX_ filter_t funcp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_filter_read(pTHX_ int idx, SV* buffer, int maxlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char**	Perl_get_op_descs(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV char**	Perl_get_op_names(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV const char*	Perl_get_no_modify(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV U32*	Perl_get_opargs(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV PPADDR_t*	Perl_get_ppaddr(pTHX)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV I32	Perl_cxinc(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_deb(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_vdeb(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_debprofdump(pTHX);
PERL_CALLCONV I32	Perl_debop(pTHX_ const OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_debstack(pTHX);
PERL_CALLCONV I32	Perl_debstackptrs(pTHX);
PERL_CALLCONV char*	Perl_delimcpy(pTHX_ char* to, const char* toend, const char* from, const char* fromend, int delim, I32* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_6);

PERL_CALLCONV void	Perl_delete_eval_scope(pTHX);
PERL_CALLCONV void	Perl_deprecate(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_deprecate_old(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_die(pTHX_ const char* pat, ...)
			__attribute__format__null_ok__(__printf__,pTHX_1,pTHX_2);

PERL_CALLCONV OP*	Perl_vdie(pTHX_ const char* pat, va_list* args);
PERL_CALLCONV OP*	Perl_die_where(pTHX_ const char* message, STRLEN msglen);
PERL_CALLCONV void	Perl_dounwind(pTHX_ I32 cxix);
/* PERL_CALLCONV bool	Perl_do_aexec(pTHX_ SV* really, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3); */

PERL_CALLCONV bool	Perl_do_aexec5(pTHX_ SV* really, SV** mark, SV** sp, int fd, int do_report)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV int	Perl_do_binmode(pTHX_ PerlIO *fp, int iotype, int mode)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_do_chop(pTHX_ SV* asv, SV* sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_do_close(pTHX_ GV* gv, bool not_implicit);
PERL_CALLCONV bool	Perl_do_eof(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);


#ifdef PERL_DEFAULT_DO_EXEC3_IMPLEMENTATION
/* PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd)
			__attribute__nonnull__(pTHX_1); */

#else
PERL_CALLCONV bool	Perl_do_exec(pTHX_ const char* cmd)
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(WIN32) || defined(__SYMBIAN32__)
PERL_CALLCONV int	Perl_do_aspawn(pTHX_ SV* really, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV int	Perl_do_spawn(pTHX_ char* cmd)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_do_spawn_nowait(pTHX_ char* cmd)
			__attribute__nonnull__(pTHX_1);

#endif
#if !defined(WIN32)
PERL_CALLCONV bool	Perl_do_exec3(pTHX_ const char* cmd, int fd, int do_report)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV void	Perl_do_execfree(pTHX);
#ifdef PERL_IN_DOIO_C
STATIC void	S_exec_failed(pTHX_ const char *cmd, int fd, int do_report)
			__attribute__nonnull__(pTHX_1);

#endif
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
PERL_CALLCONV I32	Perl_do_ipcctl(pTHX_ I32 optype, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV I32	Perl_do_ipcget(pTHX_ I32 optype, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV I32	Perl_do_msgrcv(pTHX_ SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_do_msgsnd(pTHX_ SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_do_semop(pTHX_ SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_do_shmio(pTHX_ I32 optype, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#endif
PERL_CALLCONV void	Perl_do_join(pTHX_ SV* sv, SV* del, SV** mark, SV** sp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV OP*	Perl_do_kv(pTHX);
/* PERL_CALLCONV bool	Perl_do_open(pTHX_ GV* gv, const char* name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO* supplied_fp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV bool	Perl_do_open9(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV *svs, I32 num)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_8);

PERL_CALLCONV bool	Perl_do_openn(pTHX_ GV *gv, const char *name, I32 len, int as_raw, int rawmode, int rawperm, PerlIO *supplied_fp, SV **svp, I32 num)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_do_print(pTHX_ SV* sv, PerlIO* fp)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_do_readline(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV I32	Perl_do_chomp(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_do_seek(pTHX_ GV* gv, Off_t pos, int whence);
PERL_CALLCONV void	Perl_do_sprintf(pTHX_ SV* sv, I32 len, SV** sarg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV Off_t	Perl_do_sysseek(pTHX_ GV* gv, Off_t pos, int whence)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV Off_t	Perl_do_tell(pTHX_ GV* gv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_do_trans(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV UV	Perl_do_vecget(pTHX_ SV* sv, I32 offset, I32 size)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_do_vecset(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_do_vop(pTHX_ I32 optype, SV* sv, SV* left, SV* right)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV OP*	Perl_dofile(pTHX_ OP* term, I32 force_builtin)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_dowantarray(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_dump_all(pTHX);
PERL_CALLCONV void	Perl_dump_eval(pTHX);
#if defined(DUMP_FDS)
PERL_CALLCONV void	Perl_dump_fds(pTHX_ char* s)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV void	Perl_dump_form(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_gv_dump(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_op_dump(pTHX_ const OP* arg)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_pmop_dump(pTHX_ PMOP* pm);
PERL_CALLCONV void	Perl_dump_packsubs(pTHX_ const HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_dump_sub(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_fbm_compile(pTHX_ SV* sv, U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_fbm_instr(pTHX_ unsigned char* big, unsigned char* bigend, SV* littlesv, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV char*	Perl_find_script(pTHX_ const char *scriptname, bool dosearch, const char *const *const search_ext, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_force_list(pTHX_ OP* arg);
PERL_CALLCONV OP*	Perl_fold_constants(pTHX_ OP* arg)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_form(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_vform(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_free_tmps(pTHX);
PERL_CALLCONV OP*	Perl_gen_constant_list(pTHX_ OP* o);
#if !defined(HAS_GETENV_LEN)
PERL_CALLCONV char*	Perl_getenv_len(pTHX_ const char* key, unsigned long *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV void	Perl_get_db_sub(pTHX_ SV **svp, CV *cv)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_gp_free(pTHX_ GV* gv);
PERL_CALLCONV GP*	Perl_gp_ref(pTHX_ GP* gp);
PERL_CALLCONV GV*	Perl_gv_AVadd(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV GV*	Perl_gv_HVadd(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV GV*	Perl_gv_IOadd(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV GV*	Perl_gv_autoload4(pTHX_ HV* stash, const char* name, STRLEN len, I32 method)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_gv_check(pTHX_ const HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_gv_efullname(pTHX_ SV* sv, const GV* gv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

/* PERL_CALLCONV void	Perl_gv_efullname3(pTHX_ SV* sv, const GV* gv, const char* prefix)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV void	Perl_gv_efullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV GV*	Perl_gv_fetchfile(pTHX_ const char* name)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV GV*	Perl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN len, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV GV*	Perl_gv_fetchmeth(pTHX_ HV* stash, const char* name, STRLEN len, I32 level)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV GV*	Perl_gv_fetchmeth_autoload(pTHX_ HV* stash, const char* name, STRLEN len, I32 level)
			__attribute__nonnull__(pTHX_2);

/* PERL_CALLCONV GV*	Perl_gv_fetchmethod(pTHX_ HV* stash, const char* name)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV GV*	Perl_gv_fetchmethod_autoload(pTHX_ HV* stash, const char* name, I32 autoload)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV GV*	Perl_gv_fetchpv(pTHX_ const char* name, I32 add, I32 sv_type)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_gv_fullname(pTHX_ SV* sv, const GV* gv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

/* PERL_CALLCONV void	Perl_gv_fullname3(pTHX_ SV* sv, const GV* gv, const char* prefix)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV void	Perl_gv_fullname4(pTHX_ SV* sv, const GV* gv, const char* prefix, bool keepmain)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV GP *	Perl_newGP(pTHX_ GV *const gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_gv_init(pTHX_ GV* gv, HV* stash, const char* name, STRLEN len, int multi)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_gv_name_set(pTHX_ GV* gv, const char *name, U32 len, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV HV*	Perl_gv_stashpv(pTHX_ const char* name, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HV*	Perl_gv_stashpvn(pTHX_ const char* name, U32 namelen, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HV*	Perl_gv_stashsv(pTHX_ SV* sv, I32 flags);
PERL_CALLCONV void	Perl_hv_clear(pTHX_ HV* tb);
PERL_CALLCONV HV *	Perl_hv_copy_hints_hv(pTHX_ HV *const ohv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_hv_delayfree_ent(pTHX_ HV* hv, HE* entry)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV SV*	Perl_hv_delete(pTHX_ HV* tb, const char* key, I32 klen, I32 flags)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV SV*	Perl_hv_delete_ent(pTHX_ HV* tb, SV* key, I32 flags, U32 hash)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV bool	Perl_hv_exists(pTHX_ HV* tb, const char* key, I32 klen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV bool	Perl_hv_exists_ent(pTHX_ HV* tb, SV* key, U32 hash)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV SV**	Perl_hv_fetch(pTHX_ HV* tb, const char* key, I32 klen, I32 lval)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV HE*	Perl_hv_fetch_ent(pTHX_ HV* tb, SV* key, I32 lval, U32 hash)
			__attribute__nonnull__(pTHX_2); */

PERL_CALLCONV void*	Perl_hv_common(pTHX_ HV* tb, SV* keysv, const char* key, STRLEN klen, int flags, int action, SV* val, U32 hash);
PERL_CALLCONV void*	Perl_hv_common_key_len(pTHX_ HV *hv, const char *key, I32 klen_i32, const int action, SV *val, const U32 hash)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_hv_free_ent(pTHX_ HV* hv, HE* entryK)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_hv_iterinit(pTHX_ HV* tb)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_hv_iterkey(pTHX_ HE* entry, I32* retlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SV*	Perl_hv_iterkeysv(pTHX_ HE* entry)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV HE*	Perl_hv_iternext(pTHX_ HV* tb)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV SV*	Perl_hv_iternextsv(pTHX_ HV* hv, char** key, I32* retlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV HE*	Perl_hv_iternext_flags(pTHX_ HV* tb, I32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_hv_iterval(pTHX_ HV* tb, HE* entry)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_hv_ksplit(pTHX_ HV* hv, IV newmax)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV void	Perl_hv_magic(pTHX_ HV* hv, GV* gv, int how)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV HV *	Perl_refcounted_he_chain_2hv(pTHX_ const struct refcounted_he *c);
PERL_CALLCONV SV *	Perl_refcounted_he_fetch(pTHX_ const struct refcounted_he *chain, SV *keysv, const char *key, STRLEN klen, int flags, U32 hash);
PERL_CALLCONV void	Perl_refcounted_he_free(pTHX_ struct refcounted_he *he);
PERL_CALLCONV struct refcounted_he *	Perl_refcounted_he_new(pTHX_ struct refcounted_he *const parent, SV *const key, SV *const value);
/* PERL_CALLCONV SV**	Perl_hv_store(pTHX_ HV* tb, const char* key, I32 klen, SV* val, U32 hash); */
/* PERL_CALLCONV HE*	Perl_hv_store_ent(pTHX_ HV* tb, SV* key, SV* val, U32 hash); */
/* PERL_CALLCONV SV**	Perl_hv_store_flags(pTHX_ HV* tb, const char* key, I32 klen, SV* val, U32 hash, int flags); */
PERL_CALLCONV void	Perl_hv_undef(pTHX_ HV* tb);
PERL_CALLCONV I32	Perl_ibcmp(pTHX_ const char* a, const char* b, I32 len)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_ibcmp_locale(pTHX_ const char* a, const char* b, I32 len)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_ibcmp_utf8(pTHX_ const char* a, char **pe1, UV l1, bool u1, const char* b, char **pe2, UV l2, bool u2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_5);

PERL_CALLCONV bool	Perl_ingroup(pTHX_ Gid_t testgid, bool effective)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_init_argv_symbols(pTHX_ int argc, char **argv)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_init_debugger(pTHX);
PERL_CALLCONV void	Perl_init_stacks(pTHX);
PERL_CALLCONV void	Perl_init_tm(pTHX_ struct tm *ptm)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV U32	Perl_intro_my(pTHX);
PERL_CALLCONV char*	Perl_instr(pTHX_ const char* big, const char* little)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_io_close(pTHX_ IO* io, bool not_implicit)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_invert(pTHX_ OP* cmd)
			__attribute__warn_unused_result__;

PERL_CALLCONV bool	Perl_is_gv_magical(pTHX_ const char *name, STRLEN len, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_is_lvalue_sub(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV U32	Perl_to_uni_upper_lc(pTHX_ U32 c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV U32	Perl_to_uni_title_lc(pTHX_ U32 c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV U32	Perl_to_uni_lower_lc(pTHX_ U32 c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnum(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnumc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_idfirst(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alpha(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_ascii(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_space(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_cntrl(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_graph(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_digit(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_upper(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_lower(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_print(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_punct(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_xdigit(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV UV	Perl_to_uni_upper(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV UV	Perl_to_uni_title(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV UV	Perl_to_uni_lower(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV UV	Perl_to_uni_fold(pTHX_ UV c, U8 *p, STRLEN *lenp)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV bool	Perl_is_uni_alnum_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alnumc_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_idfirst_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_alpha_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_ascii_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_space_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_cntrl_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_graph_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_digit_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_upper_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_lower_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_print_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_punct_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV bool	Perl_is_uni_xdigit_lc(pTHX_ UV c)
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV STRLEN	Perl_is_utf8_char(pTHX_ const U8 *p)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_string(pTHX_ const U8 *s, STRLEN len)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV bool	Perl_is_utf8_string_loc(pTHX_ const U8 *s, STRLEN len, const U8 **p)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV bool	Perl_is_utf8_string_loclen(pTHX_ const U8 *s, STRLEN len, const U8 **ep, STRLEN *el)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_alnum(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_alnumc(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_idfirst(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_idcont(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_alpha(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_ascii(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_space(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_cntrl(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_digit(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_graph(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_upper(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_lower(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_print(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_punct(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_xdigit(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_utf8_mark(pTHX_ const U8 *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_jmaybe(pTHX_ OP* arg)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_keyword(pTHX_ const char* d, I32 len, bool all_keywords)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_leave_scope(pTHX_ I32 base);
PERL_CALLCONV void	Perl_lex_end(pTHX);
PERL_CALLCONV void	Perl_lex_start(pTHX_ SV* line, PerlIO *rsfp, bool new_filter);
PERL_CALLCONV void	Perl_op_null(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_op_clear(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_op_refcnt_lock(pTHX);
PERL_CALLCONV void	Perl_op_refcnt_unlock(pTHX);
PERL_CALLCONV OP*	Perl_linklist(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_list(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_listkids(pTHX_ OP* o);
PERL_CALLCONV void	Perl_load_module(pTHX_ U32 flags, SV* name, SV* ver, ...)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_vload_module(pTHX_ U32 flags, SV* name, SV* ver, va_list* args)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_localize(pTHX_ OP* arg, I32 lexical)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_looks_like_number(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV UV	Perl_grok_bin(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV UV	Perl_grok_hex(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV int	Perl_grok_number(pTHX_ const char *pv, STRLEN len, UV *valuep)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_grok_numeric_radix(pTHX_ const char **sp, const char *send)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV UV	Perl_grok_oct(pTHX_ const char* start, STRLEN* len_p, I32* flags, NV *result)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV int	Perl_magic_clearenv(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_clear_all_env(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_clearhint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_clearpack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_clearsig(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_existspack(pTHX_ SV* sv, const MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_freeregexp(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_freeovrld(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_get(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getarylen(pTHX_ SV* sv, const MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getdefelem(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getnkeys(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getpack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getpos(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getsig(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getsubstr(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_gettaint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getuvar(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_getvec(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV U32	Perl_magic_len(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_nextpack(pTHX_ SV* sv, MAGIC* mg, SV* key)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV U32	Perl_magic_regdata_cnt(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_regdatum_get(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_regdatum_set(pTHX_ SV* sv, MAGIC* mg)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_set(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setamagic(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setarylen(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_freearylen_p(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setbm(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setdbline(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setdefelem(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setenv(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setfm(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_sethint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setisa(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setglob(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setmglob(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setnkeys(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setpack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setpos(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setregexp(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setsig(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setsubstr(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_settaint(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setuvar(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setvec(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_setutf8(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_set_all_env(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV U32	Perl_magic_sizepack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_magic_wipepack(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_magicname(pTHX_ const char* sym, const char* name, I32 namlen)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_markstack_grow(pTHX);
#if defined(USE_LOCALE_COLLATE)
PERL_CALLCONV int	Perl_magic_setcollxfrm(pTHX_ SV* sv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_mem_collxfrm(pTHX_ const char* s, STRLEN len, STRLEN* xlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

#endif
PERL_CALLCONV SV*	Perl_mess(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_vmess(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_qerror(pTHX_ SV* err)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sortsv(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_sortsv_flags(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t cmp, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV int	Perl_mg_clear(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_mg_copy(pTHX_ SV* sv, SV* nsv, const char* key, I32 klen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_mg_localize(pTHX_ SV* sv, SV* nsv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV MAGIC*	Perl_mg_find(pTHX_ const SV* sv, int type)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_mg_free(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_mg_get(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV U32	Perl_mg_length(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_mg_magical(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_mg_set(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_mg_size(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_mini_mktime(pTHX_ struct tm *pm)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_mod(pTHX_ OP* o, I32 type);
PERL_CALLCONV int	Perl_mode_from_discipline(pTHX_ SV* discp);
PERL_CALLCONV const char*	Perl_moreswitches(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_my(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV NV	Perl_my_atof(pTHX_ const char *s)
			__attribute__nonnull__(pTHX_1);

#if (!defined(HAS_MEMCPY) && !defined(HAS_BCOPY)) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY) && !defined(HAS_SAFE_BCOPY))
PERL_CALLCONV char*	Perl_my_bcopy(const char* from, char* to, I32 len)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
PERL_CALLCONV char*	Perl_my_bzero(char* loc, I32 len)
			__attribute__nonnull__(1);

#endif
PERL_CALLCONV void	Perl_my_exit(pTHX_ U32 status)
			__attribute__noreturn__;

PERL_CALLCONV void	Perl_my_failure_exit(pTHX)
			__attribute__noreturn__;

PERL_CALLCONV I32	Perl_my_fflush_all(pTHX);
PERL_CALLCONV Pid_t	Perl_my_fork(void);
PERL_CALLCONV void	Perl_atfork_lock(void);
PERL_CALLCONV void	Perl_atfork_unlock(void);
PERL_CALLCONV I32	Perl_my_lstat(pTHX);
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
PERL_CALLCONV I32	Perl_my_memcmp(const char* s1, const char* s2, I32 len)
			__attribute__pure__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

#endif
#if !defined(HAS_MEMSET)
PERL_CALLCONV void*	Perl_my_memset(char* loc, I32 ch, I32 len)
			__attribute__nonnull__(1);

#endif
PERL_CALLCONV I32	Perl_my_pclose(pTHX_ PerlIO* ptr);
PERL_CALLCONV PerlIO*	Perl_my_popen(pTHX_ const char* cmd, const char* mode)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV PerlIO*	Perl_my_popen_list(pTHX_ char* mode, int n, SV ** args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_my_setenv(pTHX_ const char* nam, const char* val);
PERL_CALLCONV I32	Perl_my_stat(pTHX);
PERL_CALLCONV char *	Perl_my_strftime(pTHX_ const char *fmt, int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst)
			__attribute__nonnull__(pTHX_1);

#if defined(MYSWAP)
PERL_CALLCONV short	Perl_my_swap(pTHX_ short s)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV long	Perl_my_htonl(pTHX_ long l)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__pure__;

PERL_CALLCONV long	Perl_my_ntohl(pTHX_ long l)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__pure__;

#endif
PERL_CALLCONV void	Perl_my_unexec(pTHX);
PERL_CALLCONV OP*	Perl_newANONLIST(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newANONHASH(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newANONSUB(pTHX_ I32 floor, OP* proto, OP* block);
PERL_CALLCONV OP*	Perl_newASSIGNOP(pTHX_ I32 flags, OP* left, I32 optype, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newCONDOP(pTHX_ I32 flags, OP* first, OP* trueop, OP* falseop)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV CV*	Perl_newCONSTSUB(pTHX_ HV* stash, const char* name, SV* sv);
#ifdef PERL_MAD
PERL_CALLCONV OP*	Perl_newFORM(pTHX_ I32 floor, OP* o, OP* block);
#else
PERL_CALLCONV void	Perl_newFORM(pTHX_ I32 floor, OP* o, OP* block);
#endif
PERL_CALLCONV OP*	Perl_newFOROP(pTHX_ I32 flags, char* label, line_t forline, OP* sv, OP* expr, OP* block, OP* cont)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_5);

PERL_CALLCONV OP*	Perl_newGIVENOP(pTHX_ OP* cond, OP* block, PADOFFSET defsv_off)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_newLOGOP(pTHX_ I32 optype, I32 flags, OP* left, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV OP*	Perl_newLOOPEX(pTHX_ I32 type, OP* label)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_newLOOPOP(pTHX_ I32 flags, I32 debuggable, OP* expr, OP* block)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newNULLLIST(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newOP(pTHX_ I32 optype, I32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_newPROG(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_newRANGE(pTHX_ I32 flags, OP* left, OP* right)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV OP*	Perl_newSLICEOP(pTHX_ I32 flags, OP* subscript, OP* listop)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newSTATEOP(pTHX_ I32 flags, char* label, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV CV*	Perl_newSUB(pTHX_ I32 floor, OP* o, OP* proto, OP* block);
PERL_CALLCONV CV *	Perl_newXS_flags(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV CV*	Perl_newXS(pTHX_ const char* name, XSUBADDR_t f, const char* filename)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV AV*	Perl_newAV(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newAVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_newBINOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newCVREF(pTHX_ I32 flags, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newGVOP(pTHX_ I32 type, I32 flags, GV* gv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV GV*	Perl_newGVgen(pTHX_ const char* pack)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_newGVREF(pTHX_ I32 type, OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newHVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HV*	Perl_newHV(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV HV*	Perl_newHVhv(pTHX_ HV* hv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV IO*	Perl_newIO(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newLISTOP(pTHX_ I32 type, I32 flags, OP* first, OP* last)
			__attribute__malloc__
			__attribute__warn_unused_result__;

#ifdef USE_ITHREADS
PERL_CALLCONV OP*	Perl_newPADOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);

#endif
PERL_CALLCONV OP*	Perl_newPMOP(pTHX_ I32 type, I32 flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newPVOP(pTHX_ I32 type, I32 flags, char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newRV(pTHX_ SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_newRV_noinc(pTHX_ SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_newSV(pTHX_ STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newSVREF(pTHX_ OP* o)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_newSVOP(pTHX_ I32 type, I32 flags, SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV SV*	Perl_newSViv(pTHX_ IV i)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVuv(pTHX_ UV u)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVnv(pTHX_ NV n)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpv(pTHX_ const char* s, STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvn(pTHX_ const char* s, STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVhek(pTHX_ const HEK *hek)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvn_share(pTHX_ const char* s, I32 len, U32 hash)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSVpvf(pTHX_ const char* pat, ...)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_vnewSVpvf(pTHX_ const char* pat, va_list* args)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_newSVrv(pTHX_ SV* rv, const char* classname)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_newSVsv(pTHX_ SV* old)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_newSV_type(pTHX_ svtype type)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newUNOP(pTHX_ I32 type, I32 flags, OP* first)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV OP*	Perl_newWHENOP(pTHX_ OP* cond, OP* block)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_newWHILEOP(pTHX_ I32 flags, I32 debuggable, LOOP* loop, I32 whileline, OP* expr, OP* block, OP* cont, I32 has_my)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV PERL_SI*	Perl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_scan_vstring(pTHX_ const char *vstr, const char *end, SV *sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV const char*	Perl_scan_version(pTHX_ const char *vstr, SV *sv, bool qv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SV*	Perl_new_version(pTHX_ SV *ver)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_upg_version(pTHX_ SV *ver, bool qv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_vverify(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_vnumify(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_vnormal(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_vstringify(pTHX_ SV *vs)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_vcmp(pTHX_ SV *lvs, SV *rvs)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV PerlIO*	Perl_nextargv(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_ninstr(pTHX_ const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV OP*	Perl_oopsCV(pTHX_ OP* o)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_op_free(pTHX_ OP* arg);
#ifdef PERL_MAD
PERL_CALLCONV OP*	Perl_package(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

#else
PERL_CALLCONV void	Perl_package(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV PADOFFSET	Perl_pad_alloc(pTHX_ I32 optype, U32 tmptype);
PERL_CALLCONV PADOFFSET	Perl_allocmy(pTHX_ const char *const name)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV PADOFFSET	Perl_pad_findmy(pTHX_ const char* name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV PADOFFSET	Perl_find_rundefsvoffset(pTHX);
PERL_CALLCONV OP*	Perl_oopsAV(pTHX_ OP* o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_oopsHV(pTHX_ OP* o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_pad_leavemy(pTHX);
PERL_CALLCONV SV*	Perl_pad_sv(pTHX_ PADOFFSET po);
PERL_CALLCONV void	Perl_pad_free(pTHX_ PADOFFSET po);
PERL_CALLCONV void	Perl_pad_reset(pTHX);
PERL_CALLCONV void	Perl_pad_swipe(pTHX_ PADOFFSET po, bool refadjust);
PERL_CALLCONV void	Perl_peep(pTHX_ OP* o);
PERL_CALLCONV PerlIO*	Perl_start_glob(pTHX_ SV* pattern, IO *io)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#if defined(USE_REENTRANT_API)
PERL_CALLCONV void	Perl_reentrant_size(pTHX);
PERL_CALLCONV void	Perl_reentrant_init(pTHX);
PERL_CALLCONV void	Perl_reentrant_free(pTHX);
PERL_CALLCONV void*	Perl_reentrant_retry(const char*, ...)
			__attribute__nonnull__(1);

#endif
PERL_CALLCONV void	Perl_call_atexit(pTHX_ ATEXIT_t fn, void *ptr);
PERL_CALLCONV I32	Perl_call_argv(pTHX_ const char* sub_name, I32 flags, char** argv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV I32	Perl_call_method(pTHX_ const char* methname, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_call_pv(pTHX_ const char* sub_name, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_call_sv(pTHX_ SV* sv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_despatch_signals(pTHX);
PERL_CALLCONV OP *	Perl_doref(pTHX_ OP *o, I32 type, bool set_op_ref)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_eval_pv(pTHX_ const char* p, I32 croak_on_error)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_eval_sv(pTHX_ SV* sv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_get_sv(pTHX_ const char* name, I32 create)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV AV*	Perl_get_av(pTHX_ const char* name, I32 create)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HV*	Perl_get_hv(pTHX_ const char* name, I32 create)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV CV*	Perl_get_cv(pTHX_ const char* name, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV CV*	Perl_get_cvn_flags(pTHX_ const char* name, STRLEN len, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_init_i18nl10n(pTHX_ int printwarn);
PERL_CALLCONV int	Perl_init_i18nl14n(pTHX_ int printwarn);
PERL_CALLCONV void	Perl_new_collate(pTHX_ const char* newcoll);
PERL_CALLCONV void	Perl_new_ctype(pTHX_ const char* newctype)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_new_numeric(pTHX_ const char* newcoll);
PERL_CALLCONV void	Perl_set_numeric_local(pTHX);
PERL_CALLCONV void	Perl_set_numeric_radix(pTHX);
PERL_CALLCONV void	Perl_set_numeric_standard(pTHX);
PERL_CALLCONV void	Perl_require_pv(pTHX_ const char* pv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_pack_cat(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist, SV ***next_in_list, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5)
			__attribute__nonnull__(pTHX_6);

PERL_CALLCONV void	Perl_packlist(pTHX_ SV *cat, const char *pat, const char *patend, SV **beglist, SV **endlist)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

#ifdef PERL_USES_PL_PIDSTATUS
PERL_CALLCONV void	Perl_pidgone(pTHX_ Pid_t pid, int status);
#endif
PERL_CALLCONV void	Perl_pmflag(pTHX_ U32* pmfl, int ch)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_pmruntime(pTHX_ OP* pm, OP* expr, bool isreg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_pmtrans(pTHX_ OP* o, OP* expr, OP* repl)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_pop_scope(pTHX);
PERL_CALLCONV OP*	Perl_prepend_elem(pTHX_ I32 optype, OP* head, OP* tail);
PERL_CALLCONV void	Perl_push_scope(pTHX);
/* PERL_CALLCONV OP*	Perl_ref(pTHX_ OP* o, I32 type); */
PERL_CALLCONV OP*	Perl_refkids(pTHX_ OP* o, I32 type);
PERL_CALLCONV void	Perl_regdump(pTHX_ const regexp* r)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_regdump(pTHX_ const regexp* r)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_regclass_swash(pTHX_ const regexp *prog, const struct regnode *n, bool doinit, SV **listsvp, SV **altsvp)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_pregexec(pTHX_ REGEXP * const prog, char* stringarg, char* strend, char* strbeg, I32 minend, SV* screamer, U32 nosave)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_6);

PERL_CALLCONV void	Perl_pregfree(pTHX_ struct regexp* r);
PERL_CALLCONV struct regexp*	Perl_reg_temp_copy(pTHX_ struct regexp* r)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_regfree_internal(pTHX_ REGEXP * const r);
PERL_CALLCONV char *	Perl_reg_stringify(pTHX_ MAGIC *mg, STRLEN *lp, U32 *flags, I32 *haseval)
			__attribute__nonnull__(pTHX_1);

#if defined(USE_ITHREADS)
PERL_CALLCONV void*	Perl_regdupe_internal(pTHX_ REGEXP * const r, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV REGEXP*	Perl_pregcomp(pTHX_ const SV * const pattern, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV REGEXP*	Perl_re_compile(pTHX_ const SV * const pattern, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_re_intuit_start(pTHX_ REGEXP * const rx, SV* sv, char* strpos, char* strend, const U32 flags, re_scream_pos_data *data)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV SV*	Perl_re_intuit_string(pTHX_ REGEXP * const rx)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_regexec_flags(pTHX_ REGEXP * const rx, char* stringarg, char* strend, char* strbeg, I32 minend, SV* screamer, void* data, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_6);

PERL_CALLCONV regnode*	Perl_regnext(pTHX_ regnode* p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV SV*	Perl_reg_named_buff(pTHX_ REGEXP * const rx, SV * const key, SV * const value, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_reg_named_buff_iter(pTHX_ REGEXP * const rx, const SV * const lastkey, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_reg_named_buff_fetch(pTHX_ REGEXP * const rx, SV * const namesv, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_reg_named_buff_exists(pTHX_ REGEXP * const rx, SV * const key, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SV*	Perl_reg_named_buff_firstkey(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_reg_named_buff_nextkey(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_reg_named_buff_scalar(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_reg_named_buff_all(pTHX_ REGEXP * const rx, const U32 flags)
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV void	Perl_reg_numbered_buff_fetch(pTHX_ REGEXP * const rx, const I32 paren, SV * const sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_reg_numbered_buff_store(pTHX_ REGEXP * const rx, const I32 paren, SV const * const value)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_reg_numbered_buff_length(pTHX_ REGEXP * const rx, const SV * const sv, const I32 paren)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);


PERL_CALLCONV SV*	Perl_reg_qr_package(pTHX_ REGEXP * const rx)
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV void	Perl_regprop(pTHX_ const regexp *prog, SV* sv, const regnode* o)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_repeatcpy(pTHX_ char* to, const char* from, I32 len, I32 count)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_rninstr(pTHX_ const char* big, const char* bigend, const char* little, const char* lend)
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV Sighandler_t	Perl_rsignal(pTHX_ int i, Sighandler_t t);
PERL_CALLCONV int	Perl_rsignal_restore(pTHX_ int i, Sigsave_t* t);
PERL_CALLCONV int	Perl_rsignal_save(pTHX_ int i, Sighandler_t t1, Sigsave_t* t2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV Sighandler_t	Perl_rsignal_state(pTHX_ int i);
PERL_CALLCONV void	Perl_rxres_free(pTHX_ void** rsp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_rxres_restore(pTHX_ void** rsp, REGEXP* prx)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_rxres_save(pTHX_ void** rsp, REGEXP* prx)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#if !defined(HAS_RENAME)
PERL_CALLCONV I32	Perl_same_dirent(pTHX_ const char* a, const char* b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV char*	Perl_savepv(pTHX_ const char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savepvn(pTHX_ const char* pv, I32 len)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedpv(pTHX_ const char* pv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_savesharedpvn(pTHX_ const char *const pv, const STRLEN len)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_savesvpv(pTHX_ SV* sv)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_savestack_grow(pTHX);
PERL_CALLCONV void	Perl_savestack_grow_cnt(pTHX_ I32 need);
PERL_CALLCONV void	Perl_save_aelem(pTHX_ AV* av, I32 idx, SV **sptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV I32	Perl_save_alloc(pTHX_ I32 size, I32 pad);
PERL_CALLCONV void	Perl_save_aptr(pTHX_ AV** aptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV AV*	Perl_save_ary(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_bool(pTHX_ bool* boolp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_clearsv(pTHX_ SV** svp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_delete(pTHX_ HV* hv, char* key, I32 klen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p);
PERL_CALLCONV void	Perl_save_freesv(pTHX_ SV* sv);
PERL_CALLCONV void	Perl_save_freeop(pTHX_ OP* o);
PERL_CALLCONV void	Perl_save_freepv(pTHX_ char* pv);
PERL_CALLCONV void	Perl_save_generic_svref(pTHX_ SV** sptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_generic_pvref(pTHX_ char** str)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_shared_pvref(pTHX_ char** str)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_gp(pTHX_ GV* gv, I32 empty)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HV*	Perl_save_hash(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_helem(pTHX_ HV* hv, SV *key, SV **sptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_save_hptr(pTHX_ HV** hptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_I16(pTHX_ I16* intp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_I32(pTHX_ I32* intp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_I8(pTHX_ I8* bytep)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_int(pTHX_ int* intp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_item(pTHX_ SV* item)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_iv(pTHX_ IV* iv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_list(pTHX_ SV** sarg, I32 maxsarg)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_long(pTHX_ long* longp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_mortalizesv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_nogv(pTHX_ GV* gv);
PERL_CALLCONV void	Perl_save_op(pTHX);
PERL_CALLCONV SV*	Perl_save_scalar(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_pptr(pTHX_ char** pptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_vptr(pTHX_ void* pptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_save_re_context(pTHX);
PERL_CALLCONV void	Perl_save_padsv(pTHX_ PADOFFSET off);
PERL_CALLCONV void	Perl_save_sptr(pTHX_ SV** sptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_save_svref(pTHX_ SV** sptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_sawparens(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalar(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalarkids(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalarseq(pTHX_ OP* o);
PERL_CALLCONV OP*	Perl_scalarvoid(pTHX_ OP* o)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV NV	Perl_scan_bin(pTHX_ const char* start, STRLEN len, STRLEN* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV NV	Perl_scan_hex(pTHX_ const char* start, STRLEN len, STRLEN* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV char*	Perl_scan_num(pTHX_ const char* s, YYSTYPE *lvalp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV NV	Perl_scan_oct(pTHX_ const char* start, STRLEN len, STRLEN* retlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV OP*	Perl_scope(pTHX_ OP* o);
PERL_CALLCONV char*	Perl_screaminstr(pTHX_ SV *bigstr, SV *littlestr, I32 start_shift, I32 end_shift, I32 *oldposp, I32 last)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5);

#if !defined(VMS)
PERL_CALLCONV I32	Perl_setenv_getix(pTHX_ const char* nam)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV void	Perl_setdefout(pTHX_ GV* gv);
PERL_CALLCONV HEK*	Perl_share_hek(pTHX_ const char* str, I32 len, U32 hash)
			__attribute__nonnull__(pTHX_1);

#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
PERL_CALLCONV Signal_t	Perl_sighandler(int sig, siginfo_t *info, void *uap);
PERL_CALLCONV Signal_t	Perl_csighandler(int sig, siginfo_t *info, void *uap);
#else
PERL_CALLCONV Signal_t	Perl_sighandler(int sig);
PERL_CALLCONV Signal_t	Perl_csighandler(int sig);
#endif
PERL_CALLCONV SV**	Perl_stack_grow(pTHX_ SV** sp, SV** p, int n)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_start_subparse(pTHX_ I32 is_format, U32 flags);
PERL_CALLCONV void	Perl_sub_crush_depth(pTHX_ CV* cv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_sv_2bool(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV CV*	Perl_sv_2cv(pTHX_ SV* sv, HV** st, GV** gvp, I32 lref)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV IO*	Perl_sv_2io(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

#ifdef PERL_IN_SV_C
STATIC bool	S_glob_2number(pTHX_ GV* const gv)
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_glob_2pv(pTHX_ GV* const gv, STRLEN * const len)
			__attribute__nonnull__(pTHX_1);

#endif
/* PERL_CALLCONV IV	Perl_sv_2iv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV IV	Perl_sv_2iv_flags(pTHX_ SV* sv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_2mortal(pTHX_ SV* sv);
PERL_CALLCONV NV	Perl_sv_2nv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_2num(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV char*	Perl_sv_2pv(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV char*	Perl_sv_2pv_flags(pTHX_ SV* sv, STRLEN* lp, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_2pvutf8(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_2pvbyte(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_pvn_nomg(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV UV	Perl_sv_2uv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV UV	Perl_sv_2uv_flags(pTHX_ SV* sv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV IV	Perl_sv_iv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV UV	Perl_sv_uv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV NV	Perl_sv_nv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_pvn(pTHX_ SV *sv, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_sv_pvutf8n(pTHX_ SV *sv, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_sv_pvbyten(pTHX_ SV *sv, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_sv_true(pTHX_ SV *sv);
PERL_CALLCONV void	Perl_sv_add_arena(pTHX_ char* ptr, U32 size, U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_sv_backoff(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_bless(pTHX_ SV* sv, HV* stash)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_catpvf(pTHX_ SV* sv, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_vcatpvf(pTHX_ SV* sv, const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_catpv(pTHX_ SV* sv, const char* ptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

/* PERL_CALLCONV void	Perl_sv_catpvn(pTHX_ SV* sv, const char* ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV void	Perl_sv_catsv(pTHX_ SV* dsv, SV* ssv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV void	Perl_sv_chop(pTHX_ SV* sv, const char* ptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_sv_clean_all(pTHX);
PERL_CALLCONV void	Perl_sv_clean_objs(pTHX);
PERL_CALLCONV void	Perl_sv_clear(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_sv_cmp(pTHX_ SV* sv1, SV* sv2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_sv_cmp_locale(pTHX_ SV* sv1, SV* sv2)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#if defined(USE_LOCALE_COLLATE)
PERL_CALLCONV char*	Perl_sv_collxfrm(pTHX_ SV* sv, STRLEN* nxp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV OP*	Perl_sv_compile_2op(pTHX_ SV* sv, OP** startp, const char* code, PAD** padp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV int	Perl_getcwd_sv(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_dec(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_dump(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_sv_derived_from(pTHX_ SV* sv, const char* name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_sv_does(pTHX_ SV* sv, const char* name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV I32	Perl_sv_eq(pTHX_ SV* sv1, SV* sv2);
PERL_CALLCONV void	Perl_sv_free(pTHX_ SV* sv);
PERL_CALLCONV void	Perl_sv_free2(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_free_arenas(pTHX);
PERL_CALLCONV char*	Perl_sv_gets(pTHX_ SV* sv, PerlIO* fp, I32 append)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_sv_grow(pTHX_ SV* sv, STRLEN newlen)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_inc(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_insert(pTHX_ SV* bigsv, STRLEN offset, STRLEN len, const char* little, STRLEN littlelen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV int	Perl_sv_isa(pTHX_ SV* sv, const char* name)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_sv_isobject(pTHX_ SV* sv);
PERL_CALLCONV STRLEN	Perl_sv_len(pTHX_ SV* sv);
PERL_CALLCONV STRLEN	Perl_sv_len_utf8(pTHX_ SV* sv);
PERL_CALLCONV void	Perl_sv_magic(pTHX_ SV* sv, SV* obj, int how, const char* name, I32 namlen)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV MAGIC *	Perl_sv_magicext(pTHX_ SV* sv, SV* obj, int how, const MGVTBL *vtbl, const char* name, I32 namlen)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_mortalcopy(pTHX_ SV* oldsv)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_sv_newmortal(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV SV*	Perl_sv_newref(pTHX_ SV* sv);
PERL_CALLCONV char*	Perl_sv_peek(pTHX_ SV* sv);
PERL_CALLCONV void	Perl_sv_pos_u2b(pTHX_ SV* sv, I32* offsetp, I32* lenp)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_pos_b2u(pTHX_ SV* sv, I32* offsetp)
			__attribute__nonnull__(pTHX_2);

/* PERL_CALLCONV char*	Perl_sv_pvn_force(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV char*	Perl_sv_pvutf8n_force(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_pvbyten_force(pTHX_ SV* sv, STRLEN* lp)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_recode_to_utf8(pTHX_ SV* sv, SV *encoding)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV bool	Perl_sv_cat_decode(pTHX_ SV* dsv, SV *encoding, SV *ssv, int *offset, char* tstr, int tlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

PERL_CALLCONV const char*	Perl_sv_reftype(pTHX_ const SV* sv, int ob)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_replace(pTHX_ SV* sv, SV* nsv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_report_used(pTHX);
PERL_CALLCONV void	Perl_sv_reset(pTHX_ const char* s, HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setpvf(pTHX_ SV* sv, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_vsetpvf(pTHX_ SV* sv, const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_setiv(pTHX_ SV* sv, IV num)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setpviv(pTHX_ SV* sv, IV num)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setuv(pTHX_ SV* sv, UV num)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setnv(pTHX_ SV* sv, NV num)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_setref_iv(pTHX_ SV* rv, const char* classname, IV iv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_setref_uv(pTHX_ SV* rv, const char* classname, UV uv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_setref_nv(pTHX_ SV* rv, const char* classname, NV nv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_setref_pv(pTHX_ SV* rv, const char* classname, void* pv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_sv_setref_pvn(pTHX_ SV* rv, const char* classname, const char* pv, STRLEN n)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_sv_setpv(pTHX_ SV* sv, const char* ptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setpvn(pTHX_ SV* sv, const char* ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV void	Perl_sv_setsv(pTHX_ SV* dsv, SV* ssv)
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV void	Perl_sv_taint(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV bool	Perl_sv_tainted(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_sv_unmagic(pTHX_ SV* sv, int type)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV void	Perl_sv_unref(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV void	Perl_sv_unref_flags(pTHX_ SV* sv, U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_untaint(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_upgrade(pTHX_ SV* sv, svtype new_type)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV void	Perl_sv_usepvn(pTHX_ SV* sv, char* ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV void	Perl_sv_usepvn_flags(pTHX_ SV* sv, char* ptr, STRLEN len, U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_vcatpvfn(pTHX_ SV* sv, const char* pat, STRLEN patlen, va_list* args, SV** svargs, I32 svmax, bool *maybe_tainted)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_vsetpvfn(pTHX_ SV* sv, const char* pat, STRLEN patlen, va_list* args, SV** svargs, I32 svmax, bool *maybe_tainted)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV NV	Perl_str_to_version(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV SV*	Perl_swash_init(pTHX_ const char* pkg, const char* name, SV* listsv, I32 minbits, I32 none)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV UV	Perl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_taint_env(pTHX);
PERL_CALLCONV void	Perl_taint_proper(pTHX_ const char* f, const char* s)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV UV	Perl_to_utf8_case(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, SV **swashp, const char *normal, const char *special)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5)
			__attribute__nonnull__(pTHX_6);

PERL_CALLCONV UV	Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV UV	Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV UV	Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV UV	Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#if defined(UNLINK_ALL_VERSIONS)
PERL_CALLCONV I32	Perl_unlnk(pTHX_ const char* f)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV I32	Perl_unpack_str(pTHX_ const char *pat, const char *patend, const char *s, const char *strbeg, const char *strend, char **new_s, I32 ocnt, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);

PERL_CALLCONV I32	Perl_unpackstring(pTHX_ const char *pat, const char *patend, const char *s, const char *strend, U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV void	Perl_unsharepvn(pTHX_ const char* sv, I32 len, U32 hash);
PERL_CALLCONV void	Perl_unshare_hek(pTHX_ HEK* hek);
#ifdef PERL_MAD
PERL_CALLCONV OP *	Perl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg)
			__attribute__nonnull__(pTHX_4);

#else
PERL_CALLCONV void	Perl_utilize(pTHX_ int aver, I32 floor, OP* version, OP* idop, OP* arg)
			__attribute__nonnull__(pTHX_4);

#endif
PERL_CALLCONV U8*	Perl_utf16_to_utf8(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV U8*	Perl_utf16_to_utf8_reversed(pTHX_ U8* p, U8 *d, I32 bytelen, I32 *newlen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV STRLEN	Perl_utf8_length(pTHX_ const U8* s, const U8 *e)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV IV	Perl_utf8_distance(pTHX_ const U8 *a, const U8 *b)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV U8*	Perl_utf8_hop(pTHX_ const U8 *s, I32 off)
			__attribute__warn_unused_result__
			__attribute__pure__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV U8*	Perl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV U8*	Perl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *len, bool *is_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV U8*	Perl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV UV	Perl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV UV	Perl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
			__attribute__nonnull__(pTHX_1);


#ifdef EBCDIC
PERL_CALLCONV UV	Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
			__attribute__nonnull__(pTHX_1);

#else
/* PERL_CALLCONV UV	Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
			__attribute__nonnull__(pTHX_1); */

#endif

PERL_CALLCONV UV	Perl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
			__attribute__nonnull__(pTHX_1);


#ifdef EBCDIC
PERL_CALLCONV U8*	Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv)
			__attribute__nonnull__(pTHX_1);

#else
/* PERL_CALLCONV U8*	Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv)
			__attribute__nonnull__(pTHX_1); */

#endif

/* PERL_CALLCONV U8*	Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV U8*	Perl_uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV U8*	Perl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_vivify_defelem(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_vivify_ref(pTHX_ SV* sv, U32 to_what)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_wait4pid(pTHX_ Pid_t pid, int* statusp, int flags)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV U32	Perl_parse_unicode_opts(pTHX_ const char **popt)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV U32	Perl_seed(pTHX);
PERL_CALLCONV UV	Perl_get_hash_seed(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_report_evil_fh(pTHX_ const GV *gv, const IO *io, I32 op);
PERL_CALLCONV void	Perl_report_uninit(pTHX_ SV* uninit_sv);
PERL_CALLCONV void	Perl_warn(pTHX_ const char* pat, ...)
			__attribute__format__(__printf__,pTHX_1,pTHX_2)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_vwarn(pTHX_ const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_warner(pTHX_ U32 err, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_vwarner(pTHX_ U32 err, const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_watch(pTHX_ char** addr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_whichsig(pTHX_ const char* sig)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_write_to_stderr(pTHX_ const char* message, int msglen)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_yyerror(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_yylex(pTHX);
PERL_CALLCONV int	Perl_yyparse(pTHX);
PERL_CALLCONV void	Perl_parser_free(pTHX_ const yy_parser *)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_yywarn(pTHX_ const char* s)
			__attribute__nonnull__(pTHX_1);

#if defined(MYMALLOC)
PERL_CALLCONV void	Perl_dump_mstats(pTHX_ char* s)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_get_mstats(pTHX_ perl_mstats_t *buf, int buflen, int level)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV Malloc_t	Perl_safesysmalloc(MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Malloc_t	Perl_safesyscalloc(MEM_SIZE elements, MEM_SIZE size)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Malloc_t	Perl_safesysrealloc(Malloc_t where, MEM_SIZE nbytes)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV Free_t	Perl_safesysfree(Malloc_t where);
#if defined(PERL_GLOBAL_STRUCT)
PERL_CALLCONV struct perl_vars *	Perl_GetVars(pTHX);
PERL_CALLCONV struct perl_vars*	Perl_init_global_struct(pTHX);
PERL_CALLCONV void	Perl_free_global_struct(pTHX_ struct perl_vars *plvarsp)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV int	Perl_runops_standard(pTHX);
PERL_CALLCONV int	Perl_runops_debug(pTHX);
PERL_CALLCONV void	Perl_sv_catpvf_mg(pTHX_ SV *sv, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_vcatpvf_mg(pTHX_ SV* sv, const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_catpv_mg(pTHX_ SV *sv, const char *ptr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

/* PERL_CALLCONV void	Perl_sv_catpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2); */

/* PERL_CALLCONV void	Perl_sv_catsv_mg(pTHX_ SV *dstr, SV *sstr)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV void	Perl_sv_setpvf_mg(pTHX_ SV *sv, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_2,pTHX_3)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_vsetpvf_mg(pTHX_ SV* sv, const char* pat, va_list* args)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_setiv_mg(pTHX_ SV *sv, IV i)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setpviv_mg(pTHX_ SV *sv, IV iv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setuv_mg(pTHX_ SV *sv, UV u)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setnv_mg(pTHX_ SV *sv, NV num)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setpv_mg(pTHX_ SV *sv, const char *ptr)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_setpvn_mg(pTHX_ SV *sv, const char *ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_setsv_mg(pTHX_ SV *dstr, SV *sstr)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV void	Perl_sv_usepvn_mg(pTHX_ SV *sv, char *ptr, STRLEN len)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV MGVTBL*	Perl_get_vtbl(pTHX_ int vtbl_id)
			__attribute__warn_unused_result__;

PERL_CALLCONV char*	Perl_pv_display(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_pv_escape(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, STRLEN * const escaped, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_pv_pretty(pTHX_ SV *dsv, char const * const str, const STRLEN count, const STRLEN max, char const * const start_color, char const * const end_color, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_dump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_dump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_do_gv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_do_gvgv_dump(pTHX_ I32 level, PerlIO *file, const char *name, GV *sv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_do_hv_dump(pTHX_ I32 level, PerlIO *file, const char *name, HV *sv)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_do_magic_dump(pTHX_ I32 level, PerlIO *file, const MAGIC *mg, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_do_op_dump(pTHX_ I32 level, PerlIO *file, const OP *o)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_do_pmop_dump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_do_sv_dump(pTHX_ I32 level, PerlIO *file, SV *sv, I32 nest, I32 maxnest, bool dumpops, STRLEN pvlim)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_magic_dump(pTHX_ const MAGIC *mg);
PERL_CALLCONV void	Perl_reginitcolors(pTHX);
/* PERL_CALLCONV char*	Perl_sv_2pv_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV char*	Perl_sv_2pvutf8_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV char*	Perl_sv_2pvbyte_nolen(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV char*	Perl_sv_pv(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV char*	Perl_sv_pvutf8(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV char*	Perl_sv_pvbyte(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1); */

/* PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV bool	Perl_sv_utf8_downgrade(pTHX_ SV *sv, bool fail_ok)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_utf8_encode(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_sv_utf8_decode(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

/* PERL_CALLCONV void	Perl_sv_force_normal(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1); */

PERL_CALLCONV void	Perl_sv_force_normal_flags(pTHX_ SV *sv, U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_tmps_grow(pTHX_ I32 n);
PERL_CALLCONV SV*	Perl_sv_rvweaken(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV OP*	Perl_newANONATTRSUB(pTHX_ I32 floor, OP *proto, OP *attrs, OP *block);
PERL_CALLCONV CV*	Perl_newATTRSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block);
#ifdef PERL_MAD
PERL_CALLCONV OP *	Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
			__attribute__noreturn__;

#else
PERL_CALLCONV void	Perl_newMYSUB(pTHX_ I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
			__attribute__noreturn__;

#endif
PERL_CALLCONV OP *	Perl_my_attrs(pTHX_ OP *o, OP *attrs)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_boot_core_xsutils(pTHX);
#if defined(USE_ITHREADS)
PERL_CALLCONV PERL_CONTEXT*	Perl_cx_dup(pTHX_ PERL_CONTEXT* cx, I32 ix, I32 max, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_4);

PERL_CALLCONV PERL_SI*	Perl_si_dup(pTHX_ PERL_SI* si, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV ANY*	Perl_ss_dup(pTHX_ PerlInterpreter* proto_perl, CLONE_PARAMS* param)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void*	Perl_any_dup(pTHX_ void* v, const PerlInterpreter* proto_perl)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV HE*	Perl_he_dup(pTHX_ const HE* e, bool shared, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV HEK*	Perl_hek_dup(pTHX_ HEK* e, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV REGEXP*	Perl_re_dup(pTHX_ const REGEXP* r, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV PerlIO*	Perl_fp_dup(pTHX_ PerlIO* fp, char type, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV DIR*	Perl_dirp_dup(pTHX_ DIR* dp)
			__attribute__warn_unused_result__;

PERL_CALLCONV GP*	Perl_gp_dup(pTHX_ GP* gp, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV MAGIC*	Perl_mg_dup(pTHX_ MAGIC* mg, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SV*	Perl_sv_dup(pTHX_ const SV* sstr, CLONE_PARAMS* param)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_rvpv_dup(pTHX_ SV* dstr, const SV *sstr, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV yy_parser*	Perl_parser_dup(pTHX_ const yy_parser *proto, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV PTR_TBL_t*	Perl_ptr_table_new(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void*	Perl_ptr_table_fetch(pTHX_ PTR_TBL_t *tbl, const void *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_ptr_table_store(pTHX_ PTR_TBL_t *tbl, const void *oldsv, void *newsv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_ptr_table_split(pTHX_ PTR_TBL_t *tbl)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_ptr_table_clear(pTHX_ PTR_TBL_t *tbl);
PERL_CALLCONV void	Perl_ptr_table_free(pTHX_ PTR_TBL_t *tbl);
#if defined(USE_ITHREADS)
#  if defined(HAVE_INTERP_INTERN)
PERL_CALLCONV void	Perl_sys_intern_dup(pTHX_ struct interp_intern* src, struct interp_intern* dst)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#  endif
#endif
#if defined(HAVE_INTERP_INTERN)
PERL_CALLCONV void	Perl_sys_intern_clear(pTHX);
PERL_CALLCONV void	Perl_sys_intern_init(pTHX);
#endif

PERL_CALLCONV const char *	Perl_custom_op_name(pTHX_ const OP* op)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV const char *	Perl_custom_op_desc(pTHX_ const OP* op)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV void	Perl_sv_nosharing(pTHX_ SV *sv);
/* PERL_CALLCONV void	Perl_sv_nolocking(pTHX_ SV *sv); */
PERL_CALLCONV bool	Perl_sv_destroyable(pTHX_ SV *sv);
#ifdef NO_MATHOMS
/* PERL_CALLCONV void	Perl_sv_nounlocking(pTHX_ SV *sv); */
#else
PERL_CALLCONV void	Perl_sv_nounlocking(pTHX_ SV *sv);
#endif
PERL_CALLCONV int	Perl_nothreadhook(pTHX);

END_EXTERN_C

#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
STATIC I32	S_do_trans_simple(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_do_trans_count(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_do_trans_complex(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_do_trans_simple_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_do_trans_count_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_do_trans_complex_utf8(pTHX_ SV * const sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
STATIC void	S_gv_init_sv(pTHX_ GV *gv, I32 sv_type)
			__attribute__nonnull__(pTHX_1);

STATIC HV*	S_gv_get_super_pkg(pTHX_ const char* name, I32 namelen)
			__attribute__nonnull__(pTHX_1);

STATIC HV*	S_require_tie_mod(pTHX_ GV *gv, const char *varpv, SV* namesv, const char *methpv, const U32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

#endif

PERL_CALLCONV void*	Perl_get_arena(pTHX_ size_t svtype, U32 misc)
			__attribute__malloc__
			__attribute__warn_unused_result__;


#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
STATIC void	S_hsplit(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_hfreeentries(pTHX_ HV *hv)
			__attribute__nonnull__(pTHX_1);

STATIC HE*	S_new_he(pTHX)
			__attribute__malloc__
			__attribute__warn_unused_result__;

STATIC HEK*	S_save_hek_flags(const char *str, I32 len, U32 hash, int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC void	S_hv_magic_check(HV *hv, bool *needs_copy, bool *needs_store)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);

STATIC void	S_unshare_hek_or_pvn(pTHX_ const HEK* hek, const char* str, I32 len, U32 hash);
STATIC HEK*	S_share_hek_flags(pTHX_ const char* sv, I32 len, U32 hash, int flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC void	S_hv_notallowed(pTHX_ int flags, const char *key, I32 klen, const char *msg)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);

STATIC struct xpvhv_aux*	S_hv_auxinit(HV *hv)
			__attribute__nonnull__(1);

STATIC SV*	S_hv_delete_common(pTHX_ HV* tb, SV* keysv, const char* key, STRLEN klen, int k_flags, I32 d_flags, U32 hash);
STATIC void	S_clear_placeholders(pTHX_ HV* hb, U32 items)
			__attribute__nonnull__(pTHX_1);

STATIC SV *	S_refcounted_he_value(pTHX_ const struct refcounted_he *he)
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
STATIC void	S_save_magic(pTHX_ I32 mgs_ix, SV *sv)
			__attribute__nonnull__(pTHX_2);

STATIC int	S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, const char *meth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC int	S_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, const char *meth, I32 f, int n, SV *val)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC void	S_restore_magic(pTHX_ const void *p)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_unwind_handler_stack(pTHX_ const void *p)
			__attribute__nonnull__(pTHX_1);


#endif

#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
PERL_CALLCONV OP*	Perl_ck_anoncode(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_bitop(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_concat(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_defined(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_delete(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_die(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_eof(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_eval(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_exec(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_exists(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_exit(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_ftst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_fun(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_glob(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_grep(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_index(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_join(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_lengthconst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_lfun(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_listiob(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_match(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_method(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_null(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_open(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_readline(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_repeat(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_require(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_retarget(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_return(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_rfun(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_rvconst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_sassign(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_select(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_shift(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_sort(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_spair(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_split(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_subr(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_substr(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_svconst(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_trunc(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV OP*	Perl_ck_unpack(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC bool	S_is_handle_constructor(const OP *o, I32 numargs)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC I32	S_is_list_assignment(pTHX_ const OP *o)
			__attribute__warn_unused_result__;

#  ifdef USE_ITHREADS
STATIC void	S_forget_pmop(pTHX_ PMOP *const o, U32 flags)
			__attribute__nonnull__(pTHX_1);

#  else
STATIC void	S_forget_pmop(pTHX_ PMOP *const o)
			__attribute__nonnull__(pTHX_1);

#  endif
STATIC void	S_find_and_forget_pmops(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_cop_free(pTHX_ COP *cop)
			__attribute__nonnull__(pTHX_1);

STATIC OP*	S_modkids(pTHX_ OP *o, I32 type);
STATIC OP*	S_scalarboolean(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC OP*	S_newDEFSVOP(pTHX)
			__attribute__warn_unused_result__;

STATIC OP*	S_new_logop(pTHX_ I32 type, I32 flags, OP **firstp, OP **otherp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC void	S_simplify_sort(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC const char*	S_gv_ename(pTHX_ GV *gv)
			__attribute__nonnull__(pTHX_1);

STATIC bool	S_scalar_mod_type(const OP *o, I32 type)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC OP *	S_my_kid(pTHX_ OP *o, OP *attrs, OP **imopsp)
			__attribute__nonnull__(pTHX_3);

STATIC OP *	S_dup_attrlist(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_apply_attrs(pTHX_ HV *stash, SV *target, OP *attrs, bool for_my)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC void	S_apply_attrs_my(pTHX_ HV *stash, OP *target, OP *attrs, OP **imopsp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);

STATIC void	S_bad_type(pTHX_ I32 n, const char *t, const char *name, const OP *kid)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC void	S_no_bareword_allowed(pTHX_ const OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC OP*	S_no_fh_allowed(pTHX_ OP *o)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC OP*	S_too_few_arguments(pTHX_ OP *o, const char* name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC OP*	S_too_many_arguments(pTHX_ OP *o, const char* name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC bool	S_looks_like_bool(pTHX_ const OP* o)
			__attribute__nonnull__(pTHX_1);

STATIC OP*	S_newGIVWHENOP(pTHX_ OP* cond, OP *block, I32 enter_opcode, I32 leave_opcode, PADOFFSET entertarg)
			__attribute__nonnull__(pTHX_2);

STATIC OP*	S_ref_array_or_hash(pTHX_ OP* cond);
STATIC void	S_process_special_blocks(pTHX_ const char *const fullname, GV *const gv, CV *const cv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#endif
#if defined(PL_OP_SLAB_ALLOC)
PERL_CALLCONV void*	Perl_Slab_Alloc(pTHX_ size_t sz)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_Slab_Free(pTHX_ void *op)
			__attribute__nonnull__(pTHX_1);

#  if defined(PERL_DEBUG_READONLY_OPS)
PERL_CALLCONV void	Perl_pending_Slabs_to_ro(pTHX);
PERL_CALLCONV OP *	Perl_op_refcnt_inc(pTHX_ OP *o);
PERL_CALLCONV PADOFFSET	Perl_op_refcnt_dec(pTHX_ OP *o)
			__attribute__nonnull__(pTHX_1);

#    if defined(PERL_IN_OP_C)
STATIC void	S_Slab_to_rw(pTHX_ void *op)
			__attribute__nonnull__(pTHX_1);

#    endif
#  endif
#endif

#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
STATIC void	S_find_beginning(pTHX_ SV* linestr_sv, PerlIO *rsfp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC void	S_forbid_setid(pTHX_ const char flag, const int suidscript);
STATIC void	S_incpush(pTHX_ const char *dir, bool addsubdirs, bool addoldvers, bool usesep, bool canrelocate);
STATIC void	S_init_interp(pTHX);
STATIC void	S_init_ids(pTHX);
STATIC void	S_init_main_stash(pTHX);
STATIC void	S_init_perllib(pTHX);
STATIC void	S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env)
			__attribute__nonnull__(pTHX_2);

STATIC void	S_init_predump_symbols(pTHX);
STATIC void	S_my_exit_jump(pTHX)
			__attribute__noreturn__;

STATIC void	S_nuke_stacks(pTHX);
STATIC int	S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv, int *suidscript, PerlIO **rsfpp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

STATIC void	S_usage(pTHX_ const char *name)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_validate_suid(pTHX_ const char *validarg, const char *scriptname, int fdscript, int suidscript, SV* linestr_sv, PerlIO *rsfp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5)
			__attribute__nonnull__(pTHX_6);


#  if defined(IAMSUID)
STATIC int	S_fd_on_nosuid_fs(pTHX_ int fd);
#  endif
STATIC void*	S_parse_body(pTHX_ char **env, XSINIT_t xsinit);
STATIC void	S_run_body(pTHX_ I32 oldscope)
			__attribute__noreturn__;

STATIC SV *	S_incpush_if_exists(pTHX_ SV *dir)
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
STATIC SV*	S_refto(pTHX_ SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#endif
#if defined(PERL_IN_PP_C) || defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
PERL_CALLCONV GV*	Perl_softref2xv(pTHX_ SV *const sv, const char *const what, const U32 type, SV ***spp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_4);

#endif

#if defined(PERL_IN_PP_PACK_C) || defined(PERL_DECL_PROT)
STATIC I32	S_unpack_rec(pTHX_ struct tempsym* symptr, const char *s, const char *strbeg, const char *strend, const char **new_s)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC SV **	S_pack_rec(pTHX_ SV *cat, struct tempsym* symptr, SV **beglist, SV **endlist)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC SV*	S_mul128(pTHX_ SV *sv, U8 m)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_measure_struct(pTHX_ struct tempsym* symptr)
			__attribute__nonnull__(pTHX_1);

STATIC bool	S_next_symbol(pTHX_ struct tempsym* symptr)
			__attribute__nonnull__(pTHX_1);

STATIC SV*	S_is_an_int(pTHX_ const char *s, STRLEN l)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC int	S_div128(pTHX_ SV *pnum, bool *done)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC const char *	S_group_end(pTHX_ const char *pat, const char *patend, char ender)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC const char *	S_get_num(pTHX_ const char *ppat, I32 *lenptr)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC bool	S_need_utf8(const char *pat, const char *patend)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC char	S_first_symbol(const char *pat, const char *patend)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC char *	S_sv_exp_grow(pTHX_ SV *sv, STRLEN needed)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char *	S_bytes_to_uni(const U8 *start, STRLEN len, char *dest)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);

#endif

#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
STATIC OP*	S_docatch(pTHX_ OP *o)
			__attribute__warn_unused_result__;

STATIC OP*	S_dofindlabel(pTHX_ OP *o, const char *label, OP **opstack, OP **oplimit)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC OP*	S_doparseform(pTHX_ SV *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC bool	S_num_overflow(NV value, I32 fldsize, I32 frcsize)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptoeval(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptogiven(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptolabel(pTHX_ const char *label)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_dopoptoloop(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC I32	S_dopoptosub_at(pTHX_ const PERL_CONTEXT* cxstk, I32 startingblock)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_dopoptowhen(pTHX_ I32 startingblock)
			__attribute__warn_unused_result__;

STATIC void	S_save_lines(pTHX_ AV *array, SV *sv)
			__attribute__nonnull__(pTHX_2);

STATIC bool	S_doeval(pTHX_ int gimme, OP** startop, CV* outside, U32 seq);
STATIC PerlIO *	S_check_type_and_open(pTHX_ const char *name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#ifndef PERL_DISABLE_PMC
STATIC PerlIO *	S_doopen_pm(pTHX_ const char *name, const STRLEN namelen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#endif
STATIC bool	S_path_is_absolute(const char *name)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC I32	S_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

STATIC PMOP*	S_make_matcher(pTHX_ regexp* re)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC bool	S_matcher_matches_sv(pTHX_ PMOP* matcher, SV* sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC void	S_destroy_matcher(pTHX_ PMOP* matcher)
			__attribute__nonnull__(pTHX_1);

STATIC OP*	S_do_smartmatch(pTHX_ HV* seen_this, HV* seen_other);
#endif

#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
STATIC void	S_do_oddball(pTHX_ HV *hash, SV **relem, SV **firstrelem)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC SV*	S_method_common(pTHX_ SV* meth, U32* hashp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_PP_SORT_C) || defined(PERL_DECL_PROT)
STATIC I32	S_sv_ncmp(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_sv_i_ncmp(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_amagic_ncmp(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_amagic_i_ncmp(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_amagic_cmp(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_amagic_cmp_locale(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_sortcv(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_sortcv_xsub(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_sortcv_stacked(pTHX_ SV *a, SV *b)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC void	S_qsortsvu(pTHX_ SV** array, size_t num_elts, SVCOMPARE_t compare)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

#endif

#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
STATIC OP*	S_doform(pTHX_ CV *cv, GV *gv, OP *retop)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
STATIC int	S_dooneliner(pTHX_ const char *cmd, const char *filename)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#  endif
STATIC SV *	S_space_join_names_mortal(pTHX_ char *const *array)
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
STATIC regnode*	S_reg(pTHX_ struct RExC_state_t *state, I32 paren, I32 *flagp, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

STATIC regnode*	S_reganode(pTHX_ struct RExC_state_t *state, U8 op, U32 arg)
			__attribute__nonnull__(pTHX_1);

STATIC regnode*	S_regatom(pTHX_ struct RExC_state_t *state, I32 *flagp, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC regnode*	S_regbranch(pTHX_ struct RExC_state_t *state, I32 *flagp, I32 first, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC STRLEN	S_reguni(pTHX_ const struct RExC_state_t *state, UV uv, char *s)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

STATIC regnode*	S_regclass(pTHX_ struct RExC_state_t *state, U32 depth)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_regcurly(const char *)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC regnode*	S_reg_node(pTHX_ struct RExC_state_t *state, U8 op)
			__attribute__nonnull__(pTHX_1);

STATIC UV	S_reg_recode(pTHX_ const char value, SV **encp)
			__attribute__nonnull__(pTHX_2);

STATIC regnode*	S_regpiece(pTHX_ struct RExC_state_t *state, I32 *flagp, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC regnode*	S_reg_namedseq(pTHX_ struct RExC_state_t *state, UV *valuep)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_reginsert(pTHX_ struct RExC_state_t *state, U8 op, regnode *opnd, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

STATIC void	S_regtail(pTHX_ struct RExC_state_t *state, regnode *p, const regnode *val, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC SV *	S_reg_scan_name(pTHX_ struct RExC_state_t *state, U32 flags)
			__attribute__nonnull__(pTHX_1);

STATIC U32	S_join_exact(pTHX_ struct RExC_state_t *state, regnode *scan, I32 *min, U32 flags, regnode *val, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC char *	S_regwhite(struct RExC_state_t *state, char *p)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC char *	S_nextchar(pTHX_ struct RExC_state_t *state)
			__attribute__nonnull__(pTHX_1);

STATIC bool	S_reg_skipcomment(pTHX_ struct RExC_state_t *state)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_scan_commit(pTHX_ const struct RExC_state_t* state, struct scan_data_t *data, I32 *minlenp, int is_inf)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC void	S_cl_anything(const struct RExC_state_t* state, struct regnode_charclass_class *cl)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC int	S_cl_is_anything(const struct regnode_charclass_class *cl)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC void	S_cl_init(const struct RExC_state_t* state, struct regnode_charclass_class *cl)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC void	S_cl_init_zero(const struct RExC_state_t* state, struct regnode_charclass_class *cl)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC void	S_cl_and(struct regnode_charclass_class *cl, const struct regnode_charclass_class *and_with)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC void	S_cl_or(const struct RExC_state_t* state, struct regnode_charclass_class *cl, const struct regnode_charclass_class *or_with)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);

STATIC I32	S_study_chunk(pTHX_ struct RExC_state_t* state, regnode **scanp, I32 *minlenp, I32 *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U8* recursed, struct regnode_charclass_class *and_withp, U32 flags, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

STATIC U32	S_add_data(struct RExC_state_t* state, U32 n, const char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);

STATIC void	S_re_croak2(pTHX_ const char* pat1, const char* pat2, ...)
			__attribute__noreturn__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_regpposixcc(pTHX_ struct RExC_state_t* state, I32 value)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_checkposixcc(pTHX_ struct RExC_state_t* state)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_make_trie(pTHX_ struct RExC_state_t* state, regnode *startbranch, regnode *first, regnode *last, regnode *tail, U32 word_count, U32 flags, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

STATIC void	S_make_trie_failtable(pTHX_ struct RExC_state_t* state, regnode *source, regnode *node, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#  ifdef DEBUGGING
STATIC void	S_regdump_extflags(pTHX_ const char *lead, const U32 flags);
STATIC const regnode*	S_dumpuntil(pTHX_ const regexp *r, const regnode *start, const regnode *node, const regnode *last, const regnode *plast, SV* sv, I32 indent, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_6);

STATIC void	S_put_byte(pTHX_ SV* sv, int c)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_dump_trie(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

STATIC void	S_dump_trie_interim_list(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

STATIC void	S_dump_trie_interim_table(pTHX_ const struct _reg_trie_data *trie, HV* widecharmap, AV *revcharmap, U32 next_alloc, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

STATIC U8	S_regtail_study(pTHX_ struct RExC_state_t *state, regnode *p, const regnode *val, U32 depth)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#  endif
#endif

#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
STATIC I32	S_regmatch(pTHX_ regmatch_info *reginfo, regnode *prog)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_regrepeat(pTHX_ const regexp *prog, const regnode *p, I32 max, int depth)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_regtry(pTHX_ regmatch_info *reginfo, char **startpos)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC bool	S_reginclass(pTHX_ const regexp *prog, const regnode *n, const U8 *p, STRLEN *lenp, bool do_utf8sv_is_utf8)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC CHECKPOINT	S_regcppush(pTHX_ I32 parenfloor);
STATIC char*	S_regcppop(pTHX_ const regexp *rex)
			__attribute__nonnull__(pTHX_1);

STATIC U8*	S_reghop3(U8 *pos, I32 off, const U8 *lim)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);

#ifdef XXX_dmq
STATIC U8*	S_reghop4(U8 *pos, I32 off, const U8 *llim, const U8 *rlim)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3)
			__attribute__nonnull__(4);

#endif
STATIC U8*	S_reghopmaybe3(U8 *pos, I32 off, const U8 *lim)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);

STATIC char*	S_find_byclass(pTHX_ regexp * prog, const regnode *c, char *s, const char *strend, regmatch_info *reginfo)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC void	S_swap_match_buff(pTHX_ regexp * prog)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_to_utf8_substr(pTHX_ regexp * prog)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_to_byte_substr(pTHX_ regexp * prog)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_reg_check_named_buff_matched(pTHX_ const regexp *rex, const regnode *prog)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#  ifdef DEBUGGING
STATIC void	S_dump_exec_pos(pTHX_ const char *locinput, const regnode *scan, const char *loc_regeol, const char *loc_bostr, const char *loc_reg_starttry, const bool do_utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

STATIC void	S_debug_start_match(pTHX_ const regexp *prog, const bool do_utf8, const char *start, const char *end, const char *blurb)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4)
			__attribute__nonnull__(pTHX_5);

#  endif
#endif

#if defined(PERL_IN_DUMP_C) || defined(PERL_DECL_PROT)
STATIC CV*	S_deb_curcv(pTHX_ const I32 ix);
STATIC void	S_debprof(pTHX_ const OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_sequence(pTHX_ const OP *o);
STATIC void	S_sequence_tail(pTHX_ const OP *o);
STATIC UV	S_sequence_num(pTHX_ const OP *o);
STATIC SV*	S_pm_description(pTHX_ const PMOP *pm)
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
STATIC SV*	S_save_scalar_at(pTHX_ SV **sptr)
			__attribute__nonnull__(pTHX_1);

#endif

#if defined(PERL_IN_GV_C) || defined(PERL_IN_SV_C) || defined(PERL_IN_PAD_C) || defined(PERL_DECL_PROT)
PERL_CALLCONV void	Perl_sv_add_backref(pTHX_ SV *tsv, SV *sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif

#if defined(PERL_IN_HV_C) || defined(PERL_IN_MG_C) || defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
PERL_CALLCONV int	Perl_sv_kill_backrefs(pTHX_ SV *sv, AV *av)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif

#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
STATIC char *	S_uiv_2buf(char *buf, IV iv, UV uv, int is_uv, char **peob)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(5);

STATIC void	S_sv_unglob(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_not_a_number(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_visit(pTHX_ SVFUNC_t f, U32 flags, U32 mask)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_sv_del_backref(pTHX_ SV *target, SV *ref)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC SV *	S_varname(pTHX_ GV *gv, const char gvtype, PADOFFSET targ, SV *keyname, I32 aindex, int subscript_type)
			__attribute__warn_unused_result__;

#  ifdef DEBUGGING
STATIC void	S_del_sv(pTHX_ SV *p)
			__attribute__nonnull__(pTHX_1);

#  endif
#  if !defined(NV_PRESERVES_UV)
STATIC int	S_sv_2iuv_non_preserve(pTHX_ SV *sv, I32 numtype)
			__attribute__nonnull__(pTHX_1);

#  endif
STATIC I32	S_expect_number(pTHX_ char** pattern)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#
STATIC STRLEN	S_sv_pos_u2b_forwards(const U8 *const start, const U8 *const send, STRLEN uoffset)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC STRLEN	S_sv_pos_u2b_midway(const U8 *const start, const U8 *send, STRLEN uoffset, STRLEN uend)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

STATIC STRLEN	S_sv_pos_u2b_cached(pTHX_ SV *sv, MAGIC **mgp, const U8 *const start, const U8 *const send, STRLEN uoffset, STRLEN uoffset0, STRLEN boffset0)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_4);

STATIC void	S_utf8_mg_pos_cache_update(pTHX_ SV *sv, MAGIC **mgp, STRLEN byte, STRLEN utf8, STRLEN blen)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC STRLEN	S_sv_pos_b2u_midway(pTHX_ const U8 *s, const U8 *const target, const U8 *end, STRLEN endu)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC char *	S_F0convert(NV nv, char *endbuf, STRLEN *len)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);

#  if defined(PERL_OLD_COPY_ON_WRITE)
STATIC void	S_sv_release_COW(pTHX_ SV *sv, const char *pvx, SV *after)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#  endif
STATIC SV *	S_more_sv(pTHX);
STATIC void *	S_more_bodies(pTHX_ svtype sv_type);
STATIC bool	S_sv_2iuv_common(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_glob_assign_glob(pTHX_ SV *dstr, SV *sstr, const int dtype)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC void	S_glob_assign_ref(pTHX_ SV *dstr, SV *sstr)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC PTR_TBL_ENT_t *	S_ptr_table_find(PTR_TBL_t *tbl, const void *sv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

#endif

#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
STATIC void	S_check_uni(pTHX);
STATIC void	S_force_next(pTHX_ I32 type);
STATIC char*	S_force_version(pTHX_ char *start, int guessing)
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack, int allow_tick)
			__attribute__nonnull__(pTHX_1);

STATIC SV*	S_tokeq(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_readpipe_override(pTHX);
STATIC char*	S_scan_const(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_formline(pTHX_ char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_heredoc(pTHX_ char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_ident(pTHX_ char *s, const char *send, char *dest, STRLEN destlen, I32 ck_uni)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC char*	S_scan_inputsymbol(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_pat(pTHX_ char *start, I32 type)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_subst(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_trans(pTHX_ char *start)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_5);

STATIC void	S_update_debugger_info(pTHX_ SV *orig_sv, const char *buf, STRLEN len);
STATIC char*	S_skipspace(pTHX_ char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_swallow_bom(pTHX_ U8 *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC void	S_checkcomma(pTHX_ const char *s, const char *name, const char *what)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC bool	S_feature_is_enabled(pTHX_ const char* name, STRLEN namelen)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_force_ident(pTHX_ const char *s, int kind)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_incline(pTHX_ const char *s)
			__attribute__nonnull__(pTHX_1);

STATIC int	S_intuit_method(pTHX_ char *s, GV *gv, CV *cv)
			__attribute__nonnull__(pTHX_1);

STATIC int	S_intuit_more(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_lop(pTHX_ I32 f, int x, char *s)
			__attribute__nonnull__(pTHX_3);

STATIC void	S_missingterm(pTHX_ char *s)
			__attribute__noreturn__;

STATIC void	S_no_op(pTHX_ const char *what, char *s)
			__attribute__nonnull__(pTHX_1);

STATIC I32	S_sublex_done(pTHX)
			__attribute__warn_unused_result__;

STATIC I32	S_sublex_push(pTHX)
			__attribute__warn_unused_result__;

STATIC I32	S_sublex_start(pTHX)
			__attribute__warn_unused_result__;

STATIC char *	S_filter_gets(pTHX_ SV *sv, PerlIO *fp, STRLEN append)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

STATIC HV *	S_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

STATIC char *	S_tokenize_use(pTHX_ int is_use, char *s)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);

STATIC SV*	S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen, SV *sv, SV *pv, const char *type, STRLEN typelen)
			__attribute__nonnull__(pTHX_3)
			__attribute__nonnull__(pTHX_5);

STATIC int	S_ao(pTHX_ int toketype);
#  if defined(PERL_CR_FILTER)
STATIC I32	S_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen);
STATIC void	S_strip_return(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

#  endif
#  if defined(DEBUGGING)
STATIC int	S_tokereport(pTHX_ I32 rv);
STATIC void	S_printbuf(pTHX_ const char* fmt, const char* s)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#  endif
#endif

#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
STATIC bool	S_isa_lookup(pTHX_ HV *stash, const char * const name, const HV * const name_stash)
			__attribute__nonnull__(pTHX_2);

#endif

#if defined(PERL_IN_LOCALE_C) || defined(PERL_DECL_PROT)
#if defined(USE_LOCALE_NUMERIC) || defined(USE_LOCALE_COLLATE)
STATIC char*	S_stdize_locale(pTHX_ char* locs)
			__attribute__nonnull__(pTHX_1);

#endif
#endif

#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
STATIC const COP*	S_closest_cop(pTHX_ const COP *cop, const OP *o)
			__attribute__nonnull__(pTHX_1);

STATIC SV*	S_mess_alloc(pTHX);
STATIC const char *	S_vdie_croak_common(pTHX_ const char *pat, va_list *args, STRLEN *msglen, I32* utf8);
STATIC bool	S_vdie_common(pTHX_ const char *message, STRLEN msglen, I32 utf8, bool warn);
STATIC char *	S_write_no_mem(pTHX)
			__attribute__noreturn__;

#endif

#if defined(PERL_IN_NUMERIC_C) || defined(PERL_DECL_PROT)
STATIC NV	S_mulexp10(NV value, I32 exponent);
#endif

#if defined(PERL_IN_UTF8_C) || defined(PERL_DECL_PROT)
STATIC STRLEN	S_is_utf8_char_slow(const U8 *s, const STRLEN len)
			__attribute__warn_unused_result__
			__attribute__nonnull__(1);

STATIC bool	S_is_utf8_common(pTHX_ const U8 *const p, SV **swash, const char * const swashname)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

STATIC SV*	S_swash_get(pTHX_ SV* swash, UV start, UV span)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#endif

START_EXTERN_C

PERL_CALLCONV void	Perl_sv_setsv_flags(pTHX_ SV* dsv, SV* ssv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_catpvn_flags(pTHX_ SV* sv, const char* ptr, STRLEN len, I32 flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_sv_catsv_flags(pTHX_ SV* dsv, SV* ssv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV STRLEN	Perl_sv_utf8_upgrade_flags(pTHX_ SV *sv, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV char*	Perl_sv_pvn_force_flags(pTHX_ SV* sv, STRLEN* lp, I32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_sv_copypv(pTHX_ SV* dsv, SV* ssv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_my_atof2(pTHX_ const char *s, NV* value)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV int	Perl_my_socketpair(int family, int type, int protocol, int fd[2]);
PERL_CALLCONV int	Perl_my_dirfd(pTHX_ DIR* dir);
#ifdef PERL_OLD_COPY_ON_WRITE
PERL_CALLCONV SV*	Perl_sv_setsv_cow(pTHX_ SV* dsv, SV* ssv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif

PERL_CALLCONV const char *	Perl_PerlIO_context_layers(pTHX_ const char *mode);

#if defined(USE_PERLIO) && !defined(USE_SFIO)
PERL_CALLCONV int	Perl_PerlIO_close(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_fill(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_fileno(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_eof(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_error(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_flush(pTHX_ PerlIO *f);
PERL_CALLCONV void	Perl_PerlIO_clearerr(pTHX_ PerlIO *f);
PERL_CALLCONV void	Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, int cnt);
PERL_CALLCONV void	Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR *ptr, int cnt)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_PerlIO_setlinebuf(pTHX_ PerlIO *f);
PERL_CALLCONV SSize_t	Perl_PerlIO_read(pTHX_ PerlIO *f, void *buf, Size_t count)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SSize_t	Perl_PerlIO_write(pTHX_ PerlIO *f, const void *buf, Size_t count)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV SSize_t	Perl_PerlIO_unread(pTHX_ PerlIO *f, const void *buf, Size_t count)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV Off_t	Perl_PerlIO_tell(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence);

PERL_CALLCONV STDCHAR *	Perl_PerlIO_get_base(pTHX_ PerlIO *f);
PERL_CALLCONV STDCHAR *	Perl_PerlIO_get_ptr(pTHX_ PerlIO *f);
PERL_CALLCONV int	Perl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)
			__attribute__warn_unused_result__;

PERL_CALLCONV int	Perl_PerlIO_get_cnt(pTHX_ PerlIO *f)
			__attribute__warn_unused_result__;


PERL_CALLCONV PerlIO *	Perl_PerlIO_stdin(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV PerlIO *	Perl_PerlIO_stdout(pTHX)
			__attribute__warn_unused_result__;

PERL_CALLCONV PerlIO *	Perl_PerlIO_stderr(pTHX)
			__attribute__warn_unused_result__;

#endif /* PERLIO_LAYERS */

PERL_CALLCONV void	Perl_deb_stack_all(pTHX);
#ifdef PERL_IN_DEB_C
STATIC void	S_deb_stack_n(pTHX_ SV** stack_base, I32 stack_min, I32 stack_max, I32 mark_min, I32 mark_max)
			__attribute__nonnull__(pTHX_1);

#endif

PERL_CALLCONV PADLIST*	Perl_pad_new(pTHX_ int flags)
			__attribute__malloc__
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_pad_undef(pTHX_ CV* cv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV PADOFFSET	Perl_pad_add_name(pTHX_ const char *name, HV* typestash, HV* ourstash, bool clone, bool state)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV PADOFFSET	Perl_pad_add_anon(pTHX_ SV* sv, OPCODE op_type)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_pad_check_dup(pTHX_ const char* name, bool is_our, const HV* ourstash)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_3);

#ifdef DEBUGGING
PERL_CALLCONV void	Perl_pad_setsv(pTHX_ PADOFFSET po, SV* sv)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV void	Perl_pad_block_start(pTHX_ int full);
PERL_CALLCONV void	Perl_pad_tidy(pTHX_ padtidy_type type);
PERL_CALLCONV void	Perl_do_dump_pad(pTHX_ I32 level, PerlIO *file, PADLIST *padlist, int full)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_pad_fixup_inner_anons(pTHX_ PADLIST *padlist, CV *old_cv, CV *new_cv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);


PERL_CALLCONV void	Perl_pad_push(pTHX_ PADLIST *padlist, int depth)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HV*	Perl_pad_compname_type(pTHX_ const PADOFFSET po)
			__attribute__warn_unused_result__;


#if defined(PERL_IN_PAD_C) || defined(PERL_DECL_PROT)
STATIC PADOFFSET	S_pad_findlex(pTHX_ const char *name, const CV* cv, U32 seq, int warn, SV** out_capture, SV** out_name_sv, int *out_flags)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_6)
			__attribute__nonnull__(pTHX_7);

#  if defined(DEBUGGING)
STATIC void	S_cv_dump(pTHX_ const CV *cv, const char *title)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#  endif
#endif
PERL_CALLCONV CV*	Perl_find_runcv(pTHX_ U32 *db_seqp)
			__attribute__warn_unused_result__;

PERL_CALLCONV void	Perl_free_tied_hv_pool(pTHX);
#if defined(DEBUGGING)
PERL_CALLCONV int	Perl_get_debug_opts(pTHX_ const char **s, bool givehelp)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV void	Perl_save_set_svflags(pTHX_ SV* sv, U32 mask, U32 val);
PERL_CALLCONV void	Perl_hv_assert(pTHX_ HV* tb)
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV SV*	Perl_hv_scalar(pTHX_ HV* hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32*	Perl_hv_riter_p(pTHX_ HV* hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV HE**	Perl_hv_eiter_p(pTHX_ HV* hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_hv_riter_set(pTHX_ HV* hv, I32 riter)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_hv_eiter_set(pTHX_ HV* hv, HE* eiter)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_hv_name_set(pTHX_ HV* hv, const char *name, U32 len, U32 flags)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV AV**	Perl_hv_backreferences_p(pTHX_ HV* hv)
			__attribute__nonnull__(pTHX_1);

#if defined(PERL_IN_DUMP_C) || defined(PERL_IN_HV_C) || defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
PERL_CALLCONV void	Perl_hv_kill_backrefs(pTHX_ HV* hv)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV void	Perl_hv_clear_placeholders(pTHX_ HV* hb)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32*	Perl_hv_placeholders_p(pTHX_ HV* hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV I32	Perl_hv_placeholders_get(pTHX_ HV* hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_hv_placeholders_set(pTHX_ HV* hv, I32 ph)
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV SV*	Perl_magic_scalarpack(pTHX_ HV* hv, MAGIC* mg)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);


#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
STATIC SV *	S_find_hash_subscript(pTHX_ HV *hv, SV *val)
			__attribute__nonnull__(pTHX_2);

STATIC I32	S_find_array_subscript(pTHX_ AV *av, SV *val)
			__attribute__nonnull__(pTHX_2);

STATIC SV*	S_find_uninit_var(pTHX_ OP* obase, SV* uninit_sv, bool top);
#endif

#ifdef PERL_NEED_MY_HTOLE16
PERL_CALLCONV U16	Perl_my_htole16(U16 n);
#endif
#ifdef PERL_NEED_MY_LETOH16
PERL_CALLCONV U16	Perl_my_letoh16(U16 n);
#endif
#ifdef PERL_NEED_MY_HTOBE16
PERL_CALLCONV U16	Perl_my_htobe16(U16 n);
#endif
#ifdef PERL_NEED_MY_BETOH16
PERL_CALLCONV U16	Perl_my_betoh16(U16 n);
#endif
#ifdef PERL_NEED_MY_HTOLE32
PERL_CALLCONV U32	Perl_my_htole32(U32 n);
#endif
#ifdef PERL_NEED_MY_LETOH32
PERL_CALLCONV U32	Perl_my_letoh32(U32 n);
#endif
#ifdef PERL_NEED_MY_HTOBE32
PERL_CALLCONV U32	Perl_my_htobe32(U32 n);
#endif
#ifdef PERL_NEED_MY_BETOH32
PERL_CALLCONV U32	Perl_my_betoh32(U32 n);
#endif
#ifdef PERL_NEED_MY_HTOLE64
PERL_CALLCONV U64	Perl_my_htole64(U64 n);
#endif
#ifdef PERL_NEED_MY_LETOH64
PERL_CALLCONV U64	Perl_my_letoh64(U64 n);
#endif
#ifdef PERL_NEED_MY_HTOBE64
PERL_CALLCONV U64	Perl_my_htobe64(U64 n);
#endif
#ifdef PERL_NEED_MY_BETOH64
PERL_CALLCONV U64	Perl_my_betoh64(U64 n);
#endif

#ifdef PERL_NEED_MY_HTOLES
PERL_CALLCONV short	Perl_my_htoles(short n);
#endif
#ifdef PERL_NEED_MY_LETOHS
PERL_CALLCONV short	Perl_my_letohs(short n);
#endif
#ifdef PERL_NEED_MY_HTOBES
PERL_CALLCONV short	Perl_my_htobes(short n);
#endif
#ifdef PERL_NEED_MY_BETOHS
PERL_CALLCONV short	Perl_my_betohs(short n);
#endif
#ifdef PERL_NEED_MY_HTOLEI
PERL_CALLCONV int	Perl_my_htolei(int n);
#endif
#ifdef PERL_NEED_MY_LETOHI
PERL_CALLCONV int	Perl_my_letohi(int n);
#endif
#ifdef PERL_NEED_MY_HTOBEI
PERL_CALLCONV int	Perl_my_htobei(int n);
#endif
#ifdef PERL_NEED_MY_BETOHI
PERL_CALLCONV int	Perl_my_betohi(int n);
#endif
#ifdef PERL_NEED_MY_HTOLEL
PERL_CALLCONV long	Perl_my_htolel(long n);
#endif
#ifdef PERL_NEED_MY_LETOHL
PERL_CALLCONV long	Perl_my_letohl(long n);
#endif
#ifdef PERL_NEED_MY_HTOBEL
PERL_CALLCONV long	Perl_my_htobel(long n);
#endif
#ifdef PERL_NEED_MY_BETOHL
PERL_CALLCONV long	Perl_my_betohl(long n);
#endif

PERL_CALLCONV void	Perl_my_swabn(void* ptr, int n)
			__attribute__nonnull__(1);


PERL_CALLCONV GV*	Perl_gv_fetchpvn_flags(pTHX_ const char* name, STRLEN len, I32 flags, I32 sv_type)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV GV*	Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, I32 sv_type)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV bool	Perl_is_gv_magical_sv(pTHX_ SV *name, U32 flags)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV bool	Perl_stashpv_hvname_match(pTHX_ const COP *cop, const HV *hv)
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);


#ifdef DEBUG_LEAKING_SCALARS_FORK_DUMP
PERL_CALLCONV void	Perl_dump_sv_child(pTHX_ SV *sv)
			__attribute__nonnull__(pTHX_1);

#endif

#ifdef PERL_DONT_CREATE_GVSV
PERL_CALLCONV GV*	Perl_gv_SVadd(pTHX_ GV* gv)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV bool	Perl_ckwarn(pTHX_ U32 w);
PERL_CALLCONV bool	Perl_ckwarn_d(pTHX_ U32 w);
PERL_CALLCONV STRLEN *	Perl_new_warnings_bitfield(pTHX_ STRLEN *buffer, const char *const bits, STRLEN size)
			__attribute__malloc__
			__attribute__warn_unused_result__
			__attribute__nonnull__(pTHX_2);


PERL_CALLCONV void	Perl_offer_nice_chunk(pTHX_ void *chunk, U32 chunk_size)
			__attribute__nonnull__(pTHX_1);


#ifndef SPRINTF_RETURNS_STRLEN
PERL_CALLCONV int	Perl_my_sprintf(char *buffer, const char *pat, ...)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

#endif

PERL_CALLCONV int	Perl_my_snprintf(char *buffer, const Size_t len, const char *format, ...)
			__attribute__format__(__printf__,3,4)
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);

PERL_CALLCONV int	Perl_my_vsnprintf(char *buffer, const Size_t len, const char *format, va_list ap)
			__attribute__nonnull__(1)
			__attribute__nonnull__(3);


PERL_CALLCONV void	Perl_my_clearenv(pTHX);

#ifdef PERL_IMPLICIT_CONTEXT
#ifdef PERL_GLOBAL_STRUCT_PRIVATE
PERL_CALLCONV void*	Perl_my_cxt_init(pTHX_ const char *my_cxt_key, size_t size)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV int	Perl_my_cxt_index(pTHX_ const char *my_cxt_key)
			__attribute__nonnull__(pTHX_1);

#else
PERL_CALLCONV void*	Perl_my_cxt_init(pTHX_ int *index, size_t size)
			__attribute__nonnull__(pTHX_1);

#endif
#endif

#ifndef HAS_STRLCAT
PERL_CALLCONV Size_t	Perl_my_strlcat(char *dst, const char *src, Size_t size);
#endif

#ifndef HAS_STRLCPY
PERL_CALLCONV Size_t	Perl_my_strlcpy(char *dst, const char *src, Size_t size);
#endif

#ifdef PERL_MAD
PERL_CALLCONV void	Perl_pad_peg(const char* s)
			__attribute__nonnull__(1);

#if defined(PERL_IN_DUMP_C) || defined(PERL_DECL_PROT)
STATIC void	S_xmldump_attr(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

#endif
PERL_CALLCONV void	Perl_xmldump_indent(pTHX_ I32 level, PerlIO *file, const char* pat, ...)
			__attribute__format__(__printf__,pTHX_3,pTHX_4)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_xmldump_vindent(pTHX_ I32 level, PerlIO *file, const char* pat, va_list *args)
			__attribute__nonnull__(pTHX_2)
			__attribute__nonnull__(pTHX_3);

PERL_CALLCONV void	Perl_xmldump_all(pTHX);
PERL_CALLCONV void	Perl_xmldump_packsubs(pTHX_ const HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_xmldump_sub(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_xmldump_form(pTHX_ const GV* gv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_xmldump_eval(pTHX);
PERL_CALLCONV char*	Perl_sv_catxmlsv(pTHX_ SV *dsv, SV *ssv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_sv_catxmlpvn(pTHX_ SV *dsv, const char *pv, STRLEN len, int utf8)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV char*	Perl_sv_xmlpeek(pTHX_ SV* sv)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_do_pmop_xmldump(pTHX_ I32 level, PerlIO *file, const PMOP *pm)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_pmop_xmldump(pTHX_ const PMOP* pm);
PERL_CALLCONV void	Perl_do_op_xmldump(pTHX_ I32 level, PerlIO *file, const OP *o)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV void	Perl_op_xmldump(pTHX_ const OP* arg)
			__attribute__nonnull__(pTHX_1);


PERL_CALLCONV TOKEN*	Perl_newTOKEN(pTHX_ I32 optype, YYSTYPE lval, MADPROP* madprop);
PERL_CALLCONV void	Perl_token_free(pTHX_ TOKEN* arg)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_token_getmad(pTHX_ TOKEN* arg, OP* o, char slot)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_op_getmad_weak(pTHX_ OP* from, OP* o, char slot);
PERL_CALLCONV void	Perl_op_getmad(pTHX_ OP* from, OP* o, char slot);
PERL_CALLCONV void	Perl_prepend_madprops(pTHX_ MADPROP* mp, OP* o, char slot);
PERL_CALLCONV void	Perl_append_madprops(pTHX_ MADPROP* tm, OP* o, char slot);
PERL_CALLCONV void	Perl_addmad(pTHX_ MADPROP* tm, MADPROP** root, char slot);
PERL_CALLCONV MADPROP*	Perl_newMADsv(pTHX_ char key, SV* sv)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV MADPROP*	Perl_newMADPROP(pTHX_ char key, char type, const void* val, I32 vlen);
PERL_CALLCONV void	Perl_mad_free(pTHX_ MADPROP* mp);

#  if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
STATIC char*	S_skipspace0(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_skipspace1(pTHX_ char *s)
			__attribute__nonnull__(pTHX_1);

STATIC char*	S_skipspace2(pTHX_ char *s, SV **sv)
			__attribute__nonnull__(pTHX_1);

STATIC void	S_start_force(pTHX_ int where);
STATIC void	S_curmad(pTHX_ char slot, SV *sv);
#  endif
PERL_CALLCONV int	Perl_madlex(pTHX);
PERL_CALLCONV int	Perl_madparse(pTHX);
#endif
#if !defined(HAS_SIGNBIT)
PERL_CALLCONV int	Perl_signbit(NV f)
			__attribute__pure__;

#endif

PERL_CALLCONV void	Perl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

PERL_CALLCONV REGEXP *	Perl_get_re_arg(pTHX_ SV *sv);

PERL_CALLCONV struct mro_meta*	Perl_mro_meta_init(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);

#if defined(USE_ITHREADS)
PERL_CALLCONV struct mro_meta*	Perl_mro_meta_dup(pTHX_ struct mro_meta* smeta, CLONE_PARAMS* param)
			__attribute__nonnull__(pTHX_1)
			__attribute__nonnull__(pTHX_2);

#endif
PERL_CALLCONV AV*	Perl_mro_get_linear_isa(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);

#if defined(PERL_IN_MRO_C) || defined(PERL_DECL_PROT)
STATIC AV*	S_mro_get_linear_isa_c3(pTHX_ HV* stash, I32 level)
			__attribute__nonnull__(pTHX_1);

STATIC AV*	S_mro_get_linear_isa_dfs(pTHX_ HV* stash, I32 level)
			__attribute__nonnull__(pTHX_1);

#endif
PERL_CALLCONV void	Perl_mro_isa_changed_in(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_mro_method_changed_in(pTHX_ HV* stash)
			__attribute__nonnull__(pTHX_1);

PERL_CALLCONV void	Perl_boot_core_mro(pTHX);
PERL_CALLCONV void	Perl_sys_init(int* argc, char*** argv)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2);

PERL_CALLCONV void	Perl_sys_init3(int* argc, char*** argv, char*** env)
			__attribute__nonnull__(1)
			__attribute__nonnull__(2)
			__attribute__nonnull__(3);

PERL_CALLCONV void	Perl_sys_term(void);


END_EXTERN_C
/*
 * ex: set ts=8 sts=4 sw=4 noet:
 */
/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\regnodes.h ===
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regcomp.pl from regcomp.sym.
   Any changes made here will be lost!
*/

/* Regops and State definitions */

#define REGNODE_MAX           	90
#define REGMATCH_STATE_MAX    	130

#define	END                   	0	/* 0000 End of program. */
#define	SUCCEED               	1	/* 0x01 Return from a subroutine, basically. */
#define	BOL                   	2	/* 0x02 Match "" at beginning of line. */
#define	MBOL                  	3	/* 0x03 Same, assuming multiline. */
#define	SBOL                  	4	/* 0x04 Same, assuming singleline. */
#define	EOS                   	5	/* 0x05 Match "" at end of string. */
#define	EOL                   	6	/* 0x06 Match "" at end of line. */
#define	MEOL                  	7	/* 0x07 Same, assuming multiline. */
#define	SEOL                  	8	/* 0x08 Same, assuming singleline. */
#define	BOUND                 	9	/* 0x09 Match "" at any word boundary */
#define	BOUNDL                	10	/* 0x0a Match "" at any word boundary */
#define	NBOUND                	11	/* 0x0b Match "" at any word non-boundary */
#define	NBOUNDL               	12	/* 0x0c Match "" at any word non-boundary */
#define	GPOS                  	13	/* 0x0d Matches where last m//g left off. */
#define	REG_ANY               	14	/* 0x0e Match any one character (except newline). */
#define	SANY                  	15	/* 0x0f Match any one character. */
#define	CANY                  	16	/* 0x10 Match any one byte. */
#define	ANYOF                 	17	/* 0x11 Match character in (or not in) this class. */
#define	ALNUM                 	18	/* 0x12 Match any alphanumeric character */
#define	ALNUML                	19	/* 0x13 Match any alphanumeric char in locale */
#define	NALNUM                	20	/* 0x14 Match any non-alphanumeric character */
#define	NALNUML               	21	/* 0x15 Match any non-alphanumeric char in locale */
#define	SPACE                 	22	/* 0x16 Match any whitespace character */
#define	SPACEL                	23	/* 0x17 Match any whitespace char in locale */
#define	NSPACE                	24	/* 0x18 Match any non-whitespace character */
#define	NSPACEL               	25	/* 0x19 Match any non-whitespace char in locale */
#define	DIGIT                 	26	/* 0x1a Match any numeric character */
#define	DIGITL                	27	/* 0x1b Match any numeric character in locale */
#define	NDIGIT                	28	/* 0x1c Match any non-numeric character */
#define	NDIGITL               	29	/* 0x1d Match any non-numeric character in locale */
#define	CLUMP                 	30	/* 0x1e Match any combining character sequence */
#define	BRANCH                	31	/* 0x1f Match this alternative, or the next... */
#define	BACK                  	32	/* 0x20 Match "", "next" ptr points backward. */
#define	EXACT                 	33	/* 0x21 Match this string (preceded by length). */
#define	EXACTF                	34	/* 0x22 Match this string, folded (prec. by length). */
#define	EXACTFL               	35	/* 0x23 Match this string, folded in locale (w/len). */
#define	NOTHING               	36	/* 0x24 Match empty string. */
#define	TAIL                  	37	/* 0x25 Match empty string. Can jump here from outside. */
#define	STAR                  	38	/* 0x26 Match this (simple) thing 0 or more times. */
#define	PLUS                  	39	/* 0x27 Match this (simple) thing 1 or more times. */
#define	CURLY                 	40	/* 0x28 Match this simple thing {n,m} times. */
#define	CURLYN                	41	/* 0x29 Capture next-after-this simple thing */
#define	CURLYM                	42	/* 0x2a Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	43	/* 0x2b Match this complex thing {n,m} times. */
#define	WHILEM                	44	/* 0x2c Do curly processing and see if rest matches. */
#define	OPEN                  	45	/* 0x2d Mark this point in input as start of */
#define	CLOSE                 	46	/* 0x2e Analogous to OPEN. */
#define	REF                   	47	/* 0x2f Match some already matched string */
#define	REFF                  	48	/* 0x30 Match already matched string, folded */
#define	REFFL                 	49	/* 0x31 Match already matched string, folded in loc. */
#define	IFMATCH               	50	/* 0x32 Succeeds if the following matches. */
#define	UNLESSM               	51	/* 0x33 Fails if the following matches. */
#define	SUSPEND               	52	/* 0x34 "Independent" sub-RE. */
#define	IFTHEN                	53	/* 0x35 Switch, should be preceeded by switcher . */
#define	GROUPP                	54	/* 0x36 Whether the group matched. */
#define	LONGJMP               	55	/* 0x37 Jump far away. */
#define	BRANCHJ               	56	/* 0x38 BRANCH with long offset. */
#define	EVAL                  	57	/* 0x39 Execute some Perl code. */
#define	MINMOD                	58	/* 0x3a Next operator is not greedy. */
#define	LOGICAL               	59	/* 0x3b Next opcode should set the flag only. */
#define	RENUM                 	60	/* 0x3c Group with independently numbered parens. */
#define	TRIE                  	61	/* 0x3d Match many EXACT(FL?)? at once. flags==type */
#define	TRIEC                 	62	/* 0x3e Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	63	/* 0x3f Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	64	/* 0x40 Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	65	/* 0x41 recurse to paren arg1 at (signed) ofs arg2 */
#define	GOSTART               	66	/* 0x42 recurse to start of pattern */
#define	NREF                  	67	/* 0x43 Match some already matched string */
#define	NREFF                 	68	/* 0x44 Match already matched string, folded */
#define	NREFFL                	69	/* 0x45 Match already matched string, folded in loc. */
#define	NGROUPP               	70	/* 0x46 Whether the group matched. */
#define	INSUBP                	71	/* 0x47 Whether we are in a specific recurse. */
#define	DEFINEP               	72	/* 0x48 Never execute directly. */
#define	ENDLIKE               	73	/* 0x49 Used only for the type field of verbs */
#define	OPFAIL                	74	/* 0x4a Same as (?!) */
#define	ACCEPT                	75	/* 0x4b Accepts the current matched string. */
#define	VERB                  	76	/* 0x4c    no-sv 1	Used only for the type field of verbs */
#define	PRUNE                 	77	/* 0x4d Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	78	/* 0x4e Push the current location for rollback by cut. */
#define	SKIP                  	79	/* 0x4f On failure skip forward (to the mark) before retrying */
#define	COMMIT                	80	/* 0x50 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	81	/* 0x51 On failure go to the next alternation in the group */
#define	KEEPS                 	82	/* 0x52 $& begins here. */
#define	LNBREAK               	83	/* 0x53 generic newline pattern */
#define	VERTWS                	84	/* 0x54 vertical whitespace         (Perl 6) */
#define	NVERTWS               	85	/* 0x55 not vertical whitespace     (Perl 6) */
#define	HORIZWS               	86	/* 0x56 horizontal whitespace       (Perl 6) */
#define	NHORIZWS              	87	/* 0x57 not horizontal whitespace   (Perl 6) */
#define	FOLDCHAR              	88	/* 0x58 codepoint with tricky case folding properties. */
#define	OPTIMIZED             	89	/* 0x59 Placeholder for dump. */
#define	PSEUDO                	90	/* 0x5a Pseudo opcode for internal use. */
	/* ------------ States ------------- */
#define	TRIE_next             	(REGNODE_MAX + 1)	/* state for TRIE */
#define	TRIE_next_fail        	(REGNODE_MAX + 2)	/* state for TRIE */
#define	EVAL_AB               	(REGNODE_MAX + 3)	/* state for EVAL */
#define	EVAL_AB_fail          	(REGNODE_MAX + 4)	/* state for EVAL */
#define	CURLYX_end            	(REGNODE_MAX + 5)	/* state for CURLYX */
#define	CURLYX_end_fail       	(REGNODE_MAX + 6)	/* state for CURLYX */
#define	WHILEM_A_pre          	(REGNODE_MAX + 7)	/* state for WHILEM */
#define	WHILEM_A_pre_fail     	(REGNODE_MAX + 8)	/* state for WHILEM */
#define	WHILEM_A_min          	(REGNODE_MAX + 9)	/* state for WHILEM */
#define	WHILEM_A_min_fail     	(REGNODE_MAX + 10)	/* state for WHILEM */
#define	WHILEM_A_max          	(REGNODE_MAX + 11)	/* state for WHILEM */
#define	WHILEM_A_max_fail     	(REGNODE_MAX + 12)	/* state for WHILEM */
#define	WHILEM_B_min          	(REGNODE_MAX + 13)	/* state for WHILEM */
#define	WHILEM_B_min_fail     	(REGNODE_MAX + 14)	/* state for WHILEM */
#define	WHILEM_B_max          	(REGNODE_MAX + 15)	/* state for WHILEM */
#define	WHILEM_B_max_fail     	(REGNODE_MAX + 16)	/* state for WHILEM */
#define	BRANCH_next           	(REGNODE_MAX + 17)	/* state for BRANCH */
#define	BRANCH_next_fail      	(REGNODE_MAX + 18)	/* state for BRANCH */
#define	CURLYM_A              	(REGNODE_MAX + 19)	/* state for CURLYM */
#define	CURLYM_A_fail         	(REGNODE_MAX + 20)	/* state for CURLYM */
#define	CURLYM_B              	(REGNODE_MAX + 21)	/* state for CURLYM */
#define	CURLYM_B_fail         	(REGNODE_MAX + 22)	/* state for CURLYM */
#define	IFMATCH_A             	(REGNODE_MAX + 23)	/* state for IFMATCH */
#define	IFMATCH_A_fail        	(REGNODE_MAX + 24)	/* state for IFMATCH */
#define	CURLY_B_min_known     	(REGNODE_MAX + 25)	/* state for CURLY */
#define	CURLY_B_min_known_fail	(REGNODE_MAX + 26)	/* state for CURLY */
#define	CURLY_B_min           	(REGNODE_MAX + 27)	/* state for CURLY */
#define	CURLY_B_min_fail      	(REGNODE_MAX + 28)	/* state for CURLY */
#define	CURLY_B_max           	(REGNODE_MAX + 29)	/* state for CURLY */
#define	CURLY_B_max_fail      	(REGNODE_MAX + 30)	/* state for CURLY */
#define	COMMIT_next           	(REGNODE_MAX + 31)	/* state for COMMIT */
#define	COMMIT_next_fail      	(REGNODE_MAX + 32)	/* state for COMMIT */
#define	MARKPOINT_next        	(REGNODE_MAX + 33)	/* state for MARKPOINT */
#define	MARKPOINT_next_fail   	(REGNODE_MAX + 34)	/* state for MARKPOINT */
#define	SKIP_next             	(REGNODE_MAX + 35)	/* state for SKIP */
#define	SKIP_next_fail        	(REGNODE_MAX + 36)	/* state for SKIP */
#define	CUTGROUP_next         	(REGNODE_MAX + 37)	/* state for CUTGROUP */
#define	CUTGROUP_next_fail    	(REGNODE_MAX + 38)	/* state for CUTGROUP */
#define	KEEPS_next            	(REGNODE_MAX + 39)	/* state for KEEPS */
#define	KEEPS_next_fail       	(REGNODE_MAX + 40)	/* state for KEEPS */

/* PL_regkind[] What type of regop or state is this. */

#ifndef DOINIT
EXTCONST U8 PL_regkind[];
#else
EXTCONST U8 PL_regkind[] = {
	END,      	/* END                    */
	END,      	/* SUCCEED                */
	BOL,      	/* BOL                    */
	BOL,      	/* MBOL                   */
	BOL,      	/* SBOL                   */
	EOL,      	/* EOS                    */
	EOL,      	/* EOL                    */
	EOL,      	/* MEOL                   */
	EOL,      	/* SEOL                   */
	BOUND,    	/* BOUND                  */
	BOUND,    	/* BOUNDL                 */
	NBOUND,   	/* NBOUND                 */
	NBOUND,   	/* NBOUNDL                */
	GPOS,     	/* GPOS                   */
	REG_ANY,  	/* REG_ANY                */
	REG_ANY,  	/* SANY                   */
	REG_ANY,  	/* CANY                   */
	ANYOF,    	/* ANYOF                  */
	ALNUM,    	/* ALNUM                  */
	ALNUM,    	/* ALNUML                 */
	NALNUM,   	/* NALNUM                 */
	NALNUM,   	/* NALNUML                */
	SPACE,    	/* SPACE                  */
	SPACE,    	/* SPACEL                 */
	NSPACE,   	/* NSPACE                 */
	NSPACE,   	/* NSPACEL                */
	DIGIT,    	/* DIGIT                  */
	DIGIT,    	/* DIGITL                 */
	NDIGIT,   	/* NDIGIT                 */
	NDIGIT,   	/* NDIGITL                */
	CLUMP,    	/* CLUMP                  */
	BRANCH,   	/* BRANCH                 */
	BACK,     	/* BACK                   */
	EXACT,    	/* EXACT                  */
	EXACT,    	/* EXACTF                 */
	EXACT,    	/* EXACTFL                */
	NOTHING,  	/* NOTHING                */
	NOTHING,  	/* TAIL                   */
	STAR,     	/* STAR                   */
	PLUS,     	/* PLUS                   */
	CURLY,    	/* CURLY                  */
	CURLY,    	/* CURLYN                 */
	CURLY,    	/* CURLYM                 */
	CURLY,    	/* CURLYX                 */
	WHILEM,   	/* WHILEM                 */
	OPEN,     	/* OPEN                   */
	CLOSE,    	/* CLOSE                  */
	REF,      	/* REF                    */
	REF,      	/* REFF                   */
	REF,      	/* REFFL                  */
	BRANCHJ,  	/* IFMATCH                */
	BRANCHJ,  	/* UNLESSM                */
	BRANCHJ,  	/* SUSPEND                */
	BRANCHJ,  	/* IFTHEN                 */
	GROUPP,   	/* GROUPP                 */
	LONGJMP,  	/* LONGJMP                */
	BRANCHJ,  	/* BRANCHJ                */
	EVAL,     	/* EVAL                   */
	MINMOD,   	/* MINMOD                 */
	LOGICAL,  	/* LOGICAL                */
	BRANCHJ,  	/* RENUM                  */
	TRIE,     	/* TRIE                   */
	TRIE,     	/* TRIEC                  */
	TRIE,     	/* AHOCORASICK            */
	TRIE,     	/* AHOCORASICKC           */
	GOSUB,    	/* GOSUB                  */
	GOSTART,  	/* GOSTART                */
	REF,      	/* NREF                   */
	REF,      	/* NREFF                  */
	REF,      	/* NREFFL                 */
	NGROUPP,  	/* NGROUPP                */
	INSUBP,   	/* INSUBP                 */
	DEFINEP,  	/* DEFINEP                */
	ENDLIKE,  	/* ENDLIKE                */
	ENDLIKE,  	/* OPFAIL                 */
	ENDLIKE,  	/* ACCEPT                 */
	VERB,     	/* VERB                   */
	VERB,     	/* PRUNE                  */
	VERB,     	/* MARKPOINT              */
	VERB,     	/* SKIP                   */
	VERB,     	/* COMMIT                 */
	VERB,     	/* CUTGROUP               */
	KEEPS,    	/* KEEPS                  */
	LNBREAK,  	/* LNBREAK                */
	VERTWS,   	/* VERTWS                 */
	NVERTWS,  	/* NVERTWS                */
	HORIZWS,  	/* HORIZWS                */
	NHORIZWS, 	/* NHORIZWS               */
	FOLDCHAR, 	/* FOLDCHAR               */
	NOTHING,  	/* OPTIMIZED              */
	PSEUDO,   	/* PSEUDO                 */
	/* ------------ States ------------- */
	TRIE,     	/* TRIE_next              */
	TRIE,     	/* TRIE_next_fail         */
	EVAL,     	/* EVAL_AB                */
	EVAL,     	/* EVAL_AB_fail           */
	CURLYX,   	/* CURLYX_end             */
	CURLYX,   	/* CURLYX_end_fail        */
	WHILEM,   	/* WHILEM_A_pre           */
	WHILEM,   	/* WHILEM_A_pre_fail      */
	WHILEM,   	/* WHILEM_A_min           */
	WHILEM,   	/* WHILEM_A_min_fail      */
	WHILEM,   	/* WHILEM_A_max           */
	WHILEM,   	/* WHILEM_A_max_fail      */
	WHILEM,   	/* WHILEM_B_min           */
	WHILEM,   	/* WHILEM_B_min_fail      */
	WHILEM,   	/* WHILEM_B_max           */
	WHILEM,   	/* WHILEM_B_max_fail      */
	BRANCH,   	/* BRANCH_next            */
	BRANCH,   	/* BRANCH_next_fail       */
	CURLYM,   	/* CURLYM_A               */
	CURLYM,   	/* CURLYM_A_fail          */
	CURLYM,   	/* CURLYM_B               */
	CURLYM,   	/* CURLYM_B_fail          */
	IFMATCH,  	/* IFMATCH_A              */
	IFMATCH,  	/* IFMATCH_A_fail         */
	CURLY,    	/* CURLY_B_min_known      */
	CURLY,    	/* CURLY_B_min_known_fail */
	CURLY,    	/* CURLY_B_min            */
	CURLY,    	/* CURLY_B_min_fail       */
	CURLY,    	/* CURLY_B_max            */
	CURLY,    	/* CURLY_B_max_fail       */
	COMMIT,   	/* COMMIT_next            */
	COMMIT,   	/* COMMIT_next_fail       */
	MARKPOINT,	/* MARKPOINT_next         */
	MARKPOINT,	/* MARKPOINT_next_fail    */
	SKIP,     	/* SKIP_next              */
	SKIP,     	/* SKIP_next_fail         */
	CUTGROUP, 	/* CUTGROUP_next          */
	CUTGROUP, 	/* CUTGROUP_next_fail     */
	KEEPS,    	/* KEEPS_next             */
	KEEPS,    	/* KEEPS_next_fail        */
};
#endif

/* regarglen[] - How large is the argument part of the node (in regnodes) */

#ifdef REG_COMP_C
static const U8 regarglen[] = {
	0,                                   	/* END          */
	0,                                   	/* SUCCEED      */
	0,                                   	/* BOL          */
	0,                                   	/* MBOL         */
	0,                                   	/* SBOL         */
	0,                                   	/* EOS          */
	0,                                   	/* EOL          */
	0,                                   	/* MEOL         */
	0,                                   	/* SEOL         */
	0,                                   	/* BOUND        */
	0,                                   	/* BOUNDL       */
	0,                                   	/* NBOUND       */
	0,                                   	/* NBOUNDL      */
	0,                                   	/* GPOS         */
	0,                                   	/* REG_ANY      */
	0,                                   	/* SANY         */
	0,                                   	/* CANY         */
	0,                                   	/* ANYOF        */
	0,                                   	/* ALNUM        */
	0,                                   	/* ALNUML       */
	0,                                   	/* NALNUM       */
	0,                                   	/* NALNUML      */
	0,                                   	/* SPACE        */
	0,                                   	/* SPACEL       */
	0,                                   	/* NSPACE       */
	0,                                   	/* NSPACEL      */
	0,                                   	/* DIGIT        */
	0,                                   	/* DIGITL       */
	0,                                   	/* NDIGIT       */
	0,                                   	/* NDIGITL      */
	0,                                   	/* CLUMP        */
	0,                                   	/* BRANCH       */
	0,                                   	/* BACK         */
	0,                                   	/* EXACT        */
	0,                                   	/* EXACTF       */
	0,                                   	/* EXACTFL      */
	0,                                   	/* NOTHING      */
	0,                                   	/* TAIL         */
	0,                                   	/* STAR         */
	0,                                   	/* PLUS         */
	EXTRA_SIZE(struct regnode_2),        	/* CURLY        */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYN       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYM       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYX       */
	0,                                   	/* WHILEM       */
	EXTRA_SIZE(struct regnode_1),        	/* OPEN         */
	EXTRA_SIZE(struct regnode_1),        	/* CLOSE        */
	EXTRA_SIZE(struct regnode_1),        	/* REF          */
	EXTRA_SIZE(struct regnode_1),        	/* REFF         */
	EXTRA_SIZE(struct regnode_1),        	/* REFFL        */
	EXTRA_SIZE(struct regnode_1),        	/* IFMATCH      */
	EXTRA_SIZE(struct regnode_1),        	/* UNLESSM      */
	EXTRA_SIZE(struct regnode_1),        	/* SUSPEND      */
	EXTRA_SIZE(struct regnode_1),        	/* IFTHEN       */
	EXTRA_SIZE(struct regnode_1),        	/* GROUPP       */
	EXTRA_SIZE(struct regnode_1),        	/* LONGJMP      */
	EXTRA_SIZE(struct regnode_1),        	/* BRANCHJ      */
	EXTRA_SIZE(struct regnode_1),        	/* EVAL         */
	0,                                   	/* MINMOD       */
	0,                                   	/* LOGICAL      */
	EXTRA_SIZE(struct regnode_1),        	/* RENUM        */
	EXTRA_SIZE(struct regnode_1),        	/* TRIE         */
	EXTRA_SIZE(struct regnode_charclass),	/* TRIEC        */
	EXTRA_SIZE(struct regnode_1),        	/* AHOCORASICK  */
	EXTRA_SIZE(struct regnode_charclass),	/* AHOCORASICKC */
	EXTRA_SIZE(struct regnode_2L),       	/* GOSUB        */
	0,                                   	/* GOSTART      */
	EXTRA_SIZE(struct regnode_1),        	/* NREF         */
	EXTRA_SIZE(struct regnode_1),        	/* NREFF        */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFL       */
	EXTRA_SIZE(struct regnode_1),        	/* NGROUPP      */
	EXTRA_SIZE(struct regnode_1),        	/* INSUBP       */
	EXTRA_SIZE(struct regnode_1),        	/* DEFINEP      */
	0,                                   	/* ENDLIKE      */
	0,                                   	/* OPFAIL       */
	EXTRA_SIZE(struct regnode_1),        	/* ACCEPT       */
	0,                                   	/* VERB         */
	EXTRA_SIZE(struct regnode_1),        	/* PRUNE        */
	EXTRA_SIZE(struct regnode_1),        	/* MARKPOINT    */
	EXTRA_SIZE(struct regnode_1),        	/* SKIP         */
	EXTRA_SIZE(struct regnode_1),        	/* COMMIT       */
	EXTRA_SIZE(struct regnode_1),        	/* CUTGROUP     */
	0,                                   	/* KEEPS        */
	0,                                   	/* LNBREAK      */
	0,                                   	/* VERTWS       */
	0,                                   	/* NVERTWS      */
	0,                                   	/* HORIZWS      */
	0,                                   	/* NHORIZWS     */
	EXTRA_SIZE(struct regnode_1),        	/* FOLDCHAR     */
	0,                                   	/* OPTIMIZED    */
	0,                                   	/* PSEUDO       */
};

/* reg_off_by_arg[] - Which argument holds the offset to the next node */

static const char reg_off_by_arg[] = {
	0,	/* END          */
	0,	/* SUCCEED      */
	0,	/* BOL          */
	0,	/* MBOL         */
	0,	/* SBOL         */
	0,	/* EOS          */
	0,	/* EOL          */
	0,	/* MEOL         */
	0,	/* SEOL         */
	0,	/* BOUND        */
	0,	/* BOUNDL       */
	0,	/* NBOUND       */
	0,	/* NBOUNDL      */
	0,	/* GPOS         */
	0,	/* REG_ANY      */
	0,	/* SANY         */
	0,	/* CANY         */
	0,	/* ANYOF        */
	0,	/* ALNUM        */
	0,	/* ALNUML       */
	0,	/* NALNUM       */
	0,	/* NALNUML      */
	0,	/* SPACE        */
	0,	/* SPACEL       */
	0,	/* NSPACE       */
	0,	/* NSPACEL      */
	0,	/* DIGIT        */
	0,	/* DIGITL       */
	0,	/* NDIGIT       */
	0,	/* NDIGITL      */
	0,	/* CLUMP        */
	0,	/* BRANCH       */
	0,	/* BACK         */
	0,	/* EXACT        */
	0,	/* EXACTF       */
	0,	/* EXACTFL      */
	0,	/* NOTHING      */
	0,	/* TAIL         */
	0,	/* STAR         */
	0,	/* PLUS         */
	0,	/* CURLY        */
	0,	/* CURLYN       */
	0,	/* CURLYM       */
	0,	/* CURLYX       */
	0,	/* WHILEM       */
	0,	/* OPEN         */
	0,	/* CLOSE        */
	0,	/* REF          */
	0,	/* REFF         */
	0,	/* REFFL        */
	2,	/* IFMATCH      */
	2,	/* UNLESSM      */
	1,	/* SUSPEND      */
	1,	/* IFTHEN       */
	0,	/* GROUPP       */
	1,	/* LONGJMP      */
	1,	/* BRANCHJ      */
	0,	/* EVAL         */
	0,	/* MINMOD       */
	0,	/* LOGICAL      */
	1,	/* RENUM        */
	0,	/* TRIE         */
	0,	/* TRIEC        */
	0,	/* AHOCORASICK  */
	0,	/* AHOCORASICKC */
	0,	/* GOSUB        */
	0,	/* GOSTART      */
	0,	/* NREF         */
	0,	/* NREFF        */
	0,	/* NREFFL       */
	0,	/* NGROUPP      */
	0,	/* INSUBP       */
	0,	/* DEFINEP      */
	0,	/* ENDLIKE      */
	0,	/* OPFAIL       */
	0,	/* ACCEPT       */
	0,	/* VERB         */
	0,	/* PRUNE        */
	0,	/* MARKPOINT    */
	0,	/* SKIP         */
	0,	/* COMMIT       */
	0,	/* CUTGROUP     */
	0,	/* KEEPS        */
	0,	/* LNBREAK      */
	0,	/* VERTWS       */
	0,	/* NVERTWS      */
	0,	/* HORIZWS      */
	0,	/* NHORIZWS     */
	0,	/* FOLDCHAR     */
	0,	/* OPTIMIZED    */
	0,	/* PSEUDO       */
};

#endif /* REG_COMP_C */

/* reg_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_name[];
#else
EXTCONST char * const PL_reg_name[] = {
	"END",                   	/* 0000 */
	"SUCCEED",               	/* 0x01 */
	"BOL",                   	/* 0x02 */
	"MBOL",                  	/* 0x03 */
	"SBOL",                  	/* 0x04 */
	"EOS",                   	/* 0x05 */
	"EOL",                   	/* 0x06 */
	"MEOL",                  	/* 0x07 */
	"SEOL",                  	/* 0x08 */
	"BOUND",                 	/* 0x09 */
	"BOUNDL",                	/* 0x0a */
	"NBOUND",                	/* 0x0b */
	"NBOUNDL",               	/* 0x0c */
	"GPOS",                  	/* 0x0d */
	"REG_ANY",               	/* 0x0e */
	"SANY",                  	/* 0x0f */
	"CANY",                  	/* 0x10 */
	"ANYOF",                 	/* 0x11 */
	"ALNUM",                 	/* 0x12 */
	"ALNUML",                	/* 0x13 */
	"NALNUM",                	/* 0x14 */
	"NALNUML",               	/* 0x15 */
	"SPACE",                 	/* 0x16 */
	"SPACEL",                	/* 0x17 */
	"NSPACE",                	/* 0x18 */
	"NSPACEL",               	/* 0x19 */
	"DIGIT",                 	/* 0x1a */
	"DIGITL",                	/* 0x1b */
	"NDIGIT",                	/* 0x1c */
	"NDIGITL",               	/* 0x1d */
	"CLUMP",                 	/* 0x1e */
	"BRANCH",                	/* 0x1f */
	"BACK",                  	/* 0x20 */
	"EXACT",                 	/* 0x21 */
	"EXACTF",                	/* 0x22 */
	"EXACTFL",               	/* 0x23 */
	"NOTHING",               	/* 0x24 */
	"TAIL",                  	/* 0x25 */
	"STAR",                  	/* 0x26 */
	"PLUS",                  	/* 0x27 */
	"CURLY",                 	/* 0x28 */
	"CURLYN",                	/* 0x29 */
	"CURLYM",                	/* 0x2a */
	"CURLYX",                	/* 0x2b */
	"WHILEM",                	/* 0x2c */
	"OPEN",                  	/* 0x2d */
	"CLOSE",                 	/* 0x2e */
	"REF",                   	/* 0x2f */
	"REFF",                  	/* 0x30 */
	"REFFL",                 	/* 0x31 */
	"IFMATCH",               	/* 0x32 */
	"UNLESSM",               	/* 0x33 */
	"SUSPEND",               	/* 0x34 */
	"IFTHEN",                	/* 0x35 */
	"GROUPP",                	/* 0x36 */
	"LONGJMP",               	/* 0x37 */
	"BRANCHJ",               	/* 0x38 */
	"EVAL",                  	/* 0x39 */
	"MINMOD",                	/* 0x3a */
	"LOGICAL",               	/* 0x3b */
	"RENUM",                 	/* 0x3c */
	"TRIE",                  	/* 0x3d */
	"TRIEC",                 	/* 0x3e */
	"AHOCORASICK",           	/* 0x3f */
	"AHOCORASICKC",          	/* 0x40 */
	"GOSUB",                 	/* 0x41 */
	"GOSTART",               	/* 0x42 */
	"NREF",                  	/* 0x43 */
	"NREFF",                 	/* 0x44 */
	"NREFFL",                	/* 0x45 */
	"NGROUPP",               	/* 0x46 */
	"INSUBP",                	/* 0x47 */
	"DEFINEP",               	/* 0x48 */
	"ENDLIKE",               	/* 0x49 */
	"OPFAIL",                	/* 0x4a */
	"ACCEPT",                	/* 0x4b */
	"VERB",                  	/* 0x4c */
	"PRUNE",                 	/* 0x4d */
	"MARKPOINT",             	/* 0x4e */
	"SKIP",                  	/* 0x4f */
	"COMMIT",                	/* 0x50 */
	"CUTGROUP",              	/* 0x51 */
	"KEEPS",                 	/* 0x52 */
	"LNBREAK",               	/* 0x53 */
	"VERTWS",                	/* 0x54 */
	"NVERTWS",               	/* 0x55 */
	"HORIZWS",               	/* 0x56 */
	"NHORIZWS",              	/* 0x57 */
	"FOLDCHAR",              	/* 0x58 */
	"OPTIMIZED",             	/* 0x59 */
	"PSEUDO",                	/* 0x5a */
	/* ------------ States ------------- */
	"TRIE_next",             	/* REGNODE_MAX +0x01 */
	"TRIE_next_fail",        	/* REGNODE_MAX +0x02 */
	"EVAL_AB",               	/* REGNODE_MAX +0x03 */
	"EVAL_AB_fail",          	/* REGNODE_MAX +0x04 */
	"CURLYX_end",            	/* REGNODE_MAX +0x05 */
	"CURLYX_end_fail",       	/* REGNODE_MAX +0x06 */
	"WHILEM_A_pre",          	/* REGNODE_MAX +0x07 */
	"WHILEM_A_pre_fail",     	/* REGNODE_MAX +0x08 */
	"WHILEM_A_min",          	/* REGNODE_MAX +0x09 */
	"WHILEM_A_min_fail",     	/* REGNODE_MAX +0x0a */
	"WHILEM_A_max",          	/* REGNODE_MAX +0x0b */
	"WHILEM_A_max_fail",     	/* REGNODE_MAX +0x0c */
	"WHILEM_B_min",          	/* REGNODE_MAX +0x0d */
	"WHILEM_B_min_fail",     	/* REGNODE_MAX +0x0e */
	"WHILEM_B_max",          	/* REGNODE_MAX +0x0f */
	"WHILEM_B_max_fail",     	/* REGNODE_MAX +0x10 */
	"BRANCH_next",           	/* REGNODE_MAX +0x11 */
	"BRANCH_next_fail",      	/* REGNODE_MAX +0x12 */
	"CURLYM_A",              	/* REGNODE_MAX +0x13 */
	"CURLYM_A_fail",         	/* REGNODE_MAX +0x14 */
	"CURLYM_B",              	/* REGNODE_MAX +0x15 */
	"CURLYM_B_fail",         	/* REGNODE_MAX +0x16 */
	"IFMATCH_A",             	/* REGNODE_MAX +0x17 */
	"IFMATCH_A_fail",        	/* REGNODE_MAX +0x18 */
	"CURLY_B_min_known",     	/* REGNODE_MAX +0x19 */
	"CURLY_B_min_known_fail",	/* REGNODE_MAX +0x1a */
	"CURLY_B_min",           	/* REGNODE_MAX +0x1b */
	"CURLY_B_min_fail",      	/* REGNODE_MAX +0x1c */
	"CURLY_B_max",           	/* REGNODE_MAX +0x1d */
	"CURLY_B_max_fail",      	/* REGNODE_MAX +0x1e */
	"COMMIT_next",           	/* REGNODE_MAX +0x1f */
	"COMMIT_next_fail",      	/* REGNODE_MAX +0x20 */
	"MARKPOINT_next",        	/* REGNODE_MAX +0x21 */
	"MARKPOINT_next_fail",   	/* REGNODE_MAX +0x22 */
	"SKIP_next",             	/* REGNODE_MAX +0x23 */
	"SKIP_next_fail",        	/* REGNODE_MAX +0x24 */
	"CUTGROUP_next",         	/* REGNODE_MAX +0x25 */
	"CUTGROUP_next_fail",    	/* REGNODE_MAX +0x26 */
	"KEEPS_next",            	/* REGNODE_MAX +0x27 */
	"KEEPS_next_fail",       	/* REGNODE_MAX +0x28 */
};
#endif /* DOINIT */

/* PL_reg_extflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_extflags_name[];
#else
EXTCONST char * const PL_reg_extflags_name[] = {
	/* Bits in extflags defined: 11111111111111111111111100111111 */
	"ANCH_BOL",         /* 0x00000001 */
	"ANCH_MBOL",        /* 0x00000002 */
	"ANCH_SBOL",        /* 0x00000004 */
	"ANCH_GPOS",        /* 0x00000008 */
	"GPOS_SEEN",        /* 0x00000010 */
	"GPOS_FLOAT",       /* 0x00000020 */
	"UNUSED_BIT_6",     /* 0x00000040 */
	"UNUSED_BIT_7",     /* 0x00000080 */
	"SKIPWHITE",        /* 0x00000100 */
	"START_ONLY",       /* 0x00000200 */
	"WHITE",            /* 0x00000400 */
	"LOCALE",           /* 0x00000800 */
	"MULTILINE",        /* 0x00001000 */
	"SINGLELINE",       /* 0x00002000 */
	"FOLD",             /* 0x00004000 */
	"EXTENDED",         /* 0x00008000 */
	"KEEPCOPY",         /* 0x00010000 */
	"LOOKBEHIND_SEEN",  /* 0x00020000 */
	"EVAL_SEEN",        /* 0x00040000 */
	"CANY_SEEN",        /* 0x00080000 */
	"NOSCAN",           /* 0x00100000 */
	"CHECK_ALL",        /* 0x00200000 */
	"UTF8",             /* 0x00400000 */
	"MATCH_UTF8",       /* 0x00800000 */
	"USE_INTUIT_NOML",  /* 0x01000000 */
	"USE_INTUIT_ML",    /* 0x02000000 */
	"INTUIT_TAIL",      /* 0x04000000 */
	"SPLIT",            /* 0x08000000 */
	"COPY_DONE",        /* 0x10000000 */
	"TAINTED_SEEN",     /* 0x20000000 */
	"NULL",             /* 0x40000000 */
	"TAINTED",          /* 0x80000000 */
};
#endif /* DOINIT */

/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\scope.h ===
/*    scope.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2004, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#define SAVEt_ITEM		0
#define SAVEt_SV		1
#define SAVEt_AV		2
#define SAVEt_HV		3
#define SAVEt_INT		4
#define SAVEt_LONG		5
#define SAVEt_I32		6
#define SAVEt_IV		7
#define SAVEt_SPTR		8
#define SAVEt_APTR		9
#define SAVEt_HPTR		10
#define SAVEt_PPTR		11
#define SAVEt_NSTAB		12
#define SAVEt_SVREF		13
#define SAVEt_GP		14
#define SAVEt_FREESV		15
#define SAVEt_FREEOP		16
#define SAVEt_FREEPV		17
#define SAVEt_CLEARSV		18
#define SAVEt_DELETE		19
#define SAVEt_DESTRUCTOR	20
#define SAVEt_REGCONTEXT	21
#define SAVEt_STACK_POS		22
#define SAVEt_I16		23
#define SAVEt_AELEM		24
#define SAVEt_HELEM		25
#define SAVEt_OP		26
#define SAVEt_HINTS		27
#define SAVEt_ALLOC		28
#define SAVEt_GENERIC_SVREF	29
#define SAVEt_DESTRUCTOR_X	30
#define SAVEt_VPTR		31
#define SAVEt_I8		32
#define SAVEt_COMPPAD		33
#define SAVEt_GENERIC_PVREF	34
#define SAVEt_PADSV		35
#define SAVEt_MORTALIZESV	36
#define SAVEt_SHARED_PVREF	37
#define SAVEt_BOOL		38
#define SAVEt_SET_SVFLAGS	39
#define SAVEt_SAVESWITCHSTACK	40
#define SAVEt_COP_ARYBASE	41
#define SAVEt_RE_STATE		42
#define SAVEt_COMPILE_WARNINGS	43
#define SAVEt_STACK_CXPOS	44
#define SAVEt_PARSER		45

#ifndef SCOPE_SAVES_SIGNAL_MASK
#define SCOPE_SAVES_SIGNAL_MASK 0
#endif

#define SSCHECK(need) if (PL_savestack_ix + (I32)(need) > PL_savestack_max) savestack_grow()
#define SSGROW(need) if (PL_savestack_ix + (I32)(need) > PL_savestack_max) savestack_grow_cnt(need)
#define SSPUSHINT(i) (PL_savestack[PL_savestack_ix++].any_i32 = (I32)(i))
#define SSPUSHLONG(i) (PL_savestack[PL_savestack_ix++].any_long = (long)(i))
#define SSPUSHBOOL(p) (PL_savestack[PL_savestack_ix++].any_bool = (p))
#define SSPUSHIV(i) (PL_savestack[PL_savestack_ix++].any_iv = (IV)(i))
#define SSPUSHPTR(p) (PL_savestack[PL_savestack_ix++].any_ptr = (void*)(p))
#define SSPUSHDPTR(p) (PL_savestack[PL_savestack_ix++].any_dptr = (p))
#define SSPUSHDXPTR(p) (PL_savestack[PL_savestack_ix++].any_dxptr = (p))
#define SSPOPINT (PL_savestack[--PL_savestack_ix].any_i32)
#define SSPOPLONG (PL_savestack[--PL_savestack_ix].any_long)
#define SSPOPBOOL (PL_savestack[--PL_savestack_ix].any_bool)
#define SSPOPIV (PL_savestack[--PL_savestack_ix].any_iv)
#define SSPOPPTR (PL_savestack[--PL_savestack_ix].any_ptr)
#define SSPOPDPTR (PL_savestack[--PL_savestack_ix].any_dptr)
#define SSPOPDXPTR (PL_savestack[--PL_savestack_ix].any_dxptr)

/*
=head1 Callback Functions

=for apidoc Ams||SAVETMPS
Opening bracket for temporaries on a callback.  See C<FREETMPS> and
L<perlcall>.

=for apidoc Ams||FREETMPS
Closing bracket for temporaries on a callback.  See C<SAVETMPS> and
L<perlcall>.

=for apidoc Ams||ENTER
Opening bracket on a callback.  See C<LEAVE> and L<perlcall>.

=for apidoc Ams||LEAVE
Closing bracket on a callback.  See C<ENTER> and L<perlcall>.

=cut
*/

#define SAVETMPS save_int((int*)&PL_tmps_floor), PL_tmps_floor = PL_tmps_ix
#define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps()

#ifdef DEBUGGING
#define ENTER							\
    STMT_START {						\
	push_scope();						\
	DEBUG_SCOPE("ENTER")					\
    } STMT_END
#define LEAVE							\
    STMT_START {						\
	DEBUG_SCOPE("LEAVE")					\
	pop_scope();						\
    } STMT_END
#else
#define ENTER push_scope()
#define LEAVE pop_scope()
#endif
#define LEAVE_SCOPE(old) if (PL_savestack_ix > old) leave_scope(old)

#define SAVEI8(i)	save_I8((I8*)&(i))
#define SAVEI16(i)	save_I16((I16*)&(i))
#define SAVEI32(i)	save_I32((I32*)&(i))
#define SAVEINT(i)	save_int((int*)&(i))
#define SAVEIV(i)	save_iv((IV*)&(i))
#define SAVELONG(l)	save_long((long*)&(l))
#define SAVEBOOL(b)	save_bool((bool*)&(b))
#define SAVESPTR(s)	save_sptr((SV**)&(s))
#define SAVEPPTR(s)	save_pptr((char**)&(s))
#define SAVEVPTR(s)	save_vptr((void*)&(s))
#define SAVEPADSV(s)	save_padsv(s)
#define SAVEFREESV(s)	save_freesv((SV*)(s))
#define SAVEMORTALIZESV(s)	save_mortalizesv((SV*)(s))
#define SAVEFREEOP(o)	save_freeop((OP*)(o))
#define SAVEFREEPV(p)	save_freepv((char*)(p))
#define SAVECLEARSV(sv)	save_clearsv((SV**)&(sv))
#define SAVEGENERICSV(s)	save_generic_svref((SV**)&(s))
#define SAVEGENERICPV(s)	save_generic_pvref((char**)&(s))
#define SAVESHAREDPV(s)		save_shared_pvref((char**)&(s))
#define SAVESETSVFLAGS(sv,mask,val)	save_set_svflags(sv,mask,val)
#define SAVEDELETE(h,k,l) \
	  save_delete((HV*)(h), (char*)(k), (I32)(l))
#define SAVEDESTRUCTOR(f,p) \
	  save_destructor((DESTRUCTORFUNC_NOCONTEXT_t)(f), (void*)(p))

#define SAVEDESTRUCTOR_X(f,p) \
	  save_destructor_x((DESTRUCTORFUNC_t)(f), (void*)(p))

#define SAVESTACK_POS() \
    STMT_START {				\
	SSCHECK(2);				\
	SSPUSHINT(PL_stack_sp - PL_stack_base);	\
	SSPUSHINT(SAVEt_STACK_POS);		\
    } STMT_END

#define SAVEOP()	save_op()

#define SAVEHINTS() \
    STMT_START {					\
	SSCHECK(4);					\
	if (PL_hints & HINT_LOCALIZE_HH) {		\
	    SSPUSHPTR(GvHV(PL_hintgv));			\
	    GvHV(PL_hintgv) = Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv)); \
	}						\
	if (PL_compiling.cop_hints_hash) {		\
	    HINTS_REFCNT_LOCK;				\
	    PL_compiling.cop_hints_hash->refcounted_he_refcnt++;	\
	    HINTS_REFCNT_UNLOCK;			\
	}						\
	SSPUSHPTR(PL_compiling.cop_hints_hash);		\
	SSPUSHINT(PL_hints);				\
	SSPUSHINT(SAVEt_HINTS);				\
    } STMT_END

#define SAVECOMPPAD() \
    STMT_START {						\
	SSCHECK(2);						\
	SSPUSHPTR((SV*)PL_comppad);				\
	SSPUSHINT(SAVEt_COMPPAD);				\
    } STMT_END

#define SAVESWITCHSTACK(f,t) \
    STMT_START {					\
	SSCHECK(3);					\
	SSPUSHPTR((SV*)(f));				\
	SSPUSHPTR((SV*)(t));				\
	SSPUSHINT(SAVEt_SAVESWITCHSTACK);		\
	SWITCHSTACK((f),(t));				\
	PL_curstackinfo->si_stack = (t);		\
    } STMT_END

#define SAVECOPARYBASE(c) \
    STMT_START {					\
	SSCHECK(3);					\
	SSPUSHINT(CopARYBASE_get(c));			\
	SSPUSHPTR(c);					\
	SSPUSHINT(SAVEt_COP_ARYBASE);			\
    } STMT_END

/* Need to do the cop warnings like this, rather than a "SAVEFREESHAREDPV",
   because realloc() means that the value can actually change. Possibly
   could have done savefreesharedpvREF, but this way actually seems cleaner,
   as it simplifies the code that does the saves, and reduces the load on the
   save stack.  */
#define SAVECOMPILEWARNINGS() \
    STMT_START {					\
	SSCHECK(2);					\
	SSPUSHPTR(PL_compiling.cop_warnings);		\
	SSPUSHINT(SAVEt_COMPILE_WARNINGS);		\
    } STMT_END

#define SAVESTACK_CXPOS() \
    STMT_START {                                  \
        SSCHECK(3);                               \
        SSPUSHINT(cxstack[cxstack_ix].blk_oldsp); \
        SSPUSHINT(cxstack_ix);                    \
        SSPUSHINT(SAVEt_STACK_CXPOS);             \
    } STMT_END

#define SAVEPARSER(p) \
    STMT_START {                                  \
        SSCHECK(2);                               \
        SSPUSHPTR(p);		                  \
        SSPUSHINT(SAVEt_PARSER); 	          \
    } STMT_END

#ifdef USE_ITHREADS
#  define SAVECOPSTASH(c)	SAVEPPTR(CopSTASHPV(c))
#  define SAVECOPSTASH_FREE(c)	SAVESHAREDPV(CopSTASHPV(c))
#  define SAVECOPFILE(c)	SAVEPPTR(CopFILE(c))
#  define SAVECOPFILE_FREE(c)	SAVESHAREDPV(CopFILE(c))
#  define SAVECOPLABEL(c)	SAVEPPTR(CopLABEL(c))
#  define SAVECOPLABEL_FREE(c)	SAVESHAREDPV(CopLABEL(c))
#else
#  define SAVECOPSTASH(c)	SAVESPTR(CopSTASH(c))
#  define SAVECOPSTASH_FREE(c)	SAVECOPSTASH(c)	/* XXX not refcounted */
#  define SAVECOPFILE(c)	SAVESPTR(CopFILEGV(c))
#  define SAVECOPFILE_FREE(c)	SAVEGENERICSV(CopFILEGV(c))
#  define SAVECOPLABEL(c)	SAVEPPTR(CopLABEL(c))
#  define SAVECOPLABEL_FREE(c)	SAVEPPTR(CopLABEL(c))
#endif

#define SAVECOPLINE(c)		SAVEI32(CopLINE(c))

/* SSNEW() temporarily allocates a specified number of bytes of data on the
 * savestack.  It returns an integer index into the savestack, because a
 * pointer would get broken if the savestack is moved on reallocation.
 * SSNEWa() works like SSNEW(), but also aligns the data to the specified
 * number of bytes.  MEM_ALIGNBYTES is perhaps the most useful.  The
 * alignment will be preserved therough savestack reallocation *only* if
 * realloc returns data aligned to a size divisible by "align"!
 *
 * SSPTR() converts the index returned by SSNEW/SSNEWa() into a pointer.
 */

#define SSNEW(size)             Perl_save_alloc(aTHX_ (size), 0)
#define SSNEWt(n,t)             SSNEW((n)*sizeof(t))
#define SSNEWa(size,align)	Perl_save_alloc(aTHX_ (size), \
    (align - ((int)((caddr_t)&PL_savestack[PL_savestack_ix]) % align)) % align)
#define SSNEWat(n,t,align)	SSNEWa((n)*sizeof(t), align)

#define SSPTR(off,type)         ((type)  ((char*)PL_savestack + off))
#define SSPTRt(off,type)        ((type*) ((char*)PL_savestack + off))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\sv.h ===
/*    sv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef sv_flags
#undef sv_flags		/* Convex has this in <signal.h> for sigvec() */
#endif

/*
=head1 SV Flags

=for apidoc AmU||svtype
An enum of flags for Perl types.  These are found in the file B<sv.h>
in the C<svtype> enum.  Test these flags with the C<SvTYPE> macro.

=for apidoc AmU||SVt_PV
Pointer type flag for scalars.  See C<svtype>.

=for apidoc AmU||SVt_IV
Integer type flag for scalars.  See C<svtype>.

=for apidoc AmU||SVt_NV
Double type flag for scalars.  See C<svtype>.

=for apidoc AmU||SVt_PVMG
Type flag for blessed scalars.  See C<svtype>.

=for apidoc AmU||SVt_PVAV
Type flag for arrays.  See C<svtype>.

=for apidoc AmU||SVt_PVHV
Type flag for hashes.  See C<svtype>.

=for apidoc AmU||SVt_PVCV
Type flag for code refs.  See C<svtype>.

=cut
*/

typedef enum {
	SVt_NULL,	/* 0 */
	SVt_BIND,	/* 1 */
	SVt_IV,		/* 2 */
	SVt_NV,		/* 3 */
	SVt_RV,		/* 4 */
	SVt_PV,		/* 5 */
	SVt_PVIV,	/* 6 */
	SVt_PVNV,	/* 7 */
	SVt_PVMG,	/* 8 */
	/* PVBM was here, before BIND replaced it.  */
	SVt_PVGV,	/* 9 */
	SVt_PVLV,	/* 10 */
	SVt_PVAV,	/* 11 */
	SVt_PVHV,	/* 12 */
	SVt_PVCV,	/* 13 */
	SVt_PVFM,	/* 14 */
	SVt_PVIO,	/* 15 */
	SVt_LAST	/* keep last in enum. used to size arrays */
} svtype;

#ifndef PERL_CORE
/* Although Fast Boyer Moore tables are now being stored in PVGVs, for most
   purposes eternal code wanting to consider PVBM probably needs to think of
   PVMG instead.  */
#  define SVt_PVBM	SVt_PVMG
#endif

/* There is collusion here with sv_clear - sv_clear exits early for SVt_NULL
   and SVt_IV, so never reaches the clause at the end that uses
   sv_type_details->body_size to determine whether to call safefree(). Hence
   body_size can be set no-zero to record the size of PTEs and HEs, without
   fear of bogus frees.  */
#ifdef PERL_IN_SV_C
#define PTE_SVSLOT	SVt_IV
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_IN_XS_APITEST)
#define HE_SVSLOT	SVt_NULL
#endif

#define PERL_ARENA_ROOTS_SIZE	(SVt_LAST)

/* typedefs to eliminate some typing */
typedef struct he HE;
typedef struct hek HEK;

/* Using C's structural equivalence to help emulate C++ inheritance here... */

/* start with 2 sv-head building blocks */
#define _SV_HEAD(ptrtype) \
    ptrtype	sv_any;		/* pointer to body */	\
    U32		sv_refcnt;	/* how many references to us */	\
    U32		sv_flags	/* what we are */

#define _SV_HEAD_UNION \
    union {				\
	IV      svu_iv;			\
	UV      svu_uv;			\
	SV*     svu_rv;		/* pointer to another SV */		\
	char*   svu_pv;		/* pointer to malloced string */	\
	SV**    svu_array;		\
	HE**	svu_hash;		\
	GP*	svu_gp;			\
    }	sv_u


struct STRUCT_SV {		/* struct sv { */
    _SV_HEAD(void*);
    _SV_HEAD_UNION;
#ifdef DEBUG_LEAKING_SCALARS
    unsigned	sv_debug_optype:9;	/* the type of OP that allocated us */
    unsigned	sv_debug_inpad:1;	/* was allocated in a pad for an OP */
    unsigned	sv_debug_cloned:1;	/* was cloned for an ithread */
    unsigned	sv_debug_line:16;	/* the line where we were allocated */
    char *	sv_debug_file;		/* the file where we were allocated */
#endif
};

struct gv {
    _SV_HEAD(XPVGV*);		/* pointer to xpvgv body */
    _SV_HEAD_UNION;
};

struct cv {
    _SV_HEAD(XPVCV*);		/* pointer to xpvcv body */
    _SV_HEAD_UNION;
};

struct av {
    _SV_HEAD(XPVAV*);		/* pointer to xpvav body */
    _SV_HEAD_UNION;
};

struct hv {
    _SV_HEAD(XPVHV*);		/* pointer to xpvhv body */
    _SV_HEAD_UNION;
};

struct io {
    _SV_HEAD(XPVIO*);		/* pointer to xpvio body */
    _SV_HEAD_UNION;
};

#undef _SV_HEAD
#undef _SV_HEAD_UNION		/* ensure no pollution */

/*
=head1 SV Manipulation Functions

=for apidoc Am|U32|SvREFCNT|SV* sv
Returns the value of the object's reference count.

=for apidoc Am|SV*|SvREFCNT_inc|SV* sv
Increments the reference count of the given SV.

All of the following SvREFCNT_inc* macros are optimized versions of
SvREFCNT_inc, and can be replaced with SvREFCNT_inc.

=for apidoc Am|SV*|SvREFCNT_inc_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_void|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_void_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple|SV* sv
Same as SvREFCNT_inc, but can only be used with expressions without side
effects.  Since we don't have to store a temporary value, it's faster.

=for apidoc Am|SV*|SvREFCNT_inc_simple_NN|SV* sv
Same as SvREFCNT_inc_simple, but can only be used if you know I<sv>
is not NULL.  Since we don't have to check the NULLness, it's faster
and smaller.

=for apidoc Am|void|SvREFCNT_inc_simple_void|SV* sv
Same as SvREFCNT_inc_simple, but can only be used if you don't need the
return value.  The macro doesn't need to return a meaningful value.

=for apidoc Am|void|SvREFCNT_inc_simple_void_NN|SV* sv
Same as SvREFCNT_inc, but can only be used if you don't need the return
value, and you know that I<sv> is not NULL.  The macro doesn't need
to return a meaningful value, or check for NULLness, so it's smaller
and faster.

=for apidoc Am|void|SvREFCNT_dec|SV* sv
Decrements the reference count of the given SV.

=for apidoc Am|svtype|SvTYPE|SV* sv
Returns the type of the SV.  See C<svtype>.

=for apidoc Am|void|SvUPGRADE|SV* sv|svtype type
Used to upgrade an SV to a more complex form.  Uses C<sv_upgrade> to
perform the upgrade if necessary.  See C<svtype>.

=cut
*/

#define SvANY(sv)	(sv)->sv_any
#define SvFLAGS(sv)	(sv)->sv_flags
#define SvREFCNT(sv)	(sv)->sv_refcnt

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
#  define SvREFCNT_inc(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	if (_sv)			\
	     (SvREFCNT(_sv))++;		\
	_sv;				\
    })
#  define SvREFCNT_inc_simple(sv)	\
    ({					\
	if (sv)				\
	     (SvREFCNT(sv))++;		\
	(SV *)(sv);				\
    })
#  define SvREFCNT_inc_NN(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	SvREFCNT(_sv)++;		\
	_sv;				\
    })
#  define SvREFCNT_inc_void(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	if (_sv)			\
	    (void)(SvREFCNT(_sv)++);	\
    })
#else
#  define SvREFCNT_inc(sv)	\
	((PL_Sv=(SV*)(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
#  define SvREFCNT_inc_simple(sv) \
	((sv) ? (SvREFCNT(sv)++,(SV*)(sv)) : NULL)
#  define SvREFCNT_inc_NN(sv) \
	(PL_Sv=(SV*)(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
#  define SvREFCNT_inc_void(sv) \
	(void)((PL_Sv=(SV*)(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
#endif

/* These guys don't need the curly blocks */
#define SvREFCNT_inc_simple_void(sv)	STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
#define SvREFCNT_inc_simple_NN(sv)	(++(SvREFCNT(sv)),(SV*)(sv))
#define SvREFCNT_inc_void_NN(sv)	(void)(++SvREFCNT((SV*)(sv)))
#define SvREFCNT_inc_simple_void_NN(sv)	(void)(++SvREFCNT((SV*)(sv)))

#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && !defined(PERL_GCC_PEDANTIC)
#  define SvREFCNT_dec(sv)		\
    ({					\
	SV * const _sv = (SV*)(sv);	\
	if (_sv) {			\
	    if (SvREFCNT(_sv)) {	\
		if (--(SvREFCNT(_sv)) == 0) \
		    Perl_sv_free2(aTHX_ _sv);	\
	    } else {			\
		sv_free(_sv);		\
	    }				\
	}				\
    })
#else
#define SvREFCNT_dec(sv)	sv_free((SV*)(sv))
#endif

#define SVTYPEMASK	0xff
#define SvTYPE(sv)	((svtype)((sv)->sv_flags & SVTYPEMASK))

/* Sadly there are some parts of the core that have pointers to already-freed
   SV heads, and rely on being able to tell that they are now free. So mark
   them all by using a consistent macro.  */
#define SvIS_FREED(sv)	((sv)->sv_flags == SVTYPEMASK)

#define SvUPGRADE(sv, mt) (SvTYPE(sv) >= (mt) || (sv_upgrade(sv, mt), 1))

#define SVf_IOK		0x00000100  /* has valid public integer value */
#define SVf_NOK		0x00000200  /* has valid public numeric value */
#define SVf_POK		0x00000400  /* has valid public pointer value */
#define SVf_ROK		0x00000800  /* has a valid reference pointer */

#define SVp_IOK		0x00001000  /* has valid non-public integer value */
#define SVp_NOK		0x00002000  /* has valid non-public numeric value */
#define SVp_POK		0x00004000  /* has valid non-public pointer value */
#define SVp_SCREAM	0x00008000  /* has been studied? */
#define SVphv_CLONEABLE	SVp_SCREAM  /* PVHV (stashes) clone its objects */
#define SVpgv_GP	SVp_SCREAM  /* GV has a valid GP */
#define SVprv_PCS_IMPORTED  SVp_SCREAM  /* RV is a proxy for a constant
				       subroutine in another package. Set the
				       CvIMPORTED_CV_ON() if it needs to be
				       expanded to a real GV */

#define SVs_PADSTALE	0x00010000  /* lexical has gone out of scope */
#define SVpad_STATE	0x00010000  /* pad name is a "state" var */
#define SVs_PADTMP	0x00020000  /* in use as tmp */
#define SVpad_TYPED	0x00020000  /* pad name is a Typed Lexical */
#define SVs_PADMY	0x00040000  /* in use a "my" variable */
#define SVpad_OUR	0x00040000  /* pad name is "our" instead of "my" */
#define SVs_TEMP	0x00080000  /* string is stealable? */
#define SVs_OBJECT	0x00100000  /* is "blessed" */
#define SVs_GMG		0x00200000  /* has magical get method */
#define SVs_SMG		0x00400000  /* has magical set method */
#define SVs_RMG		0x00800000  /* has random magical methods */

#define SVf_FAKE	0x01000000  /* 0: glob or lexical is just a copy
				       1: SV head arena wasn't malloc()ed
				       2: in conjunction with SVf_READONLY
					  marks a shared hash key scalar
					  (SvLEN == 0) or a copy on write
					  string (SvLEN != 0) [SvIsCOW(sv)]
				       3: For PVCV, whether CvUNIQUE(cv)
					  refers to an eval or once only
					  [CvEVAL(cv), CvSPECIAL(cv)]
				       4: Whether the regexp pointer is in
					  fact an offset [SvREPADTMP(sv)]
				       5: On a pad name SV, that slot in the
					  frame AV is a REFCNT'ed reference
					  to a lexical from "outside". */
#define SVphv_REHASH	SVf_FAKE    /* 6: On a PVHV, hash values are being
					  recalculated */
#define SVf_OOK		0x02000000  /* has valid offset value. For a PVHV this
				       means that a hv_aux struct is present
				       after the main array */
#define SVf_BREAK	0x04000000  /* refcnt is artificially low - used by
				       SV's in final arena cleanup */
#define SVf_READONLY	0x08000000  /* may not be modified */




#define SVf_THINKFIRST	(SVf_READONLY|SVf_ROK|SVf_FAKE)

#define SVf_OK		(SVf_IOK|SVf_NOK|SVf_POK|SVf_ROK| \
			 SVp_IOK|SVp_NOK|SVp_POK|SVpgv_GP)

#define PRIVSHIFT 4	/* (SVp_?OK >> PRIVSHIFT) == SVf_?OK */

#define SVf_AMAGIC	0x10000000  /* has magical overloaded methods */

/* Ensure this value does not clash with the GV_ADD* flags in gv.h: */
#define SVf_UTF8        0x20000000  /* SvPV is UTF-8 encoded
				       This is also set on RVs whose overloaded
				       stringification is UTF-8. This might
				       only happen as a side effect of SvPV() */
					   

/* Some private flags. */

/* PVAV could probably use 0x2000000 without conflict. I assume that PVFM can
   be UTF-8 encoded, and PVCVs could well have UTF-8 prototypes. PVIOs haven't
   been restructured, so sometimes get used as string buffers.  */

/* PVHV */
#define SVphv_SHAREKEYS 0x20000000  /* PVHV keys live on shared string table */
/* PVNV, PVMG, presumably only inside pads */
#define SVpad_NAME	0x40000000  /* This SV is a name in the PAD, so
				       SVpad_TYPED, SVpad_OUR and SVpad_STATE
				       apply */
/* PVAV */
#define SVpav_REAL	0x40000000  /* free old entries */
/* PVHV */
#define SVphv_LAZYDEL	0x40000000  /* entry in xhv_eiter must be deleted */
/* This is only set true on a PVGV when it's playing "PVBM", but is tested for
   on any regular scalar (anything <= PVLV) */
#define SVpbm_VALID	0x40000000
/* ??? */
#define SVrepl_EVAL	0x40000000  /* Replacement part of s///e */

/* IV, PVIV, PVNV, PVMG, PVGV and (I assume) PVLV  */
/* Presumably IVs aren't stored in pads */
#define SVf_IVisUV	0x80000000  /* use XPVUV instead of XPVIV */
/* PVAV */
#define SVpav_REIFY 	0x80000000  /* can become real */
/* PVHV */
#define SVphv_HASKFLAGS	0x80000000  /* keys have flag byte after hash */
/* PVFM */
#define SVpfm_COMPILED	0x80000000  /* FORMLINE is compiled */
/* PVGV when SVpbm_VALID is true */
#define SVpbm_TAIL	0x80000000
/* RV upwards. However, SVf_ROK and SVp_IOK are exclusive  */
#define SVprv_WEAKREF   0x80000000  /* Weak reference */


struct xpv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
};

typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
} xpv_allocated;

struct xpviv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
};

typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
} xpviv_allocated;

#define xiv_iv xiv_u.xivu_iv

struct xpvuv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xuvu_iv;
	UV	xuvu_uv;	/* unsigned value or pv offset */
	void *	xuvu_p1;
	HEK *	xivu_namehek;
    }		xuv_u;
};

#define xuv_uv xuv_u.xuvu_uv

struct xpvnv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
};

/* These structure must match the beginning of struct xpvhv in hv.h. */
struct xpvmg {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */
};

struct xpvlv {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;	/* GvNAME */
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    STRLEN	xlv_targoff;
    STRLEN	xlv_targlen;
    SV*		xlv_targ;
    char	xlv_type;	/* k=keys .=pos x=substr v=vec /=join/re
				 * y=alem/helem/iter t=tie T=tied HE */
};

/* This structure works in 3 ways - regular scalar, GV with GP, or fast
   Boyer-Moore.  */
struct xpvgv {
    union {
	NV	xnv_nv;
	HV *	xgv_stash;	/* The stash of this GV */
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* xgv_flags */
    STRLEN	xpv_len;	/* 0 */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* is this constant pattern being useful? */
	HEK *	xivu_namehek;	/* GvNAME */
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

};

/* This structure must match XPVCV in cv.h */

typedef U16 cv_flags_t;

struct xpvfm {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* PVFMs use the pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    AV *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
    IV		xfm_lines;
};

typedef struct {
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* PVFMs use the pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    AV *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
    IV		xfm_lines;
} xpvfm_allocated;

struct xpvio {
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of svu_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;	/* integer value or pv offset */
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    PerlIO *	xio_ifp;	/* ifp and ofp are normally the same */
    PerlIO *	xio_ofp;	/* but sockets need separate streams */
    /* Cray addresses everything by word boundaries (64 bits) and
     * code and data pointers cannot be mixed (which is exactly what
     * Perl_filter_add() tries to do with the dirp), hence the following
     * union trick (as suggested by Gurusamy Sarathy).
     * For further information see Geir Johansen's problem report titled
       [ID 20000612.002] Perl problem on Cray system
     * The any pointer (known as IoANY()) will also be a good place
     * to hang any IO disciplines to.
     */
    union {
	DIR *	xiou_dirp;	/* for opendir, readdir, etc */
	void *	xiou_any;	/* for alignment */
    } xio_dirpu;
    IV		xio_lines;	/* $. */
    IV		xio_page;	/* $% */
    IV		xio_page_len;	/* $= */
    IV		xio_lines_left;	/* $- */
    char *	xio_top_name;	/* $^ */
    GV *	xio_top_gv;	/* $^ */
    char *	xio_fmt_name;	/* $~ */
    GV *	xio_fmt_gv;	/* $~ */
    char *	xio_bottom_name;/* $^B */
    GV *	xio_bottom_gv;	/* $^B */
    char	xio_type;
    U8		xio_flags;
};
#define xio_dirp	xio_dirpu.xiou_dirp
#define xio_any		xio_dirpu.xiou_any

#define IOf_ARGV	1	/* this fp iterates over ARGV */
#define IOf_START	2	/* check for null ARGV and substitute '-' */
#define IOf_FLUSH	4	/* this fp wants a flush after write op */
#define IOf_DIDTOP	8	/* just did top of form */
#define IOf_UNTAINT	16	/* consider this fp (and its data) "safe" */
#define IOf_NOLINE	32	/* slurped a pseudo-line from empty file */
#define IOf_FAKE_DIRP	64	/* xio_dirp is fake (source filters kludge) */

/* The following macros define implementation-independent predicates on SVs. */

/*
=for apidoc Am|U32|SvNIOK|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.

=for apidoc Am|U32|SvNIOKp|SV* sv
Returns a U32 value indicating whether the SV contains a number, integer or
double.  Checks the B<private> setting.  Use C<SvNIOK>.

=for apidoc Am|void|SvNIOK_off|SV* sv
Unsets the NV/IV status of an SV.

=for apidoc Am|U32|SvOK|SV* sv
Returns a U32 value indicating whether the value is an SV. It also tells
whether the value is defined or not.

=for apidoc Am|U32|SvIOKp|SV* sv
Returns a U32 value indicating whether the SV contains an integer.  Checks
the B<private> setting.  Use C<SvIOK>.

=for apidoc Am|U32|SvNOKp|SV* sv
Returns a U32 value indicating whether the SV contains a double.  Checks the
B<private> setting.  Use C<SvNOK>.

=for apidoc Am|U32|SvPOKp|SV* sv
Returns a U32 value indicating whether the SV contains a character string.
Checks the B<private> setting.  Use C<SvPOK>.

=for apidoc Am|U32|SvIOK|SV* sv
Returns a U32 value indicating whether the SV contains an integer.

=for apidoc Am|void|SvIOK_on|SV* sv
Tells an SV that it is an integer.

=for apidoc Am|void|SvIOK_off|SV* sv
Unsets the IV status of an SV.

=for apidoc Am|void|SvIOK_only|SV* sv
Tells an SV that it is an integer and disables all other OK bits.

=for apidoc Am|void|SvIOK_only_UV|SV* sv
Tells and SV that it is an unsigned integer and disables all other OK bits.

=for apidoc Am|bool|SvIOK_UV|SV* sv
Returns a boolean indicating whether the SV contains an unsigned integer.

=for apidoc Am|bool|SvUOK|SV* sv
Returns a boolean indicating whether the SV contains an unsigned integer.

=for apidoc Am|bool|SvIOK_notUV|SV* sv
Returns a boolean indicating whether the SV contains a signed integer.

=for apidoc Am|U32|SvNOK|SV* sv
Returns a U32 value indicating whether the SV contains a double.

=for apidoc Am|void|SvNOK_on|SV* sv
Tells an SV that it is a double.

=for apidoc Am|void|SvNOK_off|SV* sv
Unsets the NV status of an SV.

=for apidoc Am|void|SvNOK_only|SV* sv
Tells an SV that it is a double and disables all other OK bits.

=for apidoc Am|U32|SvPOK|SV* sv
Returns a U32 value indicating whether the SV contains a character
string.

=for apidoc Am|void|SvPOK_on|SV* sv
Tells an SV that it is a string.

=for apidoc Am|void|SvPOK_off|SV* sv
Unsets the PV status of an SV.

=for apidoc Am|void|SvPOK_only|SV* sv
Tells an SV that it is a string and disables all other OK bits.
Will also turn off the UTF-8 status.

=for apidoc Am|bool|SvVOK|SV* sv
Returns a boolean indicating whether the SV contains a v-string.

=for apidoc Am|U32|SvOOK|SV* sv
Returns a U32 indicating whether the SvIVX is a valid offset value for
the SvPVX.  This hack is used internally to speed up removal of characters
from the beginning of a SvPV.  When SvOOK is true, then the start of the
allocated string buffer is really (SvPVX - SvIVX).

=for apidoc Am|U32|SvROK|SV* sv
Tests if the SV is an RV.

=for apidoc Am|void|SvROK_on|SV* sv
Tells an SV that it is an RV.

=for apidoc Am|void|SvROK_off|SV* sv
Unsets the RV status of an SV.

=for apidoc Am|SV*|SvRV|SV* sv
Dereferences an RV to return the SV.

=for apidoc Am|IV|SvIVX|SV* sv
Returns the raw value in the SV's IV slot, without checks or conversions.
Only use when you are sure SvIOK is true. See also C<SvIV()>.

=for apidoc Am|UV|SvUVX|SV* sv
Returns the raw value in the SV's UV slot, without checks or conversions.
Only use when you are sure SvIOK is true. See also C<SvUV()>.

=for apidoc Am|NV|SvNVX|SV* sv
Returns the raw value in the SV's NV slot, without checks or conversions.
Only use when you are sure SvNOK is true. See also C<SvNV()>.

=for apidoc Am|char*|SvPVX|SV* sv
Returns a pointer to the physical string in the SV.  The SV must contain a
string.

=for apidoc Am|STRLEN|SvCUR|SV* sv
Returns the length of the string which is in the SV.  See C<SvLEN>.

=for apidoc Am|STRLEN|SvLEN|SV* sv
Returns the size of the string buffer in the SV, not including any part
attributable to C<SvOOK>.  See C<SvCUR>.

=for apidoc Am|char*|SvEND|SV* sv
Returns a pointer to the last character in the string which is in the SV.
See C<SvCUR>.  Access the character as *(SvEND(sv)).

=for apidoc Am|HV*|SvSTASH|SV* sv
Returns the stash of the SV.

=for apidoc Am|void|SvIV_set|SV* sv|IV val
Set the value of the IV pointer in sv to val.  It is possible to perform
the same function of this macro with an lvalue assignment to C<SvIVX>.
With future Perls, however, it will be more efficient to use 
C<SvIV_set> instead of the lvalue assignment to C<SvIVX>.

=for apidoc Am|void|SvNV_set|SV* sv|NV val
Set the value of the NV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvPV_set|SV* sv|char* val
Set the value of the PV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvUV_set|SV* sv|UV val
Set the value of the UV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvRV_set|SV* sv|SV* val
Set the value of the RV pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvMAGIC_set|SV* sv|MAGIC* val
Set the value of the MAGIC pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvSTASH_set|SV* sv|HV* val
Set the value of the STASH pointer in sv to val.  See C<SvIV_set>.

=for apidoc Am|void|SvCUR_set|SV* sv|STRLEN len
Set the current length of the string which is in the SV.  See C<SvCUR>
and C<SvIV_set>.

=for apidoc Am|void|SvLEN_set|SV* sv|STRLEN len
Set the actual length of the string which is in the SV.  See C<SvIV_set>.

=cut
*/

#define SvNIOK(sv)		(SvFLAGS(sv) & (SVf_IOK|SVf_NOK))
#define SvNIOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK))
#define SvNIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK| \
						  SVp_IOK|SVp_NOK|SVf_IVisUV))

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#define assert_not_ROK(sv)	({assert(!SvROK(sv) || !SvRV(sv));}),
#define assert_not_glob(sv)	({assert(!isGV_with_GP(sv));}),
#else
#define assert_not_ROK(sv)	
#define assert_not_glob(sv)	
#endif

#define SvOK(sv)		((SvTYPE(sv) == SVt_BIND)		\
				 ? (SvFLAGS(SvRV(sv)) & SVf_OK)		\
				 : (SvFLAGS(sv) & SVf_OK))
#define SvOK_off(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
							SvOOK_off(sv))
#define SvOK_off_exc_UV(sv)	(assert_not_ROK(sv)			\
				 SvFLAGS(sv) &=	~(SVf_OK|		\
						  SVf_UTF8),		\
							SvOOK_off(sv))

#define SvOKp(sv)		(SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK))
#define SvIOKp(sv)		(SvFLAGS(sv) & SVp_IOK)
#define SvIOKp_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX(sv), \
				    SvFLAGS(sv) |= SVp_IOK)
#define SvNOKp(sv)		(SvFLAGS(sv) & SVp_NOK)
#define SvNOKp_on(sv)		(assert_not_glob(sv) SvFLAGS(sv) |= SVp_NOK)
#define SvPOKp(sv)		(SvFLAGS(sv) & SVp_POK)
#define SvPOKp_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= SVp_POK)

#define SvIOK(sv)		(SvFLAGS(sv) & SVf_IOK)
#define SvIOK_on(sv)		(assert_not_glob(sv) SvRELEASE_IVX(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_IOK|SVp_IOK|SVf_IVisUV))
#define SvIOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))
#define SvIOK_only_UV(sv)	(assert_not_glob(sv) SvOK_off_exc_UV(sv), \
				    SvFLAGS(sv) |= (SVf_IOK|SVp_IOK))

#define SvIOK_UV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == (SVf_IOK|SVf_IVisUV))
#define SvUOK(sv)		SvIOK_UV(sv)
#define SvIOK_notUV(sv)		((SvFLAGS(sv) & (SVf_IOK|SVf_IVisUV))	\
				 == SVf_IOK)

#define SvIsUV(sv)		(SvFLAGS(sv) & SVf_IVisUV)
#define SvIsUV_on(sv)		(SvFLAGS(sv) |= SVf_IVisUV)
#define SvIsUV_off(sv)		(SvFLAGS(sv) &= ~SVf_IVisUV)

#define SvNOK(sv)		(SvFLAGS(sv) & SVf_NOK)
#define SvNOK_on(sv)		(assert_not_glob(sv) \
				 SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))
#define SvNOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_NOK|SVp_NOK))
#define SvNOK_only(sv)		(SvOK_off(sv), \
				    SvFLAGS(sv) |= (SVf_NOK|SVp_NOK))

/*
=for apidoc Am|U32|SvUTF8|SV* sv
Returns a U32 value indicating whether the SV contains UTF-8 encoded data.
Call this after SvPV() in case any call to string overloading updates the
internal flag.

=for apidoc Am|void|SvUTF8_on|SV *sv
Turn on the UTF-8 status of an SV (the data is not changed, just the flag).
Do not use frivolously.

=for apidoc Am|void|SvUTF8_off|SV *sv
Unsets the UTF-8 status of an SV.

=for apidoc Am|void|SvPOK_only_UTF8|SV* sv
Tells an SV that it is a string and disables all other OK bits,
and leaves the UTF-8 status as it was.

=cut
 */

/* Ensure the return value of this macro does not clash with the GV_ADD* flags
in gv.h: */
#define SvUTF8(sv)		(SvFLAGS(sv) & SVf_UTF8)
#define SvUTF8_on(sv)		(SvFLAGS(sv) |= (SVf_UTF8))
#define SvUTF8_off(sv)		(SvFLAGS(sv) &= ~(SVf_UTF8))

#define SvPOK(sv)		(SvFLAGS(sv) & SVf_POK)
#define SvPOK_on(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_off(sv)		(SvFLAGS(sv) &= ~(SVf_POK|SVp_POK))
#define SvPOK_only(sv)		(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV|SVf_UTF8),	\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))
#define SvPOK_only_UTF8(sv)	(assert_not_ROK(sv) assert_not_glob(sv)	\
				 SvFLAGS(sv) &= ~(SVf_OK|		\
						  SVf_IVisUV),		\
				    SvFLAGS(sv) |= (SVf_POK|SVp_POK))

#define SvVOK(sv)		(SvMAGICAL(sv)				\
				 && mg_find(sv,PERL_MAGIC_vstring))
/* returns the vstring magic, if any */
#define SvVSTRING_mg(sv)	(SvMAGICAL(sv) \
				 ? mg_find(sv,PERL_MAGIC_vstring) : NULL)

#define SvOOK(sv)		(SvFLAGS(sv) & SVf_OOK)
#define SvOOK_on(sv)		((void)SvIOK_off(sv), SvFLAGS(sv) |= SVf_OOK)
#define SvOOK_off(sv)		((void)(SvOOK(sv) && sv_backoff(sv)))

#define SvFAKE(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvFAKE_on(sv)		(SvFLAGS(sv) |= SVf_FAKE)
#define SvFAKE_off(sv)		(SvFLAGS(sv) &= ~SVf_FAKE)

#define SvROK(sv)		(SvFLAGS(sv) & SVf_ROK)
#define SvROK_on(sv)		(SvFLAGS(sv) |= SVf_ROK)
#define SvROK_off(sv)		(SvFLAGS(sv) &= ~(SVf_ROK))

#define SvMAGICAL(sv)		(SvFLAGS(sv) & (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_on(sv)	(SvFLAGS(sv) |= (SVs_GMG|SVs_SMG|SVs_RMG))
#define SvMAGICAL_off(sv)	(SvFLAGS(sv) &= ~(SVs_GMG|SVs_SMG|SVs_RMG))

#define SvGMAGICAL(sv)		(SvFLAGS(sv) & SVs_GMG)
#define SvGMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_GMG)
#define SvGMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_GMG)

#define SvSMAGICAL(sv)		(SvFLAGS(sv) & SVs_SMG)
#define SvSMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_SMG)
#define SvSMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_SMG)

#define SvRMAGICAL(sv)		(SvFLAGS(sv) & SVs_RMG)
#define SvRMAGICAL_on(sv)	(SvFLAGS(sv) |= SVs_RMG)
#define SvRMAGICAL_off(sv)	(SvFLAGS(sv) &= ~SVs_RMG)

#define SvAMAGIC(sv)		(SvROK(sv) && (SvFLAGS(SvRV(sv)) & SVf_AMAGIC))
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvAMAGIC_on(sv)	({ SV * const kloink = sv;		\
				   assert(SvROK(kloink));		\
				   SvFLAGS(SvRV(kloink)) |= SVf_AMAGIC;	\
				})
#  define SvAMAGIC_off(sv)	({ SV * const kloink = sv;		\
				   if(SvROK(kloink))			\
					SvFLAGS(SvRV(kloink)) &= ~SVf_AMAGIC;\
				})
#else
#  define SvAMAGIC_on(sv)	(SvFLAGS(SvRV(sv)) |= SVf_AMAGIC)
#  define SvAMAGIC_off(sv) \
	(SvROK(sv) && (SvFLAGS(SvRV(sv)) &= ~SVf_AMAGIC))
#endif

/*
=for apidoc Am|char*|SvGAMAGIC|SV* sv

Returns true if the SV has get magic or overloading. If either is true then
the scalar is active data, and has the potential to return a new value every
time it is accessed. Hence you must be careful to only read it once per user
logical operation and work with that returned value. If neither is true then
the scalar's value cannot change unless written to.

=cut
*/

#define SvGAMAGIC(sv)           (SvGMAGICAL(sv) || SvAMAGIC(sv))

#define Gv_AMG(stash)           (PL_amagic_generation && Gv_AMupdate(stash))

#define SvWEAKREF(sv)		((SvFLAGS(sv) & (SVf_ROK|SVprv_WEAKREF)) \
				  == (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_WEAKREF))
#define SvWEAKREF_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_WEAKREF))

#define SvPCS_IMPORTED(sv)	((SvFLAGS(sv) & (SVf_ROK|SVprv_PCS_IMPORTED)) \
				 == (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_on(sv)	(SvFLAGS(sv) |=  (SVf_ROK|SVprv_PCS_IMPORTED))
#define SvPCS_IMPORTED_off(sv)	(SvFLAGS(sv) &= ~(SVf_ROK|SVprv_PCS_IMPORTED))

#define SvTHINKFIRST(sv)	(SvFLAGS(sv) & SVf_THINKFIRST)

#define SvPADSTALE(sv)		(SvFLAGS(sv) & SVs_PADSTALE)
#define SvPADSTALE_on(sv)	(SvFLAGS(sv) |= SVs_PADSTALE)
#define SvPADSTALE_off(sv)	(SvFLAGS(sv) &= ~SVs_PADSTALE)

#define SvPADTMP(sv)		(SvFLAGS(sv) & SVs_PADTMP)
#define SvPADTMP_on(sv)		(SvFLAGS(sv) |= SVs_PADTMP)
#define SvPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVs_PADTMP)

#define SvPADMY(sv)		(SvFLAGS(sv) & SVs_PADMY)
#define SvPADMY_on(sv)		(SvFLAGS(sv) |= SVs_PADMY)

#define SvTEMP(sv)		(SvFLAGS(sv) & SVs_TEMP)
#define SvTEMP_on(sv)		(SvFLAGS(sv) |= SVs_TEMP)
#define SvTEMP_off(sv)		(SvFLAGS(sv) &= ~SVs_TEMP)

#define SvOBJECT(sv)		(SvFLAGS(sv) & SVs_OBJECT)
#define SvOBJECT_on(sv)		(SvFLAGS(sv) |= SVs_OBJECT)
#define SvOBJECT_off(sv)	(SvFLAGS(sv) &= ~SVs_OBJECT)

#define SvREADONLY(sv)		(SvFLAGS(sv) & SVf_READONLY)
#define SvREADONLY_on(sv)	(SvFLAGS(sv) |= SVf_READONLY)
#define SvREADONLY_off(sv)	(SvFLAGS(sv) &= ~SVf_READONLY)

#define SvSCREAM(sv) ((SvFLAGS(sv) & (SVp_SCREAM|SVp_POK)) == (SVp_SCREAM|SVp_POK))
#define SvSCREAM_on(sv)		(SvFLAGS(sv) |= SVp_SCREAM)
#define SvSCREAM_off(sv)	(SvFLAGS(sv) &= ~SVp_SCREAM)

#define SvCOMPILED(sv)		(SvFLAGS(sv) & SVpfm_COMPILED)
#define SvCOMPILED_on(sv)	(SvFLAGS(sv) |= SVpfm_COMPILED)
#define SvCOMPILED_off(sv)	(SvFLAGS(sv) &= ~SVpfm_COMPILED)

#define SvEVALED(sv)		(SvFLAGS(sv) & SVrepl_EVAL)
#define SvEVALED_on(sv)		(SvFLAGS(sv) |= SVrepl_EVAL)
#define SvEVALED_off(sv)	(SvFLAGS(sv) &= ~SVrepl_EVAL)

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvVALID(sv)		({ SV *const thwacke = (SV *) (sv);	\
				   if (SvFLAGS(thwacke) & SVpbm_VALID)	\
				       assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) & SVpbm_VALID);	\
				})
#  define SvVALID_on(sv)	({ SV *const thwacke = (SV *) (sv);	\
				   assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) |= SVpbm_VALID);	\
				})
#  define SvVALID_off(sv)	({ SV *const thwacke = (SV *) (sv);	\
				   assert(!isGV_with_GP(thwacke));	\
				   (SvFLAGS(thwacke) &= ~SVpbm_VALID);	\
				})

#  define SvTAIL(sv)	({ SV *const _svi = (SV *) (sv);		\
			    assert(SvTYPE(_svi) != SVt_PVAV);		\
			    assert(SvTYPE(_svi) != SVt_PVHV);		\
			    (SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
				== (SVpbm_TAIL|SVpbm_VALID);		\
			})
#else
#  define SvVALID(sv)		(SvFLAGS(sv) & SVpbm_VALID)
#  define SvVALID_on(sv)	(SvFLAGS(sv) |= SVpbm_VALID)
#  define SvVALID_off(sv)	(SvFLAGS(sv) &= ~SVpbm_VALID)
#  define SvTAIL(sv)	    ((SvFLAGS(sv) & (SVpbm_TAIL|SVpbm_VALID))	\
			     == (SVpbm_TAIL|SVpbm_VALID))

#endif
#define SvTAIL_on(sv)		(SvFLAGS(sv) |= SVpbm_TAIL)
#define SvTAIL_off(sv)		(SvFLAGS(sv) &= ~SVpbm_TAIL)


#ifdef USE_ITHREADS
/* The following uses the FAKE flag to show that a regex pointer is infact
   its own offset in the regexpad for ithreads */
#define SvREPADTMP(sv)		(SvFLAGS(sv) & SVf_FAKE)
#define SvREPADTMP_on(sv)	(SvFLAGS(sv) |= SVf_FAKE)
#define SvREPADTMP_off(sv)	(SvFLAGS(sv) &= ~SVf_FAKE)
#endif

#define SvPAD_TYPED(sv) \
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_TYPED)) == (SVpad_NAME|SVpad_TYPED))

#define SvPAD_OUR(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_OUR)) == (SVpad_NAME|SVpad_OUR))

#define SvPAD_STATE(sv)	\
	((SvFLAGS(sv) & (SVpad_NAME|SVpad_STATE)) == (SVpad_NAME|SVpad_STATE))

#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define SvPAD_TYPED_on(sv)	({					\
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVMG);				\
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_TYPED);			\
	})
#define SvPAD_OUR_on(sv)	({					\
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVMG);				\
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_OUR);			\
	})
#define SvPAD_STATE_on(sv)	({					\
	    SV *const whap = (SV *) (sv);				\
	    assert(SvTYPE(whap) == SVt_PVNV || SvTYPE(whap) == SVt_PVMG); \
	    (SvFLAGS(whap) |= SVpad_NAME|SVpad_STATE);			\
	})
#else
#  define SvPAD_TYPED_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_TYPED)
#  define SvPAD_OUR_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_OUR)
#  define SvPAD_STATE_on(sv)	(SvFLAGS(sv) |= SVpad_NAME|SVpad_STATE)
#endif

#define SvOURSTASH(sv)	\
	(SvPAD_OUR(sv) ? ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash : NULL)
#define SvOURSTASH_set(sv, st)					\
        STMT_START {						\
	    assert(SvTYPE(sv) == SVt_PVMG);			\
	    ((XPVMG*) SvANY(sv))->xmg_u.xmg_ourstash = st;	\
	} STMT_END

#ifdef PERL_DEBUG_COW
#else
#endif
#define SvRVx(sv) SvRV(sv)

#ifdef PERL_DEBUG_COW
/* Need -0.0 for SvNVX to preserve IEEE FP "negative zero" because
   +0.0 + -0.0 => +0.0 but -0.0 + -0.0 => -0.0 */
#  define SvIVX(sv) (0 + ((XPVIV*) SvANY(sv))->xiv_iv)
#  define SvUVX(sv) (0 + ((XPVUV*) SvANY(sv))->xuv_uv)
#  define SvNVX(sv) (-0.0 + ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv)
#  define SvRV(sv) (0 + (sv)->sv_u.svu_rv)
/* Don't test the core XS code yet.  */
#  if defined (PERL_CORE) && PERL_DEBUG_COW > 1
#    define SvPVX(sv) (0 + (assert(!SvREADONLY(sv)), (sv)->sv_u.svu_pv))
#  else
#  define SvPVX(sv) SvPVX_mutable(sv)
#  endif
#  define SvCUR(sv) (0 + ((XPV*) SvANY(sv))->xpv_cur)
#  define SvLEN(sv) (0 + ((XPV*) SvANY(sv))->xpv_len)
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  ifdef DEBUGGING
#    define SvMAGIC(sv)	(0 + *(assert(SvTYPE(sv) >= SVt_PVMG), &((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic))
#    define SvSTASH(sv)	(0 + *(assert(SvTYPE(sv) >= SVt_PVMG), &((XPVMG*)  SvANY(sv))->xmg_stash))
#  else
#    define SvMAGIC(sv)	(0 + ((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic)
#    define SvSTASH(sv)	(0 + ((XPVMG*)  SvANY(sv))->xmg_stash)
#  endif
#else
#  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len
#  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur)

#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
/* These get expanded inside other macros that already use a variable _sv  */
#    define SvPVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &((_svi)->sv_u.svu_pv);					\
	 }))
#    define SvCUR(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPV*) SvANY(_svi))->xpv_cur);				\
	 }))
#    define SvIVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_IV || SvTYPE(_svi) >= SVt_PVIV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPVIV*) SvANY(_svi))->xiv_iv);				\
	 }))
#    define SvUVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_IV || SvTYPE(_svi) >= SVt_PVIV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(!isGV_with_GP(_svi));				\
	    &(((XPVUV*) SvANY(_svi))->xuv_uv);				\
	 }))
#    define SvNVX(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) == SVt_NV || SvTYPE(_svi) >= SVt_PVNV);	\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(SvTYPE(_svi) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svi));				\
	   &(((XPVNV*) SvANY(_svi))->xnv_u.xnv_nv);			\
	 }))
#    define SvRV(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_RV);				\
	    assert(SvTYPE(_svi) != SVt_PVAV);				\
	    assert(SvTYPE(_svi) != SVt_PVHV);				\
	    assert(SvTYPE(_svi) != SVt_PVCV);				\
	    assert(SvTYPE(_svi) != SVt_PVFM);				\
	    assert(!isGV_with_GP(_svi));				\
	    &((_svi)->sv_u.svu_rv);					\
	 }))
#    define SvMAGIC(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PVMG);				\
	    if(SvTYPE(_svi) == SVt_PVMG)				\
		assert(!SvPAD_OUR(_svi));				\
	    &(((XPVMG*) SvANY(_svi))->xmg_u.xmg_magic);			\
	  }))
#    define SvSTASH(sv)							\
	(*({ SV *const _svi = (SV *) (sv);				\
	    assert(SvTYPE(_svi) >= SVt_PVMG);				\
	    &(((XPVMG*) SvANY(_svi))->xmg_stash);			\
	  }))
#  else
#    define SvPVX(sv) ((sv)->sv_u.svu_pv)
#    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur
#    define SvIVX(sv) ((XPVIV*) SvANY(sv))->xiv_iv
#    define SvUVX(sv) ((XPVUV*) SvANY(sv))->xuv_uv
#    define SvNVX(sv) ((XPVNV*) SvANY(sv))->xnv_u.xnv_nv
#    define SvRV(sv) ((sv)->sv_u.svu_rv)
#    define SvMAGIC(sv)	((XPVMG*)  SvANY(sv))->xmg_u.xmg_magic
#    define SvSTASH(sv)	((XPVMG*)  SvANY(sv))->xmg_stash
#  endif
#endif

#ifndef PERL_POISON
/* Given that these two are new, there can't be any existing code using them
 *  as LVALUEs  */
#  define SvPVX_mutable(sv)	(0 + (sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)(0 + (sv)->sv_u.svu_pv))
#else
/* Except for the poison code, which uses & to scribble over the pointer after
   free() is called.  */
#  define SvPVX_mutable(sv)	((sv)->sv_u.svu_pv)
#  define SvPVX_const(sv)	((const char*)((sv)->sv_u.svu_pv))
#endif

#define SvIVXx(sv) SvIVX(sv)
#define SvUVXx(sv) SvUVX(sv)
#define SvNVXx(sv) SvNVX(sv)
#define SvPVXx(sv) SvPVX(sv)
#define SvLENx(sv) SvLEN(sv)
#define SvENDx(sv) ((PL_Sv = (sv)), SvEND(PL_Sv))


/* Ask a scalar nicely to try to become an IV, if possible.
   Not guaranteed to stay returning void */
/* Macro won't actually call sv_2iv if already IOK */
#define SvIV_please(sv) \
	STMT_START {if (!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv))) \
		(void) SvIV(sv); } STMT_END
#define SvIV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(!isGV_with_GP(sv));		\
		(((XPVIV*)  SvANY(sv))->xiv_iv = (val)); } STMT_END
#define SvNV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) == SVt_NV || SvTYPE(sv) >= SVt_PVNV); \
	    assert(SvTYPE(sv) != SVt_PVAV); assert(SvTYPE(sv) != SVt_PVHV); \
	    assert(SvTYPE(sv) != SVt_PVCV); assert(SvTYPE(sv) != SVt_PVFM); \
		assert(!isGV_with_GP(sv));		\
		(((XPVNV*)SvANY(sv))->xnv_u.xnv_nv = (val)); } STMT_END
#define SvPV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(!isGV_with_GP(sv));		\
		((sv)->sv_u.svu_pv = (val)); } STMT_END
#define SvUV_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv) >= SVt_PVIV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(!isGV_with_GP(sv));		\
		(((XPVUV*)SvANY(sv))->xuv_uv = (val)); } STMT_END
#define SvRV_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >=  SVt_RV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(SvTYPE(sv) != SVt_PVCV);		\
		assert(SvTYPE(sv) != SVt_PVFM);		\
		assert(!isGV_with_GP(sv));		\
                ((sv)->sv_u.svu_rv = (val)); } STMT_END
#define SvMAGIC_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)SvANY(sv))->xmg_u.xmg_magic = (val)); } STMT_END
#define SvSTASH_set(sv, val) \
        STMT_START { assert(SvTYPE(sv) >= SVt_PVMG); \
                (((XPVMG*)  SvANY(sv))->xmg_stash = (val)); } STMT_END
#define SvCUR_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);		\
		assert(SvTYPE(sv) != SVt_PVHV);		\
		assert(!isGV_with_GP(sv));		\
		(((XPV*)  SvANY(sv))->xpv_cur = (val)); } STMT_END
#define SvLEN_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		assert(SvTYPE(sv) != SVt_PVAV);	\
		assert(SvTYPE(sv) != SVt_PVHV);	\
		assert(!isGV_with_GP(sv));	\
		(((XPV*)  SvANY(sv))->xpv_len = (val)); } STMT_END
#define SvEND_set(sv, val) \
	STMT_START { assert(SvTYPE(sv) >= SVt_PV); \
		(SvCUR(sv) = (val) - SvPVX(sv)); } STMT_END

#define SvPV_renew(sv,n) \
	STMT_START { SvLEN_set(sv, n); \
		SvPV_set((sv), (MEM_WRAP_CHECK_(n,char)			\
				(char*)saferealloc((Malloc_t)SvPVX(sv), \
						   (MEM_SIZE)((n)))));  \
		 } STMT_END

#define SvPV_shrink_to_cur(sv) STMT_START { \
		   const STRLEN _lEnGtH = SvCUR(sv) + 1; \
		   SvPV_renew(sv, _lEnGtH); \
		 } STMT_END

#define SvPV_free(sv)							\
    STMT_START {							\
		     assert(SvTYPE(sv) >= SVt_PV);			\
		     if (SvLEN(sv)) {					\
			 if(SvOOK(sv)) {				\
			     SvPV_set(sv, SvPVX_mutable(sv) - SvIVX(sv)); \
			     SvFLAGS(sv) &= ~SVf_OOK;			\
			 }						\
			 Safefree(SvPVX(sv));				\
		     }							\
		 } STMT_END


#define PERL_FBM_TABLE_OFFSET 1	/* Number of bytes between EOS and table */

/* SvPOKp not SvPOK in the assertion because the string can be tainted! eg
   perl -T -e '/$^X/'
*/
#if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define BmFLAGS(sv)							\
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_flags);		\
	 }))
#  define BmRARE(sv)							\
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_rare);		\
	 }))
#  define BmUSEFUL(sv)							\
	(*({ SV *const uggh = (SV *) (sv);				\
	    assert(SvTYPE(uggh) == SVt_PVGV);				\
	    assert(SvVALID(uggh));					\
	    assert(!SvIOK(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xiv_u.xivu_i32);			\
	 }))
#  define BmPREVIOUS(sv)						\
	(*({ SV *const uggh = (SV *) (sv);				\
		assert(SvTYPE(uggh) == SVt_PVGV);			\
		assert(SvVALID(uggh));					\
	    &(((XPVGV*) SvANY(uggh))->xnv_u.xbm_s.xbm_previous);	\
	 }))
#else
#  define BmFLAGS(sv)		((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_flags
#  define BmRARE(sv)		((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_rare
#  define BmUSEFUL(sv)		((XPVGV*) SvANY(sv))->xiv_u.xivu_i32
#  define BmPREVIOUS(sv)	((XPVGV*) SvANY(sv))->xnv_u.xbm_s.xbm_previous

#endif

#define FmLINES(sv)	((XPVFM*)  SvANY(sv))->xfm_lines

#define LvTYPE(sv)	((XPVLV*)  SvANY(sv))->xlv_type
#define LvTARG(sv)	((XPVLV*)  SvANY(sv))->xlv_targ
#define LvTARGOFF(sv)	((XPVLV*)  SvANY(sv))->xlv_targoff
#define LvTARGLEN(sv)	((XPVLV*)  SvANY(sv))->xlv_targlen

#define IoIFP(sv)	((XPVIO*)  SvANY(sv))->xio_ifp
#define IoOFP(sv)	((XPVIO*)  SvANY(sv))->xio_ofp
#define IoDIRP(sv)	((XPVIO*)  SvANY(sv))->xio_dirp
#define IoANY(sv)	((XPVIO*)  SvANY(sv))->xio_any
#define IoLINES(sv)	((XPVIO*)  SvANY(sv))->xio_lines
#define IoPAGE(sv)	((XPVIO*)  SvANY(sv))->xio_page
#define IoPAGE_LEN(sv)	((XPVIO*)  SvANY(sv))->xio_page_len
#define IoLINES_LEFT(sv)((XPVIO*)  SvANY(sv))->xio_lines_left
#define IoTOP_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_top_name
#define IoTOP_GV(sv)	((XPVIO*)  SvANY(sv))->xio_top_gv
#define IoFMT_NAME(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_name
#define IoFMT_GV(sv)	((XPVIO*)  SvANY(sv))->xio_fmt_gv
#define IoBOTTOM_NAME(sv)((XPVIO*) SvANY(sv))->xio_bottom_name
#define IoBOTTOM_GV(sv)	((XPVIO*)  SvANY(sv))->xio_bottom_gv
#define IoTYPE(sv)	((XPVIO*)  SvANY(sv))->xio_type
#define IoFLAGS(sv)	((XPVIO*)  SvANY(sv))->xio_flags

/* IoTYPE(sv) is a single character telling the type of I/O connection. */
#define IoTYPE_RDONLY		'<'
#define IoTYPE_WRONLY		'>'
#define IoTYPE_RDWR		'+'
#define IoTYPE_APPEND 		'a'
#define IoTYPE_PIPE		'|'
#define IoTYPE_STD		'-'	/* stdin or stdout */
#define IoTYPE_SOCKET		's'
#define IoTYPE_CLOSED		' '
#define IoTYPE_IMPLICIT		'I'	/* stdin or stdout or stderr */
#define IoTYPE_NUMERIC		'#'	/* fdopen */

/*
=for apidoc Am|bool|SvTAINTED|SV* sv
Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if
not.

=for apidoc Am|void|SvTAINTED_on|SV* sv
Marks an SV as tainted if tainting is enabled.

=for apidoc Am|void|SvTAINTED_off|SV* sv
Untaints an SV. Be I<very> careful with this routine, as it short-circuits
some of Perl's fundamental security features. XS module authors should not
use this function unless they fully understand all the implications of
unconditionally untainting the value. Untainting should be done in the
standard perl fashion, via a carefully crafted regexp, rather than directly
untainting variables.

=for apidoc Am|void|SvTAINT|SV* sv
Taints an SV if tainting is enabled.

=cut
*/

#define sv_taint(sv)	  sv_magic((sv), NULL, PERL_MAGIC_taint, NULL, 0)

#define SvTAINTED(sv)	  (SvMAGICAL(sv) && sv_tainted(sv))
#define SvTAINTED_on(sv)  STMT_START{ if(PL_tainting){sv_taint(sv);}   }STMT_END
#define SvTAINTED_off(sv) STMT_START{ if(PL_tainting){sv_untaint(sv);} }STMT_END

#define SvTAINT(sv)			\
    STMT_START {			\
	if (PL_tainting) {		\
	    if (PL_tainted)		\
		SvTAINTED_on(sv);	\
	}				\
    } STMT_END

/*
=for apidoc Am|char*|SvPV_force|SV* sv|STRLEN len
Like C<SvPV> but will force the SV into containing just a string
(C<SvPOK_only>).  You want force if you are going to update the C<SvPVX>
directly.

=for apidoc Am|char*|SvPV_force_nomg|SV* sv|STRLEN len
Like C<SvPV> but will force the SV into containing just a string
(C<SvPOK_only>).  You want force if you are going to update the C<SvPVX>
directly. Doesn't process magic.

=for apidoc Am|char*|SvPV|SV* sv|STRLEN len
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified version becoming C<SvPOK>.  Handles 'get' magic. See also
C<SvPVx> for a version which guarantees to evaluate sv only once.

=for apidoc Am|char*|SvPVx|SV* sv|STRLEN len
A version of C<SvPV> which guarantees to evaluate C<sv> only once.
Only use this if C<sv> is an expression with side effects, otherwise use the
more efficient C<SvPVX>.

=for apidoc Am|char*|SvPV_nomg|SV* sv|STRLEN len
Like C<SvPV> but doesn't process magic.

=for apidoc Am|char*|SvPV_nolen|SV* sv
Returns a pointer to the string in the SV, or a stringified form of
the SV if the SV does not contain a string.  The SV may cache the
stringified form becoming C<SvPOK>.  Handles 'get' magic.

=for apidoc Am|IV|SvIV|SV* sv
Coerces the given SV to an integer and returns it. See C<SvIVx> for a
version which guarantees to evaluate sv only once.

=for apidoc Am|IV|SvIV_nomg|SV* sv
Like C<SvIV> but doesn't process magic.

=for apidoc Am|IV|SvIVx|SV* sv
Coerces the given SV to an integer and returns it. Guarantees to evaluate
C<sv> only once. Only use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvIV>.

=for apidoc Am|NV|SvNV|SV* sv
Coerce the given SV to a double and return it. See C<SvNVx> for a version
which guarantees to evaluate sv only once.

=for apidoc Am|NV|SvNVx|SV* sv
Coerces the given SV to a double and returns it. Guarantees to evaluate
C<sv> only once. Only use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvNV>.

=for apidoc Am|UV|SvUV|SV* sv
Coerces the given SV to an unsigned integer and returns it.  See C<SvUVx>
for a version which guarantees to evaluate sv only once.

=for apidoc Am|UV|SvUV_nomg|SV* sv
Like C<SvUV> but doesn't process magic.

=for apidoc Am|UV|SvUVx|SV* sv
Coerces the given SV to an unsigned integer and returns it. Guarantees to
C<sv> only once. Only use this if C<sv> is an expression with side effects,
otherwise use the more efficient C<SvUV>.

=for apidoc Am|bool|SvTRUE|SV* sv
Returns a boolean indicating whether Perl would evaluate the SV as true or
false, defined or undefined.  Does not handle 'get' magic.

=for apidoc Am|char*|SvPVutf8_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVutf8|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVutf8_nolen|SV* sv
Like C<SvPV_nolen>, but converts sv to utf8 first if necessary.

=for apidoc Am|char*|SvPVbyte_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVbyte_nolen|SV* sv
Like C<SvPV_nolen>, but converts sv to byte representation first if necessary.

=for apidoc Am|char*|SvPVutf8x_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8_force>
otherwise.

=for apidoc Am|char*|SvPVutf8x|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to utf8 first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVutf8>
otherwise.

=for apidoc Am|char*|SvPVbytex_force|SV* sv|STRLEN len
Like C<SvPV_force>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte_force>
otherwise.

=for apidoc Am|char*|SvPVbytex|SV* sv|STRLEN len
Like C<SvPV>, but converts sv to byte representation first if necessary.
Guarantees to evaluate sv only once; use the more efficient C<SvPVbyte>
otherwise.

=for apidoc Am|bool|SvIsCOW|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write. (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
COW)

=for apidoc Am|bool|SvIsCOW_shared_hash|SV* sv
Returns a boolean indicating whether the SV is Copy-On-Write shared hash key
scalar.

=for apidoc Am|void|sv_catpvn_nomg|SV* sv|const char* ptr|STRLEN len
Like C<sv_catpvn> but doesn't process magic.

=for apidoc Am|void|sv_setsv_nomg|SV* dsv|SV* ssv
Like C<sv_setsv> but doesn't process magic.

=for apidoc Am|void|sv_catsv_nomg|SV* dsv|SV* ssv
Like C<sv_catsv> but doesn't process magic.

=cut
*/

/* Let us hope that bitmaps for UV and IV are the same */
#define SvIV(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv))
#define SvUV(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
#define SvNV(sv) (SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv))

#define SvIV_nomg(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv_flags(sv, 0))
#define SvUV_nomg(sv) (SvIOK(sv) ? SvUVX(sv) : sv_2uv_flags(sv, 0))

/* ----*/

#define SvPV(sv, lp) SvPV_flags(sv, lp, SV_GMAGIC)
#define SvPV_const(sv, lp) SvPV_flags_const(sv, lp, SV_GMAGIC)
#define SvPV_mutable(sv, lp) SvPV_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_flags(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv, &lp, flags))
#define SvPV_flags_const(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \
     (const char*) sv_2pv_flags(sv, &lp, flags|SV_CONST_RETURN))
#define SvPV_flags_const_nolen(sv, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX_const(sv) : \
     (const char*) sv_2pv_flags(sv, 0, flags|SV_CONST_RETURN))
#define SvPV_flags_mutable(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \
     sv_2pv_flags(sv, &lp, flags|SV_MUTABLE_RETURN))

#define SvPV_force(sv, lp) SvPV_force_flags(sv, lp, SV_GMAGIC)
#define SvPV_force_nolen(sv) SvPV_force_flags_nolen(sv, SV_GMAGIC)
#define SvPV_force_mutable(sv, lp) SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)

#define SvPV_force_nomg(sv, lp) SvPV_force_flags(sv, lp, 0)
#define SvPV_force_nomg_nolen(sv) SvPV_force_flags_nolen(sv, 0)

#define SvPV_force_flags(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv, &lp, flags))
#define SvPV_force_flags_nolen(sv, flags) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? SvPVX(sv) : sv_pvn_force_flags(sv, 0, flags))
#define SvPV_force_flags_mutable(sv, lp, flags) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == SVf_POK \
    ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \
     : sv_pvn_force_flags(sv, &lp, flags|SV_MUTABLE_RETURN))

#define SvPV_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC))

#define SvPV_nolen_const(sv) \
    ((SvFLAGS(sv) & (SVf_POK)) == SVf_POK \
     ? SvPVX_const(sv) : sv_2pv_flags(sv, 0, SV_GMAGIC|SV_CONST_RETURN))

#define SvPV_nomg(sv, lp) SvPV_flags(sv, lp, 0)
#define SvPV_nomg_const(sv, lp) SvPV_flags_const(sv, lp, 0)
#define SvPV_nomg_const_nolen(sv) SvPV_flags_const_nolen(sv, 0)

/* ----*/

#define SvPVutf8(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvutf8(sv, &lp))

#define SvPVutf8_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_THINKFIRST)) == (SVf_POK|SVf_UTF8) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvutf8n_force(sv, &lp))


#define SvPVutf8_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK|SVf_UTF8)\
     ? SvPVX(sv) : sv_2pvutf8(sv, 0))

/* ----*/

#define SvPVbyte(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv, &lp))

#define SvPVbyte_force(sv, lp) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8|SVf_THINKFIRST)) == (SVf_POK) \
     ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvbyten_force(sv, &lp))

#define SvPVbyte_nolen(sv) \
    ((SvFLAGS(sv) & (SVf_POK|SVf_UTF8)) == (SVf_POK)\
     ? SvPVX(sv) : sv_2pvbyte(sv, 0))


    
/* define FOOx(): idempotent versions of FOO(). If possible, use a local
 * var to evaluate the arg once; failing that, use a global if possible;
 * failing that, call a function to do the work
 */

#define SvPVx_force(sv, lp) sv_pvn_force(sv, &lp)
#define SvPVutf8x_force(sv, lp) sv_pvutf8n_force(sv, &lp)
#define SvPVbytex_force(sv, lp) sv_pvbyten_force(sv, &lp)

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)

#  define SvIVx(sv) ({SV *_sv = (SV*)(sv); SvIV(_sv); })
#  define SvUVx(sv) ({SV *_sv = (SV*)(sv); SvUV(_sv); })
#  define SvNVx(sv) ({SV *_sv = (SV*)(sv); SvNV(_sv); })
#  define SvPVx(sv, lp) ({SV *_sv = (sv); SvPV(_sv, lp); })
#  define SvPVx_const(sv, lp) ({SV *_sv = (sv); SvPV_const(_sv, lp); })
#  define SvPVx_nolen(sv) ({SV *_sv = (sv); SvPV_nolen(_sv); })
#  define SvPVx_nolen_const(sv) ({SV *_sv = (sv); SvPV_nolen_const(_sv); })
#  define SvPVutf8x(sv, lp) ({SV *_sv = (sv); SvPVutf8(_sv, lp); })
#  define SvPVbytex(sv, lp) ({SV *_sv = (sv); SvPVbyte(_sv, lp); })
#  define SvPVbytex_nolen(sv) ({SV *_sv = (sv); SvPVbyte_nolen(_sv); })
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   (({XPV *nxpv = (XPV*)SvANY(sv);			\
	     nxpv &&						\
	     (nxpv->xpv_cur > 1 ||				\
	      (nxpv->xpv_cur && *(sv)->sv_u.svu_pv != '0')); })	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUEx(sv) ({SV *_sv = (sv); SvTRUE(_sv); })

#else /* __GNUC__ */

/* These inlined macros use globals, which will require a thread
 * declaration in user code, so we avoid them under threads */

#  define SvIVx(sv) ((PL_Sv = (sv)), SvIV(PL_Sv))
#  define SvUVx(sv) ((PL_Sv = (sv)), SvUV(PL_Sv))
#  define SvNVx(sv) ((PL_Sv = (sv)), SvNV(PL_Sv))
#  define SvPVx(sv, lp) ((PL_Sv = (sv)), SvPV(PL_Sv, lp))
#  define SvPVx_const(sv, lp) ((PL_Sv = (sv)), SvPV_const(PL_Sv, lp))
#  define SvPVx_nolen(sv) ((PL_Sv = (sv)), SvPV_nolen(PL_Sv))
#  define SvPVx_nolen_const(sv) ((PL_Sv = (sv)), SvPV_nolen_const(PL_Sv))
#  define SvPVutf8x(sv, lp) ((PL_Sv = (sv)), SvPVutf8(PL_Sv, lp))
#  define SvPVbytex(sv, lp) ((PL_Sv = (sv)), SvPVbyte(PL_Sv, lp))
#  define SvPVbytex_nolen(sv) ((PL_Sv = (sv)), SvPVbyte_nolen(PL_Sv))
#  define SvTRUE(sv) (						\
    !sv								\
    ? 0								\
    :    SvPOK(sv)						\
	?   ((PL_Xpv = (XPV*)SvANY(PL_Sv = (sv))) &&		\
	     (PL_Xpv->xpv_cur > 1 ||				\
	      (PL_Xpv->xpv_cur && *PL_Sv->sv_u.svu_pv != '0'))	\
	     ? 1						\
	     : 0)						\
	:							\
	    SvIOK(sv)						\
	    ? SvIVX(sv) != 0					\
	    :   SvNOK(sv)					\
		? SvNVX(sv) != 0.0				\
		: sv_2bool(sv) )
#  define SvTRUEx(sv) ((PL_Sv = (sv)), SvTRUE(PL_Sv))
#endif /* __GNU__ */

#define SvIsCOW(sv)		((SvFLAGS(sv) & (SVf_FAKE | SVf_READONLY)) == \
				    (SVf_FAKE | SVf_READONLY))
#define SvIsCOW_shared_hash(sv)	(SvIsCOW(sv) && SvLEN(sv) == 0)

#define SvSHARED_HEK_FROM_PV(pvx) \
	((struct hek*)(pvx - STRUCT_OFFSET(struct hek, hek_key)))
#define SvSHARED_HASH(sv) (0 + SvSHARED_HEK_FROM_PV(SvPVX_const(sv))->hek_hash)

/* flag values for sv_*_flags functions */
#define SV_IMMEDIATE_UNREF	1
#define SV_GMAGIC		2
#define SV_COW_DROP_PV		4
#define SV_UTF8_NO_ENCODING	8
#define SV_NOSTEAL		16
#define SV_CONST_RETURN		32
#define SV_MUTABLE_RETURN	64
#define SV_SMAGIC		128
#define SV_HAS_TRAILING_NUL	256
#define SV_COW_SHARED_HASH_KEYS	512
/* This one is only enabled for PERL_OLD_COPY_ON_WRITE */
#define SV_COW_OTHER_PVS	1024

/* The core is safe for this COW optimisation. XS code on CPAN may not be.
   So only default to doing the COW setup if we're in the core.
 */
#ifdef PERL_CORE
#  ifndef SV_DO_COW_SVSETSV
#    define SV_DO_COW_SVSETSV	SV_COW_SHARED_HASH_KEYS|SV_COW_OTHER_PVS
#  endif
#endif

#ifndef SV_DO_COW_SVSETSV
#  define SV_DO_COW_SVSETSV	0
#endif


#define sv_unref(sv)    	sv_unref_flags(sv, 0)
#define sv_force_normal(sv)	sv_force_normal_flags(sv, 0)
#define sv_usepvn(sv, p, l)	sv_usepvn_flags(sv, p, l, 0)
#define sv_usepvn_mg(sv, p, l)	sv_usepvn_flags(sv, p, l, SV_SMAGIC)

/* We are about to replace the SV's current value. So if it's copy on write
   we need to normalise it. Use the SV_COW_DROP_PV flag hint to say that
   the value is about to get thrown away, so drop the PV rather than go to
   the effort of making a read-write copy only for it to get immediately
   discarded.  */

#define SV_CHECK_THINKFIRST_COW_DROP(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, SV_COW_DROP_PV)

#ifdef PERL_OLD_COPY_ON_WRITE
#define SvRELEASE_IVX(sv)   \
    ((SvIsCOW(sv) ? sv_force_normal_flags(sv, 0) : (void) 0), SvOOK_off(sv))
#  define SvIsCOW_normal(sv)	(SvIsCOW(sv) && SvLEN(sv))
#else
#  define SvRELEASE_IVX(sv)   SvOOK_off(sv)
#endif /* PERL_OLD_COPY_ON_WRITE */

#define CAN_COW_MASK	(SVs_OBJECT|SVs_GMG|SVs_SMG|SVs_RMG|SVf_IOK|SVf_NOK| \
			 SVf_POK|SVf_ROK|SVp_IOK|SVp_NOK|SVp_POK|SVf_FAKE| \
			 SVf_OOK|SVf_BREAK|SVf_READONLY)
#define CAN_COW_FLAGS	(SVp_POK|SVf_POK)

#define SV_CHECK_THINKFIRST(sv) if (SvTHINKFIRST(sv)) \
				    sv_force_normal_flags(sv, 0)


/* all these 'functions' are now just macros */

#define sv_pv(sv) SvPV_nolen(sv)
#define sv_pvutf8(sv) SvPVutf8_nolen(sv)
#define sv_pvbyte(sv) SvPVbyte_nolen(sv)

#define sv_pvn_force_nomg(sv, lp) sv_pvn_force_flags(sv, lp, 0)
#define sv_utf8_upgrade_nomg(sv) sv_utf8_upgrade_flags(sv, 0)
#define sv_catpvn_nomg(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, 0)
#define sv_setsv(dsv, ssv) \
	sv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)
#define sv_setsv_nomg(dsv, ssv) sv_setsv_flags(dsv, ssv, SV_DO_COW_SVSETSV)
#define sv_catsv(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC)
#define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0)
#define sv_catsv_mg(dsv, ssv) sv_catsv_flags(dsv, ssv, SV_GMAGIC|SV_SMAGIC)
#define sv_catpvn(dsv, sstr, slen) sv_catpvn_flags(dsv, sstr, slen, SV_GMAGIC)
#define sv_catpvn_mg(sv, sstr, slen) \
	sv_catpvn_flags(sv, sstr, slen, SV_GMAGIC|SV_SMAGIC);
#define sv_2pv(sv, lp) sv_2pv_flags(sv, lp, SV_GMAGIC)
#define sv_2pv_nolen(sv) sv_2pv(sv, 0)
#define sv_2pvbyte_nolen(sv) sv_2pvbyte(sv, 0)
#define sv_2pvutf8_nolen(sv) sv_2pvutf8(sv, 0)
#define sv_2pv_nomg(sv, lp) sv_2pv_flags(sv, lp, 0)
#define sv_pvn_force(sv, lp) sv_pvn_force_flags(sv, lp, SV_GMAGIC)
#define sv_utf8_upgrade(sv) sv_utf8_upgrade_flags(sv, SV_GMAGIC)
#define sv_2iv(sv) sv_2iv_flags(sv, SV_GMAGIC)
#define sv_2uv(sv) sv_2uv_flags(sv, SV_GMAGIC)

/* Should be named SvCatPVN_utf8_upgrade? */
#define sv_catpvn_utf8_upgrade(dsv, sstr, slen, nsv)	\
	STMT_START {					\
	    if (!(nsv))					\
		nsv = sv_2mortal(newSVpvn(sstr, slen));	\
	    else					\
		sv_setpvn(nsv, sstr, slen);		\
	    SvUTF8_off(nsv);				\
	    sv_utf8_upgrade(nsv);			\
	    sv_catsv(dsv, nsv);	\
	} STMT_END

/*
=for apidoc Am|SV*|newRV_inc|SV* sv

Creates an RV wrapper for an SV.  The reference count for the original SV is
incremented.

=cut
*/

#define newRV_inc(sv)	newRV(sv)

/* the following macros update any magic values this sv is associated with */

/*
=head1 Magical Functions

=for apidoc Am|void|SvGETMAGIC|SV* sv
Invokes C<mg_get> on an SV if it has 'get' magic.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSETMAGIC|SV* sv
Invokes C<mg_set> on an SV if it has 'set' magic.  This macro evaluates its
argument more than once.

=for apidoc Am|void|SvSetSV|SV* dsb|SV* ssv
Calls C<sv_setsv> if dsv is not the same as ssv.  May evaluate arguments
more than once.

=for apidoc Am|void|SvSetSV_nosteal|SV* dsv|SV* ssv
Calls a non-destructive version of C<sv_setsv> if dsv is not the same as
ssv. May evaluate arguments more than once.

=for apidoc Am|void|SvSetMagicSV|SV* dsb|SV* ssv
Like C<SvSetSV>, but does any set magic required afterwards.

=for apidoc Am|void|SvSetMagicSV_nosteal|SV* dsv|SV* ssv
Like C<SvSetSV_nosteal>, but does any set magic required afterwards.

=for apidoc Am|void|SvSHARE|SV* sv
Arranges for sv to be shared between threads if a suitable module
has been loaded.

=for apidoc Am|void|SvLOCK|SV* sv
Arranges for a mutual exclusion lock to be obtained on sv if a suitable module
has been loaded.

=for apidoc Am|void|SvUNLOCK|SV* sv
Releases a mutual exclusion lock on sv if a suitable module
has been loaded.

=head1 SV Manipulation Functions

=for apidoc Am|char *|SvGROW|SV* sv|STRLEN len
Expands the character buffer in the SV so that it has room for the
indicated number of bytes (remember to reserve space for an extra trailing
NUL character).  Calls C<sv_grow> to perform the expansion if necessary.
Returns a pointer to the character buffer.

=cut
*/

#define SvSHARE(sv) CALL_FPTR(PL_sharehook)(aTHX_ sv)
#define SvLOCK(sv) CALL_FPTR(PL_lockhook)(aTHX_ sv)
#define SvUNLOCK(sv) CALL_FPTR(PL_unlockhook)(aTHX_ sv)
#define SvDESTROYABLE(sv) CALL_FPTR(PL_destroyhook)(aTHX_ sv)

#define SvGETMAGIC(x) STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
#define SvSETMAGIC(x) STMT_START { if (SvSMAGICAL(x)) mg_set(x); } STMT_END

#define SvSetSV_and(dst,src,finally) \
	STMT_START {					\
	    if ((dst) != (src)) {			\
		sv_setsv(dst, src);			\
		finally;				\
	    }						\
	} STMT_END
#define SvSetSV_nosteal_and(dst,src,finally) \
	STMT_START {					\
	    if ((dst) != (src)) {			\
		sv_setsv_flags(dst, src, SV_GMAGIC | SV_NOSTEAL | SV_DO_COW_SVSETSV);	\
		finally;				\
	    }						\
	} STMT_END

#define SvSetSV(dst,src) \
		SvSetSV_and(dst,src,/*nothing*/;)
#define SvSetSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,/*nothing*/;)

#define SvSetMagicSV(dst,src) \
		SvSetSV_and(dst,src,SvSETMAGIC(dst))
#define SvSetMagicSV_nosteal(dst,src) \
		SvSetSV_nosteal_and(dst,src,SvSETMAGIC(dst))


#if !defined(SKIP_DEBUGGING)
#define SvPEEK(sv) sv_peek(sv)
#else
#define SvPEEK(sv) ""
#endif

#define SvIMMORTAL(sv) ((sv)==&PL_sv_undef || (sv)==&PL_sv_yes || (sv)==&PL_sv_no || (sv)==&PL_sv_placeholder)

#define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)

#define isGV(sv) (SvTYPE(sv) == SVt_PVGV)
/* If I give every macro argument a different name, then there won't be bugs
   where nested macros get confused. Been there, done that.  */
#define isGV_with_GP(pwadak) \
	(((SvFLAGS(pwadak) & (SVp_POK|SVpgv_GP)) == SVpgv_GP)	\
	&& (SvTYPE(pwadak) == SVt_PVGV || SvTYPE(pwadak) == SVt_PVLV))
#define isGV_with_GP_on(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) |= SVpgv_GP);				       \
    } STMT_END
#define isGV_with_GP_off(sv)	STMT_START {			       \
	assert (SvTYPE(sv) == SVt_PVGV || SvTYPE(sv) == SVt_PVLV); \
	assert (!SvPOKp(sv));					       \
	assert (!SvIOKp(sv));					       \
	(SvFLAGS(sv) &= ~SVpgv_GP);				       \
    } STMT_END


#define SvGROW(sv,len) (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX(sv))
#define SvGROW_mutable(sv,len) \
    (SvLEN(sv) < (len) ? sv_grow(sv,len) : SvPVX_mutable(sv))
#define Sv_Grow sv_grow

#define CLONEf_COPY_STACKS 1
#define CLONEf_KEEP_PTR_TABLE 2
#define CLONEf_CLONE_HOST 4
#define CLONEf_JOIN_IN 8

struct clone_params {
  AV* stashes;
  UV  flags;
  PerlInterpreter *proto_perl;
};

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\regexp.h ===
/*    regexp.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1999, 2000, 2001, 2003,
 *    2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 */
#ifndef PLUGGABLE_RE_EXTENSION
/* we don't want to include this stuff if we are inside of
   an external regex engine based on the core one - like re 'debug'*/

struct regnode {
    U8	flags;
    U8  type;
    U16 next_off;
};

typedef struct regnode regnode;

struct reg_substr_data;

struct reg_data;

struct regexp_engine;
struct regexp;

struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;		/* non-utf8 variant */
    SV *utf8_substr;	/* utf8 variant */
    I32 end_shift;
};
struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};

#ifdef PERL_OLD_COPY_ON_WRITE
#define SV_SAVED_COPY   SV *saved_copy; /* If non-NULL, SV which is COW from original */
#else
#define SV_SAVED_COPY
#endif

typedef struct regexp_paren_pair {
    I32 start;
    I32 end;
} regexp_paren_pair;

/*
  The regexp/REGEXP struct, see L<perlreapi> for further documentation
  on the individual fields. The struct is ordered so that the most
  commonly used fields are placed at the start.

  Any patch that adds items to this struct will need to include
  changes to F<sv.c> (C<Perl_re_dup()>) and F<regcomp.c>
  (C<pregfree()>). This involves freeing or cloning items in the
  regexp's data array based on the data item's type.
*/

typedef struct regexp {
        /* what engine created this regexp? */
	const struct regexp_engine* engine; 
	struct regexp* mother_re; /* what re is this a lightweight copy of? */
	
	/* Information about the match that the perl core uses to manage things */
	U32 extflags;           /* Flags used both externally and internally */
	I32 minlen;		/* mininum possible length of string to match */
	I32 minlenret;		/* mininum possible length of $& */
	U32 gofs;               /* chars left of pos that we search from */
	struct reg_substr_data *substrs; /* substring data about strings that must appear
                                   in the final match, used for optimisations */
	U32 nparens;		/* number of capture buffers */

        /* private engine specific data */
	U32 intflags;		/* Engine Specific Internal flags */
	void *pprivate;         /* Data private to the regex engine which 
                                   created this object. */
        
        /* Data about the last/current match. These are modified during matching*/
        U32 lastparen;		/* last open paren matched */
	U32 lastcloseparen;	/* last close paren matched */
        regexp_paren_pair *swap;  /* Swap copy of *offs */ 
        regexp_paren_pair *offs;  /* Array of offsets for (@-) and (@+) */

	char *subbeg;		/* saved or original string 
				   so \digit works forever. */
	SV_SAVED_COPY           /* If non-NULL, SV which is COW from original */
	I32 sublen;		/* Length of string pointed by subbeg */
        
        
        /* Information about the match that isn't often used */
	I32 prelen;		/* length of precomp */
	const char *precomp;	/* pre-compilation regular expression */
	/* wrapped can't be const char*, as it is returned by sv_2pv_flags */
	char *wrapped;          /* wrapped version of the pattern */
	I32 wraplen;		/* length of wrapped */
	I32 seen_evals;         /* number of eval groups in the pattern - for security checks */ 
        HV *paren_names;	/* Optional hash of paren names */
        
        /* Refcount of this regexp */
	I32 refcnt;             /* Refcount of this regexp */
} regexp;

/* used for high speed searches */
typedef struct re_scream_pos_data_s
{
    char **scream_olds;		/* match pos */
    I32 *scream_pos;		/* Internal iterator of scream. */
} re_scream_pos_data;

/* regexp_engine structure. This is the dispatch table for regexes.
 * Any regex engine implementation must be able to build one of these.
 */
typedef struct regexp_engine {
    REGEXP* (*comp) (pTHX_ const SV * const pattern, const U32 flags);
    I32     (*exec) (pTHX_ REGEXP * const rx, char* stringarg, char* strend,
                     char* strbeg, I32 minend, SV* screamer,
                     void* data, U32 flags);
    char*   (*intuit) (pTHX_ REGEXP * const rx, SV *sv, char *strpos,
                       char *strend, const U32 flags,
                       re_scream_pos_data *data);
    SV*     (*checkstr) (pTHX_ REGEXP * const rx);
    void    (*free) (pTHX_ REGEXP * const rx);
    void    (*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32 paren,
                                    SV * const sv);
    void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,
                                   SV const * const value);
    I32     (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const SV * const sv,
                                    const I32 paren);
    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, const U32 flags);
    SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,
                                const U32 flags);
    SV*     (*qr_package)(pTHX_ REGEXP * const rx);
#ifdef USE_ITHREADS
    void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
#endif
} regexp_engine;

/*
  These are passed to the numbered capture variable callbacks as the
  paren name. >= 1 is reserved for actual numbered captures, i.e. $1,
  $2 etc.
*/
#define RX_BUFF_IDX_PREMATCH  -2 /* $` / ${^PREMATCH}  */
#define RX_BUFF_IDX_POSTMATCH -1 /* $' / ${^POSTMATCH} */
#define RX_BUFF_IDX_FULLMATCH      0 /* $& / ${^MATCH}     */

/*
  Flags that are passed to the named_buff and named_buff_iter
  callbacks above. Those routines are called from universal.c via the
  Tie::Hash::NamedCapture interface for %+ and %- and the re::
  functions in the same file.
*/

/* The Tie::Hash::NamedCapture operation this is part of, if any */
#define RXapif_FETCH     0x0001
#define RXapif_STORE     0x0002
#define RXapif_DELETE    0x0004
#define RXapif_CLEAR     0x0008
#define RXapif_EXISTS    0x0010
#define RXapif_SCALAR    0x0020
#define RXapif_FIRSTKEY  0x0040
#define RXapif_NEXTKEY   0x0080

/* Whether %+ or %- is being operated on */
#define RXapif_ONE       0x0100 /* %+ */
#define RXapif_ALL       0x0200 /* %- */

/* Whether this is being called from a re:: function */
#define RXapif_REGNAME         0x0400
#define RXapif_REGNAMES        0x0800
#define RXapif_REGNAMES_COUNT  0x1000 

/*
=head1 REGEXP Functions

=for apidoc Am|REGEXP *|SvRX|SV *sv

Convenience macro to get the REGEXP from a SV. This is approximately
equivalent to the following snippet:

    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv) &&
        (tmpsv = (SV*)SvRV(sv)) &&
        SvTYPE(tmpsv) == SVt_PVMG &&
        (tmpmg = mg_find(tmpsv, PERL_MAGIC_qr)))
    {
        return (REGEXP *)tmpmg->mg_obj;
    }

NULL will be returned if a REGEXP* is not found.

=for apidoc Am|bool|SvRXOK|SV* sv

Returns a boolean indicating whether the SV contains qr magic
(PERL_MAGIC_qr).

If you want to do something with the REGEXP* later use SvRX instead
and check for NULL.

=cut
*/

#define SvRX(sv)   (Perl_get_re_arg(aTHX_ sv))
#define SvRXOK(sv) (Perl_get_re_arg(aTHX_ sv) ? TRUE : FALSE)


/* Flags stored in regexp->extflags 
 * These are used by code external to the regexp engine
 *
 * Note that flags starting with RXf_PMf_ have exact equivalents
 * stored in op_pmflags and which are defined in op.h, they are defined
 * numerically here only for clarity.
 *
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes. 
 *
 */

/* Anchor and GPOS related stuff */
#define RXf_ANCH_BOL    	0x00000001
#define RXf_ANCH_MBOL   	0x00000002
#define RXf_ANCH_SBOL   	0x00000004
#define RXf_ANCH_GPOS   	0x00000008
#define RXf_GPOS_SEEN   	0x00000010
#define RXf_GPOS_FLOAT  	0x00000020
/* two bits here */
#define RXf_ANCH        	(RXf_ANCH_BOL|RXf_ANCH_MBOL|RXf_ANCH_GPOS|RXf_ANCH_SBOL)
#define RXf_GPOS_CHECK          (RXf_GPOS_SEEN|RXf_ANCH_GPOS)
#define RXf_ANCH_SINGLE         (RXf_ANCH_SBOL|RXf_ANCH_GPOS)

/* Flags indicating special patterns */
#define RXf_SKIPWHITE		0x00000100 /* Pattern is for a split / / */
#define RXf_START_ONLY		0x00000200 /* Pattern is /^/ */
#define RXf_WHITE		0x00000400 /* Pattern is /\s+/ */
#define RXf_NULL		0x40000000 /* Pattern is // */

/* 0x1F800 of extflags is used by (RXf_)PMf_COMPILETIME */
#define RXf_PMf_LOCALE  	0x00000800 /* use locale */
#define RXf_PMf_MULTILINE	0x00001000 /* /m         */
#define RXf_PMf_SINGLELINE	0x00002000 /* /s         */
#define RXf_PMf_FOLD    	0x00004000 /* /i         */
#define RXf_PMf_EXTENDED	0x00008000 /* /x         */
#define RXf_PMf_KEEPCOPY	0x00010000 /* /p         */
/* these flags are transfered from the PMOP->op_pmflags member during compilation */
#define RXf_PMf_STD_PMMOD	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED)
#define RXf_PMf_COMPILETIME	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_LOCALE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_KEEPCOPY)

#define CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl)                        \
    case IGNORE_PAT_MOD:    *(pmfl) |= RXf_PMf_FOLD;       break;   \
    case MULTILINE_PAT_MOD: *(pmfl) |= RXf_PMf_MULTILINE;  break;   \
    case SINGLE_PAT_MOD:    *(pmfl) |= RXf_PMf_SINGLELINE; break;   \
    case XTENDED_PAT_MOD:   *(pmfl) |= RXf_PMf_EXTENDED;   break

/* chars and strings used as regex pattern modifiers
 * Singlular is a 'c'har, plural is a "string"
 *
 * NOTE, KEEPCOPY was originally 'k', but was changed to 'p' for preserve
 * for compatibility reasons with Regexp::Common which highjacked (?k:...)
 * for its own uses. So 'k' is out as well.
 */
#define EXEC_PAT_MOD         'e'
#define KEEPCOPY_PAT_MOD     'p'
#define ONCE_PAT_MOD         'o'
#define GLOBAL_PAT_MOD       'g'
#define CONTINUE_PAT_MOD     'c'
#define MULTILINE_PAT_MOD    'm'
#define SINGLE_PAT_MOD       's'
#define IGNORE_PAT_MOD       'i'
#define XTENDED_PAT_MOD      'x'

#define ONCE_PAT_MODS        "o"
#define KEEPCOPY_PAT_MODS    "p"
#define EXEC_PAT_MODS        "e"
#define LOOP_PAT_MODS        "gc"

#define STD_PAT_MODS        "msix"

#define INT_PAT_MODS    STD_PAT_MODS    KEEPCOPY_PAT_MODS

#define EXT_PAT_MODS    ONCE_PAT_MODS   KEEPCOPY_PAT_MODS
#define QR_PAT_MODS     STD_PAT_MODS    EXT_PAT_MODS
#define M_PAT_MODS      QR_PAT_MODS     LOOP_PAT_MODS
#define S_PAT_MODS      M_PAT_MODS      EXEC_PAT_MODS

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes. 
 *
 */

/* What we have seen */
#define RXf_LOOKBEHIND_SEEN	0x00020000
#define RXf_EVAL_SEEN   	0x00040000
#define RXf_CANY_SEEN   	0x00080000

/* Special */
#define RXf_NOSCAN      	0x00100000
#define RXf_CHECK_ALL   	0x00200000

/* UTF8 related */
#define RXf_UTF8        	0x00400000
#define RXf_MATCH_UTF8  	0x00800000

/* Intuit related */
#define RXf_USE_INTUIT_NOML	0x01000000
#define RXf_USE_INTUIT_ML	0x02000000
#define RXf_INTUIT_TAIL 	0x04000000

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_SPLIT           0x08000000

#define RXf_USE_INTUIT		(RXf_USE_INTUIT_NOML|RXf_USE_INTUIT_ML)

/* Copy and tainted info */
#define RXf_COPY_DONE   	0x10000000
#define RXf_TAINTED_SEEN	0x20000000
#define RXf_TAINTED             0x80000000 /* this pattern is tainted */

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes. 
 *
 */

#define RX_HAS_CUTGROUP(prog) ((prog)->intflags & PREGf_CUTGROUP_SEEN)
#define RX_MATCH_TAINTED(prog)	((prog)->extflags & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) ((prog)->extflags |= RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) ((prog)->extflags &= ~RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_set(prog, t) ((t) \
				       ? RX_MATCH_TAINTED_on(prog) \
				       : RX_MATCH_TAINTED_off(prog))

#define RX_MATCH_COPIED(prog)		((prog)->extflags & RXf_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	((prog)->extflags |= RXf_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	((prog)->extflags &= ~RXf_COPY_DONE)
#define RX_MATCH_COPIED_set(prog,t)	((t) \
					 ? RX_MATCH_COPIED_on(prog) \
					 : RX_MATCH_COPIED_off(prog))

#endif /* PLUGGABLE_RE_EXTENSION */

/* Stuff that needs to be included in the plugable extension goes below here */

#ifdef PERL_OLD_COPY_ON_WRITE
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (rx->saved_copy) { \
	    SV_CHECK_THINKFIRST_COW_DROP(rx->saved_copy); \
	} \
	if (RX_MATCH_COPIED(rx)) { \
	    Safefree(rx->subbeg); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#else
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (RX_MATCH_COPIED(rx)) { \
	    Safefree(rx->subbeg); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#endif

#define RX_MATCH_UTF8(prog)		((prog)->extflags & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		((prog)->extflags |= RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		((prog)->extflags &= ~RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_set(prog, t)	((t) \
			? (RX_MATCH_UTF8_on(prog), (PL_reg_match_utf8 = 1)) \
			: (RX_MATCH_UTF8_off(prog), (PL_reg_match_utf8 = 0)))
    
#define REXEC_COPY_STR	0x01		/* Need to copy the string. */
#define REXEC_CHECKED	0x02		/* check_substr already checked. */
#define REXEC_SCREAM	0x04		/* use scream table. */
#define REXEC_IGNOREPOS	0x08		/* \G matches at start. */
#define REXEC_NOT_FIRST	0x10		/* This is another iteration of //g. */

#define ReREFCNT_inc(re) ((void)(re && re->refcnt++), re)
#define ReREFCNT_dec(re) CALLREGFREE(re)

#define FBMcf_TAIL_DOLLAR	1
#define FBMcf_TAIL_DOLLARM	2
#define FBMcf_TAIL_Z		4
#define FBMcf_TAIL_z		8
#define FBMcf_TAIL		(FBMcf_TAIL_DOLLAR|FBMcf_TAIL_DOLLARM|FBMcf_TAIL_Z|FBMcf_TAIL_z)

#define FBMrf_MULTILINE	1

/* an accepting state/position*/
struct _reg_trie_accepted {
    U8   *endpos;
    U16  wordnum;
};
typedef struct _reg_trie_accepted reg_trie_accepted;

/* some basic information about the current match that is created by
 * Perl_regexec_flags and then passed to regtry(), regmatch() etc */

typedef struct {
    regexp *prog;
    char *bol;
    char *till;
    SV *sv;
    char *ganch;
    char *cutpoint;
} regmatch_info;
 

/* structures for holding and saving the state maintained by regmatch() */

#ifndef MAX_RECURSE_EVAL_NOCHANGE_DEPTH
#define MAX_RECURSE_EVAL_NOCHANGE_DEPTH 1000
#endif

typedef I32 CHECKPOINT;

typedef struct regmatch_state {
    int resume_state;		/* where to jump to on return */
    char *locinput;		/* where to backtrack in string on failure */

    union {

	/* this is a fake union member that matches the first element
	 * of each member that needs to store positive backtrack
	 * information */
	struct {
	    struct regmatch_state *prev_yes_state;
	} yes;

        /* branchlike members */
        /* this is a fake union member that matches the first elements
         * of each member that needs to behave like a branch */
        struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    CHECKPOINT cp;
	    
        } branchlike;
        	    
	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    CHECKPOINT cp;
	    
	    regnode *next_branch; /* next branch node */
	} branch;

	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    CHECKPOINT cp;

	    reg_trie_accepted *accept_buff; /* accepting states we have seen */
	    U32		accepted; /* how many accepting states we have seen */
	    U16         *jump;  /* positive offsets from me */
	    regnode	*B;	/* node following the trie */
	    regnode	*me;	/* Which node am I - needed for jump tries*/
	} trie;

        /* special types - these members are used to store state for special
           regops like eval, if/then, lookaround and the markpoint state */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_eval;
	    struct regmatch_state *prev_curlyx;
	    regexp	*prev_rex;
	    U32		toggle_reg_flags; /* what bits in PL_reg_flags to
					    flip when transitioning between
					    inner and outer rexen */
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    U32        close_paren; /* which close bracket is our end */
	    regnode	*B;	/* the node following us  */
	} eval;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    I32 wanted;
	    I32 logical;	/* saved copy of 'logical' var */
	    regnode  *me; /* the IFMATCH/SUSPEND/UNLESSM node  */
	} ifmatch; /* and SUSPEND/UNLESSM */
	
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_mark;
	    SV* mark_name;
	    char *mark_loc;
	} mark;
	
	struct {
	    int val;
	} keeper;

        /* quantifiers - these members are used for storing state for
           for the regops used to implement quantifiers */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_curlyx; /* previous cur_curlyx */
	    regnode	*A, *B;	/* the nodes corresponding to /A*B/  */
	    CHECKPOINT	cp;	/* remember current savestack index */
	    bool	minmod;
	    int		parenfloor;/* how far back to strip paren data */
	    int		min;	/* the minimal number of A's to match */
	    int		max;	/* the maximal number of A's to match */

	    /* these two are modified by WHILEM */
	    int		count;	/* how many instances of A we've matched */
	    char	*lastloc;/* where previous A matched (0-len detect) */
	} curlyx;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *save_curlyx;
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    char	*save_lastloc;	/* previous curlyx.lastloc */
	    I32		cache_offset;
	    I32		cache_mask;
	} whilem;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    I32 c1, c2;		/* case fold search */
	    CHECKPOINT cp;
	    I32 alen;		/* length of first-matched A string */
	    I32 count;
	    bool minmod;
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
	    regnode *me;	/* the curlym node */
	} curlym;

	struct {
	    U32 paren;
	    CHECKPOINT cp;
	    I32 c1, c2;		/* case fold search */
	    char *maxpos;	/* highest possible point in string to match */
	    char *oldloc;	/* the previous locinput */
	    int count;
	    int min, max;	/* {m,n} */
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
	} curly; /* and CURLYN/PLUS/STAR */

    } u;
} regmatch_state;

/* how many regmatch_state structs to allocate as a single slab.
 * We do it in 4K blocks for efficiency. The "3" is 2 for the next/prev
 * pointers, plus 1 for any mythical malloc overhead. */
 
#define PERL_REGMATCH_SLAB_SLOTS \
    ((4096 - 3 * sizeof (void*)) / sizeof(regmatch_state))

typedef struct regmatch_slab {
    regmatch_state states[PERL_REGMATCH_SLAB_SLOTS];
    struct regmatch_slab *prev, *next;
} regmatch_slab;

#define PL_reg_flags		PL_reg_state.re_state_reg_flags
#define PL_bostr		PL_reg_state.re_state_bostr
#define PL_reginput		PL_reg_state.re_state_reginput
#define PL_regeol		PL_reg_state.re_state_regeol
#define PL_regoffs		PL_reg_state.re_state_regoffs
#define PL_reglastparen		PL_reg_state.re_state_reglastparen
#define PL_reglastcloseparen	PL_reg_state.re_state_reglastcloseparen
#define PL_reg_start_tmp	PL_reg_state.re_state_reg_start_tmp
#define PL_reg_start_tmpl	PL_reg_state.re_state_reg_start_tmpl
#define PL_reg_eval_set		PL_reg_state.re_state_reg_eval_set
#define PL_reg_match_utf8	PL_reg_state.re_state_reg_match_utf8
#define PL_reg_magic		PL_reg_state.re_state_reg_magic
#define PL_reg_oldpos		PL_reg_state.re_state_reg_oldpos
#define PL_reg_oldcurpm		PL_reg_state.re_state_reg_oldcurpm
#define PL_reg_curpm		PL_reg_state.re_state_reg_curpm
#define PL_reg_oldsaved		PL_reg_state.re_state_reg_oldsaved
#define PL_reg_oldsavedlen	PL_reg_state.re_state_reg_oldsavedlen
#define PL_reg_maxiter		PL_reg_state.re_state_reg_maxiter
#define PL_reg_leftiter		PL_reg_state.re_state_reg_leftiter
#define PL_reg_poscache		PL_reg_state.re_state_reg_poscache
#define PL_reg_poscache_size	PL_reg_state.re_state_reg_poscache_size
#define PL_regsize		PL_reg_state.re_state_regsize
#define PL_reg_starttry		PL_reg_state.re_state_reg_starttry
#define PL_nrs			PL_reg_state.re_state_nrs

struct re_save_state {
    U32 re_state_reg_flags;		/* from regexec.c */
    U32 re_state_reg_start_tmpl;	/* from regexec.c */
    I32 re_state_reg_eval_set;		/* from regexec.c */
    bool re_state_reg_match_utf8;	/* from regexec.c */
    char *re_state_bostr;
    char *re_state_reginput;		/* String-input pointer. */
    char *re_state_regeol;		/* End of input, for $ check. */
    regexp_paren_pair *re_state_regoffs;  /* Pointer to start/end pairs */
    U32 *re_state_reglastparen;		/* Similarly for lastparen. */
    U32 *re_state_reglastcloseparen;	/* Similarly for lastcloseparen. */
    char **re_state_reg_start_tmp;	/* from regexec.c */
    MAGIC *re_state_reg_magic;		/* from regexec.c */
    PMOP *re_state_reg_oldcurpm;	/* from regexec.c */
    PMOP *re_state_reg_curpm;		/* from regexec.c */
    char *re_state_reg_oldsaved;	/* old saved substr during match */
    STRLEN re_state_reg_oldsavedlen;	/* old length of saved substr during match */
    STRLEN re_state_reg_poscache_size;	/* size of pos cache of WHILEM */
    I32 re_state_reg_oldpos;		/* from regexec.c */
    I32 re_state_reg_maxiter;		/* max wait until caching pos */
    I32 re_state_reg_leftiter;		/* wait until caching pos */
    U32 re_state_regsize;		/* from regexec.c */
    char *re_state_reg_poscache;	/* cache of pos of WHILEM */
    char *re_state_reg_starttry;	/* from regexec.c */
#ifdef PERL_OLD_COPY_ON_WRITE
    SV *re_state_nrs;			/* was placeholder: unused since 5.8.0 (5.7.2 patch #12027 for bug ID 20010815.012). Used to save rx->saved_copy */
#endif
};

#define SAVESTACK_ALLOC_FOR_RE_SAVE_STATE \
	(1 + ((sizeof(struct re_save_state) - 1) / sizeof(*PL_savestack)))

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\utf8.h ===
/*    utf8.h
 *
 *    Copyright (C) 2000, 2001, 2002, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* Use UTF-8 as the default script encoding?
 * Turning this on will break scripts having non-UTF-8 binary
 * data (such as Latin-1) in string literals. */
#ifdef USE_UTF8_SCRIPTS
#    define USE_UTF8_IN_NAMES (!IN_BYTES)
#else
#    define USE_UTF8_IN_NAMES (PL_hints & HINT_UTF8)
#endif

/* Source backward compatibility. */
#define uvuni_to_utf8(d, uv)		uvuni_to_utf8_flags(d, uv, 0)
#define is_utf8_string_loc(s, len, ep)	is_utf8_string_loclen(s, len, ep, 0)

#ifdef EBCDIC
/* The equivalent of these macros but implementing UTF-EBCDIC
   are in the following header file:
 */

#include "utfebcdic.h"

#else
START_EXTERN_C

#ifdef DOINIT
EXTCONST unsigned char PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* ascii */
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus */
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* bogus */
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* scripts */
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,	 /* cjk etc. */
7,13, /* Perl extended (not UTF-8).  Up to 72bit allowed (64-bit + reserved). */
};
#else
EXTCONST unsigned char PL_utf8skip[];
#endif

END_EXTERN_C
#define UTF8SKIP(s) PL_utf8skip[*(const U8*)(s)]

/* Native character to iso-8859-1 */
#define NATIVE_TO_ASCII(ch)      (ch)
#define ASCII_TO_NATIVE(ch)      (ch)
/* Transform after encoding */
#define NATIVE_TO_UTF(ch)        (ch)
#define UTF_TO_NATIVE(ch)        (ch)
/* Transforms in wide UV chars */
#define UNI_TO_NATIVE(ch)        (ch)
#define NATIVE_TO_UNI(ch)        (ch)
/* Transforms in invariant space */
#define NATIVE_TO_NEED(enc,ch)   (ch)
#define ASCII_TO_NEED(enc,ch)    (ch)

/* As there are no translations avoid the function wrapper */
#define utf8n_to_uvchr utf8n_to_uvuni
#define uvchr_to_utf8  uvuni_to_utf8

/*

 The following table is from Unicode 3.2.

 Code Points		1st Byte  2nd Byte  3rd Byte  4th Byte

   U+0000..U+007F	00..7F
   U+0080..U+07FF	C2..DF    80..BF
   U+0800..U+0FFF	E0        A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       ******* ill-formed *******
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF	F0        90..BF    80..BF    80..BF
  U+40000..U+FFFFF	F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF	F4        80..8F    80..BF    80..BF

Note the A0..BF in U+0800..U+0FFF, the 80..9F in U+D000...U+D7FF,
the 90..BF in U+10000..U+3FFFF, and the 80...8F in U+100000..U+10FFFF.
The "gaps" are caused by legal UTF-8 avoiding non-shortest encodings:
it is technically possible to UTF-8-encode a single code point in different
ways, but that is explicitly forbidden, and the shortest possible encoding
should always be used (and that is what Perl does).

 */

/*
 Another way to look at it, as bits:

 Code Points                    1st Byte   2nd Byte  3rd Byte  4th Byte

                    0aaaaaaa     0aaaaaaa
            00000bbbbbaaaaaa     110bbbbb  10aaaaaa
            ccccbbbbbbaaaaaa     1110cccc  10bbbbbb  10aaaaaa
  00000dddccccccbbbbbbaaaaaa     11110ddd  10cccccc  10bbbbbb  10aaaaaa

As you can see, the continuation bytes all begin with C<10>, and the
leading bits of the start byte tell how many bytes the are in the
encoded character.

*/


#define UNI_IS_INVARIANT(c)		(((UV)c) <  0x80)
#define UTF8_IS_INVARIANT(c)		UNI_IS_INVARIANT(NATIVE_TO_UTF(c))
#define NATIVE_IS_INVARIANT(c)		UNI_IS_INVARIANT(NATIVE_TO_ASCII(c))
#define UTF8_IS_START(c)		(((U8)c) >= 0xc0 && (((U8)c) <= 0xfd))
#define UTF8_IS_CONTINUATION(c)		(((U8)c) >= 0x80 && (((U8)c) <= 0xbf))
#define UTF8_IS_CONTINUED(c) 		(((U8)c) &  0x80)
#define UTF8_IS_DOWNGRADEABLE_START(c)	(((U8)c & 0xfc) == 0xc0)

#define UTF_START_MARK(len) ((len >  7) ? 0xFF : (0xFE << (7-len)))
#define UTF_START_MASK(len) ((len >= 7) ? 0x00 : (0x1F >> (len-2)))

#define UTF_CONTINUATION_MARK		0x80
#define UTF_ACCUMULATION_SHIFT		6
#define UTF_CONTINUATION_MASK		((U8)0x3f)
#define UTF8_ACCUMULATE(old, new)	(((old) << UTF_ACCUMULATION_SHIFT) | (((U8)new) & UTF_CONTINUATION_MASK))

#define UTF8_EIGHT_BIT_HI(c)	((((U8)(c))>>UTF_ACCUMULATION_SHIFT)|UTF_START_MARK(2))
#define UTF8_EIGHT_BIT_LO(c)	(((((U8)(c)))&UTF_CONTINUATION_MASK)|UTF_CONTINUATION_MARK)

#ifdef HAS_QUAD
#define UNISKIP(uv) ( (uv) < 0x80           ? 1 : \
		      (uv) < 0x800          ? 2 : \
		      (uv) < 0x10000        ? 3 : \
		      (uv) < 0x200000       ? 4 : \
		      (uv) < 0x4000000      ? 5 : \
		      (uv) < 0x80000000     ? 6 : \
                      (uv) < UTF8_QUAD_MAX ? 7 : 13 )
#else
/* No, I'm not even going to *TRY* putting #ifdef inside a #define */
#define UNISKIP(uv) ( (uv) < 0x80           ? 1 : \
		      (uv) < 0x800          ? 2 : \
		      (uv) < 0x10000        ? 3 : \
		      (uv) < 0x200000       ? 4 : \
		      (uv) < 0x4000000      ? 5 : \
		      (uv) < 0x80000000     ? 6 : 7 )
#endif

/*
 * Note: we try to be careful never to call the isXXX_utf8() functions
 * unless we're pretty sure we've seen the beginning of a UTF-8 character
 * (that is, the two high bits are set).  Otherwise we risk loading in the
 * heavy-duty swash_init and swash_fetch routines unnecessarily.
 */
#define isIDFIRST_lazy_if(p,c) ((IN_BYTES || (!c || (*((const U8*)p) < 0xc0))) \
				? isIDFIRST(*(p)) \
				: isIDFIRST_utf8((const U8*)p))
#define isALNUM_lazy_if(p,c)   ((IN_BYTES || (!c || (*((const U8*)p) < 0xc0))) \
				? isALNUM(*(p)) \
				: isALNUM_utf8((const U8*)p))


#endif /* EBCDIC vs ASCII */

/* Rest of these are attributes of Unicode and perl's internals rather than the encoding */

#define isIDFIRST_lazy(p)	isIDFIRST_lazy_if(p,1)
#define isALNUM_lazy(p)		isALNUM_lazy_if(p,1)

#define UTF8_MAXBYTES 13
/* How wide can a single UTF-8 encoded character become in bytes.
 * NOTE: Strictly speaking Perl's UTF-8 should not be called UTF-8
 * since UTF-8 is an encoding of Unicode and given Unicode's current
 * upper limit only four bytes is possible.  Perl thinks of UTF-8
 * as a way to encode non-negative integers in a binary format. */
#define UTF8_MAXLEN UTF8_MAXBYTES

#define UTF8_MAXLEN_UCLC 3		/* Obsolete, do not use. */
#define UTF8_MAXLEN_UCLC_MULT 39	/* Obsolete, do not use. */
#define UTF8_MAXLEN_FOLD 3		/* Obsolete, do not use. */
#define UTF8_MAXLEN_FOLD_MULT 39	/* Obsolete, do not use. */

/* The maximum number of UTF-8 bytes a single Unicode character can
 * uppercase/lowercase/fold into; this number depends on the Unicode
 * version.  An example of maximal expansion is the U+03B0 which
 * uppercases to U+03C5 U+0308 U+0301.  The Unicode databases that
 * tell these things are UnicodeDatabase.txt, CaseFolding.txt, and
 * SpecialCasing.txt. */
#define UTF8_MAXBYTES_CASE	6

#define IN_BYTES (CopHINTS_get(PL_curcop) & HINT_BYTES)
#define DO_UTF8(sv) (SvUTF8(sv) && !IN_BYTES)

#define UTF8_ALLOW_EMPTY		0x0001
#define UTF8_ALLOW_CONTINUATION		0x0002
#define UTF8_ALLOW_NON_CONTINUATION	0x0004
#define UTF8_ALLOW_FE_FF		0x0008 /* Allow above 0x7fffFFFF */
#define UTF8_ALLOW_SHORT		0x0010
#define UTF8_ALLOW_SURROGATE		0x0020
#define UTF8_ALLOW_FFFF			0x0040 /* Allow UNICODE_ILLEGAL */
#define UTF8_ALLOW_LONG			0x0080
#define UTF8_ALLOW_ANYUV		(UTF8_ALLOW_EMPTY|UTF8_ALLOW_FE_FF|\
					 UTF8_ALLOW_SURROGATE|UTF8_ALLOW_FFFF)
#define UTF8_ALLOW_ANY			0x00FF
#define UTF8_CHECK_ONLY			0x0200
#define UTF8_ALLOW_DEFAULT		(ckWARN(WARN_UTF8) ? 0 : \
					 UTF8_ALLOW_ANYUV)

#define UNICODE_SURROGATE_FIRST		0xD800
#define UNICODE_SURROGATE_LAST		0xDFFF
#define UNICODE_REPLACEMENT		0xFFFD
#define UNICODE_BYTE_ORDER_MARK		0xFEFF
#define UNICODE_ILLEGAL			0xFFFF

/* Though our UTF-8 encoding can go beyond this,
 * let's be conservative and do as Unicode 3.2 says. */
#define PERL_UNICODE_MAX	0x10FFFF

#define UNICODE_ALLOW_SURROGATE 0x0001	/* Allow UTF-16 surrogates (EVIL) */
#define UNICODE_ALLOW_FDD0	0x0002	/* Allow the U+FDD0...U+FDEF */
#define UNICODE_ALLOW_FFFF	0x0004	/* Allow U+FFF[EF], U+1FFF[EF], ... */
#define UNICODE_ALLOW_SUPER	0x0008	/* Allow past 0x10FFFF */
#define UNICODE_ALLOW_ANY	0x000F

#define UNICODE_IS_SURROGATE(c)		((c) >= UNICODE_SURROGATE_FIRST && \
					 (c) <= UNICODE_SURROGATE_LAST)
#define UNICODE_IS_REPLACEMENT(c)	((c) == UNICODE_REPLACEMENT)
#define UNICODE_IS_BYTE_ORDER_MARK(c)	((c) == UNICODE_BYTE_ORDER_MARK)
#define UNICODE_IS_ILLEGAL(c)		((c) == UNICODE_ILLEGAL)

#ifdef HAS_QUAD
#    define UTF8_QUAD_MAX	UINT64_C(0x1000000000)
#endif

#define UTF8_IS_ASCII(c) UTF8_IS_INVARIANT(c)

#define UNICODE_LATIN_SMALL_LETTER_SHARP_S	0x00DF
#define UNICODE_GREEK_CAPITAL_LETTER_SIGMA	0x03A3
#define UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA	0x03C2
#define UNICODE_GREEK_SMALL_LETTER_SIGMA	0x03C3

#define EBCDIC_LATIN_SMALL_LETTER_SHARP_S	0x0059

#define UNI_DISPLAY_ISPRINT	0x0001
#define UNI_DISPLAY_BACKSLASH	0x0002
#define UNI_DISPLAY_QQ		(UNI_DISPLAY_ISPRINT|UNI_DISPLAY_BACKSLASH)
#define UNI_DISPLAY_REGEX	(UNI_DISPLAY_ISPRINT|UNI_DISPLAY_BACKSLASH)

#ifdef EBCDIC
#   define ANYOF_FOLD_SHARP_S(node, input, end)	\
	(ANYOF_BITMAP_TEST(node, EBCDIC_LATIN_SMALL_LETTER_SHARP_S) && \
	 (ANYOF_FLAGS(node) & ANYOF_UNICODE) && \
	 (ANYOF_FLAGS(node) & ANYOF_FOLD) && \
	 ((end) > (input) + 1) && \
	 toLOWER((input)[0]) == 's' && \
	 toLOWER((input)[1]) == 's')
#else
#   define ANYOF_FOLD_SHARP_S(node, input, end)	\
	(ANYOF_BITMAP_TEST(node, UNICODE_LATIN_SMALL_LETTER_SHARP_S) && \
	 (ANYOF_FLAGS(node) & ANYOF_UNICODE) && \
	 (ANYOF_FLAGS(node) & ANYOF_FOLD) && \
	 ((end) > (input) + 1) && \
	 toLOWER((input)[0]) == 's' && \
	 toLOWER((input)[1]) == 's')
#endif
#define SHARP_S_SKIP 2

#ifdef EBCDIC
/* IS_UTF8_CHAR() is not ported to EBCDIC */
#else
#define IS_UTF8_CHAR_1(p)	\
	((p)[0] <= 0x7F)
#define IS_UTF8_CHAR_2(p)	\
	((p)[0] >= 0xC2 && (p)[0] <= 0xDF && \
	 (p)[1] >= 0x80 && (p)[1] <= 0xBF)
#define IS_UTF8_CHAR_3a(p)	\
	((p)[0] == 0xE0 && \
	 (p)[1] >= 0xA0 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF)
#define IS_UTF8_CHAR_3b(p)	\
	((p)[0] >= 0xE1 && (p)[0] <= 0xEC && \
	 (p)[1] >= 0x80 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF)
#define IS_UTF8_CHAR_3c(p)	\
	((p)[0] == 0xED && \
	 (p)[1] >= 0x80 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF)
/* In IS_UTF8_CHAR_3c(p) one could use
 * (p)[1] >= 0x80 && (p)[1] <= 0x9F
 * if one wanted to exclude surrogates. */
#define IS_UTF8_CHAR_3d(p)	\
	((p)[0] >= 0xEE && (p)[0] <= 0xEF && \
	 (p)[1] >= 0x80 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF)
#define IS_UTF8_CHAR_4a(p)	\
	((p)[0] == 0xF0 && \
	 (p)[1] >= 0x90 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF && \
	 (p)[3] >= 0x80 && (p)[3] <= 0xBF)
#define IS_UTF8_CHAR_4b(p)	\
	((p)[0] >= 0xF1 && (p)[0] <= 0xF3 && \
	 (p)[1] >= 0x80 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF && \
	 (p)[3] >= 0x80 && (p)[3] <= 0xBF)
/* In IS_UTF8_CHAR_4c(p) one could use
 * (p)[0] == 0xF4
 * if one wanted to stop at the Unicode limit U+10FFFF.
 * The 0xF7 allows us to go to 0x1fffff (0x200000 would
 * require five bytes).  Not doing any further code points
 * since that is not needed (and that would not be strict
 * UTF-8, anyway).  The "slow path" in Perl_is_utf8_char()
 * will take care of the "extended UTF-8". */
#define IS_UTF8_CHAR_4c(p)	\
	((p)[0] == 0xF4 && (p)[0] <= 0xF7 && \
	 (p)[1] >= 0x80 && (p)[1] <= 0xBF && \
	 (p)[2] >= 0x80 && (p)[2] <= 0xBF && \
	 (p)[3] >= 0x80 && (p)[3] <= 0xBF)

#define IS_UTF8_CHAR_3(p)	\
	(IS_UTF8_CHAR_3a(p) || \
	 IS_UTF8_CHAR_3b(p) || \
	 IS_UTF8_CHAR_3c(p) || \
	 IS_UTF8_CHAR_3d(p))
#define IS_UTF8_CHAR_4(p)	\
	(IS_UTF8_CHAR_4a(p) || \
	 IS_UTF8_CHAR_4b(p) || \
	 IS_UTF8_CHAR_4c(p))

/* IS_UTF8_CHAR(p) is strictly speaking wrong (not UTF-8) because it
 * (1) allows UTF-8 encoded UTF-16 surrogates
 * (2) it allows code points past U+10FFFF.
 * The Perl_is_utf8_char() full "slow" code will handle the Perl
 * "extended UTF-8". */
#define IS_UTF8_CHAR(p, n)	\
	((n) == 1 ? IS_UTF8_CHAR_1(p) : \
 	 (n) == 2 ? IS_UTF8_CHAR_2(p) : \
	 (n) == 3 ? IS_UTF8_CHAR_3(p) : \
	 (n) == 4 ? IS_UTF8_CHAR_4(p) : 0)

#define IS_UTF8_CHAR_FAST(n) ((n) <= 4)

#endif /* IS_UTF8_CHAR() for UTF-8 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\uconfig.h ===
/*
 * This file was produced by running the config_h.SH script, which
 * gets its values from uconfig.sh, which is generally produced by
 * running Configure.
 *
 * Feel free to modify any of this as the need arises.  Note, however,
 * that running config_h.SH again will wipe out any changes you've made.
 * For a more permanent change edit uconfig.sh and rerun config_h.SH.
 *
 * $Id: Config_h.U,v 3.0.1.5 1997/02/28 14:57:43 ram Exp $
 */

/*
 * Package name      : 
 * Source directory  : 
 * Configuration time: 
 * Configured by     : 
 * Target system     : unknown
 */

#ifndef _config_h_
#define _config_h_

/* LOC_SED:
 *	This symbol holds the complete pathname to the sed program.
 */
#define LOC_SED 	""	/**/

/* HAS_ALARM:
 *	This symbol, if defined, indicates that the alarm routine is
 *	available.
 */
/*#define HAS_ALARM		/ **/

/* HAS_BCMP:
 *	This symbol is defined if the bcmp() routine is available to
 *	compare blocks of memory.
 */
/*#define HAS_BCMP	/ **/

/* HAS_BCOPY:
 *	This symbol is defined if the bcopy() routine is available to
 *	copy blocks of memory.
 */
/*#define HAS_BCOPY	/ **/

/* HAS_BZERO:
 *	This symbol is defined if the bzero() routine is available to
 *	set a memory block to 0.
 */
/*#define HAS_BZERO	/ **/

/* HAS_CHOWN:
 *	This symbol, if defined, indicates that the chown routine is
 *	available.
 */
/*#define HAS_CHOWN		/ **/

/* HAS_CHROOT:
 *	This symbol, if defined, indicates that the chroot routine is
 *	available.
 */
/*#define HAS_CHROOT		/ **/

/* HAS_CHSIZE:
 *	This symbol, if defined, indicates that the chsize routine is available
 *	to truncate files.  You might need a -lx to get this routine.
 */
/*#define	HAS_CHSIZE		/ **/

/* HASCONST:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the const type. There is no need to actually test for that symbol
 *	within your programs. The mere use of the "const" keyword will
 *	trigger the necessary tests.
 */
/*#define HASCONST	/ **/
#ifndef HASCONST
#define const
#endif

/* HAS_CUSERID:
 *	This symbol, if defined, indicates that the cuserid routine is
 *	available to get character login names.
 */
/*#define HAS_CUSERID		/ **/

/* HAS_DBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol DBL_DIG, which is the number
 *	of significant digits in a double precision number.  If this
 *	symbol is not defined, a guess of 15 is usually pretty good.
 */
/*#define HAS_DBL_DIG 	/ * */

/* HAS_DIFFTIME:
 *	This symbol, if defined, indicates that the difftime routine is
 *	available.
 */
/*#define HAS_DIFFTIME		/ **/

/* HAS_DLERROR:
 *	This symbol, if defined, indicates that the dlerror routine is
 *	available to return a string describing the last error that
 *	occurred from a call to dlopen(), dlclose() or dlsym().
 */
/*#define HAS_DLERROR	/ **/

/* HAS_DUP2:
 *	This symbol, if defined, indicates that the dup2 routine is
 *	available to duplicate file descriptors.
 */
/*#define HAS_DUP2	/ **/

/* HAS_FCHMOD:
 *	This symbol, if defined, indicates that the fchmod routine is available
 *	to change mode of opened files.  If unavailable, use chmod().
 */
/*#define HAS_FCHMOD		/ **/

/* HAS_FCHOWN:
 *	This symbol, if defined, indicates that the fchown routine is available
 *	to change ownership of opened files.  If unavailable, use chown().
 */
/*#define HAS_FCHOWN		/ **/

/* HAS_FCNTL:
 *	This symbol, if defined, indicates to the C program that
 *	the fcntl() function exists.
 */
/*#define HAS_FCNTL		/ **/

/* HAS_FGETPOS:
 *	This symbol, if defined, indicates that the fgetpos routine is
 *	available to get the file position indicator, similar to ftell().
 */
/*#define HAS_FGETPOS	/ **/

/* HAS_FLOCK:
 *	This symbol, if defined, indicates that the flock routine is
 *	available to do file locking.
 */
/*#define HAS_FLOCK		/ **/

/* HAS_FORK:
 *	This symbol, if defined, indicates that the fork routine is
 *	available.
 */
#define HAS_FORK		/**/

/* HAS_FSETPOS:
 *	This symbol, if defined, indicates that the fsetpos routine is
 *	available to set the file position indicator, similar to fseek().
 */
/*#define HAS_FSETPOS	/ **/

/* HAS_GETTIMEOFDAY:
 *	This symbol, if defined, indicates that the gettimeofday() system
 *	call is available for a sub-second accuracy clock. Usually, the file
 *	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
 *	The type "Timeval" should be used to refer to "struct timeval".
 */
/*#define HAS_GETTIMEOFDAY	/ **/
#ifdef HAS_GETTIMEOFDAY
#define Timeval struct timeval	/* Structure used by gettimeofday() */
#endif

/* HAS_GETGROUPS:
 *	This symbol, if defined, indicates that the getgroups() routine is
 *	available to get the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_GETGROUPS		/ **/

/* HAS_GETLOGIN:
 *	This symbol, if defined, indicates that the getlogin routine is
 *	available to get the login name.
 */
/*#define HAS_GETLOGIN		/ **/

/* HAS_GETPGID:
 *	This symbol, if defined, indicates to the C program that 
 *	the getpgid(pid) function is available to get the
 *	process group id.
 */
/*#define HAS_GETPGID		/ **/

/* HAS_GETPGRP2:
 *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
 *	routine is available to get the current process group.
 */
/*#define HAS_GETPGRP2		/ **/

/* HAS_GETPPID:
 *	This symbol, if defined, indicates that the getppid routine is
 *	available to get the parent process ID.
 */
/*#define HAS_GETPPID		/ **/

/* HAS_GETPRIORITY:
 *	This symbol, if defined, indicates that the getpriority routine is
 *	available to get a process's priority.
 */
/*#define HAS_GETPRIORITY		/ **/

/* HAS_INET_ATON:
 *	This symbol, if defined, indicates to the C program that the
 *	inet_aton() function is available to parse IP address "dotted-quad"
 *	strings.
 */
/*#define HAS_INET_ATON		/ **/

/* HAS_KILLPG:
 *	This symbol, if defined, indicates that the killpg routine is available
 *	to kill process groups.  If unavailable, you probably should use kill
 *	with a negative process number.
 */
/*#define HAS_KILLPG	/ **/

/* HAS_LINK:
 *	This symbol, if defined, indicates that the link routine is
 *	available to create hard links.
 */
/*#define HAS_LINK	/ **/

/* HAS_LOCALECONV:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available for numeric and monetary formatting conventions.
 */
/*#define HAS_LOCALECONV	/ **/

/* HAS_LOCKF:
 *	This symbol, if defined, indicates that the lockf routine is
 *	available to do file locking.
 */
/*#define HAS_LOCKF		/ **/

/* HAS_LSTAT:
 *	This symbol, if defined, indicates that the lstat routine is
 *	available to do file stats on symbolic links.
 */
/*#define HAS_LSTAT		/ **/

/* HAS_MBLEN:
 *	This symbol, if defined, indicates that the mblen routine is available
 *	to find the number of bytes in a multibye character.
 */
/*#define HAS_MBLEN		/ **/

/* HAS_MBSTOWCS:
 *	This symbol, if defined, indicates that the mbstowcs routine is
 *	available to covert a multibyte string into a wide character string.
 */
/*#define	HAS_MBSTOWCS		/ **/

/* HAS_MBTOWC:
 *	This symbol, if defined, indicates that the mbtowc routine is available
 *	to covert a multibyte to a wide character.
 */
/*#define HAS_MBTOWC		/ **/

/* HAS_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	to compare blocks of memory.
 */
#define HAS_MEMCMP	/**/

/* HAS_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy blocks of memory.
 */
#define HAS_MEMCPY	/**/

/* HAS_MEMMOVE:
 *	This symbol, if defined, indicates that the memmove routine is available
 *	to copy potentially overlapping blocks of memory. This should be used
 *	only when HAS_SAFE_BCOPY is not defined. If neither is there, roll your
 *	own version.
 */
/*#define HAS_MEMMOVE	/ **/

/* HAS_MEMSET:
 *	This symbol, if defined, indicates that the memset routine is available
 *	to set blocks of memory.
 */
/*#define HAS_MEMSET	/ **/

/* HAS_MKDIR:
 *	This symbol, if defined, indicates that the mkdir routine is available
 *	to create directories.  Otherwise you should fork off a new process to
 *	exec /bin/mkdir.
 */
/*#define HAS_MKDIR		/ **/

/* HAS_MKFIFO:
 *	This symbol, if defined, indicates that the mkfifo routine is
 *	available to create FIFOs. Otherwise, mknod should be able to
 *	do it for you. However, if mkfifo is there, mknod might require
 *	super-user privileges which mkfifo will not.
 */
/*#define HAS_MKFIFO		/ **/

/* HAS_MKTIME:
 *	This symbol, if defined, indicates that the mktime routine is
 *	available.
 */
/*#define HAS_MKTIME		/ **/

/* HAS_MSYNC:
 *	This symbol, if defined, indicates that the msync system call is
 *	available to synchronize a mapped file.
 */
/*#define HAS_MSYNC		/ **/

/* HAS_MUNMAP:
 *	This symbol, if defined, indicates that the munmap system call is
 *	available to unmap a region, usually mapped by mmap().
 */
/*#define HAS_MUNMAP		/ **/

/* HAS_NICE:
 *	This symbol, if defined, indicates that the nice routine is
 *	available.
 */
/*#define HAS_NICE		/ **/

/* HAS_PATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given filename.
 */
/* HAS_FPATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given open file descriptor.
 */
/*#define HAS_PATHCONF		/ **/
/*#define HAS_FPATHCONF		/ **/

/* HAS_PAUSE:
 *	This symbol, if defined, indicates that the pause routine is
 *	available to suspend a process until a signal is received.
 */
/*#define HAS_PAUSE		/ **/

/* HAS_PIPE:
 *	This symbol, if defined, indicates that the pipe routine is
 *	available to create an inter-process channel.
 */
/*#define HAS_PIPE		/ **/

/* HAS_READDIR:
 *	This symbol, if defined, indicates that the readdir routine is
 *	available to read directory entries. You may have to include
 *	<dirent.h>. See I_DIRENT.
 */
#define HAS_READDIR		/**/

/* HAS_SEEKDIR:
 *	This symbol, if defined, indicates that the seekdir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_SEEKDIR		/ **/

/* HAS_TELLDIR:
 *	This symbol, if defined, indicates that the telldir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_TELLDIR		/ **/

/* HAS_REWINDDIR:
 *	This symbol, if defined, indicates that the rewinddir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
/*#define HAS_REWINDDIR		/ **/

/* HAS_READLINK:
 *	This symbol, if defined, indicates that the readlink routine is
 *	available to read the value of a symbolic link.
 */
/*#define HAS_READLINK		/ **/

/* HAS_RENAME:
 *	This symbol, if defined, indicates that the rename routine is available
 *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
 *	trick.
 */
#define HAS_RENAME	/**/

/* HAS_RMDIR:
 *	This symbol, if defined, indicates that the rmdir routine is
 *	available to remove directories. Otherwise you should fork off a
 *	new process to exec /bin/rmdir.
 */
/*#define HAS_RMDIR		/ **/

/* HAS_SELECT:
 *	This symbol, if defined, indicates that the select routine is
 *	available to select active file descriptors. If the timeout field
 *	is used, <sys/time.h> may need to be included.
 */
/*#define HAS_SELECT	/ **/

/* HAS_SETEGID:
 *	This symbol, if defined, indicates that the setegid routine is available
 *	to change the effective gid of the current program.
 */
/*#define HAS_SETEGID		/ **/

/* HAS_SETEUID:
 *	This symbol, if defined, indicates that the seteuid routine is available
 *	to change the effective uid of the current program.
 */
/*#define HAS_SETEUID		/ **/

/* HAS_SETLINEBUF:
 *	This symbol, if defined, indicates that the setlinebuf routine is
 *	available to change stderr or stdout from block-buffered or unbuffered
 *	to a line-buffered mode.
 */
/*#define HAS_SETLINEBUF		/ **/

/* HAS_SETLOCALE:
 *	This symbol, if defined, indicates that the setlocale routine is
 *	available to handle locale-specific ctype implementations.
 */
/*#define HAS_SETLOCALE	/ **/

/* HAS_SETPGID:
 *	This symbol, if defined, indicates that the setpgid(pid, gpid)
 *	routine is available to set process group ID.
 */
/*#define HAS_SETPGID	/ **/

/* HAS_SETPGRP2:
 *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
 *	routine is available to set the current process group.
 */
/*#define HAS_SETPGRP2		/ **/

/* HAS_SETPRIORITY:
 *	This symbol, if defined, indicates that the setpriority routine is
 *	available to set a process's priority.
 */
/*#define HAS_SETPRIORITY		/ **/

/* HAS_SETREGID:
 *	This symbol, if defined, indicates that the setregid routine is
 *	available to change the real and effective gid of the current
 *	process.
 */
/* HAS_SETRESGID:
 *	This symbol, if defined, indicates that the setresgid routine is
 *	available to change the real, effective and saved gid of the current
 *	process.
 */
/*#define HAS_SETREGID		/ **/
/*#define HAS_SETRESGID		/ **/

/* HAS_SETREUID:
 *	This symbol, if defined, indicates that the setreuid routine is
 *	available to change the real and effective uid of the current
 *	process.
 */
/* HAS_SETRESUID:
 *	This symbol, if defined, indicates that the setresuid routine is
 *	available to change the real, effective and saved uid of the current
 *	process.
 */
/*#define HAS_SETREUID		/ **/
/*#define HAS_SETRESUID		/ **/

/* HAS_SETRGID:
 *	This symbol, if defined, indicates that the setrgid routine is available
 *	to change the real gid of the current program.
 */
/*#define HAS_SETRGID		/ **/

/* HAS_SETRUID:
 *	This symbol, if defined, indicates that the setruid routine is available
 *	to change the real uid of the current program.
 */
/*#define HAS_SETRUID		/ **/

/* HAS_SETSID:
 *	This symbol, if defined, indicates that the setsid routine is
 *	available to set the process group ID.
 */
/*#define HAS_SETSID	/ **/

/* HAS_STRCHR:
 *	This symbol is defined to indicate that the strchr()/strrchr()
 *	functions are available for string searching. If not, try the
 *	index()/rindex() pair.
 */
/* HAS_INDEX:
 *	This symbol is defined to indicate that the index()/rindex()
 *	functions are available for string searching.
 */
/*#define HAS_STRCHR	/ **/
/*#define HAS_INDEX	/ **/

/* HAS_STRCOLL:
 *	This symbol, if defined, indicates that the strcoll routine is
 *	available to compare strings using collating information.
 */
/*#define HAS_STRCOLL	/ **/

/* USE_STRUCT_COPY:
 *	This symbol, if defined, indicates that this C compiler knows how
 *	to copy structures.  If undefined, you'll need to use a block copy
 *	routine of some sort instead.
 */
/*#define	USE_STRUCT_COPY	/ **/

/* HAS_STRTOD:
 *	This symbol, if defined, indicates that the strtod routine is
 *	available to provide better numeric string conversion than atof().
 */
/*#define HAS_STRTOD	/ **/

/* HAS_STRTOL:
 *	This symbol, if defined, indicates that the strtol routine is available
 *	to provide better numeric string conversion than atoi() and friends.
 */
/*#define HAS_STRTOL	/ **/

/* HAS_STRXFRM:
 *	This symbol, if defined, indicates that the strxfrm() routine is
 *	available to transform strings.
 */
/*#define HAS_STRXFRM	/ **/

/* HAS_SYMLINK:
 *	This symbol, if defined, indicates that the symlink routine is available
 *	to create symbolic links.
 */
/*#define HAS_SYMLINK	/ **/

/* HAS_SYSCALL:
 *	This symbol, if defined, indicates that the syscall routine is
 *	available to call arbitrary system calls. If undefined, that's tough.
 */
/*#define HAS_SYSCALL	/ **/

/* HAS_SYSCONF:
 *	This symbol, if defined, indicates that sysconf() is available
 *	to determine system related limits and options.
 */
/*#define HAS_SYSCONF	/ **/

/* HAS_SYSTEM:
 *	This symbol, if defined, indicates that the system routine is
 *	available to issue a shell command.
 */
/*#define HAS_SYSTEM	/ **/

/* HAS_TCGETPGRP:
 *	This symbol, if defined, indicates that the tcgetpgrp routine is
 *	available to get foreground process group ID.
 */
/*#define HAS_TCGETPGRP		/ **/

/* HAS_TCSETPGRP:
 *	This symbol, if defined, indicates that the tcsetpgrp routine is
 *	available to set foreground process group ID.
 */
/*#define HAS_TCSETPGRP		/ **/

/* HAS_TRUNCATE:
 *	This symbol, if defined, indicates that the truncate routine is
 *	available to truncate files.
 */
/*#define HAS_TRUNCATE	/ **/

/* HAS_TZNAME:
 *	This symbol, if defined, indicates that the tzname[] array is
 *	available to access timezone names.
 */
/*#define HAS_TZNAME		/ **/

/* HAS_UMASK:
 *	This symbol, if defined, indicates that the umask routine is
 *	available to set and get the value of the file creation mask.
 */
/*#define HAS_UMASK		/ **/

/* HAS_USLEEP:
 *	This symbol, if defined, indicates that the usleep routine is
 *	available to let the process sleep on a sub-second accuracy.
 */
/*#define HAS_USLEEP		/ **/

/* HASVOLATILE:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the volatile declaration.
 */
/*#define	HASVOLATILE	/ **/
#ifndef HASVOLATILE
#define volatile
#endif

/* HAS_WAIT4:
 *	This symbol, if defined, indicates that wait4() exists.
 */
/*#define HAS_WAIT4	/ **/

/* HAS_WAITPID:
 *	This symbol, if defined, indicates that the waitpid routine is
 *	available to wait for child process.
 */
/*#define HAS_WAITPID	/ **/

/* HAS_WCSTOMBS:
 *	This symbol, if defined, indicates that the wcstombs routine is
 *	available to convert wide character strings to multibyte strings.
 */
/*#define HAS_WCSTOMBS	/ **/

/* HAS_WCTOMB:
 *	This symbol, if defined, indicates that the wctomb routine is available
 *	to covert a wide character to a multibyte.
 */
/*#define HAS_WCTOMB		/ **/

/* I_ARPA_INET:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <arpa/inet.h> to get inet_addr and friends declarations.
 */
/*#define	I_ARPA_INET		/ **/

/* I_DBM:
 *	This symbol, if defined, indicates that <dbm.h> exists and should
 *	be included.
 */
/* I_RPCSVC_DBM:
 *	This symbol, if defined, indicates that <rpcsvc/dbm.h> exists and
 *	should be included.
 */
/*#define I_DBM	/ **/
/*#define I_RPCSVC_DBM	/ **/

/* I_DIRENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <dirent.h>. Using this symbol also triggers the definition
 *	of the Direntry_t define which ends up being 'struct dirent' or
 *	'struct direct' depending on the availability of <dirent.h>.
 */
/* DIRNAMLEN:
 *	This symbol, if defined, indicates to the C program that the length
 *	of directory entry names is provided by a d_namlen field.  Otherwise
 *	you need to do strlen() on the d_name field.
 */
/* Direntry_t:
 *	This symbol is set to 'struct direct' or 'struct dirent' depending on
 *	whether dirent is available or not. You should use this pseudo type to
 *	portably declare your directory entries.
 */
#define I_DIRENT		/**/
/*#define DIRNAMLEN	/ **/
#define Direntry_t struct dirent

/* I_DLFCN:
 *	This symbol, if defined, indicates that <dlfcn.h> exists and should
 *	be included.
 */
/*#define I_DLFCN		/ **/

/* I_FCNTL:
 *	This manifest constant tells the C program to include <fcntl.h>.
 */
/*#define I_FCNTL	/ **/

/* I_FLOAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <float.h> to get definition of symbols like DBL_MAX or
 *	DBL_MIN, i.e. machine dependent floating point values.
 */
/*#define I_FLOAT		/ **/

/* I_LIMITS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <limits.h> to get definition of symbols like WORD_BIT or
 *	LONG_MAX, i.e. machine dependant limitations.
 */
/*#define I_LIMITS		/ **/

/* I_LOCALE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <locale.h>.
 */
/*#define	I_LOCALE		/ **/

/* I_MATH:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <math.h>.
 */
#define I_MATH		/**/

/* I_MEMORY:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <memory.h>.
 */
/*#define I_MEMORY		/ **/

/* I_NET_ERRNO:
 *	This symbol, if defined, indicates that <net/errno.h> exists and 
 *	should be included.
 */
/*#define I_NET_ERRNO		/ **/

/* I_NETINET_IN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <netinet/in.h>. Otherwise, you may try <sys/in.h>.
 */
/*#define I_NETINET_IN	/ **/

/* I_SFIO:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sfio.h>.
 */
/*#define	I_SFIO		/ **/

/* I_STDDEF:
 *	This symbol, if defined, indicates that <stddef.h> exists and should
 *	be included.
 */
/*#define I_STDDEF	/ **/

/* I_STDLIB:
 *	This symbol, if defined, indicates that <stdlib.h> exists and should
 *	be included.
 */
#define I_STDLIB		/**/

/* I_STRING:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
 */
#define I_STRING		/**/

/* I_SYS_DIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/dir.h>.
 */
/*#define I_SYS_DIR		/ **/

/* I_SYS_FILE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/file.h> to get definition of R_OK and friends.
 */
/*#define I_SYS_FILE		/ **/

/* I_SYS_IOCTL:
 *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
 *	be included. Otherwise, include <sgtty.h> or <termio.h>.
 */
/* I_SYS_SOCKIO:
 *	This symbol, if defined, indicates the <sys/sockio.h> should be included
 *	to get socket ioctl options, like SIOCATMARK.
 */
/*#define	I_SYS_IOCTL		/ **/
/*#define I_SYS_SOCKIO	/ **/

/* I_SYS_NDIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/ndir.h>.
 */
/*#define I_SYS_NDIR	/ **/

/* I_SYS_PARAM:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/param.h>.
 */
/*#define I_SYS_PARAM		/ **/

/* I_SYS_RESOURCE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/resource.h>.
 */
/*#define I_SYS_RESOURCE		/ **/

/* I_SYS_SELECT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/select.h> in order to get definition of struct timeval.
 */
/*#define I_SYS_SELECT	/ **/

/* I_SYS_STAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/stat.h>.
 */
#define	I_SYS_STAT		/**/

/* I_SYS_TIMES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/times.h>.
 */
/*#define	I_SYS_TIMES		/ **/

/* I_SYS_TYPES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/types.h>.
 */
/*#define	I_SYS_TYPES		/ **/

/* I_SYS_UN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/un.h> to get UNIX domain socket definitions.
 */
/*#define I_SYS_UN		/ **/

/* I_SYS_WAIT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/wait.h>.
 */
/*#define I_SYS_WAIT	/ **/

/* I_TERMIO:
 *	This symbol, if defined, indicates that the program should include
 *	<termio.h> rather than <sgtty.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/* I_TERMIOS:
 *	This symbol, if defined, indicates that the program should include
 *	the POSIX termios.h rather than sgtty.h or termio.h.
 *	There are also differences in the ioctl() calls that depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/ **/
/*#define I_TERMIOS		/ **/
/*#define I_SGTTY		/ **/

/* I_UNISTD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <unistd.h>.
 */
/*#define I_UNISTD		/ **/

/* I_UTIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <utime.h>.
 */
/*#define I_UTIME		/ **/

/* I_VALUES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <values.h> to get definition of symbols like MINFLOAT or
 *	MAXLONG, i.e. machine dependant limitations.  Probably, you
 *	should use <limits.h> instead, if it is available.
 */
/*#define I_VALUES		/ **/

/* I_VFORK:
 *	This symbol, if defined, indicates to the C program that it should
 *	include vfork.h.
 */
/*#define I_VFORK	/ **/

/* HAS_ACCESSX:
 *	This symbol, if defined, indicates that the accessx routine is
 *	available to do extended access checks.
 */
/*#define HAS_ACCESSX		/ **/

/* HAS_EACCESS:
 *	This symbol, if defined, indicates that the eaccess routine is
 *	available to do extended access checks.
 */
/*#define HAS_EACCESS		/ **/

/* I_SYS_ACCESS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/access.h>.
 */
/*#define   I_SYS_ACCESS                / **/

/* I_SYS_SECURITY:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/security.h>.
 */
/*#define   I_SYS_SECURITY	/ **/

/* USE_CROSS_COMPILE:
 *	This symbol, if defined, indicates that Perl is being cross-compiled.
 */
/* PERL_TARGETARCH:
 *	This symbol, if defined, indicates the target architecture
 *	Perl has been cross-compiled to.  Undefined if not a cross-compile.
 */
#ifndef USE_CROSS_COMPILE
/*#define	USE_CROSS_COMPILE	/ **/
#define	PERL_TARGETARCH	""	/**/
#endif

/* OSNAME:
 *	This symbol contains the name of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
/* OSVERS:
 *	This symbol contains the version of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
#define OSNAME "unknown"		/**/
#define OSVERS ""		/**/

/* MULTIARCH:
 *	This symbol, if defined, signifies that the build
 *	process will produce some binary files that are going to be
 *	used in a cross-platform environment.  This is the case for
 *	example with the NeXT "fat" binaries that contain executables
 *	for several CPUs.
 */
/*#define MULTIARCH		/ **/

/* MEM_ALIGNBYTES:
 *	This symbol contains the number of bytes required to align a
 *	double, or a long double when applicable. Usual values are 2,
 *	4 and 8. The default is eight, for safety.
 */
#if defined(USE_CROSS_COMPILE) || defined(MULTIARCH)
#  define MEM_ALIGNBYTES 8
#else
#define MEM_ALIGNBYTES 4
#endif

/* ARCHLIB:
 *	This variable, if defined, holds the name of the directory in
 *	which the user wants to put architecture-dependent public
 *	library files for .  It is most often a local directory
 *	such as /usr/local/lib.  Programs using this variable must be
 *	prepared to deal with filename expansion.  If ARCHLIB is the
 *	same as PRIVLIB, it is not defined, since presumably the
 *	program already searches PRIVLIB.
 */
/* ARCHLIB_EXP:
 *	This symbol contains the ~name expanded version of ARCHLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define ARCHLIB "/usr/local/lib/perl5/5.9/unknown"		/ **/
/*#define ARCHLIB_EXP "/usr/local/lib/perl5/5.9/unknown"		/ **/

/* ARCHNAME:
 *	This symbol holds a string representing the architecture name.
 *	It may be used to construct an architecture-dependant pathname
 *	where library files may be held under a private library, for
 *	instance.
 */
#define ARCHNAME "unknown"		/**/

/* HAS_ATOLF:
 *	This symbol, if defined, indicates that the atolf routine is
 *	available to convert strings into long doubles.
 */
/*#define HAS_ATOLF		/ **/

/* HAS_ATOLL:
 *	This symbol, if defined, indicates that the atoll routine is
 *	available to convert strings into long longs.
 */
/*#define HAS_ATOLL		/ **/

/* BIN:
 *	This symbol holds the path of the bin directory where the package will
 *	be installed. Program must be prepared to deal with ~name substitution.
 */
/* BIN_EXP:
 *	This symbol is the filename expanded version of the BIN symbol, for
 *	programs that do not want to deal with that at run-time.
 */
/* PERL_RELOCATABLE_INC:
 *	This symbol, if defined, indicates that we'd like to relocate entries
 *	in @INC at run time based on the location of the perl binary.
 */
#define BIN "/usr/local/bin"	/**/
#define BIN_EXP ""	/**/
#define PERL_RELOCATABLE_INC "undef" 		/**/

/* INTSIZE:
 *	This symbol contains the value of sizeof(int) so that the C
 *	preprocessor can make decisions based on it.
 */
/* LONGSIZE:
 *	This symbol contains the value of sizeof(long) so that the C
 *	preprocessor can make decisions based on it.
 */
/* SHORTSIZE:
 *	This symbol contains the value of sizeof(short) so that the C
 *	preprocessor can make decisions based on it.
 */
#define INTSIZE 4		/**/
#define LONGSIZE 4		/**/
#define SHORTSIZE 2		/**/

/* BYTEORDER:
 *	This symbol holds the hexadecimal constant defined in byteorder,
 *	in a UV, i.e. 0x1234 or 0x4321 or 0x12345678, etc...
 *	If the compiler supports cross-compiling or multiple-architecture
 *	binaries (eg. on NeXT systems), use compiler-defined macros to
 *	determine the byte order.
 *	On NeXT 3.2 (and greater), you can build "Fat" Multiple Architecture
 *	Binaries (MAB) on either big endian or little endian machines.
 *	The endian-ness is available at compile-time.  This only matters
 *	for perl, where the config.h can be generated and installed on 
 *	one system, and used by a different architecture to build an
 *	extension.  Older versions of NeXT that might not have
 *	defined either *_ENDIAN__ were all on Motorola 680x0 series,
 *	so the default case (for NeXT) is big endian to catch them. 
 *	This might matter for NeXT 3.0.
 */
#if defined(USE_CROSS_COMPILE) || defined(MULTIARCH)
#  ifdef __LITTLE_ENDIAN__
#    if LONGSIZE == 4
#      define BYTEORDER 0x1234
#    else
#      if LONGSIZE == 8
#        define BYTEORDER 0x12345678
#      endif
#    endif
#  else
#    ifdef __BIG_ENDIAN__
#      if LONGSIZE == 4
#        define BYTEORDER 0x4321
#      else
#        if LONGSIZE == 8
#          define BYTEORDER 0x87654321
#        endif
#      endif
#    endif
#  endif
#  if !defined(BYTEORDER) && (defined(NeXT) || defined(__NeXT__))
#    define BYTEORDER 0x4321
#  endif
#else
#define BYTEORDER 0x1234	/* large digits for MSB */
#endif /* NeXT */

/* CAT2:
 *	This macro concatenates 2 tokens together.
 */
/* STRINGIFY:
 *	This macro surrounds its token with double quotes.
 */
#if 42 == 1
#define CAT2(a,b)	a/**/b
#define STRINGIFY(a)	"a"
		/* If you can get stringification with catify, tell me how! */
#endif
#if 42 == 42
#define PeRl_CaTiFy(a, b)	a ## b	
#define PeRl_StGiFy(a)	#a
/* the additional level of indirection enables these macros to be
 * used as arguments to other macros.  See K&R 2nd ed., page 231. */
#define CAT2(a,b)	PeRl_CaTiFy(a,b)
#define StGiFy(a)	PeRl_StGiFy(a)
#define STRINGIFY(a)	PeRl_StGiFy(a)
#endif
#if 42 != 1 && 42 != 42
#   include "Bletch: How does this C preprocessor concatenate tokens?"
#endif

/* CPPSTDIN:
 *	This symbol contains the first part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.	 Typical value of "cc -E" or "/lib/cpp", but it can also
 *	call a wrapper. See CPPRUN.
 */
/* CPPMINUS:
 *	This symbol contains the second part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
 *	to specify standard input, otherwise the value is "".
 */
/* CPPRUN:
 *	This symbol contains the string which will invoke a C preprocessor on
 *	the standard input and produce to standard output. It needs to end
 *	with CPPLAST, after all other preprocessor flags have been specified.
 *	The main difference with CPPSTDIN is that this program will never be a
 *	pointer to a shell wrapper, i.e. it will be empty if no preprocessor is
 *	available directly to the user. Note that it may well be different from
 *	the preprocessor used to compile the C program.
 */
/* CPPLAST:
 *	This symbol is intended to be used along with CPPRUN in the same manner
 *	symbol CPPMINUS is used with CPPSTDIN. It contains either "-" or "".
 */
#define CPPSTDIN ""
#define CPPMINUS ""
#define CPPRUN ""
#define CPPLAST ""

/* HAS__FWALK:
 *	This symbol, if defined, indicates that the _fwalk system call is
 *	available to apply a function to all the file handles.
 */
/*#define HAS__FWALK		/ **/

/* HAS_ACCESS:
 *	This manifest constant lets the C program know that the access()
 *	system call is available to check for accessibility using real UID/GID.
 *	(always present on UNIX.)
 */
/*#define HAS_ACCESS		/ **/

/* HAS_AINTL:
 *	This symbol, if defined, indicates that the aintl routine is
 *	available.  If copysignl is also present we can emulate modfl.
 */
/*#define HAS_AINTL		/ **/

/* HAS_ASCTIME_R:
 *	This symbol, if defined, indicates that the asctime_r routine
 *	is available to asctime re-entrantly.
 */
/* ASCTIME_R_PROTO:
 *	This symbol encodes the prototype of asctime_r.
 *	It is zero if d_asctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_asctime_r
 *	is defined.
 */
/*#define HAS_ASCTIME_R	   / **/
#define ASCTIME_R_PROTO 0	   /**/

/* HASATTRIBUTE_FORMAT:
 *	Can we handle GCC attribute for checking printf-style formats
 */
/* HASATTRIBUTE_MALLOC:
 *	Can we handle GCC attribute for malloc-style functions.
 */
/* HASATTRIBUTE_NONNULL:
 *	Can we handle GCC attribute for nonnull function parms.
 */
/* HASATTRIBUTE_NORETURN:
 *	Can we handle GCC attribute for functions that do not return
 */
/* HASATTRIBUTE_PURE:
 *	Can we handle GCC attribute for pure functions
 */
/* HASATTRIBUTE_UNUSED:
 *	Can we handle GCC attribute for unused variables and arguments
 */
/* HASATTRIBUTE_WARN_UNUSED_RESULT:
 *	Can we handle GCC attribute for warning on unused results
 */
/*#define HASATTRIBUTE_FORMAT	/ **/
/*#define HASATTRIBUTE_NORETURN	/ **/
/*#define HASATTRIBUTE_MALLOC	/ **/
/*#define HASATTRIBUTE_NONNULL	/ **/
/*#define HASATTRIBUTE_PURE	/ **/
/*#define HASATTRIBUTE_UNUSED	/ **/
/*#define HASATTRIBUTE_WARN_UNUSED_RESULT	/ **/

/* HAS_BUILTIN_CHOOSE_EXPR:
 *	Can we handle GCC builtin for compile-time ternary-like expressions
 */
/* HAS_BUILTIN_EXPECT:
 *	Can we handle GCC builtin for telling that certain values are more
 *	likely
 */
/*#define HAS_BUILTIN_EXPECT	/ **/
/*#define HAS_BUILTIN_CHOOSE_EXPR	/ **/

/* HAS_C99_VARIADIC_MACROS:
 *	If defined, the compiler supports C99 variadic macros.
 */
/*#define	HAS_C99_VARIADIC_MACROS	/ **/

/* CASTI32:
 *	This symbol is defined if the C compiler can cast negative
 *	or large floating point numbers to 32-bit ints.
 */
/*#define	CASTI32		/ **/

/* CASTNEGFLOAT:
 *	This symbol is defined if the C compiler can cast negative
 *	numbers to unsigned longs, ints and shorts.
 */
/* CASTFLAGS:
 *	This symbol contains flags that say what difficulties the compiler
 *	has casting odd floating values to unsigned long:
 *		0 = ok
 *		1 = couldn't cast < 0
 *		2 = couldn't cast >= 0x80000000
 *		4 = couldn't cast in argument expression list
 */
/*#define	CASTNEGFLOAT		/ **/
#define CASTFLAGS 0		/**/

/* HAS_CLASS:
 *	This symbol, if defined, indicates that the class routine is
 *	available to classify doubles.  Available for example in AIX.
 *	The returned values are defined in <float.h> and are:
 *
 *	FP_PLUS_NORM	Positive normalized, nonzero
 *	FP_MINUS_NORM	Negative normalized, nonzero
 *	FP_PLUS_DENORM	Positive denormalized, nonzero
 *	FP_MINUS_DENORM	Negative denormalized, nonzero
 *	FP_PLUS_ZERO	+0.0
 *	FP_MINUS_ZERO	-0.0
 *	FP_PLUS_INF	+INF
 *	FP_MINUS_INF	-INF
 *	FP_NANS		Signaling Not a Number (NaNS)
 *	FP_NANQ		Quiet Not a Number (NaNQ)
 */
/*#define HAS_CLASS		/ **/

/* HAS_CLEARENV:
 *	This symbol, if defined, indicates that the clearenv () routine is
 *	available for use.
 */
/*#define HAS_CLEARENV		/ **/

/* VOID_CLOSEDIR:
 *	This symbol, if defined, indicates that the closedir() routine
 *	does not return a value.
 */
/*#define VOID_CLOSEDIR		/ **/

/* HAS_STRUCT_CMSGHDR:
 *	This symbol, if defined, indicates that the struct cmsghdr
 *	is supported.
 */
/*#define HAS_STRUCT_CMSGHDR	/ **/

/* HAS_COPYSIGNL:
 *	This symbol, if defined, indicates that the copysignl routine is
 *	available.  If aintl is also present we can emulate modfl.
 */
/*#define HAS_COPYSIGNL		/ **/

/* USE_CPLUSPLUS:
 *	This symbol, if defined, indicates that a C++ compiler was
 *	used to compiled Perl and will be used to compile extensions.
 */
/*#define USE_CPLUSPLUS		/ **/

/* HAS_CRYPT:
 *	This symbol, if defined, indicates that the crypt routine is available
 *	to encrypt passwords and the like.
 */
/*#define HAS_CRYPT		/ **/

/* HAS_CRYPT_R:
 *	This symbol, if defined, indicates that the crypt_r routine
 *	is available to crypt re-entrantly.
 */
/* CRYPT_R_PROTO:
 *	This symbol encodes the prototype of crypt_r.
 *	It is zero if d_crypt_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_crypt_r
 *	is defined.
 */
/*#define HAS_CRYPT_R	   / **/
#define CRYPT_R_PROTO 0	   /**/

/* HAS_CSH:
 *	This symbol, if defined, indicates that the C-shell exists.
 */
/* CSH:
 *	This symbol, if defined, contains the full pathname of csh.
 */
/*#define HAS_CSH		/ **/
#ifdef HAS_CSH
#define CSH ""	/**/
#endif

/* HAS_CTERMID_R:
 *	This symbol, if defined, indicates that the ctermid_r routine
 *	is available to ctermid re-entrantly.
 */
/* CTERMID_R_PROTO:
 *	This symbol encodes the prototype of ctermid_r.
 *	It is zero if d_ctermid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctermid_r
 *	is defined.
 */
/*#define HAS_CTERMID_R	   / **/
#define CTERMID_R_PROTO 0	   /**/

/* HAS_CTIME_R:
 *	This symbol, if defined, indicates that the ctime_r routine
 *	is available to ctime re-entrantly.
 */
/* CTIME_R_PROTO:
 *	This symbol encodes the prototype of ctime_r.
 *	It is zero if d_ctime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ctime_r
 *	is defined.
 */
/*#define HAS_CTIME_R	   / **/
#define CTIME_R_PROTO 0	   /**/

/* HAS_DBMINIT_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the dbminit() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int dbminit(char *);
 */
/*#define	HAS_DBMINIT_PROTO	/ **/

/* HAS_DIRFD:
 *	This manifest constant lets the C program know that dirfd
 *	is available.
 */
/*#define HAS_DIRFD		/ **/

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/ **/

/* SETUID_SCRIPTS_ARE_SECURE_NOW:
 *	This symbol, if defined, indicates that the bug that prevents
 *	setuid scripts from being secure is not present in this kernel.
 */
/* DOSUID:
 *	This symbol, if defined, indicates that the C program should
 *	check the script that it is executing for setuid/setgid bits, and
 *	attempt to emulate setuid/setgid on systems that have disabled
 *	setuid #! scripts because the kernel can't do it securely.
 *	It is up to the package designer to make sure that this emulation
 *	is done securely.  Among other things, it should do an fstat on
 *	the script it just opened to make sure it really is a setuid/setgid
 *	script, it should make sure the arguments passed correspond exactly
 *	to the argument on the #! line, and it should not trust any
 *	subprocesses to which it must pass the filename rather than the
 *	file descriptor of the script to be executed.
 */
/*#define SETUID_SCRIPTS_ARE_SECURE_NOW	/ **/
/*#define DOSUID		/ **/

/* HAS_DRAND48_R:
 *	This symbol, if defined, indicates that the drand48_r routine
 *	is available to drand48 re-entrantly.
 */
/* DRAND48_R_PROTO:
 *	This symbol encodes the prototype of drand48_r.
 *	It is zero if d_drand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_drand48_r
 *	is defined.
 */
/*#define HAS_DRAND48_R	   / **/
#define DRAND48_R_PROTO 0	   /**/

/* HAS_DRAND48_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the drand48() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern double drand48(void);
 */
/*#define	HAS_DRAND48_PROTO	/ **/

/* HAS_ENDGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the group database.
 */
/*#define HAS_ENDGRENT		/ **/

/* HAS_ENDGRENT_R:
 *	This symbol, if defined, indicates that the endgrent_r routine
 *	is available to endgrent re-entrantly.
 */
/* ENDGRENT_R_PROTO:
 *	This symbol encodes the prototype of endgrent_r.
 *	It is zero if d_endgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endgrent_r
 *	is defined.
 */
/*#define HAS_ENDGRENT_R	   / **/
#define ENDGRENT_R_PROTO 0	   /**/

/* HAS_ENDHOSTENT:
 *	This symbol, if defined, indicates that the endhostent() routine is
 *	available to close whatever was being used for host queries.
 */
/*#define HAS_ENDHOSTENT		/ **/

/* HAS_ENDHOSTENT_R:
 *	This symbol, if defined, indicates that the endhostent_r routine
 *	is available to endhostent re-entrantly.
 */
/* ENDHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of endhostent_r.
 *	It is zero if d_endhostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endhostent_r
 *	is defined.
 */
/*#define HAS_ENDHOSTENT_R	   / **/
#define ENDHOSTENT_R_PROTO 0	   /**/

/* HAS_ENDNETENT:
 *	This symbol, if defined, indicates that the endnetent() routine is
 *	available to close whatever was being used for network queries.
 */
/*#define HAS_ENDNETENT		/ **/

/* HAS_ENDNETENT_R:
 *	This symbol, if defined, indicates that the endnetent_r routine
 *	is available to endnetent re-entrantly.
 */
/* ENDNETENT_R_PROTO:
 *	This symbol encodes the prototype of endnetent_r.
 *	It is zero if d_endnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endnetent_r
 *	is defined.
 */
/*#define HAS_ENDNETENT_R	   / **/
#define ENDNETENT_R_PROTO 0	   /**/

/* HAS_ENDPROTOENT:
 *	This symbol, if defined, indicates that the endprotoent() routine is
 *	available to close whatever was being used for protocol queries.
 */
/*#define HAS_ENDPROTOENT		/ **/

/* HAS_ENDPROTOENT_R:
 *	This symbol, if defined, indicates that the endprotoent_r routine
 *	is available to endprotoent re-entrantly.
 */
/* ENDPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of endprotoent_r.
 *	It is zero if d_endprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endprotoent_r
 *	is defined.
 */
/*#define HAS_ENDPROTOENT_R	   / **/
#define ENDPROTOENT_R_PROTO 0	   /**/

/* HAS_ENDPWENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the passwd database.
 */
/*#define HAS_ENDPWENT		/ **/

/* HAS_ENDPWENT_R:
 *	This symbol, if defined, indicates that the endpwent_r routine
 *	is available to endpwent re-entrantly.
 */
/* ENDPWENT_R_PROTO:
 *	This symbol encodes the prototype of endpwent_r.
 *	It is zero if d_endpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endpwent_r
 *	is defined.
 */
/*#define HAS_ENDPWENT_R	   / **/
#define ENDPWENT_R_PROTO 0	   /**/

/* HAS_ENDSERVENT:
 *	This symbol, if defined, indicates that the endservent() routine is
 *	available to close whatever was being used for service queries.
 */
/*#define HAS_ENDSERVENT		/ **/

/* HAS_ENDSERVENT_R:
 *	This symbol, if defined, indicates that the endservent_r routine
 *	is available to endservent re-entrantly.
 */
/* ENDSERVENT_R_PROTO:
 *	This symbol encodes the prototype of endservent_r.
 *	It is zero if d_endservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_endservent_r
 *	is defined.
 */
/*#define HAS_ENDSERVENT_R	   / **/
#define ENDSERVENT_R_PROTO 0	   /**/

/* HAS_FAST_STDIO:
 *	This symbol, if defined, indicates that the "fast stdio"
 *	is available to manipulate the stdio buffers directly.
 */
/*#define HAS_FAST_STDIO		/ **/

/* HAS_FCHDIR:
 *	This symbol, if defined, indicates that the fchdir routine is
 *	available to change directory using a file descriptor.
 */
/*#define HAS_FCHDIR		/ **/

/* FCNTL_CAN_LOCK:
 *	This symbol, if defined, indicates that fcntl() can be used
 *	for file locking.  Normally on Unix systems this is defined.
 *	It may be undefined on VMS.
 */
/*#define FCNTL_CAN_LOCK		/ **/

/* HAS_FD_SET:
 *	This symbol, when defined, indicates presence of the fd_set typedef
 *	in <sys/types.h>
 */
/*#define HAS_FD_SET	/ **/

/* HAS_FINITE:
 *	This symbol, if defined, indicates that the finite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_FINITE		/ **/

/* HAS_FINITEL:
 *	This symbol, if defined, indicates that the finitel routine is
 *	available to check whether a long double is finite
 *	(non-infinity non-NaN).
 */
/*#define HAS_FINITEL		/ **/

/* FLEXFILENAMES:
 *	This symbol, if defined, indicates that the system supports filenames
 *	longer than 14 characters.
 */
/*#define	FLEXFILENAMES		/ **/

/* HAS_FLOCK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the flock() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int flock(int, int);
 */
/*#define	HAS_FLOCK_PROTO	/ **/

/* HAS_FP_CLASS:
 *	This symbol, if defined, indicates that the fp_class routine is
 *	available to classify doubles.  Available for example in Digital UNIX.
 *	The returned values are defined in <math.h> and are:
 *
 *	FP_SNAN           Signaling NaN (Not-a-Number)
 *	FP_QNAN           Quiet NaN (Not-a-Number)
 *	FP_POS_INF        +infinity
 *	FP_NEG_INF        -infinity
 *	FP_POS_NORM       Positive normalized
 *	FP_NEG_NORM       Negative normalized
 *	FP_POS_DENORM     Positive denormalized
 *	FP_NEG_DENORM     Negative denormalized
 *	FP_POS_ZERO       +0.0 (positive zero)
 *	FP_NEG_ZERO       -0.0 (negative zero)
 */
/*#define HAS_FP_CLASS		/ **/

/* HAS_FPCLASS:
 *	This symbol, if defined, indicates that the fpclass routine is
 *	available to classify doubles.  Available for example in Solaris/SVR4.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASS		/ **/

/* HAS_FPCLASSIFY:
 *	This symbol, if defined, indicates that the fpclassify routine is
 *	available to classify doubles.  Available for example in HP-UX.
 *	The returned values are defined in <math.h> and are
 *
 *           FP_NORMAL     Normalized
 *           FP_ZERO       Zero
 *           FP_INFINITE   Infinity
 *           FP_SUBNORMAL  Denormalized
 *           FP_NAN        NaN
 *
 */
/*#define HAS_FPCLASSIFY		/ **/

/* HAS_FPCLASSL:
 *	This symbol, if defined, indicates that the fpclassl routine is
 *	available to classify long doubles.  Available for example in IRIX.
 *	The returned values are defined in <ieeefp.h> and are:
 *
 *	FP_SNAN		signaling NaN
 *	FP_QNAN		quiet NaN
 *	FP_NINF		negative infinity
 *	FP_PINF		positive infinity
 *	FP_NDENORM	negative denormalized non-zero
 *	FP_PDENORM	positive denormalized non-zero
 *	FP_NZERO	negative zero
 *	FP_PZERO	positive zero
 *	FP_NNORM	negative normalized non-zero
 *	FP_PNORM	positive normalized non-zero
 */
/*#define HAS_FPCLASSL		/ **/

/* HAS_FPOS64_T:
 *	This symbol will be defined if the C compiler supports fpos64_t.
 */
/*#define	HAS_FPOS64_T    	/ **/

/* HAS_FREXPL:
 *	This symbol, if defined, indicates that the frexpl routine is
 *	available to break a long double floating-point number into
 *	a normalized fraction and an integral power of 2.
 */
/*#define HAS_FREXPL		/ **/

/* HAS_STRUCT_FS_DATA:
 *	This symbol, if defined, indicates that the struct fs_data
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_FS_DATA	/ **/

/* HAS_FSEEKO:
 *	This symbol, if defined, indicates that the fseeko routine is
 *	available to fseek beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FSEEKO		/ **/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATFS		/ **/

/* HAS_FSYNC:
 *	This symbol, if defined, indicates that the fsync routine is
 *	available to write a file's modified data and attributes to
 *	permanent storage.
 */
/*#define HAS_FSYNC		/ **/

/* HAS_FTELLO:
 *	This symbol, if defined, indicates that the ftello routine is
 *	available to ftell beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FTELLO		/ **/

/* HAS_FUTIMES:
 *	This symbol, if defined, indicates that the futimes routine is
 *	available to change file descriptor time stamps with struct timevals.
 */
/*#define HAS_FUTIMES		/ **/

/* Gconvert:
 *	This preprocessor macro is defined to convert a floating point
 *	number to a string without a trailing decimal point.  This
 *	emulates the behavior of sprintf("%g"), but is sometimes much more
 *	efficient.  If gconvert() is not available, but gcvt() drops the
 *	trailing decimal point, then gcvt() is used.  If all else fails,
 *	a macro using sprintf("%g") is used. Arguments for the Gconvert
 *	macro are: value, number of digits, whether trailing zeros should
 *	be retained, and the output buffer.
 *	The usual values are:
 *		d_Gconvert='gconvert((x),(n),(t),(b))'
 *		d_Gconvert='gcvt((x),(n),(b))'
 *		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
 *	The last two assume trailing zeros should not be kept.
 */
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))

/* HAS_GETCWD:
 *	This symbol, if defined, indicates that the getcwd routine is
 *	available to get the current working directory.
 */
/*#define HAS_GETCWD		/ **/

/* HAS_GETESPWNAM:
 *	This symbol, if defined, indicates that the getespwnam system call is
 *	available to retrieve enchanced (shadow) password entries by name.
 */
/*#define HAS_GETESPWNAM		/ **/

/* HAS_GETFSSTAT:
 *	This symbol, if defined, indicates that the getfsstat routine is
 *	available to stat filesystems in bulk.
 */
/*#define HAS_GETFSSTAT		/ **/

/* HAS_GETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for sequential access of the group database.
 */
/*#define HAS_GETGRENT		/ **/

/* HAS_GETGRENT_R:
 *	This symbol, if defined, indicates that the getgrent_r routine
 *	is available to getgrent re-entrantly.
 */
/* GETGRENT_R_PROTO:
 *	This symbol encodes the prototype of getgrent_r.
 *	It is zero if d_getgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrent_r
 *	is defined.
 */
/*#define HAS_GETGRENT_R	   / **/
#define GETGRENT_R_PROTO 0	   /**/

/* HAS_GETGRGID_R:
 *	This symbol, if defined, indicates that the getgrgid_r routine
 *	is available to getgrgid re-entrantly.
 */
/* GETGRGID_R_PROTO:
 *	This symbol encodes the prototype of getgrgid_r.
 *	It is zero if d_getgrgid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrgid_r
 *	is defined.
 */
/*#define HAS_GETGRGID_R	   / **/
#define GETGRGID_R_PROTO 0	   /**/

/* HAS_GETGRNAM_R:
 *	This symbol, if defined, indicates that the getgrnam_r routine
 *	is available to getgrnam re-entrantly.
 */
/* GETGRNAM_R_PROTO:
 *	This symbol encodes the prototype of getgrnam_r.
 *	It is zero if d_getgrnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getgrnam_r
 *	is defined.
 */
/*#define HAS_GETGRNAM_R	   / **/
#define GETGRNAM_R_PROTO 0	   /**/

/* HAS_GETHOSTBYADDR:
 *	This symbol, if defined, indicates that the gethostbyaddr() routine is
 *	available to look up hosts by their IP addresses.
 */
/*#define HAS_GETHOSTBYADDR		/ **/

/* HAS_GETHOSTBYNAME:
 *	This symbol, if defined, indicates that the gethostbyname() routine is
 *	available to look up host names in some data base or other.
 */
/*#define HAS_GETHOSTBYNAME		/ **/

/* HAS_GETHOSTENT:
 *	This symbol, if defined, indicates that the gethostent() routine is
 *	available to look up host names in some data base or another.
 */
/*#define HAS_GETHOSTENT		/ **/

/* HAS_GETHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	gethostname() routine to derive the host name.  See also HAS_UNAME
 *	and PHOSTNAME.
 */
/* HAS_UNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and PHOSTNAME.
 */
/* PHOSTNAME:
 *	This symbol, if defined, indicates the command to feed to the
 *	popen() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and HAS_UNAME.	Note that the command uses a fully qualified path,
 *	so that it is safe even if used by a process with super-user
 *	privileges.
 */
/* HAS_PHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	contents of PHOSTNAME as a command to feed to the popen() routine
 *	to derive the host name.
 */
/*#define HAS_GETHOSTNAME	/ **/
/*#define HAS_UNAME		/ **/
/*#define HAS_PHOSTNAME	/ **/
#ifdef HAS_PHOSTNAME
#define PHOSTNAME ""	/* How to get the host name */
#endif

/* HAS_GETHOSTBYADDR_R:
 *	This symbol, if defined, indicates that the gethostbyaddr_r routine
 *	is available to gethostbyaddr re-entrantly.
 */
/* GETHOSTBYADDR_R_PROTO:
 *	This symbol encodes the prototype of gethostbyaddr_r.
 *	It is zero if d_gethostbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyaddr_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYADDR_R	   / **/
#define GETHOSTBYADDR_R_PROTO 0	   /**/

/* HAS_GETHOSTBYNAME_R:
 *	This symbol, if defined, indicates that the gethostbyname_r routine
 *	is available to gethostbyname re-entrantly.
 */
/* GETHOSTBYNAME_R_PROTO:
 *	This symbol encodes the prototype of gethostbyname_r.
 *	It is zero if d_gethostbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostbyname_r
 *	is defined.
 */
/*#define HAS_GETHOSTBYNAME_R	   / **/
#define GETHOSTBYNAME_R_PROTO 0	   /**/

/* HAS_GETHOSTENT_R:
 *	This symbol, if defined, indicates that the gethostent_r routine
 *	is available to gethostent re-entrantly.
 */
/* GETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of gethostent_r.
 *	It is zero if d_gethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gethostent_r
 *	is defined.
 */
/*#define HAS_GETHOSTENT_R	   / **/
#define GETHOSTENT_R_PROTO 0	   /**/

/* HAS_GETHOST_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for gethostent(), gethostbyname(), and
 *	gethostbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETHOST_PROTOS	/ **/

/* HAS_GETITIMER:
 *	This symbol, if defined, indicates that the getitimer routine is
 *	available to return interval timers.
 */
/*#define HAS_GETITIMER		/ **/

/* HAS_GETLOGIN_R:
 *	This symbol, if defined, indicates that the getlogin_r routine
 *	is available to getlogin re-entrantly.
 */
/* GETLOGIN_R_PROTO:
 *	This symbol encodes the prototype of getlogin_r.
 *	It is zero if d_getlogin_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getlogin_r
 *	is defined.
 */
/*#define HAS_GETLOGIN_R	   / **/
#define GETLOGIN_R_PROTO 0	   /**/

/* HAS_GETMNT:
 *	This symbol, if defined, indicates that the getmnt routine is
 *	available to get filesystem mount info by filename.
 */
/*#define HAS_GETMNT		/ **/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to iterate through mounted file systems to get their info.
 */
/*#define HAS_GETMNTENT		/ **/

/* HAS_GETNETBYADDR:
 *	This symbol, if defined, indicates that the getnetbyaddr() routine is
 *	available to look up networks by their IP addresses.
 */
/*#define HAS_GETNETBYADDR		/ **/

/* HAS_GETNETBYNAME:
 *	This symbol, if defined, indicates that the getnetbyname() routine is
 *	available to look up networks by their names.
 */
/*#define HAS_GETNETBYNAME		/ **/

/* HAS_GETNETENT:
 *	This symbol, if defined, indicates that the getnetent() routine is
 *	available to look up network names in some data base or another.
 */
/*#define HAS_GETNETENT		/ **/

/* HAS_GETNETBYADDR_R:
 *	This symbol, if defined, indicates that the getnetbyaddr_r routine
 *	is available to getnetbyaddr re-entrantly.
 */
/* GETNETBYADDR_R_PROTO:
 *	This symbol encodes the prototype of getnetbyaddr_r.
 *	It is zero if d_getnetbyaddr_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyaddr_r
 *	is defined.
 */
/*#define HAS_GETNETBYADDR_R	   / **/
#define GETNETBYADDR_R_PROTO 0	   /**/

/* HAS_GETNETBYNAME_R:
 *	This symbol, if defined, indicates that the getnetbyname_r routine
 *	is available to getnetbyname re-entrantly.
 */
/* GETNETBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getnetbyname_r.
 *	It is zero if d_getnetbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetbyname_r
 *	is defined.
 */
/*#define HAS_GETNETBYNAME_R	   / **/
#define GETNETBYNAME_R_PROTO 0	   /**/

/* HAS_GETNETENT_R:
 *	This symbol, if defined, indicates that the getnetent_r routine
 *	is available to getnetent re-entrantly.
 */
/* GETNETENT_R_PROTO:
 *	This symbol encodes the prototype of getnetent_r.
 *	It is zero if d_getnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getnetent_r
 *	is defined.
 */
/*#define HAS_GETNETENT_R	   / **/
#define GETNETENT_R_PROTO 0	   /**/

/* HAS_GETNET_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getnetent(), getnetbyname(), and
 *	getnetbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETNET_PROTOS	/ **/

/* HAS_GETPAGESIZE:
 *	This symbol, if defined, indicates that the getpagesize system call
 *	is available to get system page size, which is the granularity of
 *	many memory management calls.
 */
/*#define HAS_GETPAGESIZE		/ **/

/* HAS_GETPROTOENT:
 *	This symbol, if defined, indicates that the getprotoent() routine is
 *	available to look up protocols in some data base or another.
 */
/*#define HAS_GETPROTOENT		/ **/

/* HAS_GETPGRP:
 *	This symbol, if defined, indicates that the getpgrp routine is
 *	available to get the current process group.
 */
/* USE_BSD_GETPGRP:
 *	This symbol, if defined, indicates that getpgrp needs one
 *	arguments whereas USG one needs none.
 */
/*#define HAS_GETPGRP		/ **/
/*#define USE_BSD_GETPGRP	/ **/

/* HAS_GETPROTOBYNAME:
 *	This symbol, if defined, indicates that the getprotobyname()
 *	routine is available to look up protocols by their name.
 */
/* HAS_GETPROTOBYNUMBER:
 *	This symbol, if defined, indicates that the getprotobynumber()
 *	routine is available to look up protocols by their number.
 */
/*#define HAS_GETPROTOBYNAME		/ **/
/*#define HAS_GETPROTOBYNUMBER		/ **/

/* HAS_GETPROTOBYNAME_R:
 *	This symbol, if defined, indicates that the getprotobyname_r routine
 *	is available to getprotobyname re-entrantly.
 */
/* GETPROTOBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getprotobyname_r.
 *	It is zero if d_getprotobyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobyname_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNAME_R	   / **/
#define GETPROTOBYNAME_R_PROTO 0	   /**/

/* HAS_GETPROTOBYNUMBER_R:
 *	This symbol, if defined, indicates that the getprotobynumber_r routine
 *	is available to getprotobynumber re-entrantly.
 */
/* GETPROTOBYNUMBER_R_PROTO:
 *	This symbol encodes the prototype of getprotobynumber_r.
 *	It is zero if d_getprotobynumber_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotobynumber_r
 *	is defined.
 */
/*#define HAS_GETPROTOBYNUMBER_R	   / **/
#define GETPROTOBYNUMBER_R_PROTO 0	   /**/

/* HAS_GETPROTOENT_R:
 *	This symbol, if defined, indicates that the getprotoent_r routine
 *	is available to getprotoent re-entrantly.
 */
/* GETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of getprotoent_r.
 *	It is zero if d_getprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getprotoent_r
 *	is defined.
 */
/*#define HAS_GETPROTOENT_R	   / **/
#define GETPROTOENT_R_PROTO 0	   /**/

/* HAS_GETPROTO_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getprotoent(), getprotobyname(), and
 *	getprotobyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETPROTO_PROTOS	/ **/

/* HAS_GETPRPWNAM:
 *	This symbol, if defined, indicates that the getprpwnam system call is
 *	available to retrieve protected (shadow) password entries by name.
 */
/*#define HAS_GETPRPWNAM		/ **/

/* HAS_GETPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for sequential access of the passwd database.
 *	If this is not available, the older getpw() function may be available.
 */
/*#define HAS_GETPWENT		/ **/

/* HAS_GETPWENT_R:
 *	This symbol, if defined, indicates that the getpwent_r routine
 *	is available to getpwent re-entrantly.
 */
/* GETPWENT_R_PROTO:
 *	This symbol encodes the prototype of getpwent_r.
 *	It is zero if d_getpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwent_r
 *	is defined.
 */
/*#define HAS_GETPWENT_R	   / **/
#define GETPWENT_R_PROTO 0	   /**/

/* HAS_GETPWNAM_R:
 *	This symbol, if defined, indicates that the getpwnam_r routine
 *	is available to getpwnam re-entrantly.
 */
/* GETPWNAM_R_PROTO:
 *	This symbol encodes the prototype of getpwnam_r.
 *	It is zero if d_getpwnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwnam_r
 *	is defined.
 */
/*#define HAS_GETPWNAM_R	   / **/
#define GETPWNAM_R_PROTO 0	   /**/

/* HAS_GETPWUID_R:
 *	This symbol, if defined, indicates that the getpwuid_r routine
 *	is available to getpwuid re-entrantly.
 */
/* GETPWUID_R_PROTO:
 *	This symbol encodes the prototype of getpwuid_r.
 *	It is zero if d_getpwuid_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getpwuid_r
 *	is defined.
 */
/*#define HAS_GETPWUID_R	   / **/
#define GETPWUID_R_PROTO 0	   /**/

/* HAS_GETSERVENT:
 *	This symbol, if defined, indicates that the getservent() routine is
 *	available to look up network services in some data base or another.
 */
/*#define HAS_GETSERVENT		/ **/

/* HAS_GETSERVBYNAME_R:
 *	This symbol, if defined, indicates that the getservbyname_r routine
 *	is available to getservbyname re-entrantly.
 */
/* GETSERVBYNAME_R_PROTO:
 *	This symbol encodes the prototype of getservbyname_r.
 *	It is zero if d_getservbyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyname_r
 *	is defined.
 */
/*#define HAS_GETSERVBYNAME_R	   / **/
#define GETSERVBYNAME_R_PROTO 0	   /**/

/* HAS_GETSERVBYPORT_R:
 *	This symbol, if defined, indicates that the getservbyport_r routine
 *	is available to getservbyport re-entrantly.
 */
/* GETSERVBYPORT_R_PROTO:
 *	This symbol encodes the prototype of getservbyport_r.
 *	It is zero if d_getservbyport_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservbyport_r
 *	is defined.
 */
/*#define HAS_GETSERVBYPORT_R	   / **/
#define GETSERVBYPORT_R_PROTO 0	   /**/

/* HAS_GETSERVENT_R:
 *	This symbol, if defined, indicates that the getservent_r routine
 *	is available to getservent re-entrantly.
 */
/* GETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of getservent_r.
 *	It is zero if d_getservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getservent_r
 *	is defined.
 */
/*#define HAS_GETSERVENT_R	   / **/
#define GETSERVENT_R_PROTO 0	   /**/

/* HAS_GETSERV_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getservent(), getservbyname(), and
 *	getservbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETSERV_PROTOS	/ **/

/* HAS_GETSPNAM:
 *	This symbol, if defined, indicates that the getspnam system call is
 *	available to retrieve SysV shadow password entries by name.
 */
/*#define HAS_GETSPNAM		/ **/

/* HAS_GETSPNAM_R:
 *	This symbol, if defined, indicates that the getspnam_r routine
 *	is available to getspnam re-entrantly.
 */
/* GETSPNAM_R_PROTO:
 *	This symbol encodes the prototype of getspnam_r.
 *	It is zero if d_getspnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_getspnam_r
 *	is defined.
 */
/*#define HAS_GETSPNAM_R	   / **/
#define GETSPNAM_R_PROTO 0	   /**/

/* HAS_GETSERVBYNAME:
 *	This symbol, if defined, indicates that the getservbyname()
 *	routine is available to look up services by their name.
 */
/* HAS_GETSERVBYPORT:
 *	This symbol, if defined, indicates that the getservbyport()
 *	routine is available to look up services by their port.
 */
/*#define HAS_GETSERVBYNAME		/ **/
/*#define HAS_GETSERVBYPORT		/ **/

/* HAS_GMTIME_R:
 *	This symbol, if defined, indicates that the gmtime_r routine
 *	is available to gmtime re-entrantly.
 */
/* GMTIME_R_PROTO:
 *	This symbol encodes the prototype of gmtime_r.
 *	It is zero if d_gmtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_gmtime_r
 *	is defined.
 */
/*#define HAS_GMTIME_R	   / **/
#define GMTIME_R_PROTO 0	   /**/

/* HAS_GNULIBC:
 *	This symbol, if defined, indicates to the C program that 
 *	the GNU C library is being used.  A better check is to use
 *	the __GLIBC__ and __GLIBC_MINOR__ symbols supplied with glibc.
 */
/*#define HAS_GNULIBC  	/ **/
#if defined(HAS_GNULIBC) && !defined(_GNU_SOURCE)
#   define _GNU_SOURCE
#endif
/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query the mount options of file systems.
 */
/*#define HAS_HASMNTOPT		/ **/

/* HAS_HTONL:
 *	This symbol, if defined, indicates that the htonl() routine (and
 *	friends htons() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_HTONS:
 *	This symbol, if defined, indicates that the htons() routine (and
 *	friends htonl() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHL:
 *	This symbol, if defined, indicates that the ntohl() routine (and
 *	friends htonl() htons() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHS:
 *	This symbol, if defined, indicates that the ntohs() routine (and
 *	friends htonl() htons() ntohl()) are available to do network
 *	order byte swapping.
 */
/*#define HAS_HTONL		/ **/
/*#define HAS_HTONS		/ **/
/*#define HAS_NTOHL		/ **/
/*#define HAS_NTOHS		/ **/

/* HAS_ILOGBL:
 *	This symbol, if defined, indicates that the ilogbl routine is
 *	available.  If scalbnl is also present we can emulate frexpl.
 */
/*#define HAS_ILOGBL		/ **/

/* HAS_INT64_T:
 *     This symbol will defined if the C compiler supports int64_t.
 *     Usually the <inttypes.h> needs to be included, but sometimes
 *	<sys/types.h> is enough.
 */
/*#define     HAS_INT64_T               / **/

/* HAS_ISASCII:
 *	This manifest constant lets the C program know that isascii 
 *	is available.
 */
/*#define HAS_ISASCII		/ **/

/* HAS_ISFINITE:
 *	This symbol, if defined, indicates that the isfinite routine is
 *	available to check whether a double is finite (non-infinity non-NaN).
 */
/*#define HAS_ISFINITE		/ **/

/* HAS_ISINF:
 *	This symbol, if defined, indicates that the isinf routine is
 *	available to check whether a double is an infinity.
 */
/*#define HAS_ISINF		/ **/

/* HAS_ISNAN:
 *	This symbol, if defined, indicates that the isnan routine is
 *	available to check whether a double is a NaN.
 */
/*#define HAS_ISNAN		/ **/

/* HAS_ISNANL:
 *	This symbol, if defined, indicates that the isnanl routine is
 *	available to check whether a long double is a NaN.
 */
/*#define HAS_ISNANL		/ **/

/* HAS_LCHOWN:
 *	This symbol, if defined, indicates that the lchown routine is
 *	available to operate on a symbolic link (instead of following the
 *	link).
 */
/*#define HAS_LCHOWN		/ **/

/* HAS_LDBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol LDBL_DIG, which is the number
 *	of significant digits in a long double precision number. Unlike
 *	for DBL_DIG, there's no good guess for LDBL_DIG if it is undefined.
 */
/*#define HAS_LDBL_DIG 	/ * */

/* LIBM_LIB_VERSION:
 *	This symbol, if defined, indicates that libm exports _LIB_VERSION
 *	and that math.h defines the enum to manipulate it.
 */
/*#define LIBM_LIB_VERSION		/ **/

/* HAS_LOCALTIME_R:
 *	This symbol, if defined, indicates that the localtime_r routine
 *	is available to localtime re-entrantly.
 */
/* LOCALTIME_R_NEEDS_TZSET:
 *	Many libc's localtime_r implementations do not call tzset,
 *	making them differ from localtime(), and making timezone
 *	changes using $ENV{TZ} without explicitly calling tzset
 *	impossible. This symbol makes us call tzset before localtime_r
 */
/* LOCALTIME_R_PROTO:
 *	This symbol encodes the prototype of localtime_r.
 *	It is zero if d_localtime_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_localtime_r
 *	is defined.
 */
/*#define HAS_LOCALTIME_R	   / **/
/*#define LOCALTIME_R_NEEDS_TZSET	   / **/
#define LOCALTIME_R_PROTO 0	   /**/

/* HAS_LONG_DOUBLE:
 *	This symbol will be defined if the C compiler supports long
 *	doubles.
 */
/* LONG_DOUBLESIZE:
 *	This symbol contains the size of a long double, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long doubles.
 */
/*#define HAS_LONG_DOUBLE		/ **/
#ifdef HAS_LONG_DOUBLE
#define LONG_DOUBLESIZE 8		/**/
#endif

/* HAS_LONG_LONG:
 *	This symbol will be defined if the C compiler supports long long.
 */
/* LONGLONGSIZE:
 *	This symbol contains the size of a long long, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long long.
 */
/*#define HAS_LONG_LONG		/ **/
#ifdef HAS_LONG_LONG
#define LONGLONGSIZE 8		/**/
#endif

/* HAS_LSEEK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the lseek() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern off_t lseek(int, off_t, int);
 */
/*#define	HAS_LSEEK_PROTO	/ **/

/* HAS_MADVISE:
 *	This symbol, if defined, indicates that the madvise system call is
 *	available to map a file into memory.
 */
/*#define HAS_MADVISE		/ **/

/* HAS_MALLOC_SIZE:
 *	This symbol, if defined, indicates that the malloc_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_SIZE		/ **/

/* HAS_MALLOC_GOOD_SIZE:
 *	This symbol, if defined, indicates that the malloc_good_size
 *	routine is available for use.
 */
/*#define HAS_MALLOC_GOOD_SIZE	/ **/

/* HAS_MEMCHR:
 *	This symbol, if defined, indicates that the memchr routine is available
 *	to locate characters within a C string.
 */
#define HAS_MEMCHR	/**/

/* HAS_MKDTEMP:
 *	This symbol, if defined, indicates that the mkdtemp routine is
 *	available to exclusively create a uniquely named temporary directory.
 */
/*#define HAS_MKDTEMP		/ **/

/* HAS_MKSTEMP:
 *	This symbol, if defined, indicates that the mkstemp routine is
 *	available to exclusively create and open a uniquely named
 *	temporary file.
 */
/*#define HAS_MKSTEMP		/ **/

/* HAS_MKSTEMPS:
 *	This symbol, if defined, indicates that the mkstemps routine is
 *	available to excluslvely create and open a uniquely named
 *	(with a suffix) temporary file.
 */
/*#define HAS_MKSTEMPS		/ **/

/* HAS_MMAP:
 *	This symbol, if defined, indicates that the mmap system call is
 *	available to map a file into memory.
 */
/* Mmap_t:
 *	This symbol holds the return type of the mmap() system call
 *	(and simultaneously the type of the first argument).
 *	Usually set to 'void *' or 'cadd_t'.
 */
/*#define HAS_MMAP		/ **/
#define Mmap_t 	/**/

/* HAS_MODFL:
 *	This symbol, if defined, indicates that the modfl routine is
 *	available to split a long double x into a fractional part f and
 *	an integer part i such that |f| < 1.0 and (f + i) = x.
 */
/* HAS_MODFL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the modfl() function.  Otherwise, it is up
 *	to the program to supply one.
 */
/* HAS_MODFL_POW32_BUG:
 *	This symbol, if defined, indicates that the modfl routine is
 *	broken for long doubles >= pow(2, 32).
 *	For example from 4294967303.150000 one would get 4294967302.000000
 *	and 1.150000.  The bug has been seen in certain versions of glibc,
 *	release 2.2.2 is known to be okay.
 */
/*#define HAS_MODFL		/ **/
/*#define HAS_MODFL_PROTO		/ **/
/*#define HAS_MODFL_POW32_BUG		/ **/

/* HAS_MPROTECT:
 *	This symbol, if defined, indicates that the mprotect system call is
 *	available to modify the access protection of a memory mapped file.
 */
/*#define HAS_MPROTECT		/ **/

/* HAS_MSG:
 *	This symbol, if defined, indicates that the entire msg*(2) library is
 *	supported (IPC mechanism based on message queues).
 */
/*#define HAS_MSG		/ **/

/* HAS_STRUCT_MSGHDR:
 *	This symbol, if defined, indicates that the struct msghdr
 *	is supported.
 */
/*#define HAS_STRUCT_MSGHDR	/ **/

/* HAS_NL_LANGINFO:
 *	This symbol, if defined, indicates that the nl_langinfo routine is
 *	available to return local data.  You will also need <langinfo.h>
 *	and therefore I_LANGINFO.
 */
/*#define HAS_NL_LANGINFO		/ **/

/* HAS_OFF64_T:
 *	This symbol will be defined if the C compiler supports off64_t.
 */
/*#define	HAS_OFF64_T    		/ **/

/* HAS_OPEN3:
 *	This manifest constant lets the C program know that the three
 *	argument form of open(2) is available.
 */
/*#define HAS_OPEN3		/ **/

/* HAS_PROCSELFEXE:
 *	This symbol is defined if PROCSELFEXE_PATH is a symlink
 *	to the absolute pathname of the executing program.
 */
/* PROCSELFEXE_PATH:
 *	If HAS_PROCSELFEXE is defined this symbol is the filename
 *	of the symbolic link pointing to the absolute pathname of
 *	the executing program.
 */
/*#define HAS_PROCSELFEXE	/ **/
#if defined(HAS_PROCSELFEXE) && !defined(PROCSELFEXE_PATH)
#define PROCSELFEXE_PATH		/**/
#endif

/* OLD_PTHREAD_CREATE_JOINABLE:
 *	This symbol, if defined, indicates how to create pthread
 *	in joinable (aka undetached) state.  NOTE: not defined
 *	if pthread.h already has defined PTHREAD_CREATE_JOINABLE
 *	(the new version of the constant).
 *	If defined, known values are PTHREAD_CREATE_UNDETACHED
 *	and __UNDETACHED.
 */
/*#define OLD_PTHREAD_CREATE_JOINABLE  / **/

/* HAS_PTHREAD_ATFORK:
 *	This symbol, if defined, indicates that the pthread_atfork routine
 *	is available to setup fork handlers.
 */
/*#define HAS_PTHREAD_ATFORK		/ **/

/* HAS_PTHREAD_ATTR_SETSCOPE:
 *	This symbol, if defined, indicates that the pthread_attr_setscope
 *	system call is available to set the contention scope attribute of
 *	a thread attribute object.
 */
/*#define HAS_PTHREAD_ATTR_SETSCOPE		/ **/

/* HAS_PTHREAD_YIELD:
 *	This symbol, if defined, indicates that the pthread_yield 
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/* SCHED_YIELD:
 *	This symbol defines the way to yield the execution of
 *	the current thread.  Known ways are sched_yield,
 *	pthread_yield, and pthread_yield with NULL.
 */
/* HAS_SCHED_YIELD:
 *	This symbol, if defined, indicates that the sched_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/*#define HAS_PTHREAD_YIELD	/ **/
#define SCHED_YIELD	sched_yield()	/**/
/*#define HAS_SCHED_YIELD	/ **/

/* HAS_RANDOM_R:
 *	This symbol, if defined, indicates that the random_r routine
 *	is available to random re-entrantly.
 */
/* RANDOM_R_PROTO:
 *	This symbol encodes the prototype of random_r.
 *	It is zero if d_random_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_random_r
 *	is defined.
 */
/*#define HAS_RANDOM_R	   / **/
#define RANDOM_R_PROTO 0	   /**/

/* HAS_READDIR64_R:
 *	This symbol, if defined, indicates that the readdir64_r routine
 *	is available to readdir64 re-entrantly.
 */
/* READDIR64_R_PROTO:
 *	This symbol encodes the prototype of readdir64_r.
 *	It is zero if d_readdir64_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir64_r
 *	is defined.
 */
/*#define HAS_READDIR64_R	   / **/
#define READDIR64_R_PROTO 0	   /**/

/* HAS_READDIR_R:
 *	This symbol, if defined, indicates that the readdir_r routine
 *	is available to readdir re-entrantly.
 */
/* READDIR_R_PROTO:
 *	This symbol encodes the prototype of readdir_r.
 *	It is zero if d_readdir_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_readdir_r
 *	is defined.
 */
/*#define HAS_READDIR_R	   / **/
#define READDIR_R_PROTO 0	   /**/

/* HAS_READV:
 *	This symbol, if defined, indicates that the readv routine is
 *	available to do gather reads.  You will also need <sys/uio.h>
 *	and there I_SYSUIO.
 */
/*#define HAS_READV		/ **/

/* HAS_RECVMSG:
 *	This symbol, if defined, indicates that the recvmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_RECVMSG		/ **/

/* HAS_SAFE_BCOPY:
 *	This symbol, if defined, indicates that the bcopy routine is available
 *	to copy potentially overlapping memory blocks. Normally, you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_BCOPY	/ **/

/* HAS_SAFE_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy potentially overlapping memory blocks.  If you need to
 *	copy overlapping memory blocks, you should check HAS_MEMMOVE and
 *	use memmove() instead, if available.
 */
/*#define HAS_SAFE_MEMCPY	/ **/

/* HAS_SANE_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	and can be used to compare relative magnitudes of chars with their high
 *	bits set.  If it is not defined, roll your own version.
 */
/*#define HAS_SANE_MEMCMP	/ **/

/* HAS_SBRK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sbrk() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern void* sbrk(int);
 *		extern void* sbrk(size_t);
 */
/*#define	HAS_SBRK_PROTO	/ **/

/* HAS_SCALBNL:
 *	This symbol, if defined, indicates that the scalbnl routine is
 *	available.  If ilogbl is also present we can emulate frexpl.
 */
/*#define HAS_SCALBNL		/ **/

/* HAS_SEM:
 *	This symbol, if defined, indicates that the entire sem*(2) library is
 *	supported.
 */
/*#define HAS_SEM		/ **/

/* HAS_SENDMSG:
 *	This symbol, if defined, indicates that the sendmsg routine is
 *	available to send structured socket messages.
 */
/*#define HAS_SENDMSG		/ **/

/* HAS_SETGRENT:
 *	This symbol, if defined, indicates that the setgrent routine is
 *	available for initializing sequential access of the group database.
 */
/*#define HAS_SETGRENT		/ **/

/* HAS_SETGRENT_R:
 *	This symbol, if defined, indicates that the setgrent_r routine
 *	is available to setgrent re-entrantly.
 */
/* SETGRENT_R_PROTO:
 *	This symbol encodes the prototype of setgrent_r.
 *	It is zero if d_setgrent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setgrent_r
 *	is defined.
 */
/*#define HAS_SETGRENT_R	   / **/
#define SETGRENT_R_PROTO 0	   /**/

/* HAS_SETGROUPS:
 *	This symbol, if defined, indicates that the setgroups() routine is
 *	available to set the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_SETGROUPS		/ **/

/* HAS_SETHOSTENT:
 *	This symbol, if defined, indicates that the sethostent() routine is
 *	available.
 */
/*#define HAS_SETHOSTENT		/ **/

/* HAS_SETHOSTENT_R:
 *	This symbol, if defined, indicates that the sethostent_r routine
 *	is available to sethostent re-entrantly.
 */
/* SETHOSTENT_R_PROTO:
 *	This symbol encodes the prototype of sethostent_r.
 *	It is zero if d_sethostent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_sethostent_r
 *	is defined.
 */
/*#define HAS_SETHOSTENT_R	   / **/
#define SETHOSTENT_R_PROTO 0	   /**/

/* HAS_SETITIMER:
 *	This symbol, if defined, indicates that the setitimer routine is
 *	available to set interval timers.
 */
/*#define HAS_SETITIMER		/ **/

/* HAS_SETLOCALE_R:
 *	This symbol, if defined, indicates that the setlocale_r routine
 *	is available to setlocale re-entrantly.
 */
/* SETLOCALE_R_PROTO:
 *	This symbol encodes the prototype of setlocale_r.
 *	It is zero if d_setlocale_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setlocale_r
 *	is defined.
 */
/*#define HAS_SETLOCALE_R	   / **/
#define SETLOCALE_R_PROTO 0	   /**/

/* HAS_SETNETENT:
 *	This symbol, if defined, indicates that the setnetent() routine is
 *	available.
 */
/*#define HAS_SETNETENT		/ **/

/* HAS_SETNETENT_R:
 *	This symbol, if defined, indicates that the setnetent_r routine
 *	is available to setnetent re-entrantly.
 */
/* SETNETENT_R_PROTO:
 *	This symbol encodes the prototype of setnetent_r.
 *	It is zero if d_setnetent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setnetent_r
 *	is defined.
 */
/*#define HAS_SETNETENT_R	   / **/
#define SETNETENT_R_PROTO 0	   /**/

/* HAS_SETPROTOENT:
 *	This symbol, if defined, indicates that the setprotoent() routine is
 *	available.
 */
/*#define HAS_SETPROTOENT		/ **/

/* HAS_SETPGRP:
 *	This symbol, if defined, indicates that the setpgrp routine is
 *	available to set the current process group.
 */
/* USE_BSD_SETPGRP:
 *	This symbol, if defined, indicates that setpgrp needs two
 *	arguments whereas USG one needs none.  See also HAS_SETPGID
 *	for a POSIX interface.
 */
/*#define HAS_SETPGRP		/ **/
/*#define USE_BSD_SETPGRP	/ **/

/* HAS_SETPROCTITLE:
 *	This symbol, if defined, indicates that the setproctitle routine is
 *	available to set process title.
 */
/*#define HAS_SETPROCTITLE		/ **/

/* HAS_SETPROTOENT_R:
 *	This symbol, if defined, indicates that the setprotoent_r routine
 *	is available to setprotoent re-entrantly.
 */
/* SETPROTOENT_R_PROTO:
 *	This symbol encodes the prototype of setprotoent_r.
 *	It is zero if d_setprotoent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setprotoent_r
 *	is defined.
 */
/*#define HAS_SETPROTOENT_R	   / **/
#define SETPROTOENT_R_PROTO 0	   /**/

/* HAS_SETPWENT:
 *	This symbol, if defined, indicates that the setpwent routine is
 *	available for initializing sequential access of the passwd database.
 */
/*#define HAS_SETPWENT		/ **/

/* HAS_SETPWENT_R:
 *	This symbol, if defined, indicates that the setpwent_r routine
 *	is available to setpwent re-entrantly.
 */
/* SETPWENT_R_PROTO:
 *	This symbol encodes the prototype of setpwent_r.
 *	It is zero if d_setpwent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setpwent_r
 *	is defined.
 */
/*#define HAS_SETPWENT_R	   / **/
#define SETPWENT_R_PROTO 0	   /**/

/* HAS_SETSERVENT:
 *	This symbol, if defined, indicates that the setservent() routine is
 *	available.
 */
/*#define HAS_SETSERVENT		/ **/

/* HAS_SETSERVENT_R:
 *	This symbol, if defined, indicates that the setservent_r routine
 *	is available to setservent re-entrantly.
 */
/* SETSERVENT_R_PROTO:
 *	This symbol encodes the prototype of setservent_r.
 *	It is zero if d_setservent_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_setservent_r
 *	is defined.
 */
/*#define HAS_SETSERVENT_R	   / **/
#define SETSERVENT_R_PROTO 0	   /**/

/* HAS_SETVBUF:
 *	This symbol, if defined, indicates that the setvbuf routine is
 *	available to change buffering on an open stdio stream.
 *	to a line-buffered mode.
 */
/*#define HAS_SETVBUF		/ **/

/* USE_SFIO:
 *	This symbol, if defined, indicates that sfio should
 *	be used.
 */
/*#define	USE_SFIO		/ **/

/* HAS_SHM:
 *	This symbol, if defined, indicates that the entire shm*(2) library is
 *	supported.
 */
/*#define HAS_SHM		/ **/

/* Shmat_t:
 *	This symbol holds the return type of the shmat() system call.
 *	Usually set to 'void *' or 'char *'.
 */
/* HAS_SHMAT_PROTOTYPE:
 *	This symbol, if defined, indicates that the sys/shm.h includes
 *	a prototype for shmat().  Otherwise, it is up to the program to
 *	guess one.  Shmat_t shmat(int, Shmat_t, int) is a good guess,
 *	but not always right so it should be emitted by the program only
 *	when HAS_SHMAT_PROTOTYPE is not defined to avoid conflicting defs.
 */
#define Shmat_t void *	/**/
/*#define HAS_SHMAT_PROTOTYPE	/ **/

/* HAS_SIGACTION:
 *	This symbol, if defined, indicates that Vr4's sigaction() routine
 *	is available.
 */
/*#define HAS_SIGACTION	/ **/

/* HAS_SIGPROCMASK:
 *	This symbol, if defined, indicates that the sigprocmask
 *	system call is available to examine or change the signal mask
 *	of the calling process.
 */
/*#define HAS_SIGPROCMASK		/ **/

/* HAS_SIGSETJMP:
 *	This variable indicates to the C program that the sigsetjmp()
 *	routine is available to save the calling process's registers
 *	and stack environment for later use by siglongjmp(), and
 *	to optionally save the process's signal mask.  See
 *	Sigjmp_buf, Sigsetjmp, and Siglongjmp.
 */
/* Sigjmp_buf:
 *	This is the buffer type to be used with Sigsetjmp and Siglongjmp.
 */
/* Sigsetjmp:
 *	This macro is used in the same way as sigsetjmp(), but will invoke
 *	traditional setjmp() if sigsetjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/* Siglongjmp:
 *	This macro is used in the same way as siglongjmp(), but will invoke
 *	traditional longjmp() if siglongjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/*#define HAS_SIGSETJMP	/ **/
#ifdef HAS_SIGSETJMP
#define Sigjmp_buf sigjmp_buf
#define Sigsetjmp(buf,save_mask) sigsetjmp((buf),(save_mask))
#define Siglongjmp(buf,retval) siglongjmp((buf),(retval))
#else
#define Sigjmp_buf jmp_buf
#define Sigsetjmp(buf,save_mask) setjmp((buf))
#define Siglongjmp(buf,retval) longjmp((buf),(retval))
#endif

/* USE_SITECUSTOMIZE:
 *	This symbol, if defined, indicates that sitecustomize should
 *	be used.
 */
#ifndef USE_SITECUSTOMIZE
/*#define	USE_SITECUSTOMIZE		/ **/
#endif

/* HAS_SNPRINTF:
 *	This symbol, if defined, indicates that the snprintf () library
 *	function is available for use.
 */
/* HAS_VSNPRINTF:
 *	This symbol, if defined, indicates that the vsnprintf () library
 *	function is available for use.
 */
/*#define HAS_SNPRINTF	/ **/
/*#define HAS_VSNPRINTF	/ **/

/* HAS_SOCKATMARK:
 *	This symbol, if defined, indicates that the sockatmark routine is
 *	available to test whether a socket is at the out-of-band mark.
 */
/*#define HAS_SOCKATMARK		/ **/

/* HAS_SOCKATMARK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sockatmark() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int sockatmark(int);
 */
/*#define	HAS_SOCKATMARK_PROTO	/ **/

/* HAS_SOCKET:
 *	This symbol, if defined, indicates that the BSD socket interface is
 *	supported.
 */
/* HAS_SOCKETPAIR:
 *	This symbol, if defined, indicates that the BSD socketpair() call is
 *	supported.
 */
/* HAS_MSG_CTRUNC:
 *	This symbol, if defined, indicates that the MSG_CTRUNC is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_DONTROUTE:
 *	This symbol, if defined, indicates that the MSG_DONTROUTE is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_OOB:
 *	This symbol, if defined, indicates that the MSG_OOB is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PEEK:
 *	This symbol, if defined, indicates that the MSG_PEEK is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PROXY:
 *	This symbol, if defined, indicates that the MSG_PROXY is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_SCM_RIGHTS:
 *	This symbol, if defined, indicates that the SCM_RIGHTS is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/*#define	HAS_SOCKET		/ **/
/*#define	HAS_SOCKETPAIR	/ **/
/*#define	HAS_MSG_CTRUNC	/ **/
/*#define	HAS_MSG_DONTROUTE	/ **/
/*#define	HAS_MSG_OOB	/ **/
/*#define	HAS_MSG_PEEK	/ **/
/*#define	HAS_MSG_PROXY	/ **/
/*#define	HAS_SCM_RIGHTS	/ **/

/* HAS_SOCKS5_INIT:
 *	This symbol, if defined, indicates that the socks5_init routine is
 *	available to initialize SOCKS 5.
 */
/*#define HAS_SOCKS5_INIT		/ **/

/* SPRINTF_RETURNS_STRLEN:
 *	This variable defines whether sprintf returns the length of the string
 *	(as per the ANSI spec). Some C libraries retain compatibility with
 *	pre-ANSI C and return a pointer to the passed in buffer; for these
 *	this variable will be undef.
 */
/*#define SPRINTF_RETURNS_STRLEN	/ **/

/* HAS_SQRTL:
 *	This symbol, if defined, indicates that the sqrtl routine is
 *	available to do long double square roots.
 */
/*#define HAS_SQRTL		/ **/

/* HAS_SRAND48_R:
 *	This symbol, if defined, indicates that the srand48_r routine
 *	is available to srand48 re-entrantly.
 */
/* SRAND48_R_PROTO:
 *	This symbol encodes the prototype of srand48_r.
 *	It is zero if d_srand48_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srand48_r
 *	is defined.
 */
/*#define HAS_SRAND48_R	   / **/
#define SRAND48_R_PROTO 0	   /**/

/* HAS_SRANDOM_R:
 *	This symbol, if defined, indicates that the srandom_r routine
 *	is available to srandom re-entrantly.
 */
/* SRANDOM_R_PROTO:
 *	This symbol encodes the prototype of srandom_r.
 *	It is zero if d_srandom_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_srandom_r
 *	is defined.
 */
/*#define HAS_SRANDOM_R	   / **/
#define SRANDOM_R_PROTO 0	   /**/

/* HAS_SETRESGID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresgid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESGID_PROTO	/ **/

/* HAS_SETRESUID_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the setresuid() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);
 */
/*#define	HAS_SETRESUID_PROTO	/ **/

/* USE_STAT_BLOCKS:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_blksize and st_blocks.
 */
#ifndef USE_STAT_BLOCKS
/*#define USE_STAT_BLOCKS 	/ **/
#endif

/* HAS_STRUCT_STATFS_F_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs
 *	does have the f_flags member containing the mount flags of
 *	the filesystem containing the file.
 *	This kind of struct statfs is coming from <sys/mount.h> (BSD 4.3),
 *	not from <sys/statfs.h> (SYSV).  Older BSDs (like Ultrix) do not
 *	have statfs() and struct statfs, they have ustat() and getmnt()
 *	with struct ustat and struct fs_data.
 */
/*#define HAS_STRUCT_STATFS_F_FLAGS		/ **/

/* HAS_STRUCT_STATFS:
 *	This symbol, if defined, indicates that the struct statfs
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_STATFS	/ **/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATVFS		/ **/

/* USE_STDIO_PTR:
 *	This symbol is defined if the _ptr and _cnt fields (or similar)
 *	of the stdio FILE structure can be used to access the stdio buffer
 *	for a file handle.  If this is defined, then the FILE_ptr(fp)
 *	and FILE_cnt(fp) macros will also be defined and should be used
 *	to access these fields.
 */
/* FILE_ptr:
 *	This macro is used to access the _ptr field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_PTR_LVALUE:
 *	This symbol is defined if the FILE_ptr macro can be used as an
 *	lvalue.
 */
/* FILE_cnt:
 *	This macro is used to access the _cnt field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_CNT_LVALUE:
 *	This symbol is defined if the FILE_cnt macro can be used as an
 *	lvalue.
 */
/* STDIO_PTR_LVAL_SETS_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n has the side effect of decreasing the
 *	value of File_cnt(fp) by n.
 */
/* STDIO_PTR_LVAL_NOCHANGE_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n leaves File_cnt(fp) unchanged.
 */
/*#define USE_STDIO_PTR 	/ **/
#ifdef USE_STDIO_PTR
#define FILE_ptr(fp)	((fp)->_IO_read_ptr)
/*#define STDIO_PTR_LVALUE 		/ **/
#define FILE_cnt(fp)	((fp)->_IO_read_end - (fp)->_IO_read_ptr)
/*#define STDIO_CNT_LVALUE 		/ **/
/*#define STDIO_PTR_LVAL_SETS_CNT	/ **/
/*#define STDIO_PTR_LVAL_NOCHANGE_CNT	/ **/
#endif

/* USE_STDIO_BASE:
 *	This symbol is defined if the _base field (or similar) of the
 *	stdio FILE structure can be used to access the stdio buffer for
 *	a file handle.  If this is defined, then the FILE_base(fp) macro
 *	will also be defined and should be used to access this field.
 *	Also, the FILE_bufsiz(fp) macro will be defined and should be used
 *	to determine the number of bytes in the buffer.  USE_STDIO_BASE
 *	will never be defined unless USE_STDIO_PTR is.
 */
/* FILE_base:
 *	This macro is used to access the _base field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_BASE is defined.
 */
/* FILE_bufsiz:
 *	This macro is used to determine the number of bytes in the I/O
 *	buffer pointed to by _base field (or equivalent) of the FILE
 *	structure pointed to its argument. This macro will always be defined
 *	if USE_STDIO_BASE is defined.
 */
/*#define USE_STDIO_BASE 	/ **/
#ifdef USE_STDIO_BASE
#define FILE_base(fp)	((fp)->_IO_read_base)
#define FILE_bufsiz(fp)	((fp)->_IO_read_end - (fp)->_IO_read_base)
#endif

/* HAS_STRERROR:
 *	This symbol, if defined, indicates that the strerror routine is
 *	available to translate error numbers to strings. See the writeup
 *	of Strerror() in this file before you try to define your own.
 */
/* HAS_SYS_ERRLIST:
 *	This symbol, if defined, indicates that the sys_errlist array is
 *	available to translate error numbers to strings. The extern int
 *	sys_nerr gives the size of that table.
 */
/* Strerror:
 *	This preprocessor symbol is defined as a macro if strerror() is
 *	not available to translate error numbers to strings but sys_errlist[]
 *	array is there.
 */
/*#define HAS_STRERROR		/ **/
/*#define HAS_SYS_ERRLIST	/ **/
#define Strerror(e) strerror(e)

/* HAS_STRERROR_R:
 *	This symbol, if defined, indicates that the strerror_r routine
 *	is available to strerror re-entrantly.
 */
/* STRERROR_R_PROTO:
 *	This symbol encodes the prototype of strerror_r.
 *	It is zero if d_strerror_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_strerror_r
 *	is defined.
 */
/*#define HAS_STRERROR_R	   / **/
#define STRERROR_R_PROTO 0	   /**/

/* HAS_STRFTIME:
 *	This symbol, if defined, indicates that the strftime routine is
 *	available to do time formatting.
 */
/*#define HAS_STRFTIME		/ **/

/* HAS_STRLCAT:
 *	This symbol, if defined, indicates that the strlcat () routine is
 *	available to do string concatenation.
 */
/*#define HAS_STRLCAT		/ **/

/* HAS_STRLCPY:
 *	This symbol, if defined, indicates that the strlcpy () routine is
 *	available to do string copying.
 */
/*#define HAS_STRLCPY		/ **/

/* HAS_STRTOLD:
 *	This symbol, if defined, indicates that the strtold routine is
 *	available to convert strings to long doubles.
 */
/*#define HAS_STRTOLD		/ **/

/* HAS_STRTOLL:
 *	This symbol, if defined, indicates that the strtoll routine is
 *	available to convert strings to long longs.
 */
/*#define HAS_STRTOLL		/ **/

/* HAS_STRTOQ:
 *	This symbol, if defined, indicates that the strtoq routine is
 *	available to convert strings to long longs (quads).
 */
/*#define HAS_STRTOQ		/ **/

/* HAS_STRTOUL:
 *	This symbol, if defined, indicates that the strtoul routine is
 *	available to provide conversion of strings to unsigned long.
 */
#define HAS_STRTOUL	/**/

/* HAS_STRTOULL:
 *	This symbol, if defined, indicates that the strtoull routine is
 *	available to convert strings to unsigned long longs.
 */
/*#define HAS_STRTOULL		/ **/

/* HAS_STRTOUQ:
 *	This symbol, if defined, indicates that the strtouq routine is
 *	available to convert strings to unsigned long longs (quads).
 */
/*#define HAS_STRTOUQ		/ **/

/* HAS_SYSCALL_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the syscall() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern int syscall(int,  ...);
 *		extern int syscall(long, ...);
 */
/*#define	HAS_SYSCALL_PROTO	/ **/

/* HAS_TELLDIR_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the telldir() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern long telldir(DIR*);
 */
/*#define	HAS_TELLDIR_PROTO	/ **/

/* HAS_TIME:
 *	This symbol, if defined, indicates that the time() routine exists.
 */
/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define HAS_TIME		/**/
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 * use getrusage(). It may be necessary to include <sys/times.h>.
 */
/*#define HAS_TIMES		/ **/

/* HAS_TMPNAM_R:
 *	This symbol, if defined, indicates that the tmpnam_r routine
 *	is available to tmpnam re-entrantly.
 */
/* TMPNAM_R_PROTO:
 *	This symbol encodes the prototype of tmpnam_r.
 *	It is zero if d_tmpnam_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_tmpnam_r
 *	is defined.
 */
/*#define HAS_TMPNAM_R	   / **/
#define TMPNAM_R_PROTO 0	   /**/

/* HAS_TTYNAME_R:
 *	This symbol, if defined, indicates that the ttyname_r routine
 *	is available to ttyname re-entrantly.
 */
/* TTYNAME_R_PROTO:
 *	This symbol encodes the prototype of ttyname_r.
 *	It is zero if d_ttyname_r is undef, and one of the
 *	REENTRANT_PROTO_T_ABC macros of reentr.h if d_ttyname_r
 *	is defined.
 */
/*#define HAS_TTYNAME_R	   / **/
#define TTYNAME_R_PROTO 0	   /**/

/* U32_ALIGNMENT_REQUIRED:
 *	This symbol, if defined, indicates that you must access
 *	character data through U32-aligned pointers.
 */
#ifndef U32_ALIGNMENT_REQUIRED
#define U32_ALIGNMENT_REQUIRED	/**/
#endif

/* HAS_UALARM:
 *	This symbol, if defined, indicates that the ualarm routine is
 *	available to do alarms with microsecond granularity.
 */
/*#define HAS_UALARM		/ **/

/* HAS_UNION_SEMUN:
 *	This symbol, if defined, indicates that the union semun is
 *	defined by including <sys/sem.h>.  If not, the user code
 *	probably needs to define it as:
 *	union semun {
 *	    int val;
 *	    struct semid_ds *buf;
 *	    unsigned short *array;
 *	}
 */
/* USE_SEMCTL_SEMUN:
 *	This symbol, if defined, indicates that union semun is
 *	used for semctl IPC_STAT.
 */
/* USE_SEMCTL_SEMID_DS:
 *	This symbol, if defined, indicates that struct semid_ds * is
 *	used for semctl IPC_STAT.
 */
/*#define HAS_UNION_SEMUN	/ **/
/*#define USE_SEMCTL_SEMUN	/ **/
/*#define USE_SEMCTL_SEMID_DS	/ **/

/* HAS_UNORDERED:
 *	This symbol, if defined, indicates that the unordered routine is
 *	available to check whether two doubles are unordered
 *	(effectively: whether either of them is NaN)
 */
/*#define HAS_UNORDERED		/ **/

/* HAS_UNSETENV:
 *	This symbol, if defined, indicates that the unsetenv () routine is
 *	available for use.
 */
/*#define HAS_UNSETENV		/ **/

/* HAS_USLEEP_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the usleep() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern int usleep(useconds_t);
 */
/*#define	HAS_USLEEP_PROTO	/ **/

/* HAS_USTAT:
 *	This symbol, if defined, indicates that the ustat system call is
 *	available to query file system statistics by dev_t.
 */
/*#define HAS_USTAT		/ **/

/* HAS_VFORK:
 *	This symbol, if defined, indicates that vfork() exists.
 */
/*#define HAS_VFORK	/ **/

/* Signal_t:
 *	This symbol's value is either "void" or "int", corresponding to the
 *	appropriate return type of a signal handler.  Thus, you can declare
 *	a signal handler using "Signal_t (*handler)()", and define the
 *	handler using "Signal_t handler(sig)".
 */
#define Signal_t int	/* Signal handler's return type */

/* HAS_VPRINTF:
 *	This symbol, if defined, indicates that the vprintf routine is available
 *	to printf with a pointer to an argument list.  If unavailable, you
 *	may need to write your own, probably in terms of _doprnt().
 */
/* USE_CHAR_VSPRINTF:
 *	This symbol is defined if this system has vsprintf() returning type
 *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
 *	is up to the package author to declare vsprintf correctly based on the
 *	symbol.
 */
#define HAS_VPRINTF	/**/
/*#define USE_CHAR_VSPRINTF 	/ **/

/* HAS_WRITEV:
 *	This symbol, if defined, indicates that the writev routine is
 *	available to do scatter writes.
 */
/*#define HAS_WRITEV		/ **/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
/*#define USE_DYNAMIC_LOADING		/ **/

/* DOUBLESIZE:
 *	This symbol contains the size of a double, so that the C preprocessor
 *	can make decisions based on it.
 */
#define DOUBLESIZE 8		/**/

/* EBCDIC:
 *     This symbol, if defined, indicates that this system uses
 *	EBCDIC encoding.
 */
/*#define	EBCDIC 		/ **/

/* FFLUSH_NULL:
 *	This symbol, if defined, tells that fflush(NULL) does flush
 *	all pending stdio output.
 */
/* FFLUSH_ALL:
 *	This symbol, if defined, tells that to flush
 *	all pending stdio output one must loop through all
 *	the stdio file handles stored in an array and fflush them.
 *	Note that if fflushNULL is defined, fflushall will not
 *	even be probed for and will be left undefined.
 */
/*#define	FFLUSH_NULL 		/ **/
/*#define	FFLUSH_ALL 		/ **/

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t int		/* File position type */

/* Gid_t_f:
 *	This symbol defines the format string used for printing a Gid_t.
 */
#define	Gid_t_f		"lu"		/**/

/* Gid_t_sign:
 *	This symbol holds the signedess of a Gid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Gid_t_sign	1		/* GID sign */

/* Gid_t_size:
 *	This symbol holds the size of a Gid_t in bytes.
 */
#define Gid_t_size 4		/* GID size */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	gid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t int		/* Type for getgid(), etc... */

/* Groups_t:
 *	This symbol holds the type used for the second argument to
 *	getgroups() and setgroups().  Usually, this is the same as
 *	gidtype (gid_t) , but sometimes it isn't.
 *	It can be int, ushort, gid_t, etc... 
 *	It may be necessary to include <sys/types.h> to get any 
 *	typedef'ed information.  This is only required if you have
 *	getgroups() or setgroups()..
 */
#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#define Groups_t int	/* Type for 2nd arg to [sg]etgroups() */
#endif

/* I_CRYPT:
 *	This symbol, if defined, indicates that <crypt.h> exists and
 *	should be included.
 */
/*#define	I_CRYPT		/ **/

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
/* DB_VERSION_MAJOR_CFG:
 *	This symbol, if defined, defines the major version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 */
/* DB_VERSION_MINOR_CFG:
 *	This symbol, if defined, defines the minor version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
/* DB_VERSION_PATCH_CFG:
 *	This symbol, if defined, defines the patch version number of
 *	Berkeley DB found in the <db.h> header when Perl was configured.
 *	For DB version 1 this is always 0.
 */
#define DB_Hash_t	u_int32_t		/**/
#define DB_Prefix_t	size_t  	/**/
#define DB_VERSION_MAJOR_CFG	  	/**/
#define DB_VERSION_MINOR_CFG	  	/**/
#define DB_VERSION_PATCH_CFG	  	/**/

/* I_FP:
 *	This symbol, if defined, indicates that <fp.h> exists and
 *	should be included.
 */
/*#define	I_FP		/ **/

/* I_FP_CLASS:
 *	This symbol, if defined, indicates that <fp_class.h> exists and
 *	should be included.
 */
/*#define	I_FP_CLASS		/ **/

/* I_GRP:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <grp.h>.
 */
/* GRPASSWD:
 *	This symbol, if defined, indicates to the C program that struct group
 *	in <grp.h> contains gr_passwd.
 */
/*#define I_GRP		/ **/
/*#define GRPASSWD	/ **/

/* I_IEEEFP:
 *	This symbol, if defined, indicates that <ieeefp.h> exists and
 *	should be included.
 */
/*#define	I_IEEEFP		/ **/

/* I_INTTYPES:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <inttypes.h>.
 */
/*#define   I_INTTYPES                / **/

/* I_LANGINFO:
 *	This symbol, if defined, indicates that <langinfo.h> exists and
 *	should be included.
 */
/*#define	I_LANGINFO		/ **/

/* I_LIBUTIL:
 *	This symbol, if defined, indicates that <libutil.h> exists and
 *	should be included.
 */
/*#define	I_LIBUTIL		/ **/

/* I_MACH_CTHREADS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <mach/cthreads.h>.
 */
/*#define   I_MACH_CTHREADS	/ **/

/* I_MNTENT:
 *	This symbol, if defined, indicates that <mntent.h> exists and
 *	should be included.
 */
/*#define	I_MNTENT		/ **/

/* I_NDBM:
 *	This symbol, if defined, indicates that <ndbm.h> exists and should
 *	be included.
 */
/*#define I_NDBM	/ **/

/* I_NETDB:
 *	This symbol, if defined, indicates that <netdb.h> exists and
 *	should be included.
 */
/*#define I_NETDB		/ **/

/* I_NETINET_TCP:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <netinet/tcp.h>.
 */
/*#define   I_NETINET_TCP                / **/

/* I_POLL:
 *	This symbol, if defined, indicates that <poll.h> exists and
 *	should be included. (see also HAS_POLL)
 */
/*#define	I_POLL		/ **/

/* I_PROT:
 *	This symbol, if defined, indicates that <prot.h> exists and
 *	should be included.
 */
/*#define	I_PROT		/ **/

/* I_PTHREAD:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <pthread.h>.
 */
/*#define   I_PTHREAD	/ **/

/* I_PWD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pwd.h>.
 */
/* PWQUOTA:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_quota.
 */
/* PWAGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_age.
 */
/* PWCHANGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_change.
 */
/* PWCLASS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_class.
 */
/* PWEXPIRE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_expire.
 */
/* PWCOMMENT:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_comment.
 */
/* PWGECOS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_gecos.
 */
/* PWPASSWD:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_passwd.
 */
/*#define I_PWD		/ **/
/*#define PWQUOTA	/ **/
/*#define PWAGE	/ **/
/*#define PWCHANGE	/ **/
/*#define PWCLASS	/ **/
/*#define PWEXPIRE	/ **/
/*#define PWCOMMENT	/ **/
/*#define PWGECOS	/ **/
/*#define PWPASSWD	/ **/

/* I_SHADOW:
 *	This symbol, if defined, indicates that <shadow.h> exists and
 *	should be included.
 */
/*#define	I_SHADOW		/ **/

/* I_SOCKS:
 *	This symbol, if defined, indicates that <socks.h> exists and
 *	should be included.
 */
/*#define	I_SOCKS		/ **/

/* I_SUNMATH:
 *	This symbol, if defined, indicates that <sunmath.h> exists and
 *	should be included.
 */
/*#define	I_SUNMATH		/ **/

/* I_SYSLOG:
 *	This symbol, if defined, indicates that <syslog.h> exists and
 *	should be included.
 */
/*#define	I_SYSLOG		/ **/

/* I_SYSMODE:
 *	This symbol, if defined, indicates that <sys/mode.h> exists and
 *	should be included.
 */
/*#define	I_SYSMODE		/ **/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates that <sys/mount.h> exists and
 *	should be included.
 */
/*#define	I_SYS_MOUNT		/ **/

/* I_SYS_STATFS:
 *	This symbol, if defined, indicates that <sys/statfs.h> exists.
 */
/*#define	I_SYS_STATFS		/ **/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates that <sys/statvfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_STATVFS		/ **/

/* I_SYSUIO:
 *	This symbol, if defined, indicates that <sys/uio.h> exists and
 *	should be included.
 */
/*#define	I_SYSUIO		/ **/

/* I_SYSUTSNAME:
 *	This symbol, if defined, indicates that <sys/utsname.h> exists and
 *	should be included.
 */
/*#define	I_SYSUTSNAME		/ **/

/* I_SYS_VFS:
 *	This symbol, if defined, indicates that <sys/vfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_VFS		/ **/

/* I_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <time.h>.
 */
/* I_SYS_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h>.
 */
/* I_SYS_TIME_KERNEL:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h> with KERNEL defined.
 */
/* HAS_TM_TM_ZONE:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_zone field.
 */
/* HAS_TM_TM_GMTOFF:
 *	This symbol, if defined, indicates to the C program that
 *	the struct tm has a tm_gmtoff field.
 */
#define I_TIME		/**/
/*#define I_SYS_TIME		/ **/
/*#define I_SYS_TIME_KERNEL		/ **/
/*#define HAS_TM_TM_ZONE		/ **/
/*#define HAS_TM_TM_GMTOFF		/ **/

/* I_USTAT:
 *	This symbol, if defined, indicates that <ustat.h> exists and
 *	should be included.
 */
/*#define	I_USTAT		/ **/

/* I_STDARG:
 *	This symbol, if defined, indicates that <stdarg.h> exists and should
 *	be included.
 */
/* I_VARARGS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <varargs.h>.
 */
#define I_STDARG		/**/
/*#define I_VARARGS	/ **/

/* PERL_INC_VERSION_LIST:
 *	This variable specifies the list of subdirectories in over
 *	which perl.c:incpush() and lib/lib.pm will automatically
 *	search when adding directories to @INC, in a format suitable
 *	for a C initialization string.  See the inc_version_list entry
 *	in Porting/Glossary for more details.
 */
/*#define PERL_INC_VERSION_LIST NULL		/ **/

/* INSTALL_USR_BIN_PERL:
 *	This symbol, if defined, indicates that Perl is to be installed
 * 	also as /usr/bin/perl.
 */
/*#define INSTALL_USR_BIN_PERL	/ **/

/* PERL_PRIfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for output.
 */
/* PERL_PRIgldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'g') for output.
 */
/* PERL_PRIeldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'e') for output.
 */
/* PERL_SCNfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for input.
 */
/*#define PERL_PRIfldbl	"llf"	/ **/
/*#define PERL_PRIgldbl	"llg"	/ **/
/*#define PERL_PRIeldbl	"lle"	/ **/
/*#define PERL_SCNfldbl	"llf"	/ **/

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
/* LSEEKSIZE:
 *	This symbol holds the number of bytes used by the Off_t.
 */
/* Off_t_size:
 *	This symbol holds the number of bytes used by the Off_t.
 */
#define Off_t int		/* <offset> type */
#define LSEEKSIZE 4		/* <offset> size */
#define Off_t_size 4	/* <offset> size */

/* PERL_MAD:
 *	This symbol, if defined, indicates that the Misc Attribution
 *	Declaration code should be conditionally compiled.
 */
/*#define	PERL_MAD		/ **/

/* Free_t:
 *	This variable contains the return type of free().  It is usually
 * void, but occasionally int.
 */
/* Malloc_t:
 *	This symbol is the type of pointer returned by malloc and realloc.
 */
#define Malloc_t void *			/**/
#define Free_t void			/**/

/* PERL_MALLOC_WRAP:
 *	This symbol, if defined, indicates that we'd like malloc wrap checks.
 */
/*#define PERL_MALLOC_WRAP		/ **/

/* MYMALLOC:
 *	This symbol, if defined, indicates that we're using our own malloc.
 */
/*#define MYMALLOC			/ **/

/* Mode_t:
 *	This symbol holds the type used to declare file modes 
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t int	 /* file mode parameter for system calls */

/* VAL_O_NONBLOCK:
 *	This symbol is to be used during open() or fcntl(F_SETFL) to turn on
 *	non-blocking I/O for the file descriptor. Note that there is no way
 *	back, i.e. you cannot turn it blocking again this way. If you wish to
 *	alternatively switch between blocking and non-blocking, use the
 *	ioctl(FIOSNBIO) call instead, but that is not supported by all devices.
 */
/* VAL_EAGAIN:
 *	This symbol holds the errno error code set by read() when no data was
 *	present on the non-blocking file descriptor.
 */
/* RD_NODATA:
 *	This symbol holds the return code from read() when no data is present
 *	on the non-blocking file descriptor. Be careful! If EOF_NONBLOCK is
 *	not defined, then you can't distinguish between no data and EOF by
 *	issuing a read(). You'll have to find another way to tell for sure!
 */
/* EOF_NONBLOCK:
 *	This symbol, if defined, indicates to the C program that a read() on
 *	a non-blocking file descriptor will return 0 on EOF, and not the value
 *	held in RD_NODATA (-1 usually, in that case!).
 */
#define VAL_O_NONBLOCK O_NONBLOCK
#define VAL_EAGAIN EAGAIN
#define RD_NODATA -1
#undef EOF_NONBLOCK

/* NEED_VA_COPY:
 *	This symbol, if defined, indicates that the system stores
 *	the variable argument list datatype, va_list, in a format
 *	that cannot be copied by simple assignment, so that some
 *	other means must be used when copying is required.
 *	As such systems vary in their provision (or non-provision)
 *	of copying mechanisms, handy.h defines a platform-
 *	independent macro, Perl_va_copy(src, dst), to do the job.
 */
/*#define	NEED_VA_COPY		/ **/

/* Netdb_host_t:
 *	This symbol holds the type used for the 1st argument
 *	to gethostbyaddr().
 */
/* Netdb_hlen_t:
 *	This symbol holds the type used for the 2nd argument
 *	to gethostbyaddr().
 */
/* Netdb_name_t:
 *	This symbol holds the type used for the argument to
 *	gethostbyname().
 */
/* Netdb_net_t:
 *	This symbol holds the type used for the 1st argument to
 *	getnetbyaddr().
 */
#define Netdb_host_t		const char * /**/
#define Netdb_hlen_t		int /**/
#define Netdb_name_t		const char * /**/
#define Netdb_net_t		unsigned long /**/

/* PERL_OTHERLIBDIRS:
 *	This variable contains a colon-separated set of paths for the perl
 *	binary to search for additional library files or modules.
 *	These directories will be tacked to the end of @INC.
 *	Perl will automatically search below each path for version-
 *	and architecture-specific directories.  See PERL_INC_VERSION_LIST
 *	for more details.
 */
/*#define PERL_OTHERLIBDIRS ""		/ **/

/* HAS_QUAD:
 *	This symbol, if defined, tells that there's a 64-bit integer type,
 *	Quad_t, and its unsigned counterpar, Uquad_t. QUADKIND will be one
 *	of QUAD_IS_INT, QUAD_IS_LONG, QUAD_IS_LONG_LONG, or QUAD_IS_INT64_T.
 */
/*#define HAS_QUAD	/ **/
#ifdef HAS_QUAD
#   define Quad_t int64_t	/**/
#   define Uquad_t uint64_t	/**/
#   define QUADKIND 4	/**/
#   define QUAD_IS_INT	1
#   define QUAD_IS_LONG	2
#   define QUAD_IS_LONG_LONG	3
#   define QUAD_IS_INT64_T	4
#endif

/* IVTYPE:
 *	This symbol defines the C type used for Perl's IV.
 */
/* UVTYPE:
 *	This symbol defines the C type used for Perl's UV.
 */
/* I8TYPE:
 *	This symbol defines the C type used for Perl's I8.
 */
/* U8TYPE:
 *	This symbol defines the C type used for Perl's U8.
 */
/* I16TYPE:
 *	This symbol defines the C type used for Perl's I16.
 */
/* U16TYPE:
 *	This symbol defines the C type used for Perl's U16.
 */
/* I32TYPE:
 *	This symbol defines the C type used for Perl's I32.
 */
/* U32TYPE:
 *	This symbol defines the C type used for Perl's U32.
 */
/* I64TYPE:
 *	This symbol defines the C type used for Perl's I64.
 */
/* U64TYPE:
 *	This symbol defines the C type used for Perl's U64.
 */
/* NVTYPE:
 *	This symbol defines the C type used for Perl's NV.
 */
/* IVSIZE:
 *	This symbol contains the sizeof(IV).
 */
/* UVSIZE:
 *	This symbol contains the sizeof(UV).
 */
/* I8SIZE:
 *	This symbol contains the sizeof(I8).
 */
/* U8SIZE:
 *	This symbol contains the sizeof(U8).
 */
/* I16SIZE:
 *	This symbol contains the sizeof(I16).
 */
/* U16SIZE:
 *	This symbol contains the sizeof(U16).
 */
/* I32SIZE:
 *	This symbol contains the sizeof(I32).
 */
/* U32SIZE:
 *	This symbol contains the sizeof(U32).
 */
/* I64SIZE:
 *	This symbol contains the sizeof(I64).
 */
/* U64SIZE:
 *	This symbol contains the sizeof(U64).
 */
/* NVSIZE:
 *	This symbol contains the sizeof(NV).
 */
/* NV_PRESERVES_UV:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	can preserve all the bits of a variable of type UVTYPE.
 */
/* NV_PRESERVES_UV_BITS:
 *	This symbol contains the number of bits a variable of type NVTYPE
 *	can preserve of a variable of type UVTYPE.
 */
/* NV_ZERO_IS_ALLBITS_ZERO:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	stores 0.0 in memory as all bits zero.
 */
#define	IVTYPE		long		/**/
#define	UVTYPE		unsigned long		/**/
#define	I8TYPE		char		/**/
#define	U8TYPE		unsigned char		/**/
#define	I16TYPE		short	/**/
#define	U16TYPE		unsigned short	/**/
#define	I32TYPE		long	/**/
#define	U32TYPE		unsigned long	/**/
#ifdef HAS_QUAD
#define	I64TYPE		int64_t	/**/
#define	U64TYPE		uint64_t	/**/
#endif
#define	NVTYPE		double		/**/
#define	IVSIZE		4		/**/
#define	UVSIZE		4		/**/
#define	I8SIZE		1		/**/
#define	U8SIZE		1		/**/
#define	I16SIZE		2	/**/
#define	U16SIZE		2	/**/
#define	I32SIZE		4	/**/
#define	U32SIZE		4	/**/
#ifdef HAS_QUAD
#define	I64SIZE		8	/**/
#define	U64SIZE		8	/**/
#endif
#define	NVSIZE		8		/**/
#undef	NV_PRESERVES_UV
#define	NV_PRESERVES_UV_BITS	0
#undef	NV_ZERO_IS_ALLBITS_ZERO
#if UVSIZE == 8
#   ifdef BYTEORDER
#       if BYTEORDER == 0x1234
#           undef BYTEORDER
#           define BYTEORDER 0x12345678
#       else
#           if BYTEORDER == 0x4321
#               undef BYTEORDER
#               define BYTEORDER 0x87654321
#           endif
#       endif
#   endif
#endif

/* IVdf:
 *	This symbol defines the format string used for printing a Perl IV
 *	as a signed decimal integer.
 */
/* UVuf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned decimal integer.
 */
/* UVof:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned octal integer.
 */
/* UVxf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in lowercase abcdef.
 */
/* UVXf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in uppercase ABCDEF.
 */
/* NVef:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %e-ish floating point format.
 */
/* NVff:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %f-ish floating point format.
 */
/* NVgf:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %g-ish floating point format.
 */
#define	IVdf		"ld"		/**/
#define	UVuf		"lu"		/**/
#define	UVof		"lo"		/**/
#define	UVxf		"lx"		/**/
#define	UVXf		"lX"		/**/
#define	NVef		"e"		/**/
#define	NVff		"f"		/**/
#define	NVgf		"g"		/**/

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t int		/* PID type */

/* PRIVLIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 */
/* PRIVLIB_EXP:
 *	This symbol contains the ~name expanded version of PRIVLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define PRIVLIB "/usr/local/lib/perl5/5.9"		/**/
#define PRIVLIB_EXP "/usr/local/lib/perl5/5.9"		/**/

/* CAN_PROTOTYPE:
 *	If defined, this macro indicates that the C compiler can handle
 *	function prototypes.
 */
/* _:
 *	This macro is used to declare function parameters for folks who want
 *	to make declarations with prototypes using a different style than
 *	the above macros.  Use double parentheses.  For example:
 *
 *		int main _((int argc, char *argv[]));
 */
/*#define	CAN_PROTOTYPE	/ **/
#ifdef CAN_PROTOTYPE
#define	_(args) args
#else
#define	_(args) ()
#endif

/* PTRSIZE:
 *	This symbol contains the size of a pointer, so that the C preprocessor
 *	can make decisions based on it.  It will be sizeof(void *) if
 *	the compiler supports (void *); otherwise it will be
 *	sizeof(char *).
 */
#define PTRSIZE 4		/**/

/* Drand01:
 *	This macro is to be used to generate uniformly distributed
 *	random numbers over the range [0., 1.[.  You may have to supply
 *	an 'extern double drand48();' in your program since SunOS 4.1.3
 *	doesn't provide you with anything relevant in its headers.
 *	See HAS_DRAND48_PROTO.
 */
/* Rand_seed_t:
 *	This symbol defines the type of the argument of the
 *	random seed function.
 */
/* seedDrand01:
 *	This symbol defines the macro to be used in seeding the
 *	random number generator (see Drand01).
 */
/* RANDBITS:
 *	This symbol indicates how many bits are produced by the
 *	function used to generate normalized random numbers.
 *	Values include 15, 16, 31, and 48.
 */
#define Drand01()		((rand() & 0x7FFF) / (double) ((unsigned long)1 << 15))		/**/
#define Rand_seed_t		int		/**/
#define seedDrand01(x)	srand((Rand_seed_t)x)	/**/
#define RANDBITS		48		/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	32	/**/

/* Select_fd_set_t:
 *	This symbol holds the type used for the 2nd, 3rd, and 4th
 *	arguments to select.  Usually, this is 'fd_set *', if HAS_FD_SET
 *	is defined, and 'int *' otherwise.  This is only useful if you 
 *	have select(), of course.
 */
#define Select_fd_set_t 	int	/**/

/* SH_PATH:
 *	This symbol contains the full pathname to the shell used on this
 *	on this system to execute Bourne shell scripts.  Usually, this will be
 *	/bin/sh, though it's possible that some systems will have /bin/ksh,
 *	/bin/pdksh, /bin/ash, /bin/bash, or even something such as
 *	D:/bin/sh.exe.
 */
#define SH_PATH ""  /**/

/* SIG_NAME:
 *	This symbol contains a list of signal names in order of
 *	signal number. This is intended
 *	to be used as a static array initialization, like this:
 *		char *sig_name[] = { SIG_NAME };
 *	The signals in the list are separated with commas, and each signal
 *	is surrounded by double quotes. There is no leading SIG in the signal
 *	name, i.e. SIGQUIT is known as "QUIT".
 *	Gaps in the signal numbers (up to NSIG) are filled in with NUMnn,
 *	etc., where nn is the actual signal number (e.g. NUM37).
 *	The signal number for sig_name[i] is stored in sig_num[i].
 *	The last element is 0 to terminate the list with a NULL.  This
 *	corresponds to the 0 at the end of the sig_name_init list.
 *	Note that this variable is initialized from the sig_name_init,
 *	not from sig_name (which is unused).
 */
/* SIG_NUM:
 *	This symbol contains a list of signal numbers, in the same order as the
 *	SIG_NAME list. It is suitable for static array initialization, as in:
 *		int sig_num[] = { SIG_NUM };
 *	The signals in the list are separated with commas, and the indices
 *	within that list and the SIG_NAME list match, so it's easy to compute
 *	the signal name from a number or vice versa at the price of a small
 *	dynamic linear lookup. 
 *	Duplicates are allowed, but are moved to the end of the list.
 *	The signal number corresponding to sig_name[i] is sig_number[i].
 *	if (i < NSIG) then sig_number[i] == i.  
 *	The last element is 0, corresponding to the 0 at the end of
 *	the sig_name_init list.
 *	Note that this variable is initialized from the sig_num_init,
 *	not from sig_num (which is unused).
 */
/* SIG_SIZE:
 *	This variable contains the number of elements of the SIG_NAME
 *	and SIG_NUM arrays, excluding the final NULL entry.
 */
#define SIG_NAME 0		/**/
#define SIG_NUM  0		/**/
#define SIG_SIZE 1			/**/

/* SITEARCH:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-dependent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITEARCH_EXP:
 *	This symbol contains the ~name expanded version of SITEARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define SITEARCH ""		/ **/
/*#define SITEARCH_EXP ""		/ **/

/* SITELIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-independent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITELIB_EXP:
 *	This symbol contains the ~name expanded version of SITELIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* SITELIB_STEM:
 *	This define is SITELIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
#define SITELIB ""		/**/
#define SITELIB_EXP ""		/**/
#define SITELIB_STEM ""		/**/

/* Size_t_size:
 *	This symbol holds the size of a Size_t in bytes.
 */
#define Size_t_size 4		/* */

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length paramater for string functions */

/* Sock_size_t:
 *	This symbol holds the type used for the size argument of
 *	various socket calls (just the base type, not the pointer-to).
 */
#define Sock_size_t		int /**/

/* SSize_t:
 *	This symbol holds the type used by functions that return
 *	a count of bytes or an error condition.  It must be a signed type.
 *	It is usually ssize_t, but may be long or int, etc.
 *	It may be necessary to include <sys/types.h> or <unistd.h>
 *	to get any typedef'ed information.
 *	We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
 */
#define SSize_t int	 /* signed count of bytes */

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL ""		/**/

/* STDCHAR:
 *	This symbol is defined to be the type of char used in stdio.h.
 *	It has the values "unsigned char" or "char".
 */
#define STDCHAR char	/**/

/* HAS_STDIO_STREAM_ARRAY:
 *	This symbol, if defined, tells that there is an array
 *	holding the stdio streams.
 */
/* STDIO_STREAM_ARRAY:
 *	This symbol tells the name of the array holding the stdio streams.
 *	Usual values include _iob, __iob, and __sF.
 */
/*#define	HAS_STDIO_STREAM_ARRAY	/ **/
#define STDIO_STREAM_ARRAY	

/* Uid_t_f:
 *	This symbol defines the format string used for printing a Uid_t.
 */
#define	Uid_t_f		"lu"		/**/

/* Uid_t_sign:
 *	This symbol holds the signedess of a Uid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Uid_t_sign	1		/* UID sign */

/* Uid_t_size:
 *	This symbol holds the size of a Uid_t in bytes.
 */
#define Uid_t_size 4		/* UID size */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t int		/* UID type */

/* USE_64_BIT_INT:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be employed (be they 32 or 64 bits).  The minimal possible
 *	64-bitness is used, just enough to get 64-bit integers into Perl.
 *	This may mean using for example "long longs", while your memory
 *	may still be limited to 2 gigabytes.
 */
/* USE_64_BIT_ALL:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be used (be they 32 or 64 bits).  The maximal possible
 *	64-bitness is employed: LP64 or ILP64, meaning that you will
 *	be able to use more than 2 gigabytes of memory.  This mode is
 *	even more binary incompatible than USE_64_BIT_INT. You may not
 *	be able to run the resulting executable in a 32-bit CPU at all or
 *	you may need at least to reboot your OS to 64-bit mode.
 */
#ifndef USE_64_BIT_INT
/*#define	USE_64_BIT_INT		/ **/
#endif

#ifndef USE_64_BIT_ALL
/*#define	USE_64_BIT_ALL		/ **/
#endif

/* USE_FAST_STDIO:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use 'fast stdio'.
 *	Defaults to define in Perls 5.8 and earlier, to undef later.
 */
#ifndef USE_FAST_STDIO
/*#define	USE_FAST_STDIO		/ **/
#endif

/* USE_LARGE_FILES:
 *	This symbol, if defined, indicates that large file support
 *	should be used when available.
 */
#ifndef USE_LARGE_FILES
/*#define	USE_LARGE_FILES		/ **/
#endif

/* USE_LONG_DOUBLE:
 *	This symbol, if defined, indicates that long doubles should
 *	be used when available.
 */
#ifndef USE_LONG_DOUBLE
/*#define	USE_LONG_DOUBLE		/ **/
#endif

/* USE_MORE_BITS:
 *	This symbol, if defined, indicates that 64-bit interfaces and
 *	long doubles should be used when available.
 */
#ifndef USE_MORE_BITS
/*#define	USE_MORE_BITS		/ **/
#endif

/* MULTIPLICITY:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use multiplicity.
 */
#ifndef MULTIPLICITY
/*#define	MULTIPLICITY		/ **/
#endif

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
#ifndef USE_PERLIO
/*#define	USE_PERLIO		/ **/
#endif

/* USE_SOCKS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use socks.
 */
#ifndef USE_SOCKS
/*#define	USE_SOCKS		/ **/
#endif

/* USE_ITHREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the interpreter-based threading implementation.
 */
/* USE_5005THREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the 5.005-based threading implementation.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/* USE_REENTRANT_API:
 *	This symbol, if defined, indicates that Perl should
 *	try to use the various _r versions of library functions.
 *	This is extremely experimental.
 */
/*#define	USE_5005THREADS		/ **/
/*#define	USE_ITHREADS		/ **/
#if defined(USE_5005THREADS) && !defined(USE_ITHREADS)
#define		USE_THREADS		/* until src is revised*/
#endif
/*#define	OLD_PTHREADS_API		/ **/
/*#define	USE_REENTRANT_API	/ **/

/* PERL_VENDORARCH:
 *	If defined, this symbol contains the name of a private library.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.
 *	It may have a ~ on the front.
 *	The standard distribution will put nothing in this directory.
 *	Vendors who distribute perl may wish to place their own
 *	architecture-dependent modules and extensions in this directory with
 *		MakeMaker Makefile.PL INSTALLDIRS=vendor
 *	or equivalent.  See INSTALL for details.
 */
/* PERL_VENDORARCH_EXP:
 *	This symbol contains the ~name expanded version of PERL_VENDORARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define PERL_VENDORARCH ""		/ **/
/*#define PERL_VENDORARCH_EXP ""		/ **/

/* PERL_VENDORLIB_EXP:
 *	This symbol contains the ~name expanded version of VENDORLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* PERL_VENDORLIB_STEM:
 *	This define is PERL_VENDORLIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
/*#define PERL_VENDORLIB_EXP ""		/ **/
/*#define PERL_VENDORLIB_STEM ""		/ **/

/* VOIDFLAGS:
 *	This symbol indicates how much support of the void type is given by this
 *	compiler.  What various bits mean:
 *
 *	    1 = supports declaration of void
 *	    2 = supports arrays of pointers to functions returning void
 *	    4 = supports comparisons between pointers to void functions and
 *		    addresses of void functions
 *	    8 = suports declaration of generic void pointers
 *
 *	The package designer should define VOIDUSED to indicate the requirements
 *	of the package.  This can be done either by #defining VOIDUSED before
 *	including config.h, or by defining defvoidused in Myinit.U.  If the
 *	latter approach is taken, only those flags will be tested.  If the
 *	level of void support necessary is not present, defines void to int.
 */
#ifndef VOIDUSED
#define VOIDUSED 1
#endif
#define VOIDFLAGS 1
#if (VOIDFLAGS & VOIDUSED) != VOIDUSED
#define void int		/* is void to be avoided? */
#define M_VOID			/* Xenix strikes again */
#endif

/* HAS_POLL:
 *	This symbol, if defined, indicates that the poll routine is
 *	available to poll active file descriptors. You may safely
 *	include <poll.h> when both this symbol *and* I_POLL are defined.
 */
/*#define HAS_POLL		/ **/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\unixish.h ===
/*    unixish.h
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002,
 *    2003, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * The following symbols are defined if your operating system supports
 * functions by that name.  All Unixes I know of support them, thus they
 * are not checked by the configuration script, but are directly defined
 * here.
 */

#ifndef PERL_MICRO

/* HAS_IOCTL:
 *	This symbol, if defined, indicates that the ioctl() routine is
 *	available to set I/O characteristics
 */
#define	HAS_IOCTL		/**/
 
/* HAS_UTIME:
 *	This symbol, if defined, indicates that the routine utime() is
 *	available to update the access and modification times of files.
 */
#define HAS_UTIME		/**/

/* HAS_GROUP
 *	This symbol, if defined, indicates that the getgrnam() and
 *	getgrgid() routines are available to get group entries.
 *	The getgrent() has a separate definition, HAS_GETGRENT.
 */
#define HAS_GROUP		/**/

/* HAS_PASSWD
 *	This symbol, if defined, indicates that the getpwnam() and
 *	getpwuid() routines are available to get password entries.
 *	The getpwent() has a separate definition, HAS_GETPWENT.
 */
#define HAS_PASSWD		/**/

#define HAS_KILL
#define HAS_WAIT

#endif /* !PERL_MICRO */
  
/* USEMYBINMODE
 *	This symbol, if defined, indicates that the program should
 *	use the routine my_binmode(FILE *fp, char iotype) to insure
 *	that a file is in "binary" mode -- that is, that no translation
 *	of bytes occurs on read or write operations.
 */
#undef USEMYBINMODE

/* Stat_t:
 *	This symbol holds the type used to declare buffers for information
 *	returned by stat().  It's usually just struct stat.  It may be necessary
 *	to include <sys/stat.h> and <sys/types.h> to get any typedef'ed
 *	information.
 */
#define Stat_t struct stat

/* USE_STAT_RDEV:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_rdev
 */
#define USE_STAT_RDEV 	/**/

/* ACME_MESS:
 *	This symbol, if defined, indicates that error messages should be 
 *	should be generated in a format that allows the use of the Acme
 *	GUI/editor's autofind feature.
 */
#undef ACME_MESS	/**/

/* UNLINK_ALL_VERSIONS:
 *	This symbol, if defined, indicates that the program should arrange
 *	to remove all versions of a file if unlink() is called.  This is
 *	probably only relevant for VMS.
 */
/* #define UNLINK_ALL_VERSIONS		/ **/

/* VMS:
 *	This symbol, if defined, indicates that the program is running under
 *	VMS.  It is currently automatically set by cpps running under VMS,
 *	and is included here for completeness only.
 */
/* #define VMS		/ **/

/* ALTERNATE_SHEBANG:
 *	This symbol, if defined, contains a "magic" string which may be used
 *	as the first line of a Perl program designed to be executed directly
 *	by name, instead of the standard Unix #!.  If ALTERNATE_SHEBANG
 *	begins with a character other then #, then Perl will only treat
 *	it as a command line if it finds the string "perl" in the first
 *	word; otherwise it's treated as the first line of code in the script.
 *	(IOW, Perl won't hand off to another interpreter via an alternate
 *	shebang sequence that might be legal Perl code.)
 */
/* #define ALTERNATE_SHEBANG "#!" / **/

# include <signal.h>

#ifndef SIGABRT
#    define SIGABRT SIGILL
#endif
#ifndef SIGILL
#    define SIGILL 6         /* blech */
#endif
#define ABORT() kill(PerlProc_getpid(),SIGABRT);

/*
 * fwrite1() should be a routine with the same calling sequence as fwrite(),
 * but which outputs all of the bytes requested as a single stream (unlike
 * fwrite() itself, which on some systems outputs several distinct records
 * if the number_of_items parameter is >1).
 */
#define fwrite1 fwrite

#define Stat(fname,bufptr) stat((fname),(bufptr))
#define Fstat(fd,bufptr)   fstat((fd),(bufptr))
#define Fflush(fp)         fflush(fp)
#define Mkdir(path,mode)   mkdir((path),(mode))

#ifndef PERL_SYS_INIT_BODY
#  define PERL_SYS_INIT_BODY(c,v)					\
	MALLOC_CHECK_TAINT2(*c,*v) PERL_FPU_INIT; PERLIO_INIT; MALLOC_INIT
#endif

#ifndef PERL_SYS_TERM_BODY
#  define PERL_SYS_TERM_BODY() \
    HINTS_REFCNT_TERM; OP_REFCNT_TERM; PERLIO_TERM; MALLOC_TERM;

#endif

#define BIT_BUCKET "/dev/null"

#define dXSUB_SYS

#ifndef NO_ENVIRON_ARRAY
#define USE_ENVIRON_ARRAY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\thread.h ===
/*    thread.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if defined(USE_ITHREADS)

#if defined(VMS)
#include <builtins.h>
#endif

#ifdef WIN32
#  include <win32thread.h>
#else
#ifdef NETWARE
#  include <nw5thread.h>
#else
#  ifdef OLD_PTHREADS_API /* Here be dragons. */
#    define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach(&(t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END

#    define PERL_GET_CONTEXT	Perl_get_context()
#    define PERL_SET_CONTEXT(t)	Perl_set_context((void*)t)

#    define PTHREAD_GETSPECIFIC_INT
#    ifdef DJGPP
#      define pthread_addr_t any_t
#      define NEED_PTHREAD_INIT
#      define PTHREAD_CREATE_JOINABLE (1)
#    endif
#    ifdef __OPEN_VM
#      define pthread_addr_t void *
#    endif
#    ifdef OEMVS
#      define pthread_addr_t void *
#      define pthread_create(t,a,s,d)        pthread_create(t,&(a),s,d)
#      define pthread_keycreate              pthread_key_create
#    endif
#    ifdef VMS
#      define pthread_attr_init(a) pthread_attr_create(a)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_setdetach_np(a,s)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(__hpux) && defined(__ux_version) && __ux_version <= 1020
#      define pthread_attr_init(a) pthread_attr_create(a)
       /* XXX pthread_setdetach_np() missing in DCE threads on HP-UX 10.20 */
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s)	(0)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(DJGPP) || defined(__OPEN_VM) || defined(OEMVS)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,&(s))
#      define YIELD pthread_yield(NULL)
#    endif
#  endif
#  if !defined(__hpux) || !defined(__ux_version) || __ux_version > 1020
#    define pthread_mutexattr_default NULL
#    define pthread_condattr_default  NULL
#  endif
#endif	/* NETWARE */
#endif

#ifndef PTHREAD_CREATE
/* You are not supposed to pass NULL as the 2nd arg of PTHREAD_CREATE(). */
#  define PTHREAD_CREATE(t,a,s,d) pthread_create(t,&(a),s,d)
#endif

#ifndef PTHREAD_ATTR_SETDETACHSTATE
#  define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,s)
#endif

#ifndef PTHREAD_CREATE_JOINABLE
#  ifdef OLD_PTHREAD_CREATE_JOINABLE
#    define PTHREAD_CREATE_JOINABLE OLD_PTHREAD_CREATE_JOINABLE
#  else
#    define PTHREAD_CREATE_JOINABLE 0 /* Panic?  No, guess. */
#  endif
#endif

#ifdef DGUX
#  define THREAD_CREATE_NEEDS_STACK (32*1024)
#endif

#ifdef __VMS
  /* Default is 1024 on VAX, 8192 otherwise */
#  define THREAD_CREATE_NEEDS_STACK (32*1024)
#endif

#ifdef I_MACH_CTHREADS

/* cthreads interface */

/* #include <mach/cthreads.h> is in perl.h #ifdef I_MACH_CTHREADS */

#define MUTEX_INIT(m) \
    STMT_START {						\
	*m = mutex_alloc();					\
	if (*m) {						\
	    mutex_init(*m);					\
	} else {						\
	    Perl_croak_nocontext("panic: MUTEX_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define MUTEX_LOCK(m)			mutex_lock(*m)
#define MUTEX_UNLOCK(m)			mutex_unlock(*m)
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	mutex_free(*m);						\
	*m = 0;							\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	*c = condition_alloc();					\
	if (*c) {						\
	    condition_init(*c);					\
	}							\
	else {							\
	    Perl_croak_nocontext("panic: COND_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define COND_SIGNAL(c)		condition_signal(*c)
#define COND_BROADCAST(c)	condition_broadcast(*c)
#define COND_WAIT(c, m)		condition_wait(*c, *m)
#define COND_DESTROY(c) \
    STMT_START {						\
	condition_free(*c);					\
	*c = 0;							\
    } STMT_END

#define THREAD_CREATE(thr, f)	(thr->self = cthread_fork(f, thr), 0)
#define THREAD_POST_CREATE(thr)

#define THREAD_RET_TYPE		any_t
#define THREAD_RET_CAST(x)	((any_t) x)

#define DETACH(t)		cthread_detach(t->self)
#define JOIN(t, avp)		(*(avp) = (AV *)cthread_join(t->self))

#define PERL_SET_CONTEXT(t)	cthread_set_data(cthread_self(), t)
#define PERL_GET_CONTEXT	cthread_data(cthread_self())

#define INIT_THREADS		cthread_init()
#define YIELD			cthread_yield()
#define ALLOC_THREAD_KEY	NOOP
#define FREE_THREAD_KEY		NOOP
#define SET_THREAD_SELF(thr)	(thr->self = cthread_self())

#endif /* I_MACH_CTHREADS */

#ifndef YIELD
#  ifdef SCHED_YIELD
#    define YIELD SCHED_YIELD
#  else
#    ifdef HAS_SCHED_YIELD
#      define YIELD sched_yield()
#    else
#      ifdef HAS_PTHREAD_YIELD
    /* pthread_yield(NULL) platforms are expected
     * to have #defined YIELD for themselves. */
#        define YIELD pthread_yield()
#      endif
#    endif
#  endif
#endif

#ifdef __hpux
#  define MUTEX_INIT_NEEDS_MUTEX_ZEROED
#endif

#ifndef MUTEX_INIT

#  ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
    /* Temporary workaround, true bug is deeper. --jhi 1999-02-25 */
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	Zero((m), 1, perl_mutex);                               \
 	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  else
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  endif

#  define MUTEX_LOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_lock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_LOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_UNLOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_unlock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_DESTROY(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_destroy((m))))		\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* MUTEX_INIT */

#ifndef COND_INIT
#  define COND_INIT(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_init((c), pthread_condattr_default)))	\
	    Perl_croak_nocontext("panic: COND_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_SIGNAL(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_signal((c))))			\
	    Perl_croak_nocontext("panic: COND_SIGNAL (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_BROADCAST(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_broadcast((c))))		\
	    Perl_croak_nocontext("panic: COND_BROADCAST (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_WAIT(c, m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_wait((c), (m))))		\
	    Perl_croak_nocontext("panic: COND_WAIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_DESTROY(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_destroy((c))))			\
	    Perl_croak_nocontext("panic: COND_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* COND_INIT */

/* DETACH(t) must only be called while holding t->mutex */
#ifndef DETACH
#  define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach((t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END
#endif /* DETACH */

#ifndef JOIN
#  define JOIN(t, avp) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_join((t)->self, (void**)(avp))))	\
	    Perl_croak_nocontext("panic: pthread_join (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* JOIN */

/* Use an unchecked fetch of thread-specific data instead of a checked one.
 * It would fail if the key were bogus, but if the key were bogus then
 * Really Bad Things would be happening anyway. --dan */
#if (defined(__ALPHA) && (__VMS_VER >= 70000000)) || \
    (defined(__alpha) && defined(__osf__) && !defined(__GNUC__)) /* Available only on >= 4.0 */
#  define HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP /* Configure test needed */
#endif

#ifdef HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP
#  define PTHREAD_GETSPECIFIC(key) pthread_unchecked_getspecific_np(key)
#else
#    define PTHREAD_GETSPECIFIC(key) pthread_getspecific(key)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT	PTHREAD_GETSPECIFIC(PL_thr_key)
#endif

#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_setspecific(PL_thr_key, (void *)(t))))	\
	    Perl_croak_nocontext("panic: pthread_setspecific (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* PERL_SET_CONTEXT */

#ifndef INIT_THREADS
#  ifdef NEED_PTHREAD_INIT
#    define INIT_THREADS pthread_init()
#  endif
#endif

#ifndef ALLOC_THREAD_KEY
#  define ALLOC_THREAD_KEY \
    STMT_START {						\
	if (pthread_key_create(&PL_thr_key, 0)) {		\
            write(2, STR_WITH_LEN("panic: pthread_key_create failed\n")); \
	    exit(1);						\
	}							\
    } STMT_END
#endif

#ifndef FREE_THREAD_KEY
#  define FREE_THREAD_KEY \
    STMT_START {						\
	pthread_key_delete(PL_thr_key);				\
    } STMT_END
#endif

#ifndef PTHREAD_ATFORK
#  ifdef HAS_PTHREAD_ATFORK
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	pthread_atfork(prepare,parent,child)
#  else
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	NOOP
#  endif
#endif

#ifndef THREAD_RET_TYPE
#  define THREAD_RET_TYPE	void *
#  define THREAD_RET_CAST(p)	((void *)(p))
#endif /* THREAD_RET */

#  define LOCK_DOLLARZERO_MUTEX		MUTEX_LOCK(&PL_dollarzero_mutex)
#  define UNLOCK_DOLLARZERO_MUTEX	MUTEX_UNLOCK(&PL_dollarzero_mutex)

#endif /* USE_ITHREADS */

#ifndef MUTEX_LOCK
#  define MUTEX_LOCK(m)
#endif

#ifndef MUTEX_UNLOCK
#  define MUTEX_UNLOCK(m)
#endif

#ifndef MUTEX_INIT
#  define MUTEX_INIT(m)
#endif

#ifndef MUTEX_DESTROY
#  define MUTEX_DESTROY(m)
#endif

#ifndef COND_INIT
#  define COND_INIT(c)
#endif

#ifndef COND_SIGNAL
#  define COND_SIGNAL(c)
#endif

#ifndef COND_BROADCAST
#  define COND_BROADCAST(c)
#endif

#ifndef COND_WAIT
#  define COND_WAIT(c, m)
#endif

#ifndef COND_DESTROY
#  define COND_DESTROY(c)
#endif

#ifndef LOCK_SV_MUTEX
#  define LOCK_SV_MUTEX
#endif

#ifndef UNLOCK_SV_MUTEX
#  define UNLOCK_SV_MUTEX
#endif

#ifndef LOCK_STRTAB_MUTEX
#  define LOCK_STRTAB_MUTEX
#endif

#ifndef UNLOCK_STRTAB_MUTEX
#  define UNLOCK_STRTAB_MUTEX
#endif

#ifndef LOCK_CRED_MUTEX
#  define LOCK_CRED_MUTEX
#endif

#ifndef UNLOCK_CRED_MUTEX
#  define UNLOCK_CRED_MUTEX
#endif

#ifndef LOCK_FDPID_MUTEX
#  define LOCK_FDPID_MUTEX
#endif

#ifndef UNLOCK_FDPID_MUTEX
#  define UNLOCK_FDPID_MUTEX
#endif

#ifndef LOCK_SV_LOCK_MUTEX
#  define LOCK_SV_LOCK_MUTEX
#endif

#ifndef UNLOCK_SV_LOCK_MUTEX
#  define UNLOCK_SV_LOCK_MUTEX
#endif

#ifndef LOCK_DOLLARZERO_MUTEX
#  define LOCK_DOLLARZERO_MUTEX
#endif

#ifndef UNLOCK_DOLLARZERO_MUTEX
#  define UNLOCK_DOLLARZERO_MUTEX
#endif

/* THR, SET_THR, and dTHR are there for compatibility with old versions */
#ifndef THR
#  define THR		PERL_GET_THX
#endif

#ifndef SET_THR
#  define SET_THR(t)	PERL_SET_THX(t)
#endif

#ifndef dTHR
#  define dTHR dNOOP
#endif

#ifndef INIT_THREADS
#  define INIT_THREADS NOOP
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\uudmap.h ===
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\util.h ===
/*    util.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1999, 2001, 2002, 2003, 2004, 2005,
 *    2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifdef VMS
#  define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || (strchr(f,':')						\
	     || ((*(f) == '[' || *(f) == '<')				\
		 && (isALNUM((f)[1]) || strchr("$-_]>",(f)[1])))))

#else		/* !VMS */
#  if defined(WIN32) || defined(__CYGWIN__)
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/' || *(f) == '\\'		/* UNC/rooted path */	\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#  else		/* !WIN32 */
#  ifdef NETWARE
#    define PERL_FILE_IS_ABSOLUTE(f) \
	(((f)[0] && (f)[1] == ':')		/* drive name */	\
	 || ((f)[0] == '\\' && (f)[1] == '\\')	/* UNC path */	\
	 ||	((f)[3] == ':'))				/* volume name, currently only sys */
#  else		/* !NETWARE */
#    if defined(DOSISH) || defined(EPOC) || defined(__SYMBIAN32__)
#      define PERL_FILE_IS_ABSOLUTE(f) \
	(*(f) == '/'							\
	 || ((f)[0] && (f)[1] == ':'))		/* drive name */
#    else	/* NEITHER DOSISH NOR EPOCISH NOR SYMBIANISH */
#      ifdef MACOS_TRADITIONAL
#        define PERL_FILE_IS_ABSOLUTE(f)	(strchr(f, ':') && *(f) != ':')
#      else /* !MACOS_TRADITIONAL */
#        define PERL_FILE_IS_ABSOLUTE(f)	(*(f) == '/')
#      endif /* MACOS_TRADITIONAL */
#    endif	/* DOSISH */
#   endif	/* NETWARE */
#  endif	/* WIN32 */
#endif		/* VMS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\utfebcdic.h ===
/*    utfebcdic.h
 *
 *    Copyright (C) 2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall, Nick
 *    Ing-Simmons, and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Macros to implement UTF-EBCDIC as perl's internal encoding
 * Taken from version 7.1 of Unicode Techical Report #16:
 *  http://www.unicode.org/unicode/reports/tr16
 */

START_EXTERN_C

#ifdef DOINIT
/* Indexed by encoded byte this table gives the length of the sequence.
   Adapted from the shadow flags table in tr16.
   The entries marked 9 in tr6 are continuation bytes and are marked
   as length 1 here so that we can recover.
*/
#if '^' == 95   /* if defined(__MVS__) || defined(??) (VM/ESA?) 1047 */
EXTCONST unsigned char PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,1,2,2,
2,2,2,2,2,2,2,3,3,3,3,3,3,1,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,4,4,4,4,
1,4,1,1,1,1,1,1,1,1,4,4,4,5,5,5,
1,1,1,1,1,1,1,1,1,1,5,6,6,7,7,1
};
#endif

#if '^' == 106  /* if defined(_OSD_POSIX) POSIX-BC */
unsigned char PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,3,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,3,1,1,1,1,1,1,1,1,2,2,2,3,2,2,
1,2,2,2,2,2,2,3,3,3,2,1,1,1,3,3,
4,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,4,6,4,4,
7,4,1,1,1,1,1,1,1,1,4,4,4,5,5,5,
1,1,1,1,1,1,1,1,1,1,5,1,6,1,7,1
};
#endif

#if '^' == 176  /* if defined(??) (OS/400?) 037 */
unsigned char PL_utf8skip[] = {
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,1,1,1,1,1,1,1,1,1,2,2,2,3,2,2,
1,2,2,2,2,2,2,3,3,3,1,1,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,3,3,4,4,4,4,
1,4,1,1,1,1,1,1,1,1,4,4,4,5,5,5,
1,1,1,1,1,1,1,1,1,1,5,6,6,7,7,1
};
#endif

/* Transform tables from tr16 applied after encoding to render encoding EBCDIC like */

#if '^' == 95   /* if defined(__MVS__) || defined(??) (VM/ESA?) 1047 */
EXTCONST unsigned char PL_utf2e[] = { /* UTF-8-mod to EBCDIC (IBM-1047) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
 0x57, 0x58, 0x59, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x70, 0x71, 0x72, 0x73,
 0x74, 0x75, 0x76, 0x77, 0x78, 0x80, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x9A, 0x9B, 0x9C,
 0x9D, 0x9E, 0x9F, 0xA0, 0xAA, 0xAB, 0xAC, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xDA, 0xDB,
 0xDC, 0xDD, 0xDE, 0xDF, 0xE1, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,
};

EXTCONST unsigned char PL_e2utf[] = { /* EBCDIC (IBM-1047) to UTF-8-mod */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
 0x2D, 0x2F, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xC5, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB,
 0xCC, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
 0xD3, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xD4, 0xD5, 0xD6, 0x5B, 0xD7, 0xD8,
 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0x5D, 0xE6, 0xE7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3,
 0x5C, 0xF4, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x9F,
};
#endif /* 1047 */

#if '^' == 106  /* if defined(_OSD_POSIX) POSIX-BC */
unsigned char PL_utf2e[] = { /* UTF-8-mod to EBCDIC (POSIX-BC) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBB, 0xBC, 0xBD, 0x6A, 0x6D,
 0x4A, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xFB, 0x4F, 0xFD, 0xFF, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0x5F,
 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xB0, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
 0x57, 0x58, 0x59, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xD0, 0x70, 0x71, 0x72, 0x73,
 0x74, 0x75, 0x76, 0x77, 0x78, 0x80, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x9A, 0x9B, 0x9C,
 0x9D, 0x9E, 0x9F, 0xA0, 0xAA, 0xAB, 0xAC, 0xAE, 0xAF, 0xBA, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
 0xB7, 0xB8, 0xB9, 0xAD, 0x79, 0xA1, 0xBE, 0xBF, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xDA, 0xDB,
 0xDC, 0xC0, 0xDE, 0xDF, 0xE1, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xFA, 0xDD, 0xFC, 0xE0, 0xFE,
};

unsigned char PL_e2utf[] = { /* EBCDIC (POSIX-BC) to UTF-8-mod */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0x60, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x9F,
 0x2D, 0x2F, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0x5E, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xE4, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xC5, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB,
 0xCC, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
 0xD3, 0xE5, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xD4, 0xD5, 0xD6, 0xE3, 0xD7, 0xD8,
 0xA9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xD9, 0x5B, 0x5C, 0x5D, 0xE6, 0xE7,
 0xF1, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
 0xBB, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xEE, 0xEF, 0xF0, 0xFC, 0xF2, 0xF3,
 0xFE, 0xF4, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xFB, 0x7B, 0xFD, 0x7D, 0xFF, 0x7E,
};
#endif /* POSIX-BC */

#if '^' == 176  /* if defined(??) (OS/400?) 037 */
unsigned char PL_utf2e[] = { /* UTF-8-mod to EBCDIC (IBM-037) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x25, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBA, 0xE0, 0xBB, 0xB0, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x15, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56,
 0x57, 0x58, 0x59, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x70, 0x71, 0x72, 0x73,
 0x74, 0x75, 0x76, 0x77, 0x78, 0x80, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x9A, 0x9B, 0x9C,
 0x9D, 0x9E, 0x9F, 0xA0, 0xAA, 0xAB, 0xAC, 0xAE, 0xAF, 0x5F, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
 0xB7, 0xB8, 0xB9, 0xAD, 0xBD, 0xBC, 0xBE, 0xBF, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xDA, 0xDB,
 0xDC, 0xDD, 0xDE, 0xDF, 0xE1, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,
};

unsigned char PL_e2utf[] = { /* EBCDIC (IBM-037) to UTF-8-mod */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x85, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x0A, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0xD9,
 0x2D, 0x2F, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xC5, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB,
 0xCC, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
 0xD3, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xD4, 0xD5, 0xD6, 0xE3, 0xD7, 0xD8,
 0x5E, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0x5B, 0x5D, 0xE5, 0xE4, 0xE6, 0xE7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3,
 0x5C, 0xF4, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x9F,
};
#endif          /* 037 */

/* These tables moved from perl.h and converted to hex.
   They map platfrom code page from/to bottom 256 codes of Unicode (i.e. iso-8859-1).
*/

#if '^' == 95   /* if defined(__MVS__) || defined(??) (VM/ESA?) 1047 */
EXTCONST unsigned char PL_a2e[] = { /* ASCII (iso-8859-1) to EBCDIC (IBM-1047) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0xAA, 0x4A, 0xB1, 0x9F, 0xB2, 0x6A, 0xB5, 0xBB, 0xB4, 0x9A, 0x8A, 0xB0, 0xCA, 0xAF, 0xBC,
 0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3, 0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
 0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68, 0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
 0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF, 0x80, 0xFD, 0xFE, 0xFB, 0xFC, 0xBA, 0xAE, 0x59,
 0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48, 0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
 0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1, 0x70, 0xDD, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
};

EXTCONST unsigned char PL_e2a[] = { /* EBCDIC (IBM-1047) to ASCII (iso-8859-1) */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0xA2, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
 0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
 0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
 0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0x5B, 0xDE, 0xAE,
 0xAC, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0xDD, 0xA8, 0xAF, 0x5D, 0xB4, 0xD7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
 0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA, 0x9F
};
#endif /* 1047 */

#if '^' == 106  /* if defined(_OSD_POSIX) POSIX-BC */
EXTCONST unsigned char PL_a2e[] = { /* ASCII (ISO8859-1) to EBCDIC (POSIX-BC) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBB, 0xBC, 0xBD, 0x6A, 0x6D,
 0x4A, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xFB, 0x4F, 0xFD, 0xFF, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0x5F,
 0x41, 0xAA, 0xB0, 0xB1, 0x9F, 0xB2, 0xD0, 0xB5, 0x79, 0xB4, 0x9A, 0x8A, 0xBA, 0xCA, 0xAF, 0xA1,
 0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3, 0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
 0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68, 0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
 0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF, 0x80, 0xE0, 0xFE, 0xDD, 0xFC, 0xAD, 0xAE, 0x59,
 0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48, 0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
 0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1, 0x70, 0xC0, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
};

EXTCONST unsigned char PL_e2a[] = { /* EBCDIC (POSIX-BC) to ASCII (ISO8859-1) */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0x60, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x9F,
 0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0x5E, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0xA8, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
 0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
 0xB5, 0xAF, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,
 0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0xAC, 0x5B, 0x5C, 0x5D, 0xB4, 0xD7,
 0xF9, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
 0xA6, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xDB, 0xFA, 0xFF,
 0xD9, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0x7B, 0xDC, 0x7D, 0xDA, 0x7E
};
#endif          /* POSIX-BC */

#if '^' == 176  /* if defined(??) (OS/400?) 037 */
EXTCONST unsigned char PL_a2e[] = { /* ASCII (ISO8859-1) to EBCDIC (IBM-037) */
 0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F, 0x16, 0x05, 0x25, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26, 0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D, 0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xBA, 0xE0, 0xBB, 0xB0, 0x6D,
 0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x15, 0x06, 0x17, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,
 0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08, 0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,
 0x41, 0xAA, 0x4A, 0xB1, 0x9F, 0xB2, 0x6A, 0xB5, 0xBD, 0xB4, 0x9A, 0x8A, 0x5F, 0xCA, 0xAF, 0xBC,
 0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3, 0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,
 0x64, 0x65, 0x62, 0x66, 0x63, 0x67, 0x9E, 0x68, 0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,
 0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xEC, 0xBF, 0x80, 0xFD, 0xFE, 0xFB, 0xFC, 0xAD, 0xAE, 0x59,
 0x44, 0x45, 0x42, 0x46, 0x43, 0x47, 0x9C, 0x48, 0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,
 0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0xCC, 0xE1, 0x70, 0xDD, 0xDE, 0xDB, 0xDC, 0x8D, 0x8E, 0xDF
};

EXTCONST unsigned char PL_e2a[] = { /* EBCDIC (IBM-037) to ASCII (ISO8859-1) */
 0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F, 0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 0x10, 0x11, 0x12, 0x13, 0x9D, 0x85, 0x08, 0x87, 0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x0A, 0x17, 0x1B, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,
 0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,
 0x20, 0xA0, 0xE2, 0xE4, 0xE0, 0xE1, 0xE3, 0xE5, 0xE7, 0xF1, 0xA2, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF, 0xEC, 0xDF, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0xAC,
 0x2D, 0x2F, 0xC2, 0xC4, 0xC0, 0xC1, 0xC3, 0xC5, 0xC7, 0xD1, 0xA6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,
 0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,
 0xB5, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,
 0x5E, 0xA3, 0xA5, 0xB7, 0xA9, 0xA7, 0xB6, 0xBC, 0xBD, 0xBE, 0x5B, 0x5D, 0xAF, 0xA8, 0xB4, 0xD7,
 0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0xAD, 0xF4, 0xF6, 0xF2, 0xF3, 0xF5,
 0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0xB9, 0xFB, 0xFC, 0xF9, 0xFA, 0xFF,
 0x5C, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0xB2, 0xD4, 0xD6, 0xD2, 0xD3, 0xD5,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0xB3, 0xDB, 0xDC, 0xD9, 0xDA, 0x9F
};
#endif          /* 037 */

#else
EXTCONST unsigned char PL_utf8skip[];
EXTCONST unsigned char PL_e2utf[];
EXTCONST unsigned char PL_utf2e[];
EXTCONST unsigned char PL_e2a[];
EXTCONST unsigned char PL_a2e[];
#endif

END_EXTERN_C

#define UTF8SKIP(s) PL_utf8skip[*(const U8*)(s)]

/* EBCDIC-happy ways of converting native code to UTF-8 */

/* Native to iso-8859-1 */
#define NATIVE_TO_ASCII(ch)      PL_e2a[(U8)(ch)]
#define ASCII_TO_NATIVE(ch)      PL_a2e[(U8)(ch)]
/* Transform after encoding */
#define NATIVE_TO_UTF(ch)        PL_e2utf[(U8)(ch)]
#define UTF_TO_NATIVE(ch)        PL_utf2e[(U8)(ch)]
/* Transform in wide UV char space */
#define NATIVE_TO_UNI(ch)        (((ch) > 255) ? (ch) : NATIVE_TO_ASCII(ch))
#define UNI_TO_NATIVE(ch)        (((ch) > 255) ? (ch) : ASCII_TO_NATIVE(ch))
/* Transform in invariant..byte space */
#define NATIVE_TO_NEED(enc,ch)   ((enc) ? UTF_TO_NATIVE(NATIVE_TO_ASCII(ch)) : (ch))
#define ASCII_TO_NEED(enc,ch)    ((enc) ? UTF_TO_NATIVE(ch) : ASCII_TO_NATIVE(ch))

/*
 * Note: we should try and be careful never to call the isXXX_utf8() functions
 * unless we're pretty sure we've seen the beginning of a UTF-EBCDIC character
 * Otherwise we risk loading in the heavy-duty swash_init and swash_fetch
 * routines unnecessarily.
 */

#define isIDFIRST_lazy_if(p,c) ((IN_BYTES || (!c || UTF8_IS_INVARIANT(*p))) \
				? isIDFIRST(*(p)) \
				: isIDFIRST_utf8((const U8*)p))
#define isALNUM_lazy_if(p,c)   ((IN_BYTES || (!c || UTF8_IS_INVARIANT(*p))) \
				? isALNUM(*(p)) \
				: isALNUM_utf8((const U8*)p))

/*
  The following table is adapted from tr16, it shows UTF-8-mod encoding of Unicode code points.

        Unicode                             Bit pattern 1st Byte 2nd Byte 3rd Byte 4th Byte 5th Byte 6th Byte 7th byte
    U+0000..U+007F                     000000000xxxxxxx 0xxxxxxx
    U+0080..U+009F                     00000000100xxxxx 100xxxxx
    U+00A0..U+00FF                     00000000yyyxxxxx 11000yyy 101xxxxx

    U+00A0..U+03FF                     000000yyyyyxxxxx 110yyyyy 101xxxxx
    U+0400..U+3FFF                     00zzzzyyyyyxxxxx 1110zzzz 101yyyyy 101xxxxx
    U+4000..U+3FFFF                 0wwwzzzzzyyyyyxxxxx 11110www 101zzzzz 101yyyyy 101xxxxx
   U+40000..U+3FFFFF            0vvwwwwwzzzzzyyyyyxxxxx 111110vv 101wwwww 101zzzzz 101yyyyy 101xxxxx
  U+400000..U+3FFFFFF       0uvvvvvwwwwwzzzzzyyyyyxxxxx 1111110u 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx
 U+4000000..U+7FFFFFFF 0tuuuuuvvvvvwwwwwzzzzzyyyyyxxxxx 1111111t 101uuuuu 101vvvvv 101wwwww 101zzzzz 101yyyyy 101xxxxx

  Note: The UTF-8-Mod transformation is valid for UCS-4 values X'0' to
  X'7FFFFFFF' (the full extent of ISO/IEC 10646 coding space).

 */

#define UNISKIP(uv) ( (uv) < 0xA0           ? 1 : \
		      (uv) < 0x400          ? 2 : \
		      (uv) < 0x4000         ? 3 : \
		      (uv) < 0x40000        ? 4 : \
		      (uv) < 0x400000       ? 5 : \
		      (uv) < 0x4000000      ? 6 : 7 )


#define UNI_IS_INVARIANT(c)		((c) <  0xA0)
/* UTF-EBCDIC sematic macros - transform back into UTF-8-Mod and then compare */
#define NATIVE_IS_INVARIANT(c)		UNI_IS_INVARIANT(NATIVE_TO_ASCII(c))
#define UTF8_IS_INVARIANT(c)		UNI_IS_INVARIANT(NATIVE_TO_UTF(c))
#define UTF8_IS_START(c)		(NATIVE_TO_UTF(c) >= 0xA0 && (NATIVE_TO_UTF(c) & 0xE0) != 0xA0)
#define UTF8_IS_CONTINUATION(c)		((NATIVE_TO_UTF(c) & 0xE0) == 0xA0)
#define UTF8_IS_CONTINUED(c) 		(NATIVE_TO_UTF(c) >= 0xA0)
#define UTF8_IS_DOWNGRADEABLE_START(c)	(NATIVE_TO_UTF(c) >= 0xA0 && (NATIVE_TO_UTF(c) & 0xF8) == 0xC0)

#define UTF_START_MARK(len) ((len >  7) ? 0xFF : (0xFE << (7-len)))
#define UTF_START_MASK(len) ((len >= 6) ? 0x01 : (0x1F >> (len-2)))
#define UTF_CONTINUATION_MARK		0xA0
#define UTF_CONTINUATION_MASK		((U8)0x1f)
#define UTF_ACCUMULATION_SHIFT		5

#define UTF8_ACCUMULATE(old, new)	(((old) << UTF_ACCUMULATION_SHIFT)|(NATIVE_TO_UTF(new) & UTF_CONTINUATION_MASK))

/* UTF-EBCDIC encode a downgradeable value */
#define UTF8_EIGHT_BIT_HI(c)	UTF_TO_NATIVE((((U8)(c))>>UTF_ACCUMULATION_SHIFT)|UTF_START_MARK(2))
#define UTF8_EIGHT_BIT_LO(c)	UTF_TO_NATIVE(((((U8)(c)))&UTF_CONTINUATION_MASK)|UTF_CONTINUATION_MARK)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\vdir.h ===
/* vdir.h
 *
 * (c) 1999 Microsoft Corporation. All rights reserved. 
 * Portions (c) 1999 ActiveState Tool Corp, http://www.ActiveState.com/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

#ifndef ___VDir_H___
#define ___VDir_H___

/*
 * Allow one slot for each possible drive letter
 * and one additional slot for a UNC name
 */
const int driveCount = ('Z'-'A')+1+1;

class VDir
{
public:
    VDir(int bManageDir = 1);
    ~VDir() {};

    void Init(VDir* pDir, VMem *pMem);
    void SetDefaultA(char const *pDefault);
    void SetDefaultW(WCHAR const *pDefault);
    char* MapPathA(const char *pInName);
    WCHAR* MapPathW(const WCHAR *pInName);
    int SetCurrentDirectoryA(char *lpBuffer);
    int SetCurrentDirectoryW(WCHAR *lpBuffer);
    inline int GetDefault(void) { return nDefault; };

    inline char* GetCurrentDirectoryA(int dwBufSize, char *lpBuffer)
    {
	char* ptr = dirTableA[nDefault];
	while (--dwBufSize)
	{
	    if ((*lpBuffer++ = *ptr++) == '\0')
		break;
	}
        *lpBuffer = '\0';
	return /* unused */ NULL;
    };
    inline WCHAR* GetCurrentDirectoryW(int dwBufSize, WCHAR *lpBuffer)
    {
	WCHAR* ptr = dirTableW[nDefault];
	while (--dwBufSize)
	{
	    if ((*lpBuffer++ = *ptr++) == '\0')
		break;
	}
        *lpBuffer = '\0';
	return /* unused */ NULL;
    };

    DWORD CalculateEnvironmentSpace(void);
    LPSTR BuildEnvironmentSpace(LPSTR lpStr);

protected:
    int SetDirA(char const *pPath, int index);
    int SetDirW(WCHAR const *pPath, int index);
    void FromEnvA(char *pEnv, int index);
    void FromEnvW(WCHAR *pEnv, int index);

    inline const char *GetDefaultDirA(void)
    {
	return dirTableA[nDefault];
    };
    inline void SetDefaultDirA(char const *pPath, int index)
    {
	SetDirA(pPath, index);
	nDefault = index;
    };
    inline const WCHAR *GetDefaultDirW(void)
    {
	return dirTableW[nDefault];
    };
    inline void SetDefaultDirW(WCHAR const *pPath, int index)
    {
	SetDirW(pPath, index);
	nDefault = index;
    };
    inline const char *GetDirA(int index)
    {
	char *ptr = dirTableA[index];
	if (!ptr) {
	    /* simulate the existance of this drive */
	    ptr = szLocalBufferA;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };
    inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    /* simulate the existance of this drive */
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };

    inline int DriveIndex(char chr)
    {
	if (chr == '\\' || chr == '/')
	    return ('Z'-'A')+1;
	return (chr | 0x20)-'a';
    };

    VMem *pMem;
    int nDefault, bManageDirectory;
    char *dirTableA[driveCount];
    char szLocalBufferA[MAX_PATH+1];
    WCHAR *dirTableW[driveCount];
    WCHAR szLocalBufferW[MAX_PATH+1];
};


VDir::VDir(int bManageDir /* = 1 */)
{
    nDefault = 0;
    bManageDirectory = bManageDir;
    memset(dirTableA, 0, sizeof(dirTableA));
    memset(dirTableW, 0, sizeof(dirTableW));
}

void VDir::Init(VDir* pDir, VMem *p)
{
    int index;

    pMem = p;
    if (pDir) {
	for (index = 0; index < driveCount; ++index) {
	    SetDirW(pDir->GetDirW(index), index);
	}
	nDefault = pDir->GetDefault();
    }
    else {
	int bSave = bManageDirectory;
	DWORD driveBits = GetLogicalDrives();
        OSVERSIONINFO osver;

        memset(&osver, 0, sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        GetVersionEx(&osver);

	bManageDirectory = 0;
        if (osver.dwMajorVersion < 5) {
            char szBuffer[MAX_PATH*driveCount];
            if (GetLogicalDriveStringsA(sizeof(szBuffer), szBuffer)) {
                char* pEnv = (char*)GetEnvironmentStringsA();
                char* ptr = szBuffer;
                for (index = 0; index < driveCount; ++index) {
                    if (driveBits & (1<<index)) {
                        ptr += SetDirA(ptr, index) + 1;
                        FromEnvA(pEnv, index);
                    }
                }
                FreeEnvironmentStringsA(pEnv);
            }
            SetDefaultA(".");
        }
        else { /* Windows 2000 or later */
            WCHAR szBuffer[MAX_PATH*driveCount];
            if (GetLogicalDriveStringsW(sizeof(szBuffer), szBuffer)) {
                WCHAR* pEnv = GetEnvironmentStringsW();
                WCHAR* ptr = szBuffer;
                for (index = 0; index < driveCount; ++index) {
                    if (driveBits & (1<<index)) {
                        ptr += SetDirW(ptr, index) + 1;
                        FromEnvW(pEnv, index);
                    }
                }
                FreeEnvironmentStringsW(pEnv);
            }
            SetDefaultW(L".");
        }
	bManageDirectory = bSave;
  }
}

int VDir::SetDirA(char const *pPath, int index)
{
    char chr, *ptr;
    int length = 0;
    WCHAR wBuffer[MAX_PATH+1];
    if (index < driveCount && pPath != NULL) {
	length = strlen(pPath);
	pMem->Free(dirTableA[index]);
	ptr = dirTableA[index] = (char*)pMem->Malloc(length+2);
	if (ptr != NULL) {
	    strcpy(ptr, pPath);
	    ptr += length-1;
	    chr = *ptr++;
	    if (chr != '\\' && chr != '/') {
		*ptr++ = '\\';
		*ptr = '\0';
	    }
	    MultiByteToWideChar(CP_ACP, 0, dirTableA[index], -1,
		    wBuffer, (sizeof(wBuffer)/sizeof(WCHAR)));
	    length = wcslen(wBuffer);
	    pMem->Free(dirTableW[index]);
	    dirTableW[index] = (WCHAR*)pMem->Malloc((length+1)*2);
	    if (dirTableW[index] != NULL) {
		wcscpy(dirTableW[index], wBuffer);
	    }
	}
    }

    if(bManageDirectory)
	::SetCurrentDirectoryA(pPath);

    return length;
}

void VDir::FromEnvA(char *pEnv, int index)
{   /* gets the directory for index from the environment variable. */
    while (*pEnv != '\0') {
	if ((pEnv[0] == '=') && (DriveIndex(pEnv[1]) == index)) {
	    SetDirA(&pEnv[4], index);
	    break;
	}
	else
	    pEnv += strlen(pEnv)+1;
    }
}

void VDir::FromEnvW(WCHAR *pEnv, int index)
{   /* gets the directory for index from the environment variable. */
    while (*pEnv != '\0') {
	if ((pEnv[0] == '=') && (DriveIndex((char)pEnv[1]) == index)) {
	    SetDirW(&pEnv[4], index);
	    break;
	}
	else
	    pEnv += wcslen(pEnv)+1;
    }
}

void VDir::SetDefaultA(char const *pDefault)
{
    char szBuffer[MAX_PATH+1];
    char *pPtr;

    if (GetFullPathNameA(pDefault, sizeof(szBuffer), szBuffer, &pPtr)) {
        if (*pDefault != '.' && pPtr != NULL)
	    *pPtr = '\0';

	SetDefaultDirA(szBuffer, DriveIndex(szBuffer[0]));
    }
}

int VDir::SetDirW(WCHAR const *pPath, int index)
{
    WCHAR chr, *ptr;
    int length = 0;
    if (index < driveCount && pPath != NULL) {
	length = wcslen(pPath);
	pMem->Free(dirTableW[index]);
	ptr = dirTableW[index] = (WCHAR*)pMem->Malloc((length+2)*2);
	if (ptr != NULL) {
            char *ansi;
	    wcscpy(ptr, pPath);
	    ptr += length-1;
	    chr = *ptr++;
	    if (chr != '\\' && chr != '/') {
		*ptr++ = '\\';
		*ptr = '\0';
	    }
            ansi = win32_ansipath(dirTableW[index]);
	    length = strlen(ansi);
	    pMem->Free(dirTableA[index]);
	    dirTableA[index] = (char*)pMem->Malloc(length+1);
	    if (dirTableA[index] != NULL) {
		strcpy(dirTableA[index], ansi);
	    }
            win32_free(ansi);
	}
    }

    if(bManageDirectory)
	::SetCurrentDirectoryW(pPath);

    return length;
}

void VDir::SetDefaultW(WCHAR const *pDefault)
{
    WCHAR szBuffer[MAX_PATH+1];
    WCHAR *pPtr;

    if (GetFullPathNameW(pDefault, (sizeof(szBuffer)/sizeof(WCHAR)), szBuffer, &pPtr)) {
        if (*pDefault != '.' && pPtr != NULL)
	    *pPtr = '\0';

	SetDefaultDirW(szBuffer, DriveIndex((char)szBuffer[0]));
    }
}

inline BOOL IsPathSep(char ch)
{
    return (ch == '\\' || ch == '/');
}

inline void DoGetFullPathNameA(char* lpBuffer, DWORD dwSize, char* Dest)
{
    char *pPtr;

    /*
     * On WinNT GetFullPathName does not fail, (or at least always
     * succeeds when the drive is valid) WinNT does set *Dest to Nullch
     * On Win98 GetFullPathName will set last error if it fails, but
     * does not touch *Dest
     */
    *Dest = '\0';
    GetFullPathNameA(lpBuffer, dwSize, Dest, &pPtr);
}

inline bool IsSpecialFileName(const char* pName)
{
    /* specical file names are devices that the system can open
     * these include AUX, CON, NUL, PRN, COMx, LPTx, CLOCK$, CONIN$, CONOUT$
     * (x is a single digit, and names are case-insensitive)
     */
    char ch = (pName[0] & ~0x20);
    switch (ch)
    {
	case 'A': /* AUX */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& !pName[3])
		    return true;
	    break;
	case 'C': /* CLOCK$, COMx,  CON, CONIN$ CONOUT$ */
	    ch = (pName[1] & ~0x20);
	    switch (ch)
	    {
		case 'L': /* CLOCK$ */
		    if (((pName[2] & ~0x20) == 'O')
			&& ((pName[3] & ~0x20) == 'C')
			&& ((pName[4] & ~0x20) == 'K')
			&& (pName[5] == '$')
			&& !pName[6])
			    return true;
		    break;
		case 'O': /* COMx,  CON, CONIN$ CONOUT$ */
		    if ((pName[2] & ~0x20) == 'M') {
			if ((pName[3] >= '1') && (pName[3] <= '9')
			    && !pName[4])
			    return true;
		    }
		    else if ((pName[2] & ~0x20) == 'N') {
			if (!pName[3])
			    return true;
			else if ((pName[3] & ~0x20) == 'I') {
			    if (((pName[4] & ~0x20) == 'N')
				&& (pName[5] == '$')
				&& !pName[6])
			    return true;
			}
			else if ((pName[3] & ~0x20) == 'O') {
			    if (((pName[4] & ~0x20) == 'U')
				&& ((pName[5] & ~0x20) == 'T')
				&& (pName[6] == '$')
				&& !pName[7])
			    return true;
			}
		    }
		    break;
	    }
	    break;
	case 'L': /* LPTx */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& (pName[3] >= '1') && (pName[3] <= '9')
		&& !pName[4])
		    return true;
	    break;
	case 'N': /* NUL */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'L')
		&& !pName[3])
		    return true;
	    break;
	case 'P': /* PRN */
	    if (((pName[1] & ~0x20) == 'R')
		&& ((pName[2] & ~0x20) == 'N')
		&& !pName[3])
		    return true;
	    break;
    }
    return false;
}

char *VDir::MapPathA(const char *pInName)
{   /*
     * possiblities -- relative path or absolute path with or without drive letter
     * OR UNC name
     */
    char szBuffer[(MAX_PATH+1)*2];
    char szlBuf[MAX_PATH+1];
    int length = strlen(pInName);

    if (!length)
	return (char*)pInName;

    if (length > MAX_PATH) {
	strncpy(szlBuf, pInName, MAX_PATH);
	if (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   
	    /* absolute path - reduce length by 2 for drive specifier */
	    szlBuf[MAX_PATH-2] = '\0';
	}
	else
	    szlBuf[MAX_PATH] = '\0';
	pInName = szlBuf;
    }
    /* strlen(pInName) is now <= MAX_PATH */

    if (pInName[1] == ':') {
	/* has drive letter */
	if (IsPathSep(pInName[2])) {
	    /* absolute with drive letter */
	    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);
	}
	else {
	    /* relative path with drive letter */
	    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));
	    strcat(szBuffer, &pInName[2]);
	    if(strlen(szBuffer) > MAX_PATH)
		szBuffer[MAX_PATH] = '\0';

	    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
	}
    }
    else {
	/* no drive letter */
	if (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {
	    /* UNC name */
	    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);
	}
	else {
	    strcpy(szBuffer, GetDefaultDirA());
	    if (IsPathSep(pInName[0])) {
		/* absolute path */
		strcpy(&szBuffer[2], pInName);
		DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
	    }
	    else {
		/* relative path */
		if (IsSpecialFileName(pInName)) {
		    return (char*)pInName;
		}
		else {
		    strcat(szBuffer, pInName);
		    if (strlen(szBuffer) > MAX_PATH)
			szBuffer[MAX_PATH] = '\0';

		    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
		}
	    }
	}
    }

    return szLocalBufferA;
}

int VDir::SetCurrentDirectoryA(char *lpBuffer)
{
    char *pPtr;
    int length, nRet = -1;

    pPtr = MapPathA(lpBuffer);
    length = strlen(pPtr);
    if(length > 3 && IsPathSep(pPtr[length-1])) {
	/* don't remove the trailing slash from 'x:\'  */
	pPtr[length-1] = '\0';
    }

    DWORD r = GetFileAttributesA(pPtr);
    if ((r != 0xffffffff) && (r & FILE_ATTRIBUTE_DIRECTORY))
    {
	char szBuffer[(MAX_PATH+1)*2];
	DoGetFullPathNameA(pPtr, sizeof(szBuffer), szBuffer);
	SetDefaultDirA(szBuffer, DriveIndex(szBuffer[0]));
	nRet = 0;
    }

    return nRet;
}

DWORD VDir::CalculateEnvironmentSpace(void)
{   /* the current directory environment strings are stored as '=D:=d:\path' */
    int index;
    DWORD dwSize = 0;
    for (index = 0; index < driveCount; ++index) {
	if (dirTableA[index] != NULL) {
	    dwSize += strlen(dirTableA[index]) + 5;  /* add 1 for trailing NULL and 4 for '=D:=' */
	}
    }
    return dwSize;
}

LPSTR VDir::BuildEnvironmentSpace(LPSTR lpStr)
{   /* store the current directory environment strings as '=D:=d:\path' */
    int index, length;
    LPSTR lpDirStr;
    for (index = 0; index < driveCount; ++index) {
	lpDirStr = dirTableA[index];
	if (lpDirStr != NULL) {
	    lpStr[0] = '=';
	    lpStr[1] = lpDirStr[0];
	    lpStr[2] = '\0';
	    CharUpper(&lpStr[1]);
	    lpStr[2] = ':';
	    lpStr[3] = '=';
	    strcpy(&lpStr[4], lpDirStr);
	    length = strlen(lpDirStr);
	    lpStr += length + 5; /* add 1 for trailing NULL and 4 for '=D:=' */
	    if (length > 3 && IsPathSep(lpStr[-2])) {
		lpStr[-2] = '\0';   /* remove the trailing path separator */
		--lpStr;
	    }
	}
    }
    return lpStr;
}

inline BOOL IsPathSep(WCHAR ch)
{
    return (ch == '\\' || ch == '/');
}

inline void DoGetFullPathNameW(WCHAR* lpBuffer, DWORD dwSize, WCHAR* Dest)
{
    WCHAR *pPtr;

    /*
     * On WinNT GetFullPathName does not fail, (or at least always
     * succeeds when the drive is valid) WinNT does set *Dest to Nullch
     * On Win98 GetFullPathName will set last error if it fails, but
     * does not touch *Dest
     */
    *Dest = '\0';
    GetFullPathNameW(lpBuffer, dwSize, Dest, &pPtr);
}

inline bool IsSpecialFileName(const WCHAR* pName)
{
    /* specical file names are devices that the system can open
     * these include AUX, CON, NUL, PRN, COMx, LPTx, CLOCK$, CONIN$, CONOUT$
     * (x is a single digit, and names are case-insensitive)
     */
    WCHAR ch = (pName[0] & ~0x20);
    switch (ch)
    {
	case 'A': /* AUX */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& !pName[3])
		    return true;
	    break;
	case 'C': /* CLOCK$, COMx,  CON, CONIN$ CONOUT$ */
	    ch = (pName[1] & ~0x20);
	    switch (ch)
	    {
		case 'L': /* CLOCK$ */
		    if (((pName[2] & ~0x20) == 'O')
			&& ((pName[3] & ~0x20) == 'C')
			&& ((pName[4] & ~0x20) == 'K')
			&& (pName[5] == '$')
			&& !pName[6])
			    return true;
		    break;
		case 'O': /* COMx,  CON, CONIN$ CONOUT$ */
		    if ((pName[2] & ~0x20) == 'M') {
			if ((pName[3] >= '1') && (pName[3] <= '9')
			    && !pName[4])
			    return true;
		    }
		    else if ((pName[2] & ~0x20) == 'N') {
			if (!pName[3])
			    return true;
			else if ((pName[3] & ~0x20) == 'I') {
			    if (((pName[4] & ~0x20) == 'N')
				&& (pName[5] == '$')
				&& !pName[6])
			    return true;
			}
			else if ((pName[3] & ~0x20) == 'O') {
			    if (((pName[4] & ~0x20) == 'U')
				&& ((pName[5] & ~0x20) == 'T')
				&& (pName[6] == '$')
				&& !pName[7])
			    return true;
			}
		    }
		    break;
	    }
	    break;
	case 'L': /* LPTx */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& (pName[3] >= '1') && (pName[3] <= '9')
		&& !pName[4])
		    return true;
	    break;
	case 'N': /* NUL */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'L')
		&& !pName[3])
		    return true;
	    break;
	case 'P': /* PRN */
	    if (((pName[1] & ~0x20) == 'R')
		&& ((pName[2] & ~0x20) == 'N')
		&& !pName[3])
		    return true;
	    break;
    }
    return false;
}

WCHAR* VDir::MapPathW(const WCHAR *pInName)
{   /*
     * possiblities -- relative path or absolute path with or without drive letter
     * OR UNC name
     */
    WCHAR szBuffer[(MAX_PATH+1)*2];
    WCHAR szlBuf[MAX_PATH+1];
    int length = wcslen(pInName);

    if (!length)
	return (WCHAR*)pInName;

    if (length > MAX_PATH) {
	wcsncpy(szlBuf, pInName, MAX_PATH);
	if (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   
	    /* absolute path - reduce length by 2 for drive specifier */
	    szlBuf[MAX_PATH-2] = '\0';
	}
	else
	    szlBuf[MAX_PATH] = '\0';
	pInName = szlBuf;
    }
    /* strlen(pInName) is now <= MAX_PATH */

    if (pInName[1] == ':') {
	/* has drive letter */
	if (IsPathSep(pInName[2])) {
	    /* absolute with drive letter */
	    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	}
	else {
	    /* relative path with drive letter */
	    wcscpy(szBuffer, GetDirW(DriveIndex((char)*pInName)));
	    wcscat(szBuffer, &pInName[2]);
	    if(wcslen(szBuffer) > MAX_PATH)
		szBuffer[MAX_PATH] = '\0';

	    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	}
    }
    else {
	/* no drive letter */
	if (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {
	    /* UNC name */
	    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	}
	else {
	    wcscpy(szBuffer, GetDefaultDirW());
	    if (IsPathSep(pInName[0])) {
		/* absolute path */
		wcscpy(&szBuffer[2], pInName);
		DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	    }
	    else {
		/* relative path */
		if (IsSpecialFileName(pInName)) {
		    return (WCHAR*)pInName;
		}
		else {
		    wcscat(szBuffer, pInName);
		    if (wcslen(szBuffer) > MAX_PATH)
			szBuffer[MAX_PATH] = '\0';

		    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
		}
	    }
	}
    }
    return szLocalBufferW;
}

int VDir::SetCurrentDirectoryW(WCHAR *lpBuffer)
{
    WCHAR *pPtr;
    int length, nRet = -1;

    pPtr = MapPathW(lpBuffer);
    length = wcslen(pPtr);
    if(length > 3 && IsPathSep(pPtr[length-1])) {
	/* don't remove the trailing slash from 'x:\'  */
	pPtr[length-1] = '\0';
    }

    DWORD r = GetFileAttributesW(pPtr);
    if ((r != 0xffffffff) && (r & FILE_ATTRIBUTE_DIRECTORY))
    {
	WCHAR wBuffer[(MAX_PATH+1)*2];
	DoGetFullPathNameW(pPtr, (sizeof(wBuffer)/sizeof(WCHAR)), wBuffer);
	SetDefaultDirW(wBuffer, DriveIndex((char)wBuffer[0]));
	nRet = 0;
    }

    return nRet;
}

#endif	/* ___VDir_H___ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\win32.h ===
/* WIN32.H
 *
 * (c) 1995 Microsoft Corporation. All rights reserved.
 * 		Developed by hip communications inc., http://info.hip.com/info/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */
#ifndef  _INC_WIN32_PERL5
#define  _INC_WIN32_PERL5

#include "BuildInfo.h"

#ifndef _WIN32_WINNT
#  define _WIN32_WINNT 0x0400     /* needed for TryEnterCriticalSection() etc. */
#endif

#if defined(PERL_IMPLICIT_SYS)
#  define DYNAMIC_ENV_FETCH
#  define HAS_GETENV_LEN
#  define prime_env_iter()
#  define WIN32IO_IS_STDIO		/* don't pull in custom stdio layer */
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
#  ifdef PERL_GLOBAL_STRUCT
#    error PERL_GLOBAL_STRUCT cannot be defined with PERL_IMPLICIT_SYS
#  endif
#  define win32_get_privlib PerlEnv_lib_path
#  define win32_get_sitelib PerlEnv_sitelib_path
#  define win32_get_vendorlib PerlEnv_vendorlib_path
#endif

#ifdef __GNUC__
#  ifndef __int64		/* some versions seem to #define it already */
#    define __int64 long long
#  endif
#  define Win32_Winsock
#ifdef __cplusplus
/* Mingw32 gcc -xc++ objects to __attribute((unused)) at least */
#undef  PERL_UNUSED_DECL
#define PERL_UNUSED_DECL
#endif
#endif


/* Define DllExport akin to perl's EXT,
 * If we are in the DLL or mimicing the DLL for Win95 work round
 * then Export the symbol,
 * otherwise import it.
 */

/* now even GCC supports __declspec() */

#if defined(PERLDLL) || defined(WIN95FIX)
#define DllExport
/*#define DllExport __declspec(dllexport)*/	/* noises with VC5+sp3 */
#else
#define DllExport __declspec(dllimport)
#endif

#define  WIN32_LEAN_AND_MEAN
#include <windows.h>

#ifdef   WIN32_LEAN_AND_MEAN		/* C file is NOT a Perl5 original. */
#define  CONTEXT	PERL_CONTEXT	/* Avoid conflict of CONTEXT defs. */
#endif /*WIN32_LEAN_AND_MEAN */

#ifndef TLS_OUT_OF_INDEXES
#define TLS_OUT_OF_INDEXES (DWORD)0xFFFFFFFF
#endif

#include <dirent.h>
#include <io.h>
#include <process.h>
#include <stdio.h>
#include <direct.h>
#include <stdlib.h>
#include <stddef.h>
#include <fcntl.h>
#ifndef EXT
#include "EXTERN.h"
#endif

struct tms {
	long	tms_utime;
	long	tms_stime;
	long	tms_cutime;
	long	tms_cstime;
};

#ifndef SYS_NMLN
#define SYS_NMLN	257
#endif

struct utsname {
    char sysname[SYS_NMLN];
    char nodename[SYS_NMLN];
    char release[SYS_NMLN];
    char version[SYS_NMLN];
    char machine[SYS_NMLN];
};

#ifndef START_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C
#endif
#endif

#define  STANDARD_C	1
#define  DOSISH		1		/* no escaping our roots */
#define  OP_BINARY	O_BINARY	/* mistake in in pp_sys.c? */

/* Define USE_SOCKETS_AS_HANDLES to enable emulation of windows sockets as
 * real filehandles. XXX Should always be defined (the other version is untested) */
#define USE_SOCKETS_AS_HANDLES

/* read() and write() aren't transparent for socket handles */
#define PERL_SOCK_SYSREAD_IS_RECV
#define PERL_SOCK_SYSWRITE_IS_SEND

#define PERL_NO_FORCE_LINK		/* no need for PL_force_link_funcs */

/* Define USE_FIXED_OSFHANDLE to fix MSVCRT's _open_osfhandle() on W95.
   It now uses some black magic to work seamlessly with the DLL CRT and
   works with MSVC++ 4.0+ or GCC/Mingw32
	-- BKS 1-24-2000
   Only use this fix for VC++ 6.x or earlier (and for GCC, which we assume
   uses MSVCRT.DLL). Later versions use MSVCR70.dll, MSVCR71.dll, etc, which
   do not require the fix. */
#if (defined(_M_IX86) && _MSC_VER >= 1000 && _MSC_VER <= 1200) || defined(__MINGW32__)
#define USE_FIXED_OSFHANDLE
#endif

/* Define PERL_WIN32_SOCK_DLOAD to have Perl dynamically load the winsock
   DLL when needed. Don't use if your compiler supports delayloading (ie, VC++ 6.0)
	-- BKS 5-29-2000 */
#if !(defined(_M_IX86) && _MSC_VER >= 1200)
#define PERL_WIN32_SOCK_DLOAD
#endif
#define ENV_IS_CASELESS

#define PIPESOCK_MODE	"b"		/* pipes, sockets default to binmode */

#ifndef VER_PLATFORM_WIN32_WINDOWS	/* VC-2.0 headers don't have this */
#define VER_PLATFORM_WIN32_WINDOWS	1
#endif

#ifndef FILE_SHARE_DELETE		/* VC-4.0 headers don't have this */
#define FILE_SHARE_DELETE		0x00000004
#endif

/* access() mode bits */
#ifndef R_OK
#  define	R_OK	4
#  define	W_OK	2
#  define	X_OK	1
#  define	F_OK	0
#endif

/* for waitpid() */
#ifndef WNOHANG
#  define WNOHANG	1
#endif

#define PERL_GET_CONTEXT_DEFINED

/* Compiler-specific stuff. */

#ifdef __BORLANDC__		/* Borland C++ */

#if (__BORLANDC__ <= 0x520)
#define _access access
#define _chdir chdir
#endif

#define _getpid getpid
#define wcsicmp _wcsicmp
#include <sys/types.h>

#ifndef DllMain
#define DllMain DllEntryPoint
#endif

#pragma warn -8004	/* "'foo' is assigned a value that is never used" */
#pragma warn -8008	/* "condition is always true/false" */
#pragma warn -8012	/* "comparing signed and unsigned values" */
#pragma warn -8027	/* "functions containing %s are not expanded inline" */
#pragma warn -8057	/* "parameter 'foo' is never used" */
#pragma warn -8060	/* "possibly incorrect assignment" */
#pragma warn -8066	/* "unreachable code" */
#pragma warn -8071	/* "conversion may lose significant digits" */
#pragma warn -8080	/* "'foo' is declared but never used" */

/* Borland C thinks that a pointer to a member variable is 12 bytes in size. */
#define PERL_MEMBER_PTR_SIZE	12

#define isnan		_isnan

#endif

#ifdef _MSC_VER			/* Microsoft Visual C++ */

#ifndef UNDER_CE
typedef long		uid_t;
typedef long		gid_t;
typedef unsigned short	mode_t;
#endif

#pragma  warning(disable: 4102)	/* "unreferenced label" */

/* Visual C thinks that a pointer to a member variable is 16 bytes in size. */
#define PERL_MEMBER_PTR_SIZE	16

#define isnan		_isnan
#define snprintf	_snprintf
#define vsnprintf	_vsnprintf

#if _MSC_VER < 1300
/* VC6 has broken NaN semantics: NaN == NaN returns true instead of false */
#define NAN_COMPARE_BROKEN 1
#endif

#endif /* _MSC_VER */

#ifdef __MINGW32__		/* Minimal Gnu-Win32 */

typedef long		uid_t;
typedef long		gid_t;
#ifndef _environ
#define _environ	environ
#endif
#define flushall	_flushall
#define fcloseall	_fcloseall
#define isnan		_isnan	/* ...same libraries as MSVC */

#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
#endif

/* <stdint.h>, pulled in by <io.h> as of mingw-runtime-3.3, typedef's
 * (u)intptr_t but doesn't set the _(U)INTPTR_T_DEFINED defines */
#ifdef _STDINT_H
#  ifndef _INTPTR_T_DEFINED
#    define _INTPTR_T_DEFINED
#  endif
#  ifndef _UINTPTR_T_DEFINED
#    define _UINTPTR_T_DEFINED
#  endif
#endif

#endif /* __MINGW32__ */

/* both GCC/Mingw32 and MSVC++ 4.0 are missing this, so we put it here */
#ifndef CP_UTF8
#  define CP_UTF8	65001
#endif

/* compatibility stuff for other compilers goes here */

#ifndef _INTPTR_T_DEFINED
typedef int		intptr_t;
#  define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
typedef unsigned int	uintptr_t;
#  define _UINTPTR_T_DEFINED
#endif

START_EXTERN_C

/* For UNIX compatibility. */

extern  uid_t	getuid(void);
extern  gid_t	getgid(void);
extern  uid_t	geteuid(void);
extern  gid_t	getegid(void);
extern  int	setuid(uid_t uid);
extern  int	setgid(gid_t gid);
extern  int	kill(int pid, int sig);
extern  int	killpg(int pid, int sig);
#ifndef USE_PERL_SBRK
extern  void	*sbrk(ptrdiff_t need);
#  define HAS_SBRK_PROTO
#endif
extern	char *	getlogin(void);
extern	int	chown(const char *p, uid_t o, gid_t g);
extern  int	mkstemp(const char *path);

#undef	 Stat
#define  Stat		win32_stat

#undef   init_os_extras
#define  init_os_extras Perl_init_os_extras

DllExport void		Perl_win32_init(int *argcp, char ***argvp);
DllExport void		Perl_win32_term(void);
DllExport void		Perl_init_os_extras(void);
DllExport void		win32_str_os_error(void *sv, DWORD err);
DllExport int		RunPerl(int argc, char **argv, char **env);

typedef struct {
    HANDLE	childStdIn;
    HANDLE	childStdOut;
    HANDLE	childStdErr;
    /*
     * the following correspond to the fields of the same name
     * in the STARTUPINFO structure. Embedders can use these to
     * control the spawning process' look.
     * Example - to hide the window of the spawned process:
     *    dwFlags = STARTF_USESHOWWINDOW;
     *	  wShowWindow = SW_HIDE;
     */
    DWORD	dwFlags;
    DWORD	dwX;
    DWORD	dwY;
    DWORD	dwXSize;
    DWORD	dwYSize;
    DWORD	dwXCountChars;
    DWORD	dwYCountChars;
    DWORD	dwFillAttribute;
    WORD	wShowWindow;
} child_IO_table;

DllExport void		win32_get_child_IO(child_IO_table* ptr);
DllExport HWND		win32_create_message_window(void);

#ifndef USE_SOCKETS_AS_HANDLES
extern FILE *		my_fdopen(int, char *);
#endif
extern int		my_fclose(FILE *);
extern int		my_fstat(int fd, Stat_t *sbufptr);
extern char *		win32_get_privlib(const char *pl);
extern char *		win32_get_sitelib(const char *pl);
extern char *		win32_get_vendorlib(const char *pl);
extern int		IsWin95(void);
extern int		IsWinNT(void);

#ifdef PERL_IMPLICIT_SYS
extern void		win32_delete_internal_host(void *h);
#endif

extern char *		staticlinkmodules[];

END_EXTERN_C

typedef  char *		caddr_t;	/* In malloc.c (core address). */

/*
 * handle socket stuff, assuming socket is always available
 */
#include <sys/socket.h>
#include <netdb.h>

#ifdef MYMALLOC
#define EMBEDMYMALLOC	/**/
/* #define USE_PERL_SBRK	/**/
/* #define PERL_SBRK_VIA_MALLOC	/**/
#endif

#ifdef PERL_TEXTMODE_SCRIPTS
#  define PERL_SCRIPT_MODE		"r"
#else
#  define PERL_SCRIPT_MODE		"rb"
#endif

/*
 * Now Win32 specific per-thread data stuff
 */

/* Leave the first couple ids after WM_USER unused because they
 * might be used by an embedding application, and on Windows
 * version before 2000 we might end up eating those messages
 * if they were not meant for us.
 */
#define WM_USER_MIN     (WM_USER+30)
#define WM_USER_MESSAGE (WM_USER_MIN)
#define WM_USER_KILL    (WM_USER_MIN+1)
#define WM_USER_MAX     (WM_USER_MIN+1)

struct thread_intern {
    /* XXX can probably use one buffer instead of several */
    char		Wstrerror_buffer[512];
    struct servent	Wservent;
    char		Wgetlogin_buffer[128];
#    ifdef USE_SOCKETS_AS_HANDLES
    int			Winit_socktype;
#    endif
#    ifdef HAVE_DES_FCRYPT
    char		Wcrypt_buffer[30];
#    endif
#    ifdef USE_RTL_THREAD_API
    void *		retv;	/* slot for thread return value */
#    endif
    BOOL               Wuse_showwindow;
    WORD               Wshowwindow;
};

#define HAVE_INTERP_INTERN
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
    HANDLE	handles[MAXIMUM_WAIT_OBJECTS];
} child_tab;

#ifdef USE_ITHREADS
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
    HANDLE	handles[MAXIMUM_WAIT_OBJECTS];
    HWND	message_hwnds[MAXIMUM_WAIT_OBJECTS];
} pseudo_child_tab;
#endif

#ifndef Sighandler_t
typedef Signal_t (*Sighandler_t) (int);
#define Sighandler_t	Sighandler_t
#endif

struct interp_intern {
    char *	perlshell_tokens;
    char **	perlshell_vec;
    long	perlshell_items;
    struct av *	fdpid;
    child_tab *	children;
#ifdef USE_ITHREADS
    DWORD	pseudo_id;
    pseudo_child_tab * pseudo_children;
#endif
    void *	internal_host;
    struct thread_intern	thr_intern;
    HWND        message_hwnd;
    UINT	timerid;
    unsigned 	poll_count;
    Sighandler_t sigtable[SIG_SIZE];
};

DllExport int win32_async_check(pTHX);

#define WIN32_POLL_INTERVAL 32768
#define PERL_ASYNC_CHECK() if (w32_do_async || PL_sig_pending) win32_async_check(aTHX)

#define w32_perlshell_tokens	(PL_sys_intern.perlshell_tokens)
#define w32_perlshell_vec	(PL_sys_intern.perlshell_vec)
#define w32_perlshell_items	(PL_sys_intern.perlshell_items)
#define w32_fdpid		(PL_sys_intern.fdpid)
#define w32_children		(PL_sys_intern.children)
#define w32_num_children	(w32_children->num)
#define w32_child_pids		(w32_children->pids)
#define w32_child_handles	(w32_children->handles)
#define w32_pseudo_id		(PL_sys_intern.pseudo_id)
#define w32_pseudo_children	(PL_sys_intern.pseudo_children)
#define w32_num_pseudo_children		(w32_pseudo_children->num)
#define w32_pseudo_child_pids		(w32_pseudo_children->pids)
#define w32_pseudo_child_handles	(w32_pseudo_children->handles)
#define w32_pseudo_child_message_hwnds	(w32_pseudo_children->message_hwnds)
#define w32_internal_host		(PL_sys_intern.internal_host)
#define w32_timerid			(PL_sys_intern.timerid)
#define w32_message_hwnd		(PL_sys_intern.message_hwnd)
#define w32_sighandler			(PL_sys_intern.sigtable)
#define w32_poll_count			(PL_sys_intern.poll_count)
#define w32_do_async			(w32_poll_count++ > WIN32_POLL_INTERVAL)
#define w32_strerror_buffer	(PL_sys_intern.thr_intern.Wstrerror_buffer)
#define w32_getlogin_buffer	(PL_sys_intern.thr_intern.Wgetlogin_buffer)
#define w32_crypt_buffer	(PL_sys_intern.thr_intern.Wcrypt_buffer)
#define w32_servent		(PL_sys_intern.thr_intern.Wservent)
#define w32_init_socktype	(PL_sys_intern.thr_intern.Winit_socktype)
#define w32_use_showwindow	(PL_sys_intern.thr_intern.Wuse_showwindow)
#define w32_showwindow	(PL_sys_intern.thr_intern.Wshowwindow)

#ifdef USE_ITHREADS
#  define PERL_WAIT_FOR_CHILDREN \
    STMT_START {							\
	if (w32_pseudo_children && w32_num_pseudo_children) {		\
	    long children = w32_num_pseudo_children;			\
	    WaitForMultipleObjects(children,				\
				   w32_pseudo_child_handles,		\
				   TRUE, INFINITE);			\
	    while (children)						\
		CloseHandle(w32_pseudo_child_handles[--children]);	\
	}								\
    } STMT_END
#endif

#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
#ifdef PERL_CORE

/* C doesn't like repeat struct definitions */
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION>=3)
#undef _CRTIMP
#endif
#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif

/*
 * Control structure for lowio file handles
 */
typedef struct {
    intptr_t osfhnd;/* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
    int lockinitflag;
    CRITICAL_SECTION lock;
} ioinfo;


/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#define _osfile(i)  (_pioinfo(i)->osfile)
#define _pipech(i)  (_pioinfo(i)->pipech)

/* since we are not doing a dup2(), this works fine */
#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (intptr_t)osfh)
#endif
#endif

/* IO.xs and POSIX.xs define PERLIO_NOT_STDIO to 1 */
#if defined(PERL_EXT_IO) || defined(PERL_EXT_POSIX)
#undef  PERLIO_NOT_STDIO
#endif
#define PERLIO_NOT_STDIO 0

#include "perlio.h"

/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 */
#include "win32iop.h"

#define EXEC_ARGV_CAST(x) ((const char *const *) x)

#if !defined(ECONNABORTED) && defined(WSAECONNABORTED)
#define ECONNABORTED WSAECONNABORTED
#endif
#if !defined(ECONNRESET) && defined(WSAECONNRESET)
#define ECONNRESET WSAECONNRESET
#endif
#if !defined(EAFNOSUPPORT) && defined(WSAEAFNOSUPPORT)
#define EAFNOSUPPORT WSAEAFNOSUPPORT
#endif
/* Why not needed for ECONNREFUSED? --abe */

DllExport void *win32_signal_context(void);
#define PERL_GET_SIG_CONTEXT win32_signal_context()

#ifdef UNDER_CE
#define Win_GetModuleHandle   XCEGetModuleHandleA
#define Win_GetProcAddress    XCEGetProcAddressA
#define Win_GetModuleFileName XCEGetModuleFileNameA
#define Win_CreateSemaphore   CreateSemaphoreW
#else
#define Win_GetModuleHandle   GetModuleHandle
#define Win_GetProcAddress    GetProcAddress
#define Win_GetModuleFileName GetModuleFileName
#define Win_CreateSemaphore   CreateSemaphore
#endif

#endif /* _INC_WIN32_PERL5 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\vmem.h ===
/* vmem.h
 *
 * (c) 1999 Microsoft Corporation. All rights reserved. 
 * Portions (c) 1999 ActiveState Tool Corp, http://www.ActiveState.com/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Options:
 *
 * Defining _USE_MSVCRT_MEM_ALLOC will cause all memory allocations
 * to be forwarded to MSVCRT.DLL. Defining _USE_LINKED_LIST as well will
 * track all allocations in a doubly linked list, so that the host can
 * free all memory allocated when it goes away.
 * If _USE_MSVCRT_MEM_ALLOC is not defined then Knuth's boundary tag algorithm
 * is used; defining _USE_BUDDY_BLOCKS will use Knuth's algorithm R
 * (Buddy system reservation)
 *
 */

#ifndef ___VMEM_H_INC___
#define ___VMEM_H_INC___

#ifndef UNDER_CE
#define _USE_MSVCRT_MEM_ALLOC
#endif
#define _USE_LINKED_LIST

// #define _USE_BUDDY_BLOCKS

// #define _DEBUG_MEM
#ifdef _DEBUG_MEM
#define ASSERT(f) if(!(f)) DebugBreak();

inline void MEMODS(char *str)
{
    OutputDebugString(str);
    OutputDebugString("\n");
}

inline void MEMODSlx(char *str, long x)
{
    char szBuffer[512];	
    sprintf(szBuffer, "%s %lx\n", str, x);
    OutputDebugString(szBuffer);
}

#define WALKHEAP() WalkHeap(0)
#define WALKHEAPTRACE() WalkHeap(1)

#else

#define ASSERT(f)
#define MEMODS(x)
#define MEMODSlx(x, y)
#define WALKHEAP()
#define WALKHEAPTRACE()

#endif

#ifdef _USE_MSVCRT_MEM_ALLOC

#ifndef _USE_LINKED_LIST
// #define _USE_LINKED_LIST
#endif

/* 
 * Pass all memory requests throught to msvcrt.dll 
 * optionaly track by using a doubly linked header
 */

typedef void (*LPFREE)(void *block);
typedef void* (*LPMALLOC)(size_t size);
typedef void* (*LPREALLOC)(void *block, size_t size);
#ifdef _USE_LINKED_LIST
class VMem;
typedef struct _MemoryBlockHeader* PMEMORY_BLOCK_HEADER;
typedef struct _MemoryBlockHeader {
    PMEMORY_BLOCK_HEADER    pNext;
    PMEMORY_BLOCK_HEADER    pPrev;
    VMem *owner;
} MEMORY_BLOCK_HEADER, *PMEMORY_BLOCK_HEADER;
#endif

class VMem
{
public:
    VMem();
    ~VMem();
    virtual void* Malloc(size_t size);
    virtual void* Realloc(void* pMem, size_t size);
    virtual void Free(void* pMem);
    virtual void GetLock(void);
    virtual void FreeLock(void);
    virtual int IsLocked(void);
    virtual long Release(void);
    virtual long AddRef(void);

    inline BOOL CreateOk(void)
    {
	return TRUE;
    };

protected:
#ifdef _USE_LINKED_LIST
    void LinkBlock(PMEMORY_BLOCK_HEADER ptr)
    {
	PMEMORY_BLOCK_HEADER next = m_Dummy.pNext;
	m_Dummy.pNext = ptr;
	ptr->pPrev = &m_Dummy;
	ptr->pNext = next;
        ptr->owner = this;
	next->pPrev = ptr;
    }
    void UnlinkBlock(PMEMORY_BLOCK_HEADER ptr)
    {
	PMEMORY_BLOCK_HEADER next = ptr->pNext;
	PMEMORY_BLOCK_HEADER prev = ptr->pPrev;
	prev->pNext = next;
	next->pPrev = prev;
    }

    MEMORY_BLOCK_HEADER	m_Dummy;
#endif

    long		m_lRefCount;	// number of current users
    CRITICAL_SECTION	m_cs;		// access lock
    HINSTANCE		m_hLib;
    LPFREE		m_pfree;
    LPMALLOC		m_pmalloc;
    LPREALLOC		m_prealloc;
};

VMem::VMem()
{
    m_lRefCount = 1;
    InitializeCriticalSection(&m_cs);
#ifdef _USE_LINKED_LIST
    m_Dummy.pNext = m_Dummy.pPrev =  &m_Dummy;
    m_Dummy.owner = this;
#endif
    m_hLib = LoadLibrary("msvcrt.dll");
    if (m_hLib) {
	m_pfree = (LPFREE)GetProcAddress(m_hLib, "free");
	m_pmalloc = (LPMALLOC)GetProcAddress(m_hLib, "malloc");
	m_prealloc = (LPREALLOC)GetProcAddress(m_hLib, "realloc");
    }
}

VMem::~VMem(void)
{
#ifdef _USE_LINKED_LIST
    while (m_Dummy.pNext != &m_Dummy) {
	Free(m_Dummy.pNext+1);
    }
#endif
    if (m_hLib)
	FreeLibrary(m_hLib);
    DeleteCriticalSection(&m_cs);
}

void* VMem::Malloc(size_t size)
{
#ifdef _USE_LINKED_LIST
    GetLock();
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)m_pmalloc(size+sizeof(MEMORY_BLOCK_HEADER));
    if (!ptr) {
	FreeLock();
	return NULL;
    }
    LinkBlock(ptr);
    FreeLock();
    return (ptr+1);
#else
    return m_pmalloc(size);
#endif
}

void* VMem::Realloc(void* pMem, size_t size)
{
#ifdef _USE_LINKED_LIST
    if (!pMem)
	return Malloc(size);

    if (!size) {
	Free(pMem);
	return NULL;
    }

    GetLock();
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)(((char*)pMem)-sizeof(MEMORY_BLOCK_HEADER));
    UnlinkBlock(ptr);
    ptr = (PMEMORY_BLOCK_HEADER)m_prealloc(ptr, size+sizeof(MEMORY_BLOCK_HEADER));
    if (!ptr) {
	FreeLock();
	return NULL;
    }
    LinkBlock(ptr);
    FreeLock();

    return (ptr+1);
#else
    return m_prealloc(pMem, size);
#endif
}

void VMem::Free(void* pMem)
{
#ifdef _USE_LINKED_LIST
    if (pMem) {
	PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)(((char*)pMem)-sizeof(MEMORY_BLOCK_HEADER));
        if (ptr->owner != this) {
	    if (ptr->owner) {
#if 1
		dTHX;
	    	int *nowhere = NULL;
	    	Perl_warn(aTHX_ "Free to wrong pool %p not %p",this,ptr->owner);
            	*nowhere = 0; /* this segfault is deliberate, 
            	                 so you can see the stack trace */
#else
                ptr->owner->Free(pMem);	
#endif
	    }
	    return;
        }
	GetLock();
	UnlinkBlock(ptr);
	ptr->owner = NULL;
	m_pfree(ptr);
	FreeLock();
    }
#else
    m_pfree(pMem);
#endif
}

void VMem::GetLock(void)
{
    EnterCriticalSection(&m_cs);
}

void VMem::FreeLock(void)
{
    LeaveCriticalSection(&m_cs);
}

int VMem::IsLocked(void)
{
#if 0
    /* XXX TryEnterCriticalSection() is not available in some versions
     * of Windows 95.  Since this code is not used anywhere yet, we 
     * skirt the issue for now. */
    BOOL bAccessed = TryEnterCriticalSection(&m_cs);
    if(bAccessed) {
	LeaveCriticalSection(&m_cs);
    }
    return !bAccessed;
#else
    ASSERT(0);	/* alarm bells for when somebody calls this */
    return 0;
#endif
}

long VMem::Release(void)
{
    long lCount = InterlockedDecrement(&m_lRefCount);
    if(!lCount)
	delete this;
    return lCount;
}

long VMem::AddRef(void)
{
    long lCount = InterlockedIncrement(&m_lRefCount);
    return lCount;
}

#else	/* _USE_MSVCRT_MEM_ALLOC */

/*
 * Knuth's boundary tag algorithm Vol #1, Page 440.
 *
 * Each block in the heap has tag words before and after it,
 *  TAG
 *  block
 *  TAG
 * The size is stored in these tags as a long word, and includes the 8 bytes
 * of overhead that the boundary tags consume.  Blocks are allocated on long
 * word boundaries, so the size is always multiples of long words.  When the
 * block is allocated, bit 0, (the tag bit), of the size is set to 1.  When 
 * a block is freed, it is merged with adjacent free blocks, and the tag bit
 * is set to 0.
 *
 * A linked list is used to manage the free list. The first two long words of
 * the block contain double links.  These links are only valid when the block
 * is freed, therefore space needs to be reserved for them.  Thus, the minimum
 * block size (not counting the tags) is 8 bytes.
 *
 * Since memory allocation may occur on a single threaded, explict locks are not
 * provided.
 * 
 */

const long lAllocStart = 0x00020000; /* start at 128K */
const long minBlockSize = sizeof(void*)*2;
const long sizeofTag = sizeof(long);
const long blockOverhead = sizeofTag*2;
const long minAllocSize = minBlockSize+blockOverhead;
#ifdef _USE_BUDDY_BLOCKS
const long lSmallBlockSize = 1024;
const size_t nListEntries = ((lSmallBlockSize-minAllocSize)/sizeof(long));

inline size_t CalcEntry(size_t size)
{
    ASSERT((size&(sizeof(long)-1)) == 0);
    return ((size - minAllocSize) / sizeof(long));
}
#endif

typedef BYTE* PBLOCK;	/* pointer to a memory block */

/*
 * Macros for accessing hidden fields in a memory block:
 *
 * SIZE	    size of this block (tag bit 0 is 1 if block is allocated)
 * PSIZE    size of previous physical block
 */

#define SIZE(block)	(*(ULONG*)(((PBLOCK)(block))-sizeofTag))
#define PSIZE(block)	(*(ULONG*)(((PBLOCK)(block))-(blockOverhead)))
inline void SetTags(PBLOCK block, long size)
{
    SIZE(block) = size;
    PSIZE(block+(size&~1)) = size;
}

/*
 * Free list pointers
 * PREV	pointer to previous block
 * NEXT	pointer to next block
 */

#define PREV(block)	(*(PBLOCK*)(block))
#define NEXT(block)	(*(PBLOCK*)((block)+sizeof(PBLOCK)))
inline void SetLink(PBLOCK block, PBLOCK prev, PBLOCK next)
{
    PREV(block) = prev;
    NEXT(block) = next;
}
inline void Unlink(PBLOCK p)
{
    PBLOCK next = NEXT(p);
    PBLOCK prev = PREV(p);
    NEXT(prev) = next;
    PREV(next) = prev;
}
#ifndef _USE_BUDDY_BLOCKS
inline void AddToFreeList(PBLOCK block, PBLOCK pInList)
{
    PBLOCK next = NEXT(pInList);
    NEXT(pInList) = block;
    SetLink(block, pInList, next);
    PREV(next) = block;
}
#endif

/* Macro for rounding up to the next sizeof(long) */
#define ROUND_UP(n)	(((ULONG)(n)+sizeof(long)-1)&~(sizeof(long)-1))
#define ROUND_UP64K(n)	(((ULONG)(n)+0x10000-1)&~(0x10000-1))
#define ROUND_DOWN(n)	((ULONG)(n)&~(sizeof(long)-1))

/*
 * HeapRec - a list of all non-contiguous heap areas
 *
 * Each record in this array contains information about a non-contiguous heap area.
 */

const int maxHeaps = 32; /* 64 was overkill */
const long lAllocMax   = 0x80000000; /* max size of allocation */

#ifdef _USE_BUDDY_BLOCKS
typedef struct _FreeListEntry
{
    BYTE    Dummy[minAllocSize];	// dummy free block
} FREE_LIST_ENTRY, *PFREE_LIST_ENTRY;
#endif

#ifndef _USE_BUDDY_BLOCKS
#define USE_BIGBLOCK_ALLOC
#endif
/*
 * performance tuning
 * Use VirtualAlloc() for blocks bigger than nMaxHeapAllocSize since
 * Windows 95/98/Me have heap managers that are designed for memory 
 * blocks smaller than four megabytes.
 */

#ifdef USE_BIGBLOCK_ALLOC
const int nMaxHeapAllocSize = (1024*512);  /* don't allocate anything larger than this from the heap */
#endif

typedef struct _HeapRec
{
    PBLOCK	base;	/* base of heap area */
    ULONG	len;	/* size of heap area */
#ifdef USE_BIGBLOCK_ALLOC
    BOOL	bBigBlock;  /* was allocate using VirtualAlloc */
#endif
} HeapRec;

class VMem
{
public:
    VMem();
    ~VMem();
    virtual void* Malloc(size_t size);
    virtual void* Realloc(void* pMem, size_t size);
    virtual void Free(void* pMem);
    virtual void GetLock(void);
    virtual void FreeLock(void);
    virtual int IsLocked(void);
    virtual long Release(void);
    virtual long AddRef(void);

    inline BOOL CreateOk(void)
    {
#ifdef _USE_BUDDY_BLOCKS
	return TRUE;
#else
	return m_hHeap != NULL;
#endif
    };

    void ReInit(void);

protected:
    void Init(void);
    int Getmem(size_t size);

    int HeapAdd(void* ptr, size_t size
#ifdef USE_BIGBLOCK_ALLOC
	, BOOL bBigBlock
#endif
    );

    void* Expand(void* block, size_t size);

#ifdef _USE_BUDDY_BLOCKS
    inline PBLOCK GetFreeListLink(int index)
    {
	if (index >= nListEntries)
	    index = nListEntries-1;
	return &m_FreeList[index].Dummy[sizeofTag];
    }
    inline PBLOCK GetOverSizeFreeList(void)
    {
	return &m_FreeList[nListEntries-1].Dummy[sizeofTag];
    }
    inline PBLOCK GetEOLFreeList(void)
    {
	return &m_FreeList[nListEntries].Dummy[sizeofTag];
    }

    void AddToFreeList(PBLOCK block, size_t size)
    {
	PBLOCK pFreeList = GetFreeListLink(CalcEntry(size));
	PBLOCK next = NEXT(pFreeList);
	NEXT(pFreeList) = block;
	SetLink(block, pFreeList, next);
	PREV(next) = block;
    }
#endif
    inline size_t CalcAllocSize(size_t size)
    {
	/*
	 * Adjust the real size of the block to be a multiple of sizeof(long), and add
	 * the overhead for the boundary tags.  Disallow negative or zero sizes.
	 */
	return (size < minBlockSize) ? minAllocSize : (size_t)ROUND_UP(size) + blockOverhead;
    }

#ifdef _USE_BUDDY_BLOCKS
    FREE_LIST_ENTRY	m_FreeList[nListEntries+1];	// free list with dummy end of list entry as well
#else
    HANDLE		m_hHeap;		    // memory heap for this script
    char		m_FreeDummy[minAllocSize];  // dummy free block
    PBLOCK		m_pFreeList;		    // pointer to first block on free list
#endif
    PBLOCK		m_pRover;		    // roving pointer into the free list
    HeapRec		m_heaps[maxHeaps];	    // list of all non-contiguous heap areas 
    int			m_nHeaps;		    // no. of heaps in m_heaps 
    long		m_lAllocSize;		    // current alloc size
    long		m_lRefCount;		    // number of current users
    CRITICAL_SECTION	m_cs;			    // access lock

#ifdef _DEBUG_MEM
    void WalkHeap(int complete);
    void MemoryUsageMessage(char *str, long x, long y, int c);
    FILE*		m_pLog;
#endif
};

VMem::VMem()
{
    m_lRefCount = 1;
#ifndef _USE_BUDDY_BLOCKS
    BOOL bRet = (NULL != (m_hHeap = HeapCreate(HEAP_NO_SERIALIZE,
				lAllocStart,	/* initial size of heap */
				0)));		/* no upper limit on size of heap */
    ASSERT(bRet);
#endif

    InitializeCriticalSection(&m_cs);
#ifdef _DEBUG_MEM
    m_pLog = 0;
#endif

    Init();
}

VMem::~VMem(void)
{
#ifndef _USE_BUDDY_BLOCKS
    ASSERT(HeapValidate(m_hHeap, HEAP_NO_SERIALIZE, NULL));
#endif
    WALKHEAPTRACE();

    DeleteCriticalSection(&m_cs);
#ifdef _USE_BUDDY_BLOCKS
    for(int index = 0; index < m_nHeaps; ++index) {
	VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
    }
#else /* !_USE_BUDDY_BLOCKS */
#ifdef USE_BIGBLOCK_ALLOC
    for(int index = 0; index < m_nHeaps; ++index) {
	if (m_heaps[index].bBigBlock) {
	    VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
	}
    }
#endif
    BOOL bRet = HeapDestroy(m_hHeap);
    ASSERT(bRet);
#endif /* _USE_BUDDY_BLOCKS */
}

void VMem::ReInit(void)
{
    for(int index = 0; index < m_nHeaps; ++index) {
#ifdef _USE_BUDDY_BLOCKS
	VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
#else
#ifdef USE_BIGBLOCK_ALLOC
	if (m_heaps[index].bBigBlock) {
	    VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
	}
	else
#endif
	    HeapFree(m_hHeap, HEAP_NO_SERIALIZE, m_heaps[index].base);
#endif /* _USE_BUDDY_BLOCKS */
    }

    Init();
}

void VMem::Init(void)
{
#ifdef _USE_BUDDY_BLOCKS
    PBLOCK pFreeList;
    /*
     * Initialize the free list by placing a dummy zero-length block on it.
     * Set the end of list marker.
     * Set the number of non-contiguous heaps to zero.
     * Set the next allocation size.
     */
    for (int index = 0; index < nListEntries; ++index) {
	pFreeList = GetFreeListLink(index);
	SIZE(pFreeList) = PSIZE(pFreeList+minAllocSize) = 0;
	PREV(pFreeList) = NEXT(pFreeList) = pFreeList;
    }
    pFreeList = GetEOLFreeList();
    SIZE(pFreeList) = PSIZE(pFreeList+minAllocSize) = 0;
    PREV(pFreeList) = NEXT(pFreeList) = NULL;
    m_pRover = GetOverSizeFreeList();
#else
    /*
     * Initialize the free list by placing a dummy zero-length block on it.
     * Set the number of non-contiguous heaps to zero.
     */
    m_pFreeList = m_pRover = (PBLOCK)(&m_FreeDummy[sizeofTag]);
    PSIZE(m_pFreeList+minAllocSize) = SIZE(m_pFreeList) = 0;
    PREV(m_pFreeList) = NEXT(m_pFreeList) = m_pFreeList;
#endif

    m_nHeaps = 0;
    m_lAllocSize = lAllocStart;
}

void* VMem::Malloc(size_t size)
{
    WALKHEAP();

    PBLOCK ptr;
    size_t lsize, rem;
    /*
     * Disallow negative or zero sizes.
     */
    size_t realsize = CalcAllocSize(size);
    if((int)realsize < minAllocSize || size == 0)
	return NULL;

#ifdef _USE_BUDDY_BLOCKS
    /*
     * Check the free list of small blocks if this is free use it
     * Otherwise check the rover if it has no blocks then
     * Scan the free list entries use the first free block
     * split the block if needed, stop at end of list marker
     */
    {
	int index = CalcEntry(realsize);
	if (index < nListEntries-1) {
	    ptr = GetFreeListLink(index);
	    lsize = SIZE(ptr);
	    if (lsize >= realsize) {
		rem = lsize - realsize;
		if(rem < minAllocSize) {
		    /* Unlink the block from the free list. */
		    Unlink(ptr);
		}
		else {
		    /*
		     * split the block
		     * The remainder is big enough to split off into a new block.
		     * Use the end of the block, resize the beginning of the block
		     * no need to change the free list.
		     */
		    SetTags(ptr, rem);
		    ptr += SIZE(ptr);
		    lsize = realsize;
		}
		SetTags(ptr, lsize | 1);
		return ptr;
	    }
	    ptr = m_pRover;
	    lsize = SIZE(ptr);
	    if (lsize >= realsize) {
		rem = lsize - realsize;
		if(rem < minAllocSize) {
		    /* Unlink the block from the free list. */
		    Unlink(ptr);
		}
		else {
		    /*
		     * split the block
		     * The remainder is big enough to split off into a new block.
		     * Use the end of the block, resize the beginning of the block
		     * no need to change the free list.
		     */
		    SetTags(ptr, rem);
		    ptr += SIZE(ptr);
		    lsize = realsize;
		}
		SetTags(ptr, lsize | 1);
		return ptr;
	    }
	    ptr = GetFreeListLink(index+1);
	    while (NEXT(ptr)) {
		lsize = SIZE(ptr);
		if (lsize >= realsize) {
		    size_t rem = lsize - realsize;
		    if(rem < minAllocSize) {
			/* Unlink the block from the free list. */
			Unlink(ptr);
		    }
		    else {
			/*
			 * split the block
			 * The remainder is big enough to split off into a new block.
			 * Use the end of the block, resize the beginning of the block
			 * no need to change the free list.
			 */
			SetTags(ptr, rem);
			ptr += SIZE(ptr);
			lsize = realsize;
		    }
		    SetTags(ptr, lsize | 1);
		    return ptr;
		}
		ptr += sizeof(FREE_LIST_ENTRY);
	    }
	}
    }
#endif

    /*
     * Start searching the free list at the rover.  If we arrive back at rover without
     * finding anything, allocate some memory from the heap and try again.
     */
    ptr = m_pRover;	/* start searching at rover */
    int loops = 2;	/* allow two times through the loop  */
    for(;;) {
	lsize = SIZE(ptr);
	ASSERT((lsize&1)==0);
	/* is block big enough? */
	if(lsize >= realsize) {	
	    /* if the remainder is too small, don't bother splitting the block. */
	    rem = lsize - realsize;
	    if(rem < minAllocSize) {
		if(m_pRover == ptr)
		    m_pRover = NEXT(ptr);

		/* Unlink the block from the free list. */
		Unlink(ptr);
	    }
	    else {
		/*
		 * split the block
		 * The remainder is big enough to split off into a new block.
		 * Use the end of the block, resize the beginning of the block
		 * no need to change the free list.
		 */
		SetTags(ptr, rem);
		ptr += SIZE(ptr);
		lsize = realsize;
	    }
	    /* Set the boundary tags to mark it as allocated. */
	    SetTags(ptr, lsize | 1);
	    return ((void *)ptr);
	}

	/*
	 * This block was unsuitable.  If we've gone through this list once already without
	 * finding anything, allocate some new memory from the heap and try again.
	 */
	ptr = NEXT(ptr);
	if(ptr == m_pRover) {
	    if(!(loops-- && Getmem(realsize))) {
		return NULL;
	    }
	    ptr = m_pRover;
	}
    }
}

void* VMem::Realloc(void* block, size_t size)
{
    WALKHEAP();

    /* if size is zero, free the block. */
    if(size == 0) {
	Free(block);
	return (NULL);
    }

    /* if block pointer is NULL, do a Malloc(). */
    if(block == NULL)
	return Malloc(size);

    /*
     * Grow or shrink the block in place.
     * if the block grows then the next block will be used if free
     */
    if(Expand(block, size) != NULL)
	return block;

    size_t realsize = CalcAllocSize(size);
    if((int)realsize < minAllocSize)
	return NULL;

    /*
     * see if the previous block is free, and is it big enough to cover the new size
     * if merged with the current block.
     */
    PBLOCK ptr = (PBLOCK)block;
    size_t cursize = SIZE(ptr) & ~1;
    size_t psize = PSIZE(ptr);
    if((psize&1) == 0 && (psize + cursize) >= realsize) {
	PBLOCK prev = ptr - psize;
	if(m_pRover == prev)
	    m_pRover = NEXT(prev);

	/* Unlink the next block from the free list. */
	Unlink(prev);

	/* Copy contents of old block to new location, make it the current block. */
	memmove(prev, ptr, cursize);
	cursize += psize;	/* combine sizes */
	ptr = prev;

	size_t rem = cursize - realsize;
	if(rem >= minAllocSize) {
	    /*
	     * The remainder is big enough to be a new block.  Set boundary
	     * tags for the resized block and the new block.
	     */
	    prev = ptr + realsize;
	    /*
	     * add the new block to the free list.
	     * next block cannot be free
	     */
	    SetTags(prev, rem);
#ifdef _USE_BUDDY_BLOCKS
	    AddToFreeList(prev, rem);
#else
	    AddToFreeList(prev, m_pFreeList);
#endif
	    cursize = realsize;
        }
	/* Set the boundary tags to mark it as allocated. */
	SetTags(ptr, cursize | 1);
        return ((void *)ptr);
    }

    /* Allocate a new block, copy the old to the new, and free the old. */
    if((ptr = (PBLOCK)Malloc(size)) != NULL) {
	memmove(ptr, block, cursize-blockOverhead);
	Free(block);
    }
    return ((void *)ptr);
}

void VMem::Free(void* p)
{
    WALKHEAP();

    /* Ignore null pointer. */
    if(p == NULL)
	return;

    PBLOCK ptr = (PBLOCK)p;

    /* Check for attempt to free a block that's already free. */
    size_t size = SIZE(ptr);
    if((size&1) == 0) {
	MEMODSlx("Attempt to free previously freed block", (long)p);
	return;
    }
    size &= ~1;	/* remove allocated tag */

    /* if previous block is free, add this block to it. */
#ifndef _USE_BUDDY_BLOCKS
    int linked = FALSE;
#endif
    size_t psize = PSIZE(ptr);
    if((psize&1) == 0) {
	ptr -= psize;	/* point to previous block */
	size += psize;	/* merge the sizes of the two blocks */
#ifdef _USE_BUDDY_BLOCKS
	Unlink(ptr);
#else
	linked = TRUE;	/* it's already on the free list */
#endif
    }

    /* if the next physical block is free, merge it with this block. */
    PBLOCK next = ptr + size;	/* point to next physical block */
    size_t nsize = SIZE(next);
    if((nsize&1) == 0) {
	/* block is free move rover if needed */
	if(m_pRover == next)
	    m_pRover = NEXT(next);

	/* unlink the next block from the free list. */
	Unlink(next);

	/* merge the sizes of this block and the next block. */
	size += nsize;
    }

    /* Set the boundary tags for the block; */
    SetTags(ptr, size);

    /* Link the block to the head of the free list. */
#ifdef _USE_BUDDY_BLOCKS
	AddToFreeList(ptr, size);
#else
    if(!linked) {
	AddToFreeList(ptr, m_pFreeList);
    }
#endif
}

void VMem::GetLock(void)
{
    EnterCriticalSection(&m_cs);
}

void VMem::FreeLock(void)
{
    LeaveCriticalSection(&m_cs);
}

int VMem::IsLocked(void)
{
#if 0
    /* XXX TryEnterCriticalSection() is not available in some versions
     * of Windows 95.  Since this code is not used anywhere yet, we 
     * skirt the issue for now. */
    BOOL bAccessed = TryEnterCriticalSection(&m_cs);
    if(bAccessed) {
	LeaveCriticalSection(&m_cs);
    }
    return !bAccessed;
#else
    ASSERT(0);	/* alarm bells for when somebody calls this */
    return 0;
#endif
}


long VMem::Release(void)
{
    long lCount = InterlockedDecrement(&m_lRefCount);
    if(!lCount)
	delete this;
    return lCount;
}

long VMem::AddRef(void)
{
    long lCount = InterlockedIncrement(&m_lRefCount);
    return lCount;
}


int VMem::Getmem(size_t requestSize)
{   /* returns -1 is successful 0 if not */
#ifdef USE_BIGBLOCK_ALLOC
    BOOL bBigBlock;
#endif
    void *ptr;

    /* Round up size to next multiple of 64K. */
    size_t size = (size_t)ROUND_UP64K(requestSize);

    /*
     * if the size requested is smaller than our current allocation size
     * adjust up
     */
    if(size < (unsigned long)m_lAllocSize)
	size = m_lAllocSize;

    /* Update the size to allocate on the next request */
    if(m_lAllocSize != lAllocMax)
	m_lAllocSize <<= 2;

#ifndef _USE_BUDDY_BLOCKS
    if(m_nHeaps != 0
#ifdef USE_BIGBLOCK_ALLOC
	&& !m_heaps[m_nHeaps-1].bBigBlock
#endif
		    ) {
	/* Expand the last allocated heap */
	ptr = HeapReAlloc(m_hHeap, HEAP_REALLOC_IN_PLACE_ONLY|HEAP_NO_SERIALIZE,
		m_heaps[m_nHeaps-1].base,
		m_heaps[m_nHeaps-1].len + size);
	if(ptr != 0) {
	    HeapAdd(((char*)ptr) + m_heaps[m_nHeaps-1].len, size
#ifdef USE_BIGBLOCK_ALLOC
		, FALSE
#endif
		);
	    return -1;
	}
    }
#endif /* _USE_BUDDY_BLOCKS */

    /*
     * if we didn't expand a block to cover the requested size
     * allocate a new Heap
     * the size of this block must include the additional dummy tags at either end
     * the above ROUND_UP64K may not have added any memory to include this.
     */
    if(size == requestSize)
	size = (size_t)ROUND_UP64K(requestSize+(blockOverhead));

Restart:
#ifdef _USE_BUDDY_BLOCKS
    ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
#else
#ifdef USE_BIGBLOCK_ALLOC
    bBigBlock = FALSE;
    if (size >= nMaxHeapAllocSize) {
	bBigBlock = TRUE;
	ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
    }
    else
#endif
    ptr = HeapAlloc(m_hHeap, HEAP_NO_SERIALIZE, size);
#endif /* _USE_BUDDY_BLOCKS */

    if (!ptr) {
	/* try to allocate a smaller chunk */
	size >>= 1;
	if(size > requestSize)
	    goto Restart;
    }

    if(ptr == 0) {
	MEMODSlx("HeapAlloc failed on size!!!", size);
	return 0;
    }

#ifdef _USE_BUDDY_BLOCKS
    if (HeapAdd(ptr, size)) {
	VirtualFree(ptr, 0, MEM_RELEASE);
	return 0;
    }
#else
#ifdef USE_BIGBLOCK_ALLOC
    if (HeapAdd(ptr, size, bBigBlock)) {
	if (bBigBlock) {
	    VirtualFree(ptr, 0, MEM_RELEASE);
	}
    }
#else
    HeapAdd(ptr, size);
#endif
#endif /* _USE_BUDDY_BLOCKS */
    return -1;
}

int VMem::HeapAdd(void* p, size_t size
#ifdef USE_BIGBLOCK_ALLOC
    , BOOL bBigBlock
#endif
    )
{   /* if the block can be succesfully added to the heap, returns 0; otherwise -1. */
    int index;

    /* Check size, then round size down to next long word boundary. */
    if(size < minAllocSize)
	return -1;

    size = (size_t)ROUND_DOWN(size);
    PBLOCK ptr = (PBLOCK)p;

#ifdef USE_BIGBLOCK_ALLOC
    if (!bBigBlock) {
#endif
	/*
	 * Search for another heap area that's contiguous with the bottom of this new area.
	 * (It should be extremely unusual to find one that's contiguous with the top).
	 */
	for(index = 0; index < m_nHeaps; ++index) {
	    if(ptr == m_heaps[index].base + (int)m_heaps[index].len) {
		/*
		 * The new block is contiguous with a previously allocated heap area.  Add its
		 * length to that of the previous heap.  Merge it with the dummy end-of-heap
		 * area marker of the previous heap.
		 */
		m_heaps[index].len += size;
		break;
	    }
	}
#ifdef USE_BIGBLOCK_ALLOC
    }
    else {
	index = m_nHeaps;
    }
#endif

    if(index == m_nHeaps) {
	/* The new block is not contiguous, or is BigBlock.  Add it to the heap list. */
	if(m_nHeaps == maxHeaps) {
	    return -1;	/* too many non-contiguous heaps */
	}
	m_heaps[m_nHeaps].base = ptr;
	m_heaps[m_nHeaps].len = size;
#ifdef USE_BIGBLOCK_ALLOC
	m_heaps[m_nHeaps].bBigBlock = bBigBlock;
#endif
	m_nHeaps++;

	/*
	 * Reserve the first LONG in the block for the ending boundary tag of a dummy
	 * block at the start of the heap area.
	 */
	size -= blockOverhead;
	ptr += blockOverhead;
	PSIZE(ptr) = 1;	/* mark the dummy previous block as allocated */
    }

    /*
     * Convert the heap to one large block.  Set up its boundary tags, and those of
     * marker block after it.  The marker block before the heap will already have
     * been set up if this heap is not contiguous with the end of another heap.
     */
    SetTags(ptr, size | 1);
    PBLOCK next = ptr + size;	/* point to dummy end block */
    SIZE(next) = 1;	/* mark the dummy end block as allocated */

    /*
     * Link the block to the start of the free list by calling free().
     * This will merge the block with any adjacent free blocks.
     */
    Free(ptr);
    return 0;
}


void* VMem::Expand(void* block, size_t size)
{
    /*
     * Disallow negative or zero sizes.
     */
    size_t realsize = CalcAllocSize(size);
    if((int)realsize < minAllocSize || size == 0)
	return NULL;

    PBLOCK ptr = (PBLOCK)block; 

    /* if the current size is the same as requested, do nothing. */
    size_t cursize = SIZE(ptr) & ~1;
    if(cursize == realsize) {
	return block;
    }

    /* if the block is being shrunk, convert the remainder of the block into a new free block. */
    if(realsize <= cursize) {
	size_t nextsize = cursize - realsize;	/* size of new remainder block */
	if(nextsize >= minAllocSize) {
	    /*
	     * Split the block
	     * Set boundary tags for the resized block and the new block.
	     */
	    SetTags(ptr, realsize | 1);
	    ptr += realsize;

	    /*
	     * add the new block to the free list.
	     * call Free to merge this block with next block if free
	     */
	    SetTags(ptr, nextsize | 1);
	    Free(ptr);
	}

	return block;
    }

    PBLOCK next = ptr + cursize;
    size_t nextsize = SIZE(next);

    /* Check the next block for consistency.*/
    if((nextsize&1) == 0 && (nextsize + cursize) >= realsize) {
	/*
	 * The next block is free and big enough.  Add the part that's needed
	 * to our block, and split the remainder off into a new block.
	 */
	if(m_pRover == next)
	    m_pRover = NEXT(next);

	/* Unlink the next block from the free list. */
	Unlink(next);
	cursize += nextsize;	/* combine sizes */

	size_t rem = cursize - realsize;	/* size of remainder */
	if(rem >= minAllocSize) {
	    /*
	     * The remainder is big enough to be a new block.
	     * Set boundary tags for the resized block and the new block.
	     */
	    next = ptr + realsize;
	    /*
	     * add the new block to the free list.
	     * next block cannot be free
	     */
	    SetTags(next, rem);
#ifdef _USE_BUDDY_BLOCKS
	    AddToFreeList(next, rem);
#else
	    AddToFreeList(next, m_pFreeList);
#endif
	    cursize = realsize;
        }
	/* Set the boundary tags to mark it as allocated. */
	SetTags(ptr, cursize | 1);
	return ((void *)ptr);
    }
    return NULL;
}

#ifdef _DEBUG_MEM
#define LOG_FILENAME ".\\MemLog.txt"

void VMem::MemoryUsageMessage(char *str, long x, long y, int c)
{
    char szBuffer[512];
    if(str) {
	if(!m_pLog)
	    m_pLog = fopen(LOG_FILENAME, "w");
	sprintf(szBuffer, str, x, y, c);
	fputs(szBuffer, m_pLog);
    }
    else {
	if(m_pLog) {
	    fflush(m_pLog);
	    fclose(m_pLog);
	    m_pLog = 0;
	}
    }
}

void VMem::WalkHeap(int complete)
{
    if(complete) {
	MemoryUsageMessage(NULL, 0, 0, 0);
	size_t total = 0;
	for(int i = 0; i < m_nHeaps; ++i) {
	    total += m_heaps[i].len;
	}
	MemoryUsageMessage("VMem heaps used %d. Total memory %08x\n", m_nHeaps, total, 0);

	/* Walk all the heaps - verify structures */
	for(int index = 0; index < m_nHeaps; ++index) {
	    PBLOCK ptr = m_heaps[index].base;
	    size_t size = m_heaps[index].len;
#ifndef _USE_BUDDY_BLOCKS
#ifdef USE_BIGBLOCK_ALLOC
	    if (!m_heaps[m_nHeaps].bBigBlock)
#endif
		ASSERT(HeapValidate(m_hHeap, HEAP_NO_SERIALIZE, ptr));
#endif

	    /* set over reserved header block */
	    size -= blockOverhead;
	    ptr += blockOverhead;
	    PBLOCK pLast = ptr + size;
	    ASSERT(PSIZE(ptr) == 1); /* dummy previous block is allocated */
	    ASSERT(SIZE(pLast) == 1); /* dummy next block is allocated */
	    while(ptr < pLast) {
		ASSERT(ptr > m_heaps[index].base);
		size_t cursize = SIZE(ptr) & ~1;
		ASSERT((PSIZE(ptr+cursize) & ~1) == cursize);
		MemoryUsageMessage("Memory Block %08x: Size %08x %c\n", (long)ptr, cursize, (SIZE(ptr)&1) ? 'x' : ' ');
		if(!(SIZE(ptr)&1)) {
		    /* this block is on the free list */
		    PBLOCK tmp = NEXT(ptr);
		    while(tmp != ptr) {
			ASSERT((SIZE(tmp)&1)==0);
			if(tmp == m_pFreeList)
			    break;
			ASSERT(NEXT(tmp));
			tmp = NEXT(tmp);
		    }
		    if(tmp == ptr) {
			MemoryUsageMessage("Memory Block %08x: Size %08x free but not in free list\n", (long)ptr, cursize, 0);
		    }
		}
		ptr += cursize;
	    }
	}
	MemoryUsageMessage(NULL, 0, 0, 0);
    }
}
#endif	/* _DEBUG_MEM */

#endif	/* _USE_MSVCRT_MEM_ALLOC */

#endif	/* ___VMEM_H_INC___ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\warnings.h ===
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by warnings.pl
   Any changes made here will be lost!
*/


#define Off(x)			((x) / 8)
#define Bit(x)			(1 << ((x) % 8))
#define IsSet(a, x)		((a)[Off(x)] & Bit(x))


#define G_WARN_OFF		0 	/* $^W == 0 */
#define G_WARN_ON		1	/* -w flag and $^W != 0 */
#define G_WARN_ALL_ON		2	/* -W flag */
#define G_WARN_ALL_OFF		4	/* -X flag */
#define G_WARN_ONCE		8	/* set if 'once' ever enabled */
#define G_WARN_ALL_MASK		(G_WARN_ALL_ON|G_WARN_ALL_OFF)

#define pWARN_STD		NULL
#define pWARN_ALL		(((STRLEN*)0)+1)    /* use warnings 'all' */
#define pWARN_NONE		(((STRLEN*)0)+2)    /* no  warnings 'all' */

#define specialWARN(x)		((x) == pWARN_STD || (x) == pWARN_ALL ||	\
				 (x) == pWARN_NONE)

/* if PL_warnhook is set to this value, then warnings die */
#define PERL_WARNHOOK_FATAL	(&PL_sv_placeholder)

/* Warnings Categories added in Perl 5.008 */

#define WARN_ALL		0
#define WARN_CLOSURE		1
#define WARN_DEPRECATED		2
#define WARN_EXITING		3
#define WARN_GLOB		4
#define WARN_IO			5
#define WARN_CLOSED		6
#define WARN_EXEC		7
#define WARN_LAYER		8
#define WARN_NEWLINE		9
#define WARN_PIPE		10
#define WARN_UNOPENED		11
#define WARN_MISC		12
#define WARN_NUMERIC		13
#define WARN_ONCE		14
#define WARN_OVERFLOW		15
#define WARN_PACK		16
#define WARN_PORTABLE		17
#define WARN_RECURSION		18
#define WARN_REDEFINE		19
#define WARN_REGEXP		20
#define WARN_SEVERE		21
#define WARN_DEBUGGING		22
#define WARN_INPLACE		23
#define WARN_INTERNAL		24
#define WARN_MALLOC		25
#define WARN_SIGNAL		26
#define WARN_SUBSTR		27
#define WARN_SYNTAX		28
#define WARN_AMBIGUOUS		29
#define WARN_BAREWORD		30
#define WARN_DIGIT		31
#define WARN_PARENTHESIS	32
#define WARN_PRECEDENCE		33
#define WARN_PRINTF		34
#define WARN_PROTOTYPE		35
#define WARN_QW			36
#define WARN_RESERVED		37
#define WARN_SEMICOLON		38
#define WARN_TAINT		39
#define WARN_THREADS		40
#define WARN_UNINITIALIZED	41
#define WARN_UNPACK		42
#define WARN_UNTIE		43
#define WARN_UTF8		44
#define WARN_VOID		45

#define WARNsize		12
#define WARN_ALLstring		"\125\125\125\125\125\125\125\125\125\125\125\125"
#define WARN_NONEstring		"\0\0\0\0\0\0\0\0\0\0\0\0"

#define isLEXWARN_on 	(PL_curcop->cop_warnings != pWARN_STD)
#define isLEXWARN_off	(PL_curcop->cop_warnings == pWARN_STD)
#define isWARN_ONCE	(PL_dowarn & (G_WARN_ON|G_WARN_ONCE))
#define isWARN_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)))
#define isWARNf_on(c,x)	(IsSet((U8 *)(c + 1), 2*(x)+1))

#define DUP_WARNINGS(p)		\
    (specialWARN(p) ? (STRLEN*)(p)	\
    : (STRLEN*)CopyD(p, PerlMemShared_malloc(sizeof(*p)+*p), sizeof(*p)+*p, \
		     			     char))

#define ckWARN(w)		Perl_ckwarn(aTHX_ packWARN(w))
#define ckWARN2(w1,w2)		Perl_ckwarn(aTHX_ packWARN2(w1,w2))
#define ckWARN3(w1,w2,w3)	Perl_ckwarn(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4(w1,w2,w3,w4)	Perl_ckwarn(aTHX_ packWARN4(w1,w2,w3,w4))

#define ckWARN_d(w)		Perl_ckwarn_d(aTHX_ packWARN(w))
#define ckWARN2_d(w1,w2)	Perl_ckwarn_d(aTHX_ packWARN2(w1,w2))
#define ckWARN3_d(w1,w2,w3)	Perl_ckwarn_d(aTHX_ packWARN3(w1,w2,w3))
#define ckWARN4_d(w1,w2,w3,w4)	Perl_ckwarn_d(aTHX_ packWARN4(w1,w2,w3,w4))

#define packWARN(a)		(a                                      )
#define packWARN2(a,b)		((a) | ((b)<<8)                         )
#define packWARN3(a,b,c)	((a) | ((b)<<8) | ((c)<<16)             )
#define packWARN4(a,b,c,d)	((a) | ((b)<<8) | ((c)<<16) | ((d) <<24))

#define unpackWARN1(x)		((x)        & 0xFF)
#define unpackWARN2(x)		(((x) >>8)  & 0xFF)
#define unpackWARN3(x)		(((x) >>16) & 0xFF)
#define unpackWARN4(x)		(((x) >>24) & 0xFF)

#define ckDEAD(x)							\
	   ( ! specialWARN(PL_curcop->cop_warnings) &&			\
	    ( isWARNf_on(PL_curcop->cop_warnings, WARN_ALL) || 		\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN1(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN2(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN3(x)) ||	\
	      isWARNf_on(PL_curcop->cop_warnings, unpackWARN4(x))))

/* end of file warnings.h */
/* ex: set ro: */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\win32iop-o.h ===
/* Time-stamp: <01/08/01 21:00:16 keuchel@w2k> */

#ifndef WIN32IOP_H
#define WIN32IOP_H

#ifndef START_EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C
#endif
#endif

#ifndef UNDER_CE
#if defined(_MSC_VER) || defined(__MINGW32__)
#  include <sys/utime.h>
#else
#  include <utime.h>
#endif
#endif

/*
 * defines for flock emulation
 */
#define LOCK_SH 1
#define LOCK_EX 2
#define LOCK_NB 4
#define LOCK_UN 8

/*
 * Make this as close to original stdio as possible.
 */

/*
 * function prototypes for our own win32io layer
 */
START_EXTERN_C

DllExport  int * 	win32_errno(void);
DllExport  char *** 	win32_environ(void);
DllExport  FILE*	win32_stdin(void);
DllExport  FILE*	win32_stdout(void);
DllExport  FILE*	win32_stderr(void);
DllExport  int		win32_ferror(FILE *fp);
DllExport  int		win32_feof(FILE *fp);
DllExport  char*	win32_strerror(int e);

DllExport  int		win32_fprintf(FILE *pf, const char *format, ...);
DllExport  int		win32_printf(const char *format, ...);
DllExport  int		win32_vfprintf(FILE *pf, const char *format, va_list arg);
DllExport  int		win32_vprintf(const char *format, va_list arg);
DllExport  size_t	win32_fread(void *buf, size_t size, size_t count, FILE *pf);
DllExport  size_t	win32_fwrite(const void *buf, size_t size, size_t count, FILE *pf);
DllExport  FILE*	win32_fopen(const char *path, const char *mode);
DllExport  FILE*	win32_fdopen(int fh, const char *mode);
DllExport  FILE*	win32_freopen(const char *path, const char *mode, FILE *pf);
DllExport  int		win32_fclose(FILE *pf);
DllExport  int		win32_fputs(const char *s,FILE *pf);
DllExport  int		win32_fputc(int c,FILE *pf);
DllExport  int		win32_ungetc(int c,FILE *pf);
DllExport  int		win32_getc(FILE *pf);
DllExport  int		win32_fileno(FILE *pf);
DllExport  void		win32_clearerr(FILE *pf);
DllExport  int		win32_fflush(FILE *pf);
DllExport  long		win32_ftell(FILE *pf);
DllExport  int		win32_fseek(FILE *pf,long offset,int origin);
DllExport  int		win32_fgetpos(FILE *pf,fpos_t *p);
DllExport  int		win32_fsetpos(FILE *pf,const fpos_t *p);
DllExport  void		win32_rewind(FILE *pf);
DllExport  FILE*	win32_tmpfile(void);
DllExport  int		win32_tmpfd(void);
DllExport  void		win32_abort(void);
DllExport  int  	win32_fstat(int fd,struct stat *sbufptr);
DllExport  int  	win32_stat(const char *name,struct stat *sbufptr);
DllExport  int		win32_pipe( int *phandles, unsigned int psize, int textmode );
DllExport  PerlIO*	win32_popen( const char *command, const char *mode );
DllExport  PerlIO*	win32_popenlist(const char *mode, IV narg, SV **args);
DllExport  int		win32_pclose( FILE *pf);
DllExport  int		win32_rename( const char *oname, const char *newname);
DllExport  int		win32_setmode( int fd, int mode);
DllExport  int		win32_chsize(int fd, Off_t size);
DllExport  long		win32_lseek( int fd, long offset, int origin);
DllExport  long		win32_tell( int fd);
DllExport  int		win32_dup( int fd);
DllExport  int		win32_dup2(int h1, int h2);
DllExport  int		win32_open(const char *path, int oflag,...);
DllExport  int		win32_close(int fd);
DllExport  int		win32_eof(int fd);
DllExport  int		win32_read(int fd, void *buf, unsigned int cnt);
DllExport  int		win32_write(int fd, const void *buf, unsigned int cnt);
DllExport  int		win32_spawnvp(int mode, const char *cmdname,
			      const char *const *argv);
DllExport  int		win32_mkdir(const char *dir, int mode);
DllExport  int		win32_rmdir(const char *dir);
DllExport  int		win32_chdir(const char *dir);
DllExport  int		win32_flock(int fd, int oper);
DllExport  int		win32_execv(const char *cmdname, const char *const *argv);
DllExport  int		win32_execvp(const char *cmdname, const char *const *argv);
DllExport  void		win32_perror(const char *str);
DllExport  void		win32_setbuf(FILE *pf, char *buf);
DllExport  int		win32_setvbuf(FILE *pf, char *buf, int type, size_t size);
DllExport  int		win32_flushall(void);
DllExport  int		win32_fcloseall(void);
DllExport  char*	win32_fgets(char *s, int n, FILE *pf);
DllExport  char*	win32_gets(char *s);
DllExport  int		win32_fgetc(FILE *pf);
DllExport  int		win32_putc(int c, FILE *pf);
DllExport  int		win32_puts(const char *s);
DllExport  int		win32_getchar(void);
DllExport  int		win32_putchar(int c);
DllExport  void*	win32_malloc(size_t size);
DllExport  void*	win32_calloc(size_t numitems, size_t size);
DllExport  void*	win32_realloc(void *block, size_t size);
DllExport  void		win32_free(void *block);

DllExport  int		win32_open_osfhandle(long handle, int flags);
DllExport  long		win32_get_osfhandle(int fd);

DllExport  DIR*		win32_opendir(char *filename);
DllExport  struct direct* win32_readdir(DIR *dirp);
DllExport  long		win32_telldir(DIR *dirp);
DllExport  void		win32_seekdir(DIR *dirp, long loc);
DllExport  void		win32_rewinddir(DIR *dirp);
DllExport  int		win32_closedir(DIR *dirp);

#ifndef USE_WIN32_RTL_ENV
DllExport  char*	win32_getenv(const char *name);
DllExport  int		win32_putenv(const char *name);
#endif

DllExport  unsigned 	win32_sleep(unsigned int);
DllExport  int		win32_times(struct tms *timebuf);
DllExport  unsigned 	win32_alarm(unsigned int sec);
DllExport  int		win32_stat(const char *path, struct stat *buf);
DllExport  char*	win32_longpath(char *path);
DllExport  int		win32_ioctl(int i, unsigned int u, char *data);
DllExport  int          win32_link(const char *oldname, const char *newname);
DllExport  int		win32_gettimeofday(struct timeval *tp, void *not_used);
DllExport  int		win32_unlink(const char *f);
DllExport  int		win32_utime(const char *f, struct utimbuf *t);
DllExport  int		win32_uname(struct utsname *n);
DllExport  int		win32_wait(int *status);
DllExport  int		win32_waitpid(int pid, int *status, int flags);
DllExport  int		win32_kill(int pid, int sig);
DllExport  unsigned long	win32_os_id(void);
DllExport  void*	win32_dynaload(const char*filename);
DllExport  int		win32_access(const char *path, int mode);
DllExport  int		win32_chmod(const char *path, int mode);
DllExport  int		win32_getpid(void);
DllExport  Sighandler_t	win32_signal(int sig, Sighandler_t subcode);

DllExport char *	win32_crypt(const char *txt, const char *salt);

END_EXTERN_C

/*
 * the following six(6) is #define in stdio.h
 */
#ifndef WIN32IO_IS_STDIO
#undef errno
#undef environ
#undef stderr
#undef stdin
#undef stdout
#undef ferror
#undef feof
#undef fclose
#undef pipe
#undef pause
#undef sleep
#undef times
#undef alarm
#undef ioctl
#undef unlink
#undef utime
#undef uname
#undef wait

#ifdef __BORLANDC__
#undef ungetc
#undef getc
#undef putc
#undef getchar
#undef putchar
#undef fileno
#endif

#define stderr				win32_stderr()
#define stdout				win32_stdout()
#define	stdin				win32_stdin()
#define feof(f)				win32_feof(f)
#define ferror(f)			win32_ferror(f)
#define errno 				(*win32_errno())
#define environ				(*win32_environ())
#define strerror			win32_strerror

/*
 * redirect to our own version
 */
#undef fprintf
#define	fprintf			win32_fprintf
#undef vfprintf
#define	vfprintf		win32_vfprintf
#undef printf
#define	printf			win32_printf
#undef vprintf
#define	vprintf			win32_vprintf
#undef fread
#define fread(buf,size,count,f)	 win32_fread(buf,size,count,f)
#undef fwrite
#define fwrite(buf,size,count,f) win32_fwrite(buf,size,count,f)
#undef fopen
#define fopen			win32_fopen
#undef fdopen
#define fdopen			win32_fdopen
#undef freopen
#define freopen			win32_freopen
#define	fclose(f)		win32_fclose(f)
#undef fputs
#define fputs(s,f)		win32_fputs(s,f)
#undef fputc
#define fputc(c,f)		win32_fputc(c,f)
#undef ungetc
#define ungetc(c,f)		win32_ungetc(c,f)
#undef getc
#define getc(f)			win32_getc(f)
#undef fileno
#define fileno(f)		win32_fileno(f)
#undef clearerr
#define clearerr(f)		win32_clearerr(f)
#undef fflush
#define fflush(f)		win32_fflush(f)
#undef ftell
#define ftell(f)		win32_ftell(f)
#undef fseek
#define fseek(f,o,w)		win32_fseek(f,o,w)
#undef fgetpos
#define fgetpos(f,p)		win32_fgetpos(f,p)
#undef fsetpos
#define fsetpos(f,p)		win32_fsetpos(f,p)
#undef rewind
#define rewind(f)		win32_rewind(f)
#define tmpfile()		win32_tmpfile()
#define abort()			win32_abort()
#define fstat(fd,bufptr)   	win32_fstat(fd,bufptr)
#define stat(pth,bufptr)   	win32_stat(pth,bufptr)
#define longpath(pth)   	win32_longpath(pth)
#define rename(old,new)		win32_rename(old,new)
#define setmode(fd,mode)	win32_setmode(fd,mode)
#define lseek(fd,offset,orig)	win32_lseek(fd,offset,orig)
#define tell(fd)		win32_tell(fd)
#define dup(fd)			win32_dup(fd)
#define dup2(fd1,fd2)		win32_dup2(fd1,fd2)
#define open			win32_open
#define close(fd)		win32_close(fd)
#define eof(fd)			win32_eof(fd)
#define read(fd,b,s)		win32_read(fd,b,s)
#define write(fd,b,s)		win32_write(fd,b,s)
#define _open_osfhandle		win32_open_osfhandle
#define _get_osfhandle		win32_get_osfhandle
#define spawnvp			win32_spawnvp
#define mkdir			win32_mkdir
#define rmdir			win32_rmdir
#define chdir			win32_chdir
#define flock(fd,o)		win32_flock(fd,o)
#define execv			win32_execv
#define execvp			win32_execvp
#define perror			win32_perror
#define setbuf			win32_setbuf
#undef setvbuf
#define setvbuf			win32_setvbuf
#undef flushall
#define flushall		win32_flushall
#undef fcloseall
#define fcloseall		win32_fcloseall
#undef fgets
#define fgets			win32_fgets
#undef gets
#define gets			win32_gets
#undef fgetc
#define fgetc			win32_fgetc
#undef putc
#define putc			win32_putc
#undef puts
#define puts			win32_puts
#undef getchar
#define getchar			win32_getchar
#undef putchar
#define putchar			win32_putchar
#define access(p,m)		win32_access(p,m)
#define chmod(p,m)		win32_chmod(p,m)


#if !defined(MYMALLOC) || !defined(PERL_CORE)
#undef malloc
#undef calloc
#undef realloc
#undef free
#define malloc			win32_malloc
#define calloc			win32_calloc
#define realloc			win32_realloc
#define free			win32_free
#endif

#define pipe(fd)		win32_pipe((fd), 512, O_BINARY)
#define pause()			win32_sleep((32767L << 16) + 32767)
#define sleep			win32_sleep
#define times			win32_times
#define alarm			win32_alarm
#define ioctl			win32_ioctl
#define link			win32_link
#define unlink			win32_unlink
#define utime			win32_utime
#define uname			win32_uname
#define wait			win32_wait
#define waitpid			win32_waitpid
#define kill			win32_kill

#define opendir			win32_opendir
#define readdir			win32_readdir
#define telldir			win32_telldir
#define seekdir			win32_seekdir
#define rewinddir		win32_rewinddir
#define closedir		win32_closedir
#define os_id			win32_os_id
#define getpid			win32_getpid

#undef crypt
#define crypt(t,s)		win32_crypt(t,s)

#ifndef USE_WIN32_RTL_ENV
#undef getenv
#define getenv win32_getenv
#undef putenv
#define putenv win32_putenv
#endif

#endif /* WIN32IO_IS_STDIO */
#endif /* WIN32IOP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\win32thread.h ===
#ifndef _WIN32THREAD_H
#define _WIN32THREAD_H

#include "win32.h"

typedef struct win32_cond { LONG waiters; HANDLE sem; } perl_cond;
typedef DWORD perl_key;
typedef HANDLE perl_os_thread;

#ifndef DONT_USE_CRITICAL_SECTION

/* Critical Sections used instead of mutexes: lightweight,
 * but can't be communicated to child processes, and can't get
 * HANDLE to it for use elsewhere.
 */
typedef CRITICAL_SECTION perl_mutex;
#define MUTEX_INIT(m) InitializeCriticalSection(m)
#define MUTEX_LOCK(m) EnterCriticalSection(m)
#define MUTEX_UNLOCK(m) LeaveCriticalSection(m)
#define MUTEX_DESTROY(m) DeleteCriticalSection(m)

#else

typedef HANDLE perl_mutex;
#  define MUTEX_INIT(m) \
    STMT_START {						\
	if ((*(m) = CreateMutex(NULL,FALSE,NULL)) == NULL)	\
	    Perl_croak_nocontext("panic: MUTEX_INIT");		\
    } STMT_END

#  define MUTEX_LOCK(m) \
    STMT_START {						\
	if (WaitForSingleObject(*(m),INFINITE) == WAIT_FAILED)	\
	    Perl_croak_nocontext("panic: MUTEX_LOCK");		\
    } STMT_END

#  define MUTEX_UNLOCK(m) \
    STMT_START {						\
	if (ReleaseMutex(*(m)) == 0)				\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK");	\
    } STMT_END

#  define MUTEX_DESTROY(m) \
    STMT_START {						\
	if (CloseHandle(*(m)) == 0)				\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY");	\
    } STMT_END

#endif

/* These macros assume that the mutex associated with the condition
 * will always be held before COND_{SIGNAL,BROADCAST,WAIT,DESTROY},
 * so there's no separate mutex protecting access to (c)->waiters
 */
#define COND_INIT(c) \
    STMT_START {						\
	(c)->waiters = 0;					\
	(c)->sem = Win_CreateSemaphore(NULL,0,LONG_MAX,NULL);	\
	if ((c)->sem == NULL)					\
	    Perl_croak_nocontext("panic: COND_INIT (%ld)",GetLastError());	\
    } STMT_END

#define COND_SIGNAL(c) \
    STMT_START {						\
	if ((c)->waiters > 0 &&					\
	    ReleaseSemaphore((c)->sem,1,NULL) == 0)		\
	    Perl_croak_nocontext("panic: COND_SIGNAL (%ld)",GetLastError());	\
    } STMT_END

#define COND_BROADCAST(c) \
    STMT_START {						\
	if ((c)->waiters > 0 &&					\
	    ReleaseSemaphore((c)->sem,(c)->waiters,NULL) == 0)	\
	    Perl_croak_nocontext("panic: COND_BROADCAST (%ld)",GetLastError());\
    } STMT_END

#define COND_WAIT(c, m) \
    STMT_START {						\
	(c)->waiters++;						\
	MUTEX_UNLOCK(m);					\
	/* Note that there's no race here, since a		\
	 * COND_BROADCAST() on another thread will have seen the\
	 * right number of waiters (i.e. including this one) */	\
	if (WaitForSingleObject((c)->sem,INFINITE)==WAIT_FAILED)\
	    Perl_croak_nocontext("panic: COND_WAIT (%ld)",GetLastError());	\
	/* XXX there may be an inconsequential race here */	\
	MUTEX_LOCK(m);						\
	(c)->waiters--;						\
    } STMT_END

#define COND_DESTROY(c) \
    STMT_START {						\
	(c)->waiters = 0;					\
	if (CloseHandle((c)->sem) == 0)				\
	    Perl_croak_nocontext("panic: COND_DESTROY (%ld)",GetLastError());	\
    } STMT_END

#define DETACH(t) \
    STMT_START {						\
	if (CloseHandle((t)->self) == 0) {			\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH");		\
	}							\
    } STMT_END


#define THREAD_CREATE(t, f)	Perl_thread_create(t, f)
#define THREAD_POST_CREATE(t)	NOOP

/* XXX Docs mention that the RTL versions of thread creation routines
 * should be used, but that advice only seems applicable when the RTL
 * is not in a DLL.  RTL DLLs in both Borland and VC seem to do all of
 * the init/deinit required upon DLL_THREAD_ATTACH/DETACH.  So we seem
 * to be completely safe using straight Win32 API calls, rather than
 * the much braindamaged RTL calls.
 *
 * _beginthread() in the RTLs call CloseHandle() just after the thread
 * function returns, which means: 1) we have a race on our hands
 * 2) it is impossible to implement join() semantics.
 *
 * IOW, do *NOT* turn on USE_RTL_THREAD_API!  It is here
 * for experimental purposes only. GSAR 98-01-02
 */
#ifdef USE_RTL_THREAD_API
#  include <process.h>
#  if defined(__BORLANDC__)
     /* Borland RTL doesn't allow a return value from thread function! */
#    define THREAD_RET_TYPE	void _USERENTRY
#    define THREAD_RET_CAST(p)	((void)(thr->i.retv = (void *)(p)))
#  elif defined (_MSC_VER)
#    define THREAD_RET_TYPE	unsigned __stdcall
#    define THREAD_RET_CAST(p)	((unsigned)(p))
#  else
     /* CRTDLL.DLL doesn't allow a return value from thread function! */
#    define THREAD_RET_TYPE	void __cdecl
#    define THREAD_RET_CAST(p)	((void)(thr->i.retv = (void *)(p)))
#  endif
#else	/* !USE_RTL_THREAD_API */
#  define THREAD_RET_TYPE	DWORD WINAPI
#  define THREAD_RET_CAST(p)	((DWORD)(p))
#endif	/* !USE_RTL_THREAD_API */

typedef THREAD_RET_TYPE thread_func_t(void *);


START_EXTERN_C

#if defined(PERLDLL) && defined(USE_DECLSPEC_THREAD) && (!defined(__BORLANDC__) || defined(_DLL))
extern __declspec(thread) void *PL_current_context;
#define PERL_SET_CONTEXT(t)   		(PL_current_context = t)
#define PERL_GET_CONTEXT		PL_current_context
#else
#define PERL_GET_CONTEXT		Perl_get_context()
#define PERL_SET_CONTEXT(t)		Perl_set_context(t)
#endif

END_EXTERN_C

#define INIT_THREADS		NOOP
#define ALLOC_THREAD_KEY \
    STMT_START {							\
	if ((PL_thr_key = TlsAlloc()) == TLS_OUT_OF_INDEXES) {		\
	    PerlIO_printf(PerlIO_stderr(),"panic: TlsAlloc");				\
	    exit(1);							\
	}								\
    } STMT_END

#define FREE_THREAD_KEY \
    STMT_START {							\
	TlsFree(PL_thr_key);						\
    } STMT_END

#define PTHREAD_ATFORK(prepare,parent,child)	NOOP

#if defined(USE_RTL_THREAD_API) && !defined(_MSC_VER)
#define JOIN(t, avp)							\
    STMT_START {							\
	if ((WaitForSingleObject((t)->self,INFINITE) == WAIT_FAILED)	\
	     || (GetExitCodeThread((t)->self,(LPDWORD)(avp)) == 0)	\
	     || (CloseHandle((t)->self) == 0))				\
	    Perl_croak_nocontext("panic: JOIN");			\
	*avp = (AV *)((t)->i.retv);					\
    } STMT_END
#else	/* !USE_RTL_THREAD_API || _MSC_VER */
#define JOIN(t, avp)							\
    STMT_START {							\
	if ((WaitForSingleObject((t)->self,INFINITE) == WAIT_FAILED)	\
	     || (GetExitCodeThread((t)->self,(LPDWORD)(avp)) == 0)	\
	     || (CloseHandle((t)->self) == 0))				\
	    Perl_croak_nocontext("panic: JOIN");			\
    } STMT_END
#endif	/* !USE_RTL_THREAD_API || _MSC_VER */

#define YIELD			Sleep(0)

#endif /* _WIN32THREAD_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\wince.h ===
/* wince.h */

/* Time-stamp: <01/08/01 20:48:08 keuchel@w2k> */

/* This file includes extracts from the celib-headers, because */
/* the celib-headers produces macro conflicts with defines in */
/* win32iop.h etc */

#ifndef WINCE_H
#define WINCE_H 1

#include "celib_defs.h"

/* include local copies of celib headers... */
#include "errno.h"
#include "sys/stat.h"
#include "time.h"
#include "cectype.h"

#ifndef START_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C
#endif
#endif

START_EXTERN_C

#ifndef _IOFBF
#define _IOFBF          0x0000
#endif
#ifndef _IOLBF
#define _IOLBF          0x0040
#endif
#ifndef _IONBF
#define _IONBF          0x0004
#endif

#if UNDER_CE <= 200
XCE_EXPORT double xceatof(const char *);
XCE_EXPORT int xcetoupper(int c);
XCE_EXPORT int xcetolower(int c);
#define atof xceatof
#define toupper xcetoupper
#define tolower xcetolower
#else
XCE_EXPORT double atof(const char *);
#endif

XCE_EXPORT void XCEShowMessageA(const char *fmt, ...);

#define time xcetime
#define gmtime xcegmtime
#define localtime xcelocaltime
#define asctime xceasctime
/* #define utime xceutime */
#define futime xcefutime
#define ftime xceftime
#define ctime xcectime
#define gettimeofday xcegettimeofday
#define GetSystemTimeAsFileTime XCEGetSystemTimeAsFileTime

#define setuid xcesetuid
#define getuid xcegetuid
#define geteuid xcegeteuid
#define seteuid xceseteuid

#define setgid xcesetgid
#define getgid xcegetgid
#define getegid xcegetegid
#define setegid xcesetegid

XCE_EXPORT int xcechown(const char *filename, int owner, int group);
#define chown xcechown

XCE_EXPORT char *xcestrrchr(const char * string, int ch);
#define strrchr xcestrrchr

XCE_EXPORT void (*xcesignal(int, void (*)(int)))(int);
XCE_EXPORT int xceraise(int);
#define signal xcesignal
#define raise xceraise

XCE_EXPORT int xcecreat(const char *filename, int pmode);
XCE_EXPORT int xceopen(const char *fname, int mode, ...);
XCE_EXPORT int xceread(int fd, void *buf, int size);
XCE_EXPORT int xcewrite(int fd, void *buf, int size);
XCE_EXPORT int xceclose(int fd);
XCE_EXPORT off_t xcelseek(int fd, int off, int whence);

XCE_EXPORT char *xcestrupr(char *string);
XCE_EXPORT char *xcestrlwr(char *string);
#define strupr xcestrupr
#define strlwr xcestrlwr

XCE_EXPORT double xcestrtod(const char *s, char **errorptr);
XCE_EXPORT long xcestrtol(const char *s, char **errorptr, int base);
XCE_EXPORT unsigned long xcestrtoul(const char *s, char **errorptr, int base);
#define strtod xcestrtod
#define strtol xcestrtol
#define strtoul xcestrtoul

XCE_EXPORT int xcestrnicmp(const char *first, const char *last, size_t count);
#define strnicmp xcestrnicmp

XCE_EXPORT int xceumask(int mask);
#define umask xceumask

XCE_EXPORT int xceisatty(int fd);
#define isatty xceisatty

XCE_EXPORT int xcechsize(int fd, unsigned long size);
#define chsize xcechsize

XCE_EXPORT char *xcegetlogin();
#define getlogin xcegetlogin

XCE_EXPORT DWORD XCEAPI XCEGetModuleFileNameA(HMODULE hModule, LPTSTR lpName, DWORD nSize);
XCE_EXPORT HMODULE XCEAPI XCEGetModuleHandleA(const char *lpName);
XCE_EXPORT FARPROC XCEAPI XCEGetProcAddressA(HMODULE hMod, const char *name);

/* //////////////////////////////////////////////////////////////////// */

#define getgid  xcegetgid
#define getegid xcegetegid
#define geteuid xcegeteuid
#define setgid  xcesetgid

#define strupr  xcestrupr
#define time    xcetime

XCE_EXPORT BOOL XCEFreeEnvironmentStrings(LPCSTR buf);
#define GetEnvironmentStrings XCEGetEnvironmentStrings
#define FreeEnvironmentStrings XCEFreeEnvironmentStrings

void wce_hitreturn();

END_EXTERN_C

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\perl\x86\lib\core\XSUB.h ===
/*    XSUB.h
 *
 *    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
 *    2003, 2004, 2005, 2006, 2007 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#ifndef _INC_PERL_XSUB_H
#define _INC_PERL_XSUB_H 1

/* first, some documentation for xsubpp-generated items */

/*
=head1 Variables created by C<xsubpp> and C<xsubpp> internal functions

=for apidoc Amn|char*|CLASS
Variable which is setup by C<xsubpp> to indicate the 
class name for a C++ XS constructor.  This is always a C<char*>.  See C<THIS>.

=for apidoc Amn|(whatever)|RETVAL
Variable which is setup by C<xsubpp> to hold the return value for an 
XSUB. This is always the proper type for the XSUB. See 
L<perlxs/"The RETVAL Variable">.

=for apidoc Amn|(whatever)|THIS
Variable which is setup by C<xsubpp> to designate the object in a C++ 
XSUB.  This is always the proper type for the C++ object.  See C<CLASS> and 
L<perlxs/"Using XS With C++">.

=for apidoc Amn|I32|ax
Variable which is setup by C<xsubpp> to indicate the stack base offset,
used by the C<ST>, C<XSprePUSH> and C<XSRETURN> macros.  The C<dMARK> macro
must be called prior to setup the C<MARK> variable.

=for apidoc Amn|I32|items
Variable which is setup by C<xsubpp> to indicate the number of 
items on the stack.  See L<perlxs/"Variable-length Parameter Lists">.

=for apidoc Amn|I32|ix
Variable which is setup by C<xsubpp> to indicate which of an 
XSUB's aliases was used to invoke it.  See L<perlxs/"The ALIAS: Keyword">.

=for apidoc Am|SV*|ST|int ix
Used to access elements on the XSUB's stack.

=for apidoc AmU||XS
Macro to declare an XSUB and its C parameter list.  This is handled by
C<xsubpp>.

=for apidoc Ams||dAX
Sets up the C<ax> variable.
This is usually handled automatically by C<xsubpp> by calling C<dXSARGS>.

=for apidoc Ams||dAXMARK
Sets up the C<ax> variable and stack marker variable C<mark>.
This is usually handled automatically by C<xsubpp> by calling 