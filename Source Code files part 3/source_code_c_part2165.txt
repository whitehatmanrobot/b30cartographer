UNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));
    ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(Srb->SenseInfoBuffer != FdoExtension->SenseData);

    ExFreePool(Srb->SenseInfoBuffer);
    Srb->SenseInfoBuffer = FdoExtension->SenseData;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE; // should be variable?
    CLEAR_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER);
    return;
}



/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SCAN_FOR_SPECIAL_HANDLER()

Routine Description:

    This routine is a callback into the driver to set device-specific
    flags based upon matches made to the device's inquiry data.  Drivers
    register for this callback using ClassRegisterScanForSpecial().

Irql:

    This routine will be called at KIRQL == PASSIVE_LEVEL

Arguments:

    DeviceObject is the device object the error occurred on.

    Srb is the Srb that was being processed when the error occurred.

    Status may be overwritten by the routine if it decides that the error
        was benign, or otherwise wishes to change the returned status code
        for this command

    Retry may be overwritten to specify that this command should or should
        not be retried (if the callee supports retrying commands)

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_SCAN_FOR_SPECIAL_HANDLER) (
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    );

VOID
ClassScanForSpecial(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN CLASSPNP_SCAN_FOR_SPECIAL_INFO DeviceList[],
    IN PCLASS_SCAN_FOR_SPECIAL_HANDLER Function
    );

#endif /* _CLASS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\buffring.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.h

Abstract:

    This module defines the change buffering state requests related data structures in RDBSS.

Author:
Notes:

    The buffering manager implementation consists of two primary data structures
    (1) CHANGE_BUFFERING_STATE_REQUEST and (2) BUFFERING_MANAGER.

    The BUFFERING_MANAGER tracks and initiates actions on all change buffering state
    requests generated by the various mini redirectors as well as the RDBSS.

    There are three lists associated with the buffering manager, i.e., the registration
    list, the dispatcher list and the handler list.

    The registration list contains all the requests initiated for which no processing
    has been done. All DPC level indications merely register the indication in this
    list. The access to this list is protected by a spin lock(RxStrucsupSpinLock).

    The dispatcher list contains all the requests for which the lookup has not been
    completed. This list is organized as a two tier list. The top level is based on
    the NetRootKey. Each entry for a NetRootKey in this list has an associated cluster
    of requests corresponding to the various SrvOpenKey's. This is the reason for
    ghaving two LIST_ENTRY's in the request data structure as well. The
    NetRootListEntry field is used for inter cluster threading and the listEntry
    field is used for intra cluster threading.

    The handler list consists of all the requests for which the lookup has been completed
    and are awaiting processing.

    The dispatcher list and the handler list access is protected by the buffering manager
    mutex.

    The three routines of interest to mini rdr writers are ...

    1) RxIndicateChangeOfBufferingState -- for registering the request.

    2) RxAssociateSrvOpenKey -- for associating a SRV_OPEN instance with the key.


    Note that the key associations are irreverisble and will last the lifetime of the
    associated SRV_OPEN.

    Also note that 0 and 0xffffffff are not valid keys for SRV_OPEN. It has special
    significance for the buffering manager.

--*/

#ifndef __BUFFRING_H__
#define __BUFFRING_H__

#define RX_REQUEST_PREPARED_FOR_HANDLING  (0x10000000)

typedef struct _CHANGE_BUFFERING_STATE_REQUEST_ {
   
    LIST_ENTRY ListEntry;

    ULONG Flags;

    PSRV_OPEN SrvOpen;
    
    PVOID SrvOpenKey;
    PVOID MRxContext;

} CHANGE_BUFFERING_STATE_REQUEST, *PCHANGE_BUFFERING_STATE_REQUEST;

typedef struct _RX_BUFFERING_MANAGER_ {

    BOOLEAN DispatcherActive;
    BOOLEAN HandlerInactive;
    BOOLEAN LastChanceHandlerActive;
    UCHAR Pad;
    
    KSPIN_LOCK SpinLock;

    //
    //  This count is always incremented and never reset. This provides us with
    //  a quick mechanism to establish if a buffering state change request has
    //  been received for a given srvcall since a point in time. 
    //
    
    __volatile LONG CumulativeNumberOfBufferingChangeRequests;
    
    LONG NumberOfUnhandledRequests;
    LONG NumberOfUndispatchedRequests;
    __volatile LONG NumberOfOutstandingOpens;
    
    LIST_ENTRY DispatcherList;
    LIST_ENTRY HandlerList;
    LIST_ENTRY LastChanceHandlerList;
    
    RX_WORK_QUEUE_ITEM DispatcherWorkItem;
    RX_WORK_QUEUE_ITEM HandlerWorkItem;
    RX_WORK_QUEUE_ITEM LastChanceHandlerWorkItem;
    
    FAST_MUTEX Mutex;
    LIST_ENTRY SrvOpenLists[1];

} RX_BUFFERING_MANAGER, *PRX_BUFFERING_MANAGER;

#define RxAcquireBufferingManagerMutex(BUFMAN) ExAcquireFastMutex( &(BUFMAN)->Mutex )

#define RxReleaseBufferingManagerMutex(BUFMAN) ExReleaseFastMutex( &(BUFMAN)->Mutex )

VOID
RxpProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall,
    BOOLEAN UpdateHandlerState
    );
VOID
RxProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    );
VOID
RxProcessFcbChangeBufferingStateRequest (
    PFCB Fcb
    );
VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
    PSRV_OPEN SrvOpen
    );

VOID
RxCompleteSrvOpenKeyAssociation (
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxInitiateSrvOpenKeyAssociation (
   IN OUT PSRV_OPEN SrvOpen 
   );

NTSTATUS
RxInitializeBufferingManager (
   PSRV_CALL SrvCall
   );
NTSTATUS
RxTearDownBufferingManager (
   PSRV_CALL SrvCall
   );

NTSTATUS
RxFlushFcbInSystemCache (
    IN PFCB Fcb,
    IN BOOLEAN SynchronizeWithLazyWriter
    );

NTSTATUS
RxPurgeFcbInSystemCache (
    IN PFCB Fcb,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UninitializeCacheMaps,
    IN BOOLEAN  FlushFile 
    );

#endif __BUFFRING_H__

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.h

Abstract:

    This module defines the change buffering state requests related data structures in RDBSS.

Author:
Notes:

    The buffering manager implementation consists of two primary data structures
    (1) CHANGE_BUFFERING_STATE_REQUEST and (2) BUFFERING_MANAGER.

    The BUFFERING_MANAGER tracks and initiates actions on all change buffering state
    requests generated by the various mini redirectors as well as the RDBSS.

    There are three lists associated with the buffering manager, i.e., the registration
    list, the dispatcher list and the handler list.

    The registration list contains all the requests initiated for which no processing
    has been done. All DPC level indications merely register the indication in this
    list. The access to this list is protected by a spin lock(RxStrucsupSpinLock).

    The dispatcher list contains all the requests for which the lookup has not been
    completed. This list is organized as a two tier list. The top level is based on
    the NetRootKey. Each entry for a NetRootKey in this list has an associated cluster
    of requests corresponding to the various SrvOpenKey's. This is the reason for
    ghaving two LIST_ENTRY's in the request data structure as well. The
    NetRootListEntry field is used for inter cluster threading and the listEntry
    field is used for intra cluster threading.

    The handler list consists of all the requests for which the lookup has been completed
    and are awaiting processing.

    The dispatcher list and the handler list access is protected by the buffering manager
    mutex.

    The three routines of interest to mini rdr writers are ...

    1) RxIndicateChangeOfBufferingState -- for registering the request.

    2) RxAssociateSrvOpenKey -- for associating a SRV_OPEN instance with the key.


    Note that the key associations are irreverisble and will last the lifetime of the
    associated SRV_OPEN.

    Also note that 0 and 0xffffffff are not valid keys for SRV_OPEN. It has special
    significance for the buffering manager.

--*/

#ifndef __BUFFRING_H__
#define __BUFFRING_H__

#define RX_REQUEST_PREPARED_FOR_HANDLING  (0x10000000)

typedef struct _CHANGE_BUFFERING_STATE_REQUEST_ {
   
    LIST_ENTRY ListEntry;

    ULONG Flags;

    PSRV_OPEN SrvOpen;
    
    PVOID SrvOpenKey;
    PVOID MRxContext;

} CHANGE_BUFFERING_STATE_REQUEST, *PCHANGE_BUFFERING_STATE_REQUEST;

typedef struct _RX_BUFFERING_MANAGER_ {

    BOOLEAN DispatcherActive;
    BOOLEAN HandlerInactive;
    BOOLEAN LastChanceHandlerActive;
    UCHAR Pad;
    
    KSPIN_LOCK SpinLock;

    //
    //  This count is always incremented and never reset. This provides us with
    //  a quick mechanism to establish if a buffering state change request has
    //  been received for a given srvcall since a point in time. 
    //
    
    LONG CumulativeNumberOfBufferingChangeRequests;
    
    LONG NumberOfUnhandledRequests;
    LONG NumberOfUndispatchedRequests;
    LONG NumberOfOutstandingOpens;
    
    LIST_ENTRY DispatcherList;
    LIST_ENTRY HandlerList;
    LIST_ENTRY LastChanceHandlerList;
    
    RX_WORK_QUEUE_ITEM DispatcherWorkItem;
    RX_WORK_QUEUE_ITEM HandlerWorkItem;
    RX_WORK_QUEUE_ITEM LastChanceHandlerWorkItem;
    
    FAST_MUTEX Mutex;
    LIST_ENTRY SrvOpenLists[1];

} RX_BUFFERING_MANAGER, *PRX_BUFFERING_MANAGER;

#define RxAcquireBufferingManagerMutex(BUFMAN) ExAcquireFastMutex( &(BUFMAN)->Mutex )

#define RxReleaseBufferingManagerMutex(BUFMAN) ExReleaseFastMutex( &(BUFMAN)->Mutex )

VOID
RxpProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall,
    BOOLEAN UpdateHandlerState
    );
VOID
RxProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    );
VOID
RxProcessFcbChangeBufferingStateRequest (
    PFCB Fcb
    );
VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
    PSRV_OPEN SrvOpen
    );

VOID
RxCompleteSrvOpenKeyAssociation (
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxInitiateSrvOpenKeyAssociation (
   IN OUT PSRV_OPEN SrvOpen 
   );

NTSTATUS
RxInitializeBufferingManager (
   PSRV_CALL SrvCall
   );
NTSTATUS
RxTearDownBufferingManager (
   PSRV_CALL SrvCall
   );

NTSTATUS
RxFlushFcbInSystemCache (
    IN PFCB Fcb,
    IN BOOLEAN SynchronizeWithLazyWriter
    );

NTSTATUS
RxPurgeFcbInSystemCache (
    IN PFCB Fcb,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UninitializeCacheMaps,
    IN BOOLEAN  FlushFile 
    );

#endif __BUFFRING_H__


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.h

Abstract:

    This module defines the change buffering state requests related data structures in RDBSS.

Author:
Notes:

    The buffering manager implementation consists of two primary data structures
    (1) CHANGE_BUFFERING_STATE_REQUEST and (2) BUFFERING_MANAGER.

    The BUFFERING_MANAGER tracks and initiates actions on all change buffering state
    requests generated by the various mini redirectors as well as the RDBSS.

    There are three lists associated with the buffering manager, i.e., the registration
    list, the dispatcher list and the handler list.

    The registration list contains all the requests initiated for which no processing
    has been done. All DPC level indications merely register the indication in this
    list. The access to this list is protected by a spin lock(RxStrucsupSpinLock).

    The dispatcher list contains all the requests for which the lookup has not been
    completed. This list is organized as a two tier list. The top level is based on
    the NetRootKey. Each entry for a NetRootKey in this list has an associated cluster
    of requests corresponding to the various SrvOpenKey's. This is the reason for
    ghaving two LIST_ENTRY's in the request data structure as well. The
    NetRootListEntry field is used for inter cluster threading and the listEntry
    field is used for intra cluster threading.

    The handler list consists of all the requests for which the lookup has been completed
    and are awaiting processing.

    The dispatcher list and the handler list access is protected by the buffering manager
    mutex.

    The three routines of interest to mini rdr writers are ...

    1) RxIndicateChangeOfBufferingState -- for registering the request.

    2) RxAssociateSrvOpenKey -- for associating a SRV_OPEN instance with the key.


    Note that the key associations are irreverisble and will last the lifetime of the
    associated SRV_OPEN.

    Also note that 0 and 0xffffffff are not valid keys for SRV_OPEN. It has special
    significance for the buffering manager.

--*/

#ifndef __BUFFRING_H__
#define __BUFFRING_H__

#define RX_REQUEST_PREPARED_FOR_HANDLING  (0x10000000)

typedef struct _CHANGE_BUFFERING_STATE_REQUEST_ {
   LIST_ENTRY     ListEntry;

   ULONG          Flags;

   PSRV_CALL      pSrvCall;
   PSRV_OPEN      pSrvOpen;

   PVOID          SrvOpenKey;
   PVOID          pMRxContext;
} CHANGE_BUFFERING_STATE_REQUEST, *PCHANGE_BUFFERING_STATE_REQUEST;

typedef struct _RX_BUFFERING_MANAGER_ {

   BOOLEAN            fDispatcherActive;
   BOOLEAN            fNoWaitHandlerActive;
   BOOLEAN            fLastChanceHandlerActive;
   UCHAR              Pad;

   KSPIN_LOCK         SpinLock;

   // This count is always incremented and never reset. This provides us with
   // a quick mechanism to establish if a buffering state change request has
   // been received for a given srvcall since a point in time.
   LONG               CumulativeNumberOfBufferingChangeRequests;

   LONG               NumberOfUnhandledRequests;
   LONG               NumberOfUndispatchedRequests;
   LONG               NumberOfOutstandingOpens;

   LIST_ENTRY         DispatcherList;
   LIST_ENTRY         HandlerList;
   LIST_ENTRY         LastChanceHandlerList;

   RX_WORK_QUEUE_ITEM DispatcherWorkItem;
   RX_WORK_QUEUE_ITEM HandlerWorkItem;
   RX_WORK_QUEUE_ITEM LastChanceHandlerWorkItem;

   FAST_MUTEX         Mutex;
   LIST_ENTRY         SrvOpenLists[1];
} RX_BUFFERING_MANAGER, *PRX_BUFFERING_MANAGER;

#define RxAcquireBufferingManagerMutex(pBufferingManager)               \
        {                                                               \
           if (!ExTryToAcquireFastMutex(&(pBufferingManager)->Mutex)) {   \
              ExAcquireFastMutex(&(pBufferingManager)->Mutex);            \
           }                                                            \
        }

#define RxReleaseBufferingManagerMutex(pBufferingManager)               \
        ExReleaseFastMutex(&(pBufferingManager)->Mutex)

extern VOID
RxpProcessChangeBufferingStateRequests(
      PSRV_CALL  pSrvCall,
      BOOLEAN    UpdateHandlerState);

extern VOID
RxProcessChangeBufferingStateRequests(
      PSRV_CALL  pSrvCall);

extern VOID
RxProcessFcbChangeBufferingStateRequest(
      PFCB  pFcb);

extern VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
      PSRV_OPEN   pSrvOpen);

extern VOID
RxCompleteSrvOpenKeyAssociation(
    IN OUT PSRV_OPEN    pSrvOpen);

extern VOID
RxInitiateSrvOpenKeyAssociation(
   IN OUT PSRV_OPEN pSrvOpen);

extern NTSTATUS
RxInitializeBufferingManager(
   PSRV_CALL pSrvCall);

extern NTSTATUS
RxTearDownBufferingManager(
   PSRV_CALL pSrvCall);

NTSTATUS
RxFlushFcbInSystemCache(
    IN PFCB     Fcb,
    IN BOOLEAN  SynchronizeWithLazyWriter
    );

NTSTATUS
RxPurgeFcbInSystemCache(
    IN PFCB             Fcb,
    IN PLARGE_INTEGER   FileOffset OPTIONAL,
    IN ULONG            Length,
    IN BOOLEAN          UninitializeCacheMaps,
    IN BOOLEAN          FlushFile );


#endif __BUFFRING_H__


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.h

Abstract:

    This module defines the change buffering state requests related data structures in RDBSS.

Author:
Notes:

    The buffering manager implementation consists of two primary data structures
    (1) CHANGE_BUFFERING_STATE_REQUEST and (2) BUFFERING_MANAGER.

    The BUFFERING_MANAGER tracks and initiates actions on all change buffering state
    requests generated by the various mini redirectors as well as the RDBSS.

    There are three lists associated with the buffering manager, i.e., the registration
    list, the dispatcher list and the handler list.

    The registration list contains all the requests initiated for which no processing
    has been done. All DPC level indications merely register the indication in this
    list. The access to this list is protected by a spin lock(RxStrucsupSpinLock).

    The dispatcher list contains all the requests for which the lookup has not been
    completed. This list is organized as a two tier list. The top level is based on
    the NetRootKey. Each entry for a NetRootKey in this list has an associated cluster
    of requests corresponding to the various SrvOpenKey's. This is the reason for
    ghaving two LIST_ENTRY's in the request data structure as well. The
    NetRootListEntry field is used for inter cluster threading and the listEntry
    field is used for intra cluster threading.

    The handler list consists of all the requests for which the lookup has been completed
    and are awaiting processing.

    The dispatcher list and the handler list access is protected by the buffering manager
    mutex.

    The three routines of interest to mini rdr writers are ...

    1) RxIndicateChangeOfBufferingState -- for registering the request.

    2) RxAssociateSrvOpenKey -- for associating a SRV_OPEN instance with the key.


    Note that the key associations are irreverisble and will last the lifetime of the
    associated SRV_OPEN.

    Also note that 0 and 0xffffffff are not valid keys for SRV_OPEN. It has special
    significance for the buffering manager.

--*/

#ifndef __BUFFRING_H__
#define __BUFFRING_H__

#define RX_REQUEST_PREPARED_FOR_HANDLING  (0x10000000)

typedef struct _CHANGE_BUFFERING_STATE_REQUEST_ {
   LIST_ENTRY     ListEntry;

   ULONG          Flags;

   PSRV_CALL      pSrvCall;
   PSRV_OPEN      pSrvOpen;

   PVOID          SrvOpenKey;
   PVOID          pMRxContext;
} CHANGE_BUFFERING_STATE_REQUEST, *PCHANGE_BUFFERING_STATE_REQUEST;

typedef struct _RX_BUFFERING_MANAGER_ {

   BOOLEAN            fDispatcherActive;
   BOOLEAN            fNoWaitHandlerActive;
   BOOLEAN            fLastChanceHandlerActive;
   UCHAR              Pad;

   KSPIN_LOCK         SpinLock;

   // This count is always incremented and never reset. This provides us with
   // a quick mechanism to establish if a buffering state change request has
   // been received for a given srvcall since a point in time.
   LONG               CumulativeNumberOfBufferingChangeRequests;

   LONG               NumberOfUnhandledRequests;
   LONG               NumberOfUndispatchedRequests;
   LONG               NumberOfOutstandingOpens;

   LIST_ENTRY         DispatcherList;
   LIST_ENTRY         HandlerList;
   LIST_ENTRY         LastChanceHandlerList;

   RX_WORK_QUEUE_ITEM DispatcherWorkItem;
   RX_WORK_QUEUE_ITEM HandlerWorkItem;
   RX_WORK_QUEUE_ITEM LastChanceHandlerWorkItem;

   FAST_MUTEX         Mutex;
   LIST_ENTRY         SrvOpenLists[1];
} RX_BUFFERING_MANAGER, *PRX_BUFFERING_MANAGER;

#define RxAcquireBufferingManagerMutex(pBufferingManager)               \
        {                                                               \
           if (!ExTryToAcquireFastMutex(&(pBufferingManager)->Mutex)) {   \
              ExAcquireFastMutex(&(pBufferingManager)->Mutex);            \
           }                                                            \
        }

#define RxReleaseBufferingManagerMutex(pBufferingManager)               \
        ExReleaseFastMutex(&(pBufferingManager)->Mutex)

extern VOID
RxpProcessChangeBufferingStateRequests(
      PSRV_CALL  pSrvCall,
      BOOLEAN    UpdateHandlerState);

extern VOID
RxProcessChangeBufferingStateRequests(
      PSRV_CALL  pSrvCall);

extern VOID
RxProcessFcbChangeBufferingStateRequest(
      PFCB  pFcb);

extern VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
      PSRV_OPEN   pSrvOpen);

extern VOID
RxCompleteSrvOpenKeyAssociation(
    IN OUT PSRV_OPEN    pSrvOpen);

extern VOID
RxInitiateSrvOpenKeyAssociation(
   IN OUT PSRV_OPEN pSrvOpen);

extern NTSTATUS
RxInitializeBufferingManager(
   PSRV_CALL pSrvCall);

extern NTSTATUS
RxTearDownBufferingManager(
   PSRV_CALL pSrvCall);

NTSTATUS
RxFlushFcbInSystemCache(
    IN PFCB     Fcb,
    IN BOOLEAN  SynchronizeWithLazyWriter
    );

NTSTATUS
RxPurgeFcbInSystemCache(
    IN PFCB             Fcb,
    IN PLARGE_INTEGER   FileOffset OPTIONAL,
    IN ULONG            Length,
    IN BOOLEAN          UninitializeCacheMaps );


#endif __BUFFRING_H__


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\cloneviewhelper.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for cloneviewhelper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cloneviewhelper_h__
#define __cloneviewhelper_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICloneViewHelper_FWD_DEFINED__
#define __ICloneViewHelper_FWD_DEFINED__
typedef interface ICloneViewHelper ICloneViewHelper;
#endif 	/* __ICloneViewHelper_FWD_DEFINED__ */


#ifndef __IViewHelper_FWD_DEFINED__
#define __IViewHelper_FWD_DEFINED__
typedef interface IViewHelper IViewHelper;
#endif 	/* __IViewHelper_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_cloneviewhelper_0000_0000 */
/* [local] */ 

#define GETCONNECTEDIDS_TARGET 0
#define GETCONNECTEDIDS_SOURCE 1
#define S_INIT 2
// 0 == TMM's passed in configuration was applied
#define SETCONFIGURATION_STATUS_APPLIED 0
// 1 == TMM's passed in configuration was applied, with additional proprietary IHV settings
#define SETCONFIGURATION_STATUS_ADDITIONAL 1
// 2 == TMM's passed in configuration was overridden and IHV's own settings were applied
#define SETCONFIGURATION_STATUS_OVERRIDDEN 2

// Topology Data

typedef struct tagSources
{
    ULONG sourceId;
    int numTargets;
    ULONG aTargets[1];
} Sources;

typedef struct tagAdapter
{
    WCHAR AdapterName[128];
    int numSources;
    Sources sources[1];
} Adapter;

typedef struct tagAdapters
{
    int numAdapters;
    Adapter adapter[1];
} Adapters;

// Display Mode Data

typedef struct tagDisplayMode
{
    WCHAR DeviceName[32];
    DEVMODEW devMode;
} DisplayMode;

typedef struct tagDisplayModes
{
    int numDisplayModes;
    DisplayMode displayMode[1];
} DisplayModes;



extern RPC_IF_HANDLE __MIDL_itf_cloneviewhelper_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cloneviewhelper_0000_0000_v0_0_s_ifspec;

#ifndef __ICloneViewHelper_INTERFACE_DEFINED__
#define __ICloneViewHelper_INTERFACE_DEFINED__

/* interface ICloneViewHelper */
/* [unique][helpstring][nonextensible][uuid][object] */ 


EXTERN_C const IID IID_ICloneViewHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F6A3D4C4-5632-4D83-B0A1-FB88712B1EB7")
    ICloneViewHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectedIDs( 
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulID,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveTopology( 
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulTargetID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveTopology( 
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [in] */ ULONG ulCount,
            /* [in] */ __RPC__in ULONG *pulTargetID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fFinalCall) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICloneViewHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICloneViewHelper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICloneViewHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICloneViewHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectedIDs )( 
            ICloneViewHelper * This,
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulID,
            /* [in] */ ULONG ulFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveTopology )( 
            ICloneViewHelper * This,
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulTargetID);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveTopology )( 
            ICloneViewHelper * This,
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [in] */ ULONG ulCount,
            /* [in] */ __RPC__in ULONG *pulTargetID);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ICloneViewHelper * This,
            /* [in] */ BOOL fFinalCall);
        
        END_INTERFACE
    } ICloneViewHelperVtbl;

    interface ICloneViewHelper
    {
        CONST_VTBL struct ICloneViewHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICloneViewHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICloneViewHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICloneViewHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICloneViewHelper_GetConnectedIDs(This,wszAdaptorName,pulCount,pulID,ulFlags)	\
    ( (This)->lpVtbl -> GetConnectedIDs(This,wszAdaptorName,pulCount,pulID,ulFlags) ) 

#define ICloneViewHelper_GetActiveTopology(This,wszAdaptorName,ulSourceID,pulCount,pulTargetID)	\
    ( (This)->lpVtbl -> GetActiveTopology(This,wszAdaptorName,ulSourceID,pulCount,pulTargetID) ) 

#define ICloneViewHelper_SetActiveTopology(This,wszAdaptorName,ulSourceID,ulCount,pulTargetID)	\
    ( (This)->lpVtbl -> SetActiveTopology(This,wszAdaptorName,ulSourceID,ulCount,pulTargetID) ) 

#define ICloneViewHelper_Commit(This,fFinalCall)	\
    ( (This)->lpVtbl -> Commit(This,fFinalCall) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICloneViewHelper_INTERFACE_DEFINED__ */


#ifndef __IViewHelper_INTERFACE_DEFINED__
#define __IViewHelper_INTERFACE_DEFINED__

/* interface IViewHelper */
/* [unique][helpstring][nonextensible][uuid][object] */ 


EXTERN_C const IID IID_IViewHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E85CCEF5-AAAA-47f0-B5E3-61F7AECDC4C1")
    IViewHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectedIDs( 
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulID,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveTopology( 
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulTargetID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveTopology( 
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [in] */ ULONG ulCount,
            /* [in] */ __RPC__in ULONG *pulTargetID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfiguration( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out ULONG *pulStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProceedOnNewConfiguration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IViewHelper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IViewHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IViewHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectedIDs )( 
            IViewHelper * This,
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulID,
            /* [in] */ ULONG ulFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveTopology )( 
            IViewHelper * This,
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [out][in] */ __RPC__inout ULONG *pulCount,
            /* [out][in] */ __RPC__inout ULONG *pulTargetID);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveTopology )( 
            IViewHelper * This,
            /* [in] */ __RPC__in LPCWSTR wszAdaptorName,
            /* [in] */ ULONG ulSourceID,
            /* [in] */ ULONG ulCount,
            /* [in] */ __RPC__in ULONG *pulTargetID);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IViewHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetConfiguration )( 
            IViewHelper * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out ULONG *pulStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetProceedOnNewConfiguration )( 
            IViewHelper * This);
        
        END_INTERFACE
    } IViewHelperVtbl;

    interface IViewHelper
    {
        CONST_VTBL struct IViewHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IViewHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IViewHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IViewHelper_GetConnectedIDs(This,wszAdaptorName,pulCount,pulID,ulFlags)	\
    ( (This)->lpVtbl -> GetConnectedIDs(This,wszAdaptorName,pulCount,pulID,ulFlags) ) 

#define IViewHelper_GetActiveTopology(This,wszAdaptorName,ulSourceID,pulCount,pulTargetID)	\
    ( (This)->lpVtbl -> GetActiveTopology(This,wszAdaptorName,ulSourceID,pulCount,pulTargetID) ) 

#define IViewHelper_SetActiveTopology(This,wszAdaptorName,ulSourceID,ulCount,pulTargetID)	\
    ( (This)->lpVtbl -> SetActiveTopology(This,wszAdaptorName,ulSourceID,ulCount,pulTargetID) ) 

#define IViewHelper_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IViewHelper_SetConfiguration(This,pIStream,pulStatus)	\
    ( (This)->lpVtbl -> SetConfiguration(This,pIStream,pulStatus) ) 

#define IViewHelper_GetProceedOnNewConfiguration(This)	\
    ( (This)->lpVtbl -> GetProceedOnNewConfiguration(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IViewHelper_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d3dhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dhal.h
 *  Content:    Direct3D HAL include file
 *
 ***************************************************************************/

#ifndef _D3DHAL_H_
#define _D3DHAL_H_
#include "ddraw.h"
#include "d3dtypes.h"
#include "d3dcaps.h"
#include "d3d.h"
#if(DIRECT3D_VERSION >= 0x0900 )
#include "d3d9.h"
#include "dxva9typ.h"
#else
#include "d3d8.h"
#endif

struct _D3DHAL_CALLBACKS;
typedef struct _D3DHAL_CALLBACKS D3DHAL_CALLBACKS, *LPD3DHAL_CALLBACKS;

struct _D3DHAL_CALLBACKS2;
typedef struct _D3DHAL_CALLBACKS2 D3DHAL_CALLBACKS2, *LPD3DHAL_CALLBACKS2;

struct _D3DHAL_CALLBACKS3;
typedef struct _D3DHAL_CALLBACKS3 D3DHAL_CALLBACKS3, *LPD3DHAL_CALLBACKS3;

typedef struct _DDRAWI_DIRECTDRAW_GBL FAR *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR *LPDDRAWI_DIRECTDRAW_LCL;
struct _DDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR *LPDDRAWI_DDRAWSURFACE_LCL;

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DHAL_NUMCLIPVERTICES  20

/*
 * These are a few special internal renderstates etc. that would
 * logically be in d3dtypes.h, but that file is external, so they are
 * here.
 */
#define D3DTSS_MAX_DX6 ((D3DTEXTURESTAGESTATETYPE)24)
#define D3DTSS_MAX_DX7 ((D3DTEXTURESTAGESTATETYPE)29)
#define D3DTSS_MAX_DX8 ((D3DTEXTURESTAGESTATETYPE)29)
#define D3DTSS_MAX_DX9 ((D3DTEXTURESTAGESTATETYPE)33)

#if( DIRECT3D_VERSION >= 0x0900 )
#define D3DTSS_MAX D3DTSS_MAX_DX9
#elif( DIRECT3D_VERSION >= 0x0800 )
#define D3DTSS_MAX D3DTSS_MAX_DX8
#elif( DIRECT3D_VERSION >= 0x0700 )
#define D3DTSS_MAX D3DTSS_MAX_DX7
#else
#define D3DTSS_MAX D3DTSS_MAX_DX6
#endif

/*
 * If DX8 driver wants to support pre-DX8 applications, it should use these
 * definitions for pre-DX8 world matrices
*/
#define D3DTRANSFORMSTATE_WORLD_DX7  1
#define D3DTRANSFORMSTATE_WORLD1_DX7 4
#define D3DTRANSFORMSTATE_WORLD2_DX7 5
#define D3DTRANSFORMSTATE_WORLD3_DX7 6

/*
 * Generally needed maximum state structure sizes.  Note that the copy of
 * these in refrasti.hpp must be kept in sync with these.
 */
#define D3DHAL_MAX_RSTATES_DX6 (256)
#define D3DHAL_MAX_RSTATES_DX7 (256)
#define D3DHAL_MAX_RSTATES_DX8 (256)
#define D3DHAL_MAX_RSTATES_DX9 (256)

#if( DIRECT3D_VERSION >= 0x0900 )
#define D3DHAL_MAX_RSTATES D3DHAL_MAX_RSTATES_DX9
#elif( DIRECT3D_VERSION >= 0x0800 )
#define D3DHAL_MAX_RSTATES D3DHAL_MAX_RSTATES_DX8
#elif( DIRECT3D_VERSION >= 0x0700 )
#define D3DHAL_MAX_RSTATES D3DHAL_MAX_RSTATES_DX7
#else
#define D3DHAL_MAX_RSTATES D3DHAL_MAX_RSTATES_DX6
#endif

#define D3D_MAXRENDERSTATES ((D3DRENDERSTATETYPE)D3DHAL_MAX_RSTATES)

/* Last state offset for combined render state and texture stage array + 1 */
#define D3DHAL_MAX_RSTATES_AND_STAGES \
    (D3DHAL_TSS_RENDERSTATEBASE + \
     D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)
/* Last texture state ID */
#define D3DHAL_MAX_TEXTURESTATES (13)
/* Last texture state ID + 1 */
#define D3DHAL_TEXTURESTATEBUF_SIZE (D3DHAL_MAX_TEXTURESTATES+1)

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM   ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM    ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DDEVICEDESC together using the D3DDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V1 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */
} D3DDEVICEDESC_V1, *LPD3DDEVICEDESC_V1;

#define D3DDEVICEDESCSIZE_V1 (sizeof(D3DDEVICEDESC_V1))

/*
 * This is equivalent to the D3DDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DDEVICEDESC structure in DX5.
 * D3DDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DDEVICEDESC together using the
 * D3DDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V2 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

} D3DDEVICEDESC_V2, *LPD3DDEVICEDESC_V2;

#define D3DDEVICEDESCSIZE_V2 (sizeof(D3DDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DDEVICEDESC structure in DX6.
 * D3DDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DDEVICEDESC together using the
 * D3DDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V3 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
} D3DDEVICEDESC_V3, *LPD3DDEVICEDESC_V3;

#define D3DDEVICEDESCSIZE_V3 (sizeof(D3DDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 */
typedef struct _D3DHAL_GLOBALDRIVERDATA {
    DWORD       dwSize;         // Size of this structure
    D3DDEVICEDESC_V1    hwCaps;                 // Capabilities of the hardware
    DWORD       dwNumVertices;      // see following comment
    DWORD       dwNumClipVertices;  // see following comment
    DWORD       dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;   // Pointer to texture formats
} D3DHAL_GLOBALDRIVERDATA;

typedef D3DHAL_GLOBALDRIVERDATA *LPD3DHAL_GLOBALDRIVERDATA;

#define D3DHAL_GLOBALDRIVERDATASIZE (sizeof(D3DHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

#if(DIRECT3D_VERSION >= 0x0700)
    /* fields added for DX7 */
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DHAL_D3DEXTENDEDCAPS;

typedef D3DHAL_D3DEXTENDEDCAPS *LPD3DHAL_D3DEXTENDEDCAPS;
#define D3DHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DEXTENDEDCAPS))

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DHAL_D3DDX6EXTENDEDCAPS *LPD3DHAL_D3DDX6EXTENDEDCAPS;
#define D3DHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0900)
typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component
} D3DCAPS8;

typedef D3DLIGHT9 D3DLIGHT8;
typedef D3DMATERIAL9 D3DMATERIAL8;
typedef D3DVIEWPORT9 D3DVIEWPORT8;
#define D3DRS_EDGEANTIALIAS D3DRS_RESERVED0
#ifndef D3DPRASTERCAPS_ANTIALIASEDGES
#define D3DPRASTERCAPS_ANTIALIASEDGES D3DPRASTERCAPS_RESERVED0
#endif /* D3DPRASTERCAPS_ANTIALIASEDGES */
#ifndef D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE 0x00800000L
#endif /* D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE */
#ifndef D3DPRASTERCAPS_PAT
#define D3DPRASTERCAPS_PAT 0x00000008L  // equal to D3DPRASTERCAPS_RESERVED2
#endif


// This cap should not be used in DX9+ drivers
//
#ifndef D3DVTXPCAPS_NO_VSDT_UBYTE4
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */
#endif

// These are old filter caps that have been retired.
#define D3DTEXF_FLATCUBIC     4
#define D3DTEXF_GAUSSIANCUBIC 5

// These are line related states and caps that have been retired
typedef struct _D3DLINEPATTERN {
    WORD    wRepeatFactor;
    WORD    wLinePattern;
} D3DLINEPATTERN;

#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L  

#endif /* DIRECT3D_VERSION >= 0x0900 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 *
 * !!! When this structure is changed, D3DHAL_CONTEXTCREATEDATA in
 *  windows\published\ntgdistr.h also must be changed to be the same size !!!
 *
 */

typedef struct _D3DHAL_CONTEXTCREATEDATA
{
    union
    {
        LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    // in:  Driver struct (legacy)
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl;    // in:  For DX7 driver onwards
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDS;      // in:  Surface to be used as target
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl; // For DX7 onwards
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDSZ;     // in:  Surface to be used as Z
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSZLcl; // For DX7 onwards
    };

    union
    {
        DWORD       dwPID;      // in:  Current process id
        ULONG_PTR dwrstates;  // Must be larger enough to hold a pointer as
                              // we can return a pointer in this field
    };
    ULONG_PTR       dwhContext; // out: Context handle
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTCREATEDATA;
typedef D3DHAL_CONTEXTCREATEDATA *LPD3DHAL_CONTEXTCREATEDATA;

typedef struct _D3DHAL_CONTEXTDESTROYDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTDESTROYDATA;
typedef D3DHAL_CONTEXTDESTROYDATA *LPD3DHAL_CONTEXTDESTROYDATA;

typedef struct _D3DHAL_CONTEXTDESTROYALLDATA
{
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DHAL_CONTEXTDESTROYALLDATA *LPD3DHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DHAL_SCENECAPTUREDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DHAL_SCENECAPTUREDATA;
typedef D3DHAL_SCENECAPTUREDATA *LPD3DHAL_SCENECAPTUREDATA;

typedef struct _D3DHAL_RENDERSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find states in buffer
    DWORD       dwCount;    // in:  How many states to process
    LPDIRECTDRAWSURFACE lpExeBuf;   // in:  Execute buffer containing data
    HRESULT     ddrval;     // out: Return value
} D3DHAL_RENDERSTATEDATA;
typedef D3DHAL_RENDERSTATEDATA *LPD3DHAL_RENDERSTATEDATA;

typedef struct _D3DHAL_RENDERPRIMITIVEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find primitive data in buffer
    DWORD       dwStatus;   // in/out: Condition branch status
    LPDIRECTDRAWSURFACE lpExeBuf;   // in:  Execute buffer containing data
    DWORD       dwTLOffset; // in:  Byte offset in lpTLBuf for start of vertex data
    LPDIRECTDRAWSURFACE lpTLBuf;    // in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION  diInstruction;  // in:  Primitive instruction
    HRESULT     ddrval;     // out: Return value
} D3DHAL_RENDERPRIMITIVEDATA;
typedef D3DHAL_RENDERPRIMITIVEDATA *LPD3DHAL_RENDERPRIMITIVEDATA;

typedef struct _D3DHAL_TEXTURECREATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    LPDIRECTDRAWSURFACE lpDDS;      // in:  Pointer to surface object
    DWORD       dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTURECREATEDATA;
typedef D3DHAL_TEXTURECREATEDATA *LPD3DHAL_TEXTURECREATEDATA;

typedef struct _D3DHAL_TEXTUREDESTROYDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTUREDESTROYDATA;
typedef D3DHAL_TEXTUREDESTROYDATA *LPD3DHAL_TEXTUREDESTROYDATA;

typedef struct _D3DHAL_TEXTURESWAPDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwHandle1;  // in:  Handle to texture 1
    DWORD       dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTURESWAPDATA;
typedef D3DHAL_TEXTURESWAPDATA *LPD3DHAL_TEXTURESWAPDATA;

typedef struct _D3DHAL_TEXTUREGETSURFDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    ULONG_PTR    lpDDS;      // out: Pointer to surface object
    DWORD       dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTUREGETSURFDATA;
typedef D3DHAL_TEXTUREGETSURFDATA *LPD3DHAL_TEXTUREGETSURFDATA;

typedef struct _D3DHAL_GETSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwWhich;    // in:  Transform, lighting or render?
    D3DSTATE        ddState;    // in/out: State.
    HRESULT     ddrval;     // out: Return value
} D3DHAL_GETSTATEDATA;
typedef D3DHAL_GETSTATEDATA *LPD3DHAL_GETSTATEDATA;


/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTCREATECB)   (LPD3DHAL_CONTEXTCREATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTDESTROYCB)  (LPD3DHAL_CONTEXTDESTROYDATA);
typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTDESTROYALLCB) (LPD3DHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (__stdcall *LPD3DHAL_SCENECAPTURECB)    (LPD3DHAL_SCENECAPTUREDATA);
typedef DWORD   (__stdcall *LPD3DHAL_RENDERSTATECB) (LPD3DHAL_RENDERSTATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_RENDERPRIMITIVECB) (LPD3DHAL_RENDERPRIMITIVEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTURECREATECB)   (LPD3DHAL_TEXTURECREATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTUREDESTROYCB)  (LPD3DHAL_TEXTUREDESTROYDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTURESWAPCB) (LPD3DHAL_TEXTURESWAPDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTUREGETSURFCB)  (LPD3DHAL_TEXTUREGETSURFDATA);
typedef DWORD   (__stdcall *LPD3DHAL_GETSTATECB)    (LPD3DHAL_GETSTATEDATA);


/*
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */

typedef struct _D3DHAL_CALLBACKS
{
    DWORD           dwSize;

    // Device context
    LPD3DHAL_CONTEXTCREATECB    ContextCreate;
    LPD3DHAL_CONTEXTDESTROYCB   ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DHAL_SCENECAPTURECB SceneCapture;

    LPVOID                      lpReserved10;           // Must be zero
    LPVOID                      lpReserved11;           // Must be zero

    // Execution
    LPD3DHAL_RENDERSTATECB  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB  RenderPrimitive;

    DWORD           dwReserved;     // Must be zero

    // Textures
    LPD3DHAL_TEXTURECREATECB    TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB   TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB   TextureGetSurf;

    LPVOID                      lpReserved12;           // Must be zero
    LPVOID                      lpReserved13;           // Must be zero
    LPVOID                      lpReserved14;           // Must be zero
    LPVOID                      lpReserved15;           // Must be zero
    LPVOID                      lpReserved16;           // Must be zero
    LPVOID                      lpReserved17;           // Must be zero
    LPVOID                      lpReserved18;           // Must be zero
    LPVOID                      lpReserved19;           // Must be zero
    LPVOID                      lpReserved20;           // Must be zero
    LPVOID                      lpReserved21;           // Must be zero

    // Pipeline state
    LPD3DHAL_GETSTATECB     GetState;

    DWORD           dwReserved0;        // Must be zero
    DWORD           dwReserved1;        // Must be zero
    DWORD           dwReserved2;        // Must be zero
    DWORD           dwReserved3;        // Must be zero
    DWORD           dwReserved4;        // Must be zero
    DWORD           dwReserved5;        // Must be zero
    DWORD           dwReserved6;        // Must be zero
    DWORD           dwReserved7;        // Must be zero
    DWORD           dwReserved8;        // Must be zero
    DWORD           dwReserved9;        // Must be zero

} D3DHAL_CALLBACKS;
typedef D3DHAL_CALLBACKS *LPD3DHAL_CALLBACKS;

#define D3DHAL_SIZE_V1 sizeof( D3DHAL_CALLBACKS )


typedef struct _D3DHAL_SETRENDERTARGETDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle
    union
    {
        LPDIRECTDRAWSURFACE lpDDS;          // in:  new render target
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl;
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDSZ;         // in:  new Z buffer
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSZLcl;
    };

    HRESULT             ddrval;         // out: Return value
} D3DHAL_SETRENDERTARGETDATA;
typedef D3DHAL_SETRENDERTARGETDATA FAR *LPD3DHAL_SETRENDERTARGETDATA;

// This bit is the same as D3DCLEAR_RESERVED0 in d3d8types.h
// When set it means that driver has to cull rects against current viewport.
// The bit is set only for pure devices
//
#define D3DCLEAR_COMPUTERECTS   0x00000008l

typedef struct _D3DHAL_CLEARDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;

typedef struct _D3DHAL_DRAWONEPRIMITIVEDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    DWORD               dwFlags;        // in:  flags

    D3DPRIMITIVETYPE    PrimitiveType;  // in:  type of primitive to draw
    union{
    D3DVERTEXTYPE       VertexType;     // in:  type of vertices
    DWORD               dwFVFControl;   // in:  FVF control DWORD
    };
    LPVOID              lpvVertices;    // in:  pointer to vertices
    DWORD               dwNumVertices;  // in:  number of vertices

    DWORD               dwReserved;     // in:  reserved

    HRESULT             ddrval;         // out: Return value

} D3DHAL_DRAWONEPRIMITIVEDATA;
typedef D3DHAL_DRAWONEPRIMITIVEDATA *LPD3DHAL_DRAWONEPRIMITIVEDATA;


typedef struct _D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
{
    ULONG_PTR               dwhContext;     // in: Context handle

    DWORD               dwFlags;        // in: flags word

    // Primitive and vertex type
    D3DPRIMITIVETYPE    PrimitiveType;  // in: primitive type
    union{
    D3DVERTEXTYPE       VertexType;     // in: vertex type
    DWORD               dwFVFControl;   // in:  FVF control DWORD
    };

    // Vertices
    LPVOID              lpvVertices;    // in: vertex data
    DWORD               dwNumVertices;  // in: vertex count

    // Indices
    LPWORD              lpwIndices;     // in: index data
    DWORD               dwNumIndices;   // in: index count

    HRESULT             ddrval;         // out: Return value
} D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;
typedef D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA *LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;


typedef struct _D3DHAL_DRAWPRIMCOUNTS
{
    WORD wNumStateChanges;
    WORD wPrimitiveType;
    WORD wVertexType;
    WORD wNumVertices;
} D3DHAL_DRAWPRIMCOUNTS, *LPD3DHAL_DRAWPRIMCOUNTS;

typedef struct _D3DHAL_DRAWPRIMITIVESDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    DWORD               dwFlags;

    //
    // Data block:
    //
    // Consists of interleaved D3DHAL_DRAWPRIMCOUNTS, state change pairs,
    // and primitive drawing commands.
    //
    //  D3DHAL_DRAWPRIMCOUNTS: gives number of state change pairs and
    //          the information on the primitive to draw.
    //          wPrimitiveType is of type D3DPRIMITIVETYPE. Drivers
    //              must support all 7 of the primitive types specified
    //              in the DrawPrimitive API.
    //          Currently, wVertexType will always be D3DVT_TLVERTEX.
    //          If the wNumVertices member is 0, then the driver should
    //              return after doing the state changing. This is the
    //              terminator for the command stream.
    // state change pairs: DWORD pairs specify the state changes that
    //          the driver should effect before drawing the primitive.
    //          wNumStateChanges can be 0, in which case the next primitive
    //          should be drawn without any state changes in between.
    //          If present, the state change pairs are NOT aligned, they
    //          immediately follow the PRIMCOUNTS structure.
    // vertex data (if any): is 32-byte aligned.
    //
    // If a primcounts structure follows (i.e. if wNumVertices was nonzero
    // in the previous one), then it will immediately follow the state
    // changes or vertex data with no alignment padding.
    //

    LPVOID              lpvData;

    DWORD               dwFVFControl;   // in:  FVF control DWORD

    HRESULT             ddrval;         // out: Return value
} D3DHAL_DRAWPRIMITIVESDATA;
typedef D3DHAL_DRAWPRIMITIVESDATA *LPD3DHAL_DRAWPRIMITIVESDATA;

typedef DWORD (CALLBACK *LPD3DHAL_SETRENDERTARGETCB) (LPD3DHAL_SETRENDERTARGETDATA);
typedef DWORD (CALLBACK *LPD3DHAL_CLEARCB)           (LPD3DHAL_CLEARDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWONEPRIMITIVECB)   (LPD3DHAL_DRAWONEPRIMITIVEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB) (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWPRIMITIVESCB)   (LPD3DHAL_DRAWPRIMITIVESDATA);

typedef struct _D3DHAL_CALLBACKS2
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks
    LPD3DHAL_SETRENDERTARGETCB  SetRenderTarget;
    LPD3DHAL_CLEARCB            Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB    DrawPrimitives;
} D3DHAL_CALLBACKS2;
typedef D3DHAL_CALLBACKS2 *LPD3DHAL_CALLBACKS2;

#define D3DHAL_CALLBACKS2SIZE       sizeof(D3DHAL_CALLBACKS2)

#define D3DHAL2_CB32_SETRENDERTARGET    0x00000001L
#define D3DHAL2_CB32_CLEAR              0x00000002L
#define D3DHAL2_CB32_DRAWONEPRIMITIVE   0x00000004L
#define D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE 0x00000008L
#define D3DHAL2_CB32_DRAWPRIMITIVES     0x00000010L

/* --------------------------------------------------------------
 * D3DCallbacks3 - queried with GetDriverInfo (GUID_D3DCallbacks3).
 *
 * Clear2 - enables stencil clears (exposed to the API in
 *      IDirect3DViewport3::Clear2
 * ValidateTextureStageState - evaluates the context's current state (including
 *      multitexture) and returns an error if the hardware cannot
 *      accelerate the current state vector.
 * DrawPrimitives2 - Renders primitives, and changes device state specified
 *                   in the command buffer.
 *
 * Multitexture-aware drivers must implement both ValidateTextureStageState.
 */

typedef struct _D3DHAL_CLEAR2DATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle

  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEAR2DATA;
typedef D3DHAL_CLEAR2DATA FAR *LPD3DHAL_CLEAR2DATA;

typedef struct _D3DHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle
    DWORD               dwFlags;        // in:  Flags, currently set to 0
    ULONG_PTR           dwReserved;     //
    DWORD               dwNumPasses;    // out: Number of passes the hardware
                                        //      can perform the operation in
    HRESULT             ddrval;         // out: return value
} D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DHAL_VALIDATETEXTURESTAGESTATEDATA *LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DHAL_DP2COMMAND
{
    BYTE bCommand;           // vertex command
    BYTE bReserved;
    union
    {
        WORD wPrimitiveCount;   // primitive count for unconnected primitives
        WORD wStateCount;     // count of render states to follow
    };
} D3DHAL_DP2COMMAND, *LPD3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DHAL_DP2OPERATION
{
    D3DDP2OP_POINTS               = 1,
    D3DDP2OP_INDEXEDLINELIST      = 2,
    D3DDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DDP2OP_RENDERSTATE          = 8,
    D3DDP2OP_LINELIST             = 15,
    D3DDP2OP_LINESTRIP            = 16,
    D3DDP2OP_INDEXEDLINESTRIP     = 17,
    D3DDP2OP_TRIANGLELIST         = 18,
    D3DDP2OP_TRIANGLESTRIP        = 19,
    D3DDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DDP2OP_TRIANGLEFAN          = 21,
    D3DDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DDP2OP_LINELIST_IMM         = 24,
    D3DDP2OP_TEXTURESTAGESTATE    = 25,     // Has edge flags and called from Execute
    D3DDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DDP2OP_INDEXEDLINELIST2     = 27,
    D3DDP2OP_VIEWPORTINFO         = 28,
    D3DDP2OP_WINFO                = 29,
// two below are for pre-DX7 interface apps running DX7 driver
    D3DDP2OP_SETPALETTE           = 30,
    D3DDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    // New for DX7
    D3DDP2OP_ZRANGE               = 32,
    D3DDP2OP_SETMATERIAL          = 33,
    D3DDP2OP_SETLIGHT             = 34,
    D3DDP2OP_CREATELIGHT          = 35,
    D3DDP2OP_SETTRANSFORM         = 36,
    D3DDP2OP_TEXBLT               = 38,
    D3DDP2OP_STATESET             = 39,
    D3DDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DDP2OP_SETRENDERTARGET      = 41,
    D3DDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DDP2OP_SETTEXLOD            = 43,
    D3DDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
    D3DDP2OP_CREATEVERTEXSHADER   = 45,
    D3DDP2OP_DELETEVERTEXSHADER   = 46,
    D3DDP2OP_SETVERTEXSHADER      = 47,
    D3DDP2OP_SETVERTEXSHADERCONST = 48,
    D3DDP2OP_SETSTREAMSOURCE      = 49,
    D3DDP2OP_SETSTREAMSOURCEUM    = 50,
    D3DDP2OP_SETINDICES           = 51,
    D3DDP2OP_DRAWPRIMITIVE        = 52,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE = 53,
    D3DDP2OP_CREATEPIXELSHADER    = 54,
    D3DDP2OP_DELETEPIXELSHADER    = 55,
    D3DDP2OP_SETPIXELSHADER       = 56,
    D3DDP2OP_SETPIXELSHADERCONST  = 57,
    D3DDP2OP_CLIPPEDTRIANGLEFAN   = 58,
    D3DDP2OP_DRAWPRIMITIVE2       = 59,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2= 60,
    D3DDP2OP_DRAWRECTPATCH        = 61,
    D3DDP2OP_DRAWTRIPATCH         = 62,
    D3DDP2OP_VOLUMEBLT            = 63,
    D3DDP2OP_BUFFERBLT            = 64,
    D3DDP2OP_MULTIPLYTRANSFORM    = 65,
    D3DDP2OP_ADDDIRTYRECT         = 66,
    D3DDP2OP_ADDDIRTYBOX          = 67,
#endif /* DIRECT3D_VERSION >= 0x0800 */
#if(DIRECT3D_VERSION >= 0x0900)
    D3DDP2OP_CREATEVERTEXSHADERDECL   = 71,
    D3DDP2OP_DELETEVERTEXSHADERDECL   = 72,
    D3DDP2OP_SETVERTEXSHADERDECL      = 73,
    D3DDP2OP_CREATEVERTEXSHADERFUNC   = 74,
    D3DDP2OP_DELETEVERTEXSHADERFUNC   = 75,
    D3DDP2OP_SETVERTEXSHADERFUNC      = 76,
    D3DDP2OP_SETVERTEXSHADERCONSTI    = 77,
    D3DDP2OP_SETSCISSORRECT           = 79,
    D3DDP2OP_SETSTREAMSOURCE2         = 80,
    D3DDP2OP_BLT                      = 81,
    D3DDP2OP_COLORFILL                = 82,
    D3DDP2OP_SETVERTEXSHADERCONSTB    = 83,
    D3DDP2OP_CREATEQUERY              = 84,
    D3DDP2OP_SETRENDERTARGET2         = 85,
    D3DDP2OP_SETDEPTHSTENCIL          = 86,
    D3DDP2OP_RESPONSECONTINUE         = 87, /* Can come only from driver */
    D3DDP2OP_RESPONSEQUERY            = 88, /* Can come only from driver */
    D3DDP2OP_GENERATEMIPSUBLEVELS     = 89,
    D3DDP2OP_DELETEQUERY              = 90,
    D3DDP2OP_ISSUEQUERY               = 91,
    D3DDP2OP_SETPIXELSHADERCONSTI     = 93,
    D3DDP2OP_SETPIXELSHADERCONSTB     = 94,
    D3DDP2OP_SETSTREAMSOURCEFREQ      = 95,
    D3DDP2OP_SURFACEBLT               = 96,
    D3DDP2OP_SETCONVOLUTIONKERNELMONO = 97,
    D3DDP2OP_COMPOSERECTS             = 98,
#endif /* DIRECT3D_VERSION >= 0x0900 */

} D3DHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DHAL_DP2POINTS, *LPD3DHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DHAL_DP2STARTVERTEX
{
    WORD wVStart;
} D3DHAL_DP2STARTVERTEX, *LPD3DHAL_DP2STARTVERTEX;

typedef struct _D3DHAL_DP2LINELIST
{
    WORD wVStart;
} D3DHAL_DP2LINELIST, *LPD3DHAL_DP2LINELIST;

typedef struct _D3DHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DHAL_DP2INDEXEDLINELIST, *LPD3DHAL_DP2INDEXEDLINELIST;

typedef struct _D3DHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DHAL_DP2LINESTRIP, *LPD3DHAL_DP2LINESTRIP;

typedef struct _D3DHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DHAL_DP2INDEXEDLINESTRIP, *LPD3DHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLELIST, *LPD3DHAL_DP2TRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DHAL_DP2INDEXEDTRIANGLELIST, *LPD3DHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST2
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLESTRIP, *LPD3DHAL_DP2TRIANGLESTRIP;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLESTRIP, *LPD3DHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLEFAN, *LPD3DHAL_DP2TRIANGLEFAN;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLEFAN, *LPD3DHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2TRIANGLEFAN_IMM
{
    DWORD dwEdgeFlags;
} D3DHAL_DP2TRIANGLEFAN_IMM;

typedef D3DHAL_DP2TRIANGLEFAN_IMM  *LPD3DHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
    union
    {
        D3DVALUE dvState;
        DWORD dwState;
    };
} D3DHAL_DP2RENDERSTATE;
typedef D3DHAL_DP2RENDERSTATE  * LPD3DHAL_DP2RENDERSTATE;

typedef struct _D3DHAL_DP2TEXTURESTAGESTATE
{
    WORD wStage;
    WORD TSState;
    DWORD dwValue;
} D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DHAL_DP2TEXTURESTAGESTATE  *LPD3DHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DHAL_DP2VIEWPORTINFO
{
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DHAL_DP2VIEWPORTINFO;
typedef D3DHAL_DP2VIEWPORTINFO  *LPD3DHAL_DP2VIEWPORTINFO;

typedef struct _D3DHAL_DP2WINFO
{
    D3DVALUE        dvWNear;
    D3DVALUE        dvWFar;
} D3DHAL_DP2WINFO;
typedef D3DHAL_DP2WINFO  *LPD3DHAL_DP2WINFO;

typedef struct _D3DHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DHAL_DP2SETPALETTE;
typedef D3DHAL_DP2SETPALETTE  *LPD3DHAL_DP2SETPALETTE;

typedef struct _D3DHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DHAL_DP2UPDATEPALETTE;
typedef D3DHAL_DP2UPDATEPALETTE  *LPD3DHAL_DP2UPDATEPALETTE;

typedef struct _D3DHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DHAL_DP2SETRENDERTARGET;
typedef D3DHAL_DP2SETRENDERTARGET  *LPD3DHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
#define D3DHAL_STATESETCREATE    5
#endif /* DIRECT3D_VERSION >= 0x0800 */
#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DHAL_DP2STATESET
{
    DWORD               dwOperation;
    DWORD               dwParam;  // State set handle passed with D3DHAL_STATESETBEGIN,
                                  // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                  // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType;   // Type use with D3DHAL_STATESETBEGIN/END
} D3DHAL_DP2STATESET;
typedef D3DHAL_DP2STATESET  *LPD3DHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DHAL_DP2ZRANGE;
typedef D3DHAL_DP2ZRANGE  *LPD3DHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DHAL_DP2SETMATERIAL, *LPD3DHAL_DP2SETMATERIAL;

// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

typedef struct _D3DHAL_DP2SETLIGHT
{
    DWORD     dwIndex;
    DWORD     dwDataType;
} D3DHAL_DP2SETLIGHT;
typedef D3DHAL_DP2SETLIGHT  *LPD3DHAL_DP2SETLIGHT;

typedef struct _D3DHAL_DP2SETCLIPPLANE
{
    DWORD     dwIndex;
    D3DVALUE  plane[4];
} D3DHAL_DP2SETCLIPPLANE;
typedef D3DHAL_DP2SETCLIPPLANE  *LPD3DHAL_DP2SETCLIPPLANE;

typedef struct _D3DHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DHAL_DP2CREATELIGHT;
typedef D3DHAL_DP2CREATELIGHT  *LPD3DHAL_DP2CREATELIGHT;

typedef struct _D3DHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DHAL_DP2SETTRANSFORM;
typedef D3DHAL_DP2SETTRANSFORM  *LPD3DHAL_DP2SETTRANSFORM;

typedef struct _D3DHAL_DP2MULTIPLYTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DHAL_DP2MULTIPLYTRANSFORM;
typedef D3DHAL_DP2MULTIPLYTRANSFORM  *LPD3DHAL_DP2MULTIPLYTRANSFORM;

typedef struct _D3DHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DHAL_DP2EXT;
typedef D3DHAL_DP2EXT  *LPD3DHAL_DP2EXT;

typedef struct _D3DHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    POINT   pDest;
    RECTL   rSrc;       // src rect
    DWORD   dwFlags;    // blt flags
} D3DHAL_DP2TEXBLT;
typedef D3DHAL_DP2TEXBLT  *LPD3DHAL_DP2TEXBLT;

typedef struct _D3DHAL_DP2SETPRIORITY
{
    DWORD dwDDSurface;
    DWORD dwPriority;
} D3DHAL_DP2SETPRIORITY;
typedef D3DHAL_DP2SETPRIORITY  *LPD3DHAL_DP2SETPRIORITY;
#endif /* DIRECT3D_VERSION >= 0x0700 */

typedef struct _D3DHAL_DP2CLEAR
{
  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DHAL_DP2CLEAR;
typedef D3DHAL_DP2CLEAR  *LPD3DHAL_DP2CLEAR;


#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DHAL_DP2SETTEXLOD;
typedef D3DHAL_DP2SETTEXLOD  *LPD3DHAL_DP2SETTEXLOD;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0800)

// Used by SetVertexShader, DeleteVertexShader
// SetVertexShaderDecl, DeleteVertexShaderDecl,
// SetVertexShaderFunc, DeleteVertexShaderFunc
typedef struct _D3DHAL_DP2VERTEXSHADER
{
    // Vertex shader handle.
    // The handle could be 0, meaning that the current vertex shader is invalid
    // (not set). When driver recieves handle 0, it should invalidate all
    // streams pointer
#endif /* DIRECT3D_VERSION >= 0x0800 */
#if(DIRECT3D_VERSION >= 0x0900)
    // When SetVertexShaderDecl is used, the dwHandle could be a legacy FVF
    // handle or a DX9 declaration handle. Bit 0 is set for DX9 declaration.
    //
    // When SetVertexShaderFunc is used and dwHandle is zero, this means fixed
    // function pipeline
#endif /* DIRECT3D_VERSION >= 0x0900 */
#if(DIRECT3D_VERSION >= 0x0800)
    DWORD dwHandle;
} D3DHAL_DP2VERTEXSHADER;
typedef D3DHAL_DP2VERTEXSHADER  *LPD3DHAL_DP2VERTEXSHADER;

typedef struct _D3DHAL_DP2CREATEVERTEXSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwDeclSize;   // Shader declaration size in bytes
    DWORD dwCodeSize;   // Shader code size in bytes
    // Declaration follows
    // Shader code follows
} D3DHAL_DP2CREATEVERTEXSHADER;
typedef D3DHAL_DP2CREATEVERTEXSHADER  *LPD3DHAL_DP2CREATEVERTEXSHADER;

// Used with all types of vertex shader constants
typedef struct _D3DHAL_DP2SETVERTEXSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy for D3DDP2OP_SETVERTEXSHADERCONST
                        // Number of 4-integer vectors to copy for D3DDP2OP_SETVERTEXSHADERCONSTI
                        // Number of BOOL values to copy for D3DDP2OP_SETVERTEXSHADERCONSTB
    // Data follows
} D3DHAL_DP2SETVERTEXSHADERCONST;
typedef D3DHAL_DP2SETVERTEXSHADERCONST  *LPD3DHAL_DP2SETVERTEXSHADERCONST;

typedef struct _D3DHAL_DP2SETSTREAMSOURCE
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwVBHandle;   // Vertex buffer handle
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCE;
typedef D3DHAL_DP2SETSTREAMSOURCE  *LPD3DHAL_DP2SETSTREAMSOURCE;

typedef struct _D3DHAL_DP2SETSTREAMSOURCEUM
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCEUM;
typedef D3DHAL_DP2SETSTREAMSOURCEUM  *LPD3DHAL_DP2SETSTREAMSOURCEUM;

typedef struct _D3DHAL_DP2SETINDICES
{
    DWORD dwVBHandle;           // Index buffer handle
    DWORD dwStride;             // Index size in bytes (2 or 4)
} D3DHAL_DP2SETINDICES;
typedef D3DHAL_DP2SETINDICES  *LPD3DHAL_DP2SETINDICES;

typedef struct _D3DHAL_DP2DRAWPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    DWORD VStart;
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWPRIMITIVE;
typedef D3DHAL_DP2DRAWPRIMITIVE  *LPD3DHAL_DP2DRAWPRIMITIVE;

typedef struct _D3DHAL_DP2DRAWINDEXEDPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    INT BaseVertexIndex;          // Vertex which corresponds to index 0
    DWORD MinIndex;                 // Min vertex index in the vertex buffer
    DWORD NumVertices;              // Number of vertices starting from MinIndex
    DWORD StartIndex;               // Start index in the index buffer
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef D3DHAL_DP2DRAWINDEXEDPRIMITIVE  *LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE;

typedef struct _D3DHAL_CLIPPEDTRIANGLEFAN
{
    DWORD FirstVertexOffset;            // Offset in bytes in the current stream 0
    DWORD dwEdgeFlags;
    DWORD PrimitiveCount;
} D3DHAL_CLIPPEDTRIANGLEFAN;
typedef D3DHAL_CLIPPEDTRIANGLEFAN  *LPD3DHAL_CLIPPEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2DRAWPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    DWORD FirstVertexOffset;            // Offset in bytes in the stream 0
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWPRIMITIVE2;
typedef D3DHAL_DP2DRAWPRIMITIVE2  *LPD3DHAL_DP2DRAWPRIMITIVE2;

typedef struct _D3DHAL_DP2DRAWINDEXEDPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    INT   BaseVertexOffset;     // Stream 0 offset of the vertex which
                                // corresponds to index 0. This offset could be
                                // negative, but when an index is added to the
                                // offset the result is positive
    DWORD MinIndex;             // Min vertex index in the vertex buffer
    DWORD NumVertices;          // Number of vertices starting from MinIndex
    DWORD StartIndexOffset;     // Offset of the start index in the index buffer
    DWORD PrimitiveCount;       // Number of triangles (points, lines)
} D3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef D3DHAL_DP2DRAWINDEXEDPRIMITIVE2  *LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2;

// Used by SetPixelShader and DeletePixelShader
typedef struct _D3DHAL_DP2PIXELSHADER
{
    // Pixel shader handle.
    // The handle could be 0, meaning that the current pixel shader is invalid
    // (not set).
    DWORD dwHandle;
} D3DHAL_DP2PIXELSHADER;
typedef D3DHAL_DP2PIXELSHADER  *LPD3DHAL_DP2PIXELSHADER;

typedef struct _D3DHAL_DP2CREATEPIXELSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwCodeSize;   // Shader code size in bytes
    // Shader code follows
} D3DHAL_DP2CREATEPIXELSHADER;
typedef D3DHAL_DP2CREATEPIXELSHADER  *LPD3DHAL_DP2CREATEPIXELSHADER;

typedef struct _D3DHAL_DP2SETPIXELSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy for D3DDP2OP_SETPIXELSHADERCONST
                        // Number of 4-integer vectors to copy for D3DDP2OP_SETPIXELSHADERCONSTI
                        // Number of BOOL values to copy for D3DDP2OP_SETPIXELSHADERCONSTB
    // Data follows
} D3DHAL_DP2SETPIXELSHADERCONST;
typedef D3DHAL_DP2SETPIXELSHADERCONST  *LPD3DHAL_DP2SETPIXELSHADERCONST;

// Flags that can be supplied to DRAWRECTPATCH and DRAWTRIPATCH
#define RTPATCHFLAG_HASSEGS  0x00000001L
#define RTPATCHFLAG_HASINFO  0x00000002L

typedef struct _D3DHAL_DP2DRAWRECTPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[4] NumSegments and/or D3DRECTPATCH_INFO
} D3DHAL_DP2DRAWRECTPATCH;
typedef D3DHAL_DP2DRAWRECTPATCH  *LPD3DHAL_DP2DRAWRECTPATCH;

typedef struct _D3DHAL_DP2DRAWTRIPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[3] NumSegments and/or D3DTRIPATCH_INFO
} D3DHAL_DP2DRAWTRIPATCH;
typedef D3DHAL_DP2DRAWTRIPATCH  *LPD3DHAL_DP2DRAWTRIPATCH;

typedef struct _D3DHAL_DP2VOLUMEBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    DWORD   dwDestX;        // dest X (width)
    DWORD   dwDestY;        // dest Y (height)
    DWORD   dwDestZ;        // dest Z (depth)
    D3DBOX  srcBox;         // src box
    DWORD   dwFlags;        // blt flags
} D3DHAL_DP2VOLUMEBLT;
typedef D3DHAL_DP2VOLUMEBLT  *LPD3DHAL_DP2VOLUMEBLT;

typedef struct _D3DHAL_DP2BUFFERBLT
{
    DWORD     dwDDDestSurface; // dest surface
    DWORD     dwDDSrcSurface;  // src surface
    DWORD     dwOffset;        // Offset in the dest surface (in BYTES)
    D3DRANGE  rSrc;            // src range
    DWORD     dwFlags;         // blt flags
} D3DHAL_DP2BUFFERBLT;
typedef D3DHAL_DP2BUFFERBLT  *LPD3DHAL_DP2BUFFERBLT;

typedef struct _D3DHAL_DP2ADDDIRTYRECT
{
    DWORD     dwSurface;      // Driver managed surface
    RECTL     rDirtyArea;     // Area marked dirty
} D3DHAL_DP2ADDDIRTYRECT;
typedef D3DHAL_DP2ADDDIRTYRECT  *LPD3DHAL_DP2ADDDIRTYRECT;

typedef struct _D3DHAL_DP2ADDDIRTYBOX
{
    DWORD     dwSurface;      // Driver managed volume
    D3DBOX    DirtyBox;       // Box marked dirty
} D3DHAL_DP2ADDDIRTYBOX;
typedef D3DHAL_DP2ADDDIRTYBOX  *LPD3DHAL_DP2ADDDIRTYBOX;

#endif /* DIRECT3D_VERSION >= 0x0800 */

#if(DIRECT3D_VERSION >= 0x0900)

typedef struct _D3DHAL_DP2CREATEVERTEXSHADERDECL
{
    DWORD dwHandle;                         // Shader function handle
    DWORD dwNumVertexElements;              // Number of vertex elements
    // D3DVERTEXELEMENT9 VertexElements[];   Vertex elements follow
} D3DHAL_DP2CREATEVERTEXSHADERDECL ;
typedef D3DHAL_DP2CREATEVERTEXSHADERDECL  *LPD3DHAL_DP2CREATEVERTEXSHADERDECL;

typedef struct _D3DHAL_DP2CREATEVERTEXSHADERFUNC
{
    DWORD dwHandle;     // Shader function handle
    DWORD dwSize;       // Shader function size in bytes
    // Shader declaration follows
} D3DHAL_DP2CREATEVERTEXSHADERFUNC ;
typedef D3DHAL_DP2CREATEVERTEXSHADERFUNC  *LPD3DHAL_DP2CREATEVERTEXSHADERFUNC;

typedef struct _D3DHAL_DP2SETSTREAMSOURCE2
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwVBHandle;   // Vertex buffer handle
    DWORD dwOffset;     // Offset of the first vertex size in bytes
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCE2;
typedef D3DHAL_DP2SETSTREAMSOURCE2  *LPD3DHAL_DP2SETSTREAMSOURCE2;

typedef struct _D3DHAL_DP2SETSTREAMSOURCEFREQ
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwDivider;    // Stream source divider
} D3DHAL_DP2SETSTREAMSOURCEFREQ;
typedef D3DHAL_DP2SETSTREAMSOURCEFREQ *LPD3DHAL_DP2SETSTREAMSOURCEFREQ;

#define D3DHAL_ROW_WEIGHTS  1
#define D3DHAL_COL_WEIGHTS  2
typedef struct _D3DHAL_DP2SETCONVOLUTIONKERNELMONO
{
    DWORD dwWidth;     // Kernel width
    DWORD dwHeight;    // Kernel height
    DWORD dwFlags;
    // If dwFlags & D3DHAL_ROW_WEIGHTS, then width floats follow. Otherwise row weights are 1.0.
    // If dwFlags & D3DHAL_COL_WEIGHTS, then height floats follow. Otherwise column weights are 1.0.
} D3DHAL_DP2SETCONVOLUTIONKERNELMONO;
typedef D3DHAL_DP2SETCONVOLUTIONKERNELMONO *LPD3DHAL_DP2SETCONVOLUTIONKERNELMONO;

typedef struct _D3DHAL_DP2COMPOSERECTS
{
    DWORD               SrcSurfaceHandle; 
    DWORD               DstSurfaceHandle;
    DWORD               SrcRectDescsVBHandle;   
    UINT                NumRects;
    DWORD               DstRectDescsVBHandle;   
    D3DCOMPOSERECTSOP   Operation;
    INT                 XOffset;
    INT                 YOffset;
} D3DHAL_DP2COMPOSERECTS;
typedef D3DHAL_DP2COMPOSERECTS *LPD3DHAL_DP2COMPOSERECTS;

typedef RECT D3DHAL_DP2SETSCISSORRECT;
typedef D3DHAL_DP2SETSCISSORRECT *LPD3DHAL_DP2SETSCISSORRECT;

typedef struct _D3DHAL_DP2BLT
{
    DWORD dwSource;         // Source surface
    RECTL rSource;          // Source rectangle
    DWORD dwSourceMipLevel; // Miplevel of lightweight surface
    DWORD dwDest;           // Dest surface
    RECTL rDest;            // Dest rectangle
    DWORD dwDestMipLevel;   // Miplevel of lightweight surface
    DWORD Flags;            // Can be DP2BLT_POINT, DP2BLT_LINEAR
} D3DHAL_DP2BLT;
typedef D3DHAL_DP2BLT  *LPD3DHAL_DP2BLT;

#define DP2BLT_POINT    0x00000001L
#define DP2BLT_LINEAR   0x00000002L

typedef struct _D3DHAL_DP2COLORFILL
{
    DWORD    dwSurface; // Surface getting filled
    RECTL    rRect;     // Surface dimensions to fill
    D3DCOLOR Color;     // A8R8G8B8 fill color
} D3DHAL_DP2COLORFILL;
typedef D3DHAL_DP2COLORFILL  *LPD3DHAL_DP2COLORFILL;

typedef struct _D3DHAL_DP2SURFACEBLT
{
    DWORD dwSource;         // Source surface
    RECTL rSource;          // Source rectangle
    DWORD dwSourceMipLevel; // Miplevel of lightweight surface
    DWORD dwDest;           // Dest surface
    RECTL rDest;            // Dest rectangle
    DWORD dwDestMipLevel;   // Miplevel of lightweight surface
    DWORD Flags;            // No flags currently defined
} D3DHAL_DP2SURFACEBLT;
typedef D3DHAL_DP2SURFACEBLT  *LPD3DHAL_DP2SURFACEBLT;

typedef D3DHAL_DP2SETVERTEXSHADERCONST D3DHAL_DP2SETVERTEXSHADERCONSTI;
typedef D3DHAL_DP2SETVERTEXSHADERCONST  *LPD3DHAL_DP2SETVERTEXSHADERCONSTI;
typedef D3DHAL_DP2SETVERTEXSHADERCONST D3DHAL_DP2SETVERTEXSHADERCONSTB;
typedef D3DHAL_DP2SETVERTEXSHADERCONSTB  *LPD3DHAL_DP2SETVERTEXSHADERCONSTB;

typedef D3DHAL_DP2SETPIXELSHADERCONST D3DHAL_DP2SETPIXELSHADERCONSTI;
typedef D3DHAL_DP2SETPIXELSHADERCONST  *LPD3DHAL_DP2SETPIXELSHADERCONSTI;
typedef D3DHAL_DP2SETPIXELSHADERCONST D3DHAL_DP2SETPIXELSHADERCONSTB;
typedef D3DHAL_DP2SETPIXELSHADERCONSTB  *LPD3DHAL_DP2SETPIXELSHADERCONSTB;

typedef struct _D3DHAL_DP2CREATEQUERY
{
    DWORD dwQueryID;
    D3DQUERYTYPE QueryType;
} D3DHAL_DP2CREATEQUERY;
typedef D3DHAL_DP2CREATEQUERY  *LPD3DHAL_DP2CREATEQUERY;

typedef struct _D3DHAL_DP2DELETEQUERY
{
    DWORD dwQueryID;
} D3DHAL_DP2DELETEQUERY;
typedef D3DHAL_DP2DELETEQUERY  *LPD3DHAL_DP2DELETEQUERY;

typedef struct _D3DHAL_DP2ISSUEQUERY
{
    DWORD dwQueryID;
    DWORD dwFlags;
} D3DHAL_DP2ISSUEQUERY;
typedef D3DHAL_DP2ISSUEQUERY  *LPD3DHAL_DP2ISSUEQUERY;

typedef struct _D3DHAL_DP2SETRENDERTARGET2
{
    DWORD RTIndex;
    DWORD hRenderTarget;
} D3DHAL_DP2SETRENDERTARGET2;
typedef D3DHAL_DP2SETRENDERTARGET2  *LPD3DHAL_DP2SETRENDERTARGET2;

typedef struct _D3DHAL_DP2SETDEPTHSTENCIL
{
    DWORD hZBuffer;
} D3DHAL_DP2SETDEPTHSTENCIL;
typedef D3DHAL_DP2SETDEPTHSTENCIL  *LPD3DHAL_DP2SETDEPTHSTENCIL;

typedef struct _D3DHAL_DP2GENERATEMIPSUBLEVELS
{
    DWORD                hSurface;
    D3DTEXTUREFILTERTYPE Filter;
} D3DHAL_DP2GENERATEMIPSUBLEVELS;
typedef D3DHAL_DP2GENERATEMIPSUBLEVELS *LPD3DHAL_DP2GENERATEMIPSUBLEVELS;

//
// Command structure for driver responses:
//

typedef struct _D3DHAL_DP2RESPONSE
{
    BYTE bCommand;     /* response/ command id */
    BYTE bReserved;
    WORD wStateCount;  /* count of responses to follow */
    DWORD dwTotalSize; /* total size of response (including the DP2REPONSE struct) to enable skipping over. */
} D3DHAL_DP2RESPONSE, *LPD3DHAL_DP2RESPONSE;

/* Begin Responses */
typedef struct _D3DHAL_DP2RESPONSEQUERY
{
    DWORD dwQueryID;
    DWORD dwSize;
} D3DHAL_DP2RESPONSEQUERY;
typedef D3DHAL_DP2RESPONSEQUERY  *LPD3DHAL_DP2RESPONSEQUERY;
/* End Responses */

#endif /* DIRECT3D_VERSION >= 0x0900 */

typedef struct _D3DHAL_DRAWPRIMITIVES2DATA {
    ULONG_PTR             dwhContext;           // in: Context handle
    DWORD             dwFlags;              // in: flags
    DWORD             dwVertexType;         // in: vertex type
    LPDDRAWI_DDRAWSURFACE_LCL lpDDCommands; // in: vertex buffer command data
    DWORD             dwCommandOffset;      // in: offset to start of vertex buffer commands
    DWORD             dwCommandLength;      // in: number of bytes of command data
    union
    { // based on D3DHALDP2_USERMEMVERTICES flag
       LPDDRAWI_DDRAWSURFACE_LCL lpDDVertex;// in: surface containing vertex data
       LPVOID lpVertices;                   // in: User mode pointer to vertices
    };
    DWORD             dwVertexOffset;       // in: offset to start of vertex data
    DWORD             dwVertexLength;       // in: number of vertices of vertex data
    DWORD             dwReqVertexBufSize;   // in: number of bytes required for the next vertex buffer
    DWORD             dwReqCommandBufSize;  // in: number of bytes required for the next commnand buffer
    LPDWORD           lpdwRStates;          // in: Pointer to the array where render states are updated
    union
    {
       DWORD          dwVertexSize;         // in: Size of each vertex in bytes
       HRESULT        ddrval;               // out: return value
    };
    DWORD             dwErrorOffset;        // out: offset in lpDDCommands to
                                            //      first D3DHAL_COMMAND not handled
} D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DHAL_DRAWPRIMITIVES2DATA  *LPD3DHAL_DRAWPRIMITIVES2DATA;

// Macros to access shader binary code
#define D3DSI_GETREGNUM(token)  (token & D3DSP_REGNUM_MASK)
#define D3DSI_GETOPCODE(command) (command & D3DSI_OPCODE_MASK)
#define D3DSI_GETWRITEMASK(token) (token & D3DSP_WRITEMASK_ALL)
#define D3DVS_GETSWIZZLECOMP(source, component)  (source >> ((component << 1) + 16) & 0x3)
#define D3DVS_GETSWIZZLE(token)  (token & D3DVS_SWIZZLE_MASK)
#define D3DVS_GETSRCMODIFIER(token) (token & D3DSP_SRCMOD_MASK)
#define D3DVS_GETADDRESSMODE(token) (token & D3DVS_ADDRESSMODE_MASK)

#if(DIRECT3D_VERSION < 0x0900)

#define D3DSI_GETREGTYPE(token) ((D3DSHADER_PARAM_REGISTER_TYPE)(token & D3DSP_REGTYPE_MASK))

#else

#define D3DSI_GETREGTYPE(token) ((D3DSHADER_PARAM_REGISTER_TYPE)(((token & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT) | \
                                 ((token & D3DSP_REGTYPE_MASK2) >> D3DSP_REGTYPE_SHIFT2)))
#define D3DSI_GETUSAGE(token) ((token & D3DSP_DCL_USAGE_MASK) >> D3DSP_DCL_USAGE_SHIFT)
#define D3DSI_GETUSAGEINDEX(token) ((token & D3DSP_DCL_USAGEINDEX_MASK) >> D3DSP_DCL_USAGEINDEX_SHIFT)
#define D3DSI_GETINSTLENGTH(token) ((token & D3DSI_INSTLENGTH_MASK) >> D3DSI_INSTLENGTH_SHIFT)
#define D3DSI_GETCOMPARISON(token) ((D3DSHADER_COMPARISON)((token & D3DSHADER_COMPARISON_MASK) >> D3DSHADER_COMPARISON_SHIFT))
#define D3DSI_GETREGISTERPROPERTIES(token) (token & D3DSP_REGISTERPROPERTIES_MASK)
#define D3DSI_GETTEXTURETYPE(token) (token & D3DSP_TEXTURETYPE_MASK)
#define D3DSI_GETDSTMODIFIER(token) (token & D3DSP_DSTMOD_MASK)
#define D3DSI_GETSWIZZLECOMP(source, component)  (source >> ((component << 1) + 16) & 0x3)
#define D3DSI_GETSWIZZLE(token)  (token & D3DVS_SWIZZLE_MASK)
#define D3DSI_GETSRCMODIFIER(token) (token & D3DSP_SRCMOD_MASK)
#define D3DSI_GETADDRESSMODE(token) (token & D3DVS_ADDRESSMODE_MASK)

#ifdef __cplusplus
// This gets regtype, and also maps D3DSPR_CONSTn to D3DSPR_CONST (for easier parsing)
inline D3DSHADER_PARAM_REGISTER_TYPE D3DSI_GETREGTYPE_RESOLVING_CONSTANTS(DWORD token)
{
    D3DSHADER_PARAM_REGISTER_TYPE RegType = D3DSI_GETREGTYPE(token);
    switch(RegType)
    {
    case D3DSPR_CONST4:
    case D3DSPR_CONST3:
    case D3DSPR_CONST2:
        return D3DSPR_CONST;
    default:
        return RegType;
    }
}

// The inline function below retrieves register number for an opcode,
// taking into account that: if the type is a
// D3DSPR_CONSTn, the register number needs to be remapped.
//
//           D3DSPR_CONST is for c0-c2047
//           D3DSPR_CONST2 is for c2048-c4095
//           D3DSPR_CONST3 is for c4096-c6143
//           D3DSPR_CONST4 is for c6144-c8191
//
// For example if the instruction token specifies type D3DSPR_CONST4, reg# 3,
// the register number retrieved is 6147.
// For other register types, the register number is just returned unchanged.
inline UINT D3DSI_GETREGNUM_RESOLVING_CONSTANTS(DWORD token)
{
    D3DSHADER_PARAM_REGISTER_TYPE RegType = D3DSI_GETREGTYPE(token);
    UINT RegNum = D3DSI_GETREGNUM(token);
    switch(RegType)
    {
    case D3DSPR_CONST4:
        return RegNum + 6144;
    case D3DSPR_CONST3:
        return RegNum + 4096;
    case D3DSPR_CONST2:
        return RegNum + 2048;
    default:
        return RegNum;
    }
}
#endif // __cplusplus

#endif

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DHALDP2_EXECUTEBUFFER     0x00000002L
// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DHALDP2_VIDMEMCOMMANDBUF  0x00000080L

// Used by the driver to ask runtime to parse the execute buffer
#define D3DERR_COMMAND_UNPARSED              MAKE_DDHRESULT(3000)

typedef DWORD (CALLBACK *LPD3DHAL_CLEAR2CB)        (LPD3DHAL_CLEAR2DATA);
typedef DWORD (CALLBACK *LPD3DHAL_VALIDATETEXTURESTAGESTATECB)(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWPRIMITIVES2CB)  (LPD3DHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DHAL_CALLBACKS3
{
    DWORD   dwSize;         // size of struct
    DWORD   dwFlags;        // flags for callbacks
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPVOID                                  lpvReserved;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;
} D3DHAL_CALLBACKS3;
typedef D3DHAL_CALLBACKS3 *LPD3DHAL_CALLBACKS3;
#define D3DHAL_CALLBACKS3SIZE       sizeof(D3DHAL_CALLBACKS3)

//  bit definitions for D3DHAL
#define D3DHAL3_CB32_CLEAR2                      0x00000001L
#define D3DHAL3_CB32_RESERVED                    0x00000002L
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE   0x00000004L
#define D3DHAL3_CB32_DRAWPRIMITIVES2             0x00000008L

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#define D3DTSS_TEXTUREMAP 0


#if(DIRECT3D_VERSION >= 0x0900)
/* --------------------------------------------------------------
 * Texture sampler renderstate.
 *
 * D3DSAMPLERSTATETYPE (D3DSAMP_*) sampler states exist to
 * separate sampler state from the rest of the D3DTSS_* states.
 * D3DSAMP_* states are only visible at the API level;
 * the runtime simply maps these to D3DTSS_* for drivers.
 *
 */

/*
 * Maximum number of texture samplers allowed.
 *
 * If this number gets bigger than 32, some retooling
 * will be needed, as DWORD bitfields are used all over the place.
 */
#define D3DHAL_SAMPLER_MAXSAMP          16

/*
 * Maximum number of samplers in vertex shaders (must be power of 2)
 */
#define D3DHAL_SAMPLER_MAXVERTEXSAMP     4

/*
 * Number of state DWORDS per sampler.
 */
#define D3DHAL_SAMPLER_STATESPERSAMP    D3DSAMP_MAX


/*
 * D3DTSS_* states that have been removed from the D3DTEXTURESTAGESTATETYPE
 * and turned into the D3DSAMP_* enum D3DTEXTURESAMPLERTYPE.
 * These defines allow D3DSAMP_* to be mapped to D3DTSS_* through the DDI
 * so that drivers can simply understand D3DTSS_* and do not have to know
 * about D3DSAMP_* at all.
 * These defines are now labelled as D3DTSS_RESERVEDn in the public
 * header definition of D3DTEXTURESTAGESTATETYPE.
 */
#define     D3DTSS_ADDRESSU        ((D3DTEXTURESTAGESTATETYPE)13)
#define     D3DTSS_ADDRESSV        ((D3DTEXTURESTAGESTATETYPE)14)
#define     D3DTSS_BORDERCOLOR     ((D3DTEXTURESTAGESTATETYPE)15)
#define     D3DTSS_MAGFILTER       ((D3DTEXTURESTAGESTATETYPE)16)
#define     D3DTSS_MINFILTER       ((D3DTEXTURESTAGESTATETYPE)17)
#define     D3DTSS_MIPFILTER       ((D3DTEXTURESTAGESTATETYPE)18)
#define     D3DTSS_MIPMAPLODBIAS   ((D3DTEXTURESTAGESTATETYPE)19)
#define     D3DTSS_MAXMIPLEVEL     ((D3DTEXTURESTAGESTATETYPE)20)
#define     D3DTSS_MAXANISOTROPY   ((D3DTEXTURESTAGESTATETYPE)21)
#define     D3DTSS_ADDRESSW        ((D3DTEXTURESTAGESTATETYPE)25)
#define     D3DTSS_SRGBTEXTURE     ((D3DTEXTURESTAGESTATETYPE)29)
#define     D3DTSS_ELEMENTINDEX    ((D3DTEXTURESTAGESTATETYPE)30)
#define     D3DTSS_DMAPOFFSET      ((D3DTEXTURESTAGESTATETYPE)31)

// These renderstates were retired in DX8:
#ifndef D3DRS_SOFTWAREVERTEXPROCESSING
#define D3DRS_SOFTWAREVERTEXPROCESSING ((D3DRENDERSTATETYPE)153)
#endif

// These renderstates were retired in DX9:
#ifndef D3DRS_PATCHSEGMENTS
#define D3DRS_LINEPATTERN   ((D3DRENDERSTATETYPE)10)
#define D3DRS_ZVISIBLE      ((D3DRENDERSTATETYPE)30)
#define D3DRS_PATCHSEGMENTS ((D3DRENDERSTATETYPE)164)
#endif

#endif /* DIRECT3D_VERSION >= 0x0900 */

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DHAL_SCENE_CAPTURE_START  0x00000000L
#define D3DHAL_SCENE_CAPTURE_END    0x00000001L

/*
 * Execute()
 */

/*
 * Use the instruction stream starting at dwOffset.
 */
#define D3DHAL_EXECUTE_NORMAL       0x00000000L

/*
 * Use the optional instruction override (diInstruction) and return
 * after completion.  dwOffset is the offset to the first primitive.
 */
#define D3DHAL_EXECUTE_OVERRIDE     0x00000001L

/*
 * GetState()
 * The driver will get passed a flag in dwWhich specifying which module
 * the state must come from.  The driver then fills in ulArg[1] with the
 * appropriate value depending on the state type given in ddState.
 */

/*
 * The following are used to get the state of a particular stage of the
 * pipeline.
 */
#define D3DHALSTATE_GET_TRANSFORM   0x00000001L
#define D3DHALSTATE_GET_LIGHT       0x00000002L
#define D3DHALSTATE_GET_RENDER      0x00000004L


/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DHAL_CONTEXT_BAD      0x000000200L

/*
 * No more contexts left.
 */
#define D3DHAL_OUTOFCONTEXTS        0x000000201L

/*
 * Execute() and ExecuteClipped()
 */

/*
 * Executed to completion via early out.
 *  (e.g. totally clipped)
 */
#define D3DHAL_EXECUTE_ABORT        0x00000210L

/*
 * An unhandled instruction code was found (e.g. D3DOP_TRANSFORM).
 * The dwOffset parameter must be set to the offset of the unhandled
 * instruction.
 *
 * Only valid from Execute()
 */
#define D3DHAL_EXECUTE_UNHANDLED    0x00000211L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                         LPVOID *lplpvReturnedCommand);


/*
 * DDI only renderstates.
 */
#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE     62      // DDI only to replace SceneCapture
#define D3DRS_DELETERTPATCH       169     // DDI only to delete high order patch
#define D3DRS_MAXVERTEXSHADERINST ((D3DRENDERSTATETYPE)196) // DDI only: vs_3_0+ num instructions to execute.
#define D3DRS_MAXPIXELSHADERINST  ((D3DRENDERSTATETYPE)197) // DDI only: ps_3_0+ num instructions to execute.
#define D3DRS_ZBIAS               ((D3DRENDERSTATETYPE)47) // replaced by depthbias

// Default values for D3DRS_MAXVERTEXSHADERINST and D3DRS_MAXPIXELSHADERINST
#define D3DINFINITEINSTRUCTIONS 0xffffffff

//-----------------------------------------------------------------------------
//
// DirectX 8.0's new driver info querying mechanism.
//
// How to handle the new driver info query mechanism.
//
// DirectX 8.0 utilizes an extension to GetDriverInfo() to query for
// additional information from the driver. Currently this mechanism is only
// used for querying for DX8 style D3D caps but it may be used for other
// information over time.
//
// This extension to GetDriverInfo takes the form of a GetDriverInfo call
// with the GUID GUID_GetDriverInfo2. When a GetDriverInfo call with this
// GUID is received by the driver the driver must check the data passed
// in the lpvData field of the DD_GETDRIVERINFODATA data structure to see
// what information is being requested.
//
// It is important to note that the GUID GUID_GetDriverInfo2 is, in fact,
// the same as the GUID_DDStereoMode. If you driver doesn't handle
// GUID_DDStereoMode this is not an issue. However, if you wish your driver
// to handle GUID_DDStereoMode as well as GUID_GetDriverInfo2 special action
// must be taken. When a call tp GetDriverInfo with the GUID
// GUID_GetDriverInfo2/GUID_DDStereoMode is made the runtime sets the
// dwHeight field of the DD_STEREOMODE structure to the special value
// D3DGDI2_MAGIC. In this way you can determine when the request is a
// stereo mode call or a GetDriverInfo2 call. The dwHeight field of
// DD_STEREOMODE corresponds to the dwMagic field of the
// DD_GETDRIVERINFO2DATA structure.
//
// The dwExpectedSize field of the DD_GETDRIVERINFODATA structure is not
// used by when a GetDriverInfo2 request is being made and should be
// ignored. The actual expected size of the data is found in the
// dwExpectedSize of the DD_GETDRIVERINFO2DATA structure.
//
// Once the driver has determined that this is a call to
// GetDriverInfo2 it must then determine the type of information being
// requested by the runtime. This type is contained in the dwType field
// of the DD_GETDRIVERINFO2DATA data structure.
//
// Finally, once the driver knows this is a GetDriverInfo2 request of a
// particular type it can copy the requested data into the data buffer.
// It is important to note that the lpvData field of the DD_GETDRIVERINFODATA
// data structure points to data buffer in which to copy your data. lpvData
// also points to the DD_GETDRIVERINFO2DATA structure. This means that the
// data returned by the driver will overwrite the DD_GETDRIVERINFO2DATA
// structure and, hence, the DD_GETDRIVERINFO2DATA structure occupies the
// first few DWORDs of the buffer.
//
// The following code fragment demonstrates how to handle GetDriverInfo2.
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (((DD_GETDRIVERINFO2DATA*)(lpData->lpvData))->dwMagic == D3DGDI2_MAGIC)
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = lpData->lpvData;
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 lpData->dwActualSize = 0;
//                 lpData->ddRVal       = DDERR_CURRENTLYNOTAVAIL;
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = lpData->lpvData;
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// The data structure which is passed to the driver when GetDriverInfo is
// called with a GUID of GUID_GetDriverInfo2.
//
// NOTE: Although the fields listed below are all read only this data
// structure is actually the first four DWORDs of the data buffer into
// which the driver writes the requested infomation. As such, these fields
// (and the entire data structure) are overwritten by the data returned by
// the driver.
//
typedef struct _DD_GETDRIVERINFO2DATA
{
    DWORD       dwReserved;     // Reserved Field.
                                // Driver should not read or write this field.

    DWORD       dwMagic;        // Magic Number. Has the value D3DGDI2_MAGIC if
                                // this is a GetDriverInfo2 call. Otherwise
                                // this structure is, in fact, a DD_STEREOMODE
                                // call.
                                // Driver should only read this field.

    DWORD       dwType;         // Type of information requested. This field
                                // contains one of the DDGDI2_TYPE_ #defines
                                // listed below.
                                // Driver should only read (not write) this
                                // field.

    DWORD       dwExpectedSize; // Expected size of the information requested.
                                // Driver should only read (not write) this
                                // field.

    // The remainder of the data buffer (beyond the first four DWORDs)
    // follows here.
} DD_GETDRIVERINFO2DATA;

//
// IMPORTANT NOTE: This GUID has exactly the same value as GUID_DDStereoMode
// and as such you must be very careful when using it. If your driver needs
// to handle both GetDriverInfo2 and DDStereoMode it must have a single
// check for the shared GUID and then distinguish between which use of that
// GUID is being requested.
//
#define GUID_GetDriverInfo2 (GUID_DDStereoMode)

//
// Magic value used to determine whether a GetDriverInfo call with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode is a GetDriverInfo2 request
// or a query about stereo capabilities. This magic number is stored in
// the dwHeight field of the DD_STEREOMODE data structure.
//
#define D3DGDI2_MAGIC       (0xFFFFFFFFul)

//
// The types of information which can be requested from the driver via
// GetDriverInfo2.
//

#define D3DGDI2_TYPE_GETD3DCAPS8            (0x00000001ul) // Return the D3DCAPS8 data
#define D3DGDI2_TYPE_GETFORMATCOUNT         (0x00000002ul) // Return the number of supported formats
#define D3DGDI2_TYPE_GETFORMAT              (0x00000003ul) // Return a particular format
#define D3DGDI2_TYPE_DXVERSION              (0x00000004ul) // Notify driver of current DX Version
#define D3DGDI2_TYPE_GETD3DCAPS9            (0x00000010ul) // Return the D3DCAPS9 data
#define D3DGDI2_TYPE_GETEXTENDEDMODECOUNT   (0x00000011ul) // Return the number of supported extended mode
#define D3DGDI2_TYPE_GETEXTENDEDMODE        (0x00000012ul) // Return a particular extended mode
#define D3DGDI2_TYPE_GETADAPTERGROUP        (0x00000013ul) // Return a adapter group information
#define D3DGDI2_TYPE_GETMULTISAMPLEQUALITYLEVELS (0x00000016ul) // Return the number of multisample quality levels
#define D3DGDI2_TYPE_DEFERRED_AGP_AWARE     (0x00000018ul) // Runtime is aware of deferred AGP frees, and will send following (NT only)
#define D3DGDI2_TYPE_FREE_DEFERRED_AGP      (0x00000019ul) // Free any deferred-freed AGP allocations for this process (NT only)
#define D3DGDI2_TYPE_DEFER_AGP_FREES        (0x00000020ul) // Start defering AGP frees for this process
#define D3DGDI2_TYPE_GETD3DQUERYCOUNT       (0x00000021ul) // Return the number of supported queries
#define D3DGDI2_TYPE_GETD3DQUERY            (0x00000022ul) // Return supported query
#define D3DGDI2_TYPE_GETDDIVERSION          (0x00000023ul) // Return DX9_DDI_VERSION

//
// This data structure is returned by the driver in response to a
// GetDriverInfo2 query with the type D3DGDI2_TYPE_GETFORMATCOUNT. It simply
// gives the number of surface formats supported by the driver. Currently this
// structure consists of a single member giving the number of supported
// surface formats.
//
typedef struct _DD_GETFORMATCOUNTDATA
{
    DD_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                 dwFormatCount; // [out]    Number of supported surface formats
    DWORD                 dwReserved;    // Reserved
} DD_GETFORMATCOUNTDATA;

//
// This data structure is used to request a specific surface format from the
// driver. It is guaranteed that the requested format will be greater than or
// equal to zero and less that the format count reported by the driver from
// the preceeding D3DGDI2_TYPE_GETFORMATCOUNT request.
//
typedef struct _DD_GETFORMATDATA
{
    DD_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                 dwFormatIndex;    // [in]     The format to return
    DDPIXELFORMAT         format;           // [out]    The actual format
} DD_GETFORMATDATA;

//
// This data structure is used to notify drivers about the DirectX version
// number. This is the value that is denoted as DD_RUNTIME_VERSION in the
// DDK headers.
//
typedef struct _DD_DXVERSION
{
    DD_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                 dwDXVersion;      // [in]     The Version of DX
    DWORD                 dwReserved;       // Reserved
} DD_DXVERSION;

// Informs driver that runtime will send a notification after last outstanding AGP
// lock has been released.
typedef struct _DD_DEFERRED_AGP_AWARE_DATA
{
    DD_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
} DD_DEFERRED_AGP_AWARE_DATA;

// Notification that the last AGP lock has been released. Driver can free all deferred AGP
// allocations for this process.
typedef struct _DD_FREE_DEFERRED_AGP_DATA
{
    DD_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
    DWORD dwProcessId;                   // [in] Process ID for whom to free deferred AGP
} DD_FREE_DEFERRED_AGP_DATA;

#if(DIRECT3D_VERSION >= 0x0900)
//
// This data structure is returned by the driver in response to a
// GetDriverInfo2 query with the type D3DGDI2_TYPE_GETEXTENDEDMODECOUNT. It simply
// gives the number of extended video modes supported by the driver. Currently this
// structure consists of a single member giving the number of supported extended
// video modes.
//
typedef struct _DD_GETEXTENDEDMODECOUNTDATA
{
    DD_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                 dwModeCount;   // [out]    Number of supported extended video modes
    DWORD                 dwReserved;    // Reserved
} DD_GETEXTENDEDMODECOUNTDATA;

//
// This data structure is used to request a specific extended video mode from the
// driver. It is guaranteed that the requested format will be greater than or
// equal to zero and less that the format count reported by the driver from
// the preceeding D3DGDI2_TYPE_GETEXTENDEDMODECOUNT request.
//
typedef struct _DD_GETEXTENDEDMODEDATA
{
    DD_GETDRIVERINFO2DATA gdi2;           // [in/out] GetDriverInfo2 data
    DWORD                 dwModeIndex;    // [in]     The format to return
    D3DDISPLAYMODE        mode;           // [out]    The actual format
} DD_GETEXTENDEDMODEDATA;

//
// This data structure is used to request a adapter group information from the driver.
// A adapter group is a set of adapters which share video hardware (like video memory,
// 3D accelerator). Thus it is mainly for DualView video adapter. Direct3D runtime
// will share surface resources (like texture, vertex buffers) across adapters within
// a adapter group upon application's request.
//
typedef struct _DD_GETADAPTERGROUPDATA
{
    DD_GETDRIVERINFO2DATA gdi2;                   // [in/out] GetDriverInfo2 data
    ULONG_PTR             ulUniqueAdapterGroupId; // [out] The unique id of adapter group that this adapter belonging to
    DWORD                 dwReserved1;            // Reserved, must be 0
    DWORD                 dwReserved2;            // Reserved, must be 0
} DD_GETADAPTERGROUPDATA;

typedef struct _DD_MULTISAMPLEQUALITYLEVELSDATA
{
    DD_GETDRIVERINFO2DATA gdi2;          //[in/out] GetDriverInfo2 data
    D3DFORMAT             Format;        //[in] Format of multi-sampled render-target
    BOOL                  bFlip  :  1;   //[in] FALSE means blt-style resolution
    D3DMULTISAMPLE_TYPE   MSType : 31;   //[in]
    DWORD                 QualityLevels; //[out]
} DD_MULTISAMPLEQUALITYLEVELSDATA;

typedef struct _DD_GETD3DQUERYCOUNTDATA
{
    DD_GETDRIVERINFO2DATA gdi2;           // [in/out] GetDriverInfo2 data
    DWORD                 dwNumQueries;   // [out]    Number of queries
} DD_GETD3DQUERYCOUNTDATA;

typedef struct _DD_GETD3DQUERYDATA
{
    DD_GETDRIVERINFO2DATA gdi2;           // [in/out] GetDriverInfo2 data
    union
    {
        DWORD                 dwQueryIndex; // [in] Index of cap
        D3DQUERYTYPE          QueryType;    // [out] Query cap
    };
} DD_GETD3DQUERYDATA;

typedef struct _DD_GETDDIVERSIONDATA
{
    DD_GETDRIVERINFO2DATA gdi2;           // [in/out] GetDriverInfo2 data
    DWORD                 dwDXVersion;    // [in] DX version (9 for DX9, etc.)
    DWORD                 dwDDIVersion;   // [out] DX9_DDI_VERSION
} DD_GETDDIVERSIONDATA;

#define DX9_DDI_VERSION     4

#endif /* DIRECT3D_VERSION >= 0x0900 */

#if(DIRECT3D_VERSION >= 0x0900)

// GetDriverState IDs - D3DDEVINFO structures used for query mechanism in public headers

#define D3DDEVINFOID_VCACHE                 4   /* Used with D3DDEVINFOID_VCACHE */

// This was eliminated in DX9 but was exposed in DX8.1 so the drivers still need it
#define D3DFMT_W11V11U10 (D3DFORMAT)65

#endif /* DIRECT3D_VERSION >= 0x0900 */

// New Caps that are not API visible that the driver exposes.
#define D3DDEVCAPS_HWVERTEXBUFFER       0x02000000L /* Device supports Driver Allocated Vertex Buffers*/
#define D3DDEVCAPS_HWINDEXBUFFER        0x04000000L /* Device supports Driver Allocated Index Buffers*/
#define D3DDEVCAPS_SUBVOLUMELOCK        0x08000000L /* Device supports locking a part of volume texture*/
#ifndef D3DPMISCCAPS_FOGINFVF
#define D3DPMISCCAPS_FOGINFVF           0x00002000L /* Device supports separate fog value in the FVF */
#endif
#ifndef D3DFVF_FOG
#define D3DFVF_FOG                      0x00002000L /* There is a separate fog value in the FVF vertex */
#endif

//
// This stuff is not API visible but should be DDI visible.
// Should be in Sync with d3d8types.h
//
#define D3DFMT_D32    (D3DFORMAT)71
#define D3DFMT_S1D15  (D3DFORMAT)72
#define D3DFMT_D15S1  (D3DFORMAT)73
#define D3DFMT_S8D24  (D3DFORMAT)74
#define D3DFMT_D24S8  (D3DFORMAT)75
#define D3DFMT_X8D24  (D3DFORMAT)76
#define D3DFMT_D24X8 (D3DFORMAT)77
#define D3DFMT_X4S4D24 (D3DFORMAT)78
#define D3DFMT_D24X4S4 (D3DFORMAT)79


//-------------- Vertex shader defines --------------------------------
// Vertex Shader register limits. D3D device must provide at least
// specified number of registers

// This one was used by DX8 only.
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_1  128

// Max number of labels in a shader
#define D3DVS_LABEL_MAX_V3_0            2048

// Max number of output texture coordinates
#define D3DVS_TCRDOUTREG_MAX_V1_1       8
#define D3DVS_TCRDOUTREG_MAX_V2_0       8
#define D3DVS_TCRDOUTREG_MAX_V2_1       8
#define D3DVS_OUTPUTREG_MAX_V3_0       12
#define D3DVS_OUTPUTREG_MAX_SW_DX9     16

// Max number of output registers
#define D3DVS_OUTPUTREG_MAX_V3_0        12

// Max number of output attributes (colors)
#define D3DVS_ATTROUTREG_MAX_V1_1       2
#define D3DVS_ATTROUTREG_MAX_V2_0       2
#define D3DVS_ATTROUTREG_MAX_V2_1       2

// Max number of input registers
#define D3DVS_INPUTREG_MAX_V1_1         16
#define D3DVS_INPUTREG_MAX_V2_0         16
#define D3DVS_INPUTREG_MAX_V2_1         16
#define D3DVS_INPUTREG_MAX_V3_0         16

// Max number of temp registers
#define D3DVS_TEMPREG_MAX_V1_1          12
#define D3DVS_TEMPREG_MAX_V2_0          12
#define D3DVS_TEMPREG_MAX_V2_1          32
#define D3DVS_TEMPREG_MAX_V3_0          32

// Max number of constant float vector registers
#define D3DVS_CONSTREG_MAX_V1_1         96
#define D3DVS_CONSTREG_MAX_V2_0         8192
#define D3DVS_CONSTREG_MAX_V2_1         8192
#define D3DVS_CONSTREG_MAX_V3_0         8192

#define D3DVS_CONSTINTREG_MAX_SW_DX9    2048

// Max number of integer constant registers
#define D3DVS_CONSTINTREG_MAX_V2_0      16
#define D3DVS_CONSTINTREG_MAX_V2_1      16
#define D3DVS_CONSTINTREG_MAX_V3_0      16

#define D3DVS_CONSTBOOLREG_MAX_SW_DX9   2048

// Max number of BOOL constant registers
#define D3DVS_CONSTBOOLREG_MAX_V2_0     16
#define D3DVS_CONSTBOOLREG_MAX_V2_1     16
#define D3DVS_CONSTBOOLREG_MAX_V3_0     16

// Max number of vector address registers
#define D3DVS_ADDRREG_MAX_V1_1          1
#define D3DVS_ADDRREG_MAX_V2_0          1
#define D3DVS_ADDRREG_MAX_V2_1          1
#define D3DVS_ADDRREG_MAX_V3_0          1

// Max absolute value of the loop step
#define D3DVS_MAXLOOPSTEP_V2_0          128
#define D3DVS_MAXLOOPSTEP_V2_1          128
#define D3DVS_MAXLOOPSTEP_V3_0          128

// Max absolute value of the loop initial valuep
#define D3DVS_MAXLOOPINITVALUE_V2_0     255
#define D3DVS_MAXLOOPINITVALUE_V2_1     255
#define D3DVS_MAXLOOPINITVALUE_V3_0     255

// Max loop interation count
#define D3DVS_MAXLOOPITERATIONCOUNT_V2_0 255
#define D3DVS_MAXLOOPITERATIONCOUNT_V2_1 255
#define D3DVS_MAXLOOPITERATIONCOUNT_V3_0 255

// Number of PREDICATE registers
#define D3DVS_PREDICATE_MAX_V2_1         1
#define D3DVS_PREDICATE_MAX_V3_0         1

//---------------- End vertex shader defines -------------------------------


//---------------- Pixel shader defines ------------------------------------
// Pixel Shader register limits. D3D device must provide at least
// specified number of registers

// Number of INPUT registers based on shader version
#define D3DPS_INPUTREG_MAX_V1_1         2
#define D3DPS_INPUTREG_MAX_V1_2         2
#define D3DPS_INPUTREG_MAX_V1_3         2
#define D3DPS_INPUTREG_MAX_V1_4         2
#define D3DPS_INPUTREG_MAX_V2_0         2
#define D3DPS_INPUTREG_MAX_V2_1         2
#define D3DPS_INPUTREG_MAX_V3_0         10
#define D3DPS_INPUTREG_MAX_SW_DX9       14

// Number of TEMP registers based on shader version
#define D3DPS_TEMPREG_MAX_V1_1          2
#define D3DPS_TEMPREG_MAX_V1_2          2
#define D3DPS_TEMPREG_MAX_V1_3          2
#define D3DPS_TEMPREG_MAX_V1_4          6
#define D3DPS_TEMPREG_MAX_V2_0          12
#define D3DPS_TEMPREG_MAX_V2_1          32
#define D3DPS_TEMPREG_MAX_V3_0          32

// Number of TEXTURE registers based on shader version
#define D3DPS_TEXTUREREG_MAX_V1_1       4
#define D3DPS_TEXTUREREG_MAX_V1_2       4
#define D3DPS_TEXTUREREG_MAX_V1_3       4
#define D3DPS_TEXTUREREG_MAX_V1_4       6
#define D3DPS_TEXTUREREG_MAX_V2_0       8
#define D3DPS_TEXTUREREG_MAX_V2_1       8
#define D3DPS_TEXTUREREG_MAX_V3_0       0

// Number of COLOROUT registers based on shader version
#define D3DPS_COLOROUT_MAX_V2_0         4
#define D3DPS_COLOROUT_MAX_V2_1         4
#define D3DPS_COLOROUT_MAX_V3_0         4

// Number of PREDICATE registers based on shader version
#define D3DPS_PREDICATE_MAX_V2_1         1
#define D3DPS_PREDICATE_MAX_V3_0         1

// Number of FLOAT constants based on shader version
#define D3DPS_CONSTREG_MAX_V1_1         8
#define D3DPS_CONSTREG_MAX_V1_2         8
#define D3DPS_CONSTREG_MAX_V1_3         8
#define D3DPS_CONSTREG_MAX_V1_4         8
#define D3DPS_CONSTREG_MAX_V2_0         32
#define D3DPS_CONSTREG_MAX_V2_1         32
#define D3DPS_CONSTREG_MAX_V3_0         224
#define D3DPS_CONSTREG_MAX_SW_DX9       8192

// Max number of pixel shader hardware BOOL constant registers
#define D3DPS_CONSTBOOLREG_MAX_V2_1     16
#define D3DPS_CONSTBOOLREG_MAX_V3_0     16
#define D3DPS_CONSTBOOLREG_MAX_SW_DX9   2048

// Max number of pixel shader hardware INTEGER constant registers
#define D3DPS_CONSTINTREG_MAX_V2_1     16
#define D3DPS_CONSTINTREG_MAX_V3_0     16
#define D3DPS_CONSTINTREG_MAX_SW_DX9   2048

// Max absolute value for loop step
#define D3DPS_MAXLOOPSTEP_V2_1          128
#define D3DPS_MAXLOOPSTEP_V3_0          128

// Max absolute value for loop initial value
#define D3DPS_MAXLOOPINITVALUE_V2_1     255
#define D3DPS_MAXLOOPINITVALUE_V3_0     255

// Max loop interation count
#define D3DPS_MAXLOOPITERATIONCOUNT_V2_1 255
#define D3DPS_MAXLOOPITERATIONCOUNT_V3_0 255

//---------------- End pixel shader defines -------------------------------

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         8
#define D3DPS_TEXTUREREG_MAX_DX8       8

#if(DIRECT3D_VERSION >= 0x0900)

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x00    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x01    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x02    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x03    // 4D float
#define D3DVSDT_D3DCOLOR    0x04    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_UBYTE4      0x05    // 4D unsigned byte
#define D3DVSDT_SHORT2      0x06    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x07    // 4D signed short

#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_BLENDINDICES    2
#define D3DVSDE_NORMAL          3
#define D3DVSDE_PSIZE           4
#define D3DVSDE_DIFFUSE         5
#define D3DVSDE_SPECULAR        6
#define D3DVSDE_TEXCOORD0       7
#define D3DVSDE_TEXCOORD1       8
#define D3DVSDE_TEXCOORD2       9
#define D3DVSDE_TEXCOORD3       10
#define D3DVSDE_TEXCOORD4       11
#define D3DVSDE_TEXCOORD5       12
#define D3DVSDE_TEXCOORD6       13
#define D3DVSDE_TEXCOORD7       14
#define D3DVSDE_POSITION2       15
#define D3DVSDE_NORMAL2         16

/* DX8 style vertex declaration

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:20] 0x0
      [19:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    Vertex Input Memory from Tessellator Data (single DWORD token)
      [31:29] 0x3
      [28]    indicates whether data is normals or u/v
      [27:24] 0x0
      [23:20] vertex register address (0..15)
      [19:16] type (dimensionality)
      [15:04] 0x0
      [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:07] 0x0
    [06:00] constant memory address (0..95)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set of stream data definition tokens.  This token sequence fully defines that stream, including the set of elements within the stream, the order in which the elements appear, the type of each element, and the vertex register into which to load an element.
Streams are allowed to include data which is not loaded into a vertex register, thus allowing data which is not used for this shader to exist in the vertex stream.  This skipped data is defined only by a count of DWORDs to skip over, since the type information is irrelevant.
The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into registers and the fourth skipped over.  Register 3 is loaded with the first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  The next two DWORDs (7th and 8th) are skipped over and not loaded into any vertex input register.   Register 7 is loaded with the 9th and 10th DWORDS interpreted as FLOAT data.
Placing of tokens other than NOPs between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

#ifndef __COMMONHALDEFINES
#define __COMMONHALDEFINES

typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;
#endif __COMMONHALDEFINES

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0x7F << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..15] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [0..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | (_ConstantAddress))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     ((0x02) << D3DVSD_DATATYPESHIFT) | (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     ((0x01) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

#endif /* DIRECT3D_VERSION >= 0x0900 */

#endif /* _D3DHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\codecapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    codecapi.h

Abstract:

    CodecAPI Definitions.

--*/

#ifndef __CODECAPI_H
#define __CODECAPI_H

#ifdef UUID_GEN
    #define DEFINE_CODECAPI_GUID( name, guidstr, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 ) \
        OUR_GUID_ENTRY( CODECAPI_##name, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 )
#else
    #if !defined(_KS_)
        #error KS.H must be included before codecapi.H
    #endif // !defined(_KS_)

/* Ideally we would like:
        #define DEFINE_CODECAPI_GUID( name, guidstr, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 ) \
            #define STATIC_CODECAPI_##name 0x##g1, 0x##g2, 0x##g3, 0x##g4, 0x##g5, 0x##g6, 0x##g7, 0x##g8, 0x##g9, 0x##g10, 0x##g11 
            DEFINE_GUIDSTRUCT( guidstr, CODECAPI_##name ) 
            #define CODECAPI_##name DEFINE_GUIDNAMED( CODECAPI_##name )
    Unfortunately you can't invoke multiple defines from a single statement
*/
    #define DEFINE_CODECAPI_GUID( name, guidstr, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11 ) DEFINE_GUIDSTRUCT( guidstr, CODECAPI_##name );
    #define DEFINE_CODECAPI_GUIDNAMED( name )       DEFINE_GUIDNAMED( CODECAPI_##name )
#endif

// Windows CodecAPI Properties

// Legend for the 
//  Reference   VariantType VariantField
//  UINT8       VT_UI1      bVal
//  UINT16      VT_UI2      uiVal
//  UINT32      VT_UI4      ulVal
//  UINT64      VT_UI8      ullVal
//  INT8        VT_I1       eVal
//  INT16       VT_I2       iVal
//  INT32       VT_I4       lVal
//  INT64       VT_I8       llVal
//  BOOL        VT_BOOL     boolVal
//  GUID        VT_BSTR     bstrVal (guid string)
//  UINT32/UNINT32 VT_UI8   ullVal  (ratio)

// { Static definitions
    #define STATIC_CODECAPI_AVEncCommonFormatConstraint 0x57cbb9b8, 0x116f, 0x4951, 0xb4, 0x0c, 0xc2, 0xa0, 0x35, 0xed, 0x8f, 0x17 
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatUnSpecified   0xaf46a35a, 0x6024, 0x4525, 0xa4, 0x8a, 0x09, 0x4b, 0x97, 0xf5, 0xb3, 0xc2
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVD_V     0xcc9598c4, 0xe7fe, 0x451d, 0xb1, 0xca, 0x76, 0x1b, 0xc8, 0x40, 0xb7, 0xf3
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVD_DashVR 0xe55199d6, 0x044c, 0x4dae, 0xa4, 0x88, 0x53, 0x1e, 0xd3, 0x06, 0x23, 0x5b
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR 0xe74c6f2e, 0xec37, 0x478d, 0x9a, 0xf4, 0xa5, 0xe1, 0x35, 0xb6, 0x27, 0x1c
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatVCD        0x95035bf7, 0x9d90, 0x40ff, 0xad, 0x5c, 0x5c, 0xf8, 0xcf, 0x71, 0xca, 0x1d
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatSVCD       0x51d85818, 0x8220, 0x448c, 0x80, 0x66, 0xd6, 0x9b, 0xed, 0x16, 0xc9, 0xad
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatATSC       0x8d7b897c, 0xa019, 0x4670, 0xaa, 0x76, 0x2e, 0xdc, 0xac, 0x7a, 0xc2, 0x96
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatDVB        0x71830d8f, 0x6c33, 0x430d, 0x84, 0x4b, 0xc2, 0x70, 0x5b, 0xaa, 0xe6, 0xdb
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatMP3        0x349733cd, 0xeb08, 0x4dc2, 0x81, 0x97, 0xe4, 0x98, 0x35, 0xef, 0x82, 0x8b
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatHighMAT    0x1eabe760, 0xfb2b, 0x4928, 0x90, 0xd1, 0x78, 0xdb, 0x88, 0xee, 0xe8, 0x89
    #define STATIC_CODECAPI_GUID_AVEncCommonFormatHighMPV    0xa2d25db8, 0xb8f9, 0x42c2, 0x8b, 0xc7, 0x0b, 0x93, 0xcf, 0x60, 0x47, 0x88
    #define STATIC_CODECAPI_AVEncCodecType                   0x08af4ac1, 0xf3f2, 0x4c74, 0x9d, 0xcf, 0x37, 0xf2, 0xec, 0x79, 0xf8, 0x26
    #define STATIC_CODECAPI_GUID_AVEncMPEG1Video                0xc8dafefe, 0xda1e, 0x4774, 0xb2, 0x7d, 0x11, 0x83, 0x0c, 0x16, 0xb1, 0xfe
    #define STATIC_CODECAPI_GUID_AVEncMPEG2Video                0x046dc19a, 0x6677, 0x4aaa, 0xa3, 0x1d, 0xc1, 0xab, 0x71, 0x6f, 0x45, 0x60
    #define STATIC_CODECAPI_GUID_AVEncMPEG1Audio                0xd4dd1362, 0xcd4a, 0x4cd6, 0x81, 0x38, 0xb9, 0x4d, 0xb4, 0x54, 0x2b, 0x04
    #define STATIC_CODECAPI_GUID_AVEncMPEG2Audio                0xee4cbb1f, 0x9c3f, 0x4770, 0x92, 0xb5, 0xfc, 0xb7, 0xc2, 0xa8, 0xd3, 0x81
    #define STATIC_CODECAPI_GUID_AVEncWMV                    0x4e0fef9b, 0x1d43, 0x41bd, 0xb8, 0xbd, 0x4d, 0x7b, 0xf7, 0x45, 0x7a, 0x2a
    #define STATIC_CODECAPI_GUID_AVEndMPEG4Video                0xdd37b12a, 0x9503, 0x4f8b, 0xb8, 0xd0, 0x32, 0x4a, 0x00, 0xc0, 0xa1, 0xcf
    #define STATIC_CODECAPI_GUID_AVEncH264Video             0x95044eab, 0x31b3, 0x47de, 0x8e, 0x75, 0x38, 0xa4, 0x2b, 0xb0, 0x3e, 0x28
    #define STATIC_CODECAPI_GUID_AVEncDV                        0x09b769c7, 0x3329, 0x44fb, 0x89, 0x54, 0xfa, 0x30, 0x93, 0x7d, 0x3d, 0x5a
    #define STATIC_CODECAPI_GUID_AVEncWMAPro                 0x1955f90c, 0x33f7, 0x4a68, 0xab, 0x81, 0x53, 0xf5, 0x65, 0x71, 0x25, 0xc4
    #define STATIC_CODECAPI_GUID_AVEncWMALossless            0x55ca7265, 0x23d8, 0x4761, 0x90, 0x31, 0xb7, 0x4f, 0xbe, 0x12, 0xf4, 0xc1
    #define STATIC_CODECAPI_GUID_AVEncWMAVoice              0x13ed18cb, 0x50e8, 0x4276, 0xa2, 0x88, 0xa6, 0xaa, 0x22, 0x83, 0x82, 0xd9
    #define STATIC_CODECAPI_GUID_AVEncDolbyDigitalPro       0xf5be76cc, 0x0ff8, 0x40eb, 0x9c, 0xb1, 0xbb, 0xa9, 0x40, 0x04, 0xd4, 0x4f
    #define STATIC_CODECAPI_GUID_AVEncDolbyDigitalConsumer  0xc1a7bf6c, 0x0059, 0x4bfa, 0x94, 0xef, 0xef, 0x74, 0x7a, 0x76, 0x8d, 0x52
    #define STATIC_CODECAPI_GUID_AVEncDolbyDigitalPlus      0x698d1b80, 0xf7dd, 0x415c, 0x97, 0x1c, 0x42, 0x49, 0x2a, 0x20, 0x56, 0xc6
    #define STATIC_CODECAPI_GUID_AVEncDTSHD                 0x2052e630, 0x469d, 0x4bfb, 0x80, 0xca, 0x1d, 0x65, 0x6e, 0x7e, 0x91, 0x8f
    #define STATIC_CODECAPI_GUID_AVEncDTS                   0x45fbcaa2, 0x5e6e, 0x4ab0, 0x88, 0x93, 0x59, 0x03, 0xbe, 0xe9, 0x3a, 0xcf
    #define STATIC_CODECAPI_GUID_AVEncMLP                   0x05f73e29, 0xf0d1, 0x431e, 0xa4, 0x1c, 0xa4, 0x74, 0x32, 0xec, 0x5a, 0x66
    #define STATIC_CODECAPI_GUID_AVEncPCM                   0x844be7f4, 0x26cf, 0x4779, 0xb3, 0x86, 0xcc, 0x05, 0xd1, 0x87, 0x99, 0x0c
    #define STATIC_CODECAPI_GUID_AVEncSDDS                  0x1dc1b82f, 0x11c8, 0x4c71, 0xb7, 0xb6, 0xee, 0x3e, 0xb9, 0xbc, 0x2b, 0x94
    #define STATIC_CODECAPI_AVEncCommonRateControlMode      0x1c0608e9, 0x370c, 0x4710, 0x8a, 0x58, 0xcb, 0x61, 0x81, 0xc4, 0x24, 0x23
    #define STATIC_CODECAPI_AVEncCommonLowLatency    0x9d3ecd55, 0x89e8, 0x490a, 0x97, 0x0a, 0x0c, 0x95, 0x48, 0xd5, 0xa5, 0x6e
    #define STATIC_CODECAPI_AVEncCommonMultipassMode  0x22533d4c, 0x47e1, 0x41b5, 0x93, 0x52, 0xa2, 0xb7, 0x78, 0x0e, 0x7a, 0xc4
    #define STATIC_CODECAPI_AVEncCommonPassStart     0x6a67739f, 0x4eb5, 0x4385, 0x99, 0x28, 0xf2, 0x76, 0xa9, 0x39, 0xef, 0x95
    #define STATIC_CODECAPI_AVEncCommonPassEnd       0x0e3d01bc, 0xc85c, 0x467d, 0x8b, 0x60, 0xc4, 0x10, 0x12, 0xee, 0x3b, 0xf6
    #define STATIC_CODECAPI_AVEncCommonRealTime      0x143a0ff6, 0xa131, 0x43da, 0xb8, 0x1e, 0x98, 0xfb, 0xb8, 0xec, 0x37, 0x8e
    #define STATIC_CODECAPI_AVEncCommonQuality       0xfcbf57a3, 0x7ea5, 0x4b0c, 0x96, 0x44, 0x69, 0xb4, 0x0c, 0x39, 0xc3, 0x91
    #define STATIC_CODECAPI_AVEncCommonQualityVsSpeed 0x98332df8, 0x03cd, 0x476b, 0x89, 0xfa, 0x3f, 0x9e, 0x44, 0x2d, 0xec, 0x9f
    #define STATIC_CODECAPI_AVEncCommonMeanBitRate   0xf7222374, 0x2144, 0x4815, 0xb5, 0x50, 0xa3, 0x7f, 0x8e, 0x12, 0xee, 0x52
    #define STATIC_CODECAPI_AVEncCommonMeanBitRateInterval 0xbfaa2f0c, 0xcb82, 0x4bc0, 0x84, 0x74, 0xf0, 0x6a, 0x8a, 0x0d, 0x02, 0x58
    #define STATIC_CODECAPI_AVEncCommonMaxBitRate    0x9651eae4, 0x39b9, 0x4ebf, 0x85, 0xef, 0xd7, 0xf4, 0x44, 0xec, 0x74, 0x65
    #define STATIC_CODECAPI_AVEncCommonMinBitRate    0x101405b2, 0x2083, 0x4034, 0xa8, 0x06, 0xef, 0xbe, 0xdd, 0xd7, 0xc9, 0xff
    #define STATIC_CODECAPI_AVEncCommonBufferSize    0x0db96574, 0xb6a4, 0x4c8b, 0x81, 0x06, 0x37, 0x73, 0xde, 0x03, 0x10, 0xcd
    #define STATIC_CODECAPI_AVEncCommonBufferInLevel 0xd9c5c8db, 0xfc74, 0x4064, 0x94, 0xe9, 0xcd, 0x19, 0xf9, 0x47, 0xed, 0x45
    #define STATIC_CODECAPI_AVEncCommonBufferOutLevel 0xccae7f49, 0xd0bc, 0x4e3d, 0xa5, 0x7e, 0xfb, 0x57, 0x40, 0x14, 0x00, 0x69
    #define STATIC_CODECAPI_AVEncCommonStreamEndHandling 0x6aad30af, 0x6ba8, 0x4ccc, 0x8f, 0xca, 0x18, 0xd1, 0x9b, 0xea, 0xeb, 0x1c
    #define STATIC_CODECAPI_AVEncStatCommonCompletedPasses 0x3e5de533, 0x9df7, 0x438c, 0x85, 0x4f, 0x9f, 0x7d, 0xd3, 0x68, 0x3d, 0x34
    #define STATIC_CODECAPI_AVEncVideoOutputFrameRate 0xea85e7c3, 0x9567, 0x4d99, 0x87, 0xc4, 0x02, 0xc1, 0xc2, 0x78, 0xca, 0x7c
    #define STATIC_CODECAPI_AVEncVideoOutputFrameRateConversion 0x8c068bf4, 0x369a, 0x4ba3, 0x82, 0xfd, 0xb2, 0x51, 0x8f, 0xb3, 0x39, 0x6e
    #define STATIC_CODECAPI_AVEncVideoPixelAspectRatio 0x3cdc718f, 0xb3e9, 0x4eb6, 0xa5, 0x7f, 0xcf, 0x1f, 0x1b, 0x32, 0x1b, 0x87
    #define STATIC_CODECAPI_AVEncVideoForceSourceScanType 0x1ef2065f, 0x058a, 0x4765, 0xa4, 0xfc, 0x8a, 0x86, 0x4c, 0x10, 0x30, 0x12
    #define STATIC_CODECAPI_AVEncVideoNoOfFieldsToEncode 0x61e4bbe2, 0x4ee0, 0x40e7, 0x80, 0xab, 0x51, 0xdd, 0xee, 0xbe, 0x62, 0x91
    #define STATIC_CODECAPI_AVEncVideoNoOfFieldsToSkip 0xa97e1240, 0x1427, 0x4c16, 0xa7, 0xf7, 0x3d, 0xcf, 0xd8, 0xba, 0x4c, 0xc5
    #define STATIC_CODECAPI_AVEncVideoEncodeDimension 0x1074df28, 0x7e0f, 0x47a4, 0xa4, 0x53, 0xcd, 0xd7, 0x38, 0x70, 0xf5, 0xce
    #define STATIC_CODECAPI_AVEncVideoEncodeOffsetOrigin 0x6bc098fe, 0xa71a, 0x4454, 0x85, 0x2e, 0x4d, 0x2d, 0xde, 0xb2, 0xcd, 0x24
    #define STATIC_CODECAPI_AVEncVideoDisplayDimension 0xde053668, 0xf4ec, 0x47a9, 0x86, 0xd0, 0x83, 0x67, 0x70, 0xf0, 0xc1, 0xd5
    #define STATIC_CODECAPI_AVEncVideoOutputScanType 0x460b5576, 0x842e, 0x49ab, 0xa6, 0x2d, 0xb3, 0x6f, 0x73, 0x12, 0xc9, 0xdb
    #define STATIC_CODECAPI_AVEncVideoInverseTelecineEnable 0x2ea9098b, 0xe76d, 0x4ccd, 0xa0, 0x30, 0xd3, 0xb8, 0x89, 0xc1, 0xb6, 0x4c
    #define STATIC_CODECAPI_AVEncVideoInverseTelecineThreshold 0x40247d84, 0xe895, 0x497f, 0xb4, 0x4c, 0xb7, 0x45, 0x60, 0xac, 0xfe, 0x27
    #define STATIC_CODECAPI_AVEncVideoSourceFilmContent 0x1791c64b, 0xccfc, 0x4827, 0xa0, 0xed, 0x25, 0x57, 0x79, 0x3b, 0x2b, 0x1c
    #define STATIC_CODECAPI_AVEncVideoSourceIsBW 0x42ffc49b, 0x1812, 0x4fdc, 0x8d, 0x24, 0x70, 0x54, 0xc5, 0x21, 0xe6, 0xeb
    #define STATIC_CODECAPI_AVEncVideoFieldSwap  0xfefd7569, 0x4e0a, 0x49f2, 0x9f, 0x2b, 0x36, 0x0e, 0xa4, 0x8c, 0x19, 0xa2
    #define STATIC_CODECAPI_AVEncVideoInputChromaResolution  0xbb0cec33, 0x16f1, 0x47b0, 0x8a, 0x88, 0x37, 0x81, 0x5b, 0xee, 0x17, 0x39
    #define STATIC_CODECAPI_AVEncVideoOutputChromaResolution 0x6097b4c9, 0x7c1d, 0x4e64, 0xbf, 0xcc, 0x9e, 0x97, 0x65, 0x31, 0x8a, 0xe7
    #define STATIC_CODECAPI_AVEncVideoInputChromaSubsampling     0xa8e73a39, 0x4435, 0x4ec3, 0xa6, 0xea, 0x98, 0x30, 0x0f, 0x4b, 0x36, 0xf7
    #define STATIC_CODECAPI_AVEncVideoOutputChromaSubsampling    0xfa561c6c, 0x7d17, 0x44f0, 0x83, 0xc9, 0x32, 0xed, 0x12, 0xe9, 0x63, 0x43
    #define STATIC_CODECAPI_AVEncVideoInputColorPrimaries    0xc24d783f, 0x7ce6, 0x4278, 0x90, 0xab, 0x28, 0xa4, 0xf1, 0xe5, 0xf8, 0x6c
    #define STATIC_CODECAPI_AVEncVideoOutputColorPrimaries   0xbe95907c, 0x9d04, 0x4921, 0x89, 0x85, 0xa6, 0xd6, 0xd8, 0x7d, 0x1a, 0x6c
    #define STATIC_CODECAPI_AVEncVideoInputColorTransferFunction 0x8c056111, 0xa9c3, 0x4b08, 0xa0, 0xa0, 0xce, 0x13, 0xf8, 0xa2, 0x7c, 0x75
    #define STATIC_CODECAPI_AVEncVideoOutputColorTransferFunction    0x4a7f884a, 0xea11, 0x460d, 0xbf, 0x57, 0xb8, 0x8b, 0xc7, 0x59, 0x00, 0xde
    #define STATIC_CODECAPI_AVEncVideoInputColorTransferMatrix   0x52ed68b9, 0x72d5, 0x4089, 0x95, 0x8d, 0xf5, 0x40, 0x5d, 0x55, 0x08, 0x1c
    #define STATIC_CODECAPI_AVEncVideoOutputColorTransferMatrix  0xa9b90444, 0xaf40, 0x4310, 0x8f, 0xbe, 0xed, 0x6d, 0x93, 0x3f, 0x89, 0x2b
    #define STATIC_CODECAPI_AVEncVideoInputColorLighting 0x46a99549, 0x0015, 0x4a45, 0x9c, 0x30, 0x1d, 0x5c, 0xfa, 0x25, 0x83, 0x16
    #define STATIC_CODECAPI_AVEncVideoOutputColorLighting    0x0e5aaac6, 0xace6, 0x4c5c, 0x99, 0x8e, 0x1a, 0x8c, 0x9c, 0x6c, 0x0f, 0x89
    #define STATIC_CODECAPI_AVEncVideoInputColorNominalRange 0x16cf25c6, 0xa2a6, 0x48e9, 0xae, 0x80, 0x21, 0xae, 0xc4, 0x1d, 0x42, 0x7e
    #define STATIC_CODECAPI_AVEncVideoOutputColorNominalRange    0x972835ed, 0x87b5, 0x4e95, 0x95, 0x00, 0xc7, 0x39, 0x58, 0x56, 0x6e, 0x54
    #define STATIC_CODECAPI_AVEncInputVideoSystem    0xbede146d, 0xb616, 0x4dc7, 0x92, 0xb2, 0xf5, 0xd9, 0xfa, 0x92, 0x98, 0xf7
    #define STATIC_CODECAPI_AVEncVideoHeaderDropFrame 0x6ed9e124, 0x7925, 0x43fe, 0x97, 0x1b, 0xe0, 0x19, 0xf6, 0x22, 0x22, 0xb4
    #define STATIC_CODECAPI_AVEncVideoHeaderHours    0x2acc7702, 0xe2da, 0x4158, 0xbf, 0x9b, 0x88, 0x88, 0x01, 0x29, 0xd7, 0x40
    #define STATIC_CODECAPI_AVEncVideoHeaderMinutes  0xdc1a99ce, 0x0307, 0x408b, 0x88, 0x0b, 0xb8, 0x34, 0x8e, 0xe8, 0xca, 0x7f
    #define STATIC_CODECAPI_AVEncVideoHeaderSeconds  0x4a2e1a05, 0xa780, 0x4f58, 0x81, 0x20, 0x9a, 0x44, 0x9d, 0x69, 0x65, 0x6b
    #define STATIC_CODECAPI_AVEncVideoHeaderFrames   0xafd5f567, 0x5c1b, 0x4adc, 0xbd, 0xaf, 0x73, 0x56, 0x10, 0x38, 0x14, 0x36
    #define STATIC_CODECAPI_AVEncVideoDefaultUpperFieldDominant 0x810167c4, 0x0bc1, 0x47ca, 0x8f, 0xc2, 0x57, 0x05, 0x5a, 0x14, 0x74, 0xa5
    #define STATIC_CODECAPI_AVEncVideoCBRMotionTradeoff 0x0d49451e, 0x18d5, 0x4367, 0xa4, 0xef, 0x32, 0x40, 0xdf, 0x16, 0x93, 0xc4
    #define STATIC_CODECAPI_AVEncVideoCodedVideoAccessUnitSize 0xb4b10c15, 0x14a7, 0x4ce8, 0xb1, 0x73, 0xdc, 0x90, 0xa0, 0xb4, 0xfc, 0xdb
    #define STATIC_CODECAPI_AVEncVideoMaxKeyframeDistance   0x2987123a, 0xba93, 0x4704, 0xb4, 0x89, 0xec, 0x1e, 0x5f, 0x25, 0x29, 0x2c
    #define STATIC_CODECAPI_AVEncStatVideoOutputFrameRate 0xbe747849, 0x9ab4, 0x4a63, 0x98, 0xfe, 0xf1, 0x43, 0xf0, 0x4f, 0x8e, 0xe9
    #define STATIC_CODECAPI_AVEncStatVideoCodedFrames    0xd47f8d61, 0x6f5a, 0x4a26, 0xbb, 0x9f, 0xcd, 0x95, 0x18, 0x46, 0x2b, 0xcd
    #define STATIC_CODECAPI_AVEncStatVideoTotalFrames    0xfdaa9916, 0x119a, 0x4222, 0x9a, 0xd6, 0x3f, 0x7c, 0xab, 0x99, 0xcc, 0x8b
    #define STATIC_CODECAPI_AVEncAudioIntervalToEncode   0x866e4b4d, 0x725a, 0x467c, 0xbb, 0x01, 0xb4, 0x96, 0xb2, 0x3b, 0x25, 0xf9
    #define STATIC_CODECAPI_AVEncAudioIntervalToSkip     0x88c15f94, 0xc38c, 0x4796, 0xa9, 0xe8, 0x96, 0xe9, 0x67, 0x98, 0x3f, 0x26
    #define STATIC_CODECAPI_AVEncAudioDualMono           0x3648126b, 0xa3e8, 0x4329, 0x9b, 0x3a, 0x5c, 0xe5, 0x66, 0xa4, 0x3b, 0xd3

    #define STATIC_CODECAPI_AVEncAudioMapDestChannel0    0xbc5d0b60, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel1    0xbc5d0b61, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel2    0xbc5d0b62, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel3    0xbc5d0b63, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel4    0xbc5d0b64, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel5    0xbc5d0b65, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel6    0xbc5d0b66, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel7    0xbc5d0b67, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel8    0xbc5d0b68, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel9    0xbc5d0b69, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel10   0xbc5d0b6a, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel11   0xbc5d0b6b, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel12   0xbc5d0b6c, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel13   0xbc5d0b6d, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel14   0xbc5d0b6e, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d
    #define STATIC_CODECAPI_AVEncAudioMapDestChannel15   0xbc5d0b6f, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d

    #define STATIC_CODECAPI_AVEncAudioInputContent       0x3e226c2b, 0x60b9, 0x4a39, 0xb0, 0x0b, 0xa7, 0xb4, 0x0f, 0x70, 0xd5, 0x66
    #define STATIC_CODECAPI_AVEncStatAudioPeakPCMValue   0xdce7fd34, 0xdc00, 0x4c16, 0x82, 0x1b, 0x35, 0xd9, 0xeb, 0x00, 0xfb, 0x1a
    #define STATIC_CODECAPI_AVEncStatAudioAveragePCMValue 0x979272f8, 0xd17f, 0x4e32, 0xbb, 0x73, 0x4e, 0x73, 0x1c, 0x68, 0xba, 0x2d
    #define STATIC_CODECAPI_AVEncStatAudioAverageBPS 0xca6724db, 0x7059, 0x4351, 0x8b, 0x43, 0xf8, 0x21, 0x98, 0x82, 0x6a, 0x14
    #define STATIC_CODECAPI_AVEncMPVGOPSize          0x95f31b26, 0x95a4, 0x41aa, 0x93, 0x03, 0x24, 0x6a, 0x7f, 0xc6, 0xee, 0xf1
    #define STATIC_CODECAPI_AVEncMPVGOPOpen          0xb1d5d4a6, 0x3300, 0x49b1, 0xae, 0x61, 0xa0, 0x99, 0x37, 0xab, 0x0e, 0x49
    #define STATIC_CODECAPI_AVEncMPVDefaultBPictureCount 0x8d390aac, 0xdc5c, 0x4200, 0xb5, 0x7f, 0x81, 0x4d, 0x04, 0xba, 0xba, 0xb2
    #define STATIC_CODECAPI_AVEncMPVProfile          0xdabb534a, 0x1d99, 0x4284, 0x97, 0x5a, 0xd9, 0x0e, 0x22, 0x39, 0xba, 0xa1
    #define STATIC_CODECAPI_AVEncMPVLevel            0x6ee40c40, 0xa60c, 0x41ef, 0x8f, 0x50, 0x37, 0xc2, 0x24, 0x9e, 0x2c, 0xb3
    #define STATIC_CODECAPI_AVEncMPVFrameFieldMode   0xacb5de96, 0x7b93, 0x4c2f, 0x88, 0x25, 0xb0, 0x29, 0x5f, 0xa9, 0x3b, 0xf4
    #define STATIC_CODECAPI_AVEncMPVAddSeqEndCode    0xa823178f, 0x57df, 0x4c7a, 0xb8, 0xfd, 0xe5, 0xec, 0x88, 0x87, 0x70, 0x8d
    #define STATIC_CODECAPI_AVEncMPVGOPSInSeq        0x993410d4, 0x2691, 0x4192, 0x99, 0x78, 0x98, 0xdc, 0x26, 0x03, 0x66, 0x9f
    #define STATIC_CODECAPI_AVEncMPVUseConcealmentMotionVectors  0xec770cf3, 0x6908, 0x4b4b, 0xaa, 0x30, 0x7f, 0xb9, 0x86, 0x21, 0x4f, 0xea
    #define STATIC_CODECAPI_AVEncMPVSceneDetection   0x552799f1, 0xdb4c, 0x405b, 0x8a, 0x3a, 0xc9, 0x3f, 0x2d, 0x06, 0x74, 0xdc
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderSeqExt 0xd5e78611, 0x082d, 0x4e6b, 0x98, 0xaf, 0x0f, 0x51, 0xab, 0x13, 0x92, 0x22
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderSeqDispExt 0x6437aa6f, 0x5a3c, 0x4de9, 0x8a, 0x16, 0x53, 0xd9, 0xc4, 0xad, 0x32, 0x6f
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderPicExt 0x1b8464ab, 0x944f, 0x45f0, 0xb7, 0x4e, 0x3a, 0x58, 0xda, 0xd1, 0x1f, 0x37
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderPicDispExt 0xc6412f84, 0xc03f, 0x4f40, 0xa0, 0x0c, 0x42, 0x93, 0xdf, 0x83, 0x95, 0xbb
    #define STATIC_CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt 0x0722d62f, 0xdd59, 0x4a86, 0x9c, 0xd5, 0x64, 0x4f, 0x8e, 0x26, 0x53, 0xd8
    #define STATIC_CODECAPI_AVEncMPVScanPattern      0x7f8a478e, 0x7bbb, 0x4ae2, 0xb2, 0xfc, 0x96, 0xd1, 0x7f, 0xc4, 0xa2, 0xd6
    #define STATIC_CODECAPI_AVEncMPVIntraDCPrecision 0xa0116151, 0xcbc8, 0x4af3, 0x97, 0xdc, 0xd0, 0x0c, 0xce, 0xb8, 0x2d, 0x79
    #define STATIC_CODECAPI_AVEncMPVQScaleType       0x2b79ebb7, 0xf484, 0x4af7, 0xbb, 0x58, 0xa2, 0xa1, 0x88, 0xc5, 0xcb, 0xbe
    #define STATIC_CODECAPI_AVEncMPVIntraVLCTable    0xa2b83ff5, 0x1a99, 0x405a, 0xaf, 0x95, 0xc5, 0x99, 0x7d, 0x55, 0x8d, 0x3a
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixIntra 0x9bea04f3, 0x6621, 0x442c, 0x8b, 0xa1, 0x3a, 0xc3, 0x78, 0x97, 0x96, 0x98
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixNonIntra 0x87f441d8, 0x0997, 0x4beb, 0xa0, 0x8e, 0x85, 0x73, 0xd4, 0x09, 0xcf, 0x75
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixChromaIntra 0x9eb9ecd4, 0x018d, 0x4ffd, 0x8f, 0x2d, 0x39, 0xe4, 0x9f, 0x07, 0xb1, 0x7a
    #define STATIC_CODECAPI_AVEncMPVQuantMatrixChromaNonIntra 0x1415b6b1, 0x362a, 0x4338, 0xba, 0x9a, 0x1e, 0xf5, 0x87, 0x03, 0xc0, 0x5b
    #define STATIC_CODECAPI_AVEncMPALayer    0x9d377230, 0xf91b, 0x453d, 0x9c, 0xe0, 0x78, 0x44, 0x54, 0x14, 0xc2, 0x2d
    #define STATIC_CODECAPI_AVEncMPACodingMode       0xb16ade03, 0x4b93, 0x43d7, 0xa5, 0x50, 0x90, 0xb4, 0xfe, 0x22, 0x45, 0x37
    #define STATIC_CODECAPI_AVEncDDService           0xd2e1bec7, 0x5172, 0x4d2a, 0xa5, 0x0e, 0x2f, 0x3b, 0x82, 0xb1, 0xdd, 0xf8
    #define STATIC_CODECAPI_AVEncDDDialogNormalization 0xd7055acf, 0xf125, 0x437d, 0xa7, 0x04, 0x79, 0xc7, 0x9f, 0x04, 0x04, 0xa8
    #define STATIC_CODECAPI_AVEncDDCentreDownMixLevel 0xe285072c, 0xc958, 0x4a81, 0xaf, 0xd2, 0xe5, 0xe0, 0xda, 0xf1, 0xb1, 0x48
    #define STATIC_CODECAPI_AVEncDDSurroundDownMixLevel 0x7b20d6e5, 0x0bcf, 0x4273, 0xa4, 0x87, 0x50, 0x6b, 0x04, 0x79, 0x97, 0xe9
    #define STATIC_CODECAPI_AVEncDDProductionInfoExists 0xb0b7fe5f, 0xb6ab, 0x4f40, 0x96, 0x4d, 0x8d, 0x91, 0xf1, 0x7c, 0x19, 0xe8
    #define STATIC_CODECAPI_AVEncDDProductionRoomType 0xdad7ad60, 0x23d8, 0x4ab7, 0xa2, 0x84, 0x55, 0x69, 0x86, 0xd8, 0xa6, 0xfe
    #define STATIC_CODECAPI_AVEncDDProductionMixLevel 0x301d103a, 0xcbf9, 0x4776, 0x88, 0x99, 0x7c, 0x15, 0xb4, 0x61, 0xab, 0x26
    #define STATIC_CODECAPI_AVEncDDCopyright         0x8694f076, 0xcd75, 0x481d, 0xa5, 0xc6, 0xa9, 0x04, 0xdc, 0xc8, 0x28, 0xf0
    #define STATIC_CODECAPI_AVEncDDOriginalBitstream 0x966ae800, 0x5bd3, 0x4ff9, 0x95, 0xb9, 0xd3, 0x05, 0x66, 0x27, 0x38, 0x56
    #define STATIC_CODECAPI_AVEncDDDigitalDeemphasis 0xe024a2c2, 0x947c, 0x45ac, 0x87, 0xd8, 0xf1, 0x03, 0x0c, 0x5c, 0x00, 0x82
    #define STATIC_CODECAPI_AVEncDDDCHighPassFilter  0x9565239f, 0x861c, 0x4ac8, 0xbf, 0xda, 0xe0, 0x0c, 0xb4, 0xdb, 0x85, 0x48
    #define STATIC_CODECAPI_AVEncDDChannelBWLowPassFilter 0xe197821d, 0xd2e7, 0x43e2, 0xad, 0x2c, 0x00, 0x58, 0x2f, 0x51, 0x85, 0x45
    #define STATIC_CODECAPI_AVEncDDLFELowPassFilter  0xd3b80f6f, 0x9d15, 0x45e5, 0x91, 0xbe, 0x01, 0x9c, 0x3f, 0xab, 0x1f, 0x01
    #define STATIC_CODECAPI_AVEncDDSurround90DegreeePhaseShift 0x25ecec9d, 0x3553, 0x42c0, 0xbb, 0x56, 0xd2, 0x57, 0x92, 0x10, 0x4f, 0x80
    #define STATIC_CODECAPI_AVEncDDSurround3dBAttenuation 0x4d43b99d, 0x31e2, 0x48b9, 0xbf, 0x2e, 0x5c, 0xbf, 0x1a, 0x57, 0x27, 0x84
    #define STATIC_CODECAPI_AVEncDDDynamicRangeCompressionControl 0xcfc2ff6d, 0x79b8, 0x4b8d, 0xa8, 0xaa, 0xa0, 0xc9, 0xbd, 0x1c, 0x29, 0x40
    #define STATIC_CODECAPI_AVEncDDRFPreEmphasisFilter 0x21af44c0, 0x244e, 0x4f3d, 0xa2, 0xcc, 0x3d, 0x30, 0x68, 0xb2, 0xe7, 0x3f
    #define STATIC_CODECAPI_AVEncDDSurroundExMode    0x91607cee, 0xdbdd, 0x4eb6, 0xbc, 0xa2, 0xaa, 0xdf, 0xaf, 0xa3, 0xdd, 0x68
    #define STATIC_CODECAPI_AVEncDDPreferredStereoDownMixMode    0x7f4e6b31, 0x9185, 0x403d, 0xb0, 0xa2, 0x76, 0x37, 0x43, 0xe6, 0xf0, 0x63
    #define STATIC_CODECAPI_AVEncDDLtRtCenterMixLvl_x10 0xdca128a2, 0x491f, 0x4600, 0xb2, 0xda, 0x76, 0xe3, 0x34, 0x4b, 0x41, 0x97
    #define STATIC_CODECAPI_AVEncDDLtRtSurroundMixLvl_x10 0x212246c7, 0x3d2c, 0x4dfa, 0xbc, 0x21, 0x65, 0x2a, 0x90, 0x98, 0x69, 0x0d
    #define STATIC_CODECAPI_AVEncDDLoRoCenterMixLvl_x10 0x1cfba222, 0x25b3, 0x4bf4, 0x9b, 0xfd, 0xe7, 0x11, 0x12, 0x67, 0x85, 0x8c
    #define STATIC_CODECAPI_AVEncDDLoRoSurroundMixLvl_x10 0xe725cff6, 0xeb56, 0x40c7, 0x84, 0x50, 0x2b, 0x93, 0x67, 0xe9, 0x15, 0x55
    #define STATIC_CODECAPI_AVEncDDAtoDConverterType 0x719f9612, 0x81a1, 0x47e0, 0x9a, 0x05, 0xd9, 0x4a, 0xd5, 0xfc, 0xa9, 0x48
    #define STATIC_CODECAPI_AVEncDDHeadphoneMode 0x4052dbec, 0x52f5, 0x42f5, 0x9b, 0x00, 0xd1, 0x34, 0xb1, 0x34, 0x1b, 0x9d
    #define STATIC_CODECAPI_AVEncWMVKeyFrameDistance 0x5569055e, 0xe268, 0x4771, 0xb8, 0x3e, 0x95, 0x55, 0xea, 0x28, 0xae, 0xd3
    #define STATIC_CODECAPI_AVEncWMVInterlacedEncoding 0xe3d00f8a, 0xc6f5, 0x4e14, 0xa5, 0x88, 0x0e, 0xc8, 0x7a, 0x72, 0x6f, 0x9b
    #define STATIC_CODECAPI_AVEncWMVDecoderComplexity 0xf32c0dab, 0xf3cb, 0x4217, 0xb7, 0x9f, 0x87, 0x62, 0x76, 0x8b, 0x5f, 0x67
    #define STATIC_CODECAPI_AVEncWMVKeyFrameBufferLevelMarker 0x51ff1115, 0x33ac, 0x426c, 0xa1, 0xb1, 0x09, 0x32, 0x1b, 0xdf, 0x96, 0xb4
    #define STATIC_CODECAPI_AVEncWMVProduceDummyFrames 0xd669d001, 0x183c, 0x42e3, 0xa3, 0xca, 0x2f, 0x45, 0x86, 0xd2, 0x39, 0x6c
    #define STATIC_CODECAPI_AVEncStatWMVCBAvg        0x6aa6229f, 0xd602, 0x4b9d, 0xb6, 0x8c, 0xc1, 0xad, 0x78, 0x88, 0x4b, 0xef
    #define STATIC_CODECAPI_AVEncStatWMVCBMax        0xe976bef8, 0x00fe, 0x44b4, 0xb6, 0x25, 0x8f, 0x23, 0x8b, 0xc0, 0x34, 0x99
    #define STATIC_CODECAPI_AVEncStatWMVDecoderComplexityProfile 0x89e69fc3, 0x0f9b, 0x436c, 0x97, 0x4a, 0xdf, 0x82, 0x12, 0x27, 0xc9, 0x0d
    #define STATIC_CODECAPI_AVEncStatMPVSkippedEmptyFrames 0x32195fd3, 0x590d, 0x4812, 0xa7, 0xed, 0x6d, 0x63, 0x9a, 0x1f, 0x97, 0x11
    #define STATIC_CODECAPI_AVEncMP12PktzSTDBuffer   0x0b751bd0, 0x819e, 0x478c, 0x94, 0x35, 0x75, 0x20, 0x89, 0x26, 0xb3, 0x77
    #define STATIC_CODECAPI_AVEncMP12PktzStreamID    0xc834d038, 0xf5e8, 0x4408, 0x9b, 0x60, 0x88, 0xf3, 0x64, 0x93, 0xfe, 0xdf
    #define STATIC_CODECAPI_AVEncMP12PktzInitialPTS  0x2a4f2065, 0x9a63, 0x4d20, 0xae, 0x22, 0x0a, 0x1b, 0xc8, 0x96, 0xa3, 0x15
    #define STATIC_CODECAPI_AVEncMP12PktzPacketSize  0xab71347a, 0x1332, 0x4dde, 0xa0, 0xe5, 0xcc, 0xf7, 0xda, 0x8a, 0x0f, 0x22
    #define STATIC_CODECAPI_AVEncMP12PktzCopyright   0xc8f4b0c1, 0x094c, 0x43c7, 0x8e, 0x68, 0xa5, 0x95, 0x40, 0x5a, 0x6e, 0xf8
    #define STATIC_CODECAPI_AVEncMP12PktzOriginal    0x6b178416, 0x31b9, 0x4964, 0x94, 0xcb, 0x6b, 0xff, 0x86, 0x6c, 0xdf, 0x83
    #define STATIC_CODECAPI_AVEncMP12MuxPacketOverhead 0xe40bd720, 0x3955, 0x4453, 0xac, 0xf9, 0xb7, 0x91, 0x32, 0xa3, 0x8f, 0xa0
    #define STATIC_CODECAPI_AVEncMP12MuxNumStreams   0xf7164a41, 0xdced, 0x4659, 0xa8, 0xf2, 0xfb, 0x69, 0x3f, 0x2a, 0x4c, 0xd0
    #define STATIC_CODECAPI_AVEncMP12MuxEarliestPTS  0x157232b6, 0xf809, 0x474e, 0x94, 0x64, 0xa7, 0xf9, 0x30, 0x14, 0xa8, 0x17
    #define STATIC_CODECAPI_AVEncMP12MuxLargestPacketSize 0x35ceb711, 0xf461, 0x4b92, 0xa4, 0xef, 0x17, 0xb6, 0x84, 0x1e, 0xd2, 0x54
    #define STATIC_CODECAPI_AVEncMP12MuxInitialSCR   0x3433ad21, 0x1b91, 0x4a0b, 0xb1, 0x90, 0x2b, 0x77, 0x06, 0x3b, 0x63, 0xa4
    #define STATIC_CODECAPI_AVEncMP12MuxMuxRate      0xee047c72, 0x4bdb, 0x4a9d, 0x8e, 0x21, 0x41, 0x92, 0x6c, 0x82, 0x3d, 0xa7
    #define STATIC_CODECAPI_AVEncMP12MuxPackSize     0xf916053a, 0x1ce8, 0x4faf, 0xaa, 0x0b, 0xba, 0x31, 0xc8, 0x00, 0x34, 0xb8
    #define STATIC_CODECAPI_AVEncMP12MuxSysSTDBufferBound 0x35746903, 0xb545, 0x43e7, 0xbb, 0x35, 0xc5, 0xe0, 0xa7, 0xd5, 0x09, 0x3c
    #define STATIC_CODECAPI_AVEncMP12MuxSysRateBound 0x05f0428a, 0xee30, 0x489d, 0xae, 0x28, 0x20, 0x5c, 0x72, 0x44, 0x67, 0x10
    #define STATIC_CODECAPI_AVEncMP12MuxTargetPacketizer 0xd862212a, 0x2015, 0x45dd, 0x9a, 0x32, 0x1b, 0x3a, 0xa8, 0x82, 0x05, 0xa0
    #define STATIC_CODECAPI_AVEncMP12MuxSysFixed     0xcefb987e, 0x894f, 0x452e, 0x8f, 0x89, 0xa4, 0xef, 0x8c, 0xec, 0x06, 0x3a
    #define STATIC_CODECAPI_AVEncMP12MuxSysCSPS      0x7952ff45, 0x9c0d, 0x4822, 0xbc, 0x82, 0x8a, 0xd7, 0x72, 0xe0, 0x29, 0x93
    #define STATIC_CODECAPI_AVEncMP12MuxSysVideoLock 0xb8296408, 0x2430, 0x4d37, 0xa2, 0xa1, 0x95, 0xb3, 0xe4, 0x35, 0xa9, 0x1d
    #define STATIC_CODECAPI_AVEncMP12MuxSysAudioLock 0x0fbb5752, 0x1d43, 0x47bf, 0xbd, 0x79, 0xf2, 0x29, 0x3d, 0x8c, 0xe3, 0x37
    #define STATIC_CODECAPI_AVEncMP12MuxDVDNavPacks  0xc7607ced, 0x8cf1, 0x4a99, 0x83, 0xa1, 0xee, 0x54, 0x61, 0xbe, 0x35, 0x74

    #define STATIC_CODECAPI_AVEncMPACopyright           0xa6ae762a, 0xd0a9, 0x4454, 0xb8, 0xef, 0xf2, 0xdb, 0xee, 0xfd, 0xd3, 0xbd
    #define STATIC_CODECAPI_AVEncMPAOriginalBitstream   0x3cfb7855, 0x9cc9, 0x47ff, 0xb8, 0x29, 0xb3, 0x67, 0x86, 0xc9, 0x23, 0x46
    #define STATIC_CODECAPI_AVEncMPAEnableRedundancyProtection 0x5e54b09e, 0xb2e7, 0x4973, 0xa8, 0x9b, 0x0b, 0x36, 0x50, 0xa3, 0xbe, 0xda
    #define STATIC_CODECAPI_AVEncMPAPrivateUserBit     0xafa505ce, 0xc1e3, 0x4e3d, 0x85, 0x1b, 0x61, 0xb7, 0x00, 0xe5, 0xe6, 0xcc
    #define STATIC_CODECAPI_AVEncMPAEmphasisType        0x2d59fcda, 0xbf4e, 0x4ed6, 0xb5, 0xdf, 0x5b, 0x03, 0xb3, 0x6b, 0x0a, 0x1f

    #define STATIC_CODECAPI_AVDecCommonMeanBitRate          0x59488217, 0x007a, 0x4f7a, 0x8e, 0x41, 0x5c, 0x48, 0xb1, 0xea, 0xc5, 0xc6
    #define STATIC_CODECAPI_AVDecCommonMeanBitRateInterval  0x0ee437c6, 0x38a7, 0x4c5c, 0x94, 0x4c, 0x68, 0xab, 0x42, 0x11, 0x6b, 0x85
    #define STATIC_CODECAPI_AVDecCommonInputFormat  0xe5005239, 0xbd89, 0x4be3, 0x9c, 0x0f, 0x5d, 0xde, 0x31, 0x79, 0x88, 0xcc 
    #define STATIC_CODECAPI_AVDecCommonOutputFormat                     0x3c790028, 0xc0ce, 0x4256, 0xb1, 0xa2, 0x1b, 0x0f, 0xc8, 0xb1, 0xdc, 0xdc

    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded    0x696e1d30, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM             0x696e1d31, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM       0x696e1d32, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream 0x696e1d33, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones  0x696e1d34, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd
    #define STATIC_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto 0x696e1d35, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd

    #define STATIC_CODECAPI_AVDecVideoImageSize        0x5ee5747c, 0x6801, 0x4cab, 0xaa, 0xf1, 0x62, 0x48, 0xfa, 0x84, 0x1b, 0xa4
    #define STATIC_CODECAPI_AVDecVideoInputScanType    0x38477e1f, 0x0ea7, 0x42cd, 0x8c, 0xd1, 0x13, 0x0c, 0xed, 0x57, 0xc5, 0x80 
    #define STATIC_CODECAPI_AVDecVideoPixelAspectRatio 0xb0cf8245, 0xf32d, 0x41df, 0xb0, 0x2c, 0x87, 0xbd, 0x30, 0x4d, 0x12, 0xab 

    #define STATIC_CODECAPI_GUID_AVDecAudioInputWMA     0xc95e8dcf, 0x4058, 0x4204, 0x8c, 0x42, 0xcb, 0x24, 0xd9, 0x1e, 0x4b, 0x9b 
    #define STATIC_CODECAPI_GUID_AVDecAudioInputWMAPro  0x0128b7c7, 0xda72, 0x4fe3, 0xbe, 0xf8, 0x5c, 0x52, 0xe3, 0x55, 0x77, 0x04
    #define STATIC_CODECAPI_GUID_AVDecAudioInputDolby   0x8e4228a0, 0xf000, 0x4e0b, 0x8f, 0x54, 0xab, 0x8d, 0x24, 0xad, 0x61, 0xa2
    #define STATIC_CODECAPI_GUID_AVDecAudioInputDTS     0x600bc0ca, 0x6a1f, 0x4e91, 0xb2, 0x41, 0x1b, 0xbe, 0xb1, 0xcb, 0x19, 0xe0 
    #define STATIC_CODECAPI_GUID_AVDecAudioInputPCM     0xf2421da5, 0xbbb4, 0x4cd5, 0xa9, 0x96, 0x93, 0x3c, 0x6b, 0x5d, 0x13, 0x47
    #define STATIC_CODECAPI_GUID_AVDecAudioInputMPEG    0x91106f36, 0x02c5, 0x4f75, 0x97, 0x19, 0x3b, 0x7a, 0xbf, 0x75, 0xe1, 0xf6

    #define STATIC_CODECAPI_AVDecAudioDualMono              0x4a52cda8, 0x30f8, 0x4216, 0xbe, 0x0f, 0xba, 0x0b, 0x20, 0x25, 0x92, 0x1d
    #define STATIC_CODECAPI_AVDecAudioDualMonoReproMode     0xa5106186, 0xcc94, 0x4bc9, 0x8c, 0xd9, 0xaa, 0x2f, 0x61, 0xf6, 0x80, 0x7e 

    #define STATIC_CODECAPI_AVAudioChannelCount             0x1d3583c4, 0x1583, 0x474e, 0xb7, 0x1a, 0x5e, 0xe4, 0x63, 0xc1, 0x98, 0xe4
    #define STATIC_CODECAPI_AVAudioChannelConfig            0x17f89cb3, 0xc38d, 0x4368, 0x9e, 0xde, 0x63, 0xb9, 0x4d, 0x17, 0x7f, 0x9f
    #define STATIC_CODECAPI_AVAudioSampleRate               0x971d2723, 0x1acb, 0x42e7, 0x85, 0x5c, 0x52, 0x0a, 0x4b, 0x70, 0xa5, 0xf2

    #define STATIC_CODECAPI_AVDDSurroundMode                0x99f2f386, 0x98d1, 0x4452, 0xa1, 0x63, 0xab, 0xc7, 0x8a, 0x6e, 0xb7, 0x70
    #define STATIC_CODECAPI_AVDecDDOperationalMode          0xd6d6c6d1, 0x064e, 0x4fdd, 0xa4, 0x0e, 0x3e, 0xcb, 0xfc, 0xb7, 0xeb, 0xd0
    #define STATIC_CODECAPI_AVDecDDMatrixDecodingMode       0xddc811a5, 0x04ed, 0x4bf3, 0xa0, 0xca, 0xd0, 0x04, 0x49, 0xf9, 0x35, 0x5f
    #define STATIC_CODECAPI_AVDecDDDynamicRangeScaleHigh    0x50196c21, 0x1f33, 0x4af5, 0xb2, 0x96, 0x11, 0x42, 0x6d, 0x6c, 0x87, 0x89 
    #define STATIC_CODECAPI_AVDecDDDynamicRangeScaleLow     0x044e62e4, 0x11a5, 0x42d5, 0xa3, 0xb2, 0x3b, 0xb2, 0xc7, 0xc2, 0xd7, 0xcf


// end of static definitions }

//
// Common Parameters
//

// AVEncCommonFormatConstraint (GUID)

DEFINE_CODECAPI_GUID( AVEncCommonFormatConstraint,      "57cbb9b8-116f-4951-b40c-c2a035ed8f17", 0x57cbb9b8, 0x116f, 0x4951, 0xb4, 0x0c, 0xc2, 0xa0, 0x35, 0xed, 0x8f, 0x17 )

DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatUnSpecified, "af46a35a-6024-4525-a48a-094b97f5b3c2", 0xaf46a35a, 0x6024, 0x4525, 0xa4, 0x8a, 0x09, 0x4b, 0x97, 0xf5, 0xb3, 0xc2 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVD_V,      "cc9598c4-e7fe-451d-b1ca-761bc840b7f3", 0xcc9598c4, 0xe7fe, 0x451d, 0xb1, 0xca, 0x76, 0x1b, 0xc8, 0x40, 0xb7, 0xf3 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVD_DashVR, "e55199d6-044c-4dae-a488-531ed306235b", 0xe55199d6, 0x044c, 0x4dae, 0xa4, 0x88, 0x53, 0x1e, 0xd3, 0x06, 0x23, 0x5b )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVD_PlusVR, "e74c6f2e-ec37-478d-9af4-a5e135b6271c", 0xe74c6f2e, 0xec37, 0x478d, 0x9a, 0xf4, 0xa5, 0xe1, 0x35, 0xb6, 0x27, 0x1c )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatVCD,        "95035bf7-9d90-40ff-ad5c-5cf8cf71ca1d", 0x95035bf7, 0x9d90, 0x40ff, 0xad, 0x5c, 0x5c, 0xf8, 0xcf, 0x71, 0xca, 0x1d )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatSVCD,       "51d85818-8220-448c-8066-d69bed16c9ad", 0x51d85818, 0x8220, 0x448c, 0x80, 0x66, 0xd6, 0x9b, 0xed, 0x16, 0xc9, 0xad )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatATSC,       "8d7b897c-a019-4670-aa76-2edcac7ac296", 0x8d7b897c, 0xa019, 0x4670, 0xaa, 0x76, 0x2e, 0xdc, 0xac, 0x7a, 0xc2, 0x96 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatDVB,        "71830d8f-6c33-430d-844b-c2705baae6db", 0x71830d8f, 0x6c33, 0x430d, 0x84, 0x4b, 0xc2, 0x70, 0x5b, 0xaa, 0xe6, 0xdb )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatMP3,        "349733cd-eb08-4dc2-8197-e49835ef828b", 0x349733cd, 0xeb08, 0x4dc2, 0x81, 0x97, 0xe4, 0x98, 0x35, 0xef, 0x82, 0x8b )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatHighMAT,    "1eabe760-fb2b-4928-90d1-78db88eee889", 0x1eabe760, 0xfb2b, 0x4928, 0x90, 0xd1, 0x78, 0xdb, 0x88, 0xee, 0xe8, 0x89 )
DEFINE_CODECAPI_GUID( GUID_AVEncCommonFormatHighMPV,    "a2d25db8-b8f9-42c2-8bc7-0b93cf604788", 0xa2d25db8, 0xb8f9, 0x42c2, 0x8b, 0xc7, 0x0b, 0x93, 0xcf, 0x60, 0x47, 0x88 )

// AVEncCodecType (GUID)
DEFINE_CODECAPI_GUID( AVEncCodecType,                   "08af4ac1-f3f2-4c74-9dcf-37f2ec79f826", 0x08af4ac1, 0xf3f2, 0x4c74, 0x9d, 0xcf, 0x37, 0xf2, 0xec, 0x79, 0xf8, 0x26 )

DEFINE_CODECAPI_GUID( GUID_AVEncMPEG1Video,             "c8dafefe-da1e-4774-b27d-11830c16b1fe", 0xc8dafefe, 0xda1e, 0x4774, 0xb2, 0x7d, 0x11, 0x83, 0x0c, 0x16, 0xb1, 0xfe )
DEFINE_CODECAPI_GUID( GUID_AVEncMPEG2Video,             "046dc19a-6677-4aaa-a31d-c1ab716f4560", 0x046dc19a, 0x6677, 0x4aaa, 0xa3, 0x1d, 0xc1, 0xab, 0x71, 0x6f, 0x45, 0x60 )
DEFINE_CODECAPI_GUID( GUID_AVEncMPEG1Audio,             "d4dd1362-cd4a-4cd6-8138-b94db4542b04", 0xd4dd1362, 0xcd4a, 0x4cd6, 0x81, 0x38, 0xb9, 0x4d, 0xb4, 0x54, 0x2b, 0x04 )
DEFINE_CODECAPI_GUID( GUID_AVEncMPEG2Audio,             "ee4cbb1f-9c3f-4770-92b5-fcb7c2a8d381", 0xee4cbb1f, 0x9c3f, 0x4770, 0x92, 0xb5, 0xfc, 0xb7, 0xc2, 0xa8, 0xd3, 0x81 )
DEFINE_CODECAPI_GUID( GUID_AVEncWMV,                    "4e0fef9b-1d43-41bd-b8bd-4d7bf7457a2a", 0x4e0fef9b, 0x1d43, 0x41bd, 0xb8, 0xbd, 0x4d, 0x7b, 0xf7, 0x45, 0x7a, 0x2a )
DEFINE_CODECAPI_GUID( GUID_AVEndMPEG4Video,             "dd37b12a-9503-4f8b-b8d0-324a00c0a1cf", 0xdd37b12a, 0x9503, 0x4f8b, 0xb8, 0xd0, 0x32, 0x4a, 0x00, 0xc0, 0xa1, 0xcf )
DEFINE_CODECAPI_GUID( GUID_AVEncH264Video,              "95044eab-31b3-47de-8e75-38a42bb03e28", 0x95044eab, 0x31b3, 0x47de, 0x8e, 0x75, 0x38, 0xa4, 0x2b, 0xb0, 0x3e, 0x28 )
DEFINE_CODECAPI_GUID( GUID_AVEncDV,                     "09b769c7-3329-44fb-8954-fa30937d3d5a", 0x09b769c7, 0x3329, 0x44fb, 0x89, 0x54, 0xfa, 0x30, 0x93, 0x7d, 0x3d, 0x5a )
DEFINE_CODECAPI_GUID( GUID_AVEncWMAPro,                 "1955f90c-33f7-4a68-ab81-53f5657125c4", 0x1955f90c, 0x33f7, 0x4a68, 0xab, 0x81, 0x53, 0xf5, 0x65, 0x71, 0x25, 0xc4 )
DEFINE_CODECAPI_GUID( GUID_AVEncWMALossless,            "55ca7265-23d8-4761-9031-b74fbe12f4c1", 0x55ca7265, 0x23d8, 0x4761, 0x90, 0x31, 0xb7, 0x4f, 0xbe, 0x12, 0xf4, 0xc1 )
DEFINE_CODECAPI_GUID( GUID_AVEncWMAVoice,               "13ed18cb-50e8-4276-a288-a6aa228382d9", 0x13ed18cb, 0x50e8, 0x4276, 0xa2, 0x88, 0xa6, 0xaa, 0x22, 0x83, 0x82, 0xd9 )
DEFINE_CODECAPI_GUID( GUID_AVEncDolbyDigitalPro,        "f5be76cc-0ff8-40eb-9cb1-bba94004d44f", 0xf5be76cc, 0x0ff8, 0x40eb, 0x9c, 0xb1, 0xbb, 0xa9, 0x40, 0x04, 0xd4, 0x4f )
DEFINE_CODECAPI_GUID( GUID_AVEncDolbyDigitalConsumer,   "c1a7bf6c-0059-4bfa-94ef-ef747a768d52", 0xc1a7bf6c, 0x0059, 0x4bfa, 0x94, 0xef, 0xef, 0x74, 0x7a, 0x76, 0x8d, 0x52 )
DEFINE_CODECAPI_GUID( GUID_AVEncDolbyDigitalPlus,       "698d1b80-f7dd-415c-971c-42492a2056c6", 0x698d1b80, 0xf7dd, 0x415c, 0x97, 0x1c, 0x42, 0x49, 0x2a, 0x20, 0x56, 0xc6 )
DEFINE_CODECAPI_GUID( GUID_AVEncDTSHD,                  "2052e630-469d-4bfb-80ca-1d656e7e918f", 0x2052e630, 0x469d, 0x4bfb, 0x80, 0xca, 0x1d, 0x65, 0x6e, 0x7e, 0x91, 0x8f )
DEFINE_CODECAPI_GUID( GUID_AVEncDTS,                    "45fbcaa2-5e6e-4ab0-8893-5903bee93acf", 0x45fbcaa2, 0x5e6e, 0x4ab0, 0x88, 0x93, 0x59, 0x03, 0xbe, 0xe9, 0x3a, 0xcf )
DEFINE_CODECAPI_GUID( GUID_AVEncMLP,                    "05f73e29-f0d1-431e-a41c-a47432ec5a66", 0x05f73e29, 0xf0d1, 0x431e, 0xa4, 0x1c, 0xa4, 0x74, 0x32, 0xec, 0x5a, 0x66 )
DEFINE_CODECAPI_GUID( GUID_AVEncPCM,                    "844be7f4-26cf-4779-b386-cc05d187990c", 0x844be7f4, 0x26cf, 0x4779, 0xb3, 0x86, 0xcc, 0x05, 0xd1, 0x87, 0x99, 0x0c )
DEFINE_CODECAPI_GUID( GUID_AVEncSDDS,                   "1dc1b82f-11c8-4c71-b7b6-ee3eb9bc2b94", 0x1dc1b82f, 0x11c8, 0x4c71, 0xb7, 0xb6, 0xee, 0x3e, 0xb9, 0xbc, 0x2b, 0x94 )

    
    

// AVEncCommonRateControlMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonRateControlMode,       "1c0608e9-370c-4710-8a58-cb6181c42423", 0x1c0608e9, 0x370c, 0x4710, 0x8a, 0x58, 0xcb, 0x61, 0x81, 0xc4, 0x24, 0x23 )

enum eAVEncCommonRateControlMode
{
    eAVEncCommonRateControlMode_CBR                = 0,
    eAVEncCommonRateControlMode_PeakConstrainedVBR = 1,
    eAVEncCommonRateControlMode_UnconstrainedVBR   = 2,
    eAVEncCommonRateControlMode_Quality            = 3
};

// AVEncCommonLowLatency (BOOL)
DEFINE_CODECAPI_GUID( AVEncCommonLowLatency,    "9d3ecd55-89e8-490a-970a-0c9548d5a56e", 0x9d3ecd55, 0x89e8, 0x490a, 0x97, 0x0a, 0x0c, 0x95, 0x48, 0xd5, 0xa5, 0x6e )

// AVEncCommonMultipassMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMultipassMode,  "22533d4c-47e1-41b5-9352-a2b7780e7ac4", 0x22533d4c, 0x47e1, 0x41b5, 0x93, 0x52, 0xa2, 0xb7, 0x78, 0x0e, 0x7a, 0xc4 )

// AVEncCommonPassStart (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonPassStart,     "6a67739f-4eb5-4385-9928-f276a939ef95", 0x6a67739f, 0x4eb5, 0x4385, 0x99, 0x28, 0xf2, 0x76, 0xa9, 0x39, 0xef, 0x95 )

// AVEncCommonPassEnd (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonPassEnd,       "0e3d01bc-c85c-467d-8b60-c41012ee3bf6", 0x0e3d01bc, 0xc85c, 0x467d, 0x8b, 0x60, 0xc4, 0x10, 0x12, 0xee, 0x3b, 0xf6 )

// AVEncCommonRealTime (BOOL)
DEFINE_CODECAPI_GUID( AVEncCommonRealTime,      "143a0ff6-a131-43da-b81e-98fbb8ec378e", 0x143a0ff6, 0xa131, 0x43da, 0xb8, 0x1e, 0x98, 0xfb, 0xb8, 0xec, 0x37, 0x8e )

// AVEncCommonQuality (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonQuality,       "fcbf57a3-7ea5-4b0c-9644-69b40c39c391", 0xfcbf57a3, 0x7ea5, 0x4b0c, 0x96, 0x44, 0x69, 0xb4, 0x0c, 0x39, 0xc3, 0x91 )

// AVEncCommonQualityVsSpeed (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonQualityVsSpeed, "98332df8-03cd-476b-89fa-3f9e442dec9f", 0x98332df8, 0x03cd, 0x476b, 0x89, 0xfa, 0x3f, 0x9e, 0x44, 0x2d, 0xec, 0x9f )

// AVEncCommonMeanBitRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMeanBitRate,   "f7222374-2144-4815-b550-a37f8e12ee52", 0xf7222374, 0x2144, 0x4815, 0xb5, 0x50, 0xa3, 0x7f, 0x8e, 0x12, 0xee, 0x52 )

// AVEncCommonMeanBitRateInterval (UINT64)
DEFINE_CODECAPI_GUID( AVEncCommonMeanBitRateInterval, "bfaa2f0c-cb82-4bc0-8474-f06a8a0d0258", 0xbfaa2f0c, 0xcb82, 0x4bc0, 0x84, 0x74, 0xf0, 0x6a, 0x8a, 0x0d, 0x02, 0x58 )

// AVEncCommonMaxBitRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMaxBitRate,    "9651eae4-39b9-4ebf-85ef-d7f444ec7465", 0x9651eae4, 0x39b9, 0x4ebf, 0x85, 0xef, 0xd7, 0xf4, 0x44, 0xec, 0x74, 0x65 )

// AVEncCommonMinBitRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonMinBitRate,    "101405b2-2083-4034-a806-efbeddd7c9ff", 0x101405b2, 0x2083, 0x4034, 0xa8, 0x06, 0xef, 0xbe, 0xdd, 0xd7, 0xc9, 0xff )

// AVEncCommonBufferSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonBufferSize,    "0db96574-b6a4-4c8b-8106-3773de0310cd", 0x0db96574, 0xb6a4, 0x4c8b, 0x81, 0x06, 0x37, 0x73, 0xde, 0x03, 0x10, 0xcd )

// AVEncCommonBufferInLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonBufferInLevel, "d9c5c8db-fc74-4064-94e9-cd19f947ed45", 0xd9c5c8db, 0xfc74, 0x4064, 0x94, 0xe9, 0xcd, 0x19, 0xf9, 0x47, 0xed, 0x45 )

// AVEncCommonBufferOutLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonBufferOutLevel, "ccae7f49-d0bc-4e3d-a57e-fb5740140069", 0xccae7f49, 0xd0bc, 0x4e3d, 0xa5, 0x7e, 0xfb, 0x57, 0x40, 0x14, 0x00, 0x69 )

// AVEncCommonStreamEndHandling (UINT32)
DEFINE_CODECAPI_GUID( AVEncCommonStreamEndHandling, "6aad30af-6ba8-4ccc-8fca-18d19beaeb1c", 0x6aad30af, 0x6ba8, 0x4ccc, 0x8f, 0xca, 0x18, 0xd1, 0x9b, 0xea, 0xeb, 0x1c )

enum eAVEncCommonStreamEndHandling
{
    eAVEncCommonStreamEndHandling_DiscardPartial = 0,
    eAVEncCommonStreamEndHandling_EnsureComplete = 1
};

//
// Common Post Encode Statistical Parameters
//

// AVEncStatCommonCompletedPasses (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatCommonCompletedPasses, "3e5de533-9df7-438c-854f-9f7dd3683d34", 0x3e5de533, 0x9df7, 0x438c, 0x85, 0x4f, 0x9f, 0x7d, 0xd3, 0x68, 0x3d, 0x34 )

//
// Common Video Parameters
//

// AVEncVideoOutputFrameRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoOutputFrameRate, "ea85e7c3-9567-4d99-87c4-02c1c278ca7c", 0xea85e7c3, 0x9567, 0x4d99, 0x87, 0xc4, 0x02, 0xc1, 0xc2, 0x78, 0xca, 0x7c )

// AVEncVideoOutputFrameRateConversion (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoOutputFrameRateConversion, "8c068bf4-369a-4ba3-82fd-b2518fb3396e", 0x8c068bf4, 0x369a, 0x4ba3, 0x82, 0xfd, 0xb2, 0x51, 0x8f, 0xb3, 0x39, 0x6e )

enum eAVEncVideoOutputFrameRateConversion
{
    eAVEncVideoOutputFrameRateConversion_Disable = 0,
    eAVEncVideoOutputFrameRateConversion_Enable  = 1,
    eAVEncVideoOutputFrameRateConversion_Alias   = 2
};

// AVEncVideoPixelAspectRatio (UINT32 as UINT16/UNIT16) <---- You have WORD in the doc
DEFINE_CODECAPI_GUID( AVEncVideoPixelAspectRatio, "3cdc718f-b3e9-4eb6-a57f-cf1f1b321b87", 0x3cdc718f, 0xb3e9, 0x4eb6, 0xa5, 0x7f, 0xcf, 0x1f, 0x1b, 0x32, 0x1b, 0x87 )

// AVEncVideoForceSourceScanType (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoForceSourceScanType, "1ef2065f-058a-4765-a4fc-8a864c103012", 0x1ef2065f, 0x058a, 0x4765, 0xa4, 0xfc, 0x8a, 0x86, 0x4c, 0x10, 0x30, 0x12 )
enum eAVEncVideoSourceScanType
{
    eAVEncVideoSourceScan_Automatic         = 0,
    eAVEncVideoSourceScan_Interlaced        = 1,
    eAVEncVideoSourceScan_Progressive       = 2
};

// AVEncVideoNoOfFieldsToEncode (UINT64)
DEFINE_CODECAPI_GUID( AVEncVideoNoOfFieldsToEncode, "61e4bbe2-4ee0-40e7-80ab-51ddeebe6291", 0x61e4bbe2, 0x4ee0, 0x40e7, 0x80, 0xab, 0x51, 0xdd, 0xee, 0xbe, 0x62, 0x91 )

// AVEncVideoNoOfFieldsToSkip (UINT64)
DEFINE_CODECAPI_GUID( AVEncVideoNoOfFieldsToSkip, "a97e1240-1427-4c16-a7f7-3dcfd8ba4cc5", 0xa97e1240, 0x1427, 0x4c16, 0xa7, 0xf7, 0x3d, 0xcf, 0xd8, 0xba, 0x4c, 0xc5 )

// AVEncVideoEncodeDimension (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoEncodeDimension, "1074df28-7e0f-47a4-a453-cdd73870f5ce", 0x1074df28, 0x7e0f, 0x47a4, 0xa4, 0x53, 0xcd, 0xd7, 0x38, 0x70, 0xf5, 0xce )

// AVEncVideoEncodeOffsetOrigin (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoEncodeOffsetOrigin, "6bc098fe-a71a-4454-852e-4d2ddeb2cd24", 0x6bc098fe, 0xa71a, 0x4454, 0x85, 0x2e, 0x4d, 0x2d, 0xde, 0xb2, 0xcd, 0x24 )

// AVEncVideoDisplayDimension (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoDisplayDimension, "de053668-f4ec-47a9-86d0-836770f0c1d5", 0xde053668, 0xf4ec, 0x47a9, 0x86, 0xd0, 0x83, 0x67, 0x70, 0xf0, 0xc1, 0xd5 )

// AVEncVideoOutputScanType (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoOutputScanType, "460b5576-842e-49ab-a62d-b36f7312c9db", 0x460b5576, 0x842e, 0x49ab, 0xa6, 0x2d, 0xb3, 0x6f, 0x73, 0x12, 0xc9, 0xdb )
enum eAVEncVideoOutputScanType
{
    eAVEncVideoOutputScan_Progressive       = 0, 
    eAVEncVideoOutputScan_Interlaced        = 1,
    eAVEncVideoOutputScan_SameAsInput       = 2,
    eAVEncVideoOutputScan_Automatic         = 3
};

// AVEncVideoInverseTelecineEnable (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoInverseTelecineEnable, "2ea9098b-e76d-4ccd-a030-d3b889c1b64c", 0x2ea9098b, 0xe76d, 0x4ccd, 0xa0, 0x30, 0xd3, 0xb8, 0x89, 0xc1, 0xb6, 0x4c )

// AVEncVideoInverseTelecineThreshold (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInverseTelecineThreshold, "40247d84-e895-497f-b44c-b74560acfe27", 0x40247d84, 0xe895, 0x497f, 0xb4, 0x4c, 0xb7, 0x45, 0x60, 0xac, 0xfe, 0x27 )

// AVEncVideoSourceFilmContent (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoSourceFilmContent, "1791c64b-ccfc-4827-a0ed-2557793b2b1c", 0x1791c64b, 0xccfc, 0x4827, 0xa0, 0xed, 0x25, 0x57, 0x79, 0x3b, 0x2b, 0x1c )

enum eAVEncVideoFilmContent
{
    eAVEncVideoFilmContent_VideoOnly = 0,
    eAVEncVideoFilmContent_FilmOnly  = 1,
    eAVEncVideoFilmContent_Mixed     = 2
};

// AVEncVideoSourceIsBW (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoSourceIsBW, "42ffc49b-1812-4fdc-8d24-7054c521e6eb", 0x42ffc49b, 0x1812, 0x4fdc, 0x8d, 0x24, 0x70, 0x54, 0xc5, 0x21, 0xe6, 0xeb )

// AVEncVideoFieldSwap (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoFieldSwap,  "fefd7569-4e0a-49f2-9f2b-360ea48c19a2", 0xfefd7569, 0x4e0a, 0x49f2, 0x9f, 0x2b, 0x36, 0x0e, 0xa4, 0x8c, 0x19, 0xa2 )

// AVEncVideoInputChromaResolution (UINT32)
// AVEncVideoOutputChromaSubsamplingFormat (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputChromaResolution,  "bb0cec33-16f1-47b0-8a88-37815bee1739", 0xbb0cec33, 0x16f1, 0x47b0, 0x8a, 0x88, 0x37, 0x81, 0x5b, 0xee, 0x17, 0x39 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputChromaResolution, "6097b4c9-7c1d-4e64-bfcc-9e9765318ae7", 0x6097b4c9, 0x7c1d, 0x4e64, 0xbf, 0xcc, 0x9e, 0x97, 0x65, 0x31, 0x8a, 0xe7 )

enum eAVEncVideoChromaResolution
{
    eAVEncVideoChromaResolution_SameAsSource =0 ,
    eAVEncVideoChromaResolution_444 = 1,
    eAVEncVideoChromaResolution_422 = 2,
    eAVEncVideoChromaResolution_420 = 3,
    eAVEncVideoChromaResolution_411 = 4
};

// AVEncVideoInputChromaSubsampling (UINT32)
// AVEncVideoOutputChromaSubsampling (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputChromaSubsampling,     "a8e73a39-4435-4ec3-a6ea-98300f4b36f7", 0xa8e73a39, 0x4435, 0x4ec3, 0xa6, 0xea, 0x98, 0x30, 0x0f, 0x4b, 0x36, 0xf7 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputChromaSubsampling,    "fa561c6c-7d17-44f0-83c9-32ed12e96343", 0xfa561c6c, 0x7d17, 0x44f0, 0x83, 0xc9, 0x32, 0xed, 0x12, 0xe9, 0x63, 0x43 )

enum eAVEncVideoChromaSubsampling
{
    eAVEncVideoChromaSubsamplingFormat_SameAsSource                   = 0,
    eAVEncVideoChromaSubsamplingFormat_ProgressiveChroma              = 0x8,
    eAVEncVideoChromaSubsamplingFormat_Horizontally_Cosited           = 0x4,
    eAVEncVideoChromaSubsamplingFormat_Vertically_Cosited             = 0x2,
    eAVEncVideoChromaSubsamplingFormat_Vertically_AlignedChromaPlanes = 0x1,
};

// AVEncVideoInputColorPrimaries (UINT32)
// AVEncVideoOutputColorPrimaries (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorPrimaries,    "c24d783f-7ce6-4278-90ab-28a4f1e5f86c", 0xc24d783f, 0x7ce6, 0x4278, 0x90, 0xab, 0x28, 0xa4, 0xf1, 0xe5, 0xf8, 0x6c )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorPrimaries,   "be95907c-9d04-4921-8985-a6d6d87d1a6c", 0xbe95907c, 0x9d04, 0x4921, 0x89, 0x85, 0xa6, 0xd6, 0xd8, 0x7d, 0x1a, 0x6c )

enum eAVEncVideoColorPrimaries
{
    eAVEncVideoColorPrimaries_SameAsSource  = 0, 
    eAVEncVideoColorPrimaries_Reserved      = 1,
    eAVEncVideoColorPrimaries_BT709         = 2,
    eAVEncVideoColorPrimaries_BT470_2_SysM  = 3,
    eAVEncVideoColorPrimaries_BT470_2_SysBG = 4,
    eAVEncVideoColorPrimaries_SMPTE170M     = 5,
    eAVEncVideoColorPrimaries_SMPTE240M     = 6,
    eAVEncVideoColorPrimaries_EBU3231       = 7,
    eAVEncVideoColorPrimaries_SMPTE_C       = 8
};

// AVEncVideoInputColorTransferFunction (UINT32)
// AVEncVideoOutputColorTransferFunction (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorTransferFunction, "8c056111-a9c3-4b08-a0a0-ce13f8a27c75", 0x8c056111, 0xa9c3, 0x4b08, 0xa0, 0xa0, 0xce, 0x13, 0xf8, 0xa2, 0x7c, 0x75 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorTransferFunction,    "4a7f884a-ea11-460d-bf57-b88bc75900de", 0x4a7f884a, 0xea11, 0x460d, 0xbf, 0x57, 0xb8, 0x8b, 0xc7, 0x59, 0x00, 0xde )

enum eAVEncVideoColorTransferFunction
{
    eAVEncVideoColorTransferFunction_SameAsSource = 0,
    eAVEncVideoColorTransferFunction_10           = 1,  // (Linear, scRGB)
    eAVEncVideoColorTransferFunction_18           = 2,
    eAVEncVideoColorTransferFunction_20           = 3,
    eAVEncVideoColorTransferFunction_22           = 4,  // (BT470-2 SysM) 
    eAVEncVideoColorTransferFunction_22_709       = 5,  // (BT709,  SMPTE296M, SMPTE170M, BT470, SMPTE274M, BT.1361) 
    eAVEncVideoColorTransferFunction_22_240M      = 6,  // (SMPTE240M, interim 274M)
    eAVEncVideoColorTransferFunction_22_8bit_sRGB = 7,  // (sRGB)
    eAVEncVideoColorTransferFunction_28           = 8
};

// AVEncVideoInputColorTransferMatrix (UINT32)
// AVEncVideoOutputColorTransferMatrix (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorTransferMatrix,   "52ed68b9-72d5-4089-958d-f5405d55081c", 0x52ed68b9, 0x72d5, 0x4089, 0x95, 0x8d, 0xf5, 0x40, 0x5d, 0x55, 0x08, 0x1c )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorTransferMatrix , "a9b90444-af40-4310-8fbe-ed6d933f892b", 0xa9b90444, 0xaf40, 0x4310, 0x8f, 0xbe, 0xed, 0x6d, 0x93, 0x3f, 0x89, 0x2b )


enum eAVEncVideoColorTransferMatrix
{
    eAVEncVideoColorTransferMatrix_SameAsSource = 0,
    eAVEncVideoColorTransferMatrix_BT709        = 1,
    eAVEncVideoColorTransferMatrix_BT601        = 2,  // (601, BT470-2 B,B, 170M)
    eAVEncVideoColorTransferMatrix_SMPTE240M    = 3
};

// AVEncVideoInputColorLighting (UINT32)
// AVEncVideoOutputColorLighting (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorLighting, "46a99549-0015-4a45-9c30-1d5cfa258316", 0x46a99549, 0x0015, 0x4a45, 0x9c, 0x30, 0x1d, 0x5c, 0xfa, 0x25, 0x83, 0x16 )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorLighting ,   "0e5aaac6-ace6-4c5c-998e-1a8c9c6c0f89", 0x0e5aaac6, 0xace6, 0x4c5c, 0x99, 0x8e, 0x1a, 0x8c, 0x9c, 0x6c, 0x0f, 0x89 )

enum eAVEncVideoColorLighting
{
    eAVEncVideoColorLighting_SameAsSource = 0,
    eAVEncVideoColorLighting_Unknown      = 1,
    eAVEncVideoColorLighting_Bright       = 2,
    eAVEncVideoColorLighting_Office       = 3,
    eAVEncVideoColorLighting_Dim          = 4,
    eAVEncVideoColorLighting_Dark         = 5
};

// AVEncVideoInputColorNominalRange (UINT32)
// AVEncVideoOutputColorNominalRange (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoInputColorNominalRange, "16cf25c6-a2a6-48e9-ae80-21aec41d427e", 0x16cf25c6, 0xa2a6, 0x48e9, 0xae, 0x80, 0x21, 0xae, 0xc4, 0x1d, 0x42, 0x7e )
DEFINE_CODECAPI_GUID( AVEncVideoOutputColorNominalRange ,   "972835ed-87b5-4e95-9500-c73958566e54", 0x972835ed, 0x87b5, 0x4e95, 0x95, 0x00, 0xc7, 0x39, 0x58, 0x56, 0x6e, 0x54 )

enum eAVEncVideoColorNominalRange
{
    eAVEncVideoColorNominalRange_SameAsSource = 0,
    eAVEncVideoColorNominalRange_0_255        = 1,  // (8 bit: 0..255, 10 bit: 0..1023)
    eAVEncVideoColorNominalRange_16_235       = 2,  // (16..235, 64..940 (16*4...235*4) 
    eAVEncVideoColorNominalRange_48_208       = 3   // (48..208) 
};

// AVEncInputVideoSystem (UINT32)
DEFINE_CODECAPI_GUID( AVEncInputVideoSystem,    "bede146d-b616-4dc7-92b2-f5d9fa9298f7", 0xbede146d, 0xb616, 0x4dc7, 0x92, 0xb2, 0xf5, 0xd9, 0xfa, 0x92, 0x98, 0xf7 )

enum eAVEncInputVideoSystem
{
    eAVEncInputVideoSystem_Unspecified = 0,
    eAVEncInputVideoSystem_PAL       = 1,
    eAVEncInputVideoSystem_NTSC      = 2,
    eAVEncInputVideoSystem_SECAM     = 3,
    eAVEncInputVideoSystem_MAC       = 4,
    eAVEncInputVideoSystem_HDV       = 5,
    eAVEncInputVideoSystem_Component = 6
};

// AVEncVideoHeaderDropFrame (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderDropFrame, "6ed9e124-7925-43fe-971b-e019f62222b4", 0x6ed9e124, 0x7925, 0x43fe, 0x97, 0x1b, 0xe0, 0x19, 0xf6, 0x22, 0x22, 0xb4 )

// AVEncVideoHeaderHours (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderHours,    "2acc7702-e2da-4158-bf9b-88880129d740", 0x2acc7702, 0xe2da, 0x4158, 0xbf, 0x9b, 0x88, 0x88, 0x01, 0x29, 0xd7, 0x40 )

// AVEncVideoHeaderMinutes (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderMinutes,  "dc1a99ce-0307-408b-880b-b8348ee8ca7f", 0xdc1a99ce, 0x0307, 0x408b, 0x88, 0x0b, 0xb8, 0x34, 0x8e, 0xe8, 0xca, 0x7f )

// AVEncVideoHeaderSeconds (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderSeconds,  "4a2e1a05-a780-4f58-8120-9a449d69656b", 0x4a2e1a05, 0xa780, 0x4f58, 0x81, 0x20, 0x9a, 0x44, 0x9d, 0x69, 0x65, 0x6b )

// AVEncVideoHeaderFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoHeaderFrames,   "afd5f567-5c1b-4adc-bdaf-735610381436", 0xafd5f567, 0x5c1b, 0x4adc, 0xbd, 0xaf, 0x73, 0x56, 0x10, 0x38, 0x14, 0x36 )

// AVEncVideoDefaultUpperFieldDominant (BOOL)
DEFINE_CODECAPI_GUID( AVEncVideoDefaultUpperFieldDominant, "810167c4-0bc1-47ca-8fc2-57055a1474a5", 0x810167c4, 0x0bc1, 0x47ca, 0x8f, 0xc2, 0x57, 0x05, 0x5a, 0x14, 0x74, 0xa5 )

// AVEncVideoCBRMotionTradeoff (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoCBRMotionTradeoff, "0d49451e-18d5-4367-a4ef-3240df1693c4", 0x0d49451e, 0x18d5, 0x4367, 0xa4, 0xef, 0x32, 0x40, 0xdf, 0x16, 0x93, 0xc4 )

// AVEncVideoCodedVideoAccessUnitSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoCodedVideoAccessUnitSize, "b4b10c15-14a7-4ce8-b173-dc90a0b4fcdb", 0xb4b10c15, 0x14a7, 0x4ce8, 0xb1, 0x73, 0xdc, 0x90, 0xa0, 0xb4, 0xfc, 0xdb )

// AVEncVideoMaxKeyframeDistance (UINT32)
DEFINE_CODECAPI_GUID( AVEncVideoMaxKeyframeDistance, "2987123a-ba93-4704-b489-ec1e5f25292c", 0x2987123a, 0xba93, 0x4704, 0xb4, 0x89, 0xec, 0x1e, 0x5f, 0x25, 0x29, 0x2c )

//
// Common Post-Encode Video Statistical Parameters
//

// AVEncStatVideoOutputFrameRate (UINT32/UINT32)
DEFINE_CODECAPI_GUID( AVEncStatVideoOutputFrameRate, "be747849-9ab4-4a63-98fe-f143f04f8ee9", 0xbe747849, 0x9ab4, 0x4a63, 0x98, 0xfe, 0xf1, 0x43, 0xf0, 0x4f, 0x8e, 0xe9 )

// AVEncStatVideoCodedFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatVideoCodedFrames,    "d47f8d61-6f5a-4a26-bb9f-cd9518462bcd", 0xd47f8d61, 0x6f5a, 0x4a26, 0xbb, 0x9f, 0xcd, 0x95, 0x18, 0x46, 0x2b, 0xcd )

// AVEncStatVideoTotalFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatVideoTotalFrames,    "fdaa9916-119a-4222-9ad6-3f7cab99cc8b", 0xfdaa9916, 0x119a, 0x4222, 0x9a, 0xd6, 0x3f, 0x7c, 0xab, 0x99, 0xcc, 0x8b )

//
// Common Audio Parameters
//

// AVEncAudioIntervalToEncode (UINT64)
DEFINE_CODECAPI_GUID( AVEncAudioIntervalToEncode,   "866e4b4d-725a-467c-bb01-b496b23b25f9", 0x866e4b4d, 0x725a, 0x467c, 0xbb, 0x01, 0xb4, 0x96, 0xb2, 0x3b, 0x25, 0xf9 )

// AVEncAudioIntervalToSkip (UINT64)
DEFINE_CODECAPI_GUID( AVEncAudioIntervalToSkip,     "88c15f94-c38c-4796-a9e8-96e967983f26", 0x88c15f94, 0xc38c, 0x4796, 0xa9, 0xe8, 0x96, 0xe9, 0x67, 0x98, 0x3f, 0x26 )

// AVEncAudioDualMono (UINT32) - Read/Write
// Some audio encoders can encode 2 channel input as "dual mono". Use this
// property to set the appropriate field in the bitstream header to indicate that the 
// 2 channel bitstream is or isn't dual mono. 
// For encoding MPEG audio, use the DualChannel option in AVEncMPACodingMode instead
DEFINE_CODECAPI_GUID( AVEncAudioDualMono, "3648126b-a3e8-4329-9b3a-5ce566a43bd3", 0x3648126b, 0xa3e8, 0x4329, 0x9b, 0x3a, 0x5c, 0xe5, 0x66, 0xa4, 0x3b, 0xd3 )

enum eAVEncAudioDualMono
{
    eAVEncAudioDualMono_SameAsInput = 0, // As indicated by input media type 
    eAVEncAudioDualMono_Off         = 1,  // 2-ch output bitstream should not be dual mono
    eAVEncAudioDualMono_On          = 2   // 2-ch output bitstream should be dual mono
}; 

// AVEncAudioMapDestChannel0..15 (UINT32)
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel0,    "bc5d0b60-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b60, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel1,    "bc5d0b61-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b61, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel2,    "bc5d0b62-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b62, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel3,    "bc5d0b63-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b63, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel4,    "bc5d0b64-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b64, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel5,    "bc5d0b65-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b65, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel6,    "bc5d0b66-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b66, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel7,    "bc5d0b67-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b67, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel8,    "bc5d0b68-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b68, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel9,    "bc5d0b69-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b69, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel10,   "bc5d0b6a-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6a, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel11,   "bc5d0b6b-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6b, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel12,   "bc5d0b6c-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6c, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel13,   "bc5d0b6d-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6d, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel14,   "bc5d0b6e-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6e, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )
DEFINE_CODECAPI_GUID( AVEncAudioMapDestChannel15,   "bc5d0b6f-df6a-4e16-9803-b82007a30c8d", 0xbc5d0b6f, 0xdf6a, 0x4e16, 0x98, 0x03, 0xb8, 0x20, 0x07, 0xa3, 0x0c, 0x8d )

// AVEncAudioInputContent (UINT32) <---- You have ENUM in the doc
DEFINE_CODECAPI_GUID( AVEncAudioInputContent,       "3e226c2b-60b9-4a39-b00b-a7b40f70d566", 0x3e226c2b, 0x60b9, 0x4a39, 0xb0, 0x0b, 0xa7, 0xb4, 0x0f, 0x70, 0xd5, 0x66 )

enum eAVEncAudioInputContent
{
    AVEncAudioInputContent_Unknown =0,
    AVEncAudioInputContent_Voice = 1,
    AVEncAudioInputContent_Music = 2
};

//
// Common Post-Encode Audio Statistical Parameters
//

// AVEncStatAudioPeakPCMValue (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatAudioPeakPCMValue,   "dce7fd34-dc00-4c16-821b-35d9eb00fb1a", 0xdce7fd34, 0xdc00, 0x4c16, 0x82, 0x1b, 0x35, 0xd9, 0xeb, 0x00, 0xfb, 0x1a )

// AVEncStatAudioAveragePCMValue (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatAudioAveragePCMValue, "979272f8-d17f-4e32-bb73-4e731c68ba2d", 0x979272f8, 0xd17f, 0x4e32, 0xbb, 0x73, 0x4e, 0x73, 0x1c, 0x68, 0xba, 0x2d )

// AVEncStatAudioAverageBPS (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatAudioAverageBPS, "ca6724db-7059-4351-8b43-f82198826a14", 0xca6724db, 0x7059, 0x4351, 0x8b, 0x43, 0xf8, 0x21, 0x98, 0x82, 0x6a, 0x14 )

//
// MPEG Video Encoding Interface
//

//
// MPV Encoder Specific Parameters
//

// AVEncMPVGOPSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVGOPSize,          "95f31b26-95a4-41aa-9303-246a7fc6eef1", 0x95f31b26, 0x95a4, 0x41aa, 0x93, 0x03, 0x24, 0x6a, 0x7f, 0xc6, 0xee, 0xf1 )

// AVEncMPVGOPOpen (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGOPOpen,          "b1d5d4a6-3300-49b1-ae61-a09937ab0e49", 0xb1d5d4a6, 0x3300, 0x49b1, 0xae, 0x61, 0xa0, 0x99, 0x37, 0xab, 0x0e, 0x49 )

// AVEncMPVDefaultBPictureCount (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVDefaultBPictureCount, "8d390aac-dc5c-4200-b57f-814d04babab2", 0x8d390aac, 0xdc5c, 0x4200, 0xb5, 0x7f, 0x81, 0x4d, 0x04, 0xba, 0xba, 0xb2 )

// AVEncMPVProfile (UINT32) <---- You have GUID in the doc
DEFINE_CODECAPI_GUID( AVEncMPVProfile,          "dabb534a-1d99-4284-975a-d90e2239baa1", 0xdabb534a, 0x1d99, 0x4284, 0x97, 0x5a, 0xd9, 0x0e, 0x22, 0x39, 0xba, 0xa1 )

enum eAVEncMPVProfile
{
    eAVEncMPVProfile_unknown = 0,
    eAVEncMPVProfile_Simple = 1,
    eAVEncMPVProfile_Main   = 2,
    eAVEncMPVProfile_High   = 3,
    eAVEncMPVProfile_422    = 4
};

// AVEncMPVLevel (UINT32) <---- You have GUID in the doc
DEFINE_CODECAPI_GUID( AVEncMPVLevel,            "6ee40c40-a60c-41ef-8f50-37c2249e2cb3", 0x6ee40c40, 0xa60c, 0x41ef, 0x8f, 0x50, 0x37, 0xc2, 0x24, 0x9e, 0x2c, 0xb3 )

enum eAVEncMPVLevel
{
    eAVEncMPVLevel_Low      = 1,
    eAVEncMPVLevel_Main     = 2,
    eAVEncMPVLevel_High1440 = 3,
    eAVEncMPVLevel_High     = 4
};

// AVEncMPVFrameFieldMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVFrameFieldMode,   "acb5de96-7b93-4c2f-8825-b0295fa93bf4", 0xacb5de96, 0x7b93, 0x4c2f, 0x88, 0x25, 0xb0, 0x29, 0x5f, 0xa9, 0x3b, 0xf4 )

enum eAVEncMPVFrameFieldMode
{
    eAVEncMPVFrameFieldMode_FieldMode = 0,
    eAVEncMPVFrameFieldMode_FrameMode = 1
};

//
// Advanced MPV Encoder Specific Parameters
//

// AVEncMPVAddSeqEndCode (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVAddSeqEndCode,    "a823178f-57df-4c7a-b8fd-e5ec8887708d", 0xa823178f, 0x57df, 0x4c7a, 0xb8, 0xfd, 0xe5, 0xec, 0x88, 0x87, 0x70, 0x8d )

// AVEncMPVGOPSInSeq (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVGOPSInSeq,        "993410d4-2691-4192-9978-98dc2603669f", 0x993410d4, 0x2691, 0x4192, 0x99, 0x78, 0x98, 0xdc, 0x26, 0x03, 0x66, 0x9f )

// AVEncMPVUseConcealmentMotionVectors (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVUseConcealmentMotionVectors,  "ec770cf3-6908-4b4b-aa30-7fb986214fea", 0xec770cf3, 0x6908, 0x4b4b, 0xaa, 0x30, 0x7f, 0xb9, 0x86, 0x21, 0x4f, 0xea )

// AVEncMPVSceneDetection (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVSceneDetection,   "552799f1-db4c-405b-8a3a-c93f2d0674dc", 0x552799f1, 0xdb4c, 0x405b, 0x8a, 0x3a, 0xc9, 0x3f, 0x2d, 0x06, 0x74, 0xdc )

enum eAVEncMPVSceneDetection
{
    eAVEncMPVSceneDetection_None                 = 0,
    eAVEncMPVSceneDetection_InsertIPicture       = 1,
    eAVEncMPVSceneDetection_StartNewGOP          = 2,
    eAVEncMPVSceneDetection_StartNewLocatableGOP = 3
};

// AVEncMPVGenerateHeaderSeqExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderSeqExt, "d5e78611-082d-4e6b-98af-0f51ab139222", 0xd5e78611, 0x082d, 0x4e6b, 0x98, 0xaf, 0x0f, 0x51, 0xab, 0x13, 0x92, 0x22 )

// AVEncMPVGenerateHeaderSeqDispExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderSeqDispExt, "6437aa6f-5a3c-4de9-8a16-53d9c4ad326f", 0x6437aa6f, 0x5a3c, 0x4de9, 0x8a, 0x16, 0x53, 0xd9, 0xc4, 0xad, 0x32, 0x6f )

// AVEncMPVGenerateHeaderPicExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderPicExt, "1b8464ab-944f-45f0-b74e-3a58dad11f37", 0x1b8464ab, 0x944f, 0x45f0, 0xb7, 0x4e, 0x3a, 0x58, 0xda, 0xd1, 0x1f, 0x37 )

// AVEncMPVGenerateHeaderPicDispExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderPicDispExt, "c6412f84-c03f-4f40-a00c-4293df8395bb", 0xc6412f84, 0xc03f, 0x4f40, 0xa0, 0x0c, 0x42, 0x93, 0xdf, 0x83, 0x95, 0xbb )

// AVEncMPVGenerateHeaderSeqScaleExt (BOOL)
DEFINE_CODECAPI_GUID( AVEncMPVGenerateHeaderSeqScaleExt, "0722d62f-dd59-4a86-9cd5-644f8e2653d8", 0x0722d62f, 0xdd59, 0x4a86, 0x9c, 0xd5, 0x64, 0x4f, 0x8e, 0x26, 0x53, 0xd8 )

// AVEncMPVScanPattern (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVScanPattern,      "7f8a478e-7bbb-4ae2-b2fc-96d17fc4a2d6", 0x7f8a478e, 0x7bbb, 0x4ae2, 0xb2, 0xfc, 0x96, 0xd1, 0x7f, 0xc4, 0xa2, 0xd6 )

enum eAVEncMPVScanPattern
{
    eAVEncMPVScanPattern_Auto          = 0,
    eAVEncMPVScanPattern_ZigZagScan    = 1,
    eAVEncMPVScanPattern_AlternateScan = 2
};

// AVEncMPVIntraDCPrecision (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVIntraDCPrecision, "a0116151-cbc8-4af3-97dc-d00cceb82d79", 0xa0116151, 0xcbc8, 0x4af3, 0x97, 0xdc, 0xd0, 0x0c, 0xce, 0xb8, 0x2d, 0x79 )

// AVEncMPVQScaleType (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVQScaleType,       "2b79ebb7-f484-4af7-bb58-a2a188c5cbbe", 0x2b79ebb7, 0xf484, 0x4af7, 0xbb, 0x58, 0xa2, 0xa1, 0x88, 0xc5, 0xcb, 0xbe )

enum eAVEncMPVQScaleType
{
    eAVEncMPVQScaleType_Auto      = 0,
    eAVEncMPVQScaleType_Linear    = 1,
    eAVEncMPVQScaleType_NonLinear = 2
};

// AVEncMPVIntraVLCTable (UINT32)
DEFINE_CODECAPI_GUID( AVEncMPVIntraVLCTable,    "a2b83ff5-1a99-405a-af95-c5997d558d3a", 0xa2b83ff5, 0x1a99, 0x405a, 0xaf, 0x95, 0xc5, 0x99, 0x7d, 0x55, 0x8d, 0x3a )

enum eAVEncMPVIntraVLCTable
{
    eAVEncMPVIntraVLCTable_Auto      = 0,
    eAVEncMPVIntraVLCTable_MPEG1     = 1,
    eAVEncMPVIntraVLCTable_Alternate = 2
};

// AVEncMPVQuantMatrixIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixIntra, "9bea04f3-6621-442c-8ba1-3ac378979698", 0x9bea04f3, 0x6621, 0x442c, 0x8b, 0xa1, 0x3a, 0xc3, 0x78, 0x97, 0x96, 0x98 )

// AVEncMPVQuantMatrixNonIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixNonIntra, "87f441d8-0997-4beb-a08e-8573d409cf75", 0x87f441d8, 0x0997, 0x4beb, 0xa0, 0x8e, 0x85, 0x73, 0xd4, 0x09, 0xcf, 0x75 )

// AVEncMPVQuantMatrixChromaIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixChromaIntra, "9eb9ecd4-018d-4ffd-8f2d-39e49f07b17a", 0x9eb9ecd4, 0x018d, 0x4ffd, 0x8f, 0x2d, 0x39, 0xe4, 0x9f, 0x07, 0xb1, 0x7a )

// AVEncMPVQuantMatrixChromaNonIntra (BYTE[64] encoded as a string of 128 hex digits)
DEFINE_CODECAPI_GUID( AVEncMPVQuantMatrixChromaNonIntra, "1415b6b1-362a-4338-ba9a-1ef58703c05b", 0x1415b6b1, 0x362a, 0x4338, 0xba, 0x9a, 0x1e, 0xf5, 0x87, 0x03, 0xc0, 0x5b )

//
// MPEG1 Audio Encoding Interface
//

//
// MPEG1 Audio Specific Parameters
//

// AVEncMPALayer (UINT)
DEFINE_CODECAPI_GUID( AVEncMPALayer,    "9d377230-f91b-453d-9ce0-78445414c22d", 0x9d377230, 0xf91b, 0x453d, 0x9c, 0xe0, 0x78, 0x44, 0x54, 0x14, 0xc2, 0x2d )

enum eAVEncMPALayer
{
    eAVEncMPALayer_1 = 1,
    eAVEncMPALayer_2 = 2,
    eAVEncMPALayer_3 = 3
};

// AVEncMPACodingMode (UINT)
DEFINE_CODECAPI_GUID( AVEncMPACodingMode,       "b16ade03-4b93-43d7-a550-90b4fe224537", 0xb16ade03, 0x4b93, 0x43d7, 0xa5, 0x50, 0x90, 0xb4, 0xfe, 0x22, 0x45, 0x37 )

enum eAVEncMPACodingMode
{
    eAVEncMPACodingMode_Mono        = 0,
    eAVEncMPACodingMode_Stereo      = 1,
    eAVEncMPACodingMode_DualChannel = 2,
    eAVEncMPACodingMode_JointStereo = 3,
    eAVEncMPACodingMode_Surround    = 4
};

// AVEncMPACopyright (BOOL) - default state to encode into the stream (may be overridden by input)
// 1 (true)  - copyright protected
// 0 (false) - not copyright protected 
DEFINE_CODECAPI_GUID( AVEncMPACopyright,         "a6ae762a-d0a9-4454-b8ef-f2dbeefdd3bd", 0xa6ae762a, 0xd0a9, 0x4454, 0xb8, 0xef, 0xf2, 0xdb, 0xee, 0xfd, 0xd3, 0xbd )

// AVEncMPAOriginalBitstream (BOOL) - default value to encode into the stream (may be overridden by input)
// 1 (true)  - for original bitstream
// 0 (false) - for copy bitstream 
DEFINE_CODECAPI_GUID( AVEncMPAOriginalBitstream, "3cfb7855-9cc9-47ff-b829-b36786c92346", 0x3cfb7855, 0x9cc9, 0x47ff, 0xb8, 0x29, 0xb3, 0x67, 0x86, 0xc9, 0x23, 0x46 )

// AVEncMPAEnableRedundancyProtection (BOOL) 
// 1 (true)  -  Redundancy should be added to facilitate error detection and concealment (CRC)
// 0 (false) -  No redundancy should be added
DEFINE_CODECAPI_GUID( AVEncMPAEnableRedundancyProtection,     "5e54b09e-b2e7-4973-a89b-0b3650a3beda", 0x5e54b09e, 0xb2e7, 0x4973, 0xa8, 0x9b, 0x0b, 0x36, 0x50, 0xa3, 0xbe, 0xda )

// AVEncMPAPrivateUserBit (UINT) - User data bit value to encode in the stream
DEFINE_CODECAPI_GUID( AVEncMPAPrivateUserBit,      "afa505ce-c1e3-4e3d-851b-61b700e5e6cc", 0xafa505ce, 0xc1e3, 0x4e3d, 0x85, 0x1b, 0x61, 0xb7, 0x00, 0xe5, 0xe6, 0xcc )

// AVEncMPAEmphasisType (UINT)
// Indicates type of de-emphasis filter to be used
DEFINE_CODECAPI_GUID( AVEncMPAEmphasisType,         "2d59fcda-bf4e-4ed6-b5df-5b03b36b0a1f", 0x2d59fcda, 0xbf4e, 0x4ed6, 0xb5, 0xdf, 0x5b, 0x03, 0xb3, 0x6b, 0x0a, 0x1f )

enum eAVEncMPAEmphasisType
{
    eAVEncMPAEmphasisType_None        = 0,
    eAVEncMPAEmphasisType_50_15       = 1,
    eAVEncMPAEmphasisType_Reserved    = 2,
    eAVEncMPAEmphasisType_CCITT_J17   = 3,
};

//
// Dolby Digital(TM) Audio Encoding Interface
//

//
// Dolby Digital(TM) Audio Specific Parameters
//

// AVEncDDService (UINT)
DEFINE_CODECAPI_GUID( AVEncDDService,           "d2e1bec7-5172-4d2a-a50e-2f3b82b1ddf8", 0xd2e1bec7, 0x5172, 0x4d2a, 0xa5, 0x0e, 0x2f, 0x3b, 0x82, 0xb1, 0xdd, 0xf8 )

enum eAVEncDDService
{
    eAVEncDDService_CM = 0,  // (Main Service: Complete Main)
    eAVEncDDService_ME = 1,  // (Main Service: Music and Effects (ME))
    eAVEncDDService_VI = 2,  // (Associated Service: Visually-Impaired (VI)
    eAVEncDDService_HI = 3,  // (Associated Service: Hearing-Impaired (HI))
    eAVEncDDService_D  = 4,  // (Associated Service: Dialog (D))
    eAVEncDDService_C  = 5,  // (Associated Service: Commentary (C))
    eAVEncDDService_E  = 6,  // (Associated Service: Emergency (E))
    eAVEncDDService_VO = 7   // (Associated Service: Voice Over (VO) / Karaoke)
};

// AVEncDDDialogNormalization (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDDialogNormalization, "d7055acf-f125-437d-a704-79c79f0404a8", 0xd7055acf, 0xf125, 0x437d, 0xa7, 0x04, 0x79, 0xc7, 0x9f, 0x04, 0x04, 0xa8 )

// AVEncDDCentreDownMixLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDCentreDownMixLevel, "e285072c-c958-4a81-afd2-e5e0daf1b148", 0xe285072c, 0xc958, 0x4a81, 0xaf, 0xd2, 0xe5, 0xe0, 0xda, 0xf1, 0xb1, 0x48 )

// AVEncDDSurroundDownMixLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDSurroundDownMixLevel, "7b20d6e5-0bcf-4273-a487-506b047997e9", 0x7b20d6e5, 0x0bcf, 0x4273, 0xa4, 0x87, 0x50, 0x6b, 0x04, 0x79, 0x97, 0xe9 )

// AVEncDDProductionInfoExists (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDProductionInfoExists, "b0b7fe5f-b6ab-4f40-964d-8d91f17c19e8", 0xb0b7fe5f, 0xb6ab, 0x4f40, 0x96, 0x4d, 0x8d, 0x91, 0xf1, 0x7c, 0x19, 0xe8 )

// AVEncDDProductionRoomType (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDProductionRoomType, "dad7ad60-23d8-4ab7-a284-556986d8a6fe", 0xdad7ad60, 0x23d8, 0x4ab7, 0xa2, 0x84, 0x55, 0x69, 0x86, 0xd8, 0xa6, 0xfe )

enum eAVEncDDProductionRoomType
{
    eAVEncDDProductionRoomType_NotIndicated = 0,
    eAVEncDDProductionRoomType_Large        = 1,
    eAVEncDDProductionRoomType_Small        = 2
};

// AVEncDDProductionMixLevel (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDProductionMixLevel, "301d103a-cbf9-4776-8899-7c15b461ab26", 0x301d103a, 0xcbf9, 0x4776, 0x88, 0x99, 0x7c, 0x15, 0xb4, 0x61, 0xab, 0x26 )

// AVEncDDCopyright (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDCopyright,         "8694f076-cd75-481d-a5c6-a904dcc828f0", 0x8694f076, 0xcd75, 0x481d, 0xa5, 0xc6, 0xa9, 0x04, 0xdc, 0xc8, 0x28, 0xf0 )

// AVEncDDOriginalBitstream (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDOriginalBitstream, "966ae800-5bd3-4ff9-95b9-d30566273856", 0x966ae800, 0x5bd3, 0x4ff9, 0x95, 0xb9, 0xd3, 0x05, 0x66, 0x27, 0x38, 0x56 )

// AVEncDDDigitalDeemphasis (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDDigitalDeemphasis, "e024a2c2-947c-45ac-87d8-f1030c5c0082", 0xe024a2c2, 0x947c, 0x45ac, 0x87, 0xd8, 0xf1, 0x03, 0x0c, 0x5c, 0x00, 0x82 )

// AVEncDDDCHighPassFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDDCHighPassFilter,  "9565239f-861c-4ac8-bfda-e00cb4db8548", 0x9565239f, 0x861c, 0x4ac8, 0xbf, 0xda, 0xe0, 0x0c, 0xb4, 0xdb, 0x85, 0x48 )

// AVEncDDChannelBWLowPassFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDChannelBWLowPassFilter, "e197821d-d2e7-43e2-ad2c-00582f518545", 0xe197821d, 0xd2e7, 0x43e2, 0xad, 0x2c, 0x00, 0x58, 0x2f, 0x51, 0x85, 0x45 )

// AVEncDDLFELowPassFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDLFELowPassFilter,  "d3b80f6f-9d15-45e5-91be-019c3fab1f01", 0xd3b80f6f, 0x9d15, 0x45e5, 0x91, 0xbe, 0x01, 0x9c, 0x3f, 0xab, 0x1f, 0x01 )

// AVEncDDSurround90DegreeePhaseShift (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDSurround90DegreeePhaseShift, "25ecec9d-3553-42c0-bb56-d25792104f80", 0x25ecec9d, 0x3553, 0x42c0, 0xbb, 0x56, 0xd2, 0x57, 0x92, 0x10, 0x4f, 0x80 )

// AVEncDDSurround3dBAttenuation (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDSurround3dBAttenuation, "4d43b99d-31e2-48b9-bf2e-5cbf1a572784", 0x4d43b99d, 0x31e2, 0x48b9, 0xbf, 0x2e, 0x5c, 0xbf, 0x1a, 0x57, 0x27, 0x84 )

// AVEncDDDynamicRangeCompressionControl (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDDynamicRangeCompressionControl, "cfc2ff6d-79b8-4b8d-a8aa-a0c9bd1c2940", 0xcfc2ff6d, 0x79b8, 0x4b8d, 0xa8, 0xaa, 0xa0, 0xc9, 0xbd, 0x1c, 0x29, 0x40 )

enum eAVEncDDDynamicRangeCompressionControl
{
    eAVEncDDDynamicRangeCompressionControl_None          = 0,
    eAVEncDDDynamicRangeCompressionControl_FilmStandard  = 1,
    eAVEncDDDynamicRangeCompressionControl_FilmLight     = 2,
    eAVEncDDDynamicRangeCompressionControl_MusicStandard = 3,
    eAVEncDDDynamicRangeCompressionControl_MusicLight    = 4,
    eAVEncDDDynamicRangeCompressionControl_Speech        = 5
};

// AVEncDDRFPreEmphasisFilter (BOOL)
DEFINE_CODECAPI_GUID( AVEncDDRFPreEmphasisFilter, "21af44c0-244e-4f3d-a2cc-3d3068b2e73f", 0x21af44c0, 0x244e, 0x4f3d, 0xa2, 0xcc, 0x3d, 0x30, 0x68, 0xb2, 0xe7, 0x3f )

// AVEncDDSurroundExMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDSurroundExMode,    "91607cee-dbdd-4eb6-bca2-aadfafa3dd68", 0x91607cee, 0xdbdd, 0x4eb6, 0xbc, 0xa2, 0xaa, 0xdf, 0xaf, 0xa3, 0xdd, 0x68 )

enum eAVEncDDSurroundExMode
{
    eAVEncDDSurroundExMode_NotIndicated = 0,
    eAVEncDDSurroundExMode_No           = 1,
    eAVEncDDSurroundExMode_Yes          = 2
};

// AVEncDDPreferredStereoDownMixMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDPreferredStereoDownMixMode,    "7f4e6b31-9185-403d-b0a2-763743e6f063", 0x7f4e6b31, 0x9185, 0x403d, 0xb0, 0xa2, 0x76, 0x37, 0x43, 0xe6, 0xf0, 0x63 )

enum eAVEncDDPreferredStereoDownMixMode
{
    eAVEncDDPreferredStereoDownMixMode_LtRt = 0,
    eAVEncDDPreferredStereoDownMixMode_LoRo = 1
};

// AVEncDDLtRtCenterMixLvl_x10 (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLtRtCenterMixLvl_x10, "dca128a2-491f-4600-b2da-76e3344b4197", 0xdca128a2, 0x491f, 0x4600, 0xb2, 0xda, 0x76, 0xe3, 0x34, 0x4b, 0x41, 0x97 )

// AVEncDDLtRtSurroundMixLvl_x10 (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLtRtSurroundMixLvl_x10, "212246c7-3d2c-4dfa-bc21-652a9098690d", 0x212246c7, 0x3d2c, 0x4dfa, 0xbc, 0x21, 0x65, 0x2a, 0x90, 0x98, 0x69, 0x0d )

// AVEncDDLoRoCenterMixLvl (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLoRoCenterMixLvl_x10, "1cfba222-25b3-4bf4-9bfd-e7111267858c", 0x1cfba222, 0x25b3, 0x4bf4, 0x9b, 0xfd, 0xe7, 0x11, 0x12, 0x67, 0x85, 0x8c )

// AVEncDDLoRoSurroundMixLvl_x10 (INT32)
DEFINE_CODECAPI_GUID( AVEncDDLoRoSurroundMixLvl_x10, "e725cff6-eb56-40c7-8450-2b9367e91555", 0xe725cff6, 0xeb56, 0x40c7, 0x84, 0x50, 0x2b, 0x93, 0x67, 0xe9, 0x15, 0x55 )

// AVEncDDAtoDConverterType (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDAtoDConverterType, "719f9612-81a1-47e0-9a05-d94ad5fca948", 0x719f9612, 0x81a1, 0x47e0, 0x9a, 0x05, 0xd9, 0x4a, 0xd5, 0xfc, 0xa9, 0x48 )

enum eAVEncDDAtoDConverterType
{
    eAVEncDDAtoDConverterType_Standard = 0,
    eAVEncDDAtoDConverterType_HDCD     = 1
};

// AVEncDDHeadphoneMode (UINT32)
DEFINE_CODECAPI_GUID( AVEncDDHeadphoneMode, "4052dbec-52f5-42f5-9b00-d134b1341b9d", 0x4052dbec, 0x52f5, 0x42f5, 0x9b, 0x00, 0xd1, 0x34, 0xb1, 0x34, 0x1b, 0x9d )

enum eAVEncDDHeadphoneMode
{
    eAVEncDDHeadphoneMode_NotIndicated = 0,
    eAVEncDDHeadphoneMode_NotEncoded   = 1,
    eAVEncDDHeadphoneMode_Encoded      = 2
};

//
// WMV Video Encoding Interface
//

//
// WMV Video Specific Parameters
//

// AVEncWMVKeyFrameDistance (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVKeyFrameDistance, "5569055e-e268-4771-b83e-9555ea28aed3", 0x5569055e, 0xe268, 0x4771, 0xb8, 0x3e, 0x95, 0x55, 0xea, 0x28, 0xae, 0xd3 )

// AVEncWMVInterlacedEncoding (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVInterlacedEncoding, "e3d00f8a-c6f5-4e14-a588-0ec87a726f9b", 0xe3d00f8a, 0xc6f5, 0x4e14, 0xa5, 0x88, 0x0e, 0xc8, 0x7a, 0x72, 0x6f, 0x9b )

// AVEncWMVDecoderComplexity (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVDecoderComplexity, "f32c0dab-f3cb-4217-b79f-8762768b5f67", 0xf32c0dab, 0xf3cb, 0x4217, 0xb7, 0x9f, 0x87, 0x62, 0x76, 0x8b, 0x5f, 0x67 )

// AVEncWMVHasKeyFrameBufferLevelMarker (BOOL)
DEFINE_CODECAPI_GUID( AVEncWMVKeyFrameBufferLevelMarker, "51ff1115-33ac-426c-a1b1-09321bdf96b4", 0x51ff1115, 0x33ac, 0x426c, 0xa1, 0xb1, 0x09, 0x32, 0x1b, 0xdf, 0x96, 0xb4 )

// AVEncWMVProduceDummyFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncWMVProduceDummyFrames, "d669d001-183c-42e3-a3ca-2f4586d2396c", 0xd669d001, 0x183c, 0x42e3, 0xa3, 0xca, 0x2f, 0x45, 0x86, 0xd2, 0x39, 0x6c )

//
// WMV Post-Encode Statistical Parameters
//

// AVEncStatWMVCBAvg (UINT32/UINT32)
DEFINE_CODECAPI_GUID( AVEncStatWMVCBAvg,        "6aa6229f-d602-4b9d-b68c-c1ad78884bef", 0x6aa6229f, 0xd602, 0x4b9d, 0xb6, 0x8c, 0xc1, 0xad, 0x78, 0x88, 0x4b, 0xef )

// AVEncStatWMVCBMax (UINT32/UINT32)
DEFINE_CODECAPI_GUID( AVEncStatWMVCBMax,        "e976bef8-00fe-44b4-b625-8f238bc03499", 0xe976bef8, 0x00fe, 0x44b4, 0xb6, 0x25, 0x8f, 0x23, 0x8b, 0xc0, 0x34, 0x99 )

// AVEncStatWMVDecoderComplexityProfile (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatWMVDecoderComplexityProfile, "89e69fc3-0f9b-436c-974a-df821227c90d", 0x89e69fc3, 0x0f9b, 0x436c, 0x97, 0x4a, 0xdf, 0x82, 0x12, 0x27, 0xc9, 0x0d )

// AVEncStatMPVSkippedEmptyFrames (UINT32)
DEFINE_CODECAPI_GUID( AVEncStatMPVSkippedEmptyFrames, "32195fd3-590d-4812-a7ed-6d639a1f9711", 0x32195fd3, 0x590d, 0x4812, 0xa7, 0xed, 0x6d, 0x63, 0x9a, 0x1f, 0x97, 0x11 )

//
// MPEG1/2 Multiplexer Interfaces
//

//
// MPEG1/2 Packetizer Interface
//

// Shared with Mux:
// AVEncMP12MuxEarliestPTS (UINT32)
// AVEncMP12MuxLargestPacketSize (UINT32)
// AVEncMP12MuxSysSTDBufferBound (UINT32)

// AVEncMP12PktzSTDBuffer (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzSTDBuffer,   "0b751bd0-819e-478c-9435-75208926b377", 0x0b751bd0, 0x819e, 0x478c, 0x94, 0x35, 0x75, 0x20, 0x89, 0x26, 0xb3, 0x77 )

// AVEncMP12PktzStreamID (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzStreamID,    "c834d038-f5e8-4408-9b60-88f36493fedf", 0xc834d038, 0xf5e8, 0x4408, 0x9b, 0x60, 0x88, 0xf3, 0x64, 0x93, 0xfe, 0xdf )

// AVEncMP12PktzInitialPTS (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzInitialPTS,  "2a4f2065-9a63-4d20-ae22-0a1bc896a315", 0x2a4f2065, 0x9a63, 0x4d20, 0xae, 0x22, 0x0a, 0x1b, 0xc8, 0x96, 0xa3, 0x15 )

// AVEncMP12PktzPacketSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12PktzPacketSize,  "ab71347a-1332-4dde-a0e5-ccf7da8a0f22", 0xab71347a, 0x1332, 0x4dde, 0xa0, 0xe5, 0xcc, 0xf7, 0xda, 0x8a, 0x0f, 0x22 )

// AVEncMP12PktzCopyright (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12PktzCopyright,   "c8f4b0c1-094c-43c7-8e68-a595405a6ef8", 0xc8f4b0c1, 0x094c, 0x43c7, 0x8e, 0x68, 0xa5, 0x95, 0x40, 0x5a, 0x6e, 0xf8 )

// AVEncMP12PktzOriginal (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12PktzOriginal,    "6b178416-31b9-4964-94cb-6bff866cdf83", 0x6b178416, 0x31b9, 0x4964, 0x94, 0xcb, 0x6b, 0xff, 0x86, 0x6c, 0xdf, 0x83 )

//
// MPEG1/2 Multiplexer Interface
//

// AVEncMP12MuxPacketOverhead (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxPacketOverhead, "e40bd720-3955-4453-acf9-b79132a38fa0", 0xe40bd720, 0x3955, 0x4453, 0xac, 0xf9, 0xb7, 0x91, 0x32, 0xa3, 0x8f, 0xa0 )

// AVEncMP12MuxNumStreams (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxNumStreams,   "f7164a41-dced-4659-a8f2-fb693f2a4cd0", 0xf7164a41, 0xdced, 0x4659, 0xa8, 0xf2, 0xfb, 0x69, 0x3f, 0x2a, 0x4c, 0xd0 )

// AVEncMP12MuxEarliestPTS (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxEarliestPTS,  "157232b6-f809-474e-9464-a7f93014a817", 0x157232b6, 0xf809, 0x474e, 0x94, 0x64, 0xa7, 0xf9, 0x30, 0x14, 0xa8, 0x17 )

// AVEncMP12MuxLargestPacketSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxLargestPacketSize, "35ceb711-f461-4b92-a4ef-17b6841ed254", 0x35ceb711, 0xf461, 0x4b92, 0xa4, 0xef, 0x17, 0xb6, 0x84, 0x1e, 0xd2, 0x54 )

// AVEncMP12MuxInitialSCR (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxInitialSCR,   "3433ad21-1b91-4a0b-b190-2b77063b63a4", 0x3433ad21, 0x1b91, 0x4a0b, 0xb1, 0x90, 0x2b, 0x77, 0x06, 0x3b, 0x63, 0xa4 )

// AVEncMP12MuxMuxRate (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxMuxRate,      "ee047c72-4bdb-4a9d-8e21-41926c823da7", 0xee047c72, 0x4bdb, 0x4a9d, 0x8e, 0x21, 0x41, 0x92, 0x6c, 0x82, 0x3d, 0xa7 )

// AVEncMP12MuxPackSize (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxPackSize,     "f916053a-1ce8-4faf-aa0b-ba31c80034b8", 0xf916053a, 0x1ce8, 0x4faf, 0xaa, 0x0b, 0xba, 0x31, 0xc8, 0x00, 0x34, 0xb8 )

// AVEncMP12MuxSysSTDBufferBound (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysSTDBufferBound, "35746903-b545-43e7-bb35-c5e0a7d5093c", 0x35746903, 0xb545, 0x43e7, 0xbb, 0x35, 0xc5, 0xe0, 0xa7, 0xd5, 0x09, 0x3c )

// AVEncMP12MuxSysRateBound (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysRateBound, "05f0428a-ee30-489d-ae28-205c72446710", 0x05f0428a, 0xee30, 0x489d, 0xae, 0x28, 0x20, 0x5c, 0x72, 0x44, 0x67, 0x10 )

// AVEncMP12MuxTargetPacketizer (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxTargetPacketizer, "d862212a-2015-45dd-9a32-1b3aa88205a0", 0xd862212a, 0x2015, 0x45dd, 0x9a, 0x32, 0x1b, 0x3a, 0xa8, 0x82, 0x05, 0xa0 )

// AVEncMP12MuxSysFixed (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysFixed,     "cefb987e-894f-452e-8f89-a4ef8cec063a", 0xcefb987e, 0x894f, 0x452e, 0x8f, 0x89, 0xa4, 0xef, 0x8c, 0xec, 0x06, 0x3a )

// AVEncMP12MuxSysCSPS (UINT32)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysCSPS,      "7952ff45-9c0d-4822-bc82-8ad772e02993", 0x7952ff45, 0x9c0d, 0x4822, 0xbc, 0x82, 0x8a, 0xd7, 0x72, 0xe0, 0x29, 0x93 )

// AVEncMP12MuxSysVideoLock (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysVideoLock, "b8296408-2430-4d37-a2a1-95b3e435a91d", 0xb8296408, 0x2430, 0x4d37, 0xa2, 0xa1, 0x95, 0xb3, 0xe4, 0x35, 0xa9, 0x1d )

// AVEncMP12MuxSysAudioLock (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12MuxSysAudioLock, "0fbb5752-1d43-47bf-bd79-f2293d8ce337", 0x0fbb5752, 0x1d43, 0x47bf, 0xbd, 0x79, 0xf2, 0x29, 0x3d, 0x8c, 0xe3, 0x37 )

// AVEncMP12MuxDVDNavPacks (BOOL)
DEFINE_CODECAPI_GUID( AVEncMP12MuxDVDNavPacks,  "c7607ced-8cf1-4a99-83a1-ee5461be3574", 0xc7607ced, 0x8cf1, 0x4a99, 0x83, 0xa1, 0xee, 0x54, 0x61, 0xbe, 0x35, 0x74 )

//
// Decoding Interface
//


// format values are GUIDs as VARIANT BSTRs 
DEFINE_CODECAPI_GUID( AVDecCommonInputFormat,       "E5005239-BD89-4be3-9C0F-5DDE317988CC", 0xe5005239, 0xbd89, 0x4be3, 0x9c, 0x0f, 0x5d, 0xde, 0x31, 0x79, 0x88, 0xcc)
DEFINE_CODECAPI_GUID( AVDecCommonOutputFormat, "3c790028-c0ce-4256-b1a2-1b0fc8b1dcdc", 0x3c790028, 0xc0ce, 0x4256, 0xb1, 0xa2, 0x1b, 0x0f, 0xc8, 0xb1, 0xdc, 0xdc)

// AVDecCommonMeanBitRate - Mean bitrate in mbits/sec (UINT32)
DEFINE_CODECAPI_GUID( AVDecCommonMeanBitRate,       "59488217-007A-4f7a-8E41-5C48B1EAC5C6", 0x59488217, 0x007a, 0x4f7a, 0x8e, 0x41, 0x5c, 0x48, 0xb1, 0xea, 0xc5, 0xc6)
// AVDecCommonMeanBitRateInterval - Mean bitrate interval (in 100ns) (UINT64)
DEFINE_CODECAPI_GUID( AVDecCommonMeanBitRateInterval,     "0EE437C6-38A7-4c5c-944C-68AB42116B85", 0x0ee437c6, 0x38a7, 0x4c5c, 0x94, 0x4c, 0x68, 0xab, 0x42, 0x11, 0x6b, 0x85)

//
// Audio Decoding Interface
//

// Value GUIDS
// The following 6 GUIDs are values of the AVDecCommonOutputFormat property
//
// Stereo PCM output using matrix-encoded stereo down mix (aka Lt/Rt) 
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded,  "696E1D30-548F-4036-825F-7026C60011BD", 0x696e1d30, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// Regular PCM output (any number of channels) 
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM,                       "696E1D31-548F-4036-825F-7026C60011BD", 0x696e1d31, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// SPDIF PCM (IEC 60958) stereo output. Type of stereo down mix should
// be specified by the application.
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_SPDIF_PCM,                 "696E1D32-548F-4036-825F-7026C60011BD", 0x696e1d32, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// SPDIF bitstream (IEC 61937) output, such as AC3, MPEG or DTS.
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_SPDIF_Bitstream,           "696E1D33-548F-4036-825F-7026C60011BD", 0x696e1d33, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)
//
// Stereo PCM output using regular stereo down mix (aka Lo/Ro)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM_Headphones,            "696E1D34-548F-4036-825F-7026C60011BD", 0x696e1d34, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)

// Stereo PCM output using automatic selection of stereo down mix 
// mode (Lo/Ro or Lt/Rt). Use this when the input stream includes
// information about the preferred downmix mode (such as Annex D of AC3).
// Default down mix mode should be specified by the application.
DEFINE_CODECAPI_GUID( GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto,           "696E1D35-548F-4036-825F-7026C60011BD", 0x696e1d34, 0x548f, 0x4036, 0x82, 0x5f, 0x70, 0x26, 0xc6, 0x00, 0x11, 0xbd)

//
// Video Decoder properties
//

// AVDecVideoImageSize (UINT32) - High UINT16 width, low UINT16 height
DEFINE_CODECAPI_GUID( AVDecVideoImageSize,          "5EE5747C-6801-4cab-AAF1-6248FA841BA4", 0x5ee5747c, 0x6801, 0x4cab, 0xaa, 0xf1, 0x62, 0x48, 0xfa, 0x84, 0x1b, 0xa4)

// AVDecVideoPixelAspectRatio (UINT32 as UINT16/UNIT16) - High UINT16 width, low UINT16 height
DEFINE_CODECAPI_GUID( AVDecVideoPixelAspectRatio,   "B0CF8245-F32D-41df-B02C-87BD304D12AB", 0xb0cf8245, 0xf32d, 0x41df, 0xb0, 0x2c, 0x87, 0xbd, 0x30, 0x4d, 0x12, 0xab)

// AVDecVideoInputScanType (UINT32)
DEFINE_CODECAPI_GUID( AVDecVideoInputScanType,      "38477E1F-0EA7-42cd-8CD1-130CED57C580", 0x38477e1f, 0x0ea7, 0x42cd, 0x8c, 0xd1, 0x13, 0x0c, 0xed, 0x57, 0xc5, 0x80)
enum eAVDecVideoInputScanType
{
    eAVDecVideoInputScan_Unknown           = 0,
    eAVDecVideoInputScan_Progressive       = 1, 
    eAVDecVideoInputScan_Interlaced_UpperFieldFirst = 2,
    eAVDecVideoInputScan_Interlaced_LowerFieldFirst = 3
};

//
// Audio Decoder properties
//


DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputWMA,          "C95E8DCF-4058-4204-8C42-CB24D91E4B9B", 0xc95e8dcf, 0x4058, 0x4204, 0x8c, 0x42, 0xcb, 0x24, 0xd9, 0x1e, 0x4b, 0x9b)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputWMAPro,       "0128B7C7-DA72-4fe3-BEF8-5C52E3557704", 0x0128b7c7, 0xda72, 0x4fe3, 0xbe, 0xf8, 0x5c, 0x52, 0xe3, 0x55, 0x77, 0x04)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputDolby,        "8E4228A0-F000-4e0b-8F54-AB8D24AD61A2", 0x8e4228a0, 0xf000, 0x4e0b, 0x8f, 0x54, 0xab, 0x8d, 0x24, 0xad, 0x61, 0xa2)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputDTS,          "600BC0CA-6A1F-4e91-B241-1BBEB1CB19E0", 0x600bc0ca, 0x6a1f, 0x4e91, 0xb2, 0x41, 0x1b, 0xbe, 0xb1, 0xcb, 0x19, 0xe0)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputPCM,          "F2421DA5-BBB4-4cd5-A996-933C6B5D1347", 0xf2421da5, 0xbbb4, 0x4cd5, 0xa9, 0x96, 0x93, 0x3c, 0x6b, 0x5d, 0x13, 0x47)
DEFINE_CODECAPI_GUID( GUID_AVDecAudioInputMPEG,         "91106F36-02C5-4f75-9719-3B7ABF75E1F6", 0x91106f36, 0x02c5, 0x4f75, 0x97, 0x19, 0x3b, 0x7a, 0xbf, 0x75, 0xe1, 0xf6)

// AVDecAudioDualMono (UINT32) - Read only
// The input bitstream header might have a field indicating whether the 2-ch bitstream
// is dual mono or not. Use this property to read this field.
// If it's dual mono, the application can set AVDecAudioDualMonoReproMode to determine
// one of 4 reproduction modes
DEFINE_CODECAPI_GUID( AVDecAudioDualMono,"4a52cda8-30f8-4216-be0f-ba0b2025921d", 0x4a52cda8, 0x30f8, 0x4216, 0xbe, 0x0f, 0xba, 0x0b, 0x20, 0x25, 0x92, 0x1d )

enum eAVDecAudioDualMono
{
    eAVDecAudioDualMono_IsNotDualMono = 0, // 2-ch bitstream input is not dual mono
    eAVDecAudioDualMono_IsDualMono    = 1, // 2-ch bitstream input is dual mono
    eAVDecAudioDualMono_UnSpecified   = 2  // There is no indication in the bitstream 
}; 

// AVDecAudioDualMonoReproMode (UINT32)
// Reproduction modes for programs containing two independent mono channels (Ch1 & Ch2).
// In case of 2-ch input, the decoder should get AVDecAudioDualMono to check if the input
// is regular stereo or dual mono. If dual mono, the application can ask the user to set the playback
// mode by setting AVDecAudioDualReproMonoMode. If output is not stereo, use AVDecDDMatrixDecodingMode or
// equivalent.
DEFINE_CODECAPI_GUID( AVDecAudioDualMonoReproMode,"a5106186-cc94-4bc9-8cd9-aa2f61f6807e", 0xa5106186, 0xcc94, 0x4bc9, 0x8c, 0xd9, 0xaa, 0x2f, 0x61, 0xf6, 0x80, 0x7e )

enum eAVDecAudioDualMonoReproMode
{
    eAVDecAudioDualMonoReproMode_STEREO      = 0, // Ch1+Ch2 for mono output, (Ch1 left,     Ch2 right) for stereo output
    eAVDecAudioDualMonoReproMode_LEFT_MONO   = 1, // Ch1 for mono output,     (Ch1 left,     Ch1 right) for stereo output
    eAVDecAudioDualMonoReproMode_RIGHT_MONO  = 2, // Ch2 for mono output,     (Ch2 left,     Ch2 right) for stereo output
    eAVDecAudioDualMonoReproMode_MIX_MONO    = 3, // Ch1+Ch2 for mono output, (Ch1+Ch2 left, Ch1+Ch2 right) for stereo output
};

//
// Audio Common Properties
//

// AVAudioChannelCount (UINT32)
// Total number of audio channels, including LFE if it exists.
DEFINE_CODECAPI_GUID( AVAudioChannelCount,          "1d3583c4-1583-474e-b71a-5ee463c198e4", 0x1d3583c4, 0x1583, 0x474e, 0xb7, 0x1a, 0x5e, 0xe4, 0x63, 0xc1, 0x98, 0xe4 )

// AVAudioChannelConfig (UINT32)
// A bit-wise OR of any number of enum values specified by eAVAudioChannelConfig
DEFINE_CODECAPI_GUID( AVAudioChannelConfig,         "17f89cb3-c38d-4368-9ede-63b94d177f9f", 0x17f89cb3, 0xc38d, 0x4368, 0x9e, 0xde, 0x63, 0xb9, 0x4d, 0x17, 0x7f, 0x9f )

// Enumerated values for  AVAudioChannelConfig are identical 
// to the speaker positions defined in ksmedia.h and used 
// in WAVE_FORMAT_EXTENSIBLE. Configurations for 5.1 and
// 7.1 channels should be identical to KSAUDIO_SPEAKER_5POINT1_SURROUND
// and KSAUDIO_SPEAKER_7POINT1_SURROUND in ksmedia.h. This means:
// 5.1 ch -> LOW_FREQUENCY | FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | SIDE_LEFT | SIDE_RIGHT 
// 7.1 ch -> LOW_FREQUENCY | FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | SIDE_LEFT | SIDE_RIGHT | BACK_LEFT | BACK_RIGHT
//
enum eAVAudioChannelConfig
{
    eAVAudioChannelConfig_FRONT_LEFT    = 0x1, 
    eAVAudioChannelConfig_FRONT_RIGHT   = 0x2, 
    eAVAudioChannelConfig_FRONT_CENTER  = 0x4, 
    eAVAudioChannelConfig_LOW_FREQUENCY = 0x8,  // aka LFE
    eAVAudioChannelConfig_BACK_LEFT     = 0x10, 
    eAVAudioChannelConfig_BACK_RIGHT    = 0x20, 
    eAVAudioChannelConfig_FRONT_LEFT_OF_CENTER  = 0x40, 
    eAVAudioChannelConfig_FRONT_RIGHT_OF_CENTER = 0x80, 
    eAVAudioChannelConfig_BACK_CENTER = 0x100,  // aka Mono Surround 
    eAVAudioChannelConfig_SIDE_LEFT   = 0x200,  // aka Left Surround
    eAVAudioChannelConfig_SIDE_RIGHT  = 0x400,  // aka Right Surround
    eAVAudioChannelConfig_TOP_CENTER  = 0x800, 
    eAVAudioChannelConfig_TOP_FRONT_LEFT   = 0x1000, 
    eAVAudioChannelConfig_TOP_FRONT_CENTER = 0x2000, 
    eAVAudioChannelConfig_TOP_FRONT_RIGHT  = 0x4000, 
    eAVAudioChannelConfig_TOP_BACK_LEFT    = 0x8000, 
    eAVAudioChannelConfig_TOP_BACK_CENTER  = 0x10000, 
    eAVAudioChannelConfig_TOP_BACK_RIGHT   = 0x20000 
};

// AVAudioSampleRate (UINT32)
// In samples per second (Hz)
DEFINE_CODECAPI_GUID( AVAudioSampleRate,            "971d2723-1acb-42e7-855c-520a4b70a5f2", 0x971d2723, 0x1acb, 0x42e7, 0x85, 0x5c, 0x52, 0x0a, 0x4b, 0x70, 0xa5, 0xf2 )

//
// Dolby Digital(TM) Audio Specific Parameters
//

// AVDDSurroundMode (UINT32) common to encoder/decoder
DEFINE_CODECAPI_GUID( AVDDSurroundMode,            "99f2f386-98d1-4452-a163-abc78a6eb770", 0x99f2f386, 0x98d1, 0x4452, 0xa1, 0x63, 0xab, 0xc7, 0x8a, 0x6e, 0xb7, 0x70 )

enum eAVDDSurroundMode
{
    eAVDDSurroundMode_NotIndicated = 0,
    eAVDDSurroundMode_No           = 1,
    eAVDDSurroundMode_Yes          = 2
};

// AVDecDDOperationalMode (UINT32)
DEFINE_CODECAPI_GUID( AVDecDDOperationalMode,"d6d6c6d1-064e-4fdd-a40e-3ecbfcb7ebd0", 0xd6d6c6d1, 0x064e, 0x4fdd, 0xa4, 0x0e, 0x3e, 0xcb, 0xfc, 0xb7, 0xeb, 0xd0 )

enum eAVDecDDOperationalMode
{
    eAVDecDDOperationalMode_NONE    = 0,
    eAVDecDDOperationalMode_LINE    = 1,// Dialnorm enabled, dialogue at -31dBFS, dynrng used, high/low scaling allowed  
    eAVDecDDOperationalMode_RF      = 2,// Dialnorm enabled, dialogue at -20dBFS, dynrng & compr used, high/low scaling NOT allowed (always fully compressed)
    eAVDecDDOperationalMode_CUSTOM0 = 3,// Analog dialnorm (dialogue normalization not part of the decoder)
    eAVDecDDOperationalMode_CUSTOM1 = 4 // Digital dialnorm (dialogue normalization is part of the decoder)
};

// AVDecDDMatrixDecodingMode(UINT32)
// A ProLogic decoder has a built-in auto-detection feature. When the Dolby Digital decoder 
// is set to the 6-channel output configuration and it is fed a 2/0 bit stream to decode, it can 
// do one of the following: 
// a) decode the bit stream and output it on the two front channels (eAVDecDDMatrixDecodingMode_OFF), 
// b) decode the bit stream followed by ProLogic decoding to create 6-channels (eAVDecDDMatrixDecodingMode_ON). 
// c) the decoder will look at the Surround bit ("dsurmod") in the bit stream to determine whether 
//    apply ProLogic decoding or not (eAVDecDDMatrixDecodingMode_AUTO).
DEFINE_CODECAPI_GUID( AVDecDDMatrixDecodingMode,"ddc811a5-04ed-4bf3-a0ca-d00449f9355f", 0xddc811a5, 0x04ed, 0x4bf3, 0xa0, 0xca, 0xd0, 0x04, 0x49, 0xf9, 0x35, 0x5f )

enum eAVDecDDMatrixDecodingMode
{
    eAVDecDDMatrixDecodingMode_OFF  = 0,  
    eAVDecDDMatrixDecodingMode_ON   = 1,  
    eAVDecDDMatrixDecodingMode_AUTO = 2   
};

// AVDecDDDynamicRangeScaleHigh (UINT32) 
// Indicates what fraction of the dynamic range compression
// to apply. Relevant for negative values of dynrng only.
// Linear range 0-100, where:
//   0 - No dynamic range compression (preserve full dynamic range)
// 100 - Apply full dynamic range compression 
DEFINE_CODECAPI_GUID( AVDecDDDynamicRangeScaleHigh,"50196c21-1f33-4af5-b296-11426d6c8789", 0x50196c21, 0x1f33, 0x4af5, 0xb2, 0x96, 0x11, 0x42, 0x6d, 0x6c, 0x87, 0x89 )


// AVDecDDDynamicRangeScaleLow (UINT32) 
// Indicates what fraction of the dynamic range compression
// to apply. Relevant for positive values of dynrng only.
// Linear range 0-100, where:
//   0 - No dynamic range compression (preserve full dynamic range)
// 100 - Apply full dynamic range compression 
DEFINE_CODECAPI_GUID( AVDecDDDynamicRangeScaleLow,"044e62e4-11a5-42d5-a3b2-3bb2c7c2d7cf", 0x044e62e4, 0x11a5, 0x42d5, 0xa3, 0xb2, 0x3b, 0xb2, 0xc7, 0xc2, 0xd7, 0xcf )


#ifndef UUID_GEN
// { GUID refs
    #define CODECAPI_AVEncCommonFormatConstraint DEFINE_CODECAPI_GUIDNAMED( AVEncCommonFormatConstraint )
    #define CODECAPI_GUID_AVEncCommonFormatUnSpecified  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatUnSpecified    )
    #define CODECAPI_GUID_AVEncCommonFormatDVD_V    DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVD_V )
    #define CODECAPI_GUID_AVEncCommonFormatDVD_DashVR   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVD_DashVR )
    #define CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVD_PlusVR )
    #define CODECAPI_GUID_AVEncCommonFormatVCD  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatVCD )
    #define CODECAPI_GUID_AVEncCommonFormatSVCD DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatSVCD )
    #define CODECAPI_GUID_AVEncCommonFormatATSC DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatATSC )
    #define CODECAPI_GUID_AVEncCommonFormatDVB  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatDVB )
    #define CODECAPI_GUID_AVEncCommonFormatMP3  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatMP3 )
    #define CODECAPI_GUID_AVEncCommonFormatHighMAT  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatHighMAT )
    #define CODECAPI_GUID_AVEncCommonFormatHighMPV  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncCommonFormatHighMPV )
    #define CODECAPI_AVEncCodecType DEFINE_CODECAPI_GUIDNAMED( AVEncCodecType )
    #define CODECAPI_GUID_AVEncMPEG1Video   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG1Video )
    #define CODECAPI_GUID_AVEncMPEG2Video   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG2Video )
    #define CODECAPI_GUID_AVEncMPEG1Audio   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG1Audio )
    #define CODECAPI_GUID_AVEncMPEG2Audio   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMPEG2Audio )
    #define CODECAPI_GUID_AVEncWMV  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMV )
    #define CODECAPI_GUID_AVEndMPEG4Video   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEndMPEG4Video )
    #define CODECAPI_GUID_AVEncH264Video    DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncH264Video )
    #define CODECAPI_GUID_AVEncDV   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDV )
    #define CODECAPI_GUID_AVEncWMAPro   DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMAPro )
    #define CODECAPI_GUID_AVEncWMALossless  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMALossless )
    #define CODECAPI_GUID_AVEncWMAVoice DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncWMAVoice )
    #define CODECAPI_GUID_AVEncDolbyDigitalPro      DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDolbyDigitalPro )
    #define CODECAPI_GUID_AVEncDolbyDigitalConsumer DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDolbyDigitalConsumer )
    #define CODECAPI_GUID_AVEncDolbyDigitalPlus     DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDolbyDigitalPlus )
    #define CODECAPI_GUID_AVEncDTSHD                DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDTSHD )
    #define CODECAPI_GUID_AVEncDTS  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncDTS )
    #define CODECAPI_GUID_AVEncMLP  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncMLP )
    #define CODECAPI_GUID_AVEncPCM  DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncPCM )
    #define CODECAPI_GUID_AVEncSDDS DEFINE_CODECAPI_GUIDNAMED( GUID_AVEncSDDS )
    #define CODECAPI_AVEncCommonRateControlMode DEFINE_CODECAPI_GUIDNAMED( AVEncCommonRateControlMode )
    #define CODECAPI_AVEncCommonLowLatency  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonLowLatency )
    #define CODECAPI_AVEncCommonMultipassMode   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMultipassMode )
    #define CODECAPI_AVEncCommonPassStart   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonPassStart )
    #define CODECAPI_AVEncCommonPassEnd DEFINE_CODECAPI_GUIDNAMED( AVEncCommonPassEnd )
    #define CODECAPI_AVEncCommonRealTime    DEFINE_CODECAPI_GUIDNAMED( AVEncCommonRealTime )
    #define CODECAPI_AVEncCommonQuality DEFINE_CODECAPI_GUIDNAMED( AVEncCommonQuality )
    #define CODECAPI_AVEncCommonQualityVsSpeed  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonQualityVsSpeed )
    #define CODECAPI_AVEncCommonMeanBitRate DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMeanBitRate )
    #define CODECAPI_AVEncCommonMeanBitRateInterval DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMeanBitRateInterval )
    #define CODECAPI_AVEncCommonMaxBitRate  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMaxBitRate )
    #define CODECAPI_AVEncCommonMinBitRate  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonMinBitRate )
    #define CODECAPI_AVEncCommonBufferSize  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonBufferSize )
    #define CODECAPI_AVEncCommonBufferInLevel   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonBufferInLevel )
    #define CODECAPI_AVEncCommonBufferOutLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncCommonBufferOutLevel )
    #define CODECAPI_AVEncCommonStreamEndHandling   DEFINE_CODECAPI_GUIDNAMED( AVEncCommonStreamEndHandling )
    #define CODECAPI_AVEncStatCommonCompletedPasses DEFINE_CODECAPI_GUIDNAMED( AVEncStatCommonCompletedPasses )
    #define CODECAPI_AVEncVideoOutputFrameRate  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputFrameRate )
    #define CODECAPI_AVEncVideoOutputFrameRateConversion    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputFrameRateConversion )
    #define CODECAPI_AVEncVideoPixelAspectRatio DEFINE_CODECAPI_GUIDNAMED( AVEncVideoPixelAspectRatio )
    #define CODECAPI_AVEncVideoForceSourceScanType  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoForceSourceScanType )
    #define CODECAPI_AVEncVideoNoOfFieldsToEncode   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoNoOfFieldsToEncode )
    #define CODECAPI_AVEncVideoNoOfFieldsToSkip DEFINE_CODECAPI_GUIDNAMED( AVEncVideoNoOfFieldsToSkip )
    #define CODECAPI_AVEncVideoEncodeDimension  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoEncodeDimension )
    #define CODECAPI_AVEncVideoEncodeOffsetOrigin   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoEncodeOffsetOrigin )
    #define CODECAPI_AVEncVideoDisplayDimension DEFINE_CODECAPI_GUIDNAMED( AVEncVideoDisplayDimension )
    #define CODECAPI_AVEncVideoOutputScanType   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputScanType )
    #define CODECAPI_AVEncVideoInverseTelecineEnable    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInverseTelecineEnable )
    #define CODECAPI_AVEncVideoInverseTelecineThreshold DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInverseTelecineThreshold )
    #define CODECAPI_AVEncVideoSourceFilmContent    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoSourceFilmContent )
    #define CODECAPI_AVEncVideoSourceIsBW   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoSourceIsBW )
    #define CODECAPI_AVEncVideoFieldSwap    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoFieldSwap )
    #define CODECAPI_AVEncVideoInputChromaResolution    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputChromaResolution )
    #define CODECAPI_AVEncVideoOutputChromaResolution   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputChromaResolution )
    #define CODECAPI_AVEncVideoInputChromaSubsampling   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputChromaSubsampling )
    #define CODECAPI_AVEncVideoOutputChromaSubsampling  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputChromaSubsampling )
    #define CODECAPI_AVEncVideoInputColorPrimaries  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorPrimaries )
    #define CODECAPI_AVEncVideoOutputColorPrimaries DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorPrimaries )
    #define CODECAPI_AVEncVideoInputColorTransferFunction   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorTransferFunction )
    #define CODECAPI_AVEncVideoOutputColorTransferFunction  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorTransferFunction )
    #define CODECAPI_AVEncVideoInputColorTransferMatrix DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorTransferMatrix )
    #define CODECAPI_AVEncVideoOutputColorTransferMatrix    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorTransferMatrix  )
    #define CODECAPI_AVEncVideoInputColorLighting   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorLighting )
    #define CODECAPI_AVEncVideoOutputColorLighting  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorLighting  )
    #define CODECAPI_AVEncVideoInputColorNominalRange   DEFINE_CODECAPI_GUIDNAMED( AVEncVideoInputColorNominalRange )
    #define CODECAPI_AVEncVideoOutputColorNominalRange  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoOutputColorNominalRange  )
    #define CODECAPI_AVEncInputVideoSystem  DEFINE_CODECAPI_GUIDNAMED( AVEncInputVideoSystem )
    #define CODECAPI_AVEncVideoHeaderDropFrame  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderDropFrame )
    #define CODECAPI_AVEncVideoHeaderHours  DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderHours )
    #define CODECAPI_AVEncVideoHeaderMinutes    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderMinutes )
    #define CODECAPI_AVEncVideoHeaderSeconds    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderSeconds )
    #define CODECAPI_AVEncVideoHeaderFrames DEFINE_CODECAPI_GUIDNAMED( AVEncVideoHeaderFrames )
    #define CODECAPI_AVEncVideoDefaultUpperFieldDominant    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoDefaultUpperFieldDominant )
    #define CODECAPI_AVEncVideoCBRMotionTradeoff    DEFINE_CODECAPI_GUIDNAMED( AVEncVideoCBRMotionTradeoff )
    #define CODECAPI_AVEncVideoCodedVideoAccessUnitSize DEFINE_CODECAPI_GUIDNAMED( AVEncVideoCodedVideoAccessUnitSize )
    #define CODECAPI_AVEncVideoMaxKeyframeDistance DEFINE_CODECAPI_GUIDNAMED( AVEncVideoMaxKeyframeDistance )
    #define CODECAPI_AVEncStatVideoOutputFrameRate  DEFINE_CODECAPI_GUIDNAMED( AVEncStatVideoOutputFrameRate )
    #define CODECAPI_AVEncStatVideoCodedFrames  DEFINE_CODECAPI_GUIDNAMED( AVEncStatVideoCodedFrames )
    #define CODECAPI_AVEncStatVideoTotalFrames  DEFINE_CODECAPI_GUIDNAMED( AVEncStatVideoTotalFrames )
    #define CODECAPI_AVEncAudioIntervalToEncode DEFINE_CODECAPI_GUIDNAMED( AVEncAudioIntervalToEncode )
    #define CODECAPI_AVEncAudioIntervalToSkip   DEFINE_CODECAPI_GUIDNAMED( AVEncAudioIntervalToSkip )
    #define CODECAPI_AVEncAudioDualMono         DEFINE_CODECAPI_GUIDNAMED( AVEncAudioDualMono )


    #define CODECAPI_AVEncAudioMapDestChannel0  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel0 )
    #define CODECAPI_AVEncAudioMapDestChannel1  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel1 )
    #define CODECAPI_AVEncAudioMapDestChannel2  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel2 )
    #define CODECAPI_AVEncAudioMapDestChannel3  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel3 )
    #define CODECAPI_AVEncAudioMapDestChannel4  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel4 )
    #define CODECAPI_AVEncAudioMapDestChannel5  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel5 )
    #define CODECAPI_AVEncAudioMapDestChannel6  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel6 )
    #define CODECAPI_AVEncAudioMapDestChannel7  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel7 )
    #define CODECAPI_AVEncAudioMapDestChannel8  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel8 )
    #define CODECAPI_AVEncAudioMapDestChannel9  DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel9 )
    #define CODECAPI_AVEncAudioMapDestChannel10 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel10 )
    #define CODECAPI_AVEncAudioMapDestChannel11 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel11 )
    #define CODECAPI_AVEncAudioMapDestChannel12 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel12 )
    #define CODECAPI_AVEncAudioMapDestChannel13 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel13 )
    #define CODECAPI_AVEncAudioMapDestChannel14 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel14 )
    #define CODECAPI_AVEncAudioMapDestChannel15 DEFINE_CODECAPI_GUIDNAMED( AVEncAudioMapDestChannel15 )
    
    #define CODECAPI_AVEncAudioInputContent DEFINE_CODECAPI_GUIDNAMED( AVEncAudioInputContent )
    #define CODECAPI_AVEncStatAudioPeakPCMValue DEFINE_CODECAPI_GUIDNAMED( AVEncStatAudioPeakPCMValue )
    #define CODECAPI_AVEncStatAudioAveragePCMValue  DEFINE_CODECAPI_GUIDNAMED( AVEncStatAudioAveragePCMValue )
    #define CODECAPI_AVEncStatAudioAverageBPS   DEFINE_CODECAPI_GUIDNAMED( AVEncStatAudioAverageBPS )
    #define CODECAPI_AVEncMPVGOPSize    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGOPSize )
    #define CODECAPI_AVEncMPVGOPOpen    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGOPOpen )
    #define CODECAPI_AVEncMPVDefaultBPictureCount   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVDefaultBPictureCount )
    #define CODECAPI_AVEncMPVProfile    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVProfile )
    #define CODECAPI_AVEncMPVLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVLevel )
    #define CODECAPI_AVEncMPVFrameFieldMode DEFINE_CODECAPI_GUIDNAMED( AVEncMPVFrameFieldMode )
    #define CODECAPI_AVEncMPVAddSeqEndCode  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVAddSeqEndCode )
    #define CODECAPI_AVEncMPVGOPSInSeq  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGOPSInSeq )
    #define CODECAPI_AVEncMPVUseConcealmentMotionVectors    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVUseConcealmentMotionVectors )
    #define CODECAPI_AVEncMPVSceneDetection DEFINE_CODECAPI_GUIDNAMED( AVEncMPVSceneDetection )
    #define CODECAPI_AVEncMPVGenerateHeaderSeqExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderSeqExt )
    #define CODECAPI_AVEncMPVGenerateHeaderSeqDispExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderSeqDispExt )
    #define CODECAPI_AVEncMPVGenerateHeaderPicExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderPicExt )
    #define CODECAPI_AVEncMPVGenerateHeaderPicDispExt   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderPicDispExt )
    #define CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVGenerateHeaderSeqScaleExt )
    #define CODECAPI_AVEncMPVScanPattern    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVScanPattern )
    #define CODECAPI_AVEncMPVIntraDCPrecision   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVIntraDCPrecision )
    #define CODECAPI_AVEncMPVQScaleType DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQScaleType )
    #define CODECAPI_AVEncMPVIntraVLCTable  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVIntraVLCTable )
    #define CODECAPI_AVEncMPVQuantMatrixIntra   DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixIntra )
    #define CODECAPI_AVEncMPVQuantMatrixNonIntra    DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixNonIntra )
    #define CODECAPI_AVEncMPVQuantMatrixChromaIntra DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixChromaIntra )
    #define CODECAPI_AVEncMPVQuantMatrixChromaNonIntra  DEFINE_CODECAPI_GUIDNAMED( AVEncMPVQuantMatrixChromaNonIntra )
    #define CODECAPI_AVEncMPALayer  DEFINE_CODECAPI_GUIDNAMED( AVEncMPALayer )
    #define CODECAPI_AVEncMPACodingMode DEFINE_CODECAPI_GUIDNAMED( AVEncMPACodingMode )
    #define CODECAPI_AVEncDDService DEFINE_CODECAPI_GUIDNAMED( AVEncDDService )
    #define CODECAPI_AVEncDDDialogNormalization DEFINE_CODECAPI_GUIDNAMED( AVEncDDDialogNormalization )
    #define CODECAPI_AVEncDDCentreDownMixLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncDDCentreDownMixLevel )
    #define CODECAPI_AVEncDDSurroundDownMixLevel    DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurroundDownMixLevel )
    #define CODECAPI_AVEncDDProductionInfoExists    DEFINE_CODECAPI_GUIDNAMED( AVEncDDProductionInfoExists )
    #define CODECAPI_AVEncDDProductionRoomType  DEFINE_CODECAPI_GUIDNAMED( AVEncDDProductionRoomType )
    #define CODECAPI_AVEncDDProductionMixLevel  DEFINE_CODECAPI_GUIDNAMED( AVEncDDProductionMixLevel )
    #define CODECAPI_AVEncDDCopyright   DEFINE_CODECAPI_GUIDNAMED( AVEncDDCopyright )
    #define CODECAPI_AVEncDDOriginalBitstream   DEFINE_CODECAPI_GUIDNAMED( AVEncDDOriginalBitstream )
    #define CODECAPI_AVEncDDDigitalDeemphasis   DEFINE_CODECAPI_GUIDNAMED( AVEncDDDigitalDeemphasis )
    #define CODECAPI_AVEncDDDCHighPassFilter    DEFINE_CODECAPI_GUIDNAMED( AVEncDDDCHighPassFilter )
    #define CODECAPI_AVEncDDChannelBWLowPassFilter  DEFINE_CODECAPI_GUIDNAMED( AVEncDDChannelBWLowPassFilter )
    #define CODECAPI_AVEncDDLFELowPassFilter    DEFINE_CODECAPI_GUIDNAMED( AVEncDDLFELowPassFilter )
    #define CODECAPI_AVEncDDSurround90DegreeePhaseShift DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurround90DegreeePhaseShift )
    #define CODECAPI_AVEncDDSurround3dBAttenuation  DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurround3dBAttenuation )
    #define CODECAPI_AVEncDDDynamicRangeCompressionControl  DEFINE_CODECAPI_GUIDNAMED( AVEncDDDynamicRangeCompressionControl )
    #define CODECAPI_AVEncDDRFPreEmphasisFilter DEFINE_CODECAPI_GUIDNAMED( AVEncDDRFPreEmphasisFilter )
    #define CODECAPI_AVEncDDSurroundExMode  DEFINE_CODECAPI_GUIDNAMED( AVEncDDSurroundExMode )
    #define CODECAPI_AVEncDDPreferredStereoDownMixMode  DEFINE_CODECAPI_GUIDNAMED( AVEncDDPreferredStereoDownMixMode )
    #define CODECAPI_AVEncDDLtRtCenterMixLvl_x10    DEFINE_CODECAPI_GUIDNAMED( AVEncDDLtRtCenterMixLvl_x10 )
    #define CODECAPI_AVEncDDLtRtSurroundMixLvl_x10  DEFINE_CODECAPI_GUIDNAMED( AVEncDDLtRtSurroundMixLvl_x10 )
    #define CODECAPI_AVEncDDLoRoCenterMixLvl_x10    DEFINE_CODECAPI_GUIDNAMED( AVEncDDLoRoCenterMixLvl_x10 )
    #define CODECAPI_AVEncDDLoRoSurroundMixLvl_x10  DEFINE_CODECAPI_GUIDNAMED( AVEncDDLoRoSurroundMixLvl_x10 )
    #define CODECAPI_AVEncDDAtoDConverterType   DEFINE_CODECAPI_GUIDNAMED( AVEncDDAtoDConverterType )
    #define CODECAPI_AVEncDDHeadphoneMode   DEFINE_CODECAPI_GUIDNAMED( AVEncDDHeadphoneMode )
    #define CODECAPI_AVEncWMVKeyFrameDistance   DEFINE_CODECAPI_GUIDNAMED( AVEncWMVKeyFrameDistance )
    #define CODECAPI_AVEncWMVInterlacedEncoding DEFINE_CODECAPI_GUIDNAMED( AVEncWMVInterlacedEncoding )
    #define CODECAPI_AVEncWMVDecoderComplexity  DEFINE_CODECAPI_GUIDNAMED( AVEncWMVDecoderComplexity )
    #define CODECAPI_AVEncWMVKeyFrameBufferLevelMarker  DEFINE_CODECAPI_GUIDNAMED( AVEncWMVKeyFrameBufferLevelMarker )
    #define CODECAPI_AVEncWMVProduceDummyFrames DEFINE_CODECAPI_GUIDNAMED( AVEncWMVProduceDummyFrames )
    #define CODECAPI_AVEncStatWMVCBAvg  DEFINE_CODECAPI_GUIDNAMED( AVEncStatWMVCBAvg )
    #define CODECAPI_AVEncStatWMVCBMax  DEFINE_CODECAPI_GUIDNAMED( AVEncStatWMVCBMax )
    #define CODECAPI_AVEncStatWMVDecoderComplexityProfile   DEFINE_CODECAPI_GUIDNAMED( AVEncStatWMVDecoderComplexityProfile )
    #define CODECAPI_AVEncStatMPVSkippedEmptyFrames DEFINE_CODECAPI_GUIDNAMED( AVEncStatMPVSkippedEmptyFrames )
    #define CODECAPI_AVEncMP12PktzSTDBuffer DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzSTDBuffer )
    #define CODECAPI_AVEncMP12PktzStreamID  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzStreamID )
    #define CODECAPI_AVEncMP12PktzInitialPTS    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzInitialPTS )
    #define CODECAPI_AVEncMP12PktzPacketSize    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzPacketSize )
    #define CODECAPI_AVEncMP12PktzCopyright DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzCopyright )
    #define CODECAPI_AVEncMP12PktzOriginal  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12PktzOriginal )
    #define CODECAPI_AVEncMP12MuxPacketOverhead DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxPacketOverhead )
    #define CODECAPI_AVEncMP12MuxNumStreams DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxNumStreams )
    #define CODECAPI_AVEncMP12MuxEarliestPTS    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxEarliestPTS )
    #define CODECAPI_AVEncMP12MuxLargestPacketSize  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxLargestPacketSize )
    #define CODECAPI_AVEncMP12MuxInitialSCR DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxInitialSCR )
    #define CODECAPI_AVEncMP12MuxMuxRate    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxMuxRate )
    #define CODECAPI_AVEncMP12MuxPackSize   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxPackSize )
    #define CODECAPI_AVEncMP12MuxSysSTDBufferBound  DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysSTDBufferBound )
    #define CODECAPI_AVEncMP12MuxSysRateBound   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysRateBound )
    #define CODECAPI_AVEncMP12MuxTargetPacketizer   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxTargetPacketizer )
    #define CODECAPI_AVEncMP12MuxSysFixed   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysFixed )
    #define CODECAPI_AVEncMP12MuxSysCSPS    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysCSPS )
    #define CODECAPI_AVEncMP12MuxSysVideoLock   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysVideoLock )
    #define CODECAPI_AVEncMP12MuxSysAudioLock   DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxSysAudioLock )
    #define CODECAPI_AVEncMP12MuxDVDNavPacks    DEFINE_CODECAPI_GUIDNAMED( AVEncMP12MuxDVDNavPacks )
    
    #define CODECAPI_AVEncMPACopyright                  DEFINE_CODECAPI_GUIDNAMED( AVEncMPACopyright )
    #define CODECAPI_AVEncMPAOriginalBitstream          DEFINE_CODECAPI_GUIDNAMED( AVEncMPAOriginalBitstream )
    #define CODECAPI_AVEncMPAEnableRedundancyProtection  DEFINE_CODECAPI_GUIDNAMED( AVEncMPAEnableRedundancyProtection )
    #define CODECAPI_AVEncMPAPrivateUserBit            DEFINE_CODECAPI_GUIDNAMED( AVEncMPAPrivateUserBit )
    #define CODECAPI_AVEncMPAEmphasisType               DEFINE_CODECAPI_GUIDNAMED( AVEncMPAEmphasisType )

    #define CODECAPI_AVDecCommonOutputFormat                        DEFINE_CODECAPI_GUIDNAMED( AVDecCommonOutputFormat )
    #define CODECAPI_AVDecCommonInputFormat     DEFINE_CODECAPI_GUIDNAMED( AVDecCommonInputFormat )
    #define CODECAPI_AVDecCommonMeanBitRate         DEFINE_CODECAPI_GUIDNAMED( AVDecCommonMeanBitRate )
    #define CODECAPI_AVDecCommonMeanBitRateInterval DEFINE_CODECAPI_GUIDNAMED( AVDecCommonMeanBitRateInterval )

    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded   DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM            DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM      DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_SPDIF_PCM )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream    DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_SPDIF_Bitstream )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM_Headphones )
    #define CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto )

    #define CODECAPI_AVDecVideoImageSize            DEFINE_CODECAPI_GUIDNAMED( AVDecVideoImageSize )
    #define CODECAPI_AVDecVideoInputScanType        DEFINE_CODECAPI_GUIDNAMED( AVDecVideoInputScanType )
    #define CODECAPI_AVDecVideoPixelAspectRatio     DEFINE_CODECAPI_GUIDNAMED( AVDecVideoPixelAspectRatio )

    #define CODECAPI_GUID_AVDecAudioInputWMA        DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputWMA )
    #define CODECAPI_GUID_AVDecAudioInputWMAPro     DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputWMAPro )
    #define CODECAPI_GUID_AVDecAudioInputDolby      DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputDolby )
    #define CODECAPI_GUID_AVDecAudioInputDTS        DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputDTS )
    #define CODECAPI_GUID_AVDecAudioInputPCM        DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputPCM )
    #define CODECAPI_GUID_AVDecAudioInputMPEG       DEFINE_CODECAPI_GUIDNAMED( GUID_AVDecAudioInputMPEG )
    #define CODECAPI_AVDecAudioDualMono             DEFINE_CODECAPI_GUIDNAMED( AVDecAudioDualMono)
    #define CODECAPI_AVDecAudioDualMonoReproMode    DEFINE_CODECAPI_GUIDNAMED( AVDecAudioDualMonoReproMode )

    #define CODECAPI_AVAudioChannelCount            DEFINE_CODECAPI_GUIDNAMED( AVAudioChannelCount )
    #define CODECAPI_AVAudioChannelConfig           DEFINE_CODECAPI_GUIDNAMED( AVAudioChannelConfig )
    #define CODECAPI_AVAudioSampleRate              DEFINE_CODECAPI_GUIDNAMED( AVAudioSampleRate )

    #define CODECAPI_AVDDSurroundMode               DEFINE_CODECAPI_GUIDNAMED( AVDDSurroundMode )
    #define CODECAPI_AVDecDDOperationalMode         DEFINE_CODECAPI_GUIDNAMED( AVDecDDOperationalMode )
    #define CODECAPI_AVDecDDMatrixDecodingMode      DEFINE_CODECAPI_GUIDNAMED( AVDecDDMatrixDecodingMode )
    #define CODECAPI_AVDecDDDynamicRangeScaleHigh   DEFINE_CODECAPI_GUIDNAMED( AVDecDDDynamicRangeScaleHigh )
    #define CODECAPI_AVDecDDDynamicRangeScaleLow    DEFINE_CODECAPI_GUIDNAMED( AVDecDDDynamicRangeScaleLow )

#endif


#endif // !defined(_CODECAPI_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d3dukmdt.h ===
/******************************Module*Header************************************\
*
* Module Name: d3dukmdt.h
*
* Content: Longhorn Display Driver Model (LDDM) user/kernel mode 
*          shared data type definitions.
*
* Copyright (c) 2003 Microsoft Corporation.  All rights reserved.
\*******************************************************************************/
#ifndef _D3DUKMDT_H_
#define _D3DUKMDT_H_

#if !defined(_D3DKMDT_H)       && \
    !defined(_D3DKMTHK_H_)     && \
    !defined(_D3DUMDDI_H_)     && \
    !defined(__DXGKRNLETW_H__)
   #error This header should not be included directly!
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present source unique identification number descriptor type
//
typedef UINT  D3DDDI_VIDEO_PRESENT_SOURCE_ID;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present source unique identification number descriptor type.
//
typedef UINT  D3DDDI_VIDEO_PRESENT_TARGET_ID;

//
// DDI level handle that represents a kernel mode object (allocation, device, etc)
//
typedef UINT D3DKMT_HANDLE;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target mode fractional frequency descriptor type.
//
// Remarks: Fractional value used to represent vertical and horizontal frequencies of a video mode
//          (i.e. VSync and HSync). Vertical frequencies are stored in Hz. Horizontal frequencies
//          are stored in Hz.
//          The dynamic range of this encoding format, given 10^-7 resolution is {0..(2^32 - 1) / 10^7},
//          which translates to {0..428.4967296} [Hz] for vertical frequencies and {0..428.4967296} [Hz]
//          for horizontal frequencies. This sub-microseconds precision range should be acceptable even
//          for a pro-video application (error in one microsecond for video signal synchronization would
//          imply a time drift with a cycle of 10^7/(60*60*24) = 115.741 days.
//
//          If rational number with a finite fractional sequence, use denominator of form 10^(length of fractional sequence).
//          If rational number without a finite fractional sequence, or a sequence exceeding the precision allowed by the 
//          dynamic range of the denominator, or an irrational number, use an appropriate ratio of integers which best 
//          represents the value.
//          
typedef struct _D3DDDI_RATIONAL
{
    UINT    Numerator;
    UINT    Denominator;
} D3DDDI_RATIONAL;



typedef struct _D3DDDI_ALLOCATIONINFO
{
    D3DKMT_HANDLE                   hAllocation;           // out: Private driver data for allocation
    CONST VOID*                     pSystemMem;            // in: Pointer to pre-allocated sysmem
    VOID*                           pPrivateDriverData;    // in(out optional): Private data for each allocation
    UINT                            PrivateDriverDataSize; // in: Size of the private data
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;         // in: VidPN source ID if this is a primary
    union
    {
        struct
        {
            UINT    Primary         : 1;    // 0x00000001
            UINT    Reserved        :31;    // 0xFFFFFFFE
        };
        UINT        Value;
    } Flags;
} D3DDDI_ALLOCATIONINFO;

typedef struct _D3DDDI_OPENALLOCATIONINFO
{
    D3DKMT_HANDLE   hAllocation;                // Handle for this allocation in this process
    CONST VOID*     pPrivateDriverData;         // Ptr to driver private buffer for this allocations
    UINT            PrivateDriverDataSize;      // Size in bytes of driver private buffer for this allocations    
}D3DDDI_OPENALLOCATIONINFO;

typedef struct _D3DDDI_ALLOCATIONLIST
{
    D3DKMT_HANDLE       hAllocation;
    union
    {
        struct
        {
            UINT            WriteOperation  	: 1;    // 0x00000001
            UINT            DoNotRetireInstance : 1;	// 0x00000002            
            UINT            Reserved        	:30;    // 0xFFFFFFFC
        };
        UINT                Value;
    };
} D3DDDI_ALLOCATIONLIST;

typedef struct _D3DDDI_PATCHLOCATIONLIST
{
    UINT                AllocationIndex;
    union
    {
        struct
        {
            UINT            SlotId          : 24;   // 0x00FFFFFF
            UINT            Reserved        : 8;    // 0xFF000000
        };
        UINT                Value;
    };
    UINT                DriverId;
    UINT                AllocationOffset;
    UINT                PatchOffset;
    UINT                SplitOffset;
} D3DDDI_PATCHLOCATIONLIST;

typedef struct _D3DDDICB_LOCKFLAGS
{
    union
    {
        struct
        {
            UINT    ReadOnly            : 1;    // 0x00000001
            UINT    WriteOnly           : 1;    // 0x00000002
            UINT    DonotWait           : 1;    // 0x00000004
            UINT    IgnoreSync          : 1;    // 0x00000008
            UINT    LockEntire          : 1;    // 0x00000010
            UINT    DonotEvict          : 1;    // 0x00000020
            UINT    AcquireAperture     : 1;    // 0x00000040
            UINT    Discard             : 1;    // 0x00000080
            UINT    NoExistingReference : 1;    // 0x00000100
            UINT    UseAlternateVA      : 1;    // 0x00000200
            UINT    IgnoreReadSync      : 1;    // 0x00000400
            UINT    Reserved            :21;    // 0xFFFFF800
        };
        UINT        Value;
    };
} D3DDDICB_LOCKFLAGS;

typedef struct _D3DDDI_ESCAPEFLAGS
{
    union
    {
        struct
        {
            UINT    HardwareAccess      : 1;    // 0x00000001
            UINT    Reserved            :31;    // 0xFFFFFFFE
        };
        UINT        Value;
    };
} D3DDDI_ESCAPEFLAGS;              

typedef struct _D3DDDI_CREATECONTEXTFLAGS
{
    union
    {
        struct
        {
            UINT    NullRendering : 1;      // 0x00000001
            UINT    Reserved      : 31;     // 0xFFFFFFFE
        };
        UINT Value;
    };
} D3DDDI_CREATECONTEXTFLAGS;

/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *      C = Computed from other channels (typically on certain read operations)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */


typedef enum _D3DDDIFORMAT
{

    D3DDDIFMT_UNKNOWN           =  0,

    D3DDDIFMT_R8G8B8            = 20,
    D3DDDIFMT_A8R8G8B8          = 21,
    D3DDDIFMT_X8R8G8B8          = 22,
    D3DDDIFMT_R5G6B5            = 23,
    D3DDDIFMT_X1R5G5B5          = 24,
    D3DDDIFMT_A1R5G5B5          = 25,
    D3DDDIFMT_A4R4G4B4          = 26,
    D3DDDIFMT_R3G3B2            = 27,
    D3DDDIFMT_A8                = 28,
    D3DDDIFMT_A8R3G3B2          = 29,
    D3DDDIFMT_X4R4G4B4          = 30,
    D3DDDIFMT_A2B10G10R10       = 31,
    D3DDDIFMT_A8B8G8R8          = 32,
    D3DDDIFMT_X8B8G8R8          = 33,
    D3DDDIFMT_G16R16            = 34,
    D3DDDIFMT_A2R10G10B10       = 35,
    D3DDDIFMT_A16B16G16R16      = 36,

    D3DDDIFMT_A8P8              = 40,
    D3DDDIFMT_P8                = 41,

    D3DDDIFMT_L8                = 50,
    D3DDDIFMT_A8L8              = 51,
    D3DDDIFMT_A4L4              = 52,

    D3DDDIFMT_V8U8              = 60,
    D3DDDIFMT_L6V5U5            = 61,
    D3DDDIFMT_X8L8V8U8          = 62,
    D3DDDIFMT_Q8W8V8U8          = 63,
    D3DDDIFMT_V16U16            = 64,
    D3DDDIFMT_W11V11U10         = 65, 
    D3DDDIFMT_A2W10V10U10       = 67,

    D3DDDIFMT_UYVY              = MAKEFOURCC('U', 'Y', 'V', 'Y'),
    D3DDDIFMT_R8G8_B8G8         = MAKEFOURCC('R', 'G', 'B', 'G'),
    D3DDDIFMT_YUY2              = MAKEFOURCC('Y', 'U', 'Y', '2'),
    D3DDDIFMT_G8R8_G8B8         = MAKEFOURCC('G', 'R', 'G', 'B'),
    D3DDDIFMT_DXT1              = MAKEFOURCC('D', 'X', 'T', '1'),
    D3DDDIFMT_DXT2              = MAKEFOURCC('D', 'X', 'T', '2'),
    D3DDDIFMT_DXT3              = MAKEFOURCC('D', 'X', 'T', '3'),
    D3DDDIFMT_DXT4              = MAKEFOURCC('D', 'X', 'T', '4'),
    D3DDDIFMT_DXT5              = MAKEFOURCC('D', 'X', 'T', '5'),

    D3DDDIFMT_D16_LOCKABLE      = 70,
    D3DDDIFMT_D32               = 71,
    D3DDDIFMT_D15S1             = 73,
    D3DDDIFMT_D24S8             = 75,
    D3DDDIFMT_D24X8             = 77,
    D3DDDIFMT_D24X4S4           = 79,
    D3DDDIFMT_D16               = 80,

    D3DDDIFMT_D32F_LOCKABLE     = 82,
    D3DDDIFMT_D24FS8            = 83,
    
    D3DDDIFMT_D32_LOCKABLE      = 84,
    D3DDDIFMT_S8_LOCKABLE       = 85,

    D3DDDIFMT_S1D15             = 72,                                          
    D3DDDIFMT_S8D24             = 74,                                         
    D3DDDIFMT_X8D24             = 76,                                          
    D3DDDIFMT_X4S4D24           = 78,                                         

    D3DDDIFMT_L16               = 81,

    D3DDDIFMT_VERTEXDATA        =100,
    D3DDDIFMT_INDEX16           =101,
    D3DDDIFMT_INDEX32           =102,

    D3DDDIFMT_Q16W16V16U16      =110,

    D3DDDIFMT_MULTI2_ARGB8      = MAKEFOURCC('M','E','T','1'),

    // Floating point surface formats

    // s10e5 formats (16-bits per channel)
    D3DDDIFMT_R16F              = 111,
    D3DDDIFMT_G16R16F           = 112,
    D3DDDIFMT_A16B16G16R16F     = 113,

    // IEEE s23e8 formats (32-bits per channel)
    D3DDDIFMT_R32F              = 114,
    D3DDDIFMT_G32R32F           = 115,
    D3DDDIFMT_A32B32G32R32F     = 116,

    D3DDDIFMT_CxV8U8            = 117,

    // Monochrome 1 bit per pixel format
    D3DDDIFMT_A1                = 118,

    // Decode compressed buffer formats
    D3DDDIFMT_DXVACOMPBUFFER_BASE     = 150,
    D3DDDIFMT_PICTUREPARAMSDATA       = D3DDDIFMT_DXVACOMPBUFFER_BASE+0,    // 150
    D3DDDIFMT_MACROBLOCKDATA          = D3DDDIFMT_DXVACOMPBUFFER_BASE+1,    // 151
    D3DDDIFMT_RESIDUALDIFFERENCEDATA  = D3DDDIFMT_DXVACOMPBUFFER_BASE+2,    // 152
    D3DDDIFMT_DEBLOCKINGDATA          = D3DDDIFMT_DXVACOMPBUFFER_BASE+3,    // 153
    D3DDDIFMT_INVERSEQUANTIZATIONDATA = D3DDDIFMT_DXVACOMPBUFFER_BASE+4,    // 154
    D3DDDIFMT_SLICECONTROLDATA        = D3DDDIFMT_DXVACOMPBUFFER_BASE+5,    // 155
    D3DDDIFMT_BITSTREAMDATA           = D3DDDIFMT_DXVACOMPBUFFER_BASE+6,    // 156
    D3DDDIFMT_MOTIONVECTORBUFFER      = D3DDDIFMT_DXVACOMPBUFFER_BASE+7,    // 157
    D3DDDIFMT_FILMGRAINBUFFER         = D3DDDIFMT_DXVACOMPBUFFER_BASE+8,    // 158
    D3DDDIFMT_DXVA_RESERVED9          = D3DDDIFMT_DXVACOMPBUFFER_BASE+9,    // 159
    D3DDDIFMT_DXVA_RESERVED10         = D3DDDIFMT_DXVACOMPBUFFER_BASE+10,   // 160
    D3DDDIFMT_DXVA_RESERVED11         = D3DDDIFMT_DXVACOMPBUFFER_BASE+11,   // 161
    D3DDDIFMT_DXVA_RESERVED12         = D3DDDIFMT_DXVACOMPBUFFER_BASE+12,   // 162
    D3DDDIFMT_DXVA_RESERVED13         = D3DDDIFMT_DXVACOMPBUFFER_BASE+13,   // 163
    D3DDDIFMT_DXVA_RESERVED14         = D3DDDIFMT_DXVACOMPBUFFER_BASE+14,   // 164
    D3DDDIFMT_DXVA_RESERVED15         = D3DDDIFMT_DXVACOMPBUFFER_BASE+15,   // 165
    D3DDDIFMT_DXVA_RESERVED16         = D3DDDIFMT_DXVACOMPBUFFER_BASE+16,   // 166
    D3DDDIFMT_DXVA_RESERVED17         = D3DDDIFMT_DXVACOMPBUFFER_BASE+17,   // 167
    D3DDDIFMT_DXVA_RESERVED18         = D3DDDIFMT_DXVACOMPBUFFER_BASE+18,   // 168
    D3DDDIFMT_DXVA_RESERVED19         = D3DDDIFMT_DXVACOMPBUFFER_BASE+19,   // 169
    D3DDDIFMT_DXVA_RESERVED20         = D3DDDIFMT_DXVACOMPBUFFER_BASE+20,   // 170
    D3DDDIFMT_DXVA_RESERVED21         = D3DDDIFMT_DXVACOMPBUFFER_BASE+21,   // 171
    D3DDDIFMT_DXVA_RESERVED22         = D3DDDIFMT_DXVACOMPBUFFER_BASE+22,   // 172
    D3DDDIFMT_DXVA_RESERVED23         = D3DDDIFMT_DXVACOMPBUFFER_BASE+23,   // 173
    D3DDDIFMT_DXVA_RESERVED24         = D3DDDIFMT_DXVACOMPBUFFER_BASE+24,   // 174
    D3DDDIFMT_DXVA_RESERVED25         = D3DDDIFMT_DXVACOMPBUFFER_BASE+25,   // 175
    D3DDDIFMT_DXVA_RESERVED26         = D3DDDIFMT_DXVACOMPBUFFER_BASE+26,   // 176
    D3DDDIFMT_DXVA_RESERVED27         = D3DDDIFMT_DXVACOMPBUFFER_BASE+27,   // 177
    D3DDDIFMT_DXVA_RESERVED28         = D3DDDIFMT_DXVACOMPBUFFER_BASE+28,   // 178
    D3DDDIFMT_DXVA_RESERVED29         = D3DDDIFMT_DXVACOMPBUFFER_BASE+29,   // 179
    D3DDDIFMT_DXVA_RESERVED30         = D3DDDIFMT_DXVACOMPBUFFER_BASE+30,   // 180
    D3DDDIFMT_DXVA_RESERVED31         = D3DDDIFMT_DXVACOMPBUFFER_BASE+31,   // 181
    D3DDDIFMT_DXVACOMPBUFFER_MAX      = D3DDDIFMT_DXVA_RESERVED31,

    D3DDDIFMT_BINARYBUFFER            = 199,                                   

    D3DDDIFMT_FORCE_UINT        =0x7fffffff
} D3DDDIFORMAT;

typedef struct _D3DDDIRECT 
{ 
    LONG left; 
    LONG top; 
    LONG right; 
    LONG bottom; 
} D3DDDIRECT; 

typedef struct _D3DDDI_KERNELOVERLAYINFO
{
    D3DKMT_HANDLE        hAllocation;           // in: Allocation to be displayed
    D3DDDIRECT           DstRect;               // in: Dest rect
    D3DDDIRECT           SrcRect;               // in: Source rect
    VOID*                pPrivateDriverData;    // in: Private driver data
    UINT                 PrivateDriverDataSize; // in: Size of private driver data
} D3DDDI_KERNELOVERLAYINFO;

typedef enum _D3DDDI_GAMMARAMP_TYPE
{
    D3DDDI_GAMMARAMP_UNINITIALIZED = 0,
    D3DDDI_GAMMARAMP_DEFAULT       = 1,
    D3DDDI_GAMMARAMP_RGB256x3x16   = 2,
    D3DDDI_GAMMARAMP_DXGI_1        = 3,
} D3DDDI_GAMMARAMP_TYPE;

typedef struct _D3DDDI_GAMMA_RAMP_RGB256x3x16
{
    USHORT  Red[256];
    USHORT  Green[256];
    USHORT  Blue[256];
} D3DDDI_GAMMA_RAMP_RGB256x3x16;

typedef struct D3DDDI_DXGI_RGB
{
    float   Red;
    float   Green;
    float   Blue;
} D3DDDI_DXGI_RGB;

typedef struct _D3DDDI_GAMMA_RAMP_DXGI_1
{
    D3DDDI_DXGI_RGB    Scale;
    D3DDDI_DXGI_RGB    Offset;
    D3DDDI_DXGI_RGB    GammaCurve[1025];
} D3DDDI_GAMMA_RAMP_DXGI_1;


// Used as a value for D3DDDI_VIDEO_PRESENT_SOURCE_ID and D3DDDI_VIDEO_PRESENT_TARGET_ID types to specify
// that the respective video present source/target ID hasn't been initialized.
#define D3DDDI_ID_UNINITIALIZED (UINT)(~0)

// TODO:[mmilirud] Define this as (UINT)(~1) to avoid collision with valid source ID equal to 0.
//
// Used as a value for D3DDDI_VIDEO_PRESENT_SOURCE_ID and D3DDDI_VIDEO_PRESENT_TARGET_ID types to specify
// that the respective video present source/target ID isn't applicable for the given execution context.
#define D3DDDI_ID_NOTAPPLICABLE (UINT)(0)

// Used as a value for D3DDDI_VIDEO_PRESENT_SOURCE_ID and D3DDDI_VIDEO_PRESENT_TARGET_ID types to specify
// that the respective video present source/target ID describes every VidPN source/target in question.
#define D3DDDI_ID_ALL (UINT)(~2)

//
// Hardcoded VidPnSource count
//
#define D3DKMDT_MAX_VIDPN_SOURCES_BITCOUNT      4
#define D3DKMDT_MAX_VIDPN_SOURCES               (1 << D3DKMDT_MAX_VIDPN_SOURCES_BITCOUNT)


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Multi-sampling method descriptor type.
//
// Remarks: Driver is free to partition its quality levels for a given multi-sampling method into as many 
//          increments as it likes, with the condition that each incremental step does noticably improve 
//          quality of the presented image.
//
typedef struct _D3DDDI_MULTISAMPLINGMETHOD
{
    // Number of sub-pixels employed in this multi-sampling method (e.g. 2 for 2x and 8 for 8x multi-sampling)
    UINT  NumSamples;

    // Upper bound on the quality range supported for this multi-sampling method. The range starts from 0
    // and goes upto and including the reported maximum quality setting.
    UINT  NumQualityLevels;
}
D3DDDI_MULTISAMPLINGMETHOD;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video signal scan line ordering descriptor type.
//
// Remarks: Scan-line ordering of the video mode, specifies whether each field contains the entire 
//          content of a frame, or only half of it (i.e. even/odd lines interchangeably). 
//          Note that while for standard interlaced modes, what field comes first can be inferred
//          from the mode, specifying this characteristic explicitly with an enum both frees up the
//          client from having to maintain mode-based look-up tables and is extensible for future
//          standard modes not listed in the D3DKMDT_VIDEO_SIGNAL_STANDARD enum.
//
typedef enum _D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING
{
    D3DDDI_VSSLO_UNINITIALIZED              = 0,
    D3DDDI_VSSLO_PROGRESSIVE                = 1,
    D3DDDI_VSSLO_INTERLACED_UPPERFIELDFIRST = 2,
    D3DDDI_VSSLO_INTERLACED_LOWERFIELDFIRST = 3,
    D3DDDI_VSSLO_OTHER                      = 255
}
D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING;


typedef enum D3DDDI_FLIPINTERVAL_TYPE
{
    D3DDDI_FLIPINTERVAL_IMMEDIATE = 0,
    D3DDDI_FLIPINTERVAL_ONE       = 1,
    D3DDDI_FLIPINTERVAL_TWO       = 2,
    D3DDDI_FLIPINTERVAL_THREE     = 3,
    D3DDDI_FLIPINTERVAL_FOUR      = 4,
} D3DDDI_FLIPINTERVAL_TYPE;


typedef enum _D3DDDI_POOL
{
     D3DDDIPOOL_SYSTEMMEM      = 1,
     D3DDDIPOOL_VIDEOMEMORY    = 2,
     D3DDDIPOOL_LOCALVIDMEM    = 3,
     D3DDDIPOOL_NONLOCALVIDMEM = 4,
} D3DDDI_POOL;


typedef enum _D3DDDIMULTISAMPLE_TYPE
{
    D3DDDIMULTISAMPLE_NONE         =  0,
    D3DDDIMULTISAMPLE_NONMASKABLE  =  1,
    D3DDDIMULTISAMPLE_2_SAMPLES    =  2,
    D3DDDIMULTISAMPLE_3_SAMPLES    =  3,
    D3DDDIMULTISAMPLE_4_SAMPLES    =  4,
    D3DDDIMULTISAMPLE_5_SAMPLES    =  5,
    D3DDDIMULTISAMPLE_6_SAMPLES    =  6,
    D3DDDIMULTISAMPLE_7_SAMPLES    =  7,
    D3DDDIMULTISAMPLE_8_SAMPLES    =  8,
    D3DDDIMULTISAMPLE_9_SAMPLES    =  9,
    D3DDDIMULTISAMPLE_10_SAMPLES   = 10,
    D3DDDIMULTISAMPLE_11_SAMPLES   = 11,
    D3DDDIMULTISAMPLE_12_SAMPLES   = 12,
    D3DDDIMULTISAMPLE_13_SAMPLES   = 13,
    D3DDDIMULTISAMPLE_14_SAMPLES   = 14,
    D3DDDIMULTISAMPLE_15_SAMPLES   = 15,
    D3DDDIMULTISAMPLE_16_SAMPLES   = 16,

    D3DDDIMULTISAMPLE_FORCE_UINT   = 0x7fffffff
} D3DDDIMULTISAMPLE_TYPE;

typedef struct _D3DDDI_RESOURCEFLAGS
{
    union
    {
        struct
        {
            UINT    RenderTarget            : 1;    // 0x00000001
            UINT    ZBuffer                 : 1;    // 0x00000002
            UINT    Dynamic                 : 1;    // 0x00000004
            UINT    HintStatic              : 1;    // 0x00000008
            UINT    AutogenMipmap           : 1;    // 0x00000010
            UINT    DMap                    : 1;    // 0x00000020
            UINT    WriteOnly               : 1;    // 0x00000040
            UINT    NotLockable             : 1;    // 0x00000080
            UINT    Points                  : 1;    // 0x00000100
            UINT    RtPatches               : 1;    // 0x00000200
            UINT    NPatches                : 1;    // 0x00000400
            UINT    SharedResource          : 1;    // 0x00000800
            UINT    DiscardRenderTarget     : 1;    // 0x00001000
            UINT    Video                   : 1;    // 0x00002000
            UINT    CaptureBuffer           : 1;    // 0x00004000
            UINT    Primary                 : 1;    // 0x00008000
            UINT    Texture                 : 1;    // 0x00010000
            UINT    CubeMap                 : 1;    // 0x00020000
            UINT    Volume                  : 1;    // 0x00040000
            UINT    VertexBuffer            : 1;    // 0x00080000
            UINT    IndexBuffer             : 1;    // 0x00100000
            UINT    DecodeRenderTarget      : 1;    // 0x00200000
            UINT    DecodeCompressedBuffer  : 1;    // 0x00400000
            UINT    VideoProcessRenderTarget: 1;    // 0x00800000
            UINT    CpuOptimized            : 1;    // 0x01000000
            UINT    MightDrawFromLocked     : 1;    // 0x02000000
            UINT    Overlay                 : 1;    // 0x04000000
            UINT    MatchGdiPrimary         : 1;    // 0x08000000
            UINT    InterlacedRefresh       : 1;    // 0x10000000
            UINT    TextApi                 : 1;    // 0x20000000
            UINT    Reserved                : 2;    // 0xC0000000
        };
        UINT        Value;
    };
} D3DDDI_RESOURCEFLAGS;

typedef struct _D3DDDI_SURFACEINFO
{
    UINT                Width;              // in: For linear, surface and volume
    UINT                Height;             // in: For surface and volume
    UINT                Depth;              // in: For volume
    CONST VOID*         pSysMem;
    UINT                SysMemPitch;
    UINT                SysMemSlicePitch;
} D3DDDI_SURFACEINFO;

typedef enum _D3DDDI_ROTATION
{
    D3DDDI_ROTATION_IDENTITY        = 1,    // No rotation.           
    D3DDDI_ROTATION_90              = 2,    // Rotated 90 degrees.
    D3DDDI_ROTATION_180             = 3,    // Rotated 180 degrees.
    D3DDDI_ROTATION_270             = 4     // Rotated 270 degrees.
} D3DDDI_ROTATION;

typedef struct _D3DDDIARG_CREATERESOURCE
{
    D3DDDIFORMAT                    Format;
    D3DDDI_POOL                     Pool;
    D3DDDIMULTISAMPLE_TYPE          MultisampleType;
    UINT                            MultisampleQuality;
    CONST D3DDDI_SURFACEINFO*       pSurfList;          // in: List of sub resource objects to create
    UINT                            SurfCount;          // in: Number of sub resource objects
    UINT                            MipLevels;
    UINT                            Fvf;                // in: FVF format for vertex buffers
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;      // in: VidPnSourceId on which the primary surface is created
    D3DDDI_RATIONAL                 RefreshRate;        // in: RefreshRate that this primary surface is to be used with
    HANDLE                          hResource;          // in/out: D3D runtime handle/UM driver handle
    D3DDDI_RESOURCEFLAGS            Flags;
    D3DDDI_ROTATION                 Rotation;           // in: The orientation of the resource. (0, 90, 180, 270)
} D3DDDIARG_CREATERESOURCE;

typedef struct _D3DDDICB_SIGNALFLAGS
{
    union
    {
        struct
        {
            UINT SignalAtSubmission : 1;
            UINT Reserved           : 31;
        };
        UINT Value;
    };
} D3DDDICB_SIGNALFLAGS;

#define D3DDDI_MAX_OBJECT_WAITED_ON 32
#define D3DDDI_MAX_OBJECT_SIGNALED  32

typedef enum _D3DDDI_SYNCHRONIZATIONOBJECT_TYPE
{
    D3DDDI_SYNCHRONIZATION_MUTEX    = 1,
    D3DDDI_SEMAPHORE                = 2
} D3DDDI_SYNCHRONIZATIONOBJECT_TYPE;

typedef struct _D3DDDI_SYNCHRONIZATIONOBJECTINFO
{
    D3DDDI_SYNCHRONIZATIONOBJECT_TYPE    Type;      // in: Type of synchronization object to create.
    union
    {
        struct
        {
            BOOL InitialState;                      // in: Initial state of a synchronization mutex.
        } SynchronizationMutex;

        struct
        {
            UINT MaxCount;                          // in: Max count of the semaphore.
            UINT InitialCount;                      // in: Initial count of the semaphore.
        } Semaphore;

        struct
        {
            UINT Reserved[16];                      // Reserved for future use.
        } Reserved;
    };
} D3DDDI_SYNCHRONIZATIONOBJECTINFO;

//
// Defines the maximum number of context a particular command buffer can 
// be broadcast to.
//
#define D3DDDI_MAX_BROADCAST_CONTEXT        64

//
// Allocation priorities.
//

#define D3DDDI_ALLOCATIONPRIORITY_MINIMUM       0x28000000
#define D3DDDI_ALLOCATIONPRIORITY_LOW           0x50000000
#define D3DDDI_ALLOCATIONPRIORITY_NORMAL        0x78000000
#define D3DDDI_ALLOCATIONPRIORITY_HIGH          0xa0000000
#define D3DDDI_ALLOCATIONPRIORITY_MAXIMUM       0xc8000000

#endif /* _D3DUKMDT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d3dkmdt.h ===
/******************************Module*Header**********************************\
*
* Module Name: d3dkmdt.h
*
* Content: Longhorn Display Driver Model (LDDM) kernel mode
*          data type definitions
*
* Copyright (c) 2004 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef _D3DKMDT_H
#define _D3DKMDT_H

#if !defined(_D3DKMDDI_H_) && \
    !defined(_DXGDMM_H_)   && \
    !defined(_VIDPRIV_H_)  && \
    !defined(_DISPMPRT_H_) && \
    !defined(_DMM_DIAG_H_)
   #error This header should not be included directly!
#endif

#include <d3dukmdt.h>
#include <wmidata.h>

//
// Hardcoded overlay count
//
#define D3DKMDT_MAX_OVERLAYS_BITCOUNT           2
#define D3DKMDT_MAX_OVERLAYS                    (1 << D3DKMDT_MAX_OVERLAYS_BITCOUNT)


//////////////////// VidPN management DDI handles /////////////////////////////////////////////////////////
DECLARE_HANDLE(D3DKMDT_HVIDPN);
DECLARE_HANDLE(D3DKMDT_HVIDEOPRESENTSOURCESET);
DECLARE_HANDLE(D3DKMDT_HVIDEOPRESENTTARGETSET);
DECLARE_HANDLE(D3DKMDT_HVIDPNTOPOLOGY);
DECLARE_HANDLE(D3DKMDT_HVIDPNSOURCEMODESET);
DECLARE_HANDLE(D3DKMDT_HVIDPNTARGETMODESET);
DECLARE_HANDLE(D3DKMDT_HMONITORSOURCEMODESET);
DECLARE_HANDLE(D3DKMDT_HMONITORFREQUENCYRANGESET);
DECLARE_HANDLE(D3DKMDT_HMONITORDESCRIPTORSET);

// Alias VOID* to make LDDM kernel mode interface prototypes using adapter handles self-explanatory.
typedef VOID* D3DKMDT_ADAPTER;



//////////////////// VidPN management DDI constants /////////////////////////////////////////////////////////

// Special values representing that given variable has not been initialized to a valid value intended
// to catch development time errors. A valid parameter should never have this value.
#define D3DKMDT_DIMENSION_UNINITIALIZED  (UINT)(~0)
#define D3DKMDT_FREQUENCY_UNINITIALIZED  (UINT)(~0)

// Special values representing that given parameter is not-specified.
// A parameter having this value should be ignored.
#define D3DKMDT_DIMENSION_NOTSPECIFIED  (UINT)(~1)
#define D3DKMDT_FREQUENCY_NOTSPECIFIED  (UINT)(~1)



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video mode standard descriptor type, listing standards that are explicitly supported by Windows.
//
// Remarks: This enum specifies based on which standard the video signal timing parameters should be computed.
//          Note that NTSC, PAL, and SECAM mode variants are treated as individual groups to avoid complicating
//          the DDI with the notion of "sub-standard" (because they don't differ from each other in the parameters
//          used to describe the video signal in the DDI and the parameters that they do differ in are of no
//          interest to us in DMM).
//
typedef enum _D3DKMDT_VIDEO_SIGNAL_STANDARD
{
    D3DKMDT_VSS_UNINITIALIZED =  0,

    // VESA standards
    D3DKMDT_VSS_VESA_DMT      =  1,    // See VESA Display Monitor Timings specification
    D3DKMDT_VSS_VESA_GTF      =  2,    // See VESA Generalized Timing Formula standard
    D3DKMDT_VSS_VESA_CVT      =  3,    // See VESA Coordinated Video Timings standard

    // De-facto standards
    D3DKMDT_VSS_IBM           =  4,
    D3DKMDT_VSS_APPLE         =  5,

    // Legacy STV standards                 W  x H{i|p} @ (  VR        /      HR       )
    D3DKMDT_VSS_NTSC_M        =  6,    //  720 x 525i   @ (59.94  [Hz] /  15,734.27[Hz])
    D3DKMDT_VSS_NTSC_J        =  7,    //  720 x 525i   @ (59.94  [Hz] /  15,734.27[Hz])
    D3DKMDT_VSS_NTSC_443      =  8,    //  720 x 525i   @ (59.94  [Hz] /  15,734.27[Hz])
    D3DKMDT_VSS_PAL_B         =  9,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_B1        = 10,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_G         = 11,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_H         = 12,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_I         = 13,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_D         = 14,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_N         = 15,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_NC        = 16,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_B       = 17,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_D       = 18,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_G       = 19,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_H       = 20,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_K       = 21,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_K1      = 22,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_L       = 23,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_SECAM_L1      = 24,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])

    // CEA/EIA standards
    D3DKMDT_VSS_EIA_861       = 25,
    D3DKMDT_VSS_EIA_861A      = 26,
    D3DKMDT_VSS_EIA_861B      = 27,

    // More legacy STV standards
    D3DKMDT_VSS_PAL_K         = 28,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_K1        = 29,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_L         = 30,    //  720 x 625i   @ (50     [Hz] /  15,625   [Hz])
    D3DKMDT_VSS_PAL_M         = 31,    //  720 x 525i   @ (59.94  [Hz] /  15,734   [Hz])

    D3DKMDT_VSS_OTHER         = 255
}
D3DKMDT_VIDEO_SIGNAL_STANDARD;



//////////////////// Video present sources //////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present source descriptor type.
//
typedef struct _D3DKMDT_VIDEO_PRESENT_SOURCE
{
    // Unique ID used to reference the respective video present source by the miniport and the OS.
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  Id;

    // Other video present source descriptor properties go here.
    DWORD  dwReserved;
}
D3DKMDT_VIDEO_PRESENT_SOURCE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN source mode enumeration type descriptor type.
//
// Remarks: This type is used to specify whether a VidPN source mode is a graphics or a text mode
//          (see VIDEO_PRESENT_SOURCE_MODE for more details).
//
typedef enum _D3DKMDT_VIDPN_SOURCE_MODE_TYPE
{
    D3DKMDT_RMT_UNINITIALIZED = 0,
    D3DKMDT_RMT_GRAPHICS      = 1,
    D3DKMDT_RMT_TEXT          = 2
}
D3DKMDT_VIDPN_SOURCE_MODE_TYPE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Pixel value access mode descriptor type.
//
// Remarks: Use Direct to represent VidPN source modes with colors stored directly in the primary surface.
//          Use PresetPalette to represent VidPN source modes with colors' indices stored in the primary
//          surface and actual color values stored in a palette specific to the video card, that must
//          be queried from the video miniport.
//          Use SettablePalette to represent VidPN source modes with colors' indices stored in the primary
//          surface and actual color values stored in a settable palette that can be dynamically set on
//          the video card, by specifying it to the video miniport.
//
typedef enum _D3DKMDT_PIXEL_VALUE_ACCESS_MODE
{
    D3DKMDT_PVAM_UNINITIALIZED   = 0,
    D3DKMDT_PVAM_DIRECT          = 1,
    D3DKMDT_PVAM_PRESETPALETTE   = 2,
    D3DKMDT_PVAM_SETTABLEPALETTE = 3,
}
D3DKMDT_PIXEL_VALUE_ACCESS_MODE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Descriptor type of the color basis with respect to which the pixels' colors are expanded,
//          or conversely, based on which the color values are synthesized.
//
// Remarks: The commonly used color bases in graphics industry are RGB, which has the basis (red, green, blue),
//          as well as YPbPr and YCbCr, which have scaled variants of basis:
//          (1, blue-1, red-1)*intensity(red,green,blue).
//          Tri-stimulus linear RGB is well suited for real-time rendering, since most filtering algorithms
//          use tri-stimulus values to approximate light's spectral transformations caused by its interaction
//          with the environment, primarily due to the fact that there is a linear relationship between the
//          perceived light level and the light's spectral intensity. Ideally, all processing of video content
//          (i.e. scaling, filtering, etc) should be performed in a linear RGB space.
//          Y'PbPr spaces store data using a nonlinear curve which is approximately the inverse of a gamma
//          2.2 curve (i.e. x^0.45).  This allows more precision to be stored in darker intensities where the
//          human eye is more sensitive.
//          sRGB (more accurately, sR'G'B') stores light intensities relative to a gamma curve.
//          scRGB stores linear values and requires much higher precision to represent the same perceptually
//          similar signal.
//          The light-intensity based YPbPr and YCbCr is better suited for persistence of pre-rendered content,
//          such as video streaming. This is due to the fact that a human visual system is more responsive to
//          small differences in photons' intensity rather than frequency (i.e. perceived color), and, hence,
//          a light-intensity based color expansion over a finite dynamic range, yields a better perceptual
//          image quality for the human eye than a tri-stimulus based color expansion in that same range
//          (e.g  non-linear Y8Cb8Cr8 appears slightly better than R8G8B8 and is comparable to R9G9B9).
//          To represent monochrome modes, use Intensity. Grayscale imaging is heavily used in medical imaging.
//          Note: the apostrophe notation Y'PbPr is used to remind you that you are working with non-linear data.
//
typedef enum _D3DKMDT_COLOR_BASIS
{
    D3DKMDT_CB_UNINITIALIZED = 0,
    D3DKMDT_CB_INTENSITY     = 1,
    D3DKMDT_CB_SRGB          = 2,
    D3DKMDT_CB_SCRGB         = 3,
    D3DKMDT_CB_YCBCR         = 4,
    D3DKMDT_CB_YPBPR         = 5,
}
D3DKMDT_COLOR_BASIS;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Descriptor type of the color coefficients dynamic range, whose linear combination with the
//          respective color basis produces final pixel values.
//
// Remarks: Examples include (5,6,5,0) for R5G6B5, (8,8,8,8) for R8G8B8A8, and (24, 0, 0, 0) for 24-bit
//          grayscale pixel encoding format.
//          NOTE: Currently this is only used for target modes, none of which has the 4th channel (e.g. alpha).
//                We are keeping the 4th field for extensibility purpose to avoid miniport interface revision
//                if 4-channel video interfaces became available between display adapter and monitor.
//
typedef struct _D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES
{
    UINT  FirstChannel;
    UINT  SecondChannel;
    UINT  ThirdChannel;
    UINT  FourthChannel;
}
D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: 2D region descriptor type.
//
// Remarks: We define our own rather than reusing SIZE type to avoid dependency on SDK headers.
//
typedef struct _D3DKMDT_2DREGION
{
    UINT cx;
    UINT cy;
}
D3DKMDT_2DREGION;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: 2D offset descriptor type.
//
// Remarks: We define our own rather than reusing SIZE type to avoid dependency on SDK headers.
//
typedef D3DKMDT_2DREGION  D3DKMDT_2DOFFSET;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Graphics video present source mode descriptor type.
//
// Remarks: Graphics video present source mode is the dominantly used subtype of the video present source
//          modes (other being the text video present source mode).
//          Note that whenever video present source mode's visible size,
//          VIDEO_PRESENT_SOURCE_MODE.GRAPHICS_RENDERING_FORMAT.sizeVisible is not equal to the respective
//          video mode's visible size, VIDEO_PRESENT_TARGET_MODE.sizeVisible, h/w scaling is undertaken by
//          the video output codec.
//
//          Miniport is free to support any D3D pixel format for its graphics modes that is meaningful
//          as a primary surface pixel format. No validation for an appropriately used pixel format shall be
//          done in kernel-mode. If this turns out to be a problem, WHQL can enforce a certain list of pixel
//          formats from user-mode.
//
//          This descriptor does NOT include pixel value sub-channel bit masks since:
//            1. Primary goal of such descriptors is to allow application developers to write extensible code
//               that can leverage future pixel formats.
//            2. As it stands, however, historically numerous application developers have failed to properly
//               implement generic pixel value decoding algorithms and pixel value sub-channel bit masks were
//               dropped in DX8.
//            3. Main idea: it's best to force application developers to test every scenario they claim to
//               support by making them use look-up tables that map D3D pixel format enums into pixel value
//               sub-channel bit masks.
//            4. To facilitate application development, it would make sense to ship a helper user-mode library
//               that does the enum-to-bitmask mapping for the application developers. They would still need
//               to code their application against existing pixel value formats but not maintain look-up tables,
//               for every application.
//            5. Need for pixel value sub-channel bitmasks exposure is further reduced by the fact that they are
//               only truly useful for linear surface formats with well defined integer RGB encoded pixel values.
//                   i. When surface format has a non-linear pixel layout
//                      (i.e. VIDEO_PRESENT_SOURCE.VidPSContentLayout = VPSCL_Linear),
//                      knowledge of pixel value sub-channel bitmasks will not help the developer to know how to
//                      access each pixel in the surface.
//                  ii. Most four-CC formats (e.g. NVT4/NVT5) fall into this category and one should test against
//                      every format to be supported by the application, because most of them imply texture layouts
//                      that aren't easily described.
//                 iii. Also the bitmasks won't work for floating point pixel formats.
//
typedef struct _D3DKMDT_GRAPHICS_RENDERING_FORMAT
{
    // Size of the primary surface required for this VidPN source mode.
    D3DKMDT_2DREGION  PrimSurfSize;

    // Size of the visible part of the primary surface, used for panned modes including zoom modes.
    D3DKMDT_2DREGION  VisibleRegionSize;

    // Number of bytes between the start of one scan line and the next.
    DWORD  Stride;

    // Pixel format type
    D3DDDIFORMAT  PixelFormat;

    // Color basis with respect to which rendering client encodes pixel values.
    D3DKMDT_COLOR_BASIS  ColorBasis;

    // Access mode for the pixel value information.
    D3DKMDT_PIXEL_VALUE_ACCESS_MODE  PixelValueAccessMode;
}
D3DKMDT_GRAPHICS_RENDERING_FORMAT;


typedef enum _D3DKMDT_TEXT_RENDERING_FORMAT
{
    D3DKMDT_TRF_UNINITIALIZED = 0
}
D3DKMDT_TEXT_RENDERING_FORMAT;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present source mode ID type.
typedef UINT  D3DKMDT_VIDEO_PRESENT_SOURCE_MODE_ID;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN source mode descriptor type.
//
// Remarks: VidPN source (rendering) mode is the mode of operation of a given video present source and determines
//          the format of this source's primary surface to which the graphics subsystem is rendering
//          the visual image to be presented to the user, and from which the video output codec is reading
//          the visual image content to be converted into a respective video mode signal.
//
typedef struct _D3DKMDT_VIDPN_SOURCE_MODE
{
    D3DKMDT_VIDEO_PRESENT_SOURCE_MODE_ID  Id;

    // Specifies whether the mode is a graphics or a text rendering mode.
    D3DKMDT_VIDPN_SOURCE_MODE_TYPE  Type;

    union
    {
        // Descriptor of the graphics rendering mode (valid only if Type==D3DKMDT_RMT_GRAPHICS).
        D3DKMDT_GRAPHICS_RENDERING_FORMAT  Graphics;

        // Descriptor of the text rendering mode (valid only if Type==D3DKMDT_RMT_TEXT).
        D3DKMDT_TEXT_RENDERING_FORMAT  Text;
    }
    Format;
}
D3DKMDT_VIDPN_SOURCE_MODE;



//////////////////////// Video present targets///////////////////////////////////////////////////////////////


// NOTE: Child device (e.g. video output) HPD awareness is used to represent the level of external
//       device (e.g. monitor) connectivity sensed by a display adapter. Child device can either be
//       always connected to an external device (e.g. integrated LCD in a mobile system) or have:
//         1. No HPD-awareness iff miniport is *not* aware of external device arrivals/departures
//            whether through interrupts or polling,
//         2. Polled HPD-awareness iff miniport can not asynchronously notify the OS about external
//            device arrivals/departures, but OS can sporadically poll for its presence, and of a
//            monitor, causing visual artifacts on each poll.
//         3. Interruptible HPD-awareness iff miniport can asynchronously notify the OS about
//            external device arrivals/departures.
typedef enum _DXGK_CHILD_DEVICE_HPD_AWARENESS {
    HpdAwarenessUninitialized   = 0,
    HpdAwarenessAlwaysConnected = 1,
    HpdAwarenessNone            = 2,
    HpdAwarenessPolled          = 3,
    HpdAwarenessInterruptible   = 4
} DXGK_CHILD_DEVICE_HPD_AWARENESS, *PDXGK_CHILD_DEVICE_HPD_AWARENESS;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Monitor orientation descriptor type.
//
typedef enum _D3DKMDT_MONITOR_ORIENTATION
{
    D3DKMDT_MO_UNINITIALIZED = 0,
    D3DKMDT_MO_0DEG          = 1,
    D3DKMDT_MO_90DEG         = 2,
    D3DKMDT_MO_180DEG        = 3,
    D3DKMDT_MO_270DEG        = 4
}
D3DKMDT_MONITOR_ORIENTATION;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video output technology descriptor type.
//
// Remarks: Video output technology is used to determine the hard-coded list of video modes supported
//          by the monitor, when monitor descriptor is not available.
//
typedef enum _D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY
{
    D3DKMDT_VOT_UNINITIALIZED        = -2,
    D3DKMDT_VOT_OTHER                = -1,
    D3DKMDT_VOT_HD15                 =  0,
    D3DKMDT_VOT_SVIDEO               =  1,
    D3DKMDT_VOT_COMPOSITE_VIDEO      =  2,
    D3DKMDT_VOT_COMPONENT_VIDEO      =  3,
    D3DKMDT_VOT_DVI                  =  4,
    D3DKMDT_VOT_HDMI                 =  5,
    D3DKMDT_VOT_LVDS                 =  6,
    D3DKMDT_VOT_D_JPN                =  8,
    D3DKMDT_VOT_SDI                  =  9,
    D3DKMDT_VOT_DISPLAYPORT_EXTERNAL = 10,
    D3DKMDT_VOT_DISPLAYPORT_EMBEDDED = 11,
    D3DKMDT_VOT_UDI_EXTERNAL         = 12,
    D3DKMDT_VOT_UDI_EMBEDDED         = 13,
    D3DKMDT_VOT_SDTVDONGLE           = 14,
    D3DKMDT_VOT_INTERNAL             = 0x80000000,

    // Remove when DDI is unlocked.
    D3DKMDT_VOT_SVIDEO_4PIN          = D3DKMDT_VOT_SVIDEO,
    D3DKMDT_VOT_SVIDEO_7PIN          = D3DKMDT_VOT_SVIDEO,
    D3DKMDT_VOT_RF                   = D3DKMDT_VOT_COMPOSITE_VIDEO,
    D3DKMDT_VOT_RCA_3COMPONENT       = D3DKMDT_VOT_COMPONENT_VIDEO,
    D3DKMDT_VOT_BNC                  = D3DKMDT_VOT_COMPONENT_VIDEO,
}
D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Monitor orientation awareness descriptor type.
//
typedef enum _D3DKMDT_MONITOR_ORIENTATION_AWARENESS
{
    D3DKMDT_MOA_UNINITIALIZED = 0,
    D3DKMDT_MOA_NONE          = 1,
    D3DKMDT_MOA_POLLED        = 2,
    D3DKMDT_MOA_INTERRUPTIBLE = 3
}
D3DKMDT_MONITOR_ORIENTATION_AWARENESS;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target descriptor type.
//
typedef struct _D3DKMDT_VIDEO_PRESENT_TARGET
{
    // Unique ID used to reference the respective video present target by the miniport and the OS.
    D3DDDI_VIDEO_PRESENT_TARGET_ID  Id;

    // Type of the video output technology (see D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY for more details).
    D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY  VideoOutputTechnology;

    // Type of the video output's HPD awareness (see D3DKMDT_VIDEO_OUTPUT_HPD_AWARENESS for more details).
    DXGK_CHILD_DEVICE_HPD_AWARENESS  VideoOutputHpdAwareness;

    D3DKMDT_MONITOR_ORIENTATION_AWARENESS  MonitorOrientationAwareness;

    // NOTE: On monitor arrival, OS will leave monitor mode set empty for monitors connected to video outputs
    //       supporting SDTV modes, expecting miniport to populate modes it wants to expose for that monitor.
    //
    // NOTE: This predicate is also used when selecting video output for presentation on a TV via
    //       APIs that don't support explicit specification of monitors/video outputs (e.g. VIDEOPARAMETERS).
    //
    // Predicate specifying whether corresponding video output supports SDTV modes.
    BOOLEAN  SupportsSdtvModes;
}
D3DKMDT_VIDEO_PRESENT_TARGET;



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target mode GTF compliance descriptor type.
typedef enum _D3DKMDT_GTFCOMPLIANCE
{
    D3DKMDT_GTF_UNINITIALIZED = 0,
    D3DKMDT_GTF_COMPLIANT     = 1,
    D3DKMDT_GTF_NOTCOMPLIANT  = 2
}
D3DKMDT_GTFCOMPLIANCE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN target mode preference descriptor type.
typedef enum _D3DKMDT_MODE_PREFERENCE
{
    D3DKMDT_MP_UNINITIALIZED = 0,
    D3DKMDT_MP_PREFERRED     = 1,
    D3DKMDT_MP_NOTPREFERRED  = 2,
}
D3DKMDT_MODE_PREFERENCE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video signal info descriptor type.
//
// Remarks: Video signal info is the mode of operation of a given video output that's driving a connected
//          moitor and is driven by an internal video output codec.
//          Note that this descriptor supersedes subset of the XDDM's VIDEO_MODE_INFORMATION structure
//          related to video mode. In XDDM, both video and rendering modes were described in this struct.
//          LDDM separates these two notions, and hence their descriptors.
//          The video standard field, vidStandard, should be used for video mode comparisons, when it's
//          set to a well-defined video standard. Note that most of the standard modes do not comply with
//          the VESA GTF frequency constraints.
//
//          If color basis of the target mode does not correspond to that of the source mode, appropriate
//          color conversion is performed by the respective video output codec.
//
typedef struct _D3DKMDT_VIDEO_SIGNAL_INFO
{
    // Video mode standard this mode is defined by (if any).
    D3DKMDT_VIDEO_SIGNAL_STANDARD  VideoStandard;

    // Video signal's size in pixels (i.e. HTotal & VTotal).
    D3DKMDT_2DREGION  TotalSize;

    // Presented image's size in active pixels (i.e. HActive & VActive).
    D3DKMDT_2DREGION  ActiveSize;

    // Vertical refresh frequency (in Hz).
    D3DDDI_RATIONAL  VSyncFreq;

    // Horizontal refresh frequency (in Hz).
    D3DDDI_RATIONAL  HSyncFreq;

    // Pixel clock rate (in Hz).
    SIZE_T  PixelRate;

    // Scan line ordering (e.g. progressive, interlaced).
    D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING  ScanLineOrdering;
}
D3DKMDT_VIDEO_SIGNAL_INFO;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target mode ID type.
typedef UINT  D3DKMDT_VIDEO_PRESENT_TARGET_MODE_ID;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target mode descriptor type.
typedef struct _D3DKMDT_VIDPN_TARGET_MODE
{
    // Identifier unique within the set this mode is part of.
    D3DKMDT_VIDEO_PRESENT_TARGET_MODE_ID  Id;

    // Video signal parameters.
    D3DKMDT_VIDEO_SIGNAL_INFO  VideoSignalInfo;

    // Predicate specifying whether this mode is preferred by the adapter given the mode pinned on
    // the source of the respective present path.
    D3DKMDT_MODE_PREFERENCE  Preference;
}
D3DKMDT_VIDPN_TARGET_MODE;



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target mode ID type.
typedef UINT  D3DKMDT_MONITOR_SOURCE_MODE_ID;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Monitor capability origin type.
typedef enum _D3DKMDT_MONITOR_CAPABILITIES_ORIGIN
{
    D3DKMDT_MCO_UNINITIALIZED                      = 0, // mode information is coming from the:
    D3DKMDT_MCO_DEFAULTMONITORPROFILE              = 1, //  + default monitor profile.
    D3DKMDT_MCO_MONITORDESCRIPTOR                  = 2, //  + monitor's descriptor.
    D3DKMDT_MCO_MONITORDESCRIPTOR_REGISTRYOVERRIDE = 3, //  + registry override of the monitor descriptor.
    D3DKMDT_MCO_SPECIFICCAP_REGISTRYOVERRIDE       = 4, //  + registry override of a specific capability.
    D3DKMDT_MCO_DRIVER                             = 5, //  + display adapter driver.
}
D3DKMDT_MONITOR_CAPABILITIES_ORIGIN;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Monitor timing type.
typedef enum _D3DKMDT_MONITOR_TIMING_TYPE
{
    D3DKMDT_MTT_UNINITIALIZED         = 0, // mode timing information is coming from:
    D3DKMDT_MTT_ESTABLISHED           = 1, //  + established timings block.
    D3DKMDT_MTT_STANDARD              = 2, //  + standard timings block.
    D3DKMDT_MTT_EXTRASTANDARD         = 3, //  + extra standard timings block.
    D3DKMDT_MTT_DETAILED              = 4, //  + detailed timings block.
    D3DKMDT_MTT_DEFAULTMONITORPROFILE = 5, //  + default monitor profile.
    D3DKMDT_MTT_DRIVER                = 6, //  + display adapter driver.
}
D3DKMDT_MONITOR_TIMING_TYPE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target mode descriptor type.
typedef struct _D3DKMDT_MONITOR_SOURCE_MODE
{
    // Identifier unique within the set this mode is part of.
    D3DKMDT_MONITOR_SOURCE_MODE_ID  Id;

    // Video signal parameters.
    D3DKMDT_VIDEO_SIGNAL_INFO  VideoSignalInfo;

    // Color basis with respect to which monitor is presenting the pixels sampled from the video signal.
    D3DKMDT_COLOR_BASIS  ColorBasis;

    // Supported dynamic range of each of the pixel color bases' coefficients by the monitor's
    // presentational technology - e.g. for a DFP LCD with 12-bit bit-depth, this might be (4, 4, 4, 0).
    D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES  ColorCoeffDynamicRanges;

    // Origins of the monitor source mode information.
    D3DKMDT_MONITOR_CAPABILITIES_ORIGIN  Origin;

    // Predicate specifying whether this mode is preferred by the monitor connected to the respective video output.
    D3DKMDT_MODE_PREFERENCE  Preference;
}
D3DKMDT_MONITOR_SOURCE_MODE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Frequency range type.
typedef struct _D3DKMDT_FREQUENCY_RANGE
{
    // Minimum vertical refresh frequency (in Hz) supported by the monitor.
    D3DDDI_RATIONAL  MinVSyncFreq;

    // Maximum vertical refresh frequency (in Hz) supported by the monitor.
    D3DDDI_RATIONAL  MaxVSyncFreq;

    // Minimum horizontal refresh frequency (in Hz) supported by the monitor.
    D3DDDI_RATIONAL  MinHSyncFreq;

    // Maximum horizontal refresh frequency (in Hz) supported by the monitor.
    D3DDDI_RATIONAL  MaxHSyncFreq;
}
D3DKMDT_FREQUENCY_RANGE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Monitor frequency range constraint type.
typedef enum _D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT
{
    D3DKMDT_MFRC_UNINITIALIZED = 0,
    D3DKMDT_MFRC_ACTIVESIZE    = 1,
    D3DKMDT_MFRC_MAXPIXELRATE  = 2
}
D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Monitor frequency range type.
typedef struct _D3DKMDT_MONITOR_FREQUENCY_RANGE
{
    // Origins of the monitor frequency range information.
    D3DKMDT_MONITOR_CAPABILITIES_ORIGIN  Origin;

    // Frequency range limits.
    D3DKMDT_FREQUENCY_RANGE  RangeLimits;

    // Type of the frequency range constraint.
    D3DKMDT_MONITOR_FREQUENCY_RANGE_CONSTRAINT  ConstraintType;

    // Constraint under which this frequency range is supported.
    union
    {
        // Active region size this frequency range applies to.
        D3DKMDT_2DREGION  ActiveSize;

        // Maximum pixel clock rate (in Hz) to which this pixel rate applies.
        SIZE_T  MaxPixelRate;

    } Constraint;
}
D3DKMDT_MONITOR_FREQUENCY_RANGE;




/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// VidPN present paths

// VidPN present path index used during enumeration of paths satisfying certain criteria
// (e.g. originating from the same source).
typedef SIZE_T  D3DKMDT_VIDPN_PRESENT_PATH_INDEX;

// Purpose: VidPN present path scaling type.
typedef enum _D3DKMDT_VIDPN_PRESENT_PATH_SCALING
{
    D3DKMDT_VPPS_UNINITIALIZED = 0,

    // For the following transformation, spatial resolutions must be equal on both the source and the target.

    // Source content is not modified in any way.
    D3DKMDT_VPPS_IDENTITY      = 1,

    // For the following three transformations, spatial resolution of the source differs from that of the target.

    // Source content is centered on the target.
    D3DKMDT_VPPS_CENTERED      = 2,

    // Source content is scaled to fit the target. Aspect ratio preservation is up to the miniport.
    D3DKMDT_VPPS_STRETCHED     = 3,

    // Source content scaling mode is not pinned.
    D3DKMDT_VPPS_UNPINNED      = 254,

    // OS does not specify the scaling mode, and miniport should decide based on its own settings.
    D3DKMDT_VPPS_NOTSPECIFIED  = 255
}
D3DKMDT_VIDPN_PRESENT_PATH_SCALING;


// Purpose: VidPN present path rotation type.
typedef enum _D3DKMDT_VIDPN_PRESENT_PATH_ROTATION
{
    D3DKMDT_VPPR_UNINITIALIZED = 0,

    // Source content is not modified in any way.
    D3DKMDT_VPPR_IDENTITY      = 1,

    // Source content is rotated 90 degrees.
    D3DKMDT_VPPR_ROTATE90      = 2,

    // Source content is rotated 180 degrees.
    D3DKMDT_VPPR_ROTATE180     = 3,

    // Source content is rotated 270 degrees.
    D3DKMDT_VPPR_ROTATE270     = 4,

    // Source content rotation setting is not pinned.
    D3DKMDT_VPPR_UNPINNED      = 254,

    // OS does not specify the rotation mode, and miniport should decide based on its own settings.
    D3DKMDT_VPPR_NOTSPECIFIED  = 255
}
D3DKMDT_VIDPN_PRESENT_PATH_ROTATION;

#define D3DKMDT_SCALING_SUPPORT_MASK 0x7;

// Purpose: Specifies what scaling modes are supported given current path configuration.
typedef struct _D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT
{
    UINT Identity       : 1;
    UINT Centered       : 1;
    UINT Stretched      : 1;
} D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT;

#define D3DKMDT_ROTATION_SUPPORT_MASK 0xf;

// Purpose: Specifies what rotation modes are supported given current path configuration.
typedef struct _D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT
{
    UINT Identity   : 1;
    UINT Rotate90   : 1;
    UINT Rotate180  : 1;
    UINT Rotate270  : 1;
} D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT;

// Purpose: Combines all the transformation related fields into one structure.
typedef struct _D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION
{
    // Scaling applied to the content presented on this video present path.
    D3DKMDT_VIDPN_PRESENT_PATH_SCALING  Scaling;

    // Scaling support given the currently pinned modes.
    D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT ScalingSupport;

    // Rotation applied to the content presented on this video present path.
    D3DKMDT_VIDPN_PRESENT_PATH_ROTATION Rotation;

    // Rotation support given the currently pinned modes.
    D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT RotationSupport;
} D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN present path importance ordinal type.
//
// Note: Higher order importance ordinals can be used (upto 255), but only the first 10 have been explicitly named.
//
typedef enum _D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE
{
    D3DKMDT_VPPI_UNINITIALIZED = 0,
    D3DKMDT_VPPI_PRIMARY       = 1,
    D3DKMDT_VPPI_SECONDARY     = 2,
    D3DKMDT_VPPI_TERTIARY      = 3,
    D3DKMDT_VPPI_QUATERNARY    = 4,
    D3DKMDT_VPPI_QUINARY       = 5,
    D3DKMDT_VPPI_SENARY        = 6,
    D3DKMDT_VPPI_SEPTENARY     = 7,
    D3DKMDT_VPPI_OCTONARY      = 8,
    D3DKMDT_VPPI_NONARY        = 9,
    D3DKMDT_VPPI_DENARY        = 10,
}
D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN present path content ordinal type.
//
// Indicates whether the content being displayed is video or graphics.
//
typedef enum _D3DKMDT_VIDPN_PRESENT_PATH_CONTENT
{
    D3DKMDT_VPPC_UNINITIALIZED = 0,

    // Miniport should optimize presentation of the present path for graphics content.
    D3DKMDT_VPPC_GRAPHICS      = 1,

    // Miniport should optimize presentation of the present path for video content.
    D3DKMDT_VPPC_VIDEO         = 2,

    // OS does not specify the content type, and miniport should decide based on its own settings.
    D3DKMDT_VPPC_NOTSPECIFIED  = 255
}
D3DKMDT_VIDPN_PRESENT_PATH_CONTENT;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN present path macrovision information.
//
// Contains macrovision caps and controls.
//
typedef enum _D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE
{
    D3DKMDT_VPPMT_UNINITIALIZED             = 0,

    D3DKMDT_VPPMT_NOPROTECTION              = 1,

    D3DKMDT_VPPMT_MACROVISION_APSTRIGGER    = 2,

    D3DKMDT_VPPMT_MACROVISION_FULLSUPPORT   = 3,

}
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE;

typedef struct _D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT
{
    UINT NoProtection          : 1;
    UINT MacroVisionApsTrigger : 1;
    UINT MacroVisionFull       : 1;
    UINT Reserved              : 29;
}
D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT;

#define D3DKMDT_MACROVISION_OEMCOPYPROTECTION_SIZE  256

typedef struct _D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION
{
    // Macrovision controls.
    D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_TYPE CopyProtectionType;
    UINT                                           APSTriggerBits;
    BYTE                                           OEMCopyProtection[D3DKMDT_MACROVISION_OEMCOPYPROTECTION_SIZE];

    // Level of available copy protection support.
    D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION_SUPPORT CopyProtectionSupport;
} D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: VidPN present path gamma ramp descriptor type.
//
typedef struct _D3DKMDT_GAMMA_RAMP
{
    D3DDDI_GAMMARAMP_TYPE    Type;
    SIZE_T                   DataSize;

    // If (Type == D3DDDI_GAMMARAMP_DEFAULT), (DataSize == 0) and (Data.pFormatOther == NULL )
    union
    {
        D3DDDI_GAMMA_RAMP_RGB256x3x16* pRgb256x3x16;  // Type == D3DDDI_GAMMARAMP_RGB256x3x16.
        D3DDDI_GAMMA_RAMP_DXGI_1*      pDxgi1;        // Type == D3DDDI_GAMMARAMP_DXGI_1.
        VOID*                          pRaw;
    }
    Data;
}
D3DKMDT_GAMMA_RAMP;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Video present target to source mapping.
//
// Remarks: This type is used to describe a mapping from a single video present target to a single
//          video present source in a VidPN topology.
//
typedef struct _D3DKMDT_VIDPN_PRESENT_PATH
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;

    D3DDDI_VIDEO_PRESENT_TARGET_ID  VidPnTargetId;

    // Video present path importance ordinal (e.g. path presenting the primary view may have higher
    // importance set on it in order to guarantee that it gets the best source/target mode sets).
    D3DKMDT_VIDPN_PRESENT_PATH_IMPORTANCE  ImportanceOrdinal;

    // Contains all the transformation related fields.
    D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION ContentTransformation;

    // Storing deltas for visible/active pixels mapping rather than visible pixels'
    // size & offset has the added benefit of ideal/default state being zeros.

    // Monitor screen's offset of visible pixels' top-left corner from
    // video signal's active pixels top-left corner.
    // Note: Default = (0,0).
    D3DKMDT_2DOFFSET  VisibleFromActiveTLOffset;

    // Monitor screen's offset of visible pixels' bottom-right corner from
    // video signal's active pixels bottom-right corner.
    // Note: Default = (0,0).
    D3DKMDT_2DOFFSET  VisibleFromActiveBROffset;

    // Video signal color basis with respect to which video output codec encodes the pixels from the respective
    // source's primary surface (e.g. on HDMI this can be either RGB or YCbCr).
    D3DKMDT_COLOR_BASIS  VidPnTargetColorBasis;

    // Supported dynamic range of each of the color bases' coefficients by the video output codec's output
    // E.g. With a DAC scaning out A2R10G10B10 primary surface at R8G8B8 color resolution, this would be (8,8,8,0),
    D3DKMDT_COLOR_COEFF_DYNAMIC_RANGES  VidPnTargetColorCoeffDynamicRanges;

    // Indicates the content being diplayed.  The driver can use this to determine whether the flicker filter
    // and overscan should be enabled or disabled.
    D3DKMDT_VIDPN_PRESENT_PATH_CONTENT Content;

    // Contains all the copy protection related fields.
    D3DKMDT_VIDPN_PRESENT_PATH_COPYPROTECTION CopyProtection;

    // A lookup table (LUT) used to compensate intensity of presented content for the color response of the monitor
    // connected to present path's target.
    D3DKMDT_GAMMA_RAMP  GammaRamp;
}
D3DKMDT_VIDPN_PRESENT_PATH;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Specifies whether to ignore monitor connectivity checks or enforce them.
//
typedef enum _D3DKMDT_MONITOR_CONNECTIVITY_CHECKS
{
    D3DKMDT_MCC_UNINITIALIZED = 0,
    D3DKMDT_MCC_IGNORE        = 1,
    D3DKMDT_MCC_ENFORCE       = 2
}
D3DKMDT_MONITOR_CONNECTIVITY_CHECKS;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose: Type of the owner whose mode set does not change during an enumeration.
//
// Remarks: When OS pins/unpins a mode in one of VidPN's mode sets, the only mode set that is guaranteed to
//          stay the same is the mode set whose mode was pinned/unpinned. Enumeration pivot lets the OS
//          specify to the miniport which mode set it should not update (because this mode set could not have
//          been invalidated as a result of the change the OS made to the VidPN.
//
typedef enum _D3DKMDT_ENUMCOFUNCMODALITY_PIVOT_TYPE
{
    D3DKMDT_EPT_UNINITIALIZED,
    D3DKMDT_EPT_VIDPNSOURCE,
    D3DKMDT_EPT_VIDPNTARGET,
    D3DKMDT_EPT_SCALING,
    D3DKMDT_EPT_ROTATION,
    D3DKMDT_EPT_NOPIVOT
}
D3DKMDT_ENUMCOFUNCMODALITY_PIVOT_TYPE;

//
// Monitor descriptor related types.
//

typedef UINT  D3DKMDT_MONITOR_DESCRIPTOR_ID;

typedef enum _D3DKMDT_MONITOR_DESCRIPTOR_TYPE
{
    D3DKMDT_MDT_UNINITIALIZED          = 0,
    D3DKMDT_MDT_VESA_EDID_V1_BASEBLOCK = 1,
    D3DKMDT_MDT_VESA_EDID_V1_BLOCKMAP  = 2,
    D3DKMDT_MDT_OTHER                  = 255
}
D3DKMDT_MONITOR_DESCRIPTOR_TYPE;

typedef struct _D3DKMDT_MONITOR_DESCRIPTOR
{
    D3DKMDT_MONITOR_DESCRIPTOR_ID        Id;
    D3DKMDT_MONITOR_DESCRIPTOR_TYPE      Type;
    SIZE_T                               DataSize;
    VOID*                                pData;
    D3DKMDT_MONITOR_CAPABILITIES_ORIGIN  Origin;
}
D3DKMDT_MONITOR_DESCRIPTOR;


typedef enum _D3DKMDT_STANDARDALLOCATION_TYPE
{
    D3DKMDT_STANDARDALLOCATION_SHAREDPRIMARYSURFACE  = 1,
    D3DKMDT_STANDARDALLOCATION_SHADOWSURFACE         = 2,
    D3DKMDT_STANDARDALLOCATION_STAGINGSURFACE        = 3,
} D3DKMDT_STANDARDALLOCATION_TYPE;

typedef struct _D3DKMDT_SHAREDPRIMARYSURFACEDATA
{
    UINT                            Width;
    UINT                            Height;
    D3DDDIFORMAT                    Format;
    D3DDDI_RATIONAL                 RefreshRate;
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
} D3DKMDT_SHAREDPRIMARYSURFACEDATA;

typedef struct _D3DKMDT_SHADOWSURFACEDATA
{
    UINT                            Width;
    UINT                            Height;
    D3DDDIFORMAT                    Format;
    UINT                            Pitch;      //out: Driver must return Pitch as this allocation will be lockabale
} D3DKMDT_SHADOWSURFACEDATA;

//Staging Surface is a surface created potentially
//during present when a direct Blt to primary is
//not possible in cases like multimon or sprites.
//This surface is always in the format of D3DDDIFMT_X8R8G8B8

typedef struct _D3DKMDT_STAGINGSURFACEDATA
{
    UINT                            Width;      //in: Width of the staging buffer
    UINT                            Height;     //in: Height of the staging buffer
    UINT                            Pitch;      //out: Driver must return Pitch as this allocation will be lockabale
} D3DKMDT_STAGINGSURFACEDATA;

typedef struct _D3DKMDT_PALETTEDATA
{
    BYTE    Red;
    BYTE    Green;
    BYTE    Blue;
    BYTE    Unused;
} D3DKMDT_PALETTEDATA;

//
//Red - Bits to be put in the Red portion of the color registers.
//
//Green - Bits to be put in the Green portion of the color registers.
//
//Blue - Bits to be put in the Blue portion of the color registers.
//

typedef struct _DXGKARG_SETPALETTE
{
    D3DDDI_VIDEO_PRESENT_SOURCE_ID  VidPnSourceId;
    UINT                            FirstEntry;
    UINT                            NumEntries;
    D3DKMDT_PALETTEDATA*            pLookupTable;
} DXGKARG_SETPALETTE;

//
//NumEntries - Number of entries in the LookupTable of color values.
//
//FirstEntry - Location in the device palette to which the first entry in the
//    LookupTable of colors should be copied to. The other entries in the
//    LookupTable should be copied sequentially, from this starting point into
//    the device's palette.
//
//pLookupTable - Array of color entries to copy into the device's color
//    registers/palette. The color entries can be accessed as a genric 32 bit
//    value or as Red/Green/Blue/Unused fields.
//

//////////////////// I2C ////////////////////////////////////////////////////////////////////////////////////

#define DXGKMDT_I2C_NO_FLAGS                     0
#define DXGKMDT_I2C_DEVICE_TRANSMITS_DATA_LENGTH 1

//////////////////// OPM (Output Protection Manager) ////////////////////////////////////////////////////////

#pragma pack( push, 1 )

#define DXGKMDT_OPM_OMAC_SIZE                       16
#define DXGKMDT_OPM_128_BIT_RANDOM_NUMBER_SIZE      16
#define DXGKMDT_OPM_ENCRYPTED_PARAMETERS_SIZE       256
#define DXGKMDT_OPM_CONFIGURE_SETTING_DATA_SIZE     4056
#define DXGKMDT_OPM_GET_INFORMATION_PARAMETERS_SIZE 4056
#define DXGKMDT_OPM_REQUESTED_INFORMATION_SIZE      4076
#define DXGKMDT_OPM_HDCP_KEY_SELECTION_VECTOR_SIZE  5
#define DXGKMDT_OPM_PROTECTION_TYPE_SIZE            4

DEFINE_GUID(DXGKMDT_OPM_GET_CURRENT_HDCP_SRM_VERSION,           0x99c5ceff, 0x5f1d, 0x4879, 0x81, 0xc1, 0xc5, 0x24, 0x43, 0xc9, 0x48, 0x2b);
DEFINE_GUID(DXGKMDT_OPM_GET_CONNECTED_HDCP_DEVICE_INFORMATION,  0x0db59d74, 0xa992, 0x492e, 0xa0, 0xbd, 0xc2, 0x3f, 0xda, 0x56, 0x4e, 0x00);
DEFINE_GUID(DXGKMDT_OPM_GET_CONNECTOR_TYPE,                     0x81d0bfd5, 0x6afe, 0x48c2, 0x99, 0xc0, 0x95, 0xa0, 0x8f, 0x97, 0xc5, 0xda);
DEFINE_GUID(DXGKMDT_OPM_GET_SUPPORTED_PROTECTION_TYPES,         0x38f2a801, 0x9a6c, 0x48bb, 0x91, 0x07, 0xb6, 0x69, 0x6e, 0x6f, 0x17, 0x97);
DEFINE_GUID(DXGKMDT_OPM_GET_VIRTUAL_PROTECTION_LEVEL,           0xb2075857, 0x3eda, 0x4d5d, 0x88, 0xdb, 0x74, 0x8f, 0x8c, 0x1a, 0x05, 0x49);
DEFINE_GUID(DXGKMDT_OPM_GET_ACTUAL_PROTECTION_LEVEL,            0x1957210a, 0x7766, 0x452a, 0xb9, 0x9a, 0xd2, 0x7a, 0xed, 0x54, 0xf0, 0x3a);
DEFINE_GUID(DXGKMDT_OPM_GET_ACTUAL_OUTPUT_FORMAT,               0xd7bf1ba3, 0xad13, 0x4f8e, 0xaf, 0x98, 0x0d, 0xcb, 0x3c, 0xa2, 0x04, 0xcc);
DEFINE_GUID(DXGKMDT_OPM_GET_ADAPTER_BUS_TYPE,                   0xc6f4d673, 0x6174, 0x4184, 0x8e, 0x35, 0xf6, 0xdb, 0x52, 0x0,  0xbc, 0xba);
DEFINE_GUID(DXGKMDT_OPM_GET_ACP_AND_CGMSA_SIGNALING,            0x6629a591, 0x3b79, 0x4cf3, 0x92, 0x4a, 0x11, 0xe8, 0xe7, 0x81, 0x16, 0x71);
DEFINE_GUID(DXGKMDT_OPM_SET_PROTECTION_LEVEL,                   0x9bb9327c, 0x4eb5, 0x4727, 0x9f, 0x00, 0xb4, 0x2b, 0x09, 0x19, 0xc0, 0xda);
DEFINE_GUID(DXGKMDT_OPM_SET_ACP_AND_CGMSA_SIGNALING,            0x09a631a5, 0xd684, 0x4c60, 0x8e, 0x4d, 0xd3, 0xbb, 0x0f, 0x0b, 0xe3, 0xee);
DEFINE_GUID(DXGKMDT_OPM_SET_HDCP_SRM,                           0x8b5ef5d1, 0xc30d, 0x44ff, 0x84, 0xa5, 0xea, 0x71, 0xdc, 0xe7, 0x8f, 0x13);

typedef enum _DXGKMDT_CERTIFICATE_TYPE
{
    DXGKMDT_OPM_CERTIFICATE  = 0,
    DXGKMDT_COPP_CERTIFICATE = 1,
    DXGKMDT_UAB_CERTIFICATE  = 2,
    DXGKMDT_FORCE_ULONG      = 0xFFFFFFFF
} DXGKMDT_CERTIFICATE_TYPE;

typedef enum _DXGKMDT_OPM_VIDEO_OUTPUT_SEMANTICS
{ 
    DXGKMDT_OPM_VOS_COPP_SEMANTICS = 0,
    DXGKMDT_OPM_VOS_OPM_SEMANTICS  = 1
} DXGKMDT_OPM_VIDEO_OUTPUT_SEMANTICS;

typedef enum _DXGKMDT_DPCP_PROTECTION_LEVEL
{
    DXGKMDT_OPM_DPCP_OFF            = 0,
    DXGKMDT_OPM_DPCP_ON             = 1,
    DXGKMDT_OPM_DPCP_FORCE_ULONG    = 0x7fffffff

} DXGKMDT_OPM_DPCP_PROTECTION_LEVEL;

typedef enum _DXGKMDT_OPM_HDCP_FLAG
{
    DXGKMDT_OPM_HDCP_FLAG_NONE           = 0x00,
    DXGKMDT_OPM_HDCP_FLAG_REPEATER       = 0x01
} DXGKMDT_OPM_HDCP_FLAG;

typedef enum _DXGKMDT_OPM_STATUS
{
    DXGKMDT_OPM_STATUS_NORMAL                           = 0x00,
    DXGKMDT_OPM_STATUS_LINK_LOST                        = 0x01,
    DXGKMDT_OPM_STATUS_RENEGOTIATION_REQUIRED           = 0x02,
    DXGKMDT_OPM_STATUS_TAMPERING_DETECTED               = 0x04,
    DXGKMDT_OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED     = 0x08
} DXGKMDT_OPM_STATUS;

// NUAE stands for Non-User Accessible Enclosure
typedef enum _DXGKMDT_OPM_BUS_TYPE_AND_IMPLEMENTATION
{
    DXGKMDT_OPM_BUS_TYPE_OTHER                                                       = 0x00000000,
    DXGKMDT_OPM_BUS_TYPE_PCI                                                         = 0x00000001,
    DXGKMDT_OPM_BUS_TYPE_PCIX                                                        = 0x00000002,
    DXGKMDT_OPM_BUS_TYPE_PCIEXPRESS                                                  = 0x00000003,
    DXGKMDT_OPM_BUS_TYPE_AGP                                                         = 0x00000004,
    DXGKMDT_OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET                        = 0x00010000,
    DXGKMDT_OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP           = 0x00020000,
    DXGKMDT_OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET         = 0x00030000,
    DXGKMDT_OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR                 = 0x00040000,
    DXGKMDT_OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE  = 0x00050000,
    DXGKMDT_OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD                             = 0x80000000,
    DXGKMDT_OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED                                  = 0x80000000
} DXGKMDT_OPM_BUS_TYPE_AND_IMPLEMENTATION;

typedef enum _DXGKMDT_OPM_HDCP_PROTECTION_LEVEL
{
    DXGKMDT_OPM_HDCP_OFF            = 0,
    DXGKMDT_OPM_HDCP_ON             = 1,
    DXGKMDT_OPM_HDCP_FORCE_ULONG    = 0x7fffffff
} DXGKMDT_OPM_HDCP_PROTECTION_LEVEL;

typedef enum _DXGKMDT_OPM_CGMSA
{
    DXGKMDT_OPM_CGMSA_OFF                                           = 0,
    DXGKMDT_OPM_CGMSA_COPY_FREELY                                   = 1,
    DXGKMDT_OPM_CGMSA_COPY_NO_MORE                                  = 2,
    DXGKMDT_OPM_CGMSA_COPY_ONE_GENERATION                           = 3,
    DXGKMDT_OPM_CGMSA_COPY_NEVER                                    = 4,
    DXGKMDT_OPM_REDISTRIBUTION_CONTROL_REQUIRED                     = 0x08,
} DXGKMDT_OPM_CGMSA;

typedef enum _DXGKMDT_OPM_ACP_PROTECTION_LEVEL
{
    DXGKMDT_OPM_ACP_OFF             = 0,
    DXGKMDT_OPM_ACP_LEVEL_ONE       = 1,
    DXGKMDT_OPM_ACP_LEVEL_TWO       = 2,
    DXGKMDT_OPM_ACP_LEVEL_THREE     = 3,
    DXGKMDT_OPM_ACP_FORCE_ULONG     = 0x7fffffff
} DXGKMDT_OPM_ACP_PROTECTION_LEVEL;

typedef enum _DXGKMDT_OPM_PROTECTION_TYPE
{
    DXGKMDT_OPM_PROTECTION_TYPE_OTHER                       = 0x80000000,
    DXGKMDT_OPM_PROTECTION_TYPE_NONE                        = 0x00000000,
    DXGKMDT_OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP        = 0x00000001,
    DXGKMDT_OPM_PROTECTION_TYPE_ACP                         = 0x00000002,
    DXGKMDT_OPM_PROTECTION_TYPE_CGMSA                       = 0x00000004,
    DXGKMDT_OPM_PROTECTION_TYPE_HDCP                        = 0x00000008,
    DXGKMDT_OPM_PROTECTION_TYPE_DPCP                        = 0x00000010,
    DXGKMDT_OPM_PROTECTION_TYPE_MASK                        = 0x8000001F
} DXGKMDT_OPM_PROTECTION_TYPE;

typedef enum _DXGKMDT_OPM_PROTECTION_STANDARD
{
    DXGKMDT_OPM_PROTECTION_STANDARD_OTHER                   = 0x80000000,
    DXGKMDT_OPM_PROTECTION_STANDARD_NONE                    = 0x00000000,
    DXGKMDT_OPM_PROTECTION_STANDARD_IEC61880_525I           = 0x00000001,
    DXGKMDT_OPM_PROTECTION_STANDARD_IEC61880_2_525I         = 0x00000002,
    DXGKMDT_OPM_PROTECTION_STANDARD_IEC62375_625P           = 0x00000004,
    DXGKMDT_OPM_PROTECTION_STANDARD_EIA608B_525             = 0x00000008,
    DXGKMDT_OPM_PROTECTION_STANDARD_EN300294_625I           = 0x00000010,
    DXGKMDT_OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P      = 0x00000020,
    DXGKMDT_OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P      = 0x00000040,
    DXGKMDT_OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I     = 0x00000080,
    DXGKMDT_OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P      = 0x00000100,
    DXGKMDT_OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P      = 0x00000200,
    DXGKMDT_OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I     = 0x00000400,
    DXGKMDT_OPM_PROTECTION_STANDARD_ARIBTRB15_525I          = 0x00000800,
    DXGKMDT_OPM_PROTECTION_STANDARD_ARIBTRB15_525P          = 0x00001000,
    DXGKMDT_OPM_PROTECTION_STANDARD_ARIBTRB15_750P          = 0x00002000,
    DXGKMDT_OPM_PROTECTION_STANDARD_ARIBTRB15_1125I         = 0x00004000,
} DXGKMDT_OPM_PROTECTION_STANDARD;

typedef enum _DXGKMDT_OPM_IMAGE_ASPECT_RATIO_EN300294
{
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3                        = 0,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER                        = 1,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP                           = 2,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER                        = 3,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP                           = 4,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER                     = 5,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER       = 6,
    DXGKMDT_OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC            = 7,
    DXGKMDT_OPM_ASPECT_RATIO_FORCE_ULONG                                        = 0x7FFFFFFF
} DXGKMDT_OPM_IMAGE_ASPECT_RATIO_EN300294;

typedef enum _DXGKMDT_OPM_INTERLEAVE_FORMAT
{
    DXGKMDT_OPM_INTERLEAVE_FORMAT_OTHER = 0,
    DXGKMDT_OPM_INTERLEAVE_FORMAT_PROGRESSIVE = 2,
    DXGKMDT_OPM_INTERLEAVE_FORMAT_INTERLEAVED_EVEN_FIRST = 3,
    DXGKMDT_OPM_INTERLEAVE_FORMAT_INTERLEAVED_ODD_FIRST = 4,
    DXGKMDT_OPM_INTERLEAVE_FORMAT_FORCE_ULONG = 0xFFFFFFFF
 
} DXGKMDT_OPM_INTERLEAVE_FORMAT;
 
typedef struct _DXGKMDT_OPM_RANDOM_NUMBER
{
    BYTE abRandomNumber[DXGKMDT_OPM_128_BIT_RANDOM_NUMBER_SIZE];
} DXGKMDT_OPM_RANDOM_NUMBER, *PDXGKMDT_OPM_RANDOM_NUMBER;

typedef struct _DXGKMDT_OPM_OMAC
{
    BYTE abOMAC[DXGKMDT_OPM_OMAC_SIZE];
} DXGKMDT_OPM_OMAC, *PDXGKMDT_OPM_OMAC;

typedef struct _DXGKMDT_OPM_ENCRYPTED_PARAMETERS
{
    BYTE abEncryptedParameters[DXGKMDT_OPM_ENCRYPTED_PARAMETERS_SIZE];
} DXGKMDT_OPM_ENCRYPTED_PARAMETERS, *PDXGKMDT_OPM_ENCRYPTED_PARAMETERS;

typedef struct _DXGKMDT_OPM_GET_INFO_PARAMETERS
{
    DXGKMDT_OPM_OMAC omac;
    DXGKMDT_OPM_RANDOM_NUMBER rnRandomNumber;
    GUID guidInformation;
    ULONG ulSequenceNumber;
    ULONG cbParametersSize;
    BYTE abParameters[DXGKMDT_OPM_GET_INFORMATION_PARAMETERS_SIZE];
} DXGKMDT_OPM_GET_INFO_PARAMETERS, *PDXGKMDT_OPM_GET_INFO_PARAMETERS;

typedef struct _DXGKMDT_OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS
{
    DXGKMDT_OPM_RANDOM_NUMBER rnRandomNumber;
    GUID guidInformation;
    ULONG ulSequenceNumber;
    ULONG cbParametersSize;
    BYTE abParameters[DXGKMDT_OPM_GET_INFORMATION_PARAMETERS_SIZE];
} DXGKMDT_OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, *PDXGKMDT_OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS;

typedef struct _DXGKMDT_OPM_HDCP_KEY_SELECTION_VECTOR
{
    BYTE abKeySelectionVector[DXGKMDT_OPM_HDCP_KEY_SELECTION_VECTOR_SIZE];
} DXGKMDT_OPM_HDCP_KEY_SELECTION_VECTOR;

typedef struct _DXGKMDT_OPM_CONNECTED_HDCP_DEVICE_INFORMATION
{
    DXGKMDT_OPM_RANDOM_NUMBER rnRandomNumber;
    ULONG ulStatusFlags;
    ULONG ulHDCPFlags;
    DXGKMDT_OPM_HDCP_KEY_SELECTION_VECTOR ksvB;
    BYTE Reserved[11];
    BYTE Reserved2[16];
    BYTE Reserved3[16];
} DXGKMDT_OPM_CONNECTED_HDCP_DEVICE_INFORMATION;

typedef struct _DXGKMDT_OPM_REQUESTED_INFORMATION
{
    DXGKMDT_OPM_OMAC omac;
    ULONG cbRequestedInformationSize;
    BYTE abRequestedInformation[DXGKMDT_OPM_REQUESTED_INFORMATION_SIZE];
} DXGKMDT_OPM_REQUESTED_INFORMATION, *PDXGKMDT_OPM_REQUESTED_INFORMATION;

typedef struct _DXGKMDT_OPM_STANDARD_INFORMATION
{
    DXGKMDT_OPM_RANDOM_NUMBER rnRandomNumber;
    ULONG ulStatusFlags;
    ULONG ulInformation;
    ULONG ulReserved;
    ULONG ulReserved2;
} DXGKMDT_OPM_STANDARD_INFORMATION;

typedef struct _DXGKMDT_OPM_ACTUAL_OUTPUT_FORMAT
{
    DXGKMDT_OPM_RANDOM_NUMBER rnRandomNumber;
    ULONG ulStatusFlags;
    ULONG ulDisplayWidth;
    ULONG ulDisplayHeight;
    DXGKMDT_OPM_INTERLEAVE_FORMAT ifInterleaveFormat;
    ULONG d3dFormat;
    ULONG ulFrequencyNumerator;
    ULONG ulFrequencyDenominator;
} DXGKMDT_OPM_ACTUAL_OUTPUT_FORMAT;

typedef struct _DXGKMDT_OPM_ACP_AND_CGMSA_SIGNALING
{
    DXGKMDT_OPM_RANDOM_NUMBER rnRandomNumber;
    ULONG ulStatusFlags;
    ULONG ulAvailableTVProtectionStandards;
    ULONG ulActiveTVProtectionStandard;
    ULONG ulReserved;
    ULONG ulAspectRatioValidMask1;
    ULONG ulAspectRatioData1;
    ULONG ulAspectRatioValidMask2;
    ULONG ulAspectRatioData2;
    ULONG ulAspectRatioValidMask3;
    ULONG ulAspectRatioData3;
    ULONG ulReserved2[4];
    ULONG ulReserved3[4];
} DXGKMDT_OPM_ACP_AND_CGMSA_SIGNALING;

typedef struct _DXGKMDT_OPM_CONFIGURE_PARAMETERS
{
    DXGKMDT_OPM_OMAC omac;
    GUID guidSetting;
    ULONG ulSequenceNumber;
    ULONG cbParametersSize;
    BYTE abParameters[DXGKMDT_OPM_CONFIGURE_SETTING_DATA_SIZE];
} DXGKMDT_OPM_CONFIGURE_PARAMETERS, *PDXGKMDT_OPM_CONFIGURE_PARAMETERS;

typedef struct _DXGKMDT_OPM_SET_PROTECTION_LEVEL_PARAMETERS
{
    ULONG ulProtectionType;
    ULONG ulProtectionLevel;
    ULONG Reserved;
    ULONG Reserved2;
} DXGKMDT_OPM_SET_PROTECTION_LEVEL_PARAMETERS;

typedef struct _DXGKMDT_OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS
{
    ULONG ulNewTVProtectionStandard;
    ULONG ulAspectRatioChangeMask1;
    ULONG ulAspectRatioData1;
    ULONG ulAspectRatioChangeMask2;
    ULONG ulAspectRatioData2;
    ULONG ulAspectRatioChangeMask3;
    ULONG ulAspectRatioData3;
    ULONG ulReserved[4];
    ULONG ulReserved2[4];
    ULONG ulReserved3;
} DXGKMDT_OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS;

typedef struct _DXGKMDT_OPM_SET_HDCP_SRM_PARAMETERS
{
    ULONG ulSRMVersion;
} DXGKMDT_OPM_SET_HDCP_SRM_PARAMETERS;

#pragma pack( pop )

#endif /* _D3DKMDT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\csq.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    csq.h

Abstract:

    This header exposes the cancel safe queue DDIs for use on Win2K at later.
    Drivers that use this header should link to csq.lib. If a driver only needs
    to work on XP or later, neither this header or the lib are required (the
    XP kernel supports the cancel safe queue DDIs natively.)

Revision History:

--*/

// Cancel SAFE DDI set start
//
// The following DDIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of DDIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue DDI set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel DDI code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel DDI set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//

#ifndef _CSQ_H_
#define _CSQ_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// If the wdm.h/ntddk.h we're including already defines cancel safe DDIs, we
// can skip the structure definitions. Otherwise, we do the rest here:
//
#ifndef IO_TYPE_CSQ_IRP_CONTEXT

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp
    );

typedef VOID
(*PIO_CSQ_REMOVE_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
    );

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
(*PIO_CSQ_PEEK_NEXT_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
    );

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
(*PIO_CSQ_ACQUIRE_LOCK)(
     IN  PIO_CSQ Csq,
     OUT PKIRQL  Irql
     );

typedef VOID
(*PIO_CSQ_RELEASE_LOCK)(
     IN PIO_CSQ Csq,
     IN KIRQL   Irql
     );


//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
(*PIO_CSQ_COMPLETE_CANCELED_IRP)(
    IN  PIO_CSQ    Csq,
    IN  PIRP       Irp
    );

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

#endif // IO_TYPE_CSQ_IRP_CONTEXT


//
// Add in new extensions to the csq.h library.
//

#ifndef IO_TYPE_CSQ_EX

#define IO_TYPE_CSQ_EX          3

typedef NTSTATUS
(*PIO_CSQ_INSERT_IRP_EX)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp,
    IN PVOID             InsertContext
    );

#endif // IO_TYPE_CSQ_EX


//
// These defines ensure the backward compatible CSQ library can be used within
// the XP build environment in which the kernel supports the functions natively.
//

#define CSQLIB_DDI(x)   Wdmlib##x

//
// Initializes the cancel queue structure.
//

#undef IoCsqInitialize
#define IoCsqInitialize         WdmlibIoCsqInitialize

NTSTATUS
CSQLIB_DDI(IoCsqInitialize)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP               CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );


#undef IoCsqInitializeEx
#define IoCsqInitializeEx       WdmlibIoCsqInitializeEx

NTSTATUS
CSQLIB_DDI(IoCsqInitializeEx)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP_EX            CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );


//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

#undef IoCsqInsertIrp
#define IoCsqInsertIrp          WdmlibIoCsqInsertIrp

VOID
CSQLIB_DDI(IoCsqInsertIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );


#undef IoCsqInsertIrpEx
#define IoCsqInsertIrpEx        WdmlibIoCsqInsertIrpEx

NTSTATUS
CSQLIB_DDI(IoCsqInsertIrpEx)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context,
    IN  PVOID               InsertContext
    );

//
// Returns an IRP if one can be found. NULL otherwise.
//

#undef IoCsqRemoveNextIrp
#define IoCsqRemoveNextIrp      WdmlibIoCsqRemoveNextIrp

PIRP
CSQLIB_DDI(IoCsqRemoveNextIrp)(
    IN  PIO_CSQ   Csq,
    IN  PVOID     PeekContext
    );

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

#undef IoCsqRemoveIrp
#define IoCsqRemoveIrp          WdmlibIoCsqRemoveIrp

PIRP
CSQLIB_DDI(IoCsqRemoveIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _CSQ_H_

// Cancel SAFE DDI set end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d3dhalex.h ===
#ifndef _D3DHALEX_H
#define _D3DHALEX_H

//-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dhalex.h
//  Content:    Direct3D HAL Extensions and Helpers include file
//              This file contains definitions and macros which although not
//              essential for building a driver are useful helpers and
//              utilities.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Macros to help with handling the new GetDriverInfo2 mechanism. The following
// macros assist with handling the GetDriverInfo2 sub-call of GetDriverInfo.
// Two of the macros are simplified ways of differentiating between
// GetDriverInfo2 calls and DDStereoMode calls. The others are simplified ways
// of getting the data structures associated with those two calls.
//
// The following code fragment demonstrates how to handle GetDriverInfo2 using
// these macros. Compare this with the code fragment in d3dhal.h
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK 
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (D3DGDI_IS_GDI2(lpData))
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = D3DGDI_GET_GDI2_DATA(lpData);
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = D3DGDI_GET_STEREOMODE_DATA(pData);
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// Macros to determine what type of call a call to GetDriverInfo with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode. A GetDriverInfo2 call or
// a DDStereoMode call.
//
#define D3DGDI_IS_GDI2(pData) \
    ((((DD_GETDRIVERINFO2DATA*)(pData->lpvData))->dwMagic)  == D3DGDI2_MAGIC)

#define D3DGDI_IS_STEREOMODE(pData) \
    ((((DD_STEREOMODE*)        (pData->lpvData))->dwHeight) != D3DGDI2_MAGIC)

//
// Macros to return the appropriate GetDriverInfo data structure for a
// call to GetDriverInfo with the GUID GUID_GetDriverInfo2/GUID_DDStereoMode.
//
#define D3DGDI_GET_GDI2_DATA(pData) \
    (D3DGDI_IS_GDI2(pData) ? (((DD_GETDRIVERINFO2DATA*)(pData->lpvData))) : NULL)

#define D3DGDI_GET_STEREOMODE_DATA(pData) \
    (D3DGDI_IS_STEREOMODE(pData) ? (((DD_STEREOMODE*)(pData->lpvData)))   : NULL)

#endif /* _D3DHALEX_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d3dvec.inl ===
/****************************************************************** 
 *                                                                *
 *   D3DVec.inl                                                   *
 *                                                                *
 *   Float-valued 3D vector class for Direct3D.                   *
 *                                                                *
 *   Copyright (c) Microsoft Corp. All rights reserved.           *
 *                                                                *
 ******************************************************************/

#include <math.h>

// =====================================
// Constructors
// =====================================

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE f)
{
    x = y = z = f;
}

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z)
{
    x = _x; y = _y; z = _z;
}

inline
_D3DVECTOR::_D3DVECTOR(const D3DVALUE f[3])
{
    x = f[0]; y = f[1]; z = f[2];
}

// =====================================
// Access grants
// =====================================

inline const D3DVALUE&
_D3DVECTOR::operator[](int i) const
{
    return (&x)[i];
}

inline D3DVALUE&
_D3DVECTOR::operator[](int i)
{
    return (&x)[i];
}


// =====================================
// Assignment operators
// =====================================

inline _D3DVECTOR&
_D3DVECTOR::operator += (const _D3DVECTOR& v)
{
   x += v.x;   y += v.y;   z += v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator -= (const _D3DVECTOR& v)
{
   x -= v.x;   y -= v.y;   z -= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (const _D3DVECTOR& v)
{
   x *= v.x;   y *= v.y;   z *= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (const _D3DVECTOR& v)
{
   x /= v.x;   y /= v.y;   z /= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (D3DVALUE s)
{
   x *= s;   y *= s;   z *= s;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (D3DVALUE s)
{
   x /= s;   y /= s;   z /= s;
   return *this;
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v)
{
   return v;
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v)
{
   return _D3DVECTOR(-v.x, -v.y, -v.z);
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z);
}

inline int
operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] < v2[0] && v1[1] < v2[1] && v1[2] < v2[2];
}

inline int
operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2];
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator * (D3DVALUE s, const _D3DVECTOR& v)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(v.x/s, v.y/s, v.z/s);
}

inline int
operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x==v2.x && v1.y==v2.y && v1.z == v2.z;
}

inline D3DVALUE
Magnitude (const _D3DVECTOR& v)
{
   return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVALUE
SquareMagnitude (const _D3DVECTOR& v)
{
   return v.x*v.x + v.y*v.y + v.z*v.z;
}

inline _D3DVECTOR
Normalize (const _D3DVECTOR& v)
{
   return v / Magnitude(v);
}

inline D3DVALUE
Min (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (v.y < ret) ret = v.y;
   if (v.z < ret) ret = v.z;
   return ret;
}

inline D3DVALUE
Max (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (ret < v.y) ret = v.y;
   if (ret < v.z) ret = v.z;
   return ret;
}

inline _D3DVECTOR
Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] < v2[0] ? v1[0] : v2[0],
                   v1[1] < v2[1] ? v1[1] : v2[1],
                   v1[2] < v2[2] ? v1[2] : v2[2]);
}

inline _D3DVECTOR
Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] > v2[0] ? v1[0] : v2[0],
                   v1[1] > v2[1] ? v1[1] : v2[1],
                   v1[2] > v2[2] ? v1[2] : v2[2]);
}

inline D3DVALUE
DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x*v2.x + v1.y * v2.y + v1.z*v2.z;
}

inline _D3DVECTOR
CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
	_D3DVECTOR result;

	result[0] = v1[1] * v2[2] - v1[2] * v2[1];
	result[1] = v1[2] * v2[0] - v1[0] * v2[2];
	result[2] = v1[0] * v2[1] - v1[1] * v2[0];

	return result;
}

inline _D3DMATRIX
operator* (const _D3DMATRIX& a, const _D3DMATRIX& b)
{
    _D3DMATRIX ret;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            ret(i, j) = 0.0f;
            for (int k=0; k<4; k++) {
                ret(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dderror.h ===
/*++ BUILD Version: ????     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

#define NO_ERROR 0L                                                 
#define ERROR_INVALID_FUNCTION           1L    
#define ERROR_NOT_ENOUGH_MEMORY          8L    
#define ERROR_DEV_NOT_EXIST              55L    
#define ERROR_INVALID_PARAMETER          87L    
#define ERROR_INSUFFICIENT_BUFFER        122L    
#define ERROR_INVALID_NAME               123L    
#define ERROR_BUSY                       170L    
#define ERROR_MORE_DATA                  234L    
#define WAIT_TIMEOUT                     258L    
#define ERROR_IO_PENDING                 997L    
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    
#define ERROR_CONTINUE                   1246L    
#define ERROR_NO_MORE_DEVICES            1248L    

#endif /* _DDERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dciman.h ===
/****************************************************************************

 DCIMAN.H

 Copyright (C) 1993-1999 Microsoft Corporation.  All Rights Reserved.

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight,
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf,
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

#ifdef WIN32
/****************************************************************************
 helper functions to call DCIMAN16.DLL
 ***************************************************************************/
extern void WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);


#else

extern int WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

/****************************************************************************
 helper macros to call DCI callbacks
 ***************************************************************************/
__inline void DCIDestroy(LPDCISURFACEINFO pdci)
{
	if( pdci->DestroySurface != NULL ) {
		pdci->DestroySurface(pdci);
	}
}

__inline void DCIEndAccess(LPDCISURFACEINFO pdci)
{
	if( pdci->EndAccess != NULL ) {
		pdci->EndAccess(pdci);
	}
}

__inline DCIRVAL DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy)
{
    RECT rc;

	if( pdci->BeginAccess != NULL ) {
		rc.left=x;
		rc.top=y;
		rc.right = rc.left+dx;
		rc.bottom = rc.top+dy;
		return pdci->BeginAccess(pdci, &rc);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCIDraw(LPDCIOFFSCREEN pdci)
{
	if( pdci->Draw != NULL ) {
		return pdci->Draw(pdci);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd)
{
	if( pdci->SetClipList != NULL ) {
		return pdci->SetClipList(pdci, prd);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src)
{
	if( pdci->SetDestination != NULL ) {
		return pdci->SetDestination(pdci, dst, src);
	} else {
		return DCI_OK;
	}
}
#endif

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d4drvif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    D4drvif.h

Abstract:

    DOT4 Driver Interface


--*/

#ifndef _DOT4DRVIF_H
#define _DOT4DRVIF_H

//////////////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Defines
//////////////////////////////////////////////////////////////////////////////
#define MAX_SERVICE_LENGTH      40


#ifndef CTL_CODE

  //
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#endif

#define FILE_DEVICE_DOT4         0x3a
#define IOCTL_DOT4_USER_BASE     2049
#define IOCTL_DOT4_LAST          IOCTL_DOT4_USER_BASE + 9

#define IOCTL_DOT4_CREATE_SOCKET                 CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  7, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_DESTROY_SOCKET                CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  9, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WAIT_FOR_CHANNEL              CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  8, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_OPEN_CHANNEL                  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  0, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_CLOSE_CHANNEL                 CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_READ                          CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  2, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WRITE                         CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  3, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_ADD_ACTIVITY_BROADCAST        CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_REMOVE_ACTIVITY_BROADCAST     CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WAIT_ACTIVITY_BROADCAST       CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  6, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


//////////////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////////////

typedef struct _DOT4_DRIVER_CMD
{
    // Handle to channel
    CHANNEL_HANDLE hChannelHandle;

    // Length of request
    ULONG ulSize;

    // Offset into buffer
    ULONG ulOffset;

    // Timeout of operation. Can be INFINITE.
    ULONG ulTimeout;

} DOT4_DRIVER_CMD, *PDOT4_DRIVER_CMD;


typedef struct _DOT4_DC_OPEN_DATA
{
    // Host socket created by CREATE_SOCKET
    unsigned char bHsid;

    // TRUE to immediately add activity broadcast upon creation
    unsigned char fAddActivity;

    // Handle to channel returned
    CHANNEL_HANDLE hChannelHandle;

} DOT4_DC_OPEN_DATA, *PDOT4_DC_OPEN_DATA;


typedef struct _DOT4_DC_CREATE_DATA
{
    // This or service name sent
    unsigned char bPsid;

    CHAR pServiceName[MAX_SERVICE_LENGTH + 1];

    // Type (stream or packet) of channels on socket
    unsigned char bType;

    // Size of read buffer for channels on socket
    ULONG ulBufferSize;

    USHORT usMaxHtoPPacketSize;

    USHORT usMaxPtoHPacketSize;

    // Host socket id returned
    unsigned char bHsid;

} DOT4_DC_CREATE_DATA, *PDOT4_DC_CREATE_DATA;


typedef struct _DOT4_DC_DESTROY_DATA
{
    // Host socket created by CREATE_SOCKET
    unsigned char bHsid;

} DOT4_DC_DESTROY_DATA, *PDOT4_DC_DESTROY_DATA;


//////////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dciddi.h ===
/*******************************************************************
 *
 *      FILE:           dciddi.h
 *
 *      DESCRIPTION:    definitions for MS/Intel-defined DCI interface
 *
 *      Copyright (C) 1994-1999 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */
#define DCICOMMAND                      3075
#define DCI_VERSION                     0x0100

#define DCICREATEPRIMARYSURFACE         1
#define DCICREATEOFFSCREENSURFACE       2
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                                  0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN                      -17
#define DCI_ERR_YALIGN                      -18
#define DCI_ERR_XYALIGN                     -19
#define DCI_ERR_WIDTHALIGN                  -20
#define DCI_ERR_HEIGHTALIGN                 -21

/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16
#define DCI_STATUS_WASSTILLDRAWING         32

#define DCI_SUCCESS(error)  (((DCIRVAL)error) >= 0)

/* DCI Capability Flags */
#define DCI_SURFACE_TYPE                        0x0000000F
#define DCI_PRIMARY                             0x00000000
#define DCI_OFFSCREEN                           0x00000001
#define DCI_OVERLAY                             0x00000002

#define DCI_VISIBLE                             0x00000010
#define DCI_CHROMAKEY                           0x00000020
#define DCI_1632_ACCESS                         0x00000040
#define DCI_DWORDSIZE                           0x00000080
#define DCI_DWORDALIGN                          0x00000100
#define DCI_WRITEONLY                           0x00000200
#define DCI_ASYNC                               0x00000400

#define DCI_CAN_STRETCHX                        0x00001000
#define DCI_CAN_STRETCHY                        0x00002000
#define DCI_CAN_STRETCHXY                       (DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN                       0x00004000
#define DCI_CAN_STRETCHYN                       0x00008000
#define DCI_CAN_STRETCHXYN                      (DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} RECTL;
typedef RECTL*       PRECTL;
typedef RECTL NEAR*  NPRECTL;
typedef RECTL FAR*   LPRECTL;
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *      input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
        DWORD   dwCommand;
        DWORD   dwParam1;
        DWORD   dwParam2;
        DWORD   dwVersion;
        DWORD   dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for
 * the DCICREATE... calls.  The fields that are actually relevant differ for
 * each of the three calls.  Details are in the DCI Spec chapter providing
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        DWORD   dwCompression;                          /* format of surface to be created                      */
        DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
        DWORD   dwWidth;                        /* height of the surface to be created          */
        DWORD   dwHeight;                       /* width of input surfaces                                      */
        DWORD   dwDCICaps;                                              /* capabilities of surface wanted */
        DWORD   dwBitCount;                                     /* bit depth of format to be created */
        LPVOID  lpSurface;                      /* pointer to an associated surface             */
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;


/**************************************************************************
 *      surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary
 * surface, and as a member of the larger structures returned by the
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
        DWORD   dwSize;                         /* size of structure                                            */
        DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
        DWORD   dwCompression;                  /* format of surface to be created                      */
        DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

        DWORD   dwWidth;                    /* width of surface                                             */
        DWORD   dwHeight;                   /* height of surface                                            */
        LONG    lStride;                    /* distance in bytes betw. one pixel            */
                                                                                /* and the pixel directly below it                      */
        DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
        ULONG_PTR dwOffSurface;             /* offset of surface pointer                            */
        WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;

        DWORD   dwReserved1;                /* reserved for provider */
        DWORD   dwReserved2;                /* reserved for DCIMAN */
        DWORD   dwReserved3;                /* reserved for future */
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
        void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */
        void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;


/*
 * This structure is used by a DCI client to provide input parameters for the
 * DCIEnumSurface call.
 */

typedef
void
(*ENUM_CALLBACK) (
    LPDCISURFACEINFO lpSurfaceInfo,
    LPVOID lpContext
    );

typedef struct _DCIENUMINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        RECT    rSrc;                           /* source rect. for stretch  */
        RECT    rDst;                           /* dest. rect. for stretch       */
        void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
        LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;


/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;

/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

        DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

        DCISURFACEINFO  dciInfo;                                                /* surface info                  */
        DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
        DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dispmprt.h ===
/*++

Copyright (c) 2004 Microsoft Corporation

Module Name:

    dispmprt.h

Abstract:

    This header contain the new Display Loader APIs.


--*/

#ifndef _DISPMPRT_H_
#define _DISPMPRT_H_

#pragma warning(push)
#pragma warning(disable:4115) // named type definition in parentheses
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

#ifndef _ACPIIOCT_H_
#include <acpiioct.h>
#endif

//
// Old includes which are only kept for now for compatibility
//

#ifndef _NTOSP_
#define _NTOSP_

//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

#endif

//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );

//
// Exclude some items from video.h
//

#define _NTOSDEF_

#include <ntddvdeo.h>
#include <video.h>

//
// Define types used in d3dukmdt.h, included via d3dkmdt.h that are not defined in this scope.
//

typedef unsigned int   UINT;
typedef unsigned long  DWORD;
typedef unsigned char  BYTE;

#include <windef.h>
#include <d3dkmddi.h>
#include <d3dkmdt.h>

#define DlDebugPrintEx(arg) DlDebugPrint arg

//
// ** New definitions *********************************************************
//

//
// Add the version number to all structures. This is defined as a USHORT to be compatible
// with the standard INTERFACE structure. The first 4 bits is the major version, the
// remaining 12 bits are the minor version.
//
// ***********  NOTE: THIS IS A HEX NUMBER, UPDATE FROM 9 to A. *****************
//

#define DXGKDDI_INTERFACE_VERSION 0x1053

//
// Define ACPI event IDs
//

#define ACPI_NOTIFY_DOCK_EVENT              0x77
#define ACPI_NOTIFY_PANEL_SWITCH            0x80
#define ACPI_NOTIFY_DEVICE_HOTPLUG          0x81
#define ACPI_NOTIFY_CYCLE_DISPLAY_HOTKEY    0x82
#define ACPI_NOTIFY_NEXT_DISPLAY_HOTKEY     0x83
#define ACPI_NOTIFY_PREV_DISPLAY_HOTKEY     0x84
#define ACPI_NOTIFY_CYCLE_BRIGHTNESS_HOTKEY 0x85
#define ACPI_NOTIFY_INC_BRIGHTNESS_HOTKEY   0x86
#define ACPI_NOTIFY_DEC_BRIGHTNESS_HOTKEY   0x87
#define ACPI_NOTIFY_ZERO_BRIGHTNESS_HOTKEY  0x88
#define ACPI_NOTIFY_VIDEO_WAKEUP            0x90

//
// ACPI argument definitions
//

#define ACPI_ARG_ENABLE_SWITCH_EVENT         0x0
#define ACPI_ARG_ENABLE_AUTO_SWITCH          0x1
#define ACPI_ARG_DISABLE_SWITCH_EVENT        0x2
#define ACPI_ARG_ENABLE_AUTO_LCD_BRIGHTNESS  0x0
#define ACPI_ARG_DISABLE_AUTO_LCD_BRIGHTNESS 0x4

//
// ACPI methods for the adapter
//

#define ACPI_METHOD_DISPLAY_DOS (ULONG)('SOD_')
#define ACPI_METHOD_DISPLAY_DOD (ULONG)('DOD_')
#define ACPI_METHOD_DISPLAY_ROM (ULONG)('MOR_')
#define ACPI_METHOD_DISPLAY_GPD (ULONG)('DPG_')
#define ACPI_METHOD_DISPLAY_SPD (ULONG)('DPS_')
#define ACPI_METHOD_DISPLAY_VPO (ULONG)('OPV_')

//
// ACPI methods for children
//

#define ACPI_METHOD_OUTPUT_ADR (ULONG)('RDA_')
#define ACPI_METHOD_OUTPUT_BCL (ULONG)('LCB_')
#define ACPI_METHOD_OUTPUT_BCM (ULONG)('MCB_')
#define ACPI_METHOD_OUTPUT_DDC (ULONG)('CDD_')
#define ACPI_METHOD_OUTPUT_DCS (ULONG)('SCD_')
#define ACPI_METHOD_OUTPUT_DGS (ULONG)('SGD_')
#define ACPI_METHOD_OUTPUT_DSS (ULONG)('SSD_')

//
// ACPI Flags
//

#define DXGK_ACPI_POLL_DISPLAY_CHILDREN 0x00000001
#define DXGK_ACPI_CHANGE_DISPLAY_MODE   0x00000002

//
// Exclude adapter access flags.
//

#define DXGK_EXCLUDE_EVICT_ALL          0x00000001
#define DXGK_EXCLUDE_CALL_SYNCHRONOUS   0x00000002
#define DXGK_EXCLUDE_BRIDGE_ACCESS      0x00000004

//
// Max of 50 characters per string.
//

#define DXGK_MAX_STRING_LEN 50
#define DXGK_MAX_REG_SZ_LEN DXGK_MAX_STRING_LEN + 1

//
// Supported device space types.
//

#define DXGK_WHICHSPACE_CONFIG       PCI_WHICHSPACE_CONFIG
#define DXGK_WHICHSPACE_ROM          PCI_WHICHSPACE_ROM
#define DXGK_WHICHSPACE_MCH          0x80000000
#define DXGK_WHICHSPACE_BRIDGE       0x80000001

//
// Linked display adapter support.
//

typedef struct _LINKED_DEVICE {
    ULONG ChainUid;
    ULONG NumberOfLinksInChain;
    BOOLEAN LeadLink;
} LINKED_DEVICE, *PLINKED_DEVICE;

//
// Type of ACPI notification event.
//

typedef enum _DXGK_EVENT_TYPE {
    DxgkUndefinedEvent,
    DxgkAcpiEvent,
    DxgkPowerStateEvent,
    DxgkDockingEvent
} DXGK_EVENT_TYPE, *PDXGK_EVENT_TYPE;

typedef struct _DXGK_VIDEO_OUTPUT_CAPABILITIES {
    D3DKMDT_VIDEO_OUTPUT_TECHNOLOGY InterfaceTechnology;
    D3DKMDT_MONITOR_ORIENTATION_AWARENESS MonitorOrientationAwareness;
    BOOLEAN SupportsSdtvModes;
} DXGK_VIDEO_OUTPUT_CAPABILITIES, *PDXGK_VIDEO_OUTPUT_CAPABILITIES;


typedef struct _DXGK_CHILD_CAPABILITIES {

    union
    {
        //
        // If (CHILD_DESCRIPTOR::ChildDeviceType == TypeVideoOutput)
        //

        DXGK_VIDEO_OUTPUT_CAPABILITIES  VideoOutput;

        //
        // If (CHILD_DESCRIPTOR::ChildDeviceType == TypeOther)
        //

        struct
        {
            UINT MustBeZero;
        }
        Other;
    } Type;

    DXGK_CHILD_DEVICE_HPD_AWARENESS HpdAwareness;
} DXGK_CHILD_CAPABILITIES, *PDXGK_CHILD_CAPABILITIES;

typedef enum _DXGK_CHILD_DEVICE_TYPE {
   TypeUninitialized,
   TypeVideoOutput,
   TypeOther
} DXGK_CHILD_DEVICE_TYPE, *PDXGK_CHILD_DEVICE_TYPE;

//
// Child descriptor structure returned to us from the miniport
//
// NOTE: If (ChildDeviceType==TypeVideoOutput) then (ChildUid == video present target ID)
//

typedef struct _DXGK_CHILD_DESCRIPTOR {
   DXGK_CHILD_DEVICE_TYPE ChildDeviceType;
   DXGK_CHILD_CAPABILITIES ChildCapabilities;
   ULONG AcpiUid;
   ULONG ChildUid;
} DXGK_CHILD_DESCRIPTOR, *PDXGK_CHILD_DESCRIPTOR;

typedef struct _DXGK_DEVICE_DESCRIPTOR {
   ULONG DescriptorOffset;
   ULONG DescriptorLength;
   PVOID DescriptorBuffer;
} DXGK_DEVICE_DESCRIPTOR, *PDXGK_DEVICE_DESCRIPTOR;

typedef struct _DXGK_GENERIC_DESCRIPTOR {
   WCHAR HardwareId[DXGK_MAX_REG_SZ_LEN];
   WCHAR InstanceId[DXGK_MAX_REG_SZ_LEN];
   WCHAR CompatibleId[DXGK_MAX_REG_SZ_LEN];
   WCHAR DeviceText[DXGK_MAX_REG_SZ_LEN];
} DXGK_GENERIC_DESCRIPTOR, *PDXGK_GENERIC_DESCRIPTOR;

//
// Types of status that the miniport can report back to us
//

typedef enum _DXGK_CHILD_STATUS_TYPE{
   StatusUninitialized,
   StatusConnection,
   StatusRotation
} DXGK_CHILD_STATUS_TYPE, *PDXGK_CHILD_STATUS_TYPE;

//
// Child Status structure which can be queried directly or
// indicated up by the miniport
//

typedef struct _DXGK_CHILD_STATUS {
   DXGK_CHILD_STATUS_TYPE Type;
   ULONG ChildUid;
   union {
      struct {
         BOOLEAN Connected;
      } HotPlug;
      struct {
         UCHAR Angle;
      } Rotation;
   };
} DXGK_CHILD_STATUS, *PDXGK_CHILD_STATUS;

//
// DxgkCbExcludeAdapterAccess callback.
//

typedef
VOID
(*DXGKDDI_PROTECTED_CALLBACK)(
    IN CONST PVOID MiniportDeviceContext,
    IN PVOID ProtectedCallbackContext,
    IN NTSTATUS ProtectionStatus
    );

//
// GUID_DEVINTERFACE_I2C {2564AA4F-DDDB-4495-B497-6AD4A84163D7}
//

DEFINE_GUID(GUID_DEVINTERFACE_I2C, 0x2564AA4F, 0xDDDB, 0x4495, 0xB4, 0x97, 0x6A, 0xD4, 0xA8, 0x41, 0x63, 0xD7);

//
// GUID_DEVINTERFACE_OPM {BF4672DE-6B4E-4BE4-A325-68A91EA49C09}
//

DEFINE_GUID(GUID_DEVINTERFACE_OPM, 0xBF4672DE, 0x6B4E, 0x4BE4, 0xA3, 0x25, 0x68, 0xA9, 0x1E, 0xA4, 0x9C, 0x09);

//
// GUID_DEVINTERFACE_BRIGHTNESS {FDE5BBA4-B3F9-46FB-BDAA-0728CE3100B4}
//

DEFINE_GUID( GUID_DEVINTERFACE_BRIGHTNESS, 0xFDE5BBA4, 0xB3F9, 0x46FB, 0xBD, 0xAA, 0x07, 0x28, 0xCE, 0x31, 0x00, 0xB4);

//
// I2C Interface queried from the miniport.
//

#define DXGK_I2C_INTERFACE_VERSION_1 0x01

typedef
NTSTATUS
(*DXGKDDI_I2C_TRANSMIT_DATA_TO_DISPLAY)(
    IN PVOID MiniportDeviceContext,
    IN D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId,
    IN ULONG SevenBitI2CAddress,
    IN ULONG DataLength,
    IN CONST PVOID Data
    );

typedef
NTSTATUS
(*DXGKDDI_I2C_RECEIVE_DATA_FROM_DISPLAY)(
    IN PVOID MiniportDeviceContext,
    IN D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId,
    IN ULONG SevenBitI2CAddress,
    IN ULONG Flags,
    IN ULONG DataLength,
    OUT PVOID Data
    );

typedef struct _DXGK_I2C_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    DXGKDDI_I2C_TRANSMIT_DATA_TO_DISPLAY  DxgkDdiI2CTransmitDataToDisplay;
    DXGKDDI_I2C_RECEIVE_DATA_FROM_DISPLAY DxgkDdiI2CReceiveDataFromDisplay;
} DXGK_I2C_INTERFACE, *PDXGK_I2C_INTERFACE;

//
// OPM Interface from the miniport.
//

#define DXGK_OPM_INTERFACE_VERSION_1 0x01

typedef
NTSTATUS
(*DXGKDDI_OPM_GET_CERTIFICATE_SIZE)(
    IN PVOID MiniportDeviceContext,
    IN DXGKMDT_CERTIFICATE_TYPE CertificateType,
    OUT PULONG CertificateSize
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_GET_CERTIFICATE)(
    IN PVOID MiniportDeviceContext,
    IN DXGKMDT_CERTIFICATE_TYPE CertificateType,
    IN ULONG CertificateSize,
    OUT PVOID CertificateBuffer
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_CREATE_PROTECTED_OUTPUT)(
    IN PVOID MiniportDeviceContext,
    IN D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId,
    IN DXGKMDT_OPM_VIDEO_OUTPUT_SEMANTICS NewVideoOutputSemantics,
    OUT PHANDLE NewProtectedOutputHandle
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_GET_RANDOM_NUMBER)(
    IN PVOID MiniportDeviceContext,
    IN HANDLE ProtectedOutputHandle,
    OUT PDXGKMDT_OPM_RANDOM_NUMBER RandomNumber
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS)(
    IN PVOID MiniportDeviceContext,
    IN HANDLE ProtectedOutputHandle,
    IN CONST PDXGKMDT_OPM_ENCRYPTED_PARAMETERS EncryptedParameters
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_GET_INFORMATION)(
    IN PVOID MiniportDeviceContext,
    IN HANDLE ProtectedOutputHandle,
    IN CONST PDXGKMDT_OPM_GET_INFO_PARAMETERS Parameters,
    OUT PDXGKMDT_OPM_REQUESTED_INFORMATION RequestedInformation
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_GET_COPP_COMPATIBLE_INFORMATION)(
    IN PVOID MiniportDeviceContext,
    IN HANDLE ProtectedOutputHandle,
    IN CONST PDXGKMDT_OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS Parameters,
    OUT PDXGKMDT_OPM_REQUESTED_INFORMATION RequestedInformation
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_CONFIGURE_PROTECTED_OUTPUT)(
    IN PVOID MiniportDeviceContext,
    IN HANDLE ProtectedOutputHandle,
    IN CONST PDXGKMDT_OPM_CONFIGURE_PARAMETERS Parameters,
    IN ULONG AdditionalParametersSize,
    IN CONST PVOID AdditionalParameters
    );

typedef
NTSTATUS
(*DXGKDDI_OPM_DESTROY_PROTECTED_OUTPUT)(
    IN PVOID MiniportDeviceContext,
    IN HANDLE ProtectedOutputHandle
    );

typedef struct _DXGK_OPM_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    DXGKDDI_OPM_GET_CERTIFICATE_SIZE                 DxgkDdiOPMGetCertificateSize;
    DXGKDDI_OPM_GET_CERTIFICATE                      DxgkDdiOPMGetCertificate;
    DXGKDDI_OPM_CREATE_PROTECTED_OUTPUT              DxgkDdiOPMCreateProtectedOutput;
    DXGKDDI_OPM_GET_RANDOM_NUMBER                    DxgkDdiOPMGetRandomNumber;
    DXGKDDI_OPM_SET_SIGNING_KEY_AND_SEQUENCE_NUMBERS DxgkDdiOPMSetSigningKeyAndSequenceNumbers;
    DXGKDDI_OPM_GET_INFORMATION                      DxgkDdiOPMGetInformation;
    DXGKDDI_OPM_GET_COPP_COMPATIBLE_INFORMATION      DxgkDdiOPMGetCOPPCompatibleInformation;
    DXGKDDI_OPM_CONFIGURE_PROTECTED_OUTPUT           DxgkDdiOPMConfigureProtectedOutput;
    DXGKDDI_OPM_DESTROY_PROTECTED_OUTPUT             DxgkDdiOPMDestroyProtectedOutput;
} DXGK_OPM_INTERFACE, *PDXGK_OPM_INTERFACE;


#define DXGK_BRIGHTNESS_INTERFACE_VERSION_1 0x01

typedef
NTSTATUS
(*DXGK_BRIGHTNESS_GET_POSSIBLE)(
    IN  PVOID  Context,
    IN  ULONG  BufferSize,
    OUT PUCHAR LevelCount,
    OUT PUCHAR BrightnessLevels
    );

typedef
NTSTATUS
(*DXGK_BRIGHTNESS_SET)(
    IN  PVOID  Context,
    IN  UCHAR  Brightness
    );

typedef
NTSTATUS
(*DXGK_BRIGHTNESS_GET)(
    IN  PVOID  Context,
    IN  PUCHAR Brightness
    );

typedef struct
{
    IN USHORT                           Size;
    IN USHORT                           Version;
    OUT PVOID                           Context;
    OUT PINTERFACE_REFERENCE            InterfaceReference;
    OUT PINTERFACE_DEREFERENCE          InterfaceDereference;
    OUT DXGK_BRIGHTNESS_GET_POSSIBLE    GetPossibleBrightness;
    OUT DXGK_BRIGHTNESS_SET             SetBrightness;
    OUT DXGK_BRIGHTNESS_GET             GetBrightness;
} DXGK_BRIGHTNESS_INTERFACE, *PDXGK_BRIGHTNESS_INTERFACE;

//
// Services exported by DxgkCbQueryServices()
//

typedef enum
{
    DxgkServicesAgp,
    DxgkServicesDebugReport,
    DxgkServicesTimedOperation
} DXGK_SERVICES;

//
// AGP Services
//

#define DXGK_AGP_INTERFACE_VERSION_1 0x01

#define DXGK_AGPCOMMAND_AGP1X       0x00001
#define DXGK_AGPCOMMAND_AGP2X       0x00002
#define DXGK_AGPCOMMAND_AGP4X       0x00004
#define DXGK_AGPCOMMAND_AGP8X       0x00008
#define DXGK_AGPCOMMAND_DISABLE_SBA 0x10000
#define DXGK_AGPCOMMAND_DISABLE_FW  0x20000

typedef
NTSTATUS
(APIENTRY *DXGKCB_AGP_ALLOCATE_POOL)(
    IN HANDLE Context,
    IN ULONG AllocationSize,
    IN MEMORY_CACHING_TYPE CacheType,
    OUT PPHYSICAL_ADDRESS PhysicalAddress,
    OUT PVOID *VirtualAddress
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_AGP_FREE_POOL)(
    IN HANDLE Context,
    IN PVOID VirtualAddress
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_AGP_SET_COMMAND)(
    IN HANDLE Context,
    IN ULONG Command
    );

typedef struct _DXGK_AGP_INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    DXGKCB_AGP_ALLOCATE_POOL AgpAllocatePool;
    DXGKCB_AGP_FREE_POOL AgpFreePool;
    DXGKCB_AGP_SET_COMMAND AgpSetCommand;
} DXGK_AGP_INTERFACE, *PDXGK_AGP_INTERFACE;

//
// Debug Report API
//

DECLARE_HANDLE(DXGK_DEBUG_REPORT_HANDLE);
#define DXGK_DEBUG_REPORT_INTERFACE_VERSION_1 0x01
#define DXGK_DEBUG_REPORT_MAX_SIZE 0xF800

typedef struct _DXGK_DEBUG_REPORT_INTERFACE
{
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    DXGK_DEBUG_REPORT_HANDLE
    (*DbgReportCreate)(
        IN HANDLE DeviceHandle,
        IN ULONG ulCode,
        IN ULONG_PTR ulpArg1,
        IN ULONG_PTR ulpArg2,
        IN ULONG_PTR ulpArg3,
        IN ULONG_PTR ulpArg4
        );

    BOOLEAN
    (*DbgReportSecondaryData)(
        IN OUT DXGK_DEBUG_REPORT_HANDLE hReport,
        IN __in_bcount(ulDataSize) PVOID pvData,
        IN ULONG ulDataSize
        );

    VOID
    (*DbgReportComplete)(
        IN OUT DXGK_DEBUG_REPORT_HANDLE hReport
        );
} DXGK_DEBUG_REPORT_INTERFACE, *PDXGK_DEBUG_REPORT_INTERFACE;

//
// Timed Operation API
//

#define DXGK_TIMED_OPERATION_INTERFACE_VERSION_1    0x01
#define DXGK_TIMED_OPERATION_TIMEOUT_MAX_SECONDS    5

typedef struct _DXGK_TIMED_OPERATION
{
    USHORT Size;
    ULONG_PTR OwnerTag;
    BOOLEAN OsHandled;
    BOOLEAN TimeoutTriggered;
    LARGE_INTEGER Timeout;
    LARGE_INTEGER StartTick;
} DXGK_TIMED_OPERATION, *PDXGK_TIMED_OPERATION;

typedef struct _DXGK_TIMED_OPERATION_INTERFACE
{
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    NTSTATUS
    (*TimedOperationStart)(
        OUT DXGK_TIMED_OPERATION* Op,
        IN const LARGE_INTEGER* Timeout,
        IN BOOLEAN OsHandled
        );

    NTSTATUS
    (*TimedOperationDelay)(
        IN OUT DXGK_TIMED_OPERATION* Op,
        IN KPROCESSOR_MODE  WaitMode,
        IN BOOLEAN  Alertable,
        IN const LARGE_INTEGER* Interval OPTIONAL
        );

    NTSTATUS
    (*TimedOperationWaitForSingleObject)(
        IN OUT DXGK_TIMED_OPERATION* Op,
        IN PVOID Object,
        IN KWAIT_REASON WaitReason,
        IN KPROCESSOR_MODE WaitMode,
        IN BOOLEAN Alertable,
        IN const LARGE_INTEGER* Timeout OPTIONAL
        );
} DXGK_TIMED_OPERATION_INTERFACE, *PDXGK_TIMED_OPERATION_INTERFACE;

typedef enum {
    DockStateUnsupported = 0,
    DockStateUnDocked    = 1,
    DockStateDocked      = 2,
    DockStateUnknown     = 3,
} DOCKING_STATE;

//
// Device Information Structure to provide OS provided data
// structures to the miniport
//

typedef struct _DXGK_DEVICE_INFO {
    PVOID MiniportDeviceContext;
    PDEVICE_OBJECT PhysicalDeviceObject;
    UNICODE_STRING DeviceRegistryPath;
    PCM_RESOURCE_LIST TranslatedResourceList;
    LARGE_INTEGER SystemMemorySize;
    PHYSICAL_ADDRESS HighestPhysicalAddress;
    PHYSICAL_ADDRESS AgpApertureBase;
    SIZE_T AgpApertureSize;
    DOCKING_STATE DockingState;
} DXGK_DEVICE_INFO, *PDXGK_DEVICE_INFO;

//
// DxgKrnl interface
//

#define DXGK_ACPI_PASS_ARGS_TO_CHILDREN 'araP'

typedef
NTSTATUS
(APIENTRY *DXGKCB_EVAL_ACPI_METHOD)(
    IN HANDLE DeviceHandle,
    IN ULONG DeviceUid,
    IN PACPI_EVAL_INPUT_BUFFER_COMPLEX AcpiInputBuffer,
    IN ULONG AcpiInputSize,
    IN OUT PACPI_EVAL_OUTPUT_BUFFER AcpiOutputBuffer,
    IN ULONG AcpiOutputSize
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_GET_DEVICE_INFORMATION)(
    IN HANDLE DeviceHandle,
    OUT PDXGK_DEVICE_INFO DeviceInfo
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_INDICATE_CHILD_STATUS)(
    IN HANDLE DeviceHandle,
    IN PDXGK_CHILD_STATUS ChildStatus
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_MAP_MEMORY)(
    IN HANDLE DeviceHandle,
    IN PHYSICAL_ADDRESS TranslatedAddress,
    IN ULONG Length,
    IN BOOLEAN InIoSpace,
    IN BOOLEAN MapToUserMode,
    IN MEMORY_CACHING_TYPE CacheType,
    OUT PVOID *VirtualAddress
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_QUERY_SERVICES)(
    IN HANDLE DeviceHandle,
    IN DXGK_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

typedef
BOOLEAN
(APIENTRY *DXGKCB_QUEUE_DPC)(
    IN HANDLE DeviceHandle
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_READ_DEVICE_SPACE)(
    IN HANDLE DeviceHandle,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG BytesRead
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_SYNCHRONIZE_EXECUTION)(
    IN HANDLE DeviceHandle,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID Context,
    IN ULONG MessageNumber,
    OUT PBOOLEAN ReturnValue
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_UNMAP_MEMORY)(
    IN HANDLE DeviceHandle,
    IN PVOID VirtualAddress
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_WRITE_DEVICE_SPACE)(
    IN HANDLE DeviceHandle,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_IS_DEVICE_PRESENT)(
    IN HANDLE DeviceHandle,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS DevicePresenceParameters,
    OUT PBOOLEAN DevicePresent
    );

typedef
VOID
(APIENTRY *DXGKCB_LOG_ETW_EVENT)(
    IN CONST LPCGUID EventGuid,
    IN UCHAR Type,
    IN USHORT EventBufferSize,
    IN PVOID EventBuffer
    );

typedef
NTSTATUS
(APIENTRY *DXGKCB_EXCLUDE_ADAPTER_ACCESS)(
    IN HANDLE DeviceHandle,
    IN ULONG Attributes,
    IN DXGKDDI_PROTECTED_CALLBACK DxgkProtectedCallback,
    IN PVOID ProtectedCallbackContext
    );

typedef struct _DXGK_START_INFO {
    ULONG                          RequiredDmaQueueEntry;
    GUID                           AdapterGuid;
} DXGK_START_INFO, *PDXGK_START_INFO;

typedef struct _DXGKRNL_INTERFACE {
    ULONG                          Size;
    ULONG                          Version;
    HANDLE                         DeviceHandle;

    DXGKCB_EVAL_ACPI_METHOD        DxgkCbEvalAcpiMethod;
    DXGKCB_GET_DEVICE_INFORMATION  DxgkCbGetDeviceInformation;
    DXGKCB_INDICATE_CHILD_STATUS   DxgkCbIndicateChildStatus;
    DXGKCB_MAP_MEMORY              DxgkCbMapMemory;
    DXGKCB_QUEUE_DPC               DxgkCbQueueDpc;
    DXGKCB_QUERY_SERVICES          DxgkCbQueryServices;
    DXGKCB_READ_DEVICE_SPACE       DxgkCbReadDeviceSpace;
    DXGKCB_SYNCHRONIZE_EXECUTION   DxgkCbSynchronizeExecution;
    DXGKCB_UNMAP_MEMORY            DxgkCbUnmapMemory;
    DXGKCB_WRITE_DEVICE_SPACE      DxgkCbWriteDeviceSpace;
    DXGKCB_IS_DEVICE_PRESENT       DxgkCbIsDevicePresent;

    DXGKCB_GETHANDLEDATA           DxgkCbGetHandleData;
    DXGKCB_GETHANDLEPARENT         DxgkCbGetHandleParent;
    DXGKCB_ENUMHANDLECHILDREN      DxgkCbEnumHandleChildren;
    DXGKCB_NOTIFY_INTERRUPT        DxgkCbNotifyInterrupt;
    DXGKCB_NOTIFY_DPC              DxgkCbNotifyDpc;
    DXGKCB_QUERYVIDPNINTERFACE     DxgkCbQueryVidPnInterface;
    DXGKCB_QUERYMONITORINTERFACE   DxgkCbQueryMonitorInterface;
    DXGKCB_GETCAPTUREADDRESS       DxgkCbGetCaptureAddress;

    DXGKCB_LOG_ETW_EVENT           DxgkCbLogEtwEvent;

    DXGKCB_EXCLUDE_ADAPTER_ACCESS  DxgkCbExcludeAdapterAccess;
} DXGKRNL_INTERFACE, *PDXGKRNL_INTERFACE;

//
// Kernel Mode Driver Interface
//

//
//  Define parameter types for SAL-annotated DDI parameters.  These are used by
//  the DDI function name typedefs.  They are not needed in a driver's DDI function
//  definitions, and should not be used in driver code.
//
//  Naming convention: Concatenate all SAL annotations, an underscore, other modifiers
//                     such as CONST, and the type of the parameter, and use uppercase
//                     only.
//
typedef __in    CONST PDEVICE_OBJECT     IN_CONST_PDEVICE_OBJECT;
typedef __inout PLINKED_DEVICE           INOUT_PLINKED_DEVICE;
typedef __inout PDXGK_CHILD_DESCRIPTOR   INOUT_PDXGK_CHILD_DESCRIPTOR;
typedef __in    PDXGK_CHILD_STATUS       IN_PDXGK_CHILD_STATUS;
typedef __inout PDXGK_DEVICE_DESCRIPTOR  INOUT_PDXGK_DEVICE_DESCRIPTOR;
typedef __in    DXGK_EVENT_TYPE          IN_DXGK_EVENT_TYPE;
typedef __in    PDXGK_START_INFO         IN_PDXGK_START_INFO;
typedef __in    PDXGKRNL_INTERFACE       IN_PDXGKRNL_INTERFACE;
typedef __in    PQUERY_INTERFACE         IN_PQUERY_INTERFACE;
typedef __in    PVIDEO_REQUEST_PACKET    IN_PVIDEO_REQUEST_PACKET;

//
//     Function name typedefs
//

typedef
    __checkReturn
NTSTATUS
DXGKDDI_ADD_DEVICE(
    IN_CONST_PDEVICE_OBJECT     PhysicalDeviceObject,
    OUT_PPVOID                  MiniportDeviceContext
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_START_DEVICE(
    IN_CONST_PVOID          MiniportDeviceContext,
    IN_PDXGK_START_INFO     DxgkStartInfo,
    IN_PDXGKRNL_INTERFACE   DxgkInterface,
    OUT_PULONG              NumberOfVideoPresentSources,
    OUT_PULONG              NumberOfChildren
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_STOP_DEVICE(
    IN_CONST_PVOID  MiniportDeviceContext
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_REMOVE_DEVICE(
    IN_CONST_PVOID  MiniportDeviceContext
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_DISPATCH_IO_REQUEST(
    IN_CONST_PVOID              MiniportDeviceContext,
    IN_ULONG                    VidPnSourceId,
    IN_PVIDEO_REQUEST_PACKET    VideoRequestPacket
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_QUERY_CHILD_RELATIONS(
    IN_CONST_PVOID                  MiniportDeviceContext,
    INOUT_PDXGK_CHILD_DESCRIPTOR    ChildRelations,
    IN_ULONG                        ChildRelationsSize
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_QUERY_CHILD_STATUS(
    IN_CONST_PVOID          MiniportDeviceContext,
    IN_PDXGK_CHILD_STATUS   ChildStatus,
    IN_BOOLEAN              NonDestructiveOnly
    );

typedef
    __checkReturn
BOOLEAN
DXGKDDI_INTERRUPT_ROUTINE(
    IN_CONST_PVOID  MiniportDeviceContext,
    IN_ULONG        MessageNumber
    );

typedef
VOID
DXGKDDI_DPC_ROUTINE(
    IN_CONST_PVOID  MiniportDeviceContext
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_QUERY_DEVICE_DESCRIPTOR(
    IN_CONST_PVOID                  MiniportDeviceContext,
    IN_ULONG                        ChildUid,
    INOUT_PDXGK_DEVICE_DESCRIPTOR   DeviceDescriptor
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_SET_POWER_STATE(
    IN_CONST_PVOID          MiniportDeviceContext,
    IN_ULONG                DeviceUid,
    IN_DEVICE_POWER_STATE   DevicePowerState,
    IN_POWER_ACTION         ActionType
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_NOTIFY_ACPI_EVENT(
    IN_CONST_PVOID      MiniportDeviceContext,
    IN_DXGK_EVENT_TYPE  EventType,
    IN_ULONG            Event,
    IN_PVOID            Argument,
    OUT_PULONG          AcpiFlags
    );

typedef
VOID
DXGKDDI_RESET_DEVICE(
    IN_CONST_PVOID  MiniportDeviceContext
    );

typedef
VOID
DXGKDDI_UNLOAD(
    VOID
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_QUERY_INTERFACE(
    IN_CONST_PVOID          MiniportDeviceContext,
    IN_PQUERY_INTERFACE     QueryInterface
    );

typedef
VOID
DXGKDDI_CONTROL_ETW_LOGGING(
    IN_BOOLEAN  Enable,
    IN_ULONG    Flags,
    IN_UCHAR    Level
    );

typedef
    __checkReturn
NTSTATUS
DXGKDDI_LINK_DEVICE(
    IN_CONST_PDEVICE_OBJECT   PhysicalDeviceObject,
    IN_CONST_PVOID            MiniportDeviceContext,
    INOUT_PLINKED_DEVICE      LinkedDevice
    );

//
//     Function pointer typedefs
//

typedef DXGKDDI_ADD_DEVICE              *PDXGKDDI_ADD_DEVICE;
typedef DXGKDDI_START_DEVICE            *PDXGKDDI_START_DEVICE;
typedef DXGKDDI_STOP_DEVICE             *PDXGKDDI_STOP_DEVICE;
typedef DXGKDDI_REMOVE_DEVICE           *PDXGKDDI_REMOVE_DEVICE;
typedef DXGKDDI_DISPATCH_IO_REQUEST     *PDXGKDDI_DISPATCH_IO_REQUEST;
typedef DXGKDDI_QUERY_CHILD_RELATIONS   *PDXGKDDI_QUERY_CHILD_RELATIONS;
typedef DXGKDDI_QUERY_CHILD_STATUS      *PDXGKDDI_QUERY_CHILD_STATUS;
typedef DXGKDDI_INTERRUPT_ROUTINE       *PDXGKDDI_INTERRUPT_ROUTINE;
typedef DXGKDDI_DPC_ROUTINE             *PDXGKDDI_DPC_ROUTINE;
typedef DXGKDDI_QUERY_DEVICE_DESCRIPTOR *PDXGKDDI_QUERY_DEVICE_DESCRIPTOR;
typedef DXGKDDI_SET_POWER_STATE         *PDXGKDDI_SET_POWER_STATE;
typedef DXGKDDI_NOTIFY_ACPI_EVENT       *PDXGKDDI_NOTIFY_ACPI_EVENT;
typedef DXGKDDI_RESET_DEVICE            *PDXGKDDI_RESET_DEVICE;
typedef DXGKDDI_UNLOAD                  *PDXGKDDI_UNLOAD;
typedef DXGKDDI_QUERY_INTERFACE         *PDXGKDDI_QUERY_INTERFACE;
typedef DXGKDDI_CONTROL_ETW_LOGGING     *PDXGKDDI_CONTROL_ETW_LOGGING;
typedef DXGKDDI_LINK_DEVICE             *PDXGKDDI_LINK_DEVICE;

//
// Driver initialization data structure
//

typedef struct _DRIVER_INITIALIZATION_DATA {
    ULONG                                   Version;
    PDXGKDDI_ADD_DEVICE                     DxgkDdiAddDevice;
    PDXGKDDI_START_DEVICE                   DxgkDdiStartDevice;
    PDXGKDDI_STOP_DEVICE                    DxgkDdiStopDevice;
    PDXGKDDI_REMOVE_DEVICE                  DxgkDdiRemoveDevice;
    PDXGKDDI_DISPATCH_IO_REQUEST            DxgkDdiDispatchIoRequest;
    PDXGKDDI_INTERRUPT_ROUTINE              DxgkDdiInterruptRoutine;
    PDXGKDDI_DPC_ROUTINE                    DxgkDdiDpcRoutine;
    PDXGKDDI_QUERY_CHILD_RELATIONS          DxgkDdiQueryChildRelations;
    PDXGKDDI_QUERY_CHILD_STATUS             DxgkDdiQueryChildStatus;
    PDXGKDDI_QUERY_DEVICE_DESCRIPTOR        DxgkDdiQueryDeviceDescriptor;
    PDXGKDDI_SET_POWER_STATE                DxgkDdiSetPowerState;
    PDXGKDDI_NOTIFY_ACPI_EVENT              DxgkDdiNotifyAcpiEvent;
    PDXGKDDI_RESET_DEVICE                   DxgkDdiResetDevice;
    PDXGKDDI_UNLOAD                         DxgkDdiUnload;
    PDXGKDDI_QUERY_INTERFACE                DxgkDdiQueryInterface;
    PDXGKDDI_CONTROL_ETW_LOGGING            DxgkDdiControlEtwLogging;

    PDXGKDDI_QUERYADAPTERINFO               DxgkDdiQueryAdapterInfo;
    PDXGKDDI_CREATEDEVICE                   DxgkDdiCreateDevice;
    PDXGKDDI_CREATEALLOCATION               DxgkDdiCreateAllocation;
    PDXGKDDI_DESTROYALLOCATION              DxgkDdiDestroyAllocation;
    PDXGKDDI_DESCRIBEALLOCATION             DxgkDdiDescribeAllocation;
    PDXGKDDI_GETSTANDARDALLOCATIONDRIVERDATA DxgkDdiGetStandardAllocationDriverData;
    PDXGKDDI_ACQUIRESWIZZLINGRANGE          DxgkDdiAcquireSwizzlingRange;
    PDXGKDDI_RELEASESWIZZLINGRANGE          DxgkDdiReleaseSwizzlingRange;
    PDXGKDDI_PATCH                          DxgkDdiPatch;
    PDXGKDDI_SUBMITCOMMAND                  DxgkDdiSubmitCommand;
    PDXGKDDI_PREEMPTCOMMAND                 DxgkDdiPreemptCommand;
    PDXGKDDI_BUILDPAGINGBUFFER              DxgkDdiBuildPagingBuffer;
    PDXGKDDI_SETPALETTE                     DxgkDdiSetPalette;
    PDXGKDDI_SETPOINTERPOSITION             DxgkDdiSetPointerPosition;
    PDXGKDDI_SETPOINTERSHAPE                DxgkDdiSetPointerShape;
    PDXGKDDI_RESETFROMTIMEOUT               DxgkDdiResetFromTimeout;
    PDXGKDDI_RESTARTFROMTIMEOUT             DxgkDdiRestartFromTimeout;
    PDXGKDDI_ESCAPE                         DxgkDdiEscape;
    PDXGKDDI_COLLECTDBGINFO                 DxgkDdiCollectDbgInfo;
    PDXGKDDI_QUERYCURRENTFENCE              DxgkDdiQueryCurrentFence;
    PDXGKDDI_ISSUPPORTEDVIDPN               DxgkDdiIsSupportedVidPn;
    PDXGKDDI_RECOMMENDFUNCTIONALVIDPN       DxgkDdiRecommendFunctionalVidPn;
    PDXGKDDI_ENUMVIDPNCOFUNCMODALITY        DxgkDdiEnumVidPnCofuncModality;
    PDXGKDDI_SETVIDPNSOURCEADDRESS          DxgkDdiSetVidPnSourceAddress;
    PDXGKDDI_SETVIDPNSOURCEVISIBILITY       DxgkDdiSetVidPnSourceVisibility;
    PDXGKDDI_COMMITVIDPN                    DxgkDdiCommitVidPn;
    PDXGKDDI_UPDATEACTIVEVIDPNPRESENTPATH   DxgkDdiUpdateActiveVidPnPresentPath;
    PDXGKDDI_RECOMMENDMONITORMODES          DxgkDdiRecommendMonitorModes;
    PDXGKDDI_RECOMMENDVIDPNTOPOLOGY         DxgkDdiRecommendVidPnTopology;
    PDXGKDDI_GETSCANLINE                    DxgkDdiGetScanLine;
    PDXGKDDI_STOPCAPTURE                    DxgkDdiStopCapture;
    PDXGKDDI_CONTROLINTERRUPT               DxgkDdiControlInterrupt;
    PDXGKDDI_CREATEOVERLAY                  DxgkDdiCreateOverlay;

    //
    // Device functions
    //

    PDXGKDDI_DESTROYDEVICE                  DxgkDdiDestroyDevice;
    PDXGKDDI_OPENALLOCATIONINFO             DxgkDdiOpenAllocation;
    PDXGKDDI_CLOSEALLOCATION                DxgkDdiCloseAllocation;
    PDXGKDDI_RENDER                         DxgkDdiRender;
    PDXGKDDI_PRESENT                        DxgkDdiPresent;

    //
    // Overlay functions
    //

    PDXGKDDI_UPDATEOVERLAY                  DxgkDdiUpdateOverlay;
    PDXGKDDI_FLIPOVERLAY                    DxgkDdiFlipOverlay;
    PDXGKDDI_DESTROYOVERLAY                 DxgkDdiDestroyOverlay;

    //
    // Context supports.
    //

    PDXGKDDI_CREATECONTEXT                  DxgkDdiCreateContext;
    PDXGKDDI_DESTROYCONTEXT                 DxgkDdiDestroyContext;

    //
    // Linked Display Adapter support.
    //

    PDXGKDDI_LINK_DEVICE                    DxgkDdiLinkDevice;
    PDXGKDDI_SETDISPLAYPRIVATEDRIVERFORMAT  DxgkDdiSetDisplayPrivateDriverFormat;
} DRIVER_INITIALIZATION_DATA, *PDRIVER_INITIALIZATION_DATA;

//
// *** Displib definitions ****************************************************
//

typedef enum _DEBUG_LEVEL {
    DlDebugError,
    DlDebugWarning,
    DlDebugTrace,
    DlDebugInfo
} DEBUG_LEVEL;

//
// Functions exported by DispLib
//

NTSTATUS
DxgkInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_INITIALIZATION_DATA DriverInitializationData
    );

PVOID
DlAllocateCommonBuffer(
    IN PVOID DeviceHandle,
    IN PVP_DMA_ADAPTER DlpDmaAdapter,
    IN ULONG DesiredLength,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled,
    OUT PVOID Reserved
    );

PVOID
DlAllocatePool(
    IN PVOID DeviceHandle,
    IN VP_POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
DlClearEvent(
    IN PVOID DeviceHandle,
    IN PEVENT pEvent
    );

VP_STATUS
DlCreateEvent(
    IN PVOID DeviceHandle,
    IN ULONG EventFlag,
    PVOID Unused,
    OUT PEVENT *ppEvent
    );

VOID
DlDebugPrint(
    IN DEBUG_LEVEL DebugPrintLevel,
    IN __in PCHAR DebugMessage,
    ...
    );

VP_STATUS
DlDeleteEvent(
    IN PVOID DeviceHandle,
    IN PEVENT pEvent
    );

VP_STATUS
DlEnumerateChildren(
    IN PVOID DeviceHandle,
    IN PVOID Reserved
    );

VOID
DlFreeDeviceBase(
    IN PVOID DeviceHandle,
    IN PVOID MappedAddress
    );

VOID
DlFreePool(
    IN PVOID DeviceHandle,
    IN PVOID Ptr
    );

NTSTATUS
DlGetAccessRanges(
    PVOID DeviceHandle,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    );

PVOID
DlGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    );

PVOID
DlGetDeviceBase(
    IN PVOID DeviceHandle,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace
    );

PVP_DMA_ADAPTER
DlGetDmaAdapter(
    IN PVOID DeviceHandle,
    IN PVP_DEVICE_DESCRIPTION DlpDeviceDescription
    );

VP_STATUS
DlGetRegistryParameters(
    IN PVOID DeviceHandle,
    IN __in PWSTR ParameterName,
    IN UCHAR IsParameterFileName,
    IN PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    IN PVOID Context
    );

__allocator
PVOID
DlGetRomImage(
    IN PVOID DeviceHandle,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    );

VP_STATUS
DlGetVersion(
    IN PVOID DeviceHandle,
    OUT PVPOSVERSIONINFO pDlpOsVersionInfo
    );

PVOID
DlLockBuffer(
    IN PVOID DeviceHandle,
    IN PVOID BaseAddress,
    IN ULONG Length,
    IN VP_LOCK_OPERATION Operation
    );

VOID
DlLogError(
    IN PVOID DeviceHandle,
    IN PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    IN VP_STATUS ErrorCode,
    IN ULONG UniqueId
    );

VP_STATUS
DlMapMemory(
    IN PVOID DeviceHandle,
    IN PHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG Length,
    IN PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    );

LONGLONG
DlQueryPerformanceCounter(
    IN PVOID pDeviceHandle,
    OUT PLONGLONG pllPerformanceFrequency OPTIONAL
    );

VOID
DlReleaseCommonBuffer(
    IN PVOID DeviceHandle,
    IN PVP_DMA_ADAPTER DlpDmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

BOOLEAN
DlScanRom(
    IN PVOID DeviceHandle,
    IN PUCHAR RomBase,
    IN ULONG RomLength,
    IN PUCHAR String
    );

LONG
DlSetEvent(
    IN PVOID DeviceHandle,
    IN PEVENT pEvent
    );

VP_STATUS
DlSetRegistryParameters(
    IN PVOID DeviceHandle,
    IN __in PWSTR ValueName,
    IN __in_bcount(ValueLength) PVOID ValueData,
    IN ULONG ValueLength
    );

VP_STATUS
DlSetTrappedEmulatorPorts(
    IN PVOID DeviceHandle,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRange
    );

VOID
DlStopTimer(
    PVOID DeviceHandle
    );

VOID
DlUnlockBuffer(
    IN PVOID DeviceHandle,
    IN PVOID Mdl
    );

VP_STATUS
DlVerifyAccessRanges(
    PVOID DeviceHandle,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VP_STATUS
DlWaitForSingleObject(
    IN PVOID DeviceHandle,
    IN PVOID pEvent,
    IN PLARGE_INTEGER Timeout
    );

VP_STATUS
DlDisableInterrupt(
    IN PVOID DeviceHandle
    );

VP_STATUS
DlEnableInterrupt(
    IN PVOID DeviceHandle
    );

NTSTATUS
DlEvalAcpiMethod(
    IN HANDLE DeviceHandle,
    IN ULONG DeviceUid,
    IN PACPI_EVAL_INPUT_BUFFER_COMPLEX AcpiInputBuffer,
    IN ULONG AcpiInputSize,
    IN OUT PACPI_EVAL_OUTPUT_BUFFER AcpiOutputBuffer,
    IN ULONG AcpiOutputSize
    );

NTSTATUS
DlGetDeviceInformation(
    IN PVOID DeviceHandle,
    OUT PDXGK_DEVICE_INFO DeviceInfo
    );

NTSTATUS
DlIndicateChildStatus(
    IN PVOID DeviceHandle,
    IN PDXGK_CHILD_STATUS ChildStatus
    );

NTSTATUS
DlMapMemoryEx(
    IN PVOID DeviceHandle,
    IN PHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG Length,
    IN PULONG InIoSpace,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *VirtualAddress,
    IN BOOLEAN MapToUserMode
    );

NTSTATUS
DlQueryServices(
    IN PVOID DeviceHandle,
    IN VIDEO_PORT_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

BOOLEAN
DlQueueDpc(
    IN PVOID DeviceHandle
    );

ULONG
DlReadDeviceSpace(
    IN PVOID DeviceHandle,
    IN ULONG DataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
DlSetBusData(
    IN PVOID DeviceHandle,
    IN ULONG BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

BOOLEAN
DlSynchronizeExecution(
    PVOID DeviceHandle,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context,
    ULONG MessageNumber
    );

NTSTATUS
DlUnmapMemory(
    PVOID DeviceHandle,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    );

#pragma warning(pop)

#endif // _DISPMPRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\d4iface.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    D4iface.h

Abstract:

    DOT4 Interface


--*/

#ifndef _DOT4_IFACE_H
#define _DOT4_IFACE_H

#ifdef __cplusplus
extern "C" {      
#endif
//////////////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Defines
//////////////////////////////////////////////////////////////////////////////
#define DOT4_MAX_CHANNELS            128

#define NO_TIMEOUT                  0


//
// DOT4 Channel types
//
#define STREAM_TYPE_CHANNEL         1
#define PACKET_TYPE_CHANNEL         2


//
// DOT4 broadcast Activity messages
//
#define DOT4_STREAM_RECEIVED    0x100
#define DOT4_STREAM_CREDITS     0x101
#define DOT4_MESSAGE_RECEIVED   0x102       // Message is received
#define DOT4_DISCONNECT         0x103       // The link was disconnected
#define DOT4_CHANNEL_CLOSED     0x105       // A channel was closed

//
// DOT4 Channels
//
#define DOT4_CHANNEL                 0
#define HP_MESSAGE_PROCESSOR        1
#define PRINTER_CHANNEL             2
// As of revision 3.7 of the DOT4 specification, socket 3 had no assignment
#define SCANNER_CHANNEL             4
#define MIO_COMMAND_PROCESSOR       5
#define ECHO_CHANNEL                6
#define FAX_SEND_CHANNEL            7
#define FAX_RECV_CHANNEL            8
#define DIAGNOSTIC_CHANNEL          9
#define HP_RESERVED                 10
#define IMAGE_DOWNLOAD              11
#define HOST_DATASTORE_UPLOAD       12
#define HOST_DATASTORE_DOWNLOAD     13
#define CONFIG_UPLOAD               14
#define CONFIG_DOWNLOAD             15


//////////////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////////////
typedef unsigned long CHANNEL_HANDLE;

typedef CHANNEL_HANDLE *PCHANNEL_HANDLE;


typedef struct _DOT4_ACTIVITY
{
    ULONG ulMessage;

    ULONG ulByteCount;

    CHANNEL_HANDLE hChannel;

} DOT4_ACTIVITY, *PDOT4_ACTIVITY;


//////////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
// end of extern "C"
}
#endif

#endif // _DOT4_IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dsfhrmports.h ===
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dmusicks.h ===
/***************************************************************************
*                                                                          *
*   DMusicKS.h -- This module defines the the DirectMusic WDM interface.   *
*                                                                          *
*   Copyright (c) Microsoft Corp. All rights reserved.                     *
*                                                                          *
***************************************************************************/

#ifndef _DMUSICKS_
#define _DMUSICKS_

#include <dmusprop.h>

#define DONT_HOLD_FOR_SEQUENCING 0x8000000000000000

typedef struct _DMUS_KERNEL_EVENT
{                                           //  this    offset
    BYTE            bReserved;              //  1       0
    BYTE            cbStruct;               //  1       1
    USHORT          cbEvent;                //  2       2
    USHORT          usChannelGroup;         //  2       4
    USHORT          usFlags;                //  2       6
    REFERENCE_TIME  ullPresTime100ns;       //  8       8
    ULONGLONG       ullBytePosition;        //  8      16
    _DMUS_KERNEL_EVENT *pNextEvt;           //  4 (8)  24
    union
    {
        BYTE        abData[sizeof(PBYTE)];  //  4 (8)  28 (32)
        PBYTE       pbData;
        _DMUS_KERNEL_EVENT *pPackageEvt;
    } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;   //         32 (40)

#define DMUS_KEF_EVENT_COMPLETE     0x0000
#define DMUS_KEF_EVENT_INCOMPLETE   0x0001  //  This event is an incomplete package or sysex.
                                            //  Do not use this data.

#define DMUS_KEF_PACKAGE_EVENT      0x0002  //  This event is a package. The uData.pPackageEvt
                                            //  field contains a pointer to a chain of events.

#define kBytePositionNone   (~(ULONGLONG)0) //  This message has no meaningful byte position

#define SHORT_EVT(evt)       ((evt)->cbEvent <= sizeof(PBYTE))
#define PACKAGE_EVT(evt)     ((evt)->usFlags & DMUS_KEF_PACKAGE_EVENT)
#define INCOMPLETE_EVT(evt)  ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE)
#define COMPLETE_EVT(evt)    (((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE) == 0)

#define SET_INCOMPLETE_EVT(evt) ((evt)->usFlags |= DMUS_KEF_EVENT_INCOMPLETE)
#define SET_COMPLETE_EVT(evt)   ((evt)->usFlags &= (~DMUS_KEF_EVENT_INCOMPLETE))
#define SET_PACKAGE_EVT(evt)    ((evt)->usFlags |= DMUS_KEF_PACKAGE_EVENT)
#define CLEAR_PACKAGE_EVT(evt)  ((evt)->usFlags &= (~DMUS_KEF_PACKAGE_EVENT))


#define STATIC_CLSID_PortDMus\
    0xb7902fe9, 0xfb0a, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("b7902fe9-fb0a-11d1-81b0-0060083316c1", CLSID_PortDMus);
#define CLSID_PortDMus DEFINE_GUIDNAMED(CLSID_PortDMus)

#define STATIC_CLSID_MiniportDriverDMusUART\
    0xd3f0ce1c, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1c-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUART);
#define CLSID_MiniportDriverDMusUART DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUART)

#define STATIC_CLSID_MiniportDriverDMusUARTCapture\
    0xd3f0ce1d, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1d-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUARTCapture);
#define CLSID_MiniportDriverDMusUARTCapture DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUARTCapture)

#define STATIC_IID_IPortDMus\
    0xc096df9c, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9c-fb09-11d1-81b0-0060083316c1", IID_IPortDMus);
#define IID_IPortDMus DEFINE_GUIDNAMED(IID_IPortDMus)

#define STATIC_IID_IMiniportDMus\
    0xc096df9d, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9d-fb09-11d1-81b0-0060083316c1", IID_IMiniportDMus);
#define IID_IMiniportDMus DEFINE_GUIDNAMED(IID_IMiniportDMus)

#define STATIC_IID_IMXF\
    0xc096df9e, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9e-fb09-11d1-81b0-0060083316c1", IID_IMXF);
#define IID_IMXF DEFINE_GUIDNAMED(IID_IMXF)

#define STATIC_IID_IAllocatorMXF\
    0xa5f0d62c, 0xb30f, 0x11d2, 0xb7, 0xa3, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("a5f0d62c-b30f-11d2-b7a3-0060083316c1", IID_IAllocatorMXF);
#define IID_IAllocatorMXF DEFINE_GUIDNAMED(IID_IAllocatorMXF)

#define STATIC_IID_ISynthSinkDMus\
    0x1f476974, 0x679b, 0x11d2, 0x8f, 0x7d, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("1f476974-679b-11d2-8f7d-00c04fbf8fef", IID_ISynthSinkDMus);
#define IID_ISynthSinkDMus DEFINE_GUIDNAMED(IID_ISynthSinkDMus)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_OUT\
    0xA4DF0EB5, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("A4DF0EB5-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_OUT);
#define KSAUDFNAME_DMUSIC_MPU_OUT DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_OUT)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_IN\
    0xB2EC0A7D, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("B2EC0A7D-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_IN);
#define KSAUDFNAME_DMUSIC_MPU_IN DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_IN)


/*****************************************************************************
 * IPortDMus
 *****************************************************************************
 * Interface for DMusic port lower edge.
 */
DECLARE_INTERFACE_(IPortDMus,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort

    //  For IPortDMus
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup    OPTIONAL
    )   PURE;

    STDMETHOD_(void,RegisterServiceGroup)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup
    )   PURE;
};

typedef IPortDMus *PPORTDMUS;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortDMus\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP   ServiceGroup    OPTIONAL\
    );\
    STDMETHODIMP_(void) RegisterServiceGroup\
    (   IN      PSERVICEGROUP   ServiceGroup\
    )
#endif  /* PC_IMPLEMENTATION */


/*****************************************************************************
 * IMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IMXF;
typedef IMXF *PMXF;

#if !defined(DEFINE_ABSTRACT_MXF)

#define DEFINE_ABSTRACT_MXF()                                   \
    STDMETHOD_(NTSTATUS,SetState)                               \
    (   THIS_                                                   \
        IN      KSSTATE State                                   \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,PutMessage)                             \
    (   THIS_                                                   \
        IN      PDMUS_KERNEL_EVENT  pDMKEvt                     \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,ConnectOutput)                          \
    (   THIS_                                                   \
        IN      PMXF    sinkMXF                                 \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,DisconnectOutput)                       \
    (   THIS_                                                   \
        IN      PMXF    sinkMXF                                 \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_MXF)

DECLARE_INTERFACE_(IMXF,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF
};

#define IMP_IMXF\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE State\
    );\
    STDMETHODIMP_(NTSTATUS) PutMessage\
    (   IN      PDMUS_KERNEL_EVENT  pDMKEvt\
    );\
    STDMETHODIMP_(NTSTATUS) ConnectOutput\
    (   IN      PMXF    sinkMXF\
    );\
    STDMETHODIMP_(NTSTATUS) DisconnectOutput\
    (   IN      PMXF    sinkMXF\
    );\

/*****************************************************************************
 * IAllocatorMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IAllocatorMXF;
typedef IAllocatorMXF *PAllocatorMXF;

DECLARE_INTERFACE_(IAllocatorMXF,IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF

    //  For IAllocatorMXF
    STDMETHOD_(NTSTATUS,GetMessage)
    (   THIS_
        OUT     PDMUS_KERNEL_EVENT * ppDMKEvt
    )   PURE;

    STDMETHOD_(USHORT,GetBufferSize)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,GetBuffer)
    (   THIS_
        OUT     PBYTE * ppBuffer
    )   PURE;

    STDMETHOD_(NTSTATUS,PutBuffer)
    (   THIS_
        IN      PBYTE   pBuffer
    )   PURE;
};

#define IMP_IAllocatorMXF\
    IMP_IMXF;\
    STDMETHODIMP_(NTSTATUS) GetMessage\
    (   OUT     PDMUS_KERNEL_EVENT * ppDMKEvt\
    );\
    STDMETHODIMP_(USHORT) GetBufferSize\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) GetBuffer\
    (   OUT     PBYTE * ppBuffer\
    );\
    STDMETHODIMP_(NTSTATUS) PutBuffer\
    (   IN      PBYTE   pBuffer\
    );\


typedef enum
{
    DMUS_STREAM_MIDI_INVALID = -1,
    DMUS_STREAM_MIDI_RENDER = 0,
    DMUS_STREAM_MIDI_CAPTURE,
    DMUS_STREAM_WAVE_SINK
} DMUS_STREAM_TYPE;

/*****************************************************************************
 * ISynthSinkDMus
 *****************************************************************************
 * Interface for synth wave out.
 */
DECLARE_INTERFACE_(ISynthSinkDMus,IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF

    //  For ISynthSinkDMus
    STDMETHOD_(void,Render)
    (   THIS_
        IN      PBYTE       pBuffer,
        IN      DWORD       dwLength,
        IN      LONGLONG    llPosition
    )   PURE;

    STDMETHOD_(NTSTATUS,SyncToMaster)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        IN      BOOL            fStart
    )   PURE;

    STDMETHOD_(NTSTATUS,SampleToRefTime)
    (   THIS_
        IN      LONGLONG         llSampleTime,
        OUT     REFERENCE_TIME * prfTime
    )   PURE;

    STDMETHOD_(NTSTATUS,RefTimeToSample)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        OUT     LONGLONG *      pllSampleTime
    )   PURE;
};

typedef ISynthSinkDMus * PSYNTHSINKDMUS;

#define IMP_ISynthSinkDMus\
    IMP_IMXF;\
    STDMETHODIMP_(void) Render\
    (   IN      PBYTE       pBuffer,\
        IN      DWORD       dwLength,\
        IN      LONGLONG    llPosition\
    );\
    STDMETHODIMP_(NTSTATUS) SyncToMaster\
    (   IN      REFERENCE_TIME  rfTime,\
        IN      BOOL            fStart\
    );\
    STDMETHODIMP_(NTSTATUS) SampleToRefTime\
    (   IN      LONGLONG         llSampleTime,\
        OUT     REFERENCE_TIME * prfTime\
    );\
    STDMETHODIMP_(NTSTATUS) RefTimeToSample\
    (   IN      REFERENCE_TIME  rfTime,\
        OUT     LONGLONG *      pllSampleTime\
    )


/*****************************************************************************
 * IMasterClock
 *****************************************************************************
 * Master clock for MXF graph
 */
DECLARE_INTERFACE_(IMasterClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,GetTime)
    (   THIS_
        OUT     REFERENCE_TIME  * pTime
    )   PURE;
};

typedef IMasterClock *PMASTERCLOCK;

#define IMP_IMasterClock               \
    STDMETHODIMP_(NTSTATUS) GetTime               \
    (   THIS_                          \
        OUT     REFERENCE_TIME * pTime \
    );                                 \


#if (NTDDI_VERSION < NTDDI_WINXP)
/*****************************************************************************
 * IPositionNotify
 *****************************************************************************
 * Byte position notify for MXF graph
 */
DECLARE_INTERFACE_(IPositionNotify,IUnknown)    
{
    STDMETHOD_(void,PositionNotify)
    (   THIS_ 
        IN      ULONGLONG   bytePosition
    )   PURE;
};

typedef IPositionNotify *PPOSITIONNOTIFY;

#define IMP_IPositionNotify                 \
    STDMETHODIMP_(void) PositionNotify      \
    (   THIS_                               \
        IN      ULONGLONG   bytePosition    \
    );                                      \

#endif

/*****************************************************************************
 * IMiniportDMus
 *****************************************************************************
 * Interface for DMusic miniports.
 */
DECLARE_INTERFACE_(IMiniportDMus,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportDMus
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMXF                  * MXF,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    )   PURE;
};

typedef IMiniportDMus *PMINIPORTDMUS;

#define IMP_IMiniportDMus\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTDMUS       Port,\
        OUT     PSERVICEGROUP * ServiceGroup\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMXF                  * MXF,                        \
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,   \
        IN      POOL_TYPE               PoolType,                   \
        IN      ULONG                   PinID,                      \
        IN      DMUS_STREAM_TYPE        StreamType,                 \
        IN      PKSDATAFORMAT           DataFormat,                 \
        OUT     PSERVICEGROUP         * ServiceGroup,               \
        IN      PAllocatorMXF           AllocatorMXF,               \
        IN      PMASTERCLOCK            MasterClock,                \
        OUT     PULONGLONG              SchedulePreFetch            \
    )

DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb, 0x04cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_Effects,     0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x00, 0x60, 0x08, 0x93, 0xb1, 0xbd);

#ifndef DMUS_EFFECT_NONE
#define DMUS_EFFECT_NONE    0x00000000
#endif

#ifndef DMUS_EFFECT_REVERB
#define DMUS_EFFECT_REVERB  0x00000001
#endif

#ifndef DMUS_EFFECT_CHORUS
#define DMUS_EFFECT_CHORUS  0x00000002
#endif


#endif  /* _DMUSICKS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE;

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload,
                                           LPVOID pvData,
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload,
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                                           HANDLE hUserData ) PURE;
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt,
                                           LPBYTE pbBuffer,
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer,
                                           DWORD dwLength,
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload,
                                           LPVOID pvData,
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload,
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                                           HANDLE hUserData ) PURE;
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt,
                                           LPBYTE pbBuffer,
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer,
                                           DWORD dwLength,
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt,
										   DWORD dwVoiceId,
										   DWORD dwChannelGroup,
										   DWORD dwChannel,
										   DWORD dwDLId,
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt,
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[],
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;
};

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime,
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;
};


DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
#else
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
#endif

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\drmk.h ===
#ifndef _DRMK_H_
#define _DRMK_H_

#ifdef __cplusplus
extern "C"
{
#endif
    
	
typedef struct tagDRMRIGHTS {
    BOOL  CopyProtect;
    ULONG Reserved;
    BOOL  DigitalOutputDisable;
} DRMRIGHTS , *PDRMRIGHTS;
typedef const DRMRIGHTS *PCDRMRIGHTS;

#define DEFINE_DRMRIGHTS_DEFAULT(DrmRights) const DRMRIGHTS DrmRights = {FALSE, 0, FALSE}


// {1915C967-3299-48cb-A3E4-69FD1D1B306E}
DEFINE_GUID(IID_IDrmAudioStream,
	    0x1915c967, 0x3299, 0x48cb, 0xa3, 0xe4, 0x69, 0xfd, 0x1d, 0x1b, 0x30, 0x6e);

DECLARE_INTERFACE_(IDrmAudioStream, IUnknown)
{
    // IUnknown methods
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_
        REFIID InterfaceId,
        PVOID* Interface
        ) PURE;
        
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    
    // IDrmAudioStream methods                       
    STDMETHOD_(NTSTATUS,SetContentId)(THIS_
	IN ULONG ContentId,
        IN PCDRMRIGHTS DrmRights
        ) PURE;
};

typedef IDrmAudioStream *PDRMAUDIOSTREAM;

#define IMP_IDrmAudioStream\
    STDMETHODIMP_(NTSTATUS) SetContentId\
    (   IN      ULONG	    ContentId,\
        IN      PCDRMRIGHTS DrmRights\
    );

typedef struct tagDRMFORWARD {
    DWORD          Flags;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT   FileObject;
    PVOID          Context;
} DRMFORWARD, *PDRMFORWARD;
typedef const DRMFORWARD *PCDRMFORWARD;

NTSTATUS
NTAPI
DrmAddContentHandlers(
    IN ULONG ContentId,
    IN PVOID* paHandlers,
    IN ULONG NumHandlers
    );

typedef
NTSTATUS
(NTAPI *PFNDRMADDCONTENTHANDLERS)(
    IN ULONG ContentId,
    IN PVOID* paHandlers,
    IN ULONG NumHandlers
    );

NTSTATUS
NTAPI
DrmCreateContentMixed(
    IN PULONG paContentId,
    IN ULONG cContentId,
    OUT PULONG pMixedContentId
    );

typedef
NTSTATUS
(NTAPI *PFNDRMCREATECONTENTMIXED)(
    IN PULONG paContentId,
    IN ULONG cContentId,
    OUT PULONG pMixedContentId
    );

NTSTATUS
NTAPI
DrmDestroyContent(
    IN ULONG ContentId
    );

typedef
NTSTATUS
(NTAPI *PFNDRMDESTROYCONTENT)(
    IN ULONG ContentId
    );

NTSTATUS
NTAPI
DrmForwardContentToDeviceObject(
    IN ULONG ContentId,
    IN PVOID Reserved,
    IN PCDRMFORWARD DrmForward
    );

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTODEVICEOBJECT)(
    IN ULONG ContentId,
    IN PVOID Reserved,
    IN PCDRMFORWARD DrmForward
    );


NTSTATUS
NTAPI
DrmForwardContentToFileObject(
    IN ULONG ContentId,
    IN PFILE_OBJECT FileObject
    );

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTOFILEOBJECT)(
    IN ULONG ContentId,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
NTAPI
DrmForwardContentToInterface(
    ULONG ContentId,
    PUNKNOWN pUnknown,
    ULONG NumMethods);

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTOINTERFACE)(
    ULONG ContentId,
    PUNKNOWN pUnknown,
    ULONG NumMethods);

NTSTATUS
NTAPI
DrmGetContentRights(
    IN ULONG ContentId,
    OUT PDRMRIGHTS DrmRights
    );

typedef
NTSTATUS
(NTAPI *PFNDRMGETCONTENTRIGHTS)(
    IN ULONG ContentId,
    OUT PDRMRIGHTS DrmRights
    );


//
// Structures for use with KSPROPERY_DRMAUDIOSTREAM_CONTENTID
//

typedef struct {
    ULONG     ContentId;
    DRMRIGHTS DrmRights;
} KSDRMAUDIOSTREAM_CONTENTID, *PKSDRMAUDIOSTREAM_CONTENTID;

typedef struct {
    KSPROPERTY                         Property;
    PVOID                              Context;
    // DRM API callback functions
    PFNDRMADDCONTENTHANDLERS            DrmAddContentHandlers;
    PFNDRMCREATECONTENTMIXED            DrmCreateContentMixed;
    PFNDRMDESTROYCONTENT                DrmDestroyContent;
    PFNDRMFORWARDCONTENTTODEVICEOBJECT  DrmForwardContentToDeviceObject;
    PFNDRMFORWARDCONTENTTOFILEOBJECT    DrmForwardContentToFileObject;
    PFNDRMFORWARDCONTENTTOINTERFACE     DrmForwardContentToInterface;
    PFNDRMGETCONTENTRIGHTS              DrmGetContentRights;
} KSP_DRMAUDIOSTREAM_CONTENTID, *PKSP_DRMAUDIOSTREAM_CONTENTID;


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dmusprop.h ===
/***************************************************************************
*                                                                          *
*   DMusProp.h -- This module defines property items for DirectMusic WDM   *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusProp_
#define _DMusProp_

#include "dmusbuff.h"

/*
    Formats
*/
#define STATIC_KSDATAFORMAT_SUBTYPE_DIRECTMUSIC\
    0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("1a82f8bc-3f8b-11d2-b774-0060083316c1", KSDATAFORMAT_SUBTYPE_DIRECTMUSIC);
#define KSDATAFORMAT_SUBTYPE_DIRECTMUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC)


/*
    Topology
*/
#define STATIC_KSNODETYPE_DMSYNTH\
    0x94824f88, 0x6183, 0x11d2, 0x8f, 0x7a, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("94824F88-6183-11d2-8F7A-00C04FBF8FEF", KSNODETYPE_DMSYNTH);
#define KSNODETYPE_DMSYNTH DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH)

/*
    Caps node (per pin)
*/
#define STATIC_KSNODETYPE_DMSYNTH_CAPS\
    0xbca2a2f1, 0x93c6, 0x11d2, 0xba, 0x1d, 0x0, 0x0, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("bca2a2f1-93c6-11d2-ba1d-0000f875ac12", KSNODETYPE_DMSYNTH_CAPS);
#define KSNODETYPE_DMSYNTH_CAPS DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH_CAPS)

/*
    DDK Property sets and items
*/
#define STATIC_KSPROPSETID_Synth_Dls\
    0xd523fa2c, 0xdee3, 0x11d1, 0xa7, 0x89, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("d523fa2c-dee3-11d1-a789-0000f875ac12", KSPROPSETID_Synth_Dls);
#define KSPROPSETID_Synth_Dls DEFINE_GUIDNAMED(KSPROPSETID_Synth_Dls)

typedef enum
{
    KSPROPERTY_SYNTH_DLS_DOWNLOAD = 0,
    KSPROPERTY_SYNTH_DLS_UNLOAD,
    KSPROPERTY_SYNTH_DLS_COMPACT,
    KSPROPERTY_SYNTH_DLS_APPEND,
    KSPROPERTY_SYNTH_DLS_WAVEFORMAT
} KSPROPERTY_SYNTH_DLS;

typedef struct _SYNTH_BUFFER
{
    ULONG   BufferSize;
    PVOID   BufferAddress;
} SYNTH_BUFFER, *PSYNTH_BUFFER;

typedef struct _SYNTHDOWNLOAD
{
    HANDLE  DownloadHandle;
    BOOL    Free;               /* the client buffer can be freed */
} SYNTHDOWNLOAD, *PSYNTHDOWNLOAD;


#define STATIC_KSPROPSETID_Synth\
    0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae25-e46e-11d1-aace-0000f875ac12", KSPROPSETID_Synth);
#define KSPROPSETID_Synth DEFINE_GUIDNAMED(KSPROPSETID_Synth)

typedef enum
{
    KSPROPERTY_SYNTH_VOLUME = 0,  /* must be first */
    KSPROPERTY_SYNTH_VOLUMEBOOST,
    KSPROPERTY_SYNTH_CAPS,
    KSPROPERTY_SYNTH_PORTPARAMETERS,
    KSPROPERTY_SYNTH_CHANNELGROUPS,
    KSPROPERTY_SYNTH_VOICEPRIORITY,
    KSPROPERTY_SYNTH_LATENCYCLOCK,
    KSPROPERTY_SYNTH_RUNNINGSTATS
} KSPROPERTY_SYNTH;

#define SYNTH_PC_DLS                (0x00000001)
#define SYNTH_PC_EXTERNAL           (0x00000002)
#define SYNTH_PC_SOFTWARESYNTH      (0x00000004)
#define SYNTH_PC_MEMORYSIZEFIXED    (0x00000008)
#define SYNTH_PC_GMINHARDWARE       (0x00000010)
#define SYNTH_PC_GSINHARDWARE       (0x00000020)
#if (NTDDI_VERSION < NTDDI_WINXP)
#define SYNTH_PC_REVERB             (0x00000040)
#elif (NTDDI_VERSION >= NTDDI_WINXP)
#define SYNTH_PC_XGINHARDWARE       (0x00000040)
// 0x80 used in user mode
// 0x100 used in user mode
#define SYNTH_PC_DLS2               (0x00000200)
// 0x400 used in user mode
// 0x800 used in user mode
#define SYNTH_PC_REVERB             (0x40000000)
#endif

#define SYNTH_PC_SYSTEMMEMORY       (0x7fffffff)

typedef struct _SYNTHCAPS
{
    GUID    Guid;
    DWORD   Flags;
    DWORD   MemorySize;
    DWORD   MaxChannelGroups;
    DWORD   MaxVoices;
    DWORD   MaxAudioChannels;
    DWORD   EffectFlags;
    WCHAR   Description[128];
} SYNTHCAPS, *PSYNTHCAPS;


typedef struct _SYNTH_PORTPARAMS
{
    DWORD   ValidParams;
    DWORD   Voices;
    DWORD   ChannelGroups;
    DWORD   AudioChannels;
    DWORD   SampleRate;
    DWORD   EffectsFlags;
    DWORD   Share;
} SYNTH_PORTPARAMS, *PSYNTH_PORTPARAMS;

/*  These flags (set in ValidParams) indicate which
 *  other members of the SYNTH_PORTPARAMS are valid
 */
#define SYNTH_PORTPARAMS_VOICES           0x00000001
#define SYNTH_PORTPARAMS_CHANNELGROUPS    0x00000002
#define SYNTH_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define SYNTH_PORTPARAMS_SAMPLERATE       0x00000008
#define SYNTH_PORTPARAMS_EFFECTS          0x00000020
#define SYNTH_PORTPARAMS_SHARE            0x00000040

/* SYNTH_EFFECT_ flags are used in the
 * EffectFlags fields of SYNTH_PORTPARAMS.
 */

#define SYNTH_EFFECT_NONE             0x00000000
#define SYNTH_EFFECT_REVERB           0x00000001
#define SYNTH_EFFECT_CHORUS           0x00000002
#define SYNTH_EFFECT_DELAY            0x00000004

/*
 * Instance data for KSPROPERTY_ITEM_SynthVoicePriority
 */
typedef struct _SYNTHVOICEPRIORITY_INSTANCE
{
    DWORD   ChannelGroup;
    DWORD   Channel;
} SYNTHVOICEPRIORITY_INSTANCE, *PSYNTHVOICEPRIORITY_INSTANCE;

/*
 * Data returned by KSPROPERTY_SYNTH_RUNNINGSTATS
 */
typedef struct _SYNTH_STATS
{
    DWORD   ValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   Voices;           /* Average number of voices playing. */
    DWORD   TotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   CPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   LostNotes;        /* Number of notes lost in 1 second. */
    DWORD   FreeMemory;       /* Free memory in bytes */
    LONG    PeakVolume;       /* Decibel level * 100. */
} SYNTH_STATS, *PSYNTH_STATS;


#define SYNTH_STATS_VOICES          (1 << 0)
#define SYNTH_STATS_TOTAL_CPU       (1 << 1)
#define SYNTH_STATS_CPU_PER_VOICE   (1 << 2)
#define SYNTH_STATS_LOST_NOTES      (1 << 3)
#define SYNTH_STATS_PEAK_VOLUME     (1 << 4)
#define SYNTH_STATS_FREE_MEMORY     (1 << 5)

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000)

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)


#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */

/*
    SDK Property sets and items
*/
typedef struct _SYNTH_REVERB_PARAMS
{
    float   fInGain;            /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;         /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal).
                                   Negative values gives less wet signal.  The coeficients are
                                   calculated so that the overall output level stays (approximately)
                                   constant regardless of the ammount of reverb mix. */
    float   fReverbTime;        /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio;   /* The ratio of the high frequencies to the global reverb time.
                                   Unless very 'splashy-bright' reverbs are wanted, this should be set to
                                   a value < 1.0.  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1
                                   than the decay time for high frequencies will be 100ms.*/
} SYNTH_REVERB_PARAMS, *PSYNTH_REVERB_PARAMS;


#define STATIC_KSPROPSETID_SynthClock \
    0xfedfae26L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae26-e46e-11d1-aace-0000f875ac12", KSPROPSETID_SynthClock);
#define KSPROPSETID_SynthClock DEFINE_GUIDNAMED(KSPROPSETID_SynthClock)

typedef enum
{
    KSPROPERTY_SYNTH_MASTERCLOCK
} KSPROPERTY_SYNTHCLOCK;
#endif /* _DMusProp_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\driverspecs.h ===
/*****************************************************************************\
*                                                                             *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.1.00                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

/*****************************************************************************\
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/

/*****************************************************************************\
* Many annotations are context dependent.  They only apply to certain versions
* of Windows, or only to certain classes of driver.  These rules can be written
* using something like __drv_when(NTDDI_VERSION >= NTDDI_WINXP, ...)
* which causes the rule only to apply to Windows XP and later.  Many of these
* symbols are already defined in various Windows headers.
*
* To facilitate using this sort of conditional rule, we collect here the
* various known symbols that are (or reasonably might) be used in such
* a conditional annotation.  Some are speculative in that the symbol has
* not yet been defined because there are no known uses of it yet.
*
* Where the symbol already exists its relevant header is
* noted below (excluding the "really well known" ones).
*
* Each symbol is listed with the currently known possible values.
*
* Some symbols are marked as #define symbols -- they are used with #ifdef
* operators only.  To use them in __drv_when, use something like
* __drv_when(__drv_defined(NT), ...).
*
* WDK Version (copied for convenience from sdkddkver.h)
*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3 
*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2 
*					 NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA
*     The WDK version is taken as the WDM version as well.
*
* OS Version: (copied for convenience from sdkddkver.h)
*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP 
*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN
*     WINVER: 0x030B 0x0400 0x0500 0x0600
*     NT (#define symbol)
* (sdkddkver.h also defines symbols for IE versions should they be needed.)
*
* Compiler Version:
*	  _MSC_VER: too many to list.
*	  _MSC_FULL_VER: too many to list.
*
* KMDF Version:  (Currently defined/used only in makefiles.)
*     KMDF_VERSION: 1     
*
* UMDF Version:  (Currently defined/used only in makefiles.)
*     UMDF_VERSION: 1     
*
* Architecture kinds:
*     __WIN64 (#define symbols)
*     _X86_
*     _AMD64_
*     _IA64_ 
*
* Machine Architectures:
*     _M_IX86
*     _M_AMD64
*     _M_IA64
*
* Driver Kind (NYI: "not yet implemented")
*   Typically these will be defined in the most-common header for a 
*   particular driver (or in individual source files if appropriate).
*   These are not intended to necessarily be orthogonal: more than one might 
*   apply to a particular driver.
*     _DRIVER_TYPE_BUS: 1                // NYI
*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI
*     _DRIVER_TYPE_MINIPORT: 1           // NYI
*     _DRIVER_TYPE_STORAGE: 1            // NYI
*     _DRIVER_TYPE_DISPLAY: 1            // NYI
*     _DRIVER_TYPE_FILESYSTEM: 1
*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1
*
* NDIS driver version: (see ndis.h for much more detail.)
*   These can be used to both identify an NDIS driver and to check the version.
*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)
*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0
*     And many others in ndis.h (including MINIPORT)
*
\*****************************************************************************/

#include "SpecStrings.h"
#include "sdv_driverspecs.h"
#if _MSC_VER > 1000 // [
#pragma once
#endif // ]

#if !defined(_MSC_EXTENSIONS) && !defined(_PREFAST_) && !defined(OACR)

	#define __internal_kernel_driver /* nothing */

#else

#ifdef  __cplusplus // [
extern "C" {
#endif  // ]


#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_) // [
#define __drv_declspec(x) __declspec(x)
#define __$drv_group(annotes)												\
	  __drv_declspec("SAL_begin") annotes __drv_declspec("SAL_end")
#define __drv_nop(x) x
#else
#define __drv_declspec(x)
#define __$drv_group(x)
#endif // ]


#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_) // [


	// ---------------------------------------------------------------------
	// Processing mode selection:
	//
	// __internal_kernel_driver
	//
	// Flag for headers that indicates a probable driver.
	// This should only be coded in headers that are normally used 
	// as the "primary" header for a class of drivers.  It sets the
	// default to kernel mode driver.
	//
	#define __internal_kernel_driver 										\
		typedef int __drv_declspec("SAL_internal_kernel_driver") 			\
					__prefast_flag_kernel_driver_mode;

	//
	// __kernel_code
	// __kernel_driver
	// __user_driver
	// __user_code
	//
	// Flags for compilation units that indicated specifically what kind of 
	// code it is.
	// These should be coded as early as possible in any compilation unit 
	// (.c/.cpp file) that doesn't get the correct default.  Whether before
	// or after __internal_kernel_driver
	// 
	// Indicate that the code is kernel, but not driver, code.
	#define __kernel_code 													\
		typedef int __drv_declspec("SAL_kernel")  							\
					__drv_declspec("SAL_nodriver")							\
					__prefast_flag_kernel_driver_mode;

	// Indicate that the code is kernel, driver, code.
	#define __kernel_driver 												\
		typedef int __drv_declspec("SAL_kernel")   							\
					__drv_declspec("SAL_driver")  							\
					__prefast_flag_kernel_driver_mode;

	// Indicate that the code is a user mode driver.
	#define __user_driver 													\
		typedef int __drv_declspec("SAL_nokernel")							\
					__drv_declspec("SAL_driver")   							\
					__prefast_flag_kernel_driver_mode;

	// Indicate that the code is ordinary user mode code.
	#define __user_code 													\
		typedef int __drv_declspec("SAL_nokernel") 							\
					__drv_declspec("SAL_nodriver") 							\
					__prefast_flag_kernel_driver_mode;

#else

	#define __internal_kernel_driver
	#define __kernel_code 
	#define __kernel_driver
	#define __user_driver
	#define __user_code

#endif

	// core macros: these provide syntatic wrappers to make other uses
	// simpler.
	// (Note: right now we can't safely use the ellipsis (...) macro
	// syntax.  If we could then '##__drv_nop(annotes)' below could be 
	// simply 'annotes', and we could code __$drv_group as __$drv_group(...) 
	// in the "expands to nothing" case.)
	//
	// For example:
	//	 __drv_in(__drv_nonconstant __setsIRQL)
	
	#define __drv_deref(annotes) __deref __$drv_group(##__drv_nop(annotes))
	#define __drv_in(annotes) __pre __$drv_group(##__drv_nop(annotes))
	#define __drv_in_deref(annotes) __pre __deref __$drv_group(##__drv_nop(annotes))
	#define __drv_out(annotes) __post __$drv_group(##__drv_nop(annotes))
	#define __drv_out_deref(annotes) __post __deref __$drv_group(##__drv_nop(annotes))
	#define __drv_when(cond, annotes)										\
	  __drv_declspec("SAL_when(" SPECSTRINGIZE(cond) ")") __$drv_group(##__drv_nop(annotes))
	#define __drv_at(expr,annotes)\
	  __drv_declspec("SAL_at(" SPECSTRINGIZE(expr) ")") __$drv_group(##__drv_nop(annotes))

	#define __drv_fun(annotes) __drv_at(return,##__drv_nop(annotes))
	#define __drv_ret(annotes) __drv_at(return,##__drv_nop(annotes))
	#define __drv_arg(expr,annotes) __drv_at(expr,##__drv_nop(annotes))
	#define __drv_unit(p)													\
	  typedef int __$drv_unit_##p __prefast_flag_kernel_driver_mode;

	// Internal macros for convenience
	#define __$drv_unit_internal_kernel_driver								\
		 __drv_declspec("SAL_internal_kernel_driver")

	//
	// __drv_unit
	//
	// Flags for compilation units that indicated specifically what kind of
	// code it is.
	// These should be coded as early as possible in any compilation unit
	// (.c/.cpp file) that doesn't get the correct default.	 Whether before
	// or after __internal_kernel_driver is immaterial as long as it will
	// successfully parse.
	//
	// Indicate that the code is kernel, but not driver, code.
	#define __$drv_unit_kernel_code											\
			__drv_declspec("SAL_kernel")  __drv_declspec("SAL_nodriver")

	// Indicate that the code is kernel, driver, code.
	#define __$drv_unit_kernel_driver										\
			__drv_declspec("SAL_kernel") __drv_declspec("SAL_driver")

	// Indicate that the code is a user mode driver.
	#define __$drv_unit_user_driver											\
			__drv_declspec("SAL_nokernel") __drv_declspec("SAL_driver")

	// Indicate that the code is ordinary user mode code.
	#define __$drv_unit_user_code											\
			__drv_declspec("SAL_nokernel")	__drv_declspec("SAL_nodriver")


	// These are needed for backwards compatability.
	#ifndef __internal_kernel_driver

	#define __internal_kernel_driver   __drv_unit(internal_kernel_driver)
	#define __kernel_code			   __drv_unit(kernel_code)
	#define __kernel_driver			   __drv_unit(kernel_driver)
	#define __user_driver			   __drv_unit(user_driver)
	#define __user_code				   __drv_unit(user_code)

	#endif

	// ---------------------------------------------------------------------
	// Syntatic utilities:
	// 
	// Needed to make the annotations convenient to use.
	//
	// So we can use a macro name that might be used in #ifdef context,
	// where it's defined with no value.  
	// This should only be used inside a __drv_when condition.
	//
	#define __drv_defined(x) macroDefined$( #x )

	// ---------------------------------------------------------------------
	// Callback properties:
	//
	// __drv_functionClass(x)
	//
	// Flag that the  the annotated function
	// is a member of that function class.	Some class names are recognized
	// by PREfast itself for special treatment.
	// This can be tested by the condition function inFunctionClass$()
	//
	#define __drv_functionClass(x)									     	\
		__post __drv_out(__drv_declspec("SAL_functionClass("#x")"))


	// ---------------------------------------------------------------------
	// Specialized properties:
	//
	// __drv_innerFunctionProperty(x)
	//
	// Flag that the annotated object has/needs the named property.
	// This should always be used with an enclosing macro that provides
	// the pre or post annotation, as needed.
	//
	#define __drv_innerFunctionProperty(x)									\
		__drv_declspec("SAL_property("SPECSTRINGIZE(x)")")


	// ---------------------------------------------------------------------
	// Resources:
	// 
	// __drv_acquiresResource(kind)
	// __drv_releasesResource(kind)
	// __drv_acquiresResourceGlobal(kind,param)
	// __drv_releasesResourceGlobal(kind,param)
	// __drv_mustHold(kind)
	// __drv_neverHold(kind)
	// __drv_mustHoldGlobal(kind,param)
	// __drv_neverHoldGlobal(kind,param)
	//
	// Flag that the annotated parameter acquires a resource of type kind.
	//
	#define __drv_acquiresResource(kind)									\
		__post __drv_declspec("SAL_acquire("#kind")")

	//
	// Flag that the annotated parameter releases a resource of type kind.
	//
	#define __drv_releasesResource(kind)									\
		__post __drv_declspec("SAL_release("#kind")")

	//
	// Flag that the annotated object acquires a global (otherwise anonymous)
	// resource of type kind named by param.
	//
	#define __drv_innerAcquiresGlobal(kind, param)							\
		__post __drv_declspec("SAL_acquireGlobal("#kind","					\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_acquiresResourceGlobal(kind,param)						\
		__drv_innerAcquiresGlobal(kind, param)
	//
	// Flag that the annotated object acquires a global (otherwise anonymous)
	// resource of type kind named by param.
	//
	#define __drv_innerReleasesGlobal(kind, param)							\
		__post __drv_declspec("SAL_releaseGlobal(" #kind ","				\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_releasesResourceGlobal(kind, param)						\
		__drv_innerReleasesGlobal(kind, param)
											  
	//
	// Flag that the annotated parameter must hold a resource of type kind
	//
	#define __drv_mustHold(kind)											\
		__pre __drv_declspec("SAL_mustHold("#kind")")

	//
	// Flag that the annotated object must hold a global resource
	// of type kind named by param.
	//
	#define __drv_innerMustHoldGlobal(kind, param)							\
		__pre __drv_declspec("SAL_mustHoldGlobal("#kind","					\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_mustHoldGlobal(kind,param)								\
		__drv_innerMustHoldGlobal(kind, param)

	//
	// Flag that the annotated parameter must never hold a resource of type kind
	//
	#define __drv_neverHold(kind)											\
		__pre __drv_declspec("SAL_neverHold("#kind")")

	//
	// Flag that the annotated object must never hold a global resource
	// of type kind named by param.
	//
	#define __drv_innerNeverHoldGlobal(kind, param)							\
		__pre __drv_declspec("SAL_neverHoldGlobal("#kind","					\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_neverHoldGlobal(kind,param)								\
		__drv_innerNeverHoldGlobal(kind, param)


	// ---------------------------------------------------------------------
	// Maintenance of IRQL values
	//
	// __drv_setsIRQL(irql)
	// __drv_raisesIRQL(irql)
	// __drv_requiresIRQL(irql)
	// __drv_maxIRQL(irql)
	// __drv_minIRQL(irql)
	// __drv_savesIRQL
	// __drv_restoresIRQL
	// __drv_savesIRQLGlobal(kind,param)
	// __drv_restoresIRQLGlobal(kind,param)
	// __drv_minFunctionIRQL(irql)
	// __drv_maxFunctionIRQL(irql)
	// __drv_useCancelIRQL
	// __drv_sameIRQL

	// 
	// The funciton exits at IRQL irql
	//
	#define __drv_setsIRQL(irql)											\
		__post __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")

	// 
	// The funciton exits at IRQL irql, but this may only raise the irql.
	//
	#define __drv_raisesIRQL(irql)											\
		__post __drv_declspec("SAL_raiseIRQL("SPECSTRINGIZE(irql)")")

	// 
	// The called function must be entered at IRQL level
	//
	#define __drv_requiresIRQL(irql)										\
		__pre __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")


	// 
	// The maximum IRQL at which the function may be called.
	//
	#define __drv_maxIRQL(irql)												\
		__pre __drv_declspec("SAL_maxIRQL("SPECSTRINGIZE(irql)")")
	// 
	// The minimum IRQL at which the function may be called.
	//
	#define __drv_minIRQL(irql)												\
		__pre __drv_declspec("SAL_minIRQL("SPECSTRINGIZE(irql)")")

	// 
	// The current IRQL is saved in the annotated parameter
	//
	#define __drv_savesIRQL __post __drv_declspec("SAL_saveIRQL")

	// 
	// The current IRQL is saved in the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#define __drv_savesIRQLGlobal(kind,param)								\
		__post __drv_declspec("SAL_saveIRQLGlobal("#kind","					\
										   SPECSTRINGIZE(param\t)")")

	// 
	// The current IRQL is restored from the annotated parameter
	//
	#define __drv_restoresIRQL __post __drv_declspec("SAL_restoreIRQL")

	// 
	// The current IRQL is restored from the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#define __drv_restoresIRQLGlobal(kind,param)							\
		__post __drv_declspec("SAL_restoreIRQLGlobal("#kind","				\
										   SPECSTRINGIZE(param\t)")")

	// The minimum IRQL to which the function can lower itself.	 The IRQL
	// at entry is assumed to be that value unless overridden.
	#define __drv_minFunctionIRQL(irql)\
		__pre __drv_innerFunctionProperty(minFunctionIrql=irql) 

	// The maximum IRQL to which the function can raise itself.
	#define __drv_maxFunctionIRQL(irql)\
		__pre __drv_innerFunctionProperty(maxFunctionIrql=irql) 

	// The function must exit with the same IRQL it was entered with.
	// (It may change it but it must restore it.)
	#define __drv_sameIRQL\
		__post __drv_declspec("SAL_sameIRQL")

	// The annotated parameter contains the cancelIRQL, which will be restored
	// by the called function.

	#define __drv_useCancelIRQL												\
		__post __drv_innerFunctionProperty(UseCancelIrql)

    // The annotated function clears the requirement that DoInitializeing
	// is cleared (or not).
	#define __drv_clearDoInit(yesNo)										\
		__post __drv_innerFunctionProperty(clearDoInit=yesNo)

	// ---------------------------------------------------------------------
	// Function and out parameter return values.
	//
	// __drv_valueIs(<list>)
	//
	// The function being annotated will return each of the specified values
	// during simulation.  The items in the list are <relational op><constant>,
	// e.g. ==0 or <0.
	// This is a ; separated list of values.  The internal parser will accept
	// a comma-separated list.  In the future __VA_ARGS__ could be used.
	// See the documentation for use of this.
	//
	#define __drv_valueIs(arglist)											\
			__post __drv_declspec("SAL_return("SPECSTRINGIZE(arglist)")")

	// ---------------------------------------------------------------------
	// Additional parameter checking.
	//
	// __drv_constant
	// __drv_nonConstant
	// __drv_strictTypeMatch(mode)
	// __drv_strictType(type,mode)
	//
	// The actual parameter must evaluate to a constant (not a const).
	//
	#define __drv_constant __pre __drv_declspec("SAL_constant")

	//
	// The actual parameter may never evaluate to a numeric constant 
	// (exclusive of a const symbol).
	//
	#define __drv_nonConstant __pre __drv_declspec("SAL_nonConstant")

	//
	// The actual parameter must match the type of the annotated formal
	// within the specifications set by mode.
	//
	#define __drv_strictTypeMatch(mode)										\
		__pre __drv_declspec("SAL_strictTypeMatch("SPECSTRINGIZE(mode)")")

	//
	// The actual parameter must match the type of typename (below) 
	// within the specifications set by mode.
	//
	#define __drv_strictType(typename,mode)									\
		__pre __drv_declspec("SAL_strictType("SPECSTRINGIZE(typename)","	\
											  SPECSTRINGIZE(mode)")")
	//
	//    The following modes are defined:
		#define __drv_typeConst   0    // constants of that type
		#define __drv_typeCond    1    // plus ?:
		#define __drv_typeBitset  2    // plus all operators
		#define __drv_typeExpr    3    // plus literal constants
	// 
	// The actual parameter must be data (not a pointer).  Used to
	// prevent passing pointers to pointers when pointers to structures
	// are needed (because &pXXX is a common error when pXXX is 
	// intended).
	#define __drv_notPointer  __pre __drv_declspec("SAL_mayBePointer(never)")
	//
	// Convenience for the most common form of the above.
	#define __drv_isObjectPointer __drv_deref(__drv_notPointer)

	// ---------------------------------------------------------------------
	// Memory management
	//
	// __drv_aliasesMem
	// __drv_allocatesMem
	// __drv_freesMem
	//
	// The annotated parameter is "kept" by the function, creating an
	// alias, and relieving any obligation to free the object.
	//
	#define __drv_aliasesMem __post __drv_declspec("SAL_IsAliased")

	//
	// Allocate/release memory-like objects.
	// Kind is unused, but should be "mem" for malloc/free
	// and "object" for new/delete.
	#define __drv_allocatesMem(kind) __post __drv_declspec("SAL_NeedsRelease")
	#define __drv_freesMem(kind)	 __post __drv_declspec("SAL_IsReleased")

	// ---------------------------------------------------------------------
	// Additional diagnostics
	//
	// __drv_preferredFunction
	// __drv_reportError
	//
	//
	// Function 'func' should be used for reason 'why'.	 Often used
	// conditionally.
	//
	#define __drv_preferredFunction(func,why)								\
		__pre __drv_declspec(												\
			"SAL_preferredFunction("SPECSTRINGIZE(func)","					\
											 #why ")")

	//
	// The error given by 'why' was detected.  Used conditionally.
	//
	#define __drv_reportError(why)											\
		__pre __drv_declspec("SAL_error(" #why ")")

	// ---------------------------------------------------------------------
	// Floating point save/restore:
	//
	// __drv_floatSaved
	// __drv_floatRestored
	// __drv_floatUsed
	//
	// The floating point hardware was saved (available to kernel)
	#define __drv_floatSaved __post __drv_declspec("SAL_floatSaved")

	//
	// The floating point hardware was restored (no longer available)
	#define __drv_floatRestored __post __drv_declspec("SAL_floatRestored")

	//
	// The function uses floating point.  Functions with floating point
	// in their type signature get this automatically.
	#define __drv_floatUsed __post __drv_declspec("SAL_floatUsed")

	// ---------------------------------------------------------------------
	// Usage:
	// 
	// __drv_interlocked
	// __drv_inTry
	// __drv_notInTry
	//
	// The parameter is used for interlocked instructions.
	#define __drv_interlocked __pre __drv_declspec("SAL_interlocked")

	// The function must be called inside a try block
	#define __drv_inTry __pre __drv_declspec("SAL_inTry")

	// The function must not be called inside a try block
	#define __drv_notInTry __pre __drv_declspec("SAL_notInTry")

	// ---------------------------------------------------------------------
	// FormatString:
	//
	// kind can be "printf", "scanf", "strftime" or "FormatMessage".
	#define __drv_formatString(kind)\
		__drv_declspec("SAL_IsFormatString(" #kind ")")
	
	// ---------------------------------------------------------------------
	// SDV support: see the SDV documentation for details

	// Identify dispatch callback types
	#define __drv_dispatchType(kindlist)\
		__drv_declspec("SAL_dispatchType("\
							#kindlist ")" )

	// Identify dispatch callback types - special case
	#define __drv_dispatchType_other\
		__drv_declspec("SAL_dispatchType(IRP_MJ_OTHER)" )

	// Identify completion callback types
	#define __drv_completionType(kindlist)\
		__drv_declspec("SAL_completionType("\
							#kindlist ")" )

	// Identify callback types (FDO or PDO)
	#define __drv_callbackType(kind)\
		__drv_declspec("SAL_callbackType("\
							#kind ")" )
	// ---------------------------------------------------------------------
	// Composite:

	//
	// Exclusive Resources
	#define __drv_acquiresExclusiveResource(kind)				\
		__drv_neverHold(kind)									\
		__drv_acquiresResource(kind)

	#define __drv_releasesExclusiveResource(kind)				\
		__drv_mustHold(kind)									\
		__drv_releasesResource(kind)

	#define __drv_acquiresExclusiveResourceGlobal(kind, param)	\
		__drv_neverHoldGlobal(kind, param)						\
		__drv_acquiresResourceGlobal(kind, param)

	#define __drv_releasesExclusiveResourceGlobal(kind, param)	\
		__drv_mustHoldGlobal(kind, param)						\
		__drv_releasesResourceGlobal(kind, param)

	//
	// CancelSpinLock
	#define __drv_acquiresCancelSpinLock						\
		__drv_innerNeverHoldGlobal(CancelSpinLock,)				\
		__drv_innerAcquiresGlobal(CancelSpinLock,)

	#define __drv_releasesCancelSpinLock						\
		__drv_innerMustHoldGlobal(CancelSpinLock,)				\
		__drv_innerReleasesGlobal(CancelSpinLock,)

	#define __drv_mustHoldCancelSpinLock						\
		__drv_innerMustHoldGlobal(CancelSpinLock,)

	#define __drv_neverHoldCancelSpinLock						\
		__drv_innerNeverHoldGlobal(CancelSpinLock,)


	//
	// CriticalRegion
	#define __drv_acquiresCriticalRegion						\
		__drv_innerNeverHoldGlobal(CriticalRegion,)				\
		__drv_innerAcquiresGlobal(CriticalRegion,)

	#define __drv_releasesCriticalRegion						\
		__drv_innerMustHoldGlobal(CriticalRegion,)				\
		__drv_innerReleasesGlobal(CriticalRegion,)

	#define __drv_mustHoldCriticalRegion						\
		__drv_innerMustHoldGlobal(CriticalRegion,)

	#define __drv_neverHoldCriticalRegion						\
		__drv_innerNeverHoldGlobal(CriticalRegion,)


	// Passing the cancel Irql to a utility function
	#define __drv_isCancelIRQL\
		__drv_useCancelIRQL													\
		__drv_at(return, __drv_innerMustHoldGlobal(CancelSpinLock,)			\
				 __drv_innerReleasesGlobal(CancelSpinLock,)					\
				 __drv_minFunctionIRQL(DISPATCH_LEVEL)						\
				 __drv_requiresIRQL(DISPATCH_LEVEL))


#endif

#ifdef	__cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dxapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxapi.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXAPI class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
);

ULONG
DxApiGetVersion(
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dxva9typ.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dxva9typ.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _DXVA9TYP_H_
#define _DXVA9TYP_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0900
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX9 interfaces
#if(DIRECT3D_VERSION >= 0x0900)


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <windows.h>

#ifdef __DIRECTX_VA_COPP_ONLY
#define __DIRECTX_VA_DECODER__
#define __DIRECTX_VA_PROCAMPCONTROL__
#define __DIRECTX_VA_DEINTERLACE__
#endif

#ifndef DXVABit
#define DXVABit(__x) (1 << __x)
#endif


// -------------------------------------------------------------------------
//
// The definitions that follow describe the DirectX Video Acceleration
// decoding interface.
// This interface is accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_DECODER__
#define __DIRECTX_VA_DECODER__

/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample2 {
    BYTE bCrValue;
    BYTE bCbValue;
    BYTE bY_Value;
    BYTE bSampleAlpha8;
} DXVA_AYUVsample2, *LPDXVA_AYUVsample2;

DEFINE_GUID(DXVAp_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVAp_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVAp_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#pragma pack(push, BeforeDXVApacking, 1)

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;

typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;

#pragma pack(pop, BeforeDXVApacking)

#endif  /* __DIRECTX_VA_DECODER__ */


#ifndef __DIRECTX_VA_DECODER9__
#define __DIRECTX_VA_DECODER9__
// -------------------------------------------------------------------------
// Decoding data types used with RenderMoComp
// -------------------------------------------------------------------------
//

typedef struct _DXVAUncompDataInfo
{
    DWORD       UncompWidth;    /* Width of uncompressed data */
    DWORD       UncompHeight;   /* Height of uncompressed data */
    D3DFORMAT   UncompFormat;   /* Format of uncompressed data */
} DXVAUncompDataInfo;

typedef struct _DXVACompBufferInfo
{
    DWORD       NumCompBuffers;     /* Number of buffers reqd for compressed data */
    DWORD       WidthToCreate;      /* Width of surface to create */
    DWORD       HeightToCreate;     /* Height of surface to create */
    DWORD       BytesToAllocate;    /* Total number of bytes used by each surface */
    DWORD       Usage;              /* Usage used to create the compressed buffer */
    D3DPOOL     Pool;               /* Pool where the compressed buffer belongs */
    D3DFORMAT   Format;             /* Format used to create the compressed buffer */
} DXVACompBufferInfo;

typedef struct _DXVABufferInfo
{
    VOID*               pCompSurface;   /* Pointer to buffer containing compressed data */
    DWORD               DataOffset;     /* Offset of relevant data from the beginning of buffer */
    DWORD               DataSize;       /* Size of relevant data */
} DXVABufferInfo;

#endif  /* __DIRECTX_VA_DECODER9__ */


// -------------------------------------------------------------------------
//
// D3DFORMAT describes a pixel memory layout, DXVA sample format contains
// additional information that describes how the pixels should be interpreted.
//
// DXVA Extended color data - occupies the SampleFormat DWORD
// data fields.
// -------------------------------------------------------------------------
#ifndef __DIRECTX_VA_SAMPLEFORMAT__
#define __DIRECTX_VA_SAMPLEFORMAT__

typedef enum _DXVA_SampleFormat {
    DXVA_SampleFormatMask = 0xFF,   // 8 bits used for DXVA Sample format
    DXVA_SampleUnknown = 0,
    DXVA_SamplePreviousFrame = 1,
    DXVA_SampleProgressiveFrame = 2,
    DXVA_SampleFieldInterleavedEvenFirst = 3,
    DXVA_SampleFieldInterleavedOddFirst = 4,
    DXVA_SampleFieldSingleEven = 5,
    DXVA_SampleFieldSingleOdd = 6,
    DXVA_SampleSubStream = 7
} DXVA_SampleFormat;

#define DXVA_ExtractSampleFormat(_sf) ((_sf) & (DXVA_SampleFormatMask))

#define DXVA_ExtractExtColorData(_sf, _Mask, _Shift) \
    (((_sf) & (_Mask)) >> (_Shift))

#define DXVABitMask(__n) (~((~0) << __n))
#define DXVA_ExtColorData_ShiftBase 8
#define DXVAColorMask(__bits,__base) (DXVABitMask(__bits) << (__base))

typedef enum _DXVA_VideoTransferFunction
{
    DXVA_VideoTransFuncShift = (DXVA_ExtColorData_ShiftBase + 19),
    DXVA_VideoTransFuncMask = DXVAColorMask(5, DXVA_VideoTransFuncShift),

    DXVA_VideoTransFunc_Unknown = 0,
    DXVA_VideoTransFunc_10 = 1,
    DXVA_VideoTransFunc_18 = 2,
    DXVA_VideoTransFunc_20 = 3,
    DXVA_VideoTransFunc_22 = 4,
    DXVA_VideoTransFunc_22_709  = 5,
    DXVA_VideoTransFunc_22_240M = 6,
    DXVA_VideoTransFunc_22_8bit_sRGB = 7,
    DXVA_VideoTransFunc_28 = 8
} DXVA_VideoTransferFunction;

typedef enum _DXVA_VideoPrimaries
{
    DXVA_VideoPrimariesShift = (DXVA_ExtColorData_ShiftBase + 14),
    DXVA_VideoPrimariesMask = DXVAColorMask(5, DXVA_VideoPrimariesShift),

    DXVA_VideoPrimaries_Unknown = 0,
    DXVA_VideoPrimaries_reserved = 1,
    DXVA_VideoPrimaries_BT709 = 2,
    DXVA_VideoPrimaries_BT470_2_SysM = 3,
    DXVA_VideoPrimaries_BT470_2_SysBG = 4,
    DXVA_VideoPrimaries_SMPTE170M = 5,
    DXVA_VideoPrimaries_SMPTE240M = 6,
    DXVA_VideoPrimaries_EBU3213 = 7,
    DXVA_VideoPrimaries_SMPTE_C = 8
} DXVA_VideoPrimaries;

typedef enum _DXVA_VideoLighting
{
    DXVA_VideoLightingShift = (DXVA_ExtColorData_ShiftBase + 10),
    DXVA_VideoLightingMask = DXVAColorMask(4, DXVA_VideoLightingShift),

    DXVA_VideoLighting_Unknown = 0,
    DXVA_VideoLighting_bright = 1,
    DXVA_VideoLighting_office = 2,
    DXVA_VideoLighting_dim = 3,
    DXVA_VideoLighting_dark = 4
} DXVA_VideoLighting;

typedef enum _DXVA_VideoTransferMatrix
{
    DXVA_VideoTransferMatrixShift = (DXVA_ExtColorData_ShiftBase + 7),
    DXVA_VideoTransferMatrixMask = DXVAColorMask(3, DXVA_VideoTransferMatrixShift),

    DXVA_VideoTransferMatrix_Unknown = 0,
    DXVA_VideoTransferMatrix_BT709 = 1,
    DXVA_VideoTransferMatrix_BT601 = 2,
    DXVA_VideoTransferMatrix_SMPTE240M = 3
} DXVA_VideoTransferMatrix;

typedef enum _DXVA_NominalRange
{
    DXVA_NominalRangeShift = (DXVA_ExtColorData_ShiftBase + 4),
    DXVA_NominalRangeMask = DXVAColorMask(3, DXVA_NominalRangeShift),

    DXVA_NominalRange_Unknown = 0,
    DXVA_NominalRange_Normal = 1,
    DXVA_NominalRange_Wide = 2,

    DXVA_NominalRange_0_255 = 1,
    DXVA_NominalRange_16_235 = 2,
    DXVA_NominalRange_48_208 = 3
} DXVA_NominalRange;

typedef enum _DXVA_VideoChromaSubsampling
{
    DXVA_VideoChromaSubsamplingShift = (DXVA_ExtColorData_ShiftBase + 0),
    DXVA_VideoChromaSubsamplingMask = DXVAColorMask(4, DXVA_VideoChromaSubsamplingShift),

    DXVA_VideoChromaSubsampling_Unknown = 0,
    DXVA_VideoChromaSubsampling_ProgressiveChroma = 0x8,
    DXVA_VideoChromaSubsampling_Horizontally_Cosited = 0x4,
    DXVA_VideoChromaSubsampling_Vertically_Cosited = 0x2,
    DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x1,
    // 4:2:0 variations
    DXVA_VideoChromaSubsampling_MPEG2  =   DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVA_VideoChromaSubsampling_MPEG1  =   DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVA_VideoChromaSubsampling_DV_PAL  =  DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_Cosited,
    // 4:4:4, 4:2:2, 4:1:1
    DXVA_VideoChromaSubsampling_Cosited =  DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes,

} DXVA_VideoChromaSubsampling;

typedef struct _DXVA_ExtendedFormat
{
    UINT                        SampleFormat : 8;           // See DXVA_SampleFormat
    UINT                        VideoChromaSubsampling : 4; // See DXVA_VideoChromaSubSampling
    DXVA_NominalRange           NominalRange : 3;           // See DXVA_NominalRange
    DXVA_VideoTransferMatrix    VideoTransferMatrix : 3;    // See DXVA_VideoTransferMatrix
    DXVA_VideoLighting          VideoLighting : 4;          // See DXVA_VideoLighting
    DXVA_VideoPrimaries         VideoPrimaries : 5;         // See DXVA_VideoPrimaries
    DXVA_VideoTransferFunction  VideoTransferFunction : 5;  // See DXVA_VideoTransferFunction
} DXVA_ExtendedFormat;

#endif  /* __DIRECTX_VA_SAMPLEFORMAT__ */


// -------------------------------------------------------------------------
//
// The definitions that follow describe the video de-interlace interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_DEINTERLACE__
#define __DIRECTX_VA_DEINTERLACE__

#ifndef REFERENCE_TME
    typedef LONGLONG REFERENCE_TIME;
#endif

DEFINE_GUID(DXVAp_DeinterlaceBobDevice,          0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);
DEFINE_GUID(DXVAp_DeinterlaceContainerDevice,    0x0e85cb93,0x3046,0x4ff0,0xae,0xcc,0xd5,0x8c,0xb5,0xf0,0x35,0xfd);

#define DXVA_DeinterlaceBobDevice               DXVAp_DeinterlaceBobDevice
#define DXVA_DeinterlaceContainerDevice         DXVAp_DeinterlaceContainerDevice

#if (DIRECT3D_VERSION < 0x0800) || !defined(DIRECT3D_VERSION)
typedef DWORD D3DFORMAT;
enum {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,
    D3DPOOL_SCRATCH                 = 3,
    D3DPOOL_LOCALVIDMEM             = 4,
    D3DPOOL_NONLOCALVIDMEM          = 5,
    D3DPOOL_FORCE_DWORD             = 0x7fffffff
};
#endif

// -------------------------------------------------------------------------
// data structures shared by User mode and Kernel mode.
// -------------------------------------------------------------------------
//

typedef struct _DXVA_Frequency {
    DWORD Numerator;
    DWORD Denominator;
} DXVA_Frequency;

typedef struct _DXVA_VideoDesc {
    DWORD               Size;
    DWORD               SampleWidth;
    DWORD               SampleHeight;
    DWORD               SampleFormat; // also contains extend color data
    D3DFORMAT           d3dFormat;
    DXVA_Frequency      InputSampleFreq;
    DXVA_Frequency      OutputFrameFreq;
} DXVA_VideoDesc, *LPDXVA_VideoDesc;

typedef enum _DXVA_VideoProcessCaps {
    DXVA_VideoProcess_None                  = 0x0000,
    DXVA_VideoProcess_YUV2RGB               = 0x0001,
    DXVA_VideoProcess_StretchX              = 0x0002,
    DXVA_VideoProcess_StretchY              = 0x0004,
    DXVA_VideoProcess_AlphaBlend            = 0x0008,
    DXVA_VideoProcess_SubRects              = 0x0010,
    DXVA_VideoProcess_SubStreams            = 0x0020,
    DXVA_VideoProcess_SubStreamsExtended    = 0x0040,
    DXVA_VideoProcess_YUV2RGBExtended       = 0x0080,
    DXVA_VideoProcess_AlphaBlendExtended    = 0x0100
} DXVA_VideoProcessCaps;

typedef enum _DXVA_DeinterlaceTech {

    // the algorithm is unknown or proprietary
    DXVA_DeinterlaceTech_Unknown                = 0x0000,

    // the algorithm creates the missing lines by repeating
    // the line either above or below it - this method will look very jaggy and
    // isn't recommended
    DXVA_DeinterlaceTech_BOBLineReplicate       = 0x0001,

    // The algorithm creates the missing lines by vertically stretching each
    // video field by a factor of two by averaging two lines
    DXVA_DeinterlaceTech_BOBVerticalStretch     = 0x0002,

    // or using a [-1, 9, 9, -1]/16 filter across four lines.
    DXVA_DeinterlaceTech_BOBVerticalStretch4Tap = 0x0100,

    // the pixels in the missing line are recreated by a median filtering operation
    DXVA_DeinterlaceTech_MedianFiltering        = 0x0004,

    // the pixels in the missing line are recreated by an edge filter.
    // In this process, spatial directional filters are applied to determine
    // the orientation of edges in the picture content, and missing
    // pixels are created by filtering along (rather than across) the
    // detected edges.
    DXVA_DeinterlaceTech_EdgeFiltering          = 0x0010,

    // the pixels in the missing line are recreated by switching on a field by
    // field basis between using either spatial or temporal interpolation
    // depending on the amount of motion.
    DXVA_DeinterlaceTech_FieldAdaptive          = 0x0020,

    // the pixels in the missing line are recreated by switching on a pixel by pixel
    // basis between using either spatial or temporal interpolation depending on
    // the amount of motion..
    DXVA_DeinterlaceTech_PixelAdaptive          = 0x0040,

    // Motion Vector Steering  identifies objects within a sequence of video
    // fields.  The missing pixels are recreated after first aligning the
    // movement axes of the individual objects in the scene to make them
    // parallel with the time axis.
    DXVA_DeinterlaceTech_MotionVectorSteered      = 0x0080

} DXVA_DeinterlaceTech;

typedef struct _DXVA_VideoSample {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DXVA_SampleFormat   SampleFormat;   // only lower 8 bits used
    VOID*               lpDDSSrcSurface;
} DXVA_VideoSample, *LPDXVA_VideoSample;

// -------------------------------------------------------------------------
// DeinterlaceBltEx declarations
// -------------------------------------------------------------------------
//

typedef enum _DXVA_SampleFlags {
    DXVA_SampleFlagsMask = DXVABit(3)|DXVABit(2)|DXVABit(1)|DXVABit(0),

    DXVA_SampleFlag_Palette_Changed         = 0x0001,
    DXVA_SampleFlag_SrcRect_Changed         = 0x0002,
    DXVA_SampleFlag_DstRect_Changed         = 0x0004,
    DXVA_SampleFlag_ColorData_Changed       = 0x0008,
} DXVA_SampleFlags;

typedef enum _DXVA_DestinationFlags {
    DXVA_DestinationFlagMask = DXVABit(3)|DXVABit(2)|DXVABit(1)|DXVABit(0),

    DXVA_DestinationFlag_Background_Changed = 0x0001,
    DXVA_DestinationFlag_TargetRect_Changed = 0x0002,
    DXVA_DestinationFlag_ColorData_Changed  = 0x0004,
    DXVA_DestinationFlag_Alpha_Changed      = 0x0008
} DXVA_DestinationFlags;

typedef struct _DXVA_VideoSample2 {
#ifdef _WIN64
    DWORD               Size;
    DWORD               Reserved;
#endif
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DWORD               SampleFormat;   // cast to DXVA_ExtendedFormat, or use Extract macros
    DWORD               SampleFlags;
    VOID*               lpDDSSrcSurface;
    RECT                rcSrc;
    RECT                rcDst;
    DXVA_AYUVsample2    Palette[16];
} DXVA_VideoSample2, *LPDXVA_VideoSample2;

typedef struct _DXVA_DeinterlaceCaps {
    DWORD                   Size;
    DWORD                   NumPreviousOutputFrames;
    DWORD                   InputPool;
    DWORD                   NumForwardRefSamples;
    DWORD                   NumBackwardRefSamples;
    D3DFORMAT               d3dOutputFormat;
    DXVA_VideoProcessCaps   VideoProcessingCaps;
    DXVA_DeinterlaceTech    DeinterlaceTechnology;
} DXVA_DeinterlaceCaps, *LPDXVA_DeinterlaceCaps;

// -------------------------------------------------------------------------
// Data types used with RenderMoComp in kernel mode
// -------------------------------------------------------------------------
//

// Function codes for RenderMoComp

#define MAX_DEINTERLACE_SURFACES                        32

#ifdef _WIN64
//
// These structures are used for thunking 32 bit DeinterlaceBltEx calls on
// 64 bit drivers.
//
typedef struct _DXVA_VideoSample32 {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DWORD               SampleFormat;
    DWORD               SampleFlags;
    DWORD               lpDDSSrcSurface;  // 32 bit pointer size
    RECT                rcSrc;
    RECT                rcDst;
    DXVA_AYUVsample2    Palette[16];
    // DWORD Pad;
    // 4 bytes of padding added by the compiler to align the struct to 8 bytes.
} DXVA_VideoSample32;

typedef struct _DXVA_DeinterlaceBltEx32 {
    DWORD               Size;
    DXVA_AYUVsample2    BackgroundColor;
    RECT                rcTarget;
    REFERENCE_TIME      rtTarget;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample32  Source[MAX_DEINTERLACE_SURFACES];
    DWORD               DestinationFormat;
    DWORD               DestinationFlags;
} DXVA_DeinterlaceBltEx32;
#endif

typedef struct _DXVA_DeinterlaceBlt {
    DWORD               Size;
    DWORD               Reserved;
    REFERENCE_TIME      rtTarget;
    RECT                DstRect;
    RECT                SrcRect;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample    Source[MAX_DEINTERLACE_SURFACES];
} DXVA_DeinterlaceBlt;

#define DXVA_DeinterlaceBltFnCode                     0x01
// lpInput => DXVA_DeinterlaceBlt*
// lpOuput => NULL /* not currently used */

typedef struct _DXVA_DeinterlaceBltEx {
    DWORD               Size;
    DXVA_AYUVsample2    BackgroundColor;
    RECT                rcTarget;
    REFERENCE_TIME      rtTarget;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample2   Source[MAX_DEINTERLACE_SURFACES];
    DWORD               DestinationFormat;
    DWORD               DestinationFlags;
} DXVA_DeinterlaceBltEx;

#define DXVA_DeinterlaceBltExFnCode                   0x02
// lpInput => DXVA_DeinterlaceBltEx*
// lpOuput => NULL /* not currently used */

#define MAX_DEINTERLACE_DEVICE_GUIDS                    32
typedef struct _DXVA_DeinterlaceQueryAvailableModes {
    DWORD               Size;
    DWORD               NumGuids;
    GUID                Guids[MAX_DEINTERLACE_DEVICE_GUIDS];
} DXVA_DeinterlaceQueryAvailableModes;

#define DXVA_DeinterlaceQueryAvailableModesFnCode     0x01
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_DeinterlaceQueryAvailableModes*

typedef struct _DXVA_DeinterlaceQueryModeCaps {
    DWORD               Size;
    GUID                Guid;
    DXVA_VideoDesc      VideoDesc;
} DXVA_DeinterlaceQueryModeCaps;

#define DXVA_DeinterlaceQueryModeCapsFnCode           0x02
// lpInput => DXVA_DeinterlaceQueryModeCaps*
// lpOuput => DXVA_DeinterlaceCaps*

#endif /* __DIRECTX_VA_DEINTERLACE__ */

// -------------------------------------------------------------------------
//
// The definitions that follow describe the video ProcAmp interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_PROCAMPCONTROL__
#define __DIRECTX_VA_PROCAMPCONTROL__

DEFINE_GUID(DXVA_ProcAmpControlDevice,
    0x9f200913,0x2ffd,0x4056,0x9f,0x1e,0xe1,0xb5,0x08,0xf2,0x2d,0xcf);

typedef enum _DXVA_ProcAmpControlProp {
    DXVA_ProcAmp_None       = 0x0000,
    DXVA_ProcAmp_Brightness = 0x0001,
    DXVA_ProcAmp_Contrast   = 0x0002,
    DXVA_ProcAmp_Hue        = 0x0004,
    DXVA_ProcAmp_Saturation = 0x0008
} DXVA_ProcAmpControlProp;

typedef struct _DXVA_ProcAmpControlCaps {
    DWORD                   Size;
    DWORD                   InputPool;
    D3DFORMAT               d3dOutputFormat;
    DWORD                   ProcAmpControlProps;// see DXVA_ProcAmpControlProp
    DWORD                   VideoProcessingCaps;// see DXVA_VideoProcessCaps
} DXVA_ProcAmpControlCaps, *LPDXVA_ProcAmpControlCaps;

#define DXVA_ProcAmpControlQueryCapsFnCode             0x03
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_ProcAmpControlCaps*

typedef struct _DXVA_ProcAmpControlQueryRange {
    DWORD                   Size;
    DXVA_ProcAmpControlProp ProcAmpControlProp;
    DXVA_VideoDesc          VideoDesc;
} DXVA_ProcAmpControlQueryRange, *LPDXVA_ProcAmpControlQueryRange;

typedef struct _DXVA_VideoPropertyRange {
    FLOAT   MinValue;
    FLOAT   MaxValue;
    FLOAT   DefaultValue;
    FLOAT   StepSize;
} DXVA_VideoPropertyRange, *LPDXVA_VideoPropertyRange;

#define DXVA_ProcAmpControlQueryRangeFnCode            0x04
// lpInput => DXVA_ProcAmpControlQueryRange*
// lpOuput => DXVA_VideoPropertyRange*

typedef struct _DXVA_ProcAmpControlBlt {
    DWORD               Size;
    RECT                DstRect;
    RECT                SrcRect;
    FLOAT               Alpha;
    FLOAT               Brightness;
    FLOAT               Contrast;
    FLOAT               Hue;
    FLOAT               Saturation;
} DXVA_ProcAmpControlBlt;

#define DXVA_ProcAmpControlBltFnCode                   0x01
// lpInput => DXVA_ProcAmpControlBlt*
// lpOuput => NULL /* not currently used */

#endif /* __DIRECTX_VA_PROCAMPCONTROL__ */

// -------------------------------------------------------------------------
//
// The definitions that follow describe the Certified Output Protection
// Protocol between the VMR and the graphics device driver.  This interface
// is not accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_CERTOUTPUTPROTECT__
#define __DIRECTX_VA_CERTOUTPUTPROTECT__

DEFINE_GUID(DXVA_COPPDevice,
    0xd2457add,0x8999,0x45ed,0x8a,0x8a,0xd1,0xaa,0x04,0x7b,0xa4,0xd5);

// -------------------------------------------------------------------------
// COPPGetCertificateLength
// -------------------------------------------------------------------------
#define DXVA_COPPGetCertificateLengthFnCode         0x01
// lpInput => NULL
// lpOuput => DWORD*

// -------------------------------------------------------------------------
// COPPKeyExchange
// -------------------------------------------------------------------------
#define DXVA_COPPKeyExchangeFnCode                  0x02
// lpInputData => NULL
// lpOuputData => GUID*

// -------------------------------------------------------------------------
// COPPSequenceStart
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPSignature {
    UCHAR   Signature[256];
} DXVA_COPPSignature, *LPDXVA_COPPSignature;

#define DXVA_COPPSequenceStartFnCode                0x03
// lpInputData => DXVA_COPPSignature*
// lpOuputData => NULL

// -------------------------------------------------------------------------
// COPPCommand
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPCommand {
    GUID    macKDI;             //   16 bytes
    GUID    guidCommandID;      //   16 bytes
    ULONG   dwSequence;         //    4 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   CommandData[4056];  // 4056 bytes (4056+4+4+16+16 = 4096)
}  DXVA_COPPCommand, *LPDXVA_COPPCommand;

#define DXVA_COPPCommandFnCode                      0x04
// lpInputData => DXVA_COPPCommand*
// lpOuputData => NULL

DEFINE_GUID(DXVA_COPPSetProtectionLevel,
    0x9bb9327c,0x4eb5,0x4727,0x9f,0x00,0xb4,0x2b,0x09,0x19,0xc0,0xda);

typedef struct _DXVA_COPPSetProtectionLevelCmdData {
    ULONG   ProtType;
    ULONG   ProtLevel;
    ULONG   ExtendedInfoChangeMask;
    ULONG   ExtendedInfoData;
} DXVA_COPPSetProtectionLevelCmdData;

// Set the HDCP protection level - (0 - 1 DWORD, 4 bytes)

typedef enum _COPP_HDCP_Protection_Level {
    COPP_HDCP_Level0    = 0,
    COPP_HDCP_LevelMin  = COPP_HDCP_Level0,
    COPP_HDCP_Level1    = 1,
    COPP_HDCP_LevelMax  = COPP_HDCP_Level1,
    COPP_HDCP_ForceDWORD = 0x7fffffff
} COPP_HDCP_Protection_Level;

typedef enum _COPP_CGMSA_Protection_Level {
    COPP_CGMSA_Disabled = 0,
    COPP_CGMSA_LevelMin = COPP_CGMSA_Disabled,
    COPP_CGMSA_CopyFreely = 1,
    COPP_CGMSA_CopyNoMore = 2,
    COPP_CGMSA_CopyOneGeneration   = 3,
    COPP_CGMSA_CopyNever = 4,
    COPP_CGMSA_RedistributionControlRequired = 0x08,
    COPP_CGMSA_LevelMax = (COPP_CGMSA_RedistributionControlRequired + COPP_CGMSA_CopyNever),
    COPP_CGMSA_ForceDWORD = 0x7fffffff
} COPP_CGMSA_Protection_Level;

typedef enum _COPP_ACP_Protection_Level {
    COPP_ACP_Level0     = 0,
    COPP_ACP_LevelMin   = COPP_ACP_Level0,
    COPP_ACP_Level1     = 1,
    COPP_ACP_Level2     = 2,
    COPP_ACP_Level3     = 3,
    COPP_ACP_LevelMax   = COPP_ACP_Level3,
    COPP_ACP_ForceDWORD = 0x7fffffff
} COPP_ACP_Protection_Level;

#define COPP_NoProtectionLevelAvailable  -1
#define COPP_DefaultProtectionLevel 0

//
// Bit flags of possible protection types.  Note that it is possible to apply
// different protection settings to a single connector.
//
enum {
    COPP_ProtectionType_Unknown      = 0x80000000,
    COPP_ProtectionType_None         = 0x00000000,
    COPP_ProtectionType_HDCP         = 0x00000001, 	
    COPP_ProtectionType_ACP          = 0x00000002,
    COPP_ProtectionType_CGMSA        = 0x00000004,
    COPP_ProtectionType_Mask         = 0x80000007,
    COPP_ProtectionType_Reserved     = 0x7FFFFFF8
};

DEFINE_GUID(DXVA_COPPSetSignaling,
    0x9a631a5, 0xd684, 0x4c60, 0x8e, 0x4d, 0xd3, 0xbb, 0xf, 0xb, 0xe3, 0xee);

typedef struct _DXVA_COPPSetSignalingCmdData {
    ULONG   ActiveTVProtectionStandard;           // See COPP_TVProtectionStandard
    ULONG   AspectRatioChangeMask1;
    ULONG   AspectRatioData1;                     // See COPP_ImageAspectRatio_EN300294 for ETSI EN 300 294 values
    ULONG   AspectRatioChangeMask2;
    ULONG   AspectRatioData2;
    ULONG   AspectRatioChangeMask3;
    ULONG   AspectRatioData3;
    ULONG   ExtendedInfoChangeMask[4];
    ULONG   ExtendedInfoData[4];
    ULONG   Reserved;
} DXVA_COPPSetSignalingCmdData;

// Add format enum and data enum
typedef enum _COPP_TVProtectionStandard {
    COPP_ProtectionStandard_Unknown                         = 0x80000000,
    COPP_ProtectionStandard_None                            = 0x00000000,
    COPP_ProtectionStandard_IEC61880_525i                   = 0x00000001,
    COPP_ProtectionStandard_IEC61880_2_525i                 = 0x00000002,
    COPP_ProtectionStandard_IEC62375_625p                   = 0x00000004,
    COPP_ProtectionStandard_EIA608B_525                     = 0x00000008,
    COPP_ProtectionStandard_EN300294_625i                   = 0x00000010,
    COPP_ProtectionStandard_CEA805A_TypeA_525p              = 0x00000020,
    COPP_ProtectionStandard_CEA805A_TypeA_750p              = 0x00000040,
    COPP_ProtectionStandard_CEA805A_TypeA_1125i             = 0x00000080,
    COPP_ProtectionStandard_CEA805A_TypeB_525p              = 0x00000100,
    COPP_ProtectionStandard_CEA805A_TypeB_750p              = 0x00000200,
    COPP_ProtectionStandard_CEA805A_TypeB_1125i             = 0x00000400,
    COPP_ProtectionStandard_ARIBTRB15_525i                  = 0x00000800,
    COPP_ProtectionStandard_ARIBTRB15_525p                  = 0x00001000,
    COPP_ProtectionStandard_ARIBTRB15_750p                  = 0x00002000,
    COPP_ProtectionStandard_ARIBTRB15_1125i                 = 0x00004000,
    COPP_ProtectionStandard_Mask                            = 0x80007FFF,
    COPP_ProtectionStandard_Reserved                        = 0x7FFF8000
} COPP_TVProtectionStandard;

#define COPP_ImageAspectRatio_EN300294_Mask                 0x00000007

typedef enum _COPP_ImageAspectRatio_EN300294 {
    COPP_AspectRatio_EN300294_FullFormat4by3                = 0,
    COPP_AspectRatio_EN300294_Box14by9Center                = 1,
    COPP_AspectRatio_EN300294_Box14by9Top                   = 2,
    COPP_AspectRatio_EN300294_Box16by9Center                = 3,
    COPP_AspectRatio_EN300294_Box16by9Top                   = 4,
    COPP_AspectRatio_EN300294_BoxGT16by9Center              = 5,
    COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = 6,
    COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic     = 7,
    COPP_AspectRatio_ForceDWORD                             = 0x7fffffff
} COPP_ImageAspectRatio_EN300294;

// -------------------------------------------------------------------------
// COPPQueryStatus
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPStatusInput {
    GUID    rApp;               //   16 bytes
    GUID    guidStatusRequestID;//   16 bytes
    ULONG   dwSequence;         //    4 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   StatusData[4056];   // 4056 bytes (4056+4+4+16+16 = 4096)
} DXVA_COPPStatusInput, *LPDXVA_COPPStatusInput;

typedef struct _DXVA_COPPStatusOutput {
    GUID    macKDI;             //   16 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   COPPStatus[4076];   // 4076 bytes (4076+16+4 = 4096)
} DXVA_COPPStatusOutput, *LPDXVA_COPPStatusOutput;

typedef enum _COPP_StatusFlags {
    COPP_StatusNormal           = 0x00,
    COPP_LinkLost               = 0x01,
    COPP_RenegotiationRequired  = 0x02,
    COPP_StatusFlagsReserved    = 0xFFFFFFFC
} COPP_StatusFlags;

typedef struct _DXVA_COPPStatusData {
    GUID    rApp;
    ULONG   dwFlags;    // See COPP_StatusFlags above
    ULONG   dwData;
    ULONG   ExtendedInfoValidMask;
    ULONG   ExtendedInfoData;
} DXVA_COPPStatusData;

typedef struct _DXVA_COPPStatusDisplayData {
    GUID    rApp;
    ULONG   dwFlags;    // See COPP_StatusFlags above
    ULONG   DisplayWidth;
    ULONG   DisplayHeight;
    ULONG   Format;     // also contains extended color data
    ULONG   d3dFormat;
    ULONG   FreqNumerator;
    ULONG   FreqDenominator;
} DXVA_COPPStatusDisplayData;

typedef enum _COPP_StatusHDCPFlags {
    COPP_HDCPRepeater       = 0x01,
    COPP_HDCPFlagsReserved  = 0xFFFFFFFE
} COPP_StatusHDCPFlags;

typedef struct _DXVA_COPPStatusHDCPKeyData {
    GUID    rApp;
    ULONG   dwFlags;        // See COPP_StatusFlags above
    ULONG   dwHDCPFlags;    // See COPP_StatusHDCPFlags above
    GUID    BKey;           // Lower 40 bits
    GUID    Reserved1;
    GUID    Reserved2;
} DXVA_COPPStatusHDCPKeyData;

#define DXVA_COPPQueryStatusFnCode 0x05
// lpInputData => DXVA_COPPStatusInput*
// lpOuputData => DXVA_COPPStatusOutput*

//
// Status GUID and enumerations
//
DEFINE_GUID(DXVA_COPPQueryConnectorType,
      0x81d0bfd5,0x6afe,0x48c2,0x99,0xc0,0x95,0xa0,0x8f,0x97,0xc5,0xda);

typedef enum _COPP_ConnectorType {
    COPP_ConnectorType_Unknown = -1,
    COPP_ConnectorType_VGA = 0,
    COPP_ConnectorType_SVideo = 1,
    COPP_ConnectorType_CompositeVideo = 2,
    COPP_ConnectorType_ComponentVideo = 3,
    COPP_ConnectorType_DVI = 4,
    COPP_ConnectorType_HDMI = 5,
    COPP_ConnectorType_LVDS = 6,
    COPP_ConnectorType_TMDS = 7,
    COPP_ConnectorType_D_JPN = 8,
    COPP_ConnectorType_Internal = 0x80000000,   // can be combined with the other connector types
    COPP_ConnectorType_ForceDWORD = 0x7fffffff  /* force 32-bit size enum */
} COPP_ConnectorType;

DEFINE_GUID(DXVA_COPPQueryProtectionType,
    0x38f2a801,0x9a6c,0x48bb,0x91,0x07,0xb6,0x69,0x6e,0x6f,0x17,0x97);

DEFINE_GUID(DXVA_COPPQueryLocalProtectionLevel,
    0xb2075857,0x3eda,0x4d5d,0x88,0xdb,0x74,0x8f,0x8c,0x1a,0x05,0x49);

DEFINE_GUID(DXVA_COPPQueryGlobalProtectionLevel,
    0x1957210a,0x7766,0x452a,0xb9,0x9a,0xd2,0x7a,0xed,0x54,0xf0,0x3a);

DEFINE_GUID(DXVA_COPPQueryDisplayData,
    0xd7bf1ba3,0xad13,0x4f8e,0xaf,0x98,0x0d,0xcb,0x3c,0xa2,0x04,0xcc);

DEFINE_GUID(DXVA_COPPQueryHDCPKeyData,
    0xdb59d74, 0xa992, 0x492e, 0xa0, 0xbd, 0xc2, 0x3f, 0xda, 0x56, 0x4e, 0x0);

DEFINE_GUID(DXVA_COPPQueryBusData,
    0xc6f4d673, 0x6174, 0x4184, 0x8e, 0x35, 0xf6, 0xdb, 0x52, 0x0, 0xbc, 0xba);

typedef enum _COPP_BusType {
    COPP_BusType_Unknown    = 0,
    COPP_BusType_PCI        = 1,
    COPP_BusType_PCIX       = 2,
    COPP_BusType_PCIExpress = 3,
    COPP_BusType_AGP        = 4,
    COPP_BusType_Integrated = 0x80000000, // can be combined with the other bus types
    COPP_BusType_ForceDWORD = 0x7fffffff  /* force 32-bit size enum */
} COPP_BusType;

DEFINE_GUID(DXVA_COPPQuerySignaling,
    0x6629a591, 0x3b79, 0x4cf3, 0x92, 0x4a, 0x11, 0xe8, 0xe7, 0x81, 0x16, 0x71);

typedef struct _DXVA_COPPStatusSignalingCmdData {
    GUID    rApp;
    ULONG   dwFlags;                                // See COPP_StatusFlags above
    ULONG   AvailableTVProtectionStandards;         // See COPP_TVProtectionStandard
    ULONG   ActiveTVProtectionStandard;             // See COPP_TVProtectionStandard
    ULONG   TVType;
    ULONG   AspectRatioValidMask1;
    ULONG   AspectRatioData1;                       // See COPP_AspectRatio_EN300294 for ETSI EN 300 294 values
    ULONG   AspectRatioValidMask2;
    ULONG   AspectRatioData2;
    ULONG   AspectRatioValidMask3;
    ULONG   AspectRatioData3;
    ULONG   ExtendedInfoValidMask[4];
    ULONG   ExtendedInfoData[4];
} DXVA_COPPStatusSignalingCmdData;

#endif /* __DIRECTX_VA_CERTOUTPUTPROTECT__ */

#endif /* (DIRECT3D_VERSION >= 0x0900) */
#endif /* _DXVA9TYP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\dsfif.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for dsfif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __dsfif_h__
#define __dsfif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDSFResourceList_FWD_DEFINED__
#define __IDSFResourceList_FWD_DEFINED__
typedef interface IDSFResourceList IDSFResourceList;
#endif 	/* __IDSFResourceList_FWD_DEFINED__ */


#ifndef __IDSFFullResourceDescriptor_FWD_DEFINED__
#define __IDSFFullResourceDescriptor_FWD_DEFINED__
typedef interface IDSFFullResourceDescriptor IDSFFullResourceDescriptor;
#endif 	/* __IDSFFullResourceDescriptor_FWD_DEFINED__ */


#ifndef __IDSFDevice_FWD_DEFINED__
#define __IDSFDevice_FWD_DEFINED__
typedef interface IDSFDevice IDSFDevice;
#endif 	/* __IDSFDevice_FWD_DEFINED__ */


#ifndef __IDSFDeviceCaps_FWD_DEFINED__
#define __IDSFDeviceCaps_FWD_DEFINED__
typedef interface IDSFDeviceCaps IDSFDeviceCaps;
#endif 	/* __IDSFDeviceCaps_FWD_DEFINED__ */


#ifndef __IDSFDeviceEvents_FWD_DEFINED__
#define __IDSFDeviceEvents_FWD_DEFINED__
typedef interface IDSFDeviceEvents IDSFDeviceEvents;
#endif 	/* __IDSFDeviceEvents_FWD_DEFINED__ */


#ifndef __IDSF_FWD_DEFINED__
#define __IDSF_FWD_DEFINED__
typedef interface IDSF IDSF;
#endif 	/* __IDSF_FWD_DEFINED__ */


#ifndef __IDSFDevices_FWD_DEFINED__
#define __IDSFDevices_FWD_DEFINED__
typedef interface IDSFDevices IDSFDevices;
#endif 	/* __IDSFDevices_FWD_DEFINED__ */


#ifndef __IDSFLog_FWD_DEFINED__
#define __IDSFLog_FWD_DEFINED__
typedef interface IDSFLog IDSFLog;
#endif 	/* __IDSFLog_FWD_DEFINED__ */


#ifndef __IDSFVersion_FWD_DEFINED__
#define __IDSFVersion_FWD_DEFINED__
typedef interface IDSFVersion IDSFVersion;
#endif 	/* __IDSFVersion_FWD_DEFINED__ */


#ifndef __IDSFPropertyBag_FWD_DEFINED__
#define __IDSFPropertyBag_FWD_DEFINED__
typedef interface IDSFPropertyBag IDSFPropertyBag;
#endif 	/* __IDSFPropertyBag_FWD_DEFINED__ */


#ifndef __IDSFBus_FWD_DEFINED__
#define __IDSFBus_FWD_DEFINED__
typedef interface IDSFBus IDSFBus;
#endif 	/* __IDSFBus_FWD_DEFINED__ */


#ifndef __IDSFPartialResourceDescriptor_FWD_DEFINED__
#define __IDSFPartialResourceDescriptor_FWD_DEFINED__
typedef interface IDSFPartialResourceDescriptor IDSFPartialResourceDescriptor;
#endif 	/* __IDSFPartialResourceDescriptor_FWD_DEFINED__ */


#ifndef __DSFPartialResourceDescriptor_FWD_DEFINED__
#define __DSFPartialResourceDescriptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFPartialResourceDescriptor DSFPartialResourceDescriptor;
#else
typedef struct DSFPartialResourceDescriptor DSFPartialResourceDescriptor;
#endif /* __cplusplus */

#endif 	/* __DSFPartialResourceDescriptor_FWD_DEFINED__ */


#ifndef __IDSFPartialResourceList_FWD_DEFINED__
#define __IDSFPartialResourceList_FWD_DEFINED__
typedef interface IDSFPartialResourceList IDSFPartialResourceList;
#endif 	/* __IDSFPartialResourceList_FWD_DEFINED__ */


#ifndef __DSFPartialResourceList_FWD_DEFINED__
#define __DSFPartialResourceList_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFPartialResourceList DSFPartialResourceList;
#else
typedef struct DSFPartialResourceList DSFPartialResourceList;
#endif /* __cplusplus */

#endif 	/* __DSFPartialResourceList_FWD_DEFINED__ */


#ifndef __DSFFullResourceDescriptor_FWD_DEFINED__
#define __DSFFullResourceDescriptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFFullResourceDescriptor DSFFullResourceDescriptor;
#else
typedef struct DSFFullResourceDescriptor DSFFullResourceDescriptor;
#endif /* __cplusplus */

#endif 	/* __DSFFullResourceDescriptor_FWD_DEFINED__ */


#ifndef __DSFResourceList_FWD_DEFINED__
#define __DSFResourceList_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResourceList DSFResourceList;
#else
typedef struct DSFResourceList DSFResourceList;
#endif /* __cplusplus */

#endif 	/* __DSFResourceList_FWD_DEFINED__ */


#ifndef __IDSFResDescPort_FWD_DEFINED__
#define __IDSFResDescPort_FWD_DEFINED__
typedef interface IDSFResDescPort IDSFResDescPort;
#endif 	/* __IDSFResDescPort_FWD_DEFINED__ */


#ifndef __DSFResDescPort_FWD_DEFINED__
#define __DSFResDescPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResDescPort DSFResDescPort;
#else
typedef struct DSFResDescPort DSFResDescPort;
#endif /* __cplusplus */

#endif 	/* __DSFResDescPort_FWD_DEFINED__ */


#ifndef __IDSFResDescDevSpecific_FWD_DEFINED__
#define __IDSFResDescDevSpecific_FWD_DEFINED__
typedef interface IDSFResDescDevSpecific IDSFResDescDevSpecific;
#endif 	/* __IDSFResDescDevSpecific_FWD_DEFINED__ */


#ifndef __DSFResDescDevSpecific_FWD_DEFINED__
#define __DSFResDescDevSpecific_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResDescDevSpecific DSFResDescDevSpecific;
#else
typedef struct DSFResDescDevSpecific DSFResDescDevSpecific;
#endif /* __cplusplus */

#endif 	/* __DSFResDescDevSpecific_FWD_DEFINED__ */


#ifndef __IDSFResDescDevPrivate_FWD_DEFINED__
#define __IDSFResDescDevPrivate_FWD_DEFINED__
typedef interface IDSFResDescDevPrivate IDSFResDescDevPrivate;
#endif 	/* __IDSFResDescDevPrivate_FWD_DEFINED__ */


#ifndef __DSFResDescDevPrivate_FWD_DEFINED__
#define __DSFResDescDevPrivate_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResDescDevPrivate DSFResDescDevPrivate;
#else
typedef struct DSFResDescDevPrivate DSFResDescDevPrivate;
#endif /* __cplusplus */

#endif 	/* __DSFResDescDevPrivate_FWD_DEFINED__ */


#ifndef __IDSFResDescInterrupt_FWD_DEFINED__
#define __IDSFResDescInterrupt_FWD_DEFINED__
typedef interface IDSFResDescInterrupt IDSFResDescInterrupt;
#endif 	/* __IDSFResDescInterrupt_FWD_DEFINED__ */


#ifndef __DSFResDescInterrupt_FWD_DEFINED__
#define __DSFResDescInterrupt_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResDescInterrupt DSFResDescInterrupt;
#else
typedef struct DSFResDescInterrupt DSFResDescInterrupt;
#endif /* __cplusplus */

#endif 	/* __DSFResDescInterrupt_FWD_DEFINED__ */


#ifndef __IDSFResDescMemory_FWD_DEFINED__
#define __IDSFResDescMemory_FWD_DEFINED__
typedef interface IDSFResDescMemory IDSFResDescMemory;
#endif 	/* __IDSFResDescMemory_FWD_DEFINED__ */


#ifndef __DSFResDescMemory_FWD_DEFINED__
#define __DSFResDescMemory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResDescMemory DSFResDescMemory;
#else
typedef struct DSFResDescMemory DSFResDescMemory;
#endif /* __cplusplus */

#endif 	/* __DSFResDescMemory_FWD_DEFINED__ */


#ifndef __IDSFResDescDMA_FWD_DEFINED__
#define __IDSFResDescDMA_FWD_DEFINED__
typedef interface IDSFResDescDMA IDSFResDescDMA;
#endif 	/* __IDSFResDescDMA_FWD_DEFINED__ */


#ifndef __DSFResDescDMA_FWD_DEFINED__
#define __DSFResDescDMA_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFResDescDMA DSFResDescDMA;
#else
typedef struct DSFResDescDMA DSFResDescDMA;
#endif /* __cplusplus */

#endif 	/* __DSFResDescDMA_FWD_DEFINED__ */


#ifndef __IDSFSystemDevice_FWD_DEFINED__
#define __IDSFSystemDevice_FWD_DEFINED__
typedef interface IDSFSystemDevice IDSFSystemDevice;
#endif 	/* __IDSFSystemDevice_FWD_DEFINED__ */


#ifndef __DSFSystemDevice_FWD_DEFINED__
#define __DSFSystemDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFSystemDevice DSFSystemDevice;
#else
typedef struct DSFSystemDevice DSFSystemDevice;
#endif /* __cplusplus */

#endif 	/* __DSFSystemDevice_FWD_DEFINED__ */


#ifndef __DSFDevice_FWD_DEFINED__
#define __DSFDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFDevice DSFDevice;
#else
typedef struct DSFDevice DSFDevice;
#endif /* __cplusplus */

#endif 	/* __DSFDevice_FWD_DEFINED__ */


#ifndef __DSF_FWD_DEFINED__
#define __DSF_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSF DSF;
#else
typedef struct DSF DSF;
#endif /* __cplusplus */

#endif 	/* __DSF_FWD_DEFINED__ */


#ifndef __DSFDevices_FWD_DEFINED__
#define __DSFDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFDevices DSFDevices;
#else
typedef struct DSFDevices DSFDevices;
#endif /* __cplusplus */

#endif 	/* __DSFDevices_FWD_DEFINED__ */


#ifndef __DSFDeviceCaps_FWD_DEFINED__
#define __DSFDeviceCaps_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFDeviceCaps DSFDeviceCaps;
#else
typedef struct DSFDeviceCaps DSFDeviceCaps;
#endif /* __cplusplus */

#endif 	/* __DSFDeviceCaps_FWD_DEFINED__ */


#ifndef __DSFLog_FWD_DEFINED__
#define __DSFLog_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFLog DSFLog;
#else
typedef struct DSFLog DSFLog;
#endif /* __cplusplus */

#endif 	/* __DSFLog_FWD_DEFINED__ */


#ifndef __DSFVersion_FWD_DEFINED__
#define __DSFVersion_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFVersion DSFVersion;
#else
typedef struct DSFVersion DSFVersion;
#endif /* __cplusplus */

#endif 	/* __DSFVersion_FWD_DEFINED__ */


#ifndef __DSFPropertyBag_FWD_DEFINED__
#define __DSFPropertyBag_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFPropertyBag DSFPropertyBag;
#else
typedef struct DSFPropertyBag DSFPropertyBag;
#endif /* __cplusplus */

#endif 	/* __DSFPropertyBag_FWD_DEFINED__ */


#ifndef __IDSFDebug_FWD_DEFINED__
#define __IDSFDebug_FWD_DEFINED__
typedef interface IDSFDebug IDSFDebug;
#endif 	/* __IDSFDebug_FWD_DEFINED__ */


#ifndef __DSFDebug_FWD_DEFINED__
#define __DSFDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFDebug DSFDebug;
#else
typedef struct DSFDebug DSFDebug;
#endif /* __cplusplus */

#endif 	/* __DSFDebug_FWD_DEFINED__ */


#ifndef __DSFBus_FWD_DEFINED__
#define __DSFBus_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSFBus DSFBus;
#else
typedef struct DSFBus DSFBus;
#endif /* __cplusplus */

#endif 	/* __DSFBus_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __DSF_LIBRARY_DEFINED__
#define __DSF_LIBRARY_DEFINED__

/* library DSF */
/* [helpstringcontext][helpcontext][helpstring][helpstringdll][helpfile][version][lcid][uuid] */ 






















typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("993417C7-E892-4F80-9295-1321623DD50D") 
enum DSFSystemPowerState
    {	DSFPowerSystemUnspecified	= 0,
	DSFPowerSystemWorking	= 1,
	DSFPowerSystemSleeping1	= 2,
	DSFPowerSystemSleeping2	= 3,
	DSFPowerSystemSleeping3	= 4,
	DSFPowerSystemHibernate	= 5,
	DSFPowerSystemShutdown	= 6
    } 	DSFSystemPowerState;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("7B8AD659-B4EF-48C4-A189-9637BD56F086") 
enum DSFDevicePowerState
    {	DSFPowerDeviceUnspecified	= 0,
	DSFPowerDeviceD0	= 1,
	DSFPowerDeviceD1	= 2,
	DSFPowerDeviceD2	= 3,
	DSFPowerDeviceD3	= 4
    } 	DSFDevicePowerState;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("C936205A-C69B-45E4-8D19-6BE3CAC15E11") 
enum DSFBitOp
    {	DSFBitOff	= 0,
	DSFBitOn	= 1,
	DSFBitToggle	= 2
    } 	DSFBitOp;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("52CAB7A6-B8AC-474D-AB38-05A4AAF21FE7") 
enum DSFOpMode
    {	DSFCapture	= 0,
	DSFSimulate	= 1,
	DSFCaptureAndSimulate	= 2
    } 	DSFOpMode;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("7D4BA3AD-960C-4A3B-A6CC-3677AD9E0EDE") 
enum DSFResourceType
    {	DSFResourceTypeNull	= 0,
	DSFResourceTypePort	= 1,
	DSFResourceTypeInterrupt	= 2,
	DSFResourceTypeMemory	= 3,
	DSFResourceTypeDma	= 4,
	DSFResourceTypeDeviceSpecific	= 5,
	DSFResourceTypeBusNumber	= 6,
	DSFResourceTypeNonArbitrated	= 128,
	DSFResourceTypeConfigData	= 128,
	DSFResourceTypeDevicePrivate	= 129,
	DSFResourceTypePcCardConfig	= 130,
	DSFResourceTypeMfCardConfig	= 131,
	DSFResourceTypeConfigurationSpace	= 132,
	DSFResourceTypeAcpi	= 133,
	DSFResourceTypePci	= 134
    } 	DSFResourceType;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("D503F600-4EDD-4B7C-A676-0B50BDAED69E") 
enum DSFShareDisposition
    {	DSFShareDispositionUndetermined	= 0,
	DSFShareDispositionDeviceExclusive	= 1,
	DSFShareDispositionDriverExclusive	= 2,
	DSFShareDispositionShared	= 3
    } 	DSFShareDisposition;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("6FA31433-AA14-4EF7-8FBA-A91F326BA32B") 
enum DSFInterfaceType
    {	DSFInterfaceTypeUndefined	= -1,
	DSFInterfaceTypeInternal	= 0,
	DSFInterfaceTypeIsa	= 1,
	DSFInterfaceTypeEisa	= 2,
	DSFInterfaceTypeMicroChannel	= 3,
	DSFInterfaceTypeTurboChannel	= 4,
	DSFInterfaceTypePCIBus	= 5,
	DSFInterfaceTypeVMEBus	= 6,
	DSFInterfaceTypeNuBus	= 7,
	DSFInterfaceTypePCMCIABus	= 8,
	DSFInterfaceTypeCBus	= 9,
	DSFInterfaceTypeMPIBus	= 10,
	DSFInterfaceTypeMPSABus	= 11,
	DSFInterfaceTypeProcessorInternal	= 12,
	DSFInterfaceTypeInternalPowerBus	= 13,
	DSFInterfaceTypePNPISABus	= 14,
	DSFInterfaceTypePNPBus	= 15
    } 	DSFInterfaceType;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("78201517-0b6c-4208-b003-2f396640e5bc") 
enum DSFStateType
    {	DSFDefaultStateType	= 0
    } 	DSFStateType;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("86b50daf-5bb2-43f3-a9ca-e5bf444d9523") 
enum DSFFlagType
    {	DSFDebugFlags	= 0,
	DSFLogFlags	= 1,
	DSFStdOutFlags	= 2
    } 	DSFFlagType;

#define	DSFVersionMajor	( 1 )

#define	DSFVersionMinor	( 0 )


EXTERN_C const IID LIBID_DSF;

#ifndef __IDSFResourceList_INTERFACE_DEFINED__
#define __IDSFResourceList_INTERFACE_DEFINED__

/* interface IDSFResourceList */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResourceList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("418E0FF4-25F9-459A-B92B-6B3294E7135C")
    IDSFResourceList : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt DSFFullResourceDescriptor	**ppDSFFullResourceDescriptor) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in DSFFullResourceDescriptor	*pDSFFullResourceDescriptor,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResourceListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResourceList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResourceList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResourceList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResourceList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResourceList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResourceList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResourceList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            IDSFResourceList * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            IDSFResourceList * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt DSFFullResourceDescriptor	**ppDSFFullResourceDescriptor);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            IDSFResourceList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            IDSFResourceList * This,
            /* [in] */ __RPC__in DSFFullResourceDescriptor	*pDSFFullResourceDescriptor,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            IDSFResourceList * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            IDSFResourceList * This);
        
        END_INTERFACE
    } IDSFResourceListVtbl;

    interface IDSFResourceList
    {
        CONST_VTBL struct IDSFResourceListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResourceList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResourceList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResourceList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResourceList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResourceList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResourceList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResourceList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResourceList_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IDSFResourceList_get_Item(This,Index,ppDSFFullResourceDescriptor)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppDSFFullResourceDescriptor) ) 

#define IDSFResourceList_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define IDSFResourceList_Add(This,pDSFFullResourceDescriptor,Index)	\
    ( (This)->lpVtbl -> Add(This,pDSFFullResourceDescriptor,Index) ) 

#define IDSFResourceList_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IDSFResourceList_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResourceList_INTERFACE_DEFINED__ */


#ifndef __IDSFFullResourceDescriptor_INTERFACE_DEFINED__
#define __IDSFFullResourceDescriptor_INTERFACE_DEFINED__

/* interface IDSFFullResourceDescriptor */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFFullResourceDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E466F6A1-269F-4E18-94E6-7D2F02779417")
    IDSFFullResourceDescriptor : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_InterfaceType( 
            /* [retval][out] */ __RPC__out DSFInterfaceType *pType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_InterfaceType( 
            /* [in] */ DSFInterfaceType Type) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_BusNumber( 
            /* [retval][out] */ __RPC__out long *plBusNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_BusNumber( 
            /* [in] */ long lBusNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_PartialResourceList( 
            /* [retval][out] */ __RPC__deref_out_opt DSFPartialResourceList	**ppDSFPartialResourceList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFFullResourceDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFFullResourceDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFFullResourceDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFFullResourceDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFFullResourceDescriptor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFFullResourceDescriptor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFFullResourceDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFFullResourceDescriptor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_InterfaceType )( 
            IDSFFullResourceDescriptor * This,
            /* [retval][out] */ __RPC__out DSFInterfaceType *pType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_InterfaceType )( 
            IDSFFullResourceDescriptor * This,
            /* [in] */ DSFInterfaceType Type);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_BusNumber )( 
            IDSFFullResourceDescriptor * This,
            /* [retval][out] */ __RPC__out long *plBusNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_BusNumber )( 
            IDSFFullResourceDescriptor * This,
            /* [in] */ long lBusNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_PartialResourceList )( 
            IDSFFullResourceDescriptor * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFPartialResourceList	**ppDSFPartialResourceList);
        
        END_INTERFACE
    } IDSFFullResourceDescriptorVtbl;

    interface IDSFFullResourceDescriptor
    {
        CONST_VTBL struct IDSFFullResourceDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFFullResourceDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFFullResourceDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFFullResourceDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFFullResourceDescriptor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFFullResourceDescriptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFFullResourceDescriptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFFullResourceDescriptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFFullResourceDescriptor_get_InterfaceType(This,pType)	\
    ( (This)->lpVtbl -> get_InterfaceType(This,pType) ) 

#define IDSFFullResourceDescriptor_put_InterfaceType(This,Type)	\
    ( (This)->lpVtbl -> put_InterfaceType(This,Type) ) 

#define IDSFFullResourceDescriptor_get_BusNumber(This,plBusNumber)	\
    ( (This)->lpVtbl -> get_BusNumber(This,plBusNumber) ) 

#define IDSFFullResourceDescriptor_put_BusNumber(This,lBusNumber)	\
    ( (This)->lpVtbl -> put_BusNumber(This,lBusNumber) ) 

#define IDSFFullResourceDescriptor_get_PartialResourceList(This,ppDSFPartialResourceList)	\
    ( (This)->lpVtbl -> get_PartialResourceList(This,ppDSFPartialResourceList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFFullResourceDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDSFDevice_INTERFACE_DEFINED__
#define __IDSFDevice_INTERFACE_DEFINED__

/* interface IDSFDevice */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3B2A057-2A23-4ABE-8188-9FB655131823")
    IDSFDevice : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Children( 
            /* [retval][out] */ __RPC__deref_out_opt DSFDevices	**ppDSFDevices) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Enabled( 
            /* [in] */ VARIANT_BOOL fvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Guid( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGuid) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Guid( 
            /* [in] */ __RPC__in BSTR bstrGuid) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall HasObject( 
            /* [in] */ __RPC__in BSTR CLSID,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvBool) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Hrm( 
            /* [in] */ DSFResourceType ResType,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkHrm) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Inserted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarInserted) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Inserted( 
            /* [in] */ VARIANT_BOOL fvarInserted) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Name( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Next( 
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Next( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_Next( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Object( 
            /* [in] */ __RPC__in BSTR GUID,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkObject) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Object( 
            /* [in] */ __RPC__in BSTR GUID,
            /* [in] */ __RPC__in_opt IUnknown *punkObject) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_Object( 
            /* [in] */ __RPC__in BSTR GUID,
            /* [in] */ __RPC__in_opt IUnknown *punkObject) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OpMode( 
            /* [retval][out] */ __RPC__out DSFOpMode *pMode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OpMode( 
            /* [in] */ DSFOpMode Mode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Parent( 
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Parent( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_Parent( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Persistent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPersistent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Persistent( 
            /* [in] */ VARIANT_BOOL fvarPersistent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_State( 
            /* [retval][out] */ __RPC__out long *plState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SystemDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IDSFSystemDevice **ppSystemDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall SetStateBit( 
            /* [in] */ long Bit,
            /* [in] */ DSFBitOp BitOp) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall StartFaultInjection( 
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Params,
            /* [retval][out] */ __RPC__out VARIANT *pvarContext) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall StopFaultInjection( 
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Children )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevices	**ppDSFDevices);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Enabled )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Enabled )( 
            IDSFDevice * This,
            /* [in] */ VARIANT_BOOL fvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Guid )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGuid);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Guid )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in BSTR bstrGuid);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *HasObject )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in BSTR CLSID,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvBool);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Hrm )( 
            IDSFDevice * This,
            /* [in] */ DSFResourceType ResType,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkHrm);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Inserted )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarInserted);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Inserted )( 
            IDSFDevice * This,
            /* [in] */ VARIANT_BOOL fvarInserted);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Name )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Name )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Next )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Next )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_Next )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Object )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in BSTR GUID,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkObject);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Object )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in BSTR GUID,
            /* [in] */ __RPC__in_opt IUnknown *punkObject);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_Object )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in BSTR GUID,
            /* [in] */ __RPC__in_opt IUnknown *punkObject);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OpMode )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__out DSFOpMode *pMode);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OpMode )( 
            IDSFDevice * This,
            /* [in] */ DSFOpMode Mode);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Parent )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Parent )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_Parent )( 
            IDSFDevice * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Persistent )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPersistent);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Persistent )( 
            IDSFDevice * This,
            /* [in] */ VARIANT_BOOL fvarPersistent);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_State )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__out long *plState);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SystemDevice )( 
            IDSFDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IDSFSystemDevice **ppSystemDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *SetStateBit )( 
            IDSFDevice * This,
            /* [in] */ long Bit,
            /* [in] */ DSFBitOp BitOp);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *StartFaultInjection )( 
            IDSFDevice * This,
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Params,
            /* [retval][out] */ __RPC__out VARIANT *pvarContext);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *StopFaultInjection )( 
            IDSFDevice * This,
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Context);
        
        END_INTERFACE
    } IDSFDeviceVtbl;

    interface IDSFDevice
    {
        CONST_VTBL struct IDSFDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFDevice_get_Children(This,ppDSFDevices)	\
    ( (This)->lpVtbl -> get_Children(This,ppDSFDevices) ) 

#define IDSFDevice_get_Enabled(This,pfvarEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfvarEnabled) ) 

#define IDSFDevice_put_Enabled(This,fvarEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,fvarEnabled) ) 

#define IDSFDevice_get_Guid(This,pbstrGuid)	\
    ( (This)->lpVtbl -> get_Guid(This,pbstrGuid) ) 

#define IDSFDevice_put_Guid(This,bstrGuid)	\
    ( (This)->lpVtbl -> put_Guid(This,bstrGuid) ) 

#define IDSFDevice_HasObject(This,CLSID,pvBool)	\
    ( (This)->lpVtbl -> HasObject(This,CLSID,pvBool) ) 

#define IDSFDevice_get_Hrm(This,ResType,ppunkHrm)	\
    ( (This)->lpVtbl -> get_Hrm(This,ResType,ppunkHrm) ) 

#define IDSFDevice_get_Inserted(This,pfvarInserted)	\
    ( (This)->lpVtbl -> get_Inserted(This,pfvarInserted) ) 

#define IDSFDevice_put_Inserted(This,fvarInserted)	\
    ( (This)->lpVtbl -> put_Inserted(This,fvarInserted) ) 

#define IDSFDevice_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IDSFDevice_put_Name(This,bstrName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrName) ) 

#define IDSFDevice_get_Next(This,ppDSFDevice)	\
    ( (This)->lpVtbl -> get_Next(This,ppDSFDevice) ) 

#define IDSFDevice_put_Next(This,pDSFDevice)	\
    ( (This)->lpVtbl -> put_Next(This,pDSFDevice) ) 

#define IDSFDevice_putref_Next(This,pDSFDevice)	\
    ( (This)->lpVtbl -> putref_Next(This,pDSFDevice) ) 

#define IDSFDevice_get_Object(This,GUID,ppunkObject)	\
    ( (This)->lpVtbl -> get_Object(This,GUID,ppunkObject) ) 

#define IDSFDevice_put_Object(This,GUID,punkObject)	\
    ( (This)->lpVtbl -> put_Object(This,GUID,punkObject) ) 

#define IDSFDevice_putref_Object(This,GUID,punkObject)	\
    ( (This)->lpVtbl -> putref_Object(This,GUID,punkObject) ) 

#define IDSFDevice_get_OpMode(This,pMode)	\
    ( (This)->lpVtbl -> get_OpMode(This,pMode) ) 

#define IDSFDevice_put_OpMode(This,Mode)	\
    ( (This)->lpVtbl -> put_OpMode(This,Mode) ) 

#define IDSFDevice_get_Parent(This,ppDSFDevice)	\
    ( (This)->lpVtbl -> get_Parent(This,ppDSFDevice) ) 

#define IDSFDevice_put_Parent(This,pDSFDevice)	\
    ( (This)->lpVtbl -> put_Parent(This,pDSFDevice) ) 

#define IDSFDevice_putref_Parent(This,pDSFDevice)	\
    ( (This)->lpVtbl -> putref_Parent(This,pDSFDevice) ) 

#define IDSFDevice_get_Persistent(This,pfvarPersistent)	\
    ( (This)->lpVtbl -> get_Persistent(This,pfvarPersistent) ) 

#define IDSFDevice_put_Persistent(This,fvarPersistent)	\
    ( (This)->lpVtbl -> put_Persistent(This,fvarPersistent) ) 

#define IDSFDevice_get_State(This,plState)	\
    ( (This)->lpVtbl -> get_State(This,plState) ) 

#define IDSFDevice_get_SystemDevice(This,ppSystemDevice)	\
    ( (This)->lpVtbl -> get_SystemDevice(This,ppSystemDevice) ) 

#define IDSFDevice_SetStateBit(This,Bit,BitOp)	\
    ( (This)->lpVtbl -> SetStateBit(This,Bit,BitOp) ) 

#define IDSFDevice_StartFaultInjection(This,ResType,Params,pvarContext)	\
    ( (This)->lpVtbl -> StartFaultInjection(This,ResType,Params,pvarContext) ) 

#define IDSFDevice_StopFaultInjection(This,ResType,Context)	\
    ( (This)->lpVtbl -> StopFaultInjection(This,ResType,Context) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFDevice_INTERFACE_DEFINED__ */


#ifndef __IDSFDeviceCaps_INTERFACE_DEFINED__
#define __IDSFDeviceCaps_INTERFACE_DEFINED__

/* interface IDSFDeviceCaps */
/* [object][helpstringcontext][helpcontext][helpstring][nonextensible][uuid] */ 


EXTERN_C const IID IID_IDSFDeviceCaps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("766705D3-5109-460D-80B5-30D97B17D867")
    IDSFDeviceCaps : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Version( 
            /* [retval][out] */ __RPC__out short *psVersion) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Version( 
            /* [in] */ short sVersion) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceD1( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarDeviceD1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceD1( 
            /* [in] */ VARIANT_BOOL fvarDeviceD1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceD2( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarDeviceD2) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceD2( 
            /* [in] */ VARIANT_BOOL fvarDeviceD2) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LockSupported( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarLockSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LockSupported( 
            /* [in] */ VARIANT_BOOL fvarLockSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_EjectSupported( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEjectSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_EjectSupported( 
            /* [in] */ VARIANT_BOOL fvarEjectSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Removable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarRemovable) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Removable( 
            /* [in] */ VARIANT_BOOL fvarRemovable) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DockDevice( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarDockDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DockDevice( 
            /* [in] */ VARIANT_BOOL fvarDockDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_UniqueID( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarUniqueID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_UniqueID( 
            /* [in] */ VARIANT_BOOL fvarUniqueID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SilentInstall( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSilentInstall) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_SilentInstall( 
            /* [in] */ VARIANT_BOOL fvarSilentInstall) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_RawDeviceOK( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarRawDeviceOK) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_RawDeviceOK( 
            /* [in] */ VARIANT_BOOL fvarRawDeviceOK) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SurpriseRemovalOK( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSurpriseRemovalOK) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_SurpriseRemovalOK( 
            /* [in] */ VARIANT_BOOL fvarSurpriseRemovalOK) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeFromD0( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_WakeFromD0( 
            /* [in] */ VARIANT_BOOL fvarWakeFromD0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeFromD1( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_WakeFromD1( 
            /* [in] */ VARIANT_BOOL fvarWakeFromD1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeFromD2( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD2) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_WakeFromD2( 
            /* [in] */ VARIANT_BOOL fvarWakeFromD2) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeFromD3( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD3) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_WakeFromD3( 
            /* [in] */ VARIANT_BOOL fvarWakeFromD3) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HardwareDisabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarHardwareDisabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HardwareDisabled( 
            /* [in] */ VARIANT_BOOL fvarHardwareDisabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NonDynamic( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarNonDynamic) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_NonDynamic( 
            /* [in] */ VARIANT_BOOL fvarNonDynamic) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WarmEjectSupported( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWarmEjectSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_WarmEjectSupported( 
            /* [in] */ VARIANT_BOOL fvarWarmEjectSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NoDisplayInUI( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarNoDisplayInUI) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_NoDisplayInUI( 
            /* [in] */ VARIANT_BOOL fvarNoDisplayInUI) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reserved( 
            /* [retval][out] */ __RPC__out short *psReserved) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Reserved( 
            /* [in] */ short sReserved) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Address( 
            /* [retval][out] */ __RPC__out long *plAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Address( 
            /* [in] */ long lAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_UINumber( 
            /* [retval][out] */ __RPC__out long *plUINumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_UINumber( 
            /* [in] */ long lUINumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceState( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDeviceState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceState( 
            /* [in] */ __RPC__in SAFEARRAY * psaDeviceState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SystemWake( 
            /* [retval][out] */ __RPC__out DSFSystemPowerState *pPowerState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_SystemWake( 
            /* [in] */ DSFSystemPowerState PowerState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceWake( 
            /* [retval][out] */ __RPC__out DSFDevicePowerState *pPowerState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceWake( 
            /* [in] */ DSFDevicePowerState PowerState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_D1Latency( 
            /* [retval][out] */ __RPC__out long *plD1Latency) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_D1Latency( 
            /* [in] */ long lD1Latency) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_D2Latency( 
            /* [retval][out] */ __RPC__out long *plD2Latency) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_D2Latency( 
            /* [in] */ long lD2Latency) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_D3Latency( 
            /* [retval][out] */ __RPC__out long *plD3Latency) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_D3Latency( 
            /* [in] */ long lD3Latency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFDeviceCapsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFDeviceCaps * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFDeviceCaps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFDeviceCaps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFDeviceCaps * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFDeviceCaps * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFDeviceCaps * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFDeviceCaps * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Version )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out short *psVersion);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Version )( 
            IDSFDeviceCaps * This,
            /* [in] */ short sVersion);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceD1 )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarDeviceD1);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceD1 )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarDeviceD1);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceD2 )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarDeviceD2);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceD2 )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarDeviceD2);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LockSupported )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarLockSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LockSupported )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarLockSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_EjectSupported )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEjectSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_EjectSupported )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarEjectSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Removable )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarRemovable);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Removable )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarRemovable);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DockDevice )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarDockDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DockDevice )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarDockDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_UniqueID )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarUniqueID);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_UniqueID )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarUniqueID);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SilentInstall )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSilentInstall);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_SilentInstall )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarSilentInstall);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_RawDeviceOK )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarRawDeviceOK);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_RawDeviceOK )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarRawDeviceOK);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SurpriseRemovalOK )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSurpriseRemovalOK);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_SurpriseRemovalOK )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarSurpriseRemovalOK);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeFromD0 )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD0);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_WakeFromD0 )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarWakeFromD0);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeFromD1 )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD1);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_WakeFromD1 )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarWakeFromD1);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeFromD2 )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD2);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_WakeFromD2 )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarWakeFromD2);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeFromD3 )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWakeFromD3);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_WakeFromD3 )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarWakeFromD3);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HardwareDisabled )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarHardwareDisabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HardwareDisabled )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarHardwareDisabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NonDynamic )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarNonDynamic);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_NonDynamic )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarNonDynamic);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WarmEjectSupported )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWarmEjectSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_WarmEjectSupported )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarWarmEjectSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NoDisplayInUI )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarNoDisplayInUI);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_NoDisplayInUI )( 
            IDSFDeviceCaps * This,
            /* [in] */ VARIANT_BOOL fvarNoDisplayInUI);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reserved )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out short *psReserved);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Reserved )( 
            IDSFDeviceCaps * This,
            /* [in] */ short sReserved);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Address )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out long *plAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Address )( 
            IDSFDeviceCaps * This,
            /* [in] */ long lAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_UINumber )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out long *plUINumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_UINumber )( 
            IDSFDeviceCaps * This,
            /* [in] */ long lUINumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceState )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDeviceState);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceState )( 
            IDSFDeviceCaps * This,
            /* [in] */ __RPC__in SAFEARRAY * psaDeviceState);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SystemWake )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out DSFSystemPowerState *pPowerState);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_SystemWake )( 
            IDSFDeviceCaps * This,
            /* [in] */ DSFSystemPowerState PowerState);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceWake )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out DSFDevicePowerState *pPowerState);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceWake )( 
            IDSFDeviceCaps * This,
            /* [in] */ DSFDevicePowerState PowerState);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_D1Latency )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out long *plD1Latency);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_D1Latency )( 
            IDSFDeviceCaps * This,
            /* [in] */ long lD1Latency);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_D2Latency )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out long *plD2Latency);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_D2Latency )( 
            IDSFDeviceCaps * This,
            /* [in] */ long lD2Latency);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_D3Latency )( 
            IDSFDeviceCaps * This,
            /* [retval][out] */ __RPC__out long *plD3Latency);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_D3Latency )( 
            IDSFDeviceCaps * This,
            /* [in] */ long lD3Latency);
        
        END_INTERFACE
    } IDSFDeviceCapsVtbl;

    interface IDSFDeviceCaps
    {
        CONST_VTBL struct IDSFDeviceCapsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFDeviceCaps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFDeviceCaps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFDeviceCaps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFDeviceCaps_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFDeviceCaps_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFDeviceCaps_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFDeviceCaps_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFDeviceCaps_get_Version(This,psVersion)	\
    ( (This)->lpVtbl -> get_Version(This,psVersion) ) 

#define IDSFDeviceCaps_put_Version(This,sVersion)	\
    ( (This)->lpVtbl -> put_Version(This,sVersion) ) 

#define IDSFDeviceCaps_get_DeviceD1(This,pfvarDeviceD1)	\
    ( (This)->lpVtbl -> get_DeviceD1(This,pfvarDeviceD1) ) 

#define IDSFDeviceCaps_put_DeviceD1(This,fvarDeviceD1)	\
    ( (This)->lpVtbl -> put_DeviceD1(This,fvarDeviceD1) ) 

#define IDSFDeviceCaps_get_DeviceD2(This,pfvarDeviceD2)	\
    ( (This)->lpVtbl -> get_DeviceD2(This,pfvarDeviceD2) ) 

#define IDSFDeviceCaps_put_DeviceD2(This,fvarDeviceD2)	\
    ( (This)->lpVtbl -> put_DeviceD2(This,fvarDeviceD2) ) 

#define IDSFDeviceCaps_get_LockSupported(This,pfvarLockSupported)	\
    ( (This)->lpVtbl -> get_LockSupported(This,pfvarLockSupported) ) 

#define IDSFDeviceCaps_put_LockSupported(This,fvarLockSupported)	\
    ( (This)->lpVtbl -> put_LockSupported(This,fvarLockSupported) ) 

#define IDSFDeviceCaps_get_EjectSupported(This,pfvarEjectSupported)	\
    ( (This)->lpVtbl -> get_EjectSupported(This,pfvarEjectSupported) ) 

#define IDSFDeviceCaps_put_EjectSupported(This,fvarEjectSupported)	\
    ( (This)->lpVtbl -> put_EjectSupported(This,fvarEjectSupported) ) 

#define IDSFDeviceCaps_get_Removable(This,pfvarRemovable)	\
    ( (This)->lpVtbl -> get_Removable(This,pfvarRemovable) ) 

#define IDSFDeviceCaps_put_Removable(This,fvarRemovable)	\
    ( (This)->lpVtbl -> put_Removable(This,fvarRemovable) ) 

#define IDSFDeviceCaps_get_DockDevice(This,pfvarDockDevice)	\
    ( (This)->lpVtbl -> get_DockDevice(This,pfvarDockDevice) ) 

#define IDSFDeviceCaps_put_DockDevice(This,fvarDockDevice)	\
    ( (This)->lpVtbl -> put_DockDevice(This,fvarDockDevice) ) 

#define IDSFDeviceCaps_get_UniqueID(This,pfvarUniqueID)	\
    ( (This)->lpVtbl -> get_UniqueID(This,pfvarUniqueID) ) 

#define IDSFDeviceCaps_put_UniqueID(This,fvarUniqueID)	\
    ( (This)->lpVtbl -> put_UniqueID(This,fvarUniqueID) ) 

#define IDSFDeviceCaps_get_SilentInstall(This,pfvarSilentInstall)	\
    ( (This)->lpVtbl -> get_SilentInstall(This,pfvarSilentInstall) ) 

#define IDSFDeviceCaps_put_SilentInstall(This,fvarSilentInstall)	\
    ( (This)->lpVtbl -> put_SilentInstall(This,fvarSilentInstall) ) 

#define IDSFDeviceCaps_get_RawDeviceOK(This,pfvarRawDeviceOK)	\
    ( (This)->lpVtbl -> get_RawDeviceOK(This,pfvarRawDeviceOK) ) 

#define IDSFDeviceCaps_put_RawDeviceOK(This,fvarRawDeviceOK)	\
    ( (This)->lpVtbl -> put_RawDeviceOK(This,fvarRawDeviceOK) ) 

#define IDSFDeviceCaps_get_SurpriseRemovalOK(This,pfvarSurpriseRemovalOK)	\
    ( (This)->lpVtbl -> get_SurpriseRemovalOK(This,pfvarSurpriseRemovalOK) ) 

#define IDSFDeviceCaps_put_SurpriseRemovalOK(This,fvarSurpriseRemovalOK)	\
    ( (This)->lpVtbl -> put_SurpriseRemovalOK(This,fvarSurpriseRemovalOK) ) 

#define IDSFDeviceCaps_get_WakeFromD0(This,pfvarWakeFromD0)	\
    ( (This)->lpVtbl -> get_WakeFromD0(This,pfvarWakeFromD0) ) 

#define IDSFDeviceCaps_put_WakeFromD0(This,fvarWakeFromD0)	\
    ( (This)->lpVtbl -> put_WakeFromD0(This,fvarWakeFromD0) ) 

#define IDSFDeviceCaps_get_WakeFromD1(This,pfvarWakeFromD1)	\
    ( (This)->lpVtbl -> get_WakeFromD1(This,pfvarWakeFromD1) ) 

#define IDSFDeviceCaps_put_WakeFromD1(This,fvarWakeFromD1)	\
    ( (This)->lpVtbl -> put_WakeFromD1(This,fvarWakeFromD1) ) 

#define IDSFDeviceCaps_get_WakeFromD2(This,pfvarWakeFromD2)	\
    ( (This)->lpVtbl -> get_WakeFromD2(This,pfvarWakeFromD2) ) 

#define IDSFDeviceCaps_put_WakeFromD2(This,fvarWakeFromD2)	\
    ( (This)->lpVtbl -> put_WakeFromD2(This,fvarWakeFromD2) ) 

#define IDSFDeviceCaps_get_WakeFromD3(This,pfvarWakeFromD3)	\
    ( (This)->lpVtbl -> get_WakeFromD3(This,pfvarWakeFromD3) ) 

#define IDSFDeviceCaps_put_WakeFromD3(This,fvarWakeFromD3)	\
    ( (This)->lpVtbl -> put_WakeFromD3(This,fvarWakeFromD3) ) 

#define IDSFDeviceCaps_get_HardwareDisabled(This,pfvarHardwareDisabled)	\
    ( (This)->lpVtbl -> get_HardwareDisabled(This,pfvarHardwareDisabled) ) 

#define IDSFDeviceCaps_put_HardwareDisabled(This,fvarHardwareDisabled)	\
    ( (This)->lpVtbl -> put_HardwareDisabled(This,fvarHardwareDisabled) ) 

#define IDSFDeviceCaps_get_NonDynamic(This,pfvarNonDynamic)	\
    ( (This)->lpVtbl -> get_NonDynamic(This,pfvarNonDynamic) ) 

#define IDSFDeviceCaps_put_NonDynamic(This,fvarNonDynamic)	\
    ( (This)->lpVtbl -> put_NonDynamic(This,fvarNonDynamic) ) 

#define IDSFDeviceCaps_get_WarmEjectSupported(This,pfvarWarmEjectSupported)	\
    ( (This)->lpVtbl -> get_WarmEjectSupported(This,pfvarWarmEjectSupported) ) 

#define IDSFDeviceCaps_put_WarmEjectSupported(This,fvarWarmEjectSupported)	\
    ( (This)->lpVtbl -> put_WarmEjectSupported(This,fvarWarmEjectSupported) ) 

#define IDSFDeviceCaps_get_NoDisplayInUI(This,pfvarNoDisplayInUI)	\
    ( (This)->lpVtbl -> get_NoDisplayInUI(This,pfvarNoDisplayInUI) ) 

#define IDSFDeviceCaps_put_NoDisplayInUI(This,fvarNoDisplayInUI)	\
    ( (This)->lpVtbl -> put_NoDisplayInUI(This,fvarNoDisplayInUI) ) 

#define IDSFDeviceCaps_get_Reserved(This,psReserved)	\
    ( (This)->lpVtbl -> get_Reserved(This,psReserved) ) 

#define IDSFDeviceCaps_put_Reserved(This,sReserved)	\
    ( (This)->lpVtbl -> put_Reserved(This,sReserved) ) 

#define IDSFDeviceCaps_get_Address(This,plAddress)	\
    ( (This)->lpVtbl -> get_Address(This,plAddress) ) 

#define IDSFDeviceCaps_put_Address(This,lAddress)	\
    ( (This)->lpVtbl -> put_Address(This,lAddress) ) 

#define IDSFDeviceCaps_get_UINumber(This,plUINumber)	\
    ( (This)->lpVtbl -> get_UINumber(This,plUINumber) ) 

#define IDSFDeviceCaps_put_UINumber(This,lUINumber)	\
    ( (This)->lpVtbl -> put_UINumber(This,lUINumber) ) 

#define IDSFDeviceCaps_get_DeviceState(This,ppsaDeviceState)	\
    ( (This)->lpVtbl -> get_DeviceState(This,ppsaDeviceState) ) 

#define IDSFDeviceCaps_put_DeviceState(This,psaDeviceState)	\
    ( (This)->lpVtbl -> put_DeviceState(This,psaDeviceState) ) 

#define IDSFDeviceCaps_get_SystemWake(This,pPowerState)	\
    ( (This)->lpVtbl -> get_SystemWake(This,pPowerState) ) 

#define IDSFDeviceCaps_put_SystemWake(This,PowerState)	\
    ( (This)->lpVtbl -> put_SystemWake(This,PowerState) ) 

#define IDSFDeviceCaps_get_DeviceWake(This,pPowerState)	\
    ( (This)->lpVtbl -> get_DeviceWake(This,pPowerState) ) 

#define IDSFDeviceCaps_put_DeviceWake(This,PowerState)	\
    ( (This)->lpVtbl -> put_DeviceWake(This,PowerState) ) 

#define IDSFDeviceCaps_get_D1Latency(This,plD1Latency)	\
    ( (This)->lpVtbl -> get_D1Latency(This,plD1Latency) ) 

#define IDSFDeviceCaps_put_D1Latency(This,lD1Latency)	\
    ( (This)->lpVtbl -> put_D1Latency(This,lD1Latency) ) 

#define IDSFDeviceCaps_get_D2Latency(This,plD2Latency)	\
    ( (This)->lpVtbl -> get_D2Latency(This,plD2Latency) ) 

#define IDSFDeviceCaps_put_D2Latency(This,lD2Latency)	\
    ( (This)->lpVtbl -> put_D2Latency(This,lD2Latency) ) 

#define IDSFDeviceCaps_get_D3Latency(This,plD3Latency)	\
    ( (This)->lpVtbl -> get_D3Latency(This,plD3Latency) ) 

#define IDSFDeviceCaps_put_D3Latency(This,lD3Latency)	\
    ( (This)->lpVtbl -> put_D3Latency(This,lD3Latency) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFDeviceCaps_INTERFACE_DEFINED__ */


#ifndef __IDSFDeviceEvents_INTERFACE_DEFINED__
#define __IDSFDeviceEvents_INTERFACE_DEFINED__

/* interface IDSFDeviceEvents */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFDeviceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E706BA6-2C8F-4441-8931-1ACEB318112F")
    IDSFDeviceEvents : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Disabled( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Enabled( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Inserted( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall OpModeChange( 
            /* [in] */ DSFOpMode NewOpMode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Removed( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall ResourcesSet( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall StartFaultInjection( 
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Params,
            /* [retval][out] */ __RPC__out VARIANT *pvarContext) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall StopFaultInjection( 
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Context) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall StateChange( 
            /* [in] */ long Bit,
            /* [in] */ short Value,
            /* [in] */ long NewState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFDeviceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFDeviceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFDeviceEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFDeviceEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFDeviceEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFDeviceEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFDeviceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFDeviceEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Disabled )( 
            IDSFDeviceEvents * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Enabled )( 
            IDSFDeviceEvents * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Inserted )( 
            IDSFDeviceEvents * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *OpModeChange )( 
            IDSFDeviceEvents * This,
            /* [in] */ DSFOpMode NewOpMode);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Removed )( 
            IDSFDeviceEvents * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *ResourcesSet )( 
            IDSFDeviceEvents * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *StartFaultInjection )( 
            IDSFDeviceEvents * This,
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Params,
            /* [retval][out] */ __RPC__out VARIANT *pvarContext);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *StopFaultInjection )( 
            IDSFDeviceEvents * This,
            /* [in] */ DSFResourceType ResType,
            /* [in] */ VARIANT Context);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *StateChange )( 
            IDSFDeviceEvents * This,
            /* [in] */ long Bit,
            /* [in] */ short Value,
            /* [in] */ long NewState);
        
        END_INTERFACE
    } IDSFDeviceEventsVtbl;

    interface IDSFDeviceEvents
    {
        CONST_VTBL struct IDSFDeviceEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFDeviceEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFDeviceEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFDeviceEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFDeviceEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFDeviceEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFDeviceEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFDeviceEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFDeviceEvents_Disabled(This)	\
    ( (This)->lpVtbl -> Disabled(This) ) 

#define IDSFDeviceEvents_Enabled(This)	\
    ( (This)->lpVtbl -> Enabled(This) ) 

#define IDSFDeviceEvents_Inserted(This)	\
    ( (This)->lpVtbl -> Inserted(This) ) 

#define IDSFDeviceEvents_OpModeChange(This,NewOpMode)	\
    ( (This)->lpVtbl -> OpModeChange(This,NewOpMode) ) 

#define IDSFDeviceEvents_Removed(This)	\
    ( (This)->lpVtbl -> Removed(This) ) 

#define IDSFDeviceEvents_ResourcesSet(This)	\
    ( (This)->lpVtbl -> ResourcesSet(This) ) 

#define IDSFDeviceEvents_StartFaultInjection(This,ResType,Params,pvarContext)	\
    ( (This)->lpVtbl -> StartFaultInjection(This,ResType,Params,pvarContext) ) 

#define IDSFDeviceEvents_StopFaultInjection(This,ResType,Context)	\
    ( (This)->lpVtbl -> StopFaultInjection(This,ResType,Context) ) 

#define IDSFDeviceEvents_StateChange(This,Bit,Value,NewState)	\
    ( (This)->lpVtbl -> StateChange(This,Bit,Value,NewState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFDeviceEvents_INTERFACE_DEFINED__ */


#ifndef __IDSF_INTERFACE_DEFINED__
#define __IDSF_INTERFACE_DEFINED__

/* interface IDSF */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("959B9C1D-5644-4835-8297-F435B3FA80DD")
    IDSF : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Devices( 
            /* [retval][out] */ __RPC__deref_out_opt DSFDevices	**ppDSFDevices) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Log( 
            /* [retval][out] */ __RPC__deref_out_opt DSFLog	**ppDSFLog) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Version( 
            /* [retval][out] */ __RPC__deref_out_opt DSFVersion	**ppDSFVersion) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall CreateDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrInstanceID,
            /* [in] */ VARIANT HardwareIDs,
            /* [in] */ VARIANT CompatibleIDs,
            /* [in] */ __RPC__in DSFResourceList	*RawResources,
            /* [in] */ __RPC__in DSFResourceList	*XlatedResources,
            /* [in] */ __RPC__in DSFDeviceCaps	*DeviceCapabilities,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall WriteState( 
            /* [in] */ DSFStateType Type,
            /* [in] */ __RPC__in BSTR Guid,
            /* [in] */ __RPC__in DSFPropertyBag	*pDSFPropertyBag) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall ReadState( 
            /* [in] */ DSFStateType Type,
            /* [in] */ __RPC__in BSTR Guid,
            /* [retval][out] */ __RPC__deref_out_opt DSFPropertyBag	**ppDSFPropertyBag) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall DeleteState( 
            /* [in] */ DSFStateType Type,
            /* [in] */ __RPC__in BSTR Guid) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall SetDriverFlags( 
            /* [in] */ __RPC__in BSTR DriverGuid,
            /* [in] */ DSFFlagType FlagType,
            /* [in] */ unsigned long Flags) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall EnableDriverLogging( 
            /* [in] */ __RPC__in BSTR DriverGuid,
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall HotPlug( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice,
            /* [in] */ __RPC__in BSTR bstrBus,
            /* [retval][out] */ __RPC__deref_out_opt IDSFBus **ppiDSFBus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSF * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSF * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSF * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSF * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Devices )( 
            IDSF * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevices	**ppDSFDevices);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Log )( 
            IDSF * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFLog	**ppDSFLog);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Version )( 
            IDSF * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFVersion	**ppDSFVersion);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *CreateDevice )( 
            IDSF * This,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrInstanceID,
            /* [in] */ VARIANT HardwareIDs,
            /* [in] */ VARIANT CompatibleIDs,
            /* [in] */ __RPC__in DSFResourceList	*RawResources,
            /* [in] */ __RPC__in DSFResourceList	*XlatedResources,
            /* [in] */ __RPC__in DSFDeviceCaps	*DeviceCapabilities,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *WriteState )( 
            IDSF * This,
            /* [in] */ DSFStateType Type,
            /* [in] */ __RPC__in BSTR Guid,
            /* [in] */ __RPC__in DSFPropertyBag	*pDSFPropertyBag);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *ReadState )( 
            IDSF * This,
            /* [in] */ DSFStateType Type,
            /* [in] */ __RPC__in BSTR Guid,
            /* [retval][out] */ __RPC__deref_out_opt DSFPropertyBag	**ppDSFPropertyBag);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *DeleteState )( 
            IDSF * This,
            /* [in] */ DSFStateType Type,
            /* [in] */ __RPC__in BSTR Guid);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *SetDriverFlags )( 
            IDSF * This,
            /* [in] */ __RPC__in BSTR DriverGuid,
            /* [in] */ DSFFlagType FlagType,
            /* [in] */ unsigned long Flags);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *EnableDriverLogging )( 
            IDSF * This,
            /* [in] */ __RPC__in BSTR DriverGuid,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *HotPlug )( 
            IDSF * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice,
            /* [in] */ __RPC__in BSTR bstrBus,
            /* [retval][out] */ __RPC__deref_out_opt IDSFBus **ppiDSFBus);
        
        END_INTERFACE
    } IDSFVtbl;

    interface IDSF
    {
        CONST_VTBL struct IDSFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSF_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSF_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSF_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSF_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSF_get_Devices(This,ppDSFDevices)	\
    ( (This)->lpVtbl -> get_Devices(This,ppDSFDevices) ) 

#define IDSF_get_Log(This,ppDSFLog)	\
    ( (This)->lpVtbl -> get_Log(This,ppDSFLog) ) 

#define IDSF_get_Version(This,ppDSFVersion)	\
    ( (This)->lpVtbl -> get_Version(This,ppDSFVersion) ) 

#define IDSF_CreateDevice(This,bstrDeviceID,bstrInstanceID,HardwareIDs,CompatibleIDs,RawResources,XlatedResources,DeviceCapabilities,ppDSFDevice)	\
    ( (This)->lpVtbl -> CreateDevice(This,bstrDeviceID,bstrInstanceID,HardwareIDs,CompatibleIDs,RawResources,XlatedResources,DeviceCapabilities,ppDSFDevice) ) 

#define IDSF_WriteState(This,Type,Guid,pDSFPropertyBag)	\
    ( (This)->lpVtbl -> WriteState(This,Type,Guid,pDSFPropertyBag) ) 

#define IDSF_ReadState(This,Type,Guid,ppDSFPropertyBag)	\
    ( (This)->lpVtbl -> ReadState(This,Type,Guid,ppDSFPropertyBag) ) 

#define IDSF_DeleteState(This,Type,Guid)	\
    ( (This)->lpVtbl -> DeleteState(This,Type,Guid) ) 

#define IDSF_SetDriverFlags(This,DriverGuid,FlagType,Flags)	\
    ( (This)->lpVtbl -> SetDriverFlags(This,DriverGuid,FlagType,Flags) ) 

#define IDSF_EnableDriverLogging(This,DriverGuid,Enable)	\
    ( (This)->lpVtbl -> EnableDriverLogging(This,DriverGuid,Enable) ) 

#define IDSF_HotPlug(This,pDSFDevice,bstrBus,ppiDSFBus)	\
    ( (This)->lpVtbl -> HotPlug(This,pDSFDevice,bstrBus,ppiDSFBus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSF_INTERFACE_DEFINED__ */


#ifndef __IDSFDevices_INTERFACE_DEFINED__
#define __IDSFDevices_INTERFACE_DEFINED__

/* interface IDSFDevices */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E75FB264-EA8A-4167-892B-F6F315249518")
    IDSFDevices : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFDevices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            IDSFDevices * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            IDSFDevices * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt DSFDevice	**ppDSFDevice);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            IDSFDevices * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Refresh )( 
            IDSFDevices * This);
        
        END_INTERFACE
    } IDSFDevicesVtbl;

    interface IDSFDevices
    {
        CONST_VTBL struct IDSFDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFDevices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFDevices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFDevices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFDevices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFDevices_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IDSFDevices_get_Item(This,Index,ppDSFDevice)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppDSFDevice) ) 

#define IDSFDevices_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define IDSFDevices_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFDevices_INTERFACE_DEFINED__ */


#ifndef __IDSFLog_INTERFACE_DEFINED__
#define __IDSFLog_INTERFACE_DEFINED__

/* interface IDSFLog */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7902A6F-4CC1-4ABE-8E7A-6EFF79BBBACA")
    IDSFLog : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Write( 
            /* [in] */ __RPC__in BSTR Text) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Enabled( 
            /* [in] */ VARIANT_BOOL fvarEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFLog * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFLog * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFLog * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Write )( 
            IDSFLog * This,
            /* [in] */ __RPC__in BSTR Text);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Enabled )( 
            IDSFLog * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Enabled )( 
            IDSFLog * This,
            /* [in] */ VARIANT_BOOL fvarEnabled);
        
        END_INTERFACE
    } IDSFLogVtbl;

    interface IDSFLog
    {
        CONST_VTBL struct IDSFLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFLog_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFLog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFLog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFLog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFLog_Write(This,Text)	\
    ( (This)->lpVtbl -> Write(This,Text) ) 

#define IDSFLog_get_Enabled(This,pfvarEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfvarEnabled) ) 

#define IDSFLog_put_Enabled(This,fvarEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,fvarEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFLog_INTERFACE_DEFINED__ */


#ifndef __IDSFVersion_INTERFACE_DEFINED__
#define __IDSFVersion_INTERFACE_DEFINED__

/* interface IDSFVersion */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFVersion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F65DF1DA-32B4-411A-B989-1B43B5C428F2")
    IDSFVersion : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Major( 
            /* [retval][out] */ __RPC__out long *plMajor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Minor( 
            /* [retval][out] */ __RPC__out long *plMinor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OSMajor( 
            /* [retval][out] */ __RPC__out long *plOSMajor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OSMinor( 
            /* [retval][out] */ __RPC__out long *plOSMinor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFVersionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFVersion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFVersion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFVersion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFVersion * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFVersion * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFVersion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFVersion * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Major )( 
            IDSFVersion * This,
            /* [retval][out] */ __RPC__out long *plMajor);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Minor )( 
            IDSFVersion * This,
            /* [retval][out] */ __RPC__out long *plMinor);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OSMajor )( 
            IDSFVersion * This,
            /* [retval][out] */ __RPC__out long *plOSMajor);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OSMinor )( 
            IDSFVersion * This,
            /* [retval][out] */ __RPC__out long *plOSMinor);
        
        END_INTERFACE
    } IDSFVersionVtbl;

    interface IDSFVersion
    {
        CONST_VTBL struct IDSFVersionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFVersion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFVersion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFVersion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFVersion_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFVersion_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFVersion_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFVersion_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFVersion_get_Major(This,plMajor)	\
    ( (This)->lpVtbl -> get_Major(This,plMajor) ) 

#define IDSFVersion_get_Minor(This,plMinor)	\
    ( (This)->lpVtbl -> get_Minor(This,plMinor) ) 

#define IDSFVersion_get_OSMajor(This,plOSMajor)	\
    ( (This)->lpVtbl -> get_OSMajor(This,plOSMajor) ) 

#define IDSFVersion_get_OSMinor(This,plOSMinor)	\
    ( (This)->lpVtbl -> get_OSMinor(This,plOSMinor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFVersion_INTERFACE_DEFINED__ */


#ifndef __IDSFPropertyBag_INTERFACE_DEFINED__
#define __IDSFPropertyBag_INTERFACE_DEFINED__

/* interface IDSFPropertyBag */
/* [object][helpstringcontext][helpcontext][helpstring][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFPropertyBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac2ed126-da20-48db-817c-61689122d1e0")
    IDSFPropertyBag : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Write( 
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Read( 
            /* [in] */ __RPC__in BSTR Name,
            /* [retval][out] */ __RPC__out VARIANT *Value) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ __RPC__in BSTR Name) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFPropertyBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFPropertyBag * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFPropertyBag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFPropertyBag * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFPropertyBag * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFPropertyBag * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFPropertyBag * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFPropertyBag * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Write )( 
            IDSFPropertyBag * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ VARIANT Value);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Read )( 
            IDSFPropertyBag * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [retval][out] */ __RPC__out VARIANT *Value);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            IDSFPropertyBag * This,
            /* [in] */ __RPC__in BSTR Name);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            IDSFPropertyBag * This);
        
        END_INTERFACE
    } IDSFPropertyBagVtbl;

    interface IDSFPropertyBag
    {
        CONST_VTBL struct IDSFPropertyBagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFPropertyBag_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFPropertyBag_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFPropertyBag_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFPropertyBag_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFPropertyBag_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFPropertyBag_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFPropertyBag_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFPropertyBag_Write(This,Name,Value)	\
    ( (This)->lpVtbl -> Write(This,Name,Value) ) 

#define IDSFPropertyBag_Read(This,Name,Value)	\
    ( (This)->lpVtbl -> Read(This,Name,Value) ) 

#define IDSFPropertyBag_Remove(This,Name)	\
    ( (This)->lpVtbl -> Remove(This,Name) ) 

#define IDSFPropertyBag_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFPropertyBag_INTERFACE_DEFINED__ */


#ifndef __IDSFBus_INTERFACE_DEFINED__
#define __IDSFBus_INTERFACE_DEFINED__

/* interface IDSFBus */
/* [object][helpstringcontext][helpcontext][helpstring][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFBus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E927C266-5364-449E-AE52-D6A782AFDA9C")
    IDSFBus : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_GUID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGuid) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall HotPlug( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Unplug( 
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFBusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFBus * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFBus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFBus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFBus * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFBus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFBus * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFBus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Name )( 
            IDSFBus * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_GUID )( 
            IDSFBus * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGuid);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *HotPlug )( 
            IDSFBus * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Unplug )( 
            IDSFBus * This,
            /* [in] */ __RPC__in DSFDevice	*pDSFDevice);
        
        END_INTERFACE
    } IDSFBusVtbl;

    interface IDSFBus
    {
        CONST_VTBL struct IDSFBusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFBus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFBus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFBus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFBus_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFBus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFBus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFBus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFBus_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IDSFBus_get_GUID(This,pbstrGuid)	\
    ( (This)->lpVtbl -> get_GUID(This,pbstrGuid) ) 

#define IDSFBus_HotPlug(This,pDSFDevice)	\
    ( (This)->lpVtbl -> HotPlug(This,pDSFDevice) ) 

#define IDSFBus_Unplug(This,pDSFDevice)	\
    ( (This)->lpVtbl -> Unplug(This,pDSFDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFBus_INTERFACE_DEFINED__ */


#ifndef __IDSFPartialResourceDescriptor_INTERFACE_DEFINED__
#define __IDSFPartialResourceDescriptor_INTERFACE_DEFINED__

/* interface IDSFPartialResourceDescriptor */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFPartialResourceDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("227948DE-4F1F-4689-8D9F-ED044417C5A9")
    IDSFPartialResourceDescriptor : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Type( 
            /* [retval][out] */ __RPC__out DSFResourceType *pType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Type( 
            /* [in] */ DSFResourceType ResType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ShareDisposition( 
            /* [retval][out] */ __RPC__out DSFShareDisposition *pShareType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ShareDisposition( 
            /* [in] */ DSFShareDisposition ShareType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Flags( 
            /* [retval][out] */ __RPC__out short *psFlags) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Flags( 
            /* [in] */ short sFlags) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Descriptor( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Descriptor( 
            /* [in] */ __RPC__in_opt IDispatch *pdispDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HRM( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkHRM) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HRM( 
            /* [in] */ __RPC__in_opt IUnknown *punkHRM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFPartialResourceDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFPartialResourceDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFPartialResourceDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFPartialResourceDescriptor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Type )( 
            IDSFPartialResourceDescriptor * This,
            /* [retval][out] */ __RPC__out DSFResourceType *pType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Type )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ DSFResourceType ResType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ShareDisposition )( 
            IDSFPartialResourceDescriptor * This,
            /* [retval][out] */ __RPC__out DSFShareDisposition *pShareType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ShareDisposition )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ DSFShareDisposition ShareType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Flags )( 
            IDSFPartialResourceDescriptor * This,
            /* [retval][out] */ __RPC__out short *psFlags);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Flags )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ short sFlags);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Descriptor )( 
            IDSFPartialResourceDescriptor * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Descriptor )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ __RPC__in_opt IDispatch *pdispDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HRM )( 
            IDSFPartialResourceDescriptor * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkHRM);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HRM )( 
            IDSFPartialResourceDescriptor * This,
            /* [in] */ __RPC__in_opt IUnknown *punkHRM);
        
        END_INTERFACE
    } IDSFPartialResourceDescriptorVtbl;

    interface IDSFPartialResourceDescriptor
    {
        CONST_VTBL struct IDSFPartialResourceDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFPartialResourceDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFPartialResourceDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFPartialResourceDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFPartialResourceDescriptor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFPartialResourceDescriptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFPartialResourceDescriptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFPartialResourceDescriptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFPartialResourceDescriptor_get_Type(This,pType)	\
    ( (This)->lpVtbl -> get_Type(This,pType) ) 

#define IDSFPartialResourceDescriptor_put_Type(This,ResType)	\
    ( (This)->lpVtbl -> put_Type(This,ResType) ) 

#define IDSFPartialResourceDescriptor_get_ShareDisposition(This,pShareType)	\
    ( (This)->lpVtbl -> get_ShareDisposition(This,pShareType) ) 

#define IDSFPartialResourceDescriptor_put_ShareDisposition(This,ShareType)	\
    ( (This)->lpVtbl -> put_ShareDisposition(This,ShareType) ) 

#define IDSFPartialResourceDescriptor_get_Flags(This,psFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,psFlags) ) 

#define IDSFPartialResourceDescriptor_put_Flags(This,sFlags)	\
    ( (This)->lpVtbl -> put_Flags(This,sFlags) ) 

#define IDSFPartialResourceDescriptor_get_Descriptor(This,ppdispDescriptor)	\
    ( (This)->lpVtbl -> get_Descriptor(This,ppdispDescriptor) ) 

#define IDSFPartialResourceDescriptor_put_Descriptor(This,pdispDescriptor)	\
    ( (This)->lpVtbl -> put_Descriptor(This,pdispDescriptor) ) 

#define IDSFPartialResourceDescriptor_get_HRM(This,ppunkHRM)	\
    ( (This)->lpVtbl -> get_HRM(This,ppunkHRM) ) 

#define IDSFPartialResourceDescriptor_put_HRM(This,punkHRM)	\
    ( (This)->lpVtbl -> put_HRM(This,punkHRM) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFPartialResourceDescriptor_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFPartialResourceDescriptor;

#ifdef __cplusplus

class DECLSPEC_UUID("7E3FC012-1DB1-4135-AAAA-7FA6ED1CF620")
DSFPartialResourceDescriptor;
#endif

#ifndef __IDSFPartialResourceList_INTERFACE_DEFINED__
#define __IDSFPartialResourceList_INTERFACE_DEFINED__

/* interface IDSFPartialResourceList */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFPartialResourceList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C388EB82-EA52-4459-84D9-69B7E9846EC0")
    IDSFPartialResourceList : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Version( 
            /* [retval][out] */ __RPC__out short *psVersion) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Version( 
            /* [in] */ short sVersion) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Revision( 
            /* [retval][out] */ __RPC__out short *psRevision) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Revision( 
            /* [in] */ short sRevision) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt DSFPartialResourceDescriptor	**ppDSFPartialResourceDescriptor) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in DSFPartialResourceDescriptor	*pDSFPartialResourceDescriptor,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFPartialResourceListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFPartialResourceList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFPartialResourceList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFPartialResourceList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFPartialResourceList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFPartialResourceList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFPartialResourceList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFPartialResourceList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Version )( 
            IDSFPartialResourceList * This,
            /* [retval][out] */ __RPC__out short *psVersion);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Version )( 
            IDSFPartialResourceList * This,
            /* [in] */ short sVersion);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Revision )( 
            IDSFPartialResourceList * This,
            /* [retval][out] */ __RPC__out short *psRevision);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Revision )( 
            IDSFPartialResourceList * This,
            /* [in] */ short sRevision);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            IDSFPartialResourceList * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            IDSFPartialResourceList * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt DSFPartialResourceDescriptor	**ppDSFPartialResourceDescriptor);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            IDSFPartialResourceList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            IDSFPartialResourceList * This,
            /* [in] */ __RPC__in DSFPartialResourceDescriptor	*pDSFPartialResourceDescriptor,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            IDSFPartialResourceList * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            IDSFPartialResourceList * This);
        
        END_INTERFACE
    } IDSFPartialResourceListVtbl;

    interface IDSFPartialResourceList
    {
        CONST_VTBL struct IDSFPartialResourceListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFPartialResourceList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFPartialResourceList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFPartialResourceList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFPartialResourceList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFPartialResourceList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFPartialResourceList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFPartialResourceList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFPartialResourceList_get_Version(This,psVersion)	\
    ( (This)->lpVtbl -> get_Version(This,psVersion) ) 

#define IDSFPartialResourceList_put_Version(This,sVersion)	\
    ( (This)->lpVtbl -> put_Version(This,sVersion) ) 

#define IDSFPartialResourceList_get_Revision(This,psRevision)	\
    ( (This)->lpVtbl -> get_Revision(This,psRevision) ) 

#define IDSFPartialResourceList_put_Revision(This,sRevision)	\
    ( (This)->lpVtbl -> put_Revision(This,sRevision) ) 

#define IDSFPartialResourceList_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IDSFPartialResourceList_get_Item(This,Index,ppDSFPartialResourceDescriptor)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppDSFPartialResourceDescriptor) ) 

#define IDSFPartialResourceList_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define IDSFPartialResourceList_Add(This,pDSFPartialResourceDescriptor,Index)	\
    ( (This)->lpVtbl -> Add(This,pDSFPartialResourceDescriptor,Index) ) 

#define IDSFPartialResourceList_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IDSFPartialResourceList_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFPartialResourceList_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFPartialResourceList;

#ifdef __cplusplus

class DECLSPEC_UUID("DC1C8B82-254C-4AD9-8CE0-CA477FC56DB1")
DSFPartialResourceList;
#endif

EXTERN_C const CLSID CLSID_DSFFullResourceDescriptor;

#ifdef __cplusplus

class DECLSPEC_UUID("CECFEC54-035C-4103-B64F-A200AB9F32C2")
DSFFullResourceDescriptor;
#endif

EXTERN_C const CLSID CLSID_DSFResourceList;

#ifdef __cplusplus

class DECLSPEC_UUID("3596C463-2D1E-40B7-8DC7-7BB32F9E2DC4")
DSFResourceList;
#endif

#ifndef __IDSFResDescPort_INTERFACE_DEFINED__
#define __IDSFResDescPort_INTERFACE_DEFINED__

/* interface IDSFResDescPort */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResDescPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82850DB2-0F99-4529-9F6E-6C1273C6027C")
    IDSFResDescPort : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_StartLow( 
            /* [retval][out] */ __RPC__out long *plStartLow) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_StartLow( 
            /* [in] */ long lStartLow) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_StartHigh( 
            /* [retval][out] */ __RPC__out long *plStartHigh) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_StartHigh( 
            /* [in] */ long lStartHigh) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out long *plLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ long lLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResDescPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResDescPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResDescPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResDescPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResDescPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResDescPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResDescPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResDescPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_StartLow )( 
            IDSFResDescPort * This,
            /* [retval][out] */ __RPC__out long *plStartLow);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_StartLow )( 
            IDSFResDescPort * This,
            /* [in] */ long lStartLow);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_StartHigh )( 
            IDSFResDescPort * This,
            /* [retval][out] */ __RPC__out long *plStartHigh);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_StartHigh )( 
            IDSFResDescPort * This,
            /* [in] */ long lStartHigh);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            IDSFResDescPort * This,
            /* [retval][out] */ __RPC__out long *plLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            IDSFResDescPort * This,
            /* [in] */ long lLength);
        
        END_INTERFACE
    } IDSFResDescPortVtbl;

    interface IDSFResDescPort
    {
        CONST_VTBL struct IDSFResDescPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResDescPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResDescPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResDescPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResDescPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResDescPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResDescPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResDescPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResDescPort_get_StartLow(This,plStartLow)	\
    ( (This)->lpVtbl -> get_StartLow(This,plStartLow) ) 

#define IDSFResDescPort_put_StartLow(This,lStartLow)	\
    ( (This)->lpVtbl -> put_StartLow(This,lStartLow) ) 

#define IDSFResDescPort_get_StartHigh(This,plStartHigh)	\
    ( (This)->lpVtbl -> get_StartHigh(This,plStartHigh) ) 

#define IDSFResDescPort_put_StartHigh(This,lStartHigh)	\
    ( (This)->lpVtbl -> put_StartHigh(This,lStartHigh) ) 

#define IDSFResDescPort_get_Length(This,plLength)	\
    ( (This)->lpVtbl -> get_Length(This,plLength) ) 

#define IDSFResDescPort_put_Length(This,lLength)	\
    ( (This)->lpVtbl -> put_Length(This,lLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResDescPort_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFResDescPort;

#ifdef __cplusplus

class DECLSPEC_UUID("680D2930-B314-4B4F-87F0-14E8ECB1982F")
DSFResDescPort;
#endif

#ifndef __IDSFResDescDevSpecific_INTERFACE_DEFINED__
#define __IDSFResDescDevSpecific_INTERFACE_DEFINED__

/* interface IDSFResDescDevSpecific */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResDescDevSpecific;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("914D27BF-0AB4-44c2-873D-84D163B39DD5")
    IDSFResDescDevSpecific : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DataSize( 
            /* [retval][out] */ __RPC__out long *plDataSize) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DataSize( 
            /* [in] */ long lDataSize) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reserved1( 
            /* [retval][out] */ __RPC__out long *plReserved1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Reserved1( 
            /* [in] */ long lReserved1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reserved2( 
            /* [retval][out] */ __RPC__out long *plReserved2) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Reserved2( 
            /* [in] */ long lReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResDescDevSpecificVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResDescDevSpecific * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResDescDevSpecific * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResDescDevSpecific * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DataSize )( 
            IDSFResDescDevSpecific * This,
            /* [retval][out] */ __RPC__out long *plDataSize);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DataSize )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ long lDataSize);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reserved1 )( 
            IDSFResDescDevSpecific * This,
            /* [retval][out] */ __RPC__out long *plReserved1);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Reserved1 )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ long lReserved1);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reserved2 )( 
            IDSFResDescDevSpecific * This,
            /* [retval][out] */ __RPC__out long *plReserved2);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Reserved2 )( 
            IDSFResDescDevSpecific * This,
            /* [in] */ long lReserved2);
        
        END_INTERFACE
    } IDSFResDescDevSpecificVtbl;

    interface IDSFResDescDevSpecific
    {
        CONST_VTBL struct IDSFResDescDevSpecificVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResDescDevSpecific_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResDescDevSpecific_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResDescDevSpecific_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResDescDevSpecific_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResDescDevSpecific_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResDescDevSpecific_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResDescDevSpecific_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResDescDevSpecific_get_DataSize(This,plDataSize)	\
    ( (This)->lpVtbl -> get_DataSize(This,plDataSize) ) 

#define IDSFResDescDevSpecific_put_DataSize(This,lDataSize)	\
    ( (This)->lpVtbl -> put_DataSize(This,lDataSize) ) 

#define IDSFResDescDevSpecific_get_Reserved1(This,plReserved1)	\
    ( (This)->lpVtbl -> get_Reserved1(This,plReserved1) ) 

#define IDSFResDescDevSpecific_put_Reserved1(This,lReserved1)	\
    ( (This)->lpVtbl -> put_Reserved1(This,lReserved1) ) 

#define IDSFResDescDevSpecific_get_Reserved2(This,plReserved2)	\
    ( (This)->lpVtbl -> get_Reserved2(This,plReserved2) ) 

#define IDSFResDescDevSpecific_put_Reserved2(This,lReserved2)	\
    ( (This)->lpVtbl -> put_Reserved2(This,lReserved2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResDescDevSpecific_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFResDescDevSpecific;

#ifdef __cplusplus

class DECLSPEC_UUID("75679715-3926-4211-A5A6-6A333023D5BA")
DSFResDescDevSpecific;
#endif

#ifndef __IDSFResDescDevPrivate_INTERFACE_DEFINED__
#define __IDSFResDescDevPrivate_INTERFACE_DEFINED__

/* interface IDSFResDescDevPrivate */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResDescDevPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C455E6E1-F93D-47bd-9042-95B7AB0A7D2B")
    IDSFResDescDevPrivate : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Data0( 
            /* [retval][out] */ __RPC__out long *plData0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Data0( 
            /* [in] */ long lData0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Data1( 
            /* [retval][out] */ __RPC__out long *plData1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Data1( 
            /* [in] */ long lData1) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Data2( 
            /* [retval][out] */ __RPC__out long *plData2) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Data2( 
            /* [in] */ long lData2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResDescDevPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResDescDevPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResDescDevPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResDescDevPrivate * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Data0 )( 
            IDSFResDescDevPrivate * This,
            /* [retval][out] */ __RPC__out long *plData0);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Data0 )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ long lData0);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Data1 )( 
            IDSFResDescDevPrivate * This,
            /* [retval][out] */ __RPC__out long *plData1);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Data1 )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ long lData1);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Data2 )( 
            IDSFResDescDevPrivate * This,
            /* [retval][out] */ __RPC__out long *plData2);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Data2 )( 
            IDSFResDescDevPrivate * This,
            /* [in] */ long lData2);
        
        END_INTERFACE
    } IDSFResDescDevPrivateVtbl;

    interface IDSFResDescDevPrivate
    {
        CONST_VTBL struct IDSFResDescDevPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResDescDevPrivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResDescDevPrivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResDescDevPrivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResDescDevPrivate_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResDescDevPrivate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResDescDevPrivate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResDescDevPrivate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResDescDevPrivate_get_Data0(This,plData0)	\
    ( (This)->lpVtbl -> get_Data0(This,plData0) ) 

#define IDSFResDescDevPrivate_put_Data0(This,lData0)	\
    ( (This)->lpVtbl -> put_Data0(This,lData0) ) 

#define IDSFResDescDevPrivate_get_Data1(This,plData1)	\
    ( (This)->lpVtbl -> get_Data1(This,plData1) ) 

#define IDSFResDescDevPrivate_put_Data1(This,lData1)	\
    ( (This)->lpVtbl -> put_Data1(This,lData1) ) 

#define IDSFResDescDevPrivate_get_Data2(This,plData2)	\
    ( (This)->lpVtbl -> get_Data2(This,plData2) ) 

#define IDSFResDescDevPrivate_put_Data2(This,lData2)	\
    ( (This)->lpVtbl -> put_Data2(This,lData2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResDescDevPrivate_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFResDescDevPrivate;

#ifdef __cplusplus

class DECLSPEC_UUID("F03EAE50-D772-4125-82E7-087B91ADF213")
DSFResDescDevPrivate;
#endif

#ifndef __IDSFResDescInterrupt_INTERFACE_DEFINED__
#define __IDSFResDescInterrupt_INTERFACE_DEFINED__

/* interface IDSFResDescInterrupt */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResDescInterrupt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20F6EF07-E851-464A-B1BC-549B941682B0")
    IDSFResDescInterrupt : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Level( 
            /* [retval][out] */ __RPC__out long *plLevel) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Level( 
            /* [in] */ long lLevel) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Vector( 
            /* [retval][out] */ __RPC__out long *plVector) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Vector( 
            /* [in] */ long lVector) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Affinity( 
            /* [retval][out] */ __RPC__out long *plAffinity) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Affinity( 
            /* [in] */ long lAffinity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResDescInterruptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResDescInterrupt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResDescInterrupt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResDescInterrupt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResDescInterrupt * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResDescInterrupt * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResDescInterrupt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResDescInterrupt * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Level )( 
            IDSFResDescInterrupt * This,
            /* [retval][out] */ __RPC__out long *plLevel);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Level )( 
            IDSFResDescInterrupt * This,
            /* [in] */ long lLevel);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Vector )( 
            IDSFResDescInterrupt * This,
            /* [retval][out] */ __RPC__out long *plVector);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Vector )( 
            IDSFResDescInterrupt * This,
            /* [in] */ long lVector);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Affinity )( 
            IDSFResDescInterrupt * This,
            /* [retval][out] */ __RPC__out long *plAffinity);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Affinity )( 
            IDSFResDescInterrupt * This,
            /* [in] */ long lAffinity);
        
        END_INTERFACE
    } IDSFResDescInterruptVtbl;

    interface IDSFResDescInterrupt
    {
        CONST_VTBL struct IDSFResDescInterruptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResDescInterrupt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResDescInterrupt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResDescInterrupt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResDescInterrupt_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResDescInterrupt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResDescInterrupt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResDescInterrupt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResDescInterrupt_get_Level(This,plLevel)	\
    ( (This)->lpVtbl -> get_Level(This,plLevel) ) 

#define IDSFResDescInterrupt_put_Level(This,lLevel)	\
    ( (This)->lpVtbl -> put_Level(This,lLevel) ) 

#define IDSFResDescInterrupt_get_Vector(This,plVector)	\
    ( (This)->lpVtbl -> get_Vector(This,plVector) ) 

#define IDSFResDescInterrupt_put_Vector(This,lVector)	\
    ( (This)->lpVtbl -> put_Vector(This,lVector) ) 

#define IDSFResDescInterrupt_get_Affinity(This,plAffinity)	\
    ( (This)->lpVtbl -> get_Affinity(This,plAffinity) ) 

#define IDSFResDescInterrupt_put_Affinity(This,lAffinity)	\
    ( (This)->lpVtbl -> put_Affinity(This,lAffinity) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResDescInterrupt_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFResDescInterrupt;

#ifdef __cplusplus

class DECLSPEC_UUID("B68DF23C-9DB6-4C0A-B927-94F0AFE080C4")
DSFResDescInterrupt;
#endif

#ifndef __IDSFResDescMemory_INTERFACE_DEFINED__
#define __IDSFResDescMemory_INTERFACE_DEFINED__

/* interface IDSFResDescMemory */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResDescMemory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48ADC411-19EE-4E06-9772-882B487BB8C0")
    IDSFResDescMemory : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_StartLow( 
            /* [retval][out] */ __RPC__out long *plStartLow) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_StartLow( 
            /* [in] */ long lStartLow) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_StartHigh( 
            /* [retval][out] */ __RPC__out long *plStartHigh) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_StartHigh( 
            /* [in] */ long lStartHigh) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out long *plLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ long lLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResDescMemoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResDescMemory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResDescMemory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResDescMemory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResDescMemory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResDescMemory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResDescMemory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResDescMemory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_StartLow )( 
            IDSFResDescMemory * This,
            /* [retval][out] */ __RPC__out long *plStartLow);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_StartLow )( 
            IDSFResDescMemory * This,
            /* [in] */ long lStartLow);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_StartHigh )( 
            IDSFResDescMemory * This,
            /* [retval][out] */ __RPC__out long *plStartHigh);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_StartHigh )( 
            IDSFResDescMemory * This,
            /* [in] */ long lStartHigh);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            IDSFResDescMemory * This,
            /* [retval][out] */ __RPC__out long *plLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            IDSFResDescMemory * This,
            /* [in] */ long lLength);
        
        END_INTERFACE
    } IDSFResDescMemoryVtbl;

    interface IDSFResDescMemory
    {
        CONST_VTBL struct IDSFResDescMemoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResDescMemory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResDescMemory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResDescMemory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResDescMemory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResDescMemory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResDescMemory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResDescMemory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResDescMemory_get_StartLow(This,plStartLow)	\
    ( (This)->lpVtbl -> get_StartLow(This,plStartLow) ) 

#define IDSFResDescMemory_put_StartLow(This,lStartLow)	\
    ( (This)->lpVtbl -> put_StartLow(This,lStartLow) ) 

#define IDSFResDescMemory_get_StartHigh(This,plStartHigh)	\
    ( (This)->lpVtbl -> get_StartHigh(This,plStartHigh) ) 

#define IDSFResDescMemory_put_StartHigh(This,lStartHigh)	\
    ( (This)->lpVtbl -> put_StartHigh(This,lStartHigh) ) 

#define IDSFResDescMemory_get_Length(This,plLength)	\
    ( (This)->lpVtbl -> get_Length(This,plLength) ) 

#define IDSFResDescMemory_put_Length(This,lLength)	\
    ( (This)->lpVtbl -> put_Length(This,lLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResDescMemory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFResDescMemory;

#ifdef __cplusplus

class DECLSPEC_UUID("FDB94131-E0D2-41E7-A43F-72258F098281")
DSFResDescMemory;
#endif

#ifndef __IDSFResDescDMA_INTERFACE_DEFINED__
#define __IDSFResDescDMA_INTERFACE_DEFINED__

/* interface IDSFResDescDMA */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFResDescDMA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9DA9B4D3-C73F-42B8-8CA2-0E5E3FF7198E")
    IDSFResDescDMA : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Channel( 
            /* [retval][out] */ __RPC__out long *plChannel) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Channel( 
            /* [in] */ long lChannel) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Port( 
            /* [retval][out] */ __RPC__out long *plPort) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Port( 
            /* [in] */ long lPort) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reserved( 
            /* [retval][out] */ __RPC__out long *plReserved) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Reserved( 
            /* [in] */ long lReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFResDescDMAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFResDescDMA * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFResDescDMA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFResDescDMA * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFResDescDMA * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFResDescDMA * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFResDescDMA * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFResDescDMA * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Channel )( 
            IDSFResDescDMA * This,
            /* [retval][out] */ __RPC__out long *plChannel);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Channel )( 
            IDSFResDescDMA * This,
            /* [in] */ long lChannel);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Port )( 
            IDSFResDescDMA * This,
            /* [retval][out] */ __RPC__out long *plPort);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Port )( 
            IDSFResDescDMA * This,
            /* [in] */ long lPort);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reserved )( 
            IDSFResDescDMA * This,
            /* [retval][out] */ __RPC__out long *plReserved);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Reserved )( 
            IDSFResDescDMA * This,
            /* [in] */ long lReserved);
        
        END_INTERFACE
    } IDSFResDescDMAVtbl;

    interface IDSFResDescDMA
    {
        CONST_VTBL struct IDSFResDescDMAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFResDescDMA_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFResDescDMA_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFResDescDMA_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFResDescDMA_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFResDescDMA_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFResDescDMA_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFResDescDMA_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFResDescDMA_get_Channel(This,plChannel)	\
    ( (This)->lpVtbl -> get_Channel(This,plChannel) ) 

#define IDSFResDescDMA_put_Channel(This,lChannel)	\
    ( (This)->lpVtbl -> put_Channel(This,lChannel) ) 

#define IDSFResDescDMA_get_Port(This,plPort)	\
    ( (This)->lpVtbl -> get_Port(This,plPort) ) 

#define IDSFResDescDMA_put_Port(This,lPort)	\
    ( (This)->lpVtbl -> put_Port(This,lPort) ) 

#define IDSFResDescDMA_get_Reserved(This,plReserved)	\
    ( (This)->lpVtbl -> get_Reserved(This,plReserved) ) 

#define IDSFResDescDMA_put_Reserved(This,lReserved)	\
    ( (This)->lpVtbl -> put_Reserved(This,lReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFResDescDMA_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFResDescDMA;

#ifdef __cplusplus

class DECLSPEC_UUID("449D593F-EFE0-414E-A5D8-2333B223090E")
DSFResDescDMA;
#endif

#ifndef __IDSFSystemDevice_INTERFACE_DEFINED__
#define __IDSFSystemDevice_INTERFACE_DEFINED__

/* interface IDSFSystemDevice */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_IDSFSystemDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8041F860-55E4-4709-A96C-FA51EBC8F895")
    IDSFSystemDevice : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Address( 
            /* [retval][out] */ __RPC__out long *plAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Address( 
            /* [in] */ long lAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_BusNumber( 
            /* [retval][out] */ __RPC__out long *plBusNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_BusNumber( 
            /* [in] */ long lBusNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_BusTypeGUID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGUID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_BusTypeGUID( 
            /* [in] */ __RPC__in BSTR bstrGUID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Capabilities( 
            /* [retval][out] */ __RPC__deref_out_opt DSFDeviceCaps	**ppDSFDeviceCaps) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Capabilities( 
            /* [in] */ __RPC__in DSFDeviceCaps	*pDSFDeviceCaps) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_Capabilities( 
            /* [in] */ __RPC__in DSFDeviceCaps	*pDSFDeviceCaps) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ClassGUID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGUID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ClassGUID( 
            /* [in] */ __RPC__in BSTR bstrGUID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ClassName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ClassName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_CompatibleIDs( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaIDs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_CompatibleIDs( 
            /* [in] */ __RPC__in SAFEARRAY * psaIDs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDescription) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceDescription( 
            /* [in] */ __RPC__in BSTR bstrDescription) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceID( 
            /* [in] */ __RPC__in BSTR bstrID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DriverKeyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrKeyName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DriverKeyName( 
            /* [in] */ __RPC__in BSTR bstrKeyName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_EnumeratorName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_EnumeratorName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_FriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_FriendlyName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HardwareIDs( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaIDs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HardwareIDs( 
            /* [in] */ __RPC__in SAFEARRAY * psaIDs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_InstanceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_InstanceID( 
            /* [in] */ __RPC__in BSTR bstrID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LegacyBusType( 
            /* [retval][out] */ __RPC__out DSFInterfaceType *pBusType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LegacyBusType( 
            /* [in] */ DSFInterfaceType BusType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LocationInfo( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInfo) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LocationInfo( 
            /* [in] */ __RPC__in BSTR bstrInfo) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Manufacturer( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Manufacturer( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_PDOName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPDOName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_PDOName( 
            /* [in] */ __RPC__in BSTR bstrPDOName) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_RawResources( 
            /* [retval][out] */ __RPC__deref_out_opt DSFResourceList	**ppDSFResourceList) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_RawResources( 
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_RawResources( 
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_UINumber( 
            /* [retval][out] */ __RPC__out long *plNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_UINumber( 
            /* [in] */ long lNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_XlatedResources( 
            /* [retval][out] */ __RPC__deref_out_opt DSFResourceList	**ppDSFResourceList) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_XlatedResources( 
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_XlatedResources( 
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFSystemDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFSystemDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFSystemDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSFSystemDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSFSystemDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSFSystemDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Address )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__out long *plAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Address )( 
            IDSFSystemDevice * This,
            /* [in] */ long lAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_BusNumber )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__out long *plBusNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_BusNumber )( 
            IDSFSystemDevice * This,
            /* [in] */ long lBusNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_BusTypeGUID )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGUID);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_BusTypeGUID )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrGUID);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Capabilities )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFDeviceCaps	**ppDSFDeviceCaps);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Capabilities )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in DSFDeviceCaps	*pDSFDeviceCaps);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_Capabilities )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in DSFDeviceCaps	*pDSFDeviceCaps);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ClassGUID )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGUID);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ClassGUID )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrGUID);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ClassName )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ClassName )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_CompatibleIDs )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaIDs);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_CompatibleIDs )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in SAFEARRAY * psaIDs);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceDescription )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDescription);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceDescription )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrDescription);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceID )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrID);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceID )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrID);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DriverKeyName )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrKeyName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DriverKeyName )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrKeyName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_EnumeratorName )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_EnumeratorName )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_FriendlyName )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_FriendlyName )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HardwareIDs )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaIDs);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HardwareIDs )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in SAFEARRAY * psaIDs);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_InstanceID )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrID);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_InstanceID )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrID);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LegacyBusType )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__out DSFInterfaceType *pBusType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LegacyBusType )( 
            IDSFSystemDevice * This,
            /* [in] */ DSFInterfaceType BusType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LocationInfo )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInfo);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LocationInfo )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrInfo);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Manufacturer )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Manufacturer )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_PDOName )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPDOName);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_PDOName )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in BSTR bstrPDOName);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_RawResources )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFResourceList	**ppDSFResourceList);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_RawResources )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_RawResources )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_UINumber )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__out long *plNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_UINumber )( 
            IDSFSystemDevice * This,
            /* [in] */ long lNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_XlatedResources )( 
            IDSFSystemDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt DSFResourceList	**ppDSFResourceList);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_XlatedResources )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_XlatedResources )( 
            IDSFSystemDevice * This,
            /* [in] */ __RPC__in DSFResourceList	*pDSFResourceList);
        
        END_INTERFACE
    } IDSFSystemDeviceVtbl;

    interface IDSFSystemDevice
    {
        CONST_VTBL struct IDSFSystemDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFSystemDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFSystemDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFSystemDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFSystemDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSFSystemDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSFSystemDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSFSystemDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSFSystemDevice_get_Address(This,plAddress)	\
    ( (This)->lpVtbl -> get_Address(This,plAddress) ) 

#define IDSFSystemDevice_put_Address(This,lAddress)	\
    ( (This)->lpVtbl -> put_Address(This,lAddress) ) 

#define IDSFSystemDevice_get_BusNumber(This,plBusNumber)	\
    ( (This)->lpVtbl -> get_BusNumber(This,plBusNumber) ) 

#define IDSFSystemDevice_put_BusNumber(This,lBusNumber)	\
    ( (This)->lpVtbl -> put_BusNumber(This,lBusNumber) ) 

#define IDSFSystemDevice_get_BusTypeGUID(This,pbstrGUID)	\
    ( (This)->lpVtbl -> get_BusTypeGUID(This,pbstrGUID) ) 

#define IDSFSystemDevice_put_BusTypeGUID(This,bstrGUID)	\
    ( (This)->lpVtbl -> put_BusTypeGUID(This,bstrGUID) ) 

#define IDSFSystemDevice_get_Capabilities(This,ppDSFDeviceCaps)	\
    ( (This)->lpVtbl -> get_Capabilities(This,ppDSFDeviceCaps) ) 

#define IDSFSystemDevice_put_Capabilities(This,pDSFDeviceCaps)	\
    ( (This)->lpVtbl -> put_Capabilities(This,pDSFDeviceCaps) ) 

#define IDSFSystemDevice_putref_Capabilities(This,pDSFDeviceCaps)	\
    ( (This)->lpVtbl -> putref_Capabilities(This,pDSFDeviceCaps) ) 

#define IDSFSystemDevice_get_ClassGUID(This,pbstrGUID)	\
    ( (This)->lpVtbl -> get_ClassGUID(This,pbstrGUID) ) 

#define IDSFSystemDevice_put_ClassGUID(This,bstrGUID)	\
    ( (This)->lpVtbl -> put_ClassGUID(This,bstrGUID) ) 

#define IDSFSystemDevice_get_ClassName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_ClassName(This,pbstrName) ) 

#define IDSFSystemDevice_put_ClassName(This,bstrName)	\
    ( (This)->lpVtbl -> put_ClassName(This,bstrName) ) 

#define IDSFSystemDevice_get_CompatibleIDs(This,ppsaIDs)	\
    ( (This)->lpVtbl -> get_CompatibleIDs(This,ppsaIDs) ) 

#define IDSFSystemDevice_put_CompatibleIDs(This,psaIDs)	\
    ( (This)->lpVtbl -> put_CompatibleIDs(This,psaIDs) ) 

#define IDSFSystemDevice_get_DeviceDescription(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_DeviceDescription(This,pbstrDescription) ) 

#define IDSFSystemDevice_put_DeviceDescription(This,bstrDescription)	\
    ( (This)->lpVtbl -> put_DeviceDescription(This,bstrDescription) ) 

#define IDSFSystemDevice_get_DeviceID(This,pbstrID)	\
    ( (This)->lpVtbl -> get_DeviceID(This,pbstrID) ) 

#define IDSFSystemDevice_put_DeviceID(This,bstrID)	\
    ( (This)->lpVtbl -> put_DeviceID(This,bstrID) ) 

#define IDSFSystemDevice_get_DriverKeyName(This,pbstrKeyName)	\
    ( (This)->lpVtbl -> get_DriverKeyName(This,pbstrKeyName) ) 

#define IDSFSystemDevice_put_DriverKeyName(This,bstrKeyName)	\
    ( (This)->lpVtbl -> put_DriverKeyName(This,bstrKeyName) ) 

#define IDSFSystemDevice_get_EnumeratorName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_EnumeratorName(This,pbstrName) ) 

#define IDSFSystemDevice_put_EnumeratorName(This,bstrName)	\
    ( (This)->lpVtbl -> put_EnumeratorName(This,bstrName) ) 

#define IDSFSystemDevice_get_FriendlyName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbstrName) ) 

#define IDSFSystemDevice_put_FriendlyName(This,bstrName)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,bstrName) ) 

#define IDSFSystemDevice_get_HardwareIDs(This,ppsaIDs)	\
    ( (This)->lpVtbl -> get_HardwareIDs(This,ppsaIDs) ) 

#define IDSFSystemDevice_put_HardwareIDs(This,psaIDs)	\
    ( (This)->lpVtbl -> put_HardwareIDs(This,psaIDs) ) 

#define IDSFSystemDevice_get_InstanceID(This,pbstrID)	\
    ( (This)->lpVtbl -> get_InstanceID(This,pbstrID) ) 

#define IDSFSystemDevice_put_InstanceID(This,bstrID)	\
    ( (This)->lpVtbl -> put_InstanceID(This,bstrID) ) 

#define IDSFSystemDevice_get_LegacyBusType(This,pBusType)	\
    ( (This)->lpVtbl -> get_LegacyBusType(This,pBusType) ) 

#define IDSFSystemDevice_put_LegacyBusType(This,BusType)	\
    ( (This)->lpVtbl -> put_LegacyBusType(This,BusType) ) 

#define IDSFSystemDevice_get_LocationInfo(This,pbstrInfo)	\
    ( (This)->lpVtbl -> get_LocationInfo(This,pbstrInfo) ) 

#define IDSFSystemDevice_put_LocationInfo(This,bstrInfo)	\
    ( (This)->lpVtbl -> put_LocationInfo(This,bstrInfo) ) 

#define IDSFSystemDevice_get_Manufacturer(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Manufacturer(This,pbstrName) ) 

#define IDSFSystemDevice_put_Manufacturer(This,bstrName)	\
    ( (This)->lpVtbl -> put_Manufacturer(This,bstrName) ) 

#define IDSFSystemDevice_get_PDOName(This,pbstrPDOName)	\
    ( (This)->lpVtbl -> get_PDOName(This,pbstrPDOName) ) 

#define IDSFSystemDevice_put_PDOName(This,bstrPDOName)	\
    ( (This)->lpVtbl -> put_PDOName(This,bstrPDOName) ) 

#define IDSFSystemDevice_get_RawResources(This,ppDSFResourceList)	\
    ( (This)->lpVtbl -> get_RawResources(This,ppDSFResourceList) ) 

#define IDSFSystemDevice_put_RawResources(This,pDSFResourceList)	\
    ( (This)->lpVtbl -> put_RawResources(This,pDSFResourceList) ) 

#define IDSFSystemDevice_putref_RawResources(This,pDSFResourceList)	\
    ( (This)->lpVtbl -> putref_RawResources(This,pDSFResourceList) ) 

#define IDSFSystemDevice_get_UINumber(This,plNumber)	\
    ( (This)->lpVtbl -> get_UINumber(This,plNumber) ) 

#define IDSFSystemDevice_put_UINumber(This,lNumber)	\
    ( (This)->lpVtbl -> put_UINumber(This,lNumber) ) 

#define IDSFSystemDevice_get_XlatedResources(This,ppDSFResourceList)	\
    ( (This)->lpVtbl -> get_XlatedResources(This,ppDSFResourceList) ) 

#define IDSFSystemDevice_put_XlatedResources(This,pDSFResourceList)	\
    ( (This)->lpVtbl -> put_XlatedResources(This,pDSFResourceList) ) 

#define IDSFSystemDevice_putref_XlatedResources(This,pDSFResourceList)	\
    ( (This)->lpVtbl -> putref_XlatedResources(This,pDSFResourceList) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFSystemDevice_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFSystemDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("1AE675C7-9C3D-429c-94C9-137A00246470")
DSFSystemDevice;
#endif

EXTERN_C const CLSID CLSID_DSFDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("8B6626F7-F57B-4C47-AE2F-4813FB4D40D6")
DSFDevice;
#endif

EXTERN_C const CLSID CLSID_DSF;

#ifdef __cplusplus

class DECLSPEC_UUID("44DD6DC0-6427-4C02-8D5C-1179C50C65D7")
DSF;
#endif

EXTERN_C const CLSID CLSID_DSFDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("60FA4E76-ED77-4458-ABCF-56E23113FE61")
DSFDevices;
#endif

EXTERN_C const CLSID CLSID_DSFDeviceCaps;

#ifdef __cplusplus

class DECLSPEC_UUID("26FF1048-7125-45F8-ACA8-F13C5E883ED1")
DSFDeviceCaps;
#endif

EXTERN_C const CLSID CLSID_DSFLog;

#ifdef __cplusplus

class DECLSPEC_UUID("A880A214-56A0-426A-844A-7AACCF7C3641")
DSFLog;
#endif

EXTERN_C const CLSID CLSID_DSFVersion;

#ifdef __cplusplus

class DECLSPEC_UUID("9B89C450-8E7C-4B02-B4A0-B581A9999B47")
DSFVersion;
#endif

EXTERN_C const CLSID CLSID_DSFPropertyBag;

#ifdef __cplusplus

class DECLSPEC_UUID("c283c5ec-4ba5-46ec-9efc-e9f1bffe7c70")
DSFPropertyBag;
#endif

#ifndef __IDSFDebug_INTERFACE_DEFINED__
#define __IDSFDebug_INTERFACE_DEFINED__

/* interface IDSFDebug */
/* [object][helpstringcontext][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IDSFDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69b999b5-1f70-418b-83ac-900a289a07f9")
    IDSFDebug : public IUnknown
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall SetObjectFlags( 
            /* [in] */ DSFFlagType FlagType,
            /* [in] */ unsigned long Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSFDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSFDebug * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSFDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSFDebug * This);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *SetObjectFlags )( 
            IDSFDebug * This,
            /* [in] */ DSFFlagType FlagType,
            /* [in] */ unsigned long Flags);
        
        END_INTERFACE
    } IDSFDebugVtbl;

    interface IDSFDebug
    {
        CONST_VTBL struct IDSFDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSFDebug_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSFDebug_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSFDebug_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSFDebug_SetObjectFlags(This,FlagType,Flags)	\
    ( (This)->lpVtbl -> SetObjectFlags(This,FlagType,Flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSFDebug_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DSFDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("f6d08a7f-ef55-406b-be39-2fe6f613ef3d")
DSFDebug;
#endif

EXTERN_C const CLSID CLSID_DSFBus;

#ifdef __cplusplus

class DECLSPEC_UUID("0DEF0513-18CE-4AA4-8C7C-70D37206B4F7")
DSFBus;
#endif
#endif /* __DSF_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ExDispid.h ===
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes
#define DISPID_TITLEICONCHANGE    114   // sent when the top level window icon may have changed.

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204

#define DISPID_BEFORENAVIGATE2              250           // hyperlink clicked on
#define DISPID_NEWWINDOW2                   251
#define DISPID_NAVIGATECOMPLETE2            252           // UIActivate new document
#define DISPID_ONQUIT                       253
#define DISPID_ONVISIBLE                    254           // sent when the window goes visible/hidden
#define DISPID_ONTOOLBAR                    255           // sent when the toolbar should be shown/hidden
#define DISPID_ONMENUBAR                    256           // sent when the menubar should be shown/hidden
#define DISPID_ONSTATUSBAR                  257           // sent when the statusbar should be shown/hidden
#define DISPID_ONFULLSCREEN                 258           // sent when kiosk mode should be on/off
#define DISPID_DOCUMENTCOMPLETE             259           // new document goes ReadyState_Complete
#define DISPID_ONTHEATERMODE                260           // sent when theater mode should be on/off
#define DISPID_ONADDRESSBAR                 261           // sent when the address bar should be shown/hidden
#define DISPID_WINDOWSETRESIZABLE           262           // sent to set the style of the host window frame
#define DISPID_WINDOWCLOSING                263           // sent before script window.close closes the window 
#define DISPID_WINDOWSETLEFT                264           // sent when the put_left method is called on the WebOC
#define DISPID_WINDOWSETTOP                 265           // sent when the put_top method is called on the WebOC
#define DISPID_WINDOWSETWIDTH               266           // sent when the put_width method is called on the WebOC
#define DISPID_WINDOWSETHEIGHT              267           // sent when the put_height method is called on the WebOC 
#define DISPID_CLIENTTOHOSTWINDOW           268           // sent during window.open to request conversion of dimensions
#define DISPID_SETSECURELOCKICON            269           // sent to suggest the appropriate security icon to show
#define DISPID_FILEDOWNLOAD                 270           // Fired to indicate the File Download dialog is opening
#define DISPID_NAVIGATEERROR                271           // Fired to indicate the a binding error has occured
#define DISPID_PRIVACYIMPACTEDSTATECHANGE   272           // Fired when the user's browsing experience is impacted
#define DISPID_NEWWINDOW3                   273
#define DISPID_VIEWUPDATE                   281           // Fired when the contents of a shell browser window change
#define DISPID_SETPHISHINGFILTERSTATUS      282           // Fired by the Phishing Filter API to signal what state the analysis is in
#define DISPID_WINDOWSTATECHANGED           283           // Fired to indicate that the browser window's visibility or enabled state has changed

// Printing events
#define DISPID_PRINTTEMPLATEINSTANTIATION   225           // Fired to indicate that a print template is instantiated
#define DISPID_PRINTTEMPLATETEARDOWN        226           // Fired to indicate that a print templete is completely gone 
#define DISPID_UPDATEPAGESTATUS             227           // Fired to indicate that the spooling status has changed

// define the events for the shell window list
#define DISPID_WINDOWREGISTERED             200           // Window registered
#define DISPID_WINDOWREVOKED                201           // Window Revoked

#define DISPID_RESETFIRSTBOOTMODE       1
#define DISPID_RESETSAFEMODE            2
#define DISPID_REFRESHOFFLINEDESKTOP    3
#define DISPID_ADDFAVORITE              4
#define DISPID_ADDCHANNEL               5
#define DISPID_ADDDESKTOPCOMPONENT      6
#define DISPID_ISSUBSCRIBED             7
#define DISPID_NAVIGATEANDFIND          8
#define DISPID_IMPORTEXPORTFAVORITES    9
#define DISPID_AUTOCOMPLETESAVEFORM     10
#define DISPID_AUTOSCAN                 11
#define DISPID_AUTOCOMPLETEATTACH       12
#define DISPID_SHOWBROWSERUI            13
#define DISPID_ADDSEARCHPROVIDER        14
#define DISPID_RUNONCESHOWN             15
#define DISPID_SKIPRUNONCE              16
#define DISPID_CUSTOMIZESETTINGS        17
#define DISPID_SQMENABLED               18
#define DISPID_PHISHINGENABLED          19
#define DISPID_BRANDIMAGEURI            20
#define DISPID_SKIPTABSWELCOME          21
#define DISPID_DIAGNOSECONNECTION       22
#define DISPID_CUSTOMIZECLEARTYPE       23
#define DISPID_ISSEARCHPROVIDERINSTALLED 24
#define DISPID_ISSEARCHMIGRATED         25
#define DISPID_DEFAULTSEARCHPROVIDER    26
#define DISPID_RUNONCEREQUIREDSETTINGSCOMPLETE 27
#define DISPID_RUNONCEHASSHOWN          28
#define DISPID_SEARCHGUIDEURL           29
#define DISPID_SHELLUIHELPERLAST        30

#define DISPID_ADVANCEERROR             10
#define DISPID_RETREATERROR             11
#define DISPID_CANADVANCEERROR          12
#define DISPID_CANRETREATERROR          13
#define DISPID_GETERRORLINE             14
#define DISPID_GETERRORCHAR             15
#define DISPID_GETERRORCODE             16
#define DISPID_GETERRORMSG              17
#define DISPID_GETERRORURL              18
#define DISPID_GETDETAILSSTATE          19
#define DISPID_SETDETAILSSTATE          20
#define DISPID_GETPERERRSTATE           21
#define DISPID_SETPERERRSTATE           22
#define DISPID_GETALWAYSSHOWLOCKSTATE   23

// Dispatch IDS for ShellFavoritesNameSpace Dispatch Events.
//
#define DISPID_FAVSELECTIONCHANGE       1
#define DISPID_SELECTIONCHANGE          2
#define DISPID_DOUBLECLICK              3
#define DISPID_INITIALIZED              4

#define DISPID_MOVESELECTIONUP          1
#define DISPID_MOVESELECTIONDOWN        2
#define DISPID_RESETSORT                3
#define DISPID_NEWFOLDER                4
#define DISPID_SYNCHRONIZE              5
#define DISPID_IMPORT                   6
#define DISPID_EXPORT                   7
#define DISPID_INVOKECONTEXTMENU        8
#define DISPID_MOVESELECTIONTO          9
#define DISPID_SUBSCRIPTIONSENABLED     10
#define DISPID_CREATESUBSCRIPTION       11
#define DISPID_DELETESUBSCRIPTION       12
#define DISPID_SETROOT                  13
#define DISPID_ENUMOPTIONS              14
#define DISPID_SELECTEDITEM             15
#define DISPID_ROOT                     16
#define DISPID_DEPTH                    17
#define DISPID_MODE                     18
#define DISPID_FLAGS                    19
#define DISPID_TVFLAGS                  20
#define DISPID_NSCOLUMNS                21
#define DISPID_COUNTVIEWTYPES           22
#define DISPID_SETVIEWTYPE              23
#define DISPID_SELECTEDITEMS            24
#define DISPID_EXPAND                   25
#define DISPID_UNSELECTALL              26

#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fcbtable.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.h

Abstract:

    This module defines the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:
--*/


#ifndef _RXFCBTABLE_
#define _RXFCBTABLE_

typedef struct _RX_FCB_TABLE_ENTRY {

    //
    //  Normal Header for Refcounted Structure
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  the computed hash value
    //

    ULONG HashValue;

    //
    //  the path associated with the FCB
    //

    UNICODE_STRING Path;

    //
    //  the threaded list of all entries in a bucket.
    //

    LIST_ENTRY HashLinks;

    //
    //  Statistics for amortising lookup costs
    //

    LONG Lookups;
} RX_FCB_TABLE_ENTRY, *PRX_FCB_TABLE_ENTRY;


#define RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS 32

typedef struct _RX_FCB_TABLE {

    //
    //  Normal Header for refcounted data structures
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  version stamp changes on each insertion/removal
    //

    __volatile ULONG Version;

    BOOLEAN CaseInsensitiveMatch;
    USHORT NumberOfBuckets;

    //
    //  Statistics for table maintenance
    //

    __volatile LONG Lookups;
    __volatile LONG FailedLookups;
    __volatile LONG Compares;

    //
    //  Resource used to control table access
    //

    ERESOURCE TableLock;

    //
    //  TableEntry for the Null string
    //

    PRX_FCB_TABLE_ENTRY TableEntryForNull;

    //
    //  the hash buckets
    //

    LIST_ENTRY HashBuckets[RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS];
} RX_FCB_TABLE, *PRX_FCB_TABLE;

extern
VOID
RxInitializeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN BOOLEAN CaseInsensitiveMatch
    );

extern 
VOID
RxFinalizeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable
    );

extern 
PFCB
RxFcbTableLookupFcb (
    IN  PRX_FCB_TABLE FcbTable,
    IN  PUNICODE_STRING Path
    );

extern 
NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    );

extern 
NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    );

#define RxAcquireFcbTableLockShared(TABLE,WAIT) \
        ExAcquireResourceSharedLite( &(TABLE)->TableLock, WAIT )

#define RxAcquireFcbTableLockExclusive(TABLE,WAIT) \
        ExAcquireResourceExclusiveLite( &(TABLE)->TableLock, WAIT )

#define RxReleaseFcbTableLock(TABLE)  \
        ExReleaseResourceLite( &(TABLE)->TableLock )

#define RxIsFcbTableLockExclusive(TABLE) ExIsResourceAcquiredExclusiveLite( &(TABLE)->TableLock )

#define RxIsFcbTableLockAcquired(TABLE) ( ExIsResourceAcquiredSharedLite( &(TABLE)->TableLock ) || \
                                          ExIsResourceAcquiredExclusiveLite( &(TABLE)->TableLock ) )


#endif

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.h

Abstract:

    This module defines the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:
--*/


#ifndef _RXFCBTABLE_
#define _RXFCBTABLE_

typedef struct _RX_FCB_TABLE_ENTRY {

    //
    //  Normal Header for Refcounted Structure
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  the computed hash value
    //

    ULONG HashValue;

    //
    //  the path associated with the FCB
    //

    UNICODE_STRING Path;

    //
    //  the threaded list of all entries in a bucket.
    //

    LIST_ENTRY HashLinks;

    //
    //  Statistics for amortising lookup costs
    //

    LONG Lookups;
} RX_FCB_TABLE_ENTRY, *PRX_FCB_TABLE_ENTRY;


#define RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS 32

typedef struct _RX_FCB_TABLE {

    //
    //  Normal Header for refcounted data structures
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  version stamp changes on each insertion/removal
    //

    ULONG Version;

    BOOLEAN CaseInsensitiveMatch;
    USHORT NumberOfBuckets;

    //
    //  Statistics for table maintenance
    //

    LONG Lookups;
    LONG FailedLookups;
    LONG Compares;

    //
    //  Resource used to control table access
    //

    ERESOURCE TableLock;

    //
    //  TableEntry for the Null string
    //

    PRX_FCB_TABLE_ENTRY TableEntryForNull;

    //
    //  the hash buckets
    //

    LIST_ENTRY HashBuckets[RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS];
} RX_FCB_TABLE, *PRX_FCB_TABLE;

extern
VOID
RxInitializeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN BOOLEAN CaseInsensitiveMatch
    );

extern 
VOID
RxFinalizeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable
    );

extern 
PFCB
RxFcbTableLookupFcb (
    IN  PRX_FCB_TABLE FcbTable,
    IN  PUNICODE_STRING Path
    );

extern 
NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    );

extern 
NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    );

#define RxAcquireFcbTableLockShared(TABLE,WAIT) \
        ExAcquireResourceSharedLite( &(TABLE)->TableLock, WAIT )

#define RxAcquireFcbTableLockExclusive(TABLE,WAIT) \
        ExAcquireResourceExclusiveLite( &(TABLE)->TableLock, WAIT )

#define RxReleaseFcbTableLock(TABLE)  \
        ExReleaseResourceLite( &(TABLE)->TableLock )

#define RxIsFcbTableLockExclusive(TABLE) ExIsResourceAcquiredExclusiveLite( &(TABLE)->TableLock )

#define RxIsFcbTableLockAcquired(TABLE) ( ExIsResourceAcquiredSharedLite( &(TABLE)->TableLock ) || \
                                          ExIsResourceAcquiredExclusiveLite( &(TABLE)->TableLock ) )


#endif


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.h

Abstract:

    This module defines the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:
Revision History:

    This was derived from the original implementation of prefix tables done
    by Joe Linn.

--*/


#ifndef _RXFCBTABLE_
#define _RXFCBTABLE_

typedef struct _RX_FCB_TABLE_ENTRY {

    // Normal Header for Refcounted Structure
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    // the computed hash value
    ULONG      HashValue;

    // the path associated with the FCB
    UNICODE_STRING Path;

    // the threaded list of all entries in a bucket.
    LIST_ENTRY HashLinks;

    // Statistics for amortising lookup costs
    LONG       Lookups;
} RX_FCB_TABLE_ENTRY, *PRX_FCB_TABLE_ENTRY;


#define RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS 32

typedef struct _RX_FCB_TABLE {

    // Normal Header for refcounted data structures
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    // version stamp changes on each insertion/removal
    ULONG Version;

    BOOLEAN CaseInsensitiveMatch;
    USHORT  NumberOfBuckets;

    // Statistics for table maintenance
    LONG    Lookups;
    LONG    FailedLookups;
    LONG    Compares;

    // Resource used to control table access
    ERESOURCE TableLock;

    // TableEntry for the Null string
    PRX_FCB_TABLE_ENTRY pTableEntryForNull;

    // the hash buckets
    LIST_ENTRY HashBuckets[RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS];
} RX_FCB_TABLE, *PRX_FCB_TABLE;

extern VOID
RxInitializeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN     BOOLEAN       CaseInsensitiveMatch);

extern VOID
RxFinalizeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable);

extern PFCB
RxFcbTableLookupFcb(
    IN  PRX_FCB_TABLE    pFcbTable,
    IN  PUNICODE_STRING  pPath);

extern NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb);

extern NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb);

#define RxAcquireFcbTableLockShared(pFcbTable,Wait) \
        ExAcquireResourceSharedLite(&(pFcbTable)->TableLock,Wait)

#define RxAcquireFcbTableLockExclusive(pFcbTable,Wait) \
        ExAcquireResourceExclusiveLite(&(pFcbTable)->TableLock,Wait)

#define RxReleaseFcbTableLock(pFcbTable)  \
        ExReleaseResourceLite(&(pFcbTable)->TableLock)

#define RxIsFcbTableLockExclusive(PTABLE) ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock)

#define RxIsFcbTableLockAcquired(PTABLE) ( ExIsResourceAcquiredSharedLite(&(PTABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock) )


#endif


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.h

Abstract:

    This module defines the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:
--*/


#ifndef _RXFCBTABLE_
#define _RXFCBTABLE_

typedef struct _RX_FCB_TABLE_ENTRY {

    // Normal Header for Refcounted Structure
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    // the computed hash value
    ULONG      HashValue;

    // the path associated with the FCB
    UNICODE_STRING Path;

    // the threaded list of all entries in a bucket.
    LIST_ENTRY HashLinks;

    // Statistics for amortising lookup costs
    LONG       Lookups;
} RX_FCB_TABLE_ENTRY, *PRX_FCB_TABLE_ENTRY;


#define RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS 32

typedef struct _RX_FCB_TABLE {

    // Normal Header for refcounted data structures
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    // version stamp changes on each insertion/removal
    ULONG Version;

    BOOLEAN CaseInsensitiveMatch;
    USHORT  NumberOfBuckets;

    // Statistics for table maintenance
    LONG    Lookups;
    LONG    FailedLookups;
    LONG    Compares;

    // Resource used to control table access
    ERESOURCE TableLock;

    // TableEntry for the Null string
    PRX_FCB_TABLE_ENTRY pTableEntryForNull;

    // the hash buckets
    LIST_ENTRY HashBuckets[RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS];
} RX_FCB_TABLE, *PRX_FCB_TABLE;

extern VOID
RxInitializeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN     BOOLEAN       CaseInsensitiveMatch);

extern VOID
RxFinalizeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable);

extern PFCB
RxFcbTableLookupFcb(
    IN  PRX_FCB_TABLE    pFcbTable,
    IN  PUNICODE_STRING  pPath);

extern NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb);

extern NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb);

#define RxAcquireFcbTableLockShared(pFcbTable,Wait) \
        ExAcquireResourceShared(&(pFcbTable)->TableLock,Wait)

#define RxAcquireFcbTableLockExclusive(pFcbTable,Wait) \
        ExAcquireResourceExclusive(&(pFcbTable)->TableLock,Wait)

#define RxReleaseFcbTableLock(pFcbTable)  \
        ExReleaseResource(&(pFcbTable)->TableLock)

#define RxIsFcbTableLockExclusive(PTABLE) ExIsResourceAcquiredExclusive(&(PTABLE)->TableLock)

#define RxIsFcbTableLockAcquired(PTABLE) ( ExIsResourceAcquiredShared(&(PTABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusive(&(PTABLE)->TableLock) )


#endif


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fcb.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Fcb.h

Abstract:

    This module defines File Control Block data structures, by which we mean:

       1) File Control Blocks     (FCB)
       2) File Object Extensions  (FOXB)
       3) Net Roots               (NET_ROOT)
       4) ServerSide Open Context (SRV_OPEN)
       5) Server Call Context     (SRV_CALL)
       6) View of Net Roots       (V_NET_ROOT)

    The more complete description follows the prototypes.

Author:
--*/

#ifndef _FCB_STRUCTS_DEFINED_
#define _FCB_STRUCTS_DEFINED_

#include "fcbtable.h"
#include "buffring.h"

typedef NODE_TYPE_CODE TYPE_OF_OPEN;

struct _FCB_INIT_PACKET;
typedef struct _FCB_INIT_PACKET *PFCB_INIT_PACKET;


/* -----------------------------------------------------------
       There are six important data structures in the wrapper that are shared with the
       various mini redirectors. These data structures come in two flavours -- the
       mini redirector flavour which contains only those fields that can be manipulated
       by the mini redirector and the RDBSS flavour defined here. The mini redirector
       flavour carries the prefix MRX_.

       The six data structures are SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and FOBX
       respectively.

       The global view of these structures is the following (information on each of the
       data structures follows the locking description )

       L O C K I N G  <-------

       There are two levels of lookup tables used: a global table for srvcalls
       and netroots and a table-per-netroot for fcbs.  This allows directory
       operations on different netroots to be almost completely noninterfering
       (once the connections are established).  Directory operations on the
       same netroot do intefere slightly.  The following table describes what
       locks you need:

       OPERATION         DATATYPE              LOCK REQUIRED

       create/finalize   srvcall/(v)netroot    exclusive on netnametablelock
       ref/deref/lookup  srvcall/(v)netroot    shared on netnametablelock (at least)

       create/finalize   fcb/srvopen/fobx      exclusive on netroot->fcbtablelock
       ref/deref/lookup  fcb/srvopen/fobx      shared on netroot->fcbtablelock

       Note that manipulations on srvopens and fobxs require the same lock as
       fcbs....this is simply a memory saving idea.  It would be
       straightforward to add another resource at the fcb level to remove this;
       a set of sharted resources could be used to decrease the probability of
       collision to an acceptably low level.

       R E F   C O U N T S  <---------------

       Each of the structures is reference counted. The counts are the
       following:

       refcount(srvcall) = number of netroots pointing to srvcall + DYNAMIC
       refcount(netroot) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fcb)     = number of fcbs pointing to netroot + DYNAMIC
       refcount(srvopen) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fobx)    = DYNAMIC

       In each case, dynamic refers to the number of callers that have
       referenced the structure without dereferencing it. The static part of
       the refcount is maintained by the routines themselves; for example,
       CreateNetRoot increments the refcount for the associated srvcall.
       Reference and Successful Lookups increment the reference counts;
       dereference decrements the count. Creates set the reference counts to 1,

       If you require both locks (like FinalizeNetFcb), you take the fcblock
       first AND THEN the global table lock. obviously, you release in the
       opposite order.

----------------------------------*/

//
// SRV_CALL
//
// A global list of the SRV_CALL structures is maintained in the global
// data.  Each SrvCall structure has stuff that is unique to a srv_call.
// Now, the rx doesn't know what this stuff is except for
//
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) a list of associated NET_ROOTs
//     c) a set of timing parameters that control how often the subrx wants
//        to be called by the rx in different circumstances (i.e. idle timouts)
//     d) the minirdr id
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// In fact, the Unicode name of the structure is carried in the structure itself
// at the end.  The extra space begins at the end of the known stuff so that a
// mini redirector can just refer to his extra space using the context fields

// These flags are not visible to the mini redirectors.

#define SRVCALL_FLAG_NO_CONNECTION_ALLOWED (0x10000)
#define SRVCALL_FLAG_NO_WRITES_ALLOWED     (0x20000)
#define SRVCALL_FLAG_NO_DELETES_ALLOWED    (0x40000)

#ifdef __cplusplus
typedef struct _SRV_CALL : public MRX_SRV_CALL {
#else //  !__cplusplus
typedef struct _SRV_CALL {

    //
    //  The portion of SRV_CALL visible to mini redirectors.
    //

    union {
        MRX_SRV_CALL;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus

    //
    //  The finalization of a SRV_CALL instance consists of two parts,
    //  destroying the association with all NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //  
    //  Name and Prefixtable entry for name lookups
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  Current condition of the SRV_CALL, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    ULONG SerialNumberForEnum;

    //
    //  Number of delayed close files
    //

    __volatile LONG NumberOfCloseDelayedFiles;

    //
    //  List of Contexts which are waiting for the SRV_CALL transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the SRV_CALL instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened at this server.
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The Buffering manager for coordinating/processing the buffering state
    //  change requests of the files opened at the server.
    //

    RX_BUFFERING_MANAGER BufferingManager;
} SRV_CALL, *PSRV_CALL;

//
//  A NET_ROOT contains
//      0) signature and refcount
//      a) a name and associated table stuff
//      b) backpointer to the SRV_CALL structure
//      c) size information for the various substructures
//      d) a lookuptable of FCB structures
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  A NET_ROOT is what the rx wants to deal with.....not a server.
//  Accordingly, the rx calls down to open a netroot and the subrx is
//  responsible for opening a server and calling up to put the right
//  structures.
//

#define NETROOT_FLAG_ENCLOSED_ALLOCATED       ( 0x00010000 )
#define NETROOT_FLAG_DEVICE_NETROOT           ( 0x00020000 )
#define NETROOT_FLAG_FINALIZATION_IN_PROGRESS ( 0x00040000 )
#define NETROOT_FLAG_NAME_ALREADY_REMOVED     ( 0x00080000 )

#define NETROOT_INIT_KEY (0)

#ifdef __cplusplus
typedef struct _NET_ROOT : public MRX_NET_ROOT {
#else // !__cplusplus
typedef struct _NET_ROOT {

    //
    //  The porion of NET_ROOT instance visible to mini redirectors.
    //

    union {
        MRX_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_CALL SrvCall;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a NET_ROOT instance consists of two parts,
    //  destroying the association with all V_NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  Current condition of the NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened for this NET_ROOt
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The default V_NET_ROOT instance to be used on this NET_ROOT
    //

    PV_NET_ROOT DefaultVNetRoot;

    //
    //  list of V_NET_ROOTs associated with the NET_ROOT
    //

    LIST_ENTRY VirtualNetRoots;

    //
    //  the count of V_NET_ROOT instances associated with the NET_ROOT
    //

    ULONG NumberOfVirtualNetRoots;

    ULONG SerialNumberForEnum;

    //
    //  NET_ROOT name and prefix table entry
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  the FCB's associated with this NET_ROOT
    //

    RX_FCB_TABLE FcbTable;
} NET_ROOT, *PNET_ROOT;

//
//  A V_NETROOT contains
//     0) signature and refcount
//     a) ptr to netroot and links.
//     b) name info for table lookup (prefix)
//     c) name for a prefix to be added to whatever name you see. this is for simulating a netroot
//     mapped not at the root of the actual netroot.
//

#ifdef __cplusplus
typedef struct _V_NET_ROOT : public MRX_V_NET_ROOT {
#else //  !__cplusplus
typedef struct _V_NET_ROOT {

    //
    //  the portion of V_NET_ROOT visible to mini redirectors
    //

    union {
        MRX_V_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a V_NET_ROOT instance consists of two parts,
    //  destroying the association with all FCBs etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    BOOLEAN ConnectionFinalizationDone;

    //
    //  Current condition of the V_NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Additional reference for the Delete FSCTL. This field is long as
    //  opposed to a BOOLEAN eventhough it can have only one of two values
    //  0 or 1. This enables the usage of interlocked instructions
    //

    __volatile LONG AdditionalReferenceForDeleteFsctlTaken;

    //
    //  Prefix table entry and V_NET_ROOT name ( prefix table entry is inserted
    //  in the RxNetNameTable)
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  this name is prepended to all fcbs (not currently used)
    //

    UNICODE_STRING NamePrefix;

    //
    //  amount of bytes required to get past the netroot
    //

    ULONG PrefixOffsetInBytes;

    //
    //  List entry to wire the V_NET_ROOT instance into a list of V_NET_ROOTS
    //  maintained in the NET_ROOT
    //

    LIST_ENTRY NetRootListEntry;

    ULONG SerialNumberForEnum;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the V_NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;
} V_NET_ROOT, *PV_NET_ROOT;

#define FILESIZE_LOCK_DISABLED(x)

//
//  An FCB contains
//      0) FSRTL_COMMON_HEADER
//      1) a reference count
//      a) a name and associated table stuff
//      b) backpointer to the NET_ROOT structure
//      c) a list of SRV_OPEN structures
//      d) device object
//      e) dispatch table (not yet)
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FCB is pointed to by the FsContext Field in the file object.  The
//  rule is that all the guys sharing an FCB are talking about the same
//  file.  (unfortuantely, SMB servers are implemented today in such a way
//  that names are aliased so that two different names could be the same
//  actual file.....sigh!) The Fcb is the focal point of file
//  operations...since operations on the same FCB are actually on the same
//  file, synchronization is based on the Fcb rather than some higher level
//  (the levels described so far are lower, i.e.  farther from the user).
//  Again, we will provide for colocation of FCB/SRV_OPEN/FOBX to improve
//  paging behaviour.  We don't colocate the FCB and NET_ROOT because the
//  NET_ROOTs are not paged but FCBs usually are (i.e.  unless they are
//  paging files).
//
//  The Fcb record corresponds to every open file and directory and is is split up into
//  two portions a non paged part, i.e., an instance allocated in non paged pool and
//  a paged part. The former is the NON_PAGED_FCB and the later is referred to as FCB.
//  The FCB conatins a pointer to the corresponding NON_PAGED_FCB part. A backpointer
//  is maintained from the NON_PAGED_FCB to the FCB for debugging purposes in debug builds
//

typedef struct _NON_PAGED_FCB {

    //
    //  Struct type and size for debugging/tracking
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  This resource is used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE HeaderResource;

    //
    //  This resource is also used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE PagingIoResource;

#ifdef USE_FILESIZE_LOCK

    //
    //  This mutex protect the filesize during read/write
    //

    FAST_MUTEX FileSizeLock;

#endif

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the FCB.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.
    //

    ULONG OutstandingAsyncWrites;

    //
    //  This event is set when OutstandingAsyncWrites transitions to zero.
    //

    PKEVENT OutstandingAsyncEvent;

    KEVENT TheActualEvent;

    //
    //  The mechanism for the mini redirectors to store additional information
    //

    PVOID MiniRdrContext[2];

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

    //
    // This resource is used to protect the buffered locks list
    //
    ERESOURCE BufferedLocksResource;

#if DBG
    PFCB FcbBackPointer;
#endif

} NON_PAGED_FCB, *PNON_PAGED_FCB;

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

//
//  A enumerated type distinguishing the varios contexts under which the FCB resource
//  is accquired.
//

typedef enum _RX_FCBTRACKER_CASES {
    
    RX_FCBTRACKER_CASE_NORMAL,
    RX_FCBTRACKER_CASE_NULLCONTEXT,
    RX_FCBTRACKER_CASE_CBS_CONTEXT,
    RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT,
    RX_FCBTRACKER_CASE_MAXIMUM

} RX_FCBTRACKER_CASES;

typedef struct _FCB_LOCK {

    struct _FCB_LOCK    *Next;
    LARGE_INTEGER       Length;
    LARGE_INTEGER       BytesOffset;
    ULONG               Key;
    BOOLEAN             ExclusiveLock;

} FCB_LOCK, *PFCB_LOCK;

typedef struct _FCB_BUFFERED_LOCKS {

    struct _FCB_LOCK    *List;
    __volatile ULONG               PendingLockOps;
    PERESOURCE          Resource;

} FCB_BUFFERED_LOCKS, *PFCB_BUFFERED_LOCKS;


#ifdef __cplusplus
typedef struct _FCB : public MRX_FCB {
#else //  !__cplusplus
typedef struct _FCB {
    
    //
    //  Entries are reference counted. ordinarily this would be at the beginning but
    //  in the case of FCB's it will follows the common header and fixed part
    //

    union {
        MRX_FCB;
        struct {
           FSRTL_ADVANCED_FCB_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  !__cplusplus

    //
    //  VNetroot for this FCB, if any
    //

    PV_NET_ROOT VNetRoot;  

    //
    //  Structure for fields that must be in non-paged pool.
    //

    PNON_PAGED_FCB NonPaged;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The resource accquisition mechanism gives preference to buffering state change
    //  processing over other requests. Therefor when a buffering state change is
    //  indicated all subsequent requests are shunted off to wait on a buffering state
    //  change completion event. This enables the actual buffering state change processing
    //  to complete in a timely fashion.
    //

    PKEVENT pBufferingStateChangeCompletedEvent;

    //
    //  Number of contexts awaiting buffering state change processing completion
    //

    LONG NumberOfBufferingStateChangeWaiters;

    //
    //  the name in the table is always a suffix of the name as viewed by the mini
    //  redirector. the string in the prefix entry is the name in the table....
    //  the "alreadyprefixedname: points to the whole name.
    //

    RX_FCB_TABLE_ENTRY FcbTableEntry;

    //
    //  the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name
    //

    UNICODE_STRING PrivateAlreadyPrefixedName;

    //
    //  Indicates that the V_NET_ROOT related processing on finalization is complete
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  the present state of the FCB, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Pointer to the private dispatch table, if any.
    //

    PRX_FSD_DISPATCH_VECTOR PrivateDispatchVector;

    //
    //  the device object that owns this fcb
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PMINIRDR_DISPATCH MRxDispatch;

    //
    //  private fast dispatch table, if any. This allows lwio to add it's own hooks
    //

    PFAST_IO_DISPATCH MRxFastIoDispatch;

    //
    //  Whenever a  FCB instance is created a correpsonding SRV_OPEN and FOBX instance
    //  is also created. More than one SRV_OPEN can be associated with a given FCB and
    //  more than one FOBX is associated with a given SRV_OPEN. In a majority of the
    //  cases the number of SRV_OPENs associated with an FCB is one and the number of
    //  FOBX associated with a given SRV_OPEN is 1. In order to improve the spatial
    //  locality and the paging behaviour in such cases the allocation for the
    //  FCB also involves an allocation for the SRV_OPEN and FOBX.
    //

    //
    //  set initially to the internally allocated srv_open
    //

    PSRV_OPEN InternalSrvOpen;

    //
    //  set to internal fobx until allocated
    //

    PFOBX InternalFobx;

    //
    //  the shared access for each time this file/directory is opened.
    //

    SHARE_ACCESS ShareAccess;
    SHARE_ACCESS ShareAccessPerSrvOpens;

    //
    //  this information is returned when the file is opened. ..might as well
    //  cache it so that so that tandard info query can be handled on the client
    //  side
    //

    ULONG NumberOfLinks;

    //
    //  Cache these entries..... speeds up RxFastQueryBasicInfo().
    //

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastChangeTime;

    //
    //  used to check by mini redirs in order to decide whether to update the FCB
    //

    ULONG ulFileSizeVersion;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    FILE_LOCK FileLock;

    //
    //  do this wierdly so that I can call stuff be the inner or outer names
    //

    union {
#ifndef __cplusplus
        LOWIO_PER_FCB_INFO;
#endif // __cplusplus
        LOWIO_PER_FCB_INFO LowIoPerFcbInfo;
    };

#ifdef USE_FILESIZE_LOCK
    PFAST_MUTEX FileSizeLock;
#endif

    //
    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Fobx.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.
    //

    ULONG EaModificationCount;

    FCB_BUFFERED_LOCKS  BufferedLocks;

#if DBG
    PNON_PAGED_FCB CopyOfNonPaged;     //  copy of NonPaged so we can zap the real pointer and still find it
#endif
#ifdef RDBSS_TRACKER
    ULONG FcbAcquires[RX_FCBTRACKER_CASE_MAXIMUM]; //  there are four types
    ULONG FcbReleases[RX_FCBTRACKER_CASE_MAXIMUM];
#else
#error tracker must be defined
#endif

    PCHAR PagingIoResourceFile;
    ULONG PagingIoResourceLine;

} FCB, *PFCB;

//
//  Here are the Fcb state fields.
//

#define FCB_STATE_SRVOPEN_USED                   ( 0x80000000 )
#define FCB_STATE_FOBX_USED                      ( 0x40000000 )
#define FCB_STATE_ADDEDBACKSLASH                 ( 0x20000000 )
#define FCB_STATE_NAME_ALREADY_REMOVED           ( 0x10000000 )
#define FCB_STATE_WRITECACHING_ENABLED           ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHING_ENABLED            ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )
#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )
#define FCB_STATE_SPECIAL_PATH                   ( 0x00020000 )
#define FCB_STATE_FILE_IS_SHADOWED               ( 0x00010000 )
#define FCB_STATE_FILE_IS_DISK_COMPRESSED        ( 0x00008000 )
#define FCB_STATE_FILE_IS_BUF_COMPRESSED         ( 0x00004000 )
#define FCB_STATE_BUFFERSTATE_CHANGING           ( 0x00002000 )
#define FCB_STATE_FAKEFCB                        ( 0x00001000 )
#define FCB_STATE_DELAY_CLOSE                    ( 0x00000800 )
#define FCB_STATE_READAHEAD_DEFERRED             ( 0x00000100 )
#define FCB_STATE_ORPHANED                       ( 0x00000080 )
#define FCB_STATE_BUFFERING_STATE_CHANGE_PENDING ( 0x00000040 )
#define FCB_STATE_TEMPORARY                      ( 0x00000020 )
#define FCB_STATE_DISABLE_LOCAL_BUFFERING        ( 0x00000010 )
#define FCB_STATE_LWIO_ENABLED                   ( 0x00000008 )
#define FCB_STATE_PAGING_FILE                    ( 0x00000004 )
#define FCB_STATE_TRUNCATE_ON_CLOSE              ( 0x00000002 )
#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

#define FCB_STATE_BUFFERING_STATE_MASK    \
                    (( FCB_STATE_WRITECACHING_ENABLED           \
                          | FCB_STATE_WRITEBUFFERING_ENABLED    \
                          | FCB_STATE_READCACHING_ENABLED       \
                          | FCB_STATE_READBUFFERING_ENABLED     \
                          | FCB_STATE_OPENSHARING_ENABLED       \
                          | FCB_STATE_COLLAPSING_ENABLED        \
                          | FCB_STATE_LOCK_BUFFERING_ENABLED    \
                          | FCB_STATE_FILESIZECACHEING_ENABLED  \
                          | FCB_STATE_FILETIMECACHEING_ENABLED  ))
//
//  This is the MAX recursive resource limit.
//

#define MAX_FCB_ASYNC_ACQUIRE            (0xf000)

typedef struct _FCB_INIT_PACKET {
    PULONG pAttributes;             //  in the fcb this is DirentRxFlags;
    PULONG pNumLinks;               //  in the fcb this is NumberOfLinks;
    PLARGE_INTEGER pCreationTime;   //  these fields are the same as for the Fcb
    PLARGE_INTEGER pLastAccessTime;
    PLARGE_INTEGER pLastWriteTime;
    PLARGE_INTEGER pLastChangeTime;
    PLARGE_INTEGER pAllocationSize; //  common header fields
    PLARGE_INTEGER pFileSize;
    PLARGE_INTEGER pValidDataLength;
} FCB_INIT_PACKET;

//
//  A SRV_OPEN contains
//      0) signature and refcount
//      a) backpointer to the FCB
//      b) backpointer to the NET_ROOT   //maybe
//      c) a list of FOXB structures
//      d) access rights and collapsability status
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The SRV_OPEN points to a structure describing a spevific open on the
//  server; multiple file objects and fileobject extensions (FOBXs) can
//  share the same srvopen if the access rights are correct.  For example,
//  this would be where the FID is stored for SMBs.  A list of these hangs
//  from the FCB.  Similarly, all fileobject extensionss that share the same
//  serverside open are listed together here.  Also here is information
//  about whether a new open of this FCB can share this serverside open
//  context; obviously the guys that pass the test on the list.
//

//
//  The SRVOPEN flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define SRVOPEN_FLAG_ENCLOSED_ALLOCATED  (0x10000)
#define SRVOPEN_FLAG_FOBX_USED           (0x20000)
#define SRVOPEN_FLAG_SHAREACCESS_UPDATED (0x40000)

#ifdef __cplusplus
typedef struct _SRV_OPEN : public MRX_SRV_OPEN {
#else //  !__cplusplus
typedef struct _SRV_OPEN {

    //
    //  the portion of SRV_OPEN visible to all the mini redirectors.
    //

    union {
        MRX_SRV_OPEN;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;

           //
           //  the Fcb and VNetRoot for this srv_open
           //

           PFCB Fcb;       
           PV_NET_ROOT VNetRoot;
        };
    };
#endif //  !__cplusplus

    BOOLEAN UpperFinalizationDone;

    //
    //  the current condition of the SRV_OPEN, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Buffering state manager token
    //

    __volatile LONG BufferingToken;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the SRV_OPEN.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Head for the list of FOBXs associated with this SRV_OPEN
    //

    LIST_ENTRY FobxList;

    //
    //  The colocated instance of FOBX that is allocated whenever a SRV_OPEN
    //  instance is allocated.
    //

    PFOBX InternalFobx;

    //
    //  the data structure for maintaining the mapping between the key
    //  associated with the SRV_OPEN instance by the mini redirector and
    //  the SRV_OPEN instance
    //

    union {
       LIST_ENTRY SrvOpenKeyList;
       ULONG SequenceNumber;
    };
    NTSTATUS OpenStatus;
} SRV_OPEN, *PSRV_OPEN;

#define RxWriteCachingAllowed(FCB,SRVOPEN) \
      (FlagOn( (FCB)->FcbState, FCB_STATE_WRITECACHING_ENABLED ) && \
       !FlagOn( (SRVOPEN)->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHING ))

#define SRVOPEN_INIT_KEY (0)

//
//  A FOBX contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the SRV_OPEN
//     c) context information about this open
//     ...
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FOBX points to the "fileobject extension", i.e.  all the stuff that
//  is per fileobject is not stored there because the IO system provides
//  fixed size filesystem objects (not a dig BTW, that's just the decision).
//  The FOBX for any file object is referenced by the FsContext2 field in
//  the fileobject.  Even tho the FOBX is ordinarily a terminus in the
//  structure, it is currently refcounted anyway.

//  The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define FOBX_FLAG_MATCH_ALL               (0x10000)

//
//  This tells us whether we allocated buffers to hold search templates.
//

#define FOBX_FLAG_FREE_UNICODE            (0x20000)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define FOBX_FLAG_USER_SET_LAST_WRITE     (0x40000)
#define FOBX_FLAG_USER_SET_LAST_ACCESS    (0x80000)
#define FOBX_FLAG_USER_SET_CREATION       (0x100000)
#define FOBX_FLAG_USER_SET_LAST_CHANGE    (0x200000)

//
//  This bit says the file object associated with this Fobx was opened for
//  read only access.
//

#define FOBX_FLAG_READ_ONLY               (0x400000)

//
//  the delete on close flag is used to track a file object that was opened with delete-on-close;
//  when this object is closed, we copy the bit to the fcb and make it global
//

#define FOBX_FLAG_DELETE_ON_CLOSE         (0x800000)

//
//  this bits is used by minirdrs that do not have NT semantics. for example, the smbmini has
//  to close a file before it can try a rename or delete. after the operation, we prevent people from
//  getting back in.
//

#define FOBX_FLAG_SRVOPEN_CLOSED          (0x1000000)

//
//  this bit is used to tell whether the original name was a UNC name so that
//  we can return the name the same way
//

#define FOBX_FLAG_UNC_NAME                (0x2000000)

//
//  this flag tells if this fobx is allocated as part of a larger structure
//

#define FOBX_FLAG_ENCLOSED_ALLOCATED      (0x4000000)

//
//  this flag specfies if the FOBX was included in the count of dormant
//  files against the server.
//

#define FOBX_FLAG_MARKED_AS_DORMANT       (0x8000000)

//
//  this flag notes down the fact that some writes have been issued on this FOBX
//  this is used to issue flushes on close
//

#define FOBX_FLAG_WRITES_ISSUED           (0x10000000)

#ifdef __cplusplus
typedef struct _FOBX : public MRX_FOBX {
#else //  !__cplusplus
typedef struct _FOBX {
    //
    //  the portion of FOBX visible to the mini redirectors
    //

    union {
        MRX_FOBX;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_OPEN SrvOpen;
        };
    };
#endif //  __cplusplus

    //
    //  a serial number....it wraps but not often
    //

    __volatile ULONG FobxSerialNumber;

    //
    //  list entry to wire the FOBX to the list of FOBXs maintained in
    //  the associated SRV_OPEN
    //

    LIST_ENTRY FobxQLinks;

    //
    //  list entry to gather all the FOBX instance marked for garbage collection
    //  scavenging
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  list entry to thread together all the FOBXs which have a pending close
    //  operation.
    //

    LIST_ENTRY ClosePendingList;

    LARGE_INTEGER CloseTime;

    BOOLEAN UpperFinalizationDone;
    BOOLEAN ContainsWildCards;
    BOOLEAN fOpenCountDecremented;

    //
    //  Parameters depending on the type of file opened, pipe/file etc.
    //

    union {

        struct {

            union {
#ifndef __cplusplus
                MRX_PIPE_HANDLE_INFORMATION;
#endif //  __cplusplus
                MRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;
            };

            LARGE_INTEGER CollectDataTime;
            ULONG CollectDataSize;
            THROTTLING_STATE ThrottlingState;   //  for peek and read om msgmodepipes

            //
            //  these serialization Qs must be together
            //  and read must be the first
            //

            LIST_ENTRY ReadSerializationQueue;
            LIST_ENTRY WriteSerializationQueue;
        } NamedPipe;

        struct {
            RXVBO PredictedReadOffset;
            RXVBO PredictedWriteOffset;
            THROTTLING_STATE LockThrottlingState;   //  for locks
            LARGE_INTEGER LastLockOffset;
            LARGE_INTEGER LastLockRange;
        } DiskFile;
    } Specific;

    //
    // Only required for finalization.
    // We do not take a reference on the RxDeviceObject when copied from the FCB,
    // as the FCB holds a reference, and FCB finalization will happen only after
    // FOBX finalization.
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

} FOBX, *PFOBX;


#define FOBX_NUMBER_OF_SERIALIZATION_QUEUES 2

//
//  The RDBSS wrapper relies upon ref. counting to mark the instances of
//  various data structures. The following macros implement a debugging
//  mechanism to track/log the reference counts associated with various
//  data structures. A fine grained control to monitor each data structure
//  separately is provided. Each of these can be further controlled to either
//  print the tracking info or log it.
//

#define RDBSS_REF_TRACK_SRVCALL  (0x00000001)
#define RDBSS_REF_TRACK_NETROOT  (0x00000002)
#define RDBSS_REF_TRACK_VNETROOT (0x00000004)
#define RDBSS_REF_TRACK_NETFOBX  (0x00000008)
#define RDBSS_REF_TRACK_NETFCB   (0x00000010)
#define RDBSS_REF_TRACK_SRVOPEN  (0x00000020)

#define RX_LOG_REF_TRACKING      (0x80000000)
#define RX_PRINT_REF_TRACKING    (0x40000000)

//
//  The reference count tracking mechanism is activated by setting the following
//  variable to the appropriate value defined above.
//

extern ULONG RdbssReferenceTracingValue;

//
//  Macros for tracking the line number and the file of each reference and
//  derefernce on the data structure. on Non DBG builds they are defined as
//  NOTHING. For each data structure the appropriate reference/dereference
//  macro is defined, These should be used instead of raw manipulation of
//  the reference counts.
//

VOID
RxpTrackReference (
    __in ULONG TraceType,
    __in PCSTR FileName,
    __in ULONG Line,
    __in PVOID Instance
    );

BOOLEAN
RxpTrackDereference (
    __in ULONG TraceType,
    __in PCSTR FileName,
    __in ULONG Line,
    __in PVOID Instance
    );

#define REF_TRACING_ON(TraceMask)  (TraceMask & RdbssReferenceTracingValue)
#define PRINT_REF_COUNT(TYPE,Count)                                 \
        if (REF_TRACING_ON( RDBSS_REF_TRACK_ ## TYPE ) &&           \
            (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING)) { \
           DbgPrint("%ld\n",Count);                                 \
        }

#define RxReferenceSrvCallAtDpc(SrvCall)                                      \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   ASSERT( SrvCall->NodeReferenceCount > 1 );                                 \
   InterlockedIncrement( &SrvCall->NodeReferenceCount )

#define RxReferenceSrvCall(SrvCall)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxReference( SrvCall )

#define RxDereferenceSrvCall(SrvCall,LockHoldingState)                          \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxDereference(SrvCall, LockHoldingState )

#define RxReferenceNetRoot(NetRoot)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot ); \
   RxReference( NetRoot )

#define RxDereferenceNetRoot( NetRoot, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot );\
   RxDereference( NetRoot, LockHoldingState )

#define RxReferenceVNetRoot(VNetRoot)                                        \
   RxpTrackReference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot );\
   RxReference( VNetRoot )

#define RxDereferenceVNetRoot( VNetRoot, LockHoldingState )                       \
   RxpTrackDereference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot ); \
   RxDereference( VNetRoot, LockHoldingState )

#define RxReferenceNetFobx(Fobx)                                          \
   RxpTrackReference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );      \
   RxReference( Fobx )

#define RxDereferenceNetFobx(Fobx,LockHoldingState)                       \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );    \
   RxDereference( Fobx, LockHoldingState )

#define RxReferenceSrvOpen(SrvOpen)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen ); \
   RxReference( SrvOpen )

#define RxDereferenceSrvOpen( SrvOpen, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen); \
   RxDereference( SrvOpen, LockHoldingState )

#define RxReferenceNetFcb(Fcb)                                            \
  (RxpTrackReference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),  \
   RxpReferenceNetFcb( Fcb ))

//
//  the following macros manipulate the reference count and also return the
//  status of the final derefence or finalize call. This results in the usage
//  of the , operator.
//           

#define RxDereferenceNetFcb(Fcb)  ( \
   ((LONG)RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb )), \
   RxpDereferenceNetFcb( Fcb ))

#define RxDereferenceAndFinalizeNetFcb(Fcb,RxContext,RecursiveFinalize,ForceFinalize) ( \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),              \
   RxpDereferenceAndFinalizeNetFcb( Fcb, RxContext, RecursiveFinalize, ForceFinalize )) \

//
//  Check for structure alignment errors
//            

VOID
RxCheckFcbStructuresForAlignment(
    VOID
    );


//
//  SRV_CALL related routines.
//

PSRV_CALL
RxCreateSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING InnerNamePrefix OPTIONAL,
    IN PRX_CONNECTION_ID RxConnectionId
    );


#define RxWaitForStableSrvCall(SRVCALL,RXCONTEXT) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), NULL); \
    }

#define RxWaitForStableSrvCall_Async(SRVCALL,RXCONTEXT,PNTSTATUS) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), (PNTSTATUS) ); \
    }

#define RxTransitionSrvCall(SRVCALL,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvCall -- %lx Condition -- %ld\n",(SRVCALL),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList )

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN BOOLEAN ForceFinalize
    );

//
// NET_ROOT related routines.
//

PNET_ROOT
RxCreateNetRoot (
    IN PSRV_CALL SrvCall,
    IN PUNICODE_STRING Name,
    IN ULONG NetRootFlags,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxFinishNetRootInitialization (
    IN OUT PNET_ROOT ThisNetRoot,
    IN PMINIRDR_DISPATCH Dispatch,
    IN PUNICODE_STRING  InnerNamePrefix,
    IN ULONG FcbSize,
    IN ULONG SrvOpenSize,
    IN ULONG FobxSize,
    IN ULONG NetRootFlags
    );


#define RxWaitForStableNetRoot(NETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetRoot -- %lx\n",(NETROOT)));    \
    RxWaitForStableCondition(&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetRoot(NETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetRoot -- %lx Condition -- %ld\n",(NETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList)

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// V_NET_ROOT related routines
//

NTSTATUS
RxInitializeVNetRootParameters (
   PRX_CONTEXT RxContext,
   OUT LUID *LogonId,
   OUT PULONG SessionId,
   OUT PUNICODE_STRING *UserNamePtr,
   OUT PUNICODE_STRING *UserDomainNamePtr,
   OUT PUNICODE_STRING *PasswordPtr,
   OUT PULONG Flags
   );

VOID
RxUninitializeVNetRootParameters (
   IN PUNICODE_STRING UserName,
   IN PUNICODE_STRING UserDomainName,
   IN PUNICODE_STRING Password,
   OUT PULONG Flags
   );

PV_NET_ROOT
RxCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PNET_ROOT NetRoot,
    IN PUNICODE_STRING CanonicalName,
    IN PUNICODE_STRING LocalNetRootName,
    IN PUNICODE_STRING FilePath,
    IN PRX_CONNECTION_ID RxConnectionId
    );

BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#define RxWaitForStableVNetRoot(VNETROOT,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableVNetRoot -- %lx\n",(VNETROOT)) );    \
    RxWaitForStableCondition( &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionVNetRoot(VNETROOT,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionVNetRoot -- %lx Condition -- %ld\n", (VNETROOT), (CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList )

#ifdef USE_FILESIZE_LOCK

//
//  FCB related routines.
//

#define RxAcquireFileSizeLock(PFCB) { \
    ExAcquireFastMutex( (PFCB)->Specific.Fcb.FileSizeLock ); \
}
#define RxReleaseFileSizeLock(PFCB) { \
    ExReleaseFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}

#endif

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN PLONGLONG FileSize
    );

VOID
RxGetFileSizeWithLock (
    IN PFCB Fcb,
    OUT PLONGLONG FileSize
    );

PFCB
RxCreateNetFcb (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PV_NET_ROOT VNetRoot,
    IN PUNICODE_STRING Name
    );

#define RxWaitForStableNetFcb(FCB,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(FCB)));    \
    RxWaitForStableCondition( &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionNetFcb(FCB,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionNetFcb -- %lx Condition -- %ld\n",(FCB),(CONDITION))); \
    RxUpdateCondition( (CONDITION), &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList )


#define RxFormInitPacket(IP,I1,I1a,I2,I3,I4a,I4b,I5,I6,I7) (\
            IP.pAttributes = I1, \
            IP.pNumLinks = I1a, \
            IP.pCreationTime = I2, \
            IP.pLastAccessTime = I3, \
            IP.pLastWriteTime = I4a, \
            IP.pLastChangeTime = I4b, \
            IP.pAllocationSize = I5, \
            IP.pFileSize = I6, \
            IP.pValidDataLength = I7, \
          &IP)

#if DBG
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb) {\
    ASSERT( ___thisfcb->NonPaged == ___thisfcb->CopyOfNonPaged );       \
    ASSERT( ___thisfcb->NonPaged->FcbBackPointer == ___thisfcb );       \
    }
#else
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb)
#endif

#define ASSERT_CORRECT_FCB_STRUCTURE(THIS_FCB__) { \
    ASSERT( NodeTypeIsFcb(THIS_FCB__));                                 \
    ASSERT( THIS_FCB__->NonPaged != NULL );                             \
    ASSERT( NodeType(THIS_FCB__->NonPaged) == RDBSS_NTC_NONPAGED_FCB);  \
    ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(THIS_FCB__) \
    }

RX_FILE_TYPE
RxInferFileType (
    IN PRX_CONTEXT RxContext
    );

VOID
RxFinishFcbInitialization (
    IN OUT PMRX_FCB Fcb,
    IN RX_FILE_TYPE FileType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    );

#define RxWaitForStableSrvOpen(SRVOPEN,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableFcb -- %lx\n",(SRVOPEN)) );    \
    RxWaitForStableCondition( &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionSrvOpen(SRVOPEN,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvOpen -- %lx Condition -- %ld\n",(SRVOPEN),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList )

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    );

LONG
RxpReferenceNetFcb (
   PFCB Fcb
   );

LONG
RxpDereferenceNetFcb (
   PFCB Fcb
   );

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if DBG
extern BOOLEAN RxLoudFcbOpsOnExes;
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING Name
    );
#else
#define RxLoudFcbMsg(a,b) (FALSE)
#endif


//
//  SRV_OPEN related methods
//

PSRV_OPEN
RxCreateSrvOpen (
    IN PV_NET_ROOT VNetRoot,
    IN OUT PFCB Fcb
    );

VOID
RxTransitionSrvOpenState (
    OUT PSRV_OPEN ThisSrvOpen,
    IN RX_BLOCK_CONDITION Condition
    );

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if 0
#else
INLINE 
PUNICODE_STRING
GET_ALREADY_PREFIXED_NAME (
    PMRX_SRV_OPEN SrvOpen,
    PMRX_FCB Fcb)
{
    PFCB ThisFcb = (PFCB)Fcb;

#if DBG
    if (SrvOpen != NULL ) {
        ASSERT( NodeType( SrvOpen ) == RDBSS_NTC_SRVOPEN );
        ASSERT( ThisFcb != NULL );
        ASSERT( NodeTypeIsFcb( Fcb) );
        ASSERT( SrvOpen->pFcb == Fcb );
        ASSERT( SrvOpen->pAlreadyPrefixedName == &ThisFcb->PrivateAlreadyPrefixedName );
    }
#endif

    return( &ThisFcb->PrivateAlreadyPrefixedName);
}
#endif

#define GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(Rxcontext) \
        (GET_ALREADY_PREFIXED_NAME( (Rxcontext)->pRelevantSrvOpen, (Rxcontext)->pFcb ))

//
//  FOBX related routines
//

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT RxContext,
    IN PMRX_SRV_OPEN MrxSrvOpen
    );

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#endif // _FCB_STRUCTS_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Fcb.h

Abstract:

    This module defines File Control Block data structures, by which we mean:

       1) File Control Blocks     (FCB)
       2) File Object Extensions  (FOXB)
       3) Net Roots               (NET_ROOT)
       4) ServerSide Open Context (SRV_OPEN)
       5) Server Call Context     (SRV_CALL)
       6) View of Net Roots       (V_NET_ROOT)

    The more complete description follows the prototypes.

Author:
--*/

#ifndef _FCB_STRUCTS_DEFINED_
#define _FCB_STRUCTS_DEFINED_

#include "fcbtable.h"
#include "buffring.h"

typedef NODE_TYPE_CODE TYPE_OF_OPEN;

struct _FCB_INIT_PACKET;
typedef struct _FCB_INIT_PACKET *PFCB_INIT_PACKET;


/* -----------------------------------------------------------
       There are six important data structures in the wrapper that are shared with the
       various mini redirectors. These data structures come in two flavours -- the
       mini redirector flavour which contains only those fields that can be manipulated
       by the mini redirector and the RDBSS flavour defined here. The mini redirector
       flavour carries the prefix MRX_.

       The six data structures are SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and FOBX
       respectively.

       The global view of these structures is the following (information on each of the
       data structures follows the locking description )

       L O C K I N G  <-------

       There are two levels of lookup tables used: a global table for srvcalls
       and netroots and a table-per-netroot for fcbs.  This allows directory
       operations on different netroots to be almost completely noninterfering
       (once the connections are established).  Directory operations on the
       same netroot do intefere slightly.  The following table describes what
       locks you need:

       OPERATION         DATATYPE              LOCK REQUIRED

       create/finalize   srvcall/(v)netroot    exclusive on netnametablelock
       ref/deref/lookup  srvcall/(v)netroot    shared on netnametablelock (at least)

       create/finalize   fcb/srvopen/fobx      exclusive on netroot->fcbtablelock
       ref/deref/lookup  fcb/srvopen/fobx      shared on netroot->fcbtablelock

       Note that manipulations on srvopens and fobxs require the same lock as
       fcbs....this is simply a memory saving idea.  It would be
       straightforward to add another resource at the fcb level to remove this;
       a set of sharted resources could be used to decrease the probability of
       collision to an acceptably low level.

       R E F   C O U N T S  <---------------

       Each of the structures is reference counted. The counts are the
       following:

       refcount(srvcall) = number of netroots pointing to srvcall + DYNAMIC
       refcount(netroot) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fcb)     = number of fcbs pointing to netroot + DYNAMIC
       refcount(srvopen) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fobx)    = DYNAMIC

       In each case, dynamic refers to the number of callers that have
       referenced the structure without dereferencing it. The static part of
       the refcount is maintained by the routines themselves; for example,
       CreateNetRoot increments the refcount for the associated srvcall.
       Reference and Successful Lookups increment the reference counts;
       dereference decrements the count. Creates set the reference counts to 1,

       If you require both locks (like FinalizeNetFcb), you take the fcblock
       first AND THEN the global table lock. obviously, you release in the
       opposite order.

----------------------------------*/

//
// SRV_CALL
//
// A global list of the SRV_CALL structures is maintained in the global
// data.  Each SrvCall structure has stuff that is unique to a srv_call.
// Now, the rx doesn't know what this stuff is except for
//
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) a list of associated NET_ROOTs
//     c) a set of timing parameters that control how often the subrx wants
//        to be called by the rx in different circumstances (i.e. idle timouts)
//     d) the minirdr id
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// In fact, the Unicode name of the structure is carried in the structure itself
// at the end.  The extra space begins at the end of the known stuff so that a
// mini redirector can just refer to his extra space using the context fields

// These flags are not visible to the mini redirectors.

#define SRVCALL_FLAG_NO_CONNECTION_ALLOWED (0x10000)
#define SRVCALL_FLAG_NO_WRITES_ALLOWED     (0x20000)
#define SRVCALL_FLAG_NO_DELETES_ALLOWED    (0x40000)

#ifdef __cplusplus
typedef struct _SRV_CALL : public MRX_SRV_CALL {
#else //  !__cplusplus
typedef struct _SRV_CALL {

    //
    //  The portion of SRV_CALL visible to mini redirectors.
    //

    union {
        MRX_SRV_CALL;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus

    //
    //  The finalization of a SRV_CALL instance consists of two parts,
    //  destroying the association with all NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //  
    //  Name and Prefixtable entry for name lookups
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  Current condition of the SRV_CALL, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    ULONG SerialNumberForEnum;

    //
    //  Number of delayed close files
    //

    LONG NumberOfCloseDelayedFiles;

    //
    //  List of Contexts which are waiting for the SRV_CALL transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the SRV_CALL instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened at this server.
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The Buffering manager for coordinating/processing the buffering state
    //  change requests of the files opened at the server.
    //

    RX_BUFFERING_MANAGER BufferingManager;
} SRV_CALL, *PSRV_CALL;

//
//  A NET_ROOT contains
//      0) signature and refcount
//      a) a name and associated table stuff
//      b) backpointer to the SRV_CALL structure
//      c) size information for the various substructures
//      d) a lookuptable of FCB structures
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  A NET_ROOT is what the rx wants to deal with.....not a server.
//  Accordingly, the rx calls down to open a netroot and the subrx is
//  responsible for opening a server and calling up to put the right
//  structures.
//

#define NETROOT_FLAG_ENCLOSED_ALLOCATED       ( 0x00010000 )
#define NETROOT_FLAG_DEVICE_NETROOT           ( 0x00020000 )
#define NETROOT_FLAG_FINALIZATION_IN_PROGRESS ( 0x00040000 )
#define NETROOT_FLAG_NAME_ALREADY_REMOVED     ( 0x00080000 )

#define NETROOT_INIT_KEY (0)

#ifdef __cplusplus
typedef struct _NET_ROOT : public MRX_NET_ROOT {
#else // !__cplusplus
typedef struct _NET_ROOT {

    //
    //  The porion of NET_ROOT instance visible to mini redirectors.
    //

    union {
        MRX_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_CALL SrvCall;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a NET_ROOT instance consists of two parts,
    //  destroying the association with all V_NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  Current condition of the NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened for this NET_ROOt
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The default V_NET_ROOT instance to be used on this NET_ROOT
    //

    PV_NET_ROOT DefaultVNetRoot;

    //
    //  list of V_NET_ROOTs associated with the NET_ROOT
    //

    LIST_ENTRY VirtualNetRoots;

    //
    //  the count of V_NET_ROOT instances associated with the NET_ROOT
    //

    ULONG NumberOfVirtualNetRoots;

    ULONG SerialNumberForEnum;

    //
    //  NET_ROOT name and prefix table entry
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  the FCB's associated with this NET_ROOT
    //

    RX_FCB_TABLE FcbTable;
} NET_ROOT, *PNET_ROOT;

//
//  A V_NETROOT contains
//     0) signature and refcount
//     a) ptr to netroot and links.
//     b) name info for table lookup (prefix)
//     c) name for a prefix to be added to whatever name you see. this is for simulating a netroot
//     mapped not at the root of the actual netroot.
//

#ifdef __cplusplus
typedef struct _V_NET_ROOT : public MRX_V_NET_ROOT {
#else //  !__cplusplus
typedef struct _V_NET_ROOT {

    //
    //  the portion of V_NET_ROOT visible to mini redirectors
    //

    union {
        MRX_V_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a V_NET_ROOT instance consists of two parts,
    //  destroying the association with all FCBs etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    BOOLEAN ConnectionFinalizationDone;

    //
    //  Current condition of the V_NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Additional reference for the Delete FSCTL. This field is long as
    //  opposed to a BOOLEAN eventhough it can have only one of two values
    //  0 or 1. This enables the usage of interlocked instructions
    //

    LONG AdditionalReferenceForDeleteFsctlTaken;

    //
    //  Prefix table entry and V_NET_ROOT name ( prefix table entry is inserted
    //  in the RxNetNameTable)
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  this name is prepended to all fcbs (not currently used)
    //

    UNICODE_STRING NamePrefix;

    //
    //  amount of bytes required to get past the netroot
    //

    ULONG PrefixOffsetInBytes;

    //
    //  List entry to wire the V_NET_ROOT instance into a list of V_NET_ROOTS
    //  maintained in the NET_ROOT
    //

    LIST_ENTRY NetRootListEntry;

    ULONG SerialNumberForEnum;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the V_NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;
} V_NET_ROOT, *PV_NET_ROOT;

#define FILESIZE_LOCK_DISABLED(x)

//
//  An FCB contains
//      0) FSRTL_COMMON_HEADER
//      1) a reference count
//      a) a name and associated table stuff
//      b) backpointer to the NET_ROOT structure
//      c) a list of SRV_OPEN structures
//      d) device object
//      e) dispatch table (not yet)
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FCB is pointed to by the FsContext Field in the file object.  The
//  rule is that all the guys sharing an FCB are talking about the same
//  file.  (unfortuantely, SMB servers are implemented today in such a way
//  that names are aliased so that two different names could be the same
//  actual file.....sigh!) The Fcb is the focal point of file
//  operations...since operations on the same FCB are actually on the same
//  file, synchronization is based on the Fcb rather than some higher level
//  (the levels described so far are lower, i.e.  farther from the user).
//  Again, we will provide for colocation of FCB/SRV_OPEN/FOBX to improve
//  paging behaviour.  We don't colocate the FCB and NET_ROOT because the
//  NET_ROOTs are not paged but FCBs usually are (i.e.  unless they are
//  paging files).
//
//  The Fcb record corresponds to every open file and directory and is is split up into
//  two portions a non paged part, i.e., an instance allocated in non paged pool and
//  a paged part. The former is the NON_PAGED_FCB and the later is referred to as FCB.
//  The FCB conatins a pointer to the corresponding NON_PAGED_FCB part. A backpointer
//  is maintained from the NON_PAGED_FCB to the FCB for debugging purposes in debug builds
//

typedef struct _NON_PAGED_FCB {

    //
    //  Struct type and size for debugging/tracking
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  This resource is used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE HeaderResource;

    //
    //  This resource is also used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE PagingIoResource;

#ifdef USE_FILESIZE_LOCK

    //
    //  This mutex protect the filesize during read/write
    //

    FAST_MUTEX FileSizeLock;

#endif

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the FCB.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.
    //

    ULONG OutstandingAsyncWrites;

    //
    //  This event is set when OutstandingAsyncWrites transitions to zero.
    //

    PKEVENT OutstandingAsyncEvent;

    KEVENT TheActualEvent;

    //
    //  The mechanism for the mini redirectors to store additional information
    //

    PVOID MiniRdrContext[2];

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

    //
    // This resource is used to protect the buffered locks list
    //
    ERESOURCE BufferedLocksResource;

#if DBG
    PFCB FcbBackPointer;
#endif

} NON_PAGED_FCB, *PNON_PAGED_FCB;

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

//
//  A enumerated type distinguishing the varios contexts under which the FCB resource
//  is accquired.
//

typedef enum _RX_FCBTRACKER_CASES {
    
    RX_FCBTRACKER_CASE_NORMAL,
    RX_FCBTRACKER_CASE_NULLCONTEXT,
    RX_FCBTRACKER_CASE_CBS_CONTEXT,
    RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT,
    RX_FCBTRACKER_CASE_MAXIMUM

} RX_FCBTRACKER_CASES;

typedef struct _FCB_LOCK {

    struct _FCB_LOCK    *Next;
    LARGE_INTEGER       Length;
    LARGE_INTEGER       BytesOffset;
    ULONG               Key;
    BOOLEAN             ExclusiveLock;

} FCB_LOCK, *PFCB_LOCK;

typedef struct _FCB_BUFFERED_LOCKS {

    struct _FCB_LOCK    *List;
    ULONG               PendingLockOps;
    PERESOURCE          Resource;

} FCB_BUFFERED_LOCKS, *PFCB_BUFFERED_LOCKS;


#ifdef __cplusplus
typedef struct _FCB : public MRX_FCB {
#else //  !__cplusplus
typedef struct _FCB {
    
    //
    //  Entries are reference counted. ordinarily this would be at the beginning but
    //  in the case of FCB's it will follows the common header and fixed part
    //

    union {
        MRX_FCB;
        struct {
           FSRTL_ADVANCED_FCB_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  !__cplusplus

    //
    //  VNetroot for this FCB, if any
    //

    PV_NET_ROOT VNetRoot;  

    //
    //  Structure for fields that must be in non-paged pool.
    //

    PNON_PAGED_FCB NonPaged;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The resource accquisition mechanism gives preference to buffering state change
    //  processing over other requests. Therefor when a buffering state change is
    //  indicated all subsequent requests are shunted off to wait on a buffering state
    //  change completion event. This enables the actual buffering state change processing
    //  to complete in a timely fashion.
    //

    PKEVENT pBufferingStateChangeCompletedEvent;

    //
    //  Number of contexts awaiting buffering state change processing completion
    //

    LONG NumberOfBufferingStateChangeWaiters;

    //
    //  the name in the table is always a suffix of the name as viewed by the mini
    //  redirector. the string in the prefix entry is the name in the table....
    //  the "alreadyprefixedname: points to the whole name.
    //

    RX_FCB_TABLE_ENTRY FcbTableEntry;

    //
    //  the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name
    //

    UNICODE_STRING PrivateAlreadyPrefixedName;

    //
    //  Indicates that the V_NET_ROOT related processing on finalization is complete
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  the present state of the FCB, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Pointer to the private dispatch table, if any.
    //

    PRX_FSD_DISPATCH_VECTOR PrivateDispatchVector;

    //
    //  the device object that owns this fcb
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PMINIRDR_DISPATCH MRxDispatch;

    //
    //  private fast dispatch table, if any. This allows lwio to add it's own hooks
    //

    PFAST_IO_DISPATCH MRxFastIoDispatch;

    //
    //  Whenever a  FCB instance is created a correpsonding SRV_OPEN and FOBX instance
    //  is also created. More than one SRV_OPEN can be associated with a given FCB and
    //  more than one FOBX is associated with a given SRV_OPEN. In a majority of the
    //  cases the number of SRV_OPENs associated with an FCB is one and the number of
    //  FOBX associated with a given SRV_OPEN is 1. In order to improve the spatial
    //  locality and the paging behaviour in such cases the allocation for the
    //  FCB also involves an allocation for the SRV_OPEN and FOBX.
    //

    //
    //  set initially to the internally allocated srv_open
    //

    PSRV_OPEN InternalSrvOpen;

    //
    //  set to internal fobx until allocated
    //

    PFOBX InternalFobx;

    //
    //  the shared access for each time this file/directory is opened.
    //

    SHARE_ACCESS ShareAccess;
    SHARE_ACCESS ShareAccessPerSrvOpens;

    //
    //  this information is returned when the file is opened. ..might as well
    //  cache it so that so that tandard info query can be handled on the client
    //  side
    //

    ULONG NumberOfLinks;

    //
    //  Cache these entries..... speeds up RxFastQueryBasicInfo().
    //

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastChangeTime;

    //
    //  used to check by mini redirs in order to decide whether to update the FCB
    //

    ULONG ulFileSizeVersion;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //

    FILE_LOCK FileLock;

    //
    //  do this wierdly so that I can call stuff be the inner or outer names
    //

    union {
#ifndef __cplusplus
        LOWIO_PER_FCB_INFO;
#endif // __cplusplus
        LOWIO_PER_FCB_INFO LowIoPerFcbInfo;
    };

#ifdef USE_FILESIZE_LOCK
    PFAST_MUTEX FileSizeLock;
#endif

    //
    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Fobx.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.
    //

    ULONG EaModificationCount;

    FCB_BUFFERED_LOCKS  BufferedLocks;

#if DBG
    PNON_PAGED_FCB CopyOfNonPaged;     //  copy of NonPaged so we can zap the real pointer and still find it
#endif
#ifdef RDBSS_TRACKER
    ULONG FcbAcquires[RX_FCBTRACKER_CASE_MAXIMUM]; //  there are four types
    ULONG FcbReleases[RX_FCBTRACKER_CASE_MAXIMUM];
#else
#error tracker must be defined
#endif

    PCHAR PagingIoResourceFile;
    ULONG PagingIoResourceLine;

} FCB, *PFCB;

//
//  Here are the Fcb state fields.
//

#define FCB_STATE_SRVOPEN_USED                   ( 0x80000000 )
#define FCB_STATE_FOBX_USED                      ( 0x40000000 )
#define FCB_STATE_ADDEDBACKSLASH                 ( 0x20000000 )
#define FCB_STATE_NAME_ALREADY_REMOVED           ( 0x10000000 )
#define FCB_STATE_WRITECACHING_ENABLED           ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHING_ENABLED            ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )
#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )
#define FCB_STATE_SPECIAL_PATH                   ( 0x00020000 )
#define FCB_STATE_FILE_IS_SHADOWED               ( 0x00010000 )
#define FCB_STATE_FILE_IS_DISK_COMPRESSED        ( 0x00008000 )
#define FCB_STATE_FILE_IS_BUF_COMPRESSED         ( 0x00004000 )
#define FCB_STATE_BUFFERSTATE_CHANGING           ( 0x00002000 )
#define FCB_STATE_FAKEFCB                        ( 0x00001000 )
#define FCB_STATE_DELAY_CLOSE                    ( 0x00000800 )
#define FCB_STATE_READAHEAD_DEFERRED             ( 0x00000100 )
#define FCB_STATE_ORPHANED                       ( 0x00000080 )
#define FCB_STATE_BUFFERING_STATE_CHANGE_PENDING ( 0x00000040 )
#define FCB_STATE_TEMPORARY                      ( 0x00000020 )
#define FCB_STATE_DISABLE_LOCAL_BUFFERING        ( 0x00000010 )
#define FCB_STATE_LWIO_ENABLED                   ( 0x00000008 )
#define FCB_STATE_PAGING_FILE                    ( 0x00000004 )
#define FCB_STATE_TRUNCATE_ON_CLOSE              ( 0x00000002 )
#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

#define FCB_STATE_BUFFERING_STATE_MASK    \
                    (( FCB_STATE_WRITECACHING_ENABLED           \
                          | FCB_STATE_WRITEBUFFERING_ENABLED    \
                          | FCB_STATE_READCACHING_ENABLED       \
                          | FCB_STATE_READBUFFERING_ENABLED     \
                          | FCB_STATE_OPENSHARING_ENABLED       \
                          | FCB_STATE_COLLAPSING_ENABLED        \
                          | FCB_STATE_LOCK_BUFFERING_ENABLED    \
                          | FCB_STATE_FILESIZECACHEING_ENABLED  \
                          | FCB_STATE_FILETIMECACHEING_ENABLED  ))
//
//  This is the MAX recursive resource limit.
//

#define MAX_FCB_ASYNC_ACQUIRE            (0xf000)

typedef struct _FCB_INIT_PACKET {
    PULONG pAttributes;             //  in the fcb this is DirentRxFlags;
    PULONG pNumLinks;               //  in the fcb this is NumberOfLinks;
    PLARGE_INTEGER pCreationTime;   //  these fields are the same as for the Fcb
    PLARGE_INTEGER pLastAccessTime;
    PLARGE_INTEGER pLastWriteTime;
    PLARGE_INTEGER pLastChangeTime;
    PLARGE_INTEGER pAllocationSize; //  common header fields
    PLARGE_INTEGER pFileSize;
    PLARGE_INTEGER pValidDataLength;
} FCB_INIT_PACKET;

//
//  A SRV_OPEN contains
//      0) signature and refcount
//      a) backpointer to the FCB
//      b) backpointer to the NET_ROOT   //maybe
//      c) a list of FOXB structures
//      d) access rights and collapsability status
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The SRV_OPEN points to a structure describing a spevific open on the
//  server; multiple file objects and fileobject extensions (FOBXs) can
//  share the same srvopen if the access rights are correct.  For example,
//  this would be where the FID is stored for SMBs.  A list of these hangs
//  from the FCB.  Similarly, all fileobject extensionss that share the same
//  serverside open are listed together here.  Also here is information
//  about whether a new open of this FCB can share this serverside open
//  context; obviously the guys that pass the test on the list.
//

//
//  The SRVOPEN flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define SRVOPEN_FLAG_ENCLOSED_ALLOCATED  (0x10000)
#define SRVOPEN_FLAG_FOBX_USED           (0x20000)
#define SRVOPEN_FLAG_SHAREACCESS_UPDATED (0x40000)

#ifdef __cplusplus
typedef struct _SRV_OPEN : public MRX_SRV_OPEN {
#else //  !__cplusplus
typedef struct _SRV_OPEN {

    //
    //  the portion of SRV_OPEN visible to all the mini redirectors.
    //

    union {
        MRX_SRV_OPEN;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;

           //
           //  the Fcb and VNetRoot for this srv_open
           //

           PFCB Fcb;       
           PV_NET_ROOT VNetRoot;
        };
    };
#endif //  !__cplusplus

    BOOLEAN UpperFinalizationDone;

    //
    //  the current condition of the SRV_OPEN, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Buffering state manager token
    //

    LONG BufferingToken;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the SRV_OPEN.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Head for the list of FOBXs associated with this SRV_OPEN
    //

    LIST_ENTRY FobxList;

    //
    //  The colocated instance of FOBX that is allocated whenever a SRV_OPEN
    //  instance is allocated.
    //

    PFOBX InternalFobx;

    //
    //  the data structure for maintaining the mapping between the key
    //  associated with the SRV_OPEN instance by the mini redirector and
    //  the SRV_OPEN instance
    //

    union {
       LIST_ENTRY SrvOpenKeyList;
       ULONG SequenceNumber;
    };
    NTSTATUS OpenStatus;
} SRV_OPEN, *PSRV_OPEN;

#define RxWriteCachingAllowed(FCB,SRVOPEN) \
      (FlagOn( (FCB)->FcbState, FCB_STATE_WRITECACHING_ENABLED ) && \
       !FlagOn( (SRVOPEN)->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHING ))

#define SRVOPEN_INIT_KEY (0)

//
//  A FOBX contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the SRV_OPEN
//     c) context information about this open
//     ...
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FOBX points to the "fileobject extension", i.e.  all the stuff that
//  is per fileobject is not stored there because the IO system provides
//  fixed size filesystem objects (not a dig BTW, that's just the decision).
//  The FOBX for any file object is referenced by the FsContext2 field in
//  the fileobject.  Even tho the FOBX is ordinarily a terminus in the
//  structure, it is currently refcounted anyway.

//  The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define FOBX_FLAG_MATCH_ALL               (0x10000)

//
//  This tells us whether we allocated buffers to hold search templates.
//

#define FOBX_FLAG_FREE_UNICODE            (0x20000)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define FOBX_FLAG_USER_SET_LAST_WRITE     (0x40000)
#define FOBX_FLAG_USER_SET_LAST_ACCESS    (0x80000)
#define FOBX_FLAG_USER_SET_CREATION       (0x100000)
#define FOBX_FLAG_USER_SET_LAST_CHANGE    (0x200000)

//
//  This bit says the file object associated with this Fobx was opened for
//  read only access.
//

#define FOBX_FLAG_READ_ONLY               (0x400000)

//
//  the delete on close flag is used to track a file object that was opened with delete-on-close;
//  when this object is closed, we copy the bit to the fcb and make it global
//

#define FOBX_FLAG_DELETE_ON_CLOSE         (0x800000)

//
//  this bits is used by minirdrs that do not have NT semantics. for example, the smbmini has
//  to close a file before it can try a rename or delete. after the operation, we prevent people from
//  getting back in.
//

#define FOBX_FLAG_SRVOPEN_CLOSED          (0x1000000)

//
//  this bit is used to tell whether the original name was a UNC name so that
//  we can return the name the same way
//

#define FOBX_FLAG_UNC_NAME                (0x2000000)

//
//  this flag tells if this fobx is allocated as part of a larger structure
//

#define FOBX_FLAG_ENCLOSED_ALLOCATED      (0x4000000)

//
//  this flag specfies if the FOBX was included in the count of dormant
//  files against the server.
//

#define FOBX_FLAG_MARKED_AS_DORMANT       (0x8000000)

//
//  this flag notes down the fact that some writes have been issued on this FOBX
//  this is used to issue flushes on close
//

#define FOBX_FLAG_WRITES_ISSUED           (0x10000000)

#ifdef __cplusplus
typedef struct _FOBX : public MRX_FOBX {
#else //  !__cplusplus
typedef struct _FOBX {
    //
    //  the portion of FOBX visible to the mini redirectors
    //

    union {
        MRX_FOBX;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_OPEN SrvOpen;
        };
    };
#endif //  __cplusplus

    //
    //  a serial number....it wraps but not often
    //

    ULONG FobxSerialNumber;

    //
    //  list entry to wire the FOBX to the list of FOBXs maintained in
    //  the associated SRV_OPEN
    //

    LIST_ENTRY FobxQLinks;

    //
    //  list entry to gather all the FOBX instance marked for garbage collection
    //  scavenging
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  list entry to thread together all the FOBXs which have a pending close
    //  operation.
    //

    LIST_ENTRY ClosePendingList;

    LARGE_INTEGER CloseTime;

    BOOLEAN UpperFinalizationDone;
    BOOLEAN ContainsWildCards;
    BOOLEAN fOpenCountDecremented;

    //
    //  Parameters depending on the type of file opened, pipe/file etc.
    //

    union {

        struct {

            union {
#ifndef __cplusplus
                MRX_PIPE_HANDLE_INFORMATION;
#endif //  __cplusplus
                MRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;
            };

            LARGE_INTEGER CollectDataTime;
            ULONG CollectDataSize;
            THROTTLING_STATE ThrottlingState;   //  for peek and read om msgmodepipes

            //
            //  these serialization Qs must be together
            //  and read must be the first
            //

            LIST_ENTRY ReadSerializationQueue;
            LIST_ENTRY WriteSerializationQueue;
        } NamedPipe;

        struct {
            RXVBO PredictedReadOffset;
            RXVBO PredictedWriteOffset;
            THROTTLING_STATE LockThrottlingState;   //  for locks
            LARGE_INTEGER LastLockOffset;
            LARGE_INTEGER LastLockRange;
        } DiskFile;
    } Specific;

    //
    // Only required for finalization.
    // We do not take a reference on the RxDeviceObject when copied from the FCB,
    // as the FCB holds a reference, and FCB finalization will happen only after
    // FOBX finalization.
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

} FOBX, *PFOBX;


#define FOBX_NUMBER_OF_SERIALIZATION_QUEUES 2

//
//  The RDBSS wrapper relies upon ref. counting to mark the instances of
//  various data structures. The following macros implement a debugging
//  mechanism to track/log the reference counts associated with various
//  data structures. A fine grained control to monitor each data structure
//  separately is provided. Each of these can be further controlled to either
//  print the tracking info or log it.
//

#define RDBSS_REF_TRACK_SRVCALL  (0x00000001)
#define RDBSS_REF_TRACK_NETROOT  (0x00000002)
#define RDBSS_REF_TRACK_VNETROOT (0x00000004)
#define RDBSS_REF_TRACK_NETFOBX  (0x00000008)
#define RDBSS_REF_TRACK_NETFCB   (0x00000010)
#define RDBSS_REF_TRACK_SRVOPEN  (0x00000020)

#define RX_LOG_REF_TRACKING      (0x80000000)
#define RX_PRINT_REF_TRACKING    (0x40000000)

//
//  The reference count tracking mechanism is activated by setting the following
//  variable to the appropriate value defined above.
//

extern ULONG RdbssReferenceTracingValue;

//
//  Macros for tracking the line number and the file of each reference and
//  derefernce on the data structure. on Non DBG builds they are defined as
//  NOTHING. For each data structure the appropriate reference/dereference
//  macro is defined, These should be used instead of raw manipulation of
//  the reference counts.
//

#ifdef DBG
VOID
RxpTrackReference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

BOOLEAN
RxpTrackDereference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

#else
#define RxpTrackReference(Type,File,Line,Instance)    NOTHING
#define RxpTrackDereference(Type,File,Line,Instance)  NOTHING
#endif

#define REF_TRACING_ON(TraceMask)  (TraceMask & RdbssReferenceTracingValue)
#define PRINT_REF_COUNT(TYPE,Count)                                 \
        if (REF_TRACING_ON( RDBSS_REF_TRACK_ ## TYPE ) &&           \
            (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING)) { \
           DbgPrint("%ld\n",Count);                                 \
        }

#define RxReferenceSrvCallAtDpc(SrvCall)                                      \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   ASSERT( SrvCall->NodeReferenceCount > 1 );                                 \
   InterlockedIncrement( &SrvCall->NodeReferenceCount )

#define RxReferenceSrvCall(SrvCall)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxReference( SrvCall )

#define RxDereferenceSrvCall(SrvCall,LockHoldingState)                          \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxDereference(SrvCall, LockHoldingState )

#define RxReferenceNetRoot(NetRoot)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot ); \
   RxReference( NetRoot )

#define RxDereferenceNetRoot( NetRoot, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot );\
   RxDereference( NetRoot, LockHoldingState )

#define RxReferenceVNetRoot(VNetRoot)                                        \
   RxpTrackReference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot );\
   RxReference( VNetRoot )

#define RxDereferenceVNetRoot( VNetRoot, LockHoldingState )                       \
   RxpTrackDereference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot ); \
   RxDereference( VNetRoot, LockHoldingState )

#define RxReferenceNetFobx(Fobx)                                          \
   RxpTrackReference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );      \
   RxReference( Fobx )

#define RxDereferenceNetFobx(Fobx,LockHoldingState)                       \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );    \
   RxDereference( Fobx, LockHoldingState )

#define RxReferenceSrvOpen(SrvOpen)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen ); \
   RxReference( SrvOpen )

#define RxDereferenceSrvOpen( SrvOpen, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen); \
   RxDereference( SrvOpen, LockHoldingState )

#define RxReferenceNetFcb(Fcb)                                            \
  (RxpTrackReference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),  \
   RxpReferenceNetFcb( Fcb ))

//
//  the following macros manipulate the reference count and also return the
//  status of the final derefence or finalize call. This results in the usage
//  of the , operator.
//           

#define RxDereferenceNetFcb(Fcb)  ( \
   ((LONG)RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb )), \
   RxpDereferenceNetFcb( Fcb ))

#define RxDereferenceAndFinalizeNetFcb(Fcb,RxContext,RecursiveFinalize,ForceFinalize) ( \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),              \
   RxpDereferenceAndFinalizeNetFcb( Fcb, RxContext, RecursiveFinalize, ForceFinalize )) \

//
//  Check for structure alignment errors
//            

VOID
RxCheckFcbStructuresForAlignment(
    VOID
    );


//
//  SRV_CALL related routines.
//

PSRV_CALL
RxCreateSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING InnerNamePrefix OPTIONAL,
    IN PRX_CONNECTION_ID RxConnectionId
    );


#define RxWaitForStableSrvCall(SRVCALL,RXCONTEXT) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), NULL); \
    }

#define RxWaitForStableSrvCall_Async(SRVCALL,RXCONTEXT,PNTSTATUS) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), (PNTSTATUS) ); \
    }

#define RxTransitionSrvCall(SRVCALL,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvCall -- %lx Condition -- %ld\n",(SRVCALL),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList )

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN BOOLEAN ForceFinalize
    );

//
// NET_ROOT related routines.
//

PNET_ROOT
RxCreateNetRoot (
    IN PSRV_CALL SrvCall,
    IN PUNICODE_STRING Name,
    IN ULONG NetRootFlags,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxFinishNetRootInitialization (
    IN OUT PNET_ROOT ThisNetRoot,
    IN PMINIRDR_DISPATCH Dispatch,
    IN PUNICODE_STRING  InnerNamePrefix,
    IN ULONG FcbSize,
    IN ULONG SrvOpenSize,
    IN ULONG FobxSize,
    IN ULONG NetRootFlags
    );


#define RxWaitForStableNetRoot(NETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetRoot -- %lx\n",(NETROOT)));    \
    RxWaitForStableCondition(&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetRoot(NETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetRoot -- %lx Condition -- %ld\n",(NETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList)

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// V_NET_ROOT related routines
//

NTSTATUS
RxInitializeVNetRootParameters (
   PRX_CONTEXT RxContext,
   OUT LUID *LogonId,
   OUT PULONG SessionId,
   OUT PUNICODE_STRING *UserNamePtr,
   OUT PUNICODE_STRING *UserDomainNamePtr,
   OUT PUNICODE_STRING *PasswordPtr,
   OUT PULONG Flags
   );

VOID
RxUninitializeVNetRootParameters (
   IN PUNICODE_STRING UserName,
   IN PUNICODE_STRING UserDomainName,
   IN PUNICODE_STRING Password,
   OUT PULONG Flags
   );

PV_NET_ROOT
RxCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PNET_ROOT NetRoot,
    IN PUNICODE_STRING CanonicalName,
    IN PUNICODE_STRING LocalNetRootName,
    IN PUNICODE_STRING FilePath,
    IN PRX_CONNECTION_ID RxConnectionId
    );

BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#define RxWaitForStableVNetRoot(VNETROOT,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableVNetRoot -- %lx\n",(VNETROOT)) );    \
    RxWaitForStableCondition( &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionVNetRoot(VNETROOT,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionVNetRoot -- %lx Condition -- %ld\n", (VNETROOT), (CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList )

#ifdef USE_FILESIZE_LOCK

//
//  FCB related routines.
//

#define RxAcquireFileSizeLock(PFCB) { \
    ExAcquireFastMutex( (PFCB)->Specific.Fcb.FileSizeLock ); \
}
#define RxReleaseFileSizeLock(PFCB) { \
    ExReleaseFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}

#endif

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN PLONGLONG FileSize
    );

VOID
RxGetFileSizeWithLock (
    IN PFCB Fcb,
    OUT PLONGLONG FileSize
    );

PFCB
RxCreateNetFcb (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PV_NET_ROOT VNetRoot,
    IN PUNICODE_STRING Name
    );

#define RxWaitForStableNetFcb(FCB,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(FCB)));    \
    RxWaitForStableCondition( &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionNetFcb(FCB,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionNetFcb -- %lx Condition -- %ld\n",(FCB),(CONDITION))); \
    RxUpdateCondition( (CONDITION), &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList )


#define RxFormInitPacket(IP,I1,I1a,I2,I3,I4a,I4b,I5,I6,I7) (\
            IP.pAttributes = I1, \
            IP.pNumLinks = I1a, \
            IP.pCreationTime = I2, \
            IP.pLastAccessTime = I3, \
            IP.pLastWriteTime = I4a, \
            IP.pLastChangeTime = I4b, \
            IP.pAllocationSize = I5, \
            IP.pFileSize = I6, \
            IP.pValidDataLength = I7, \
          &IP)

#if DBG
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb) {\
    ASSERT( ___thisfcb->NonPaged == ___thisfcb->CopyOfNonPaged );       \
    ASSERT( ___thisfcb->NonPaged->FcbBackPointer == ___thisfcb );       \
    }
#else
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb)
#endif

#define ASSERT_CORRECT_FCB_STRUCTURE(THIS_FCB__) { \
    ASSERT( NodeTypeIsFcb(THIS_FCB__));                                 \
    ASSERT( THIS_FCB__->NonPaged != NULL );                             \
    ASSERT( NodeType(THIS_FCB__->NonPaged) == RDBSS_NTC_NONPAGED_FCB);  \
    ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(THIS_FCB__) \
    }

RX_FILE_TYPE
RxInferFileType (
    IN PRX_CONTEXT RxContext
    );

VOID
RxFinishFcbInitialization (
    IN OUT PMRX_FCB Fcb,
    IN RX_FILE_TYPE FileType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    );

#define RxWaitForStableSrvOpen(SRVOPEN,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableFcb -- %lx\n",(SRVOPEN)) );    \
    RxWaitForStableCondition( &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionSrvOpen(SRVOPEN,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvOpen -- %lx Condition -- %ld\n",(SRVOPEN),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList )

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    );

LONG
RxpReferenceNetFcb (
   PFCB Fcb
   );

LONG
RxpDereferenceNetFcb (
   PFCB Fcb
   );

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if DBG
extern BOOLEAN RxLoudFcbOpsOnExes;
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING Name
    );
#else
#define RxLoudFcbMsg(a,b) (FALSE)
#endif


//
//  SRV_OPEN related methods
//

PSRV_OPEN
RxCreateSrvOpen (
    IN PV_NET_ROOT VNetRoot,
    IN OUT PFCB Fcb
    );

VOID
RxTransitionSrvOpenState (
    OUT PSRV_OPEN ThisSrvOpen,
    IN RX_BLOCK_CONDITION Condition
    );

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if 0
#else
INLINE 
PUNICODE_STRING
GET_ALREADY_PREFIXED_NAME (
    PMRX_SRV_OPEN SrvOpen,
    PMRX_FCB Fcb)
{
    PFCB ThisFcb = (PFCB)Fcb;

#if DBG
    if (SrvOpen != NULL ) {
        ASSERT( NodeType( SrvOpen ) == RDBSS_NTC_SRVOPEN );
        ASSERT( ThisFcb != NULL );
        ASSERT( NodeTypeIsFcb( Fcb) );
        ASSERT( SrvOpen->pFcb == Fcb );
        ASSERT( SrvOpen->pAlreadyPrefixedName == &ThisFcb->PrivateAlreadyPrefixedName );
    }
#endif

    return( &ThisFcb->PrivateAlreadyPrefixedName);
}
#endif

#define GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(Rxcontext) \
        (GET_ALREADY_PREFIXED_NAME( (Rxcontext)->pRelevantSrvOpen, (Rxcontext)->pFcb ))

//
//  FOBX related routines
//

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT RxContext,
    IN PMRX_SRV_OPEN MrxSrvOpen
    );

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#endif // _FCB_STRUCTS_DEFINED_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Fcb.h

Abstract:

    This module defines File Control Block data structures, by which we mean:

       1) File Control Blocks     (FCB)
       2) File Object Extensions  (FOXB)
       3) Net Roots               (NET_ROOT)
       4) ServerSide Open Context (SRV_OPEN)
       5) Server Call Context     (SRV_CALL)
       6) View of Net Roots       (V_NET_ROOT)

    The more complete description follows the prototypes.

Author:
--*/

#ifndef _FCB_STRUCTS_DEFINED_
#define _FCB_STRUCTS_DEFINED_

#include "fcbtable.h"
#include "buffring.h"

typedef NODE_TYPE_CODE TYPE_OF_OPEN;

struct _FCB_INIT_PACKET;
typedef struct _FCB_INIT_PACKET *PFCB_INIT_PACKET;


/* -----------------------------------------------------------
       There are six important data structures in the wrapper that are shared with the
       various mini redirectors. These data structures come in two flavours -- the
       mini redirector flavour which contains only those fields that can be manipulated
       by the mini redirector and the RDBSS flavour defined here. The mini redirector
       flavour carries the prefix MRX_.

       The six data structures are SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and FOBX
       respectively.

       The global view of these structures is the following (information on each of the
       data structures follows the locking description )

       L O C K I N G  <-------

       There are two levels of lookup tables used: a global table for srvcalls
       and netroots and a table-per-netroot for fcbs.  This allows directory
       operations on different netroots to be almost completely noninterfering
       (once the connections are established).  Directory operations on the
       same netroot do intefere slightly.  The following table describes what
       locks you need:

       OPERATION         DATATYPE              LOCK REQUIRED

       create/finalize   srvcall/(v)netroot    exclusive on netnametablelock
       ref/deref/lookup  srvcall/(v)netroot    shared on netnametablelock (at least)

       create/finalize   fcb/srvopen/fobx      exclusive on netroot->fcbtablelock
       ref/deref/lookup  fcb/srvopen/fobx      shared on netroot->fcbtablelock

       Note that manipulations on srvopens and fobxs require the same lock as
       fcbs....this is simply a memory saving idea.  It would be
       straightforward to add another resource at the fcb level to remove this;
       a set of sharted resources could be used to decrease the probability of
       collision to an acceptably low level.

       R E F   C O U N T S  <---------------

       Each of the structures is reference counted. The counts are the
       following:

       refcount(srvcall) = number of netroots pointing to srvcall + DYNAMIC
       refcount(netroot) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fcb)     = number of fcbs pointing to netroot + DYNAMIC
       refcount(srvopen) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fobx)    = DYNAMIC

       In each case, dynamic refers to the number of callers that have
       referenced the structure without dereferencing it. The static part of
       the refcount is maintained by the routines themselves; for example,
       CreateNetRoot increments the refcount for the associated srvcall.
       Reference and Successful Lookups increment the reference counts;
       dereference decrements the count. Creates set the reference counts to 1,

       If you require both locks (like FinalizeNetFcb), you take the fcblock
       first AND THEN the global table lock. obviously, you release in the
       opposite order.

----------------------------------*/

//
// SRV_CALL
//
// A global list of the SRV_CALL structures is maintained in the global
// data.  Each SrvCall structure has stuff that is unique to a srv_call.
// Now, the rx doesn't know what this stuff is except for
//
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) a list of associated NET_ROOTs
//     c) a set of timing parameters that control how often the subrx wants
//        to be called by the rx in different circumstances (i.e. idle timouts)
//     d) the minirdr id
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// In fact, the Unicode name of the structure is carried in the structure itself
// at the end.  The extra space begins at the end of the known stuff so that a
// mini redirector can just refer to his extra space using the context fields

// These flags are not visible to the mini redirectors.

#define SRVCALL_FLAG_NO_CONNECTION_ALLOWED (0x10000)
#define SRVCALL_FLAG_NO_WRITES_ALLOWED     (0x20000)
#define SRVCALL_FLAG_NO_DELETES_ALLOWED    (0x40000)

#ifdef __cplusplus
typedef struct _SRV_CALL : public MRX_SRV_CALL {
#else //  !__cplusplus
typedef struct _SRV_CALL {

    //
    //  The portion of SRV_CALL visible to mini redirectors.
    //

    union {
        MRX_SRV_CALL;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus

    //
    //  The finalization of a SRV_CALL instance consists of two parts,
    //  destroying the association with all NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //  
    //  Name and Prefixtable entry for name lookups
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  Current condition of the SRV_CALL, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    ULONG SerialNumberForEnum;

    //
    //  Number of delayed close files
    //

    LONG NumberOfCloseDelayedFiles;

    //
    //  List of Contexts which are waiting for the SRV_CALL transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the SRV_CALL instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened at this server.
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The Buffering manager for coordinating/processing the buffering state
    //  change requests of the files opened at the server.
    //

    RX_BUFFERING_MANAGER BufferingManager;
} SRV_CALL, *PSRV_CALL;

//
//  A NET_ROOT contains
//      0) signature and refcount
//      a) a name and associated table stuff
//      b) backpointer to the SRV_CALL structure
//      c) size information for the various substructures
//      d) a lookuptable of FCB structures
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  A NET_ROOT is what the rx wants to deal with.....not a server.
//  Accordingly, the rx calls down to open a netroot and the subrx is
//  responsible for opening a server and calling up to put the right
//  structures.
//

#define NETROOT_FLAG_ENCLOSED_ALLOCATED       ( 0x00010000 )
#define NETROOT_FLAG_DEVICE_NETROOT           ( 0x00020000 )
#define NETROOT_FLAG_FINALIZATION_IN_PROGRESS ( 0x00040000 )
#define NETROOT_FLAG_NAME_ALREADY_REMOVED     ( 0x00080000 )

#define NETROOT_INIT_KEY (0)

#ifdef __cplusplus
typedef struct _NET_ROOT : public MRX_NET_ROOT {
#else // !__cplusplus
typedef struct _NET_ROOT {

    //
    //  The porion of NET_ROOT instance visible to mini redirectors.
    //

    union {
        MRX_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_CALL SrvCall;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a NET_ROOT instance consists of two parts,
    //  destroying the association with all V_NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  Current condition of the NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened for this NET_ROOt
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The default V_NET_ROOT instance to be used on this NET_ROOT
    //

    PV_NET_ROOT DefaultVNetRoot;

    //
    //  list of V_NET_ROOTs associated with the NET_ROOT
    //

    LIST_ENTRY VirtualNetRoots;

    //
    //  the count of V_NET_ROOT instances associated with the NET_ROOT
    //

    ULONG NumberOfVirtualNetRoots;

    ULONG  SerialNumberForEnum;

    //
    //  NET_ROOT name and prefix table entry
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  the FCB's associated with this NET_ROOT
    //

    RX_FCB_TABLE FcbTable;
} NET_ROOT, *PNET_ROOT;

//
//  A V_NETROOT contains
//     0) signature and refcount
//     a) ptr to netroot and links.
//     b) name info for table lookup (prefix)
//     c) name for a prefix to be added to whatever name you see. this is for simulating a netroot
//     mapped not at the root of the actual netroot.
//

#ifdef __cplusplus
typedef struct _V_NET_ROOT : public MRX_V_NET_ROOT {
#else //  !__cplusplus
typedef struct _V_NET_ROOT {

    //
    //  the portion of V_NET_ROOT visible to mini redirectors
    //

    union {
        MRX_V_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a V_NET_ROOT instance consists of two parts,
    //  destroying the association with all FCBs etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    BOOLEAN ConnectionFinalizationDone;

    //
    //  Current condition of the V_NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Additional reference for the Delete FSCTL. This field is long as
    //  opposed to a BOOLEAN eventhough it can have only one of two values
    //  0 or 1. This enables the usage of interlocked instructions
    //

    LONG AdditionalReferenceForDeleteFsctlTaken;

    //
    //  Prefix table entry and V_NET_ROOT name ( prefix table entry is inserted
    //  in the RxNetNameTable)
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  this name is prepended to all fcbs (not currently used)
    //

    UNICODE_STRING NamePrefix;

    //
    //  amount of bytes required to get past the netroot
    //

    ULONG PrefixOffsetInBytes;

    //
    //  List entry to wire the V_NET_ROOT instance into a list of V_NET_ROOTS
    //  maintained in the NET_ROOT
    //

    LIST_ENTRY NetRootListEntry;

    ULONG SerialNumberForEnum;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the V_NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;
} V_NET_ROOT, *PV_NET_ROOT;

#define FILESIZE_LOCK_DISABLED(x)

//
//  An FCB contains
//      0) FSRTL_COMMON_HEADER
//      1) a reference count
//      a) a name and associated table stuff
//      b) backpointer to the NET_ROOT structure
//      c) a list of SRV_OPEN structures
//      d) device object
//      e) dispatch table (not yet)
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FCB is pointed to by the FsContext Field in the file object.  The
//  rule is that all the guys sharing an FCB are talking about the same
//  file.  (unfortuantely, SMB servers are implemented today in such a way
//  that names are aliased so that two different names could be the same
//  actual file.....sigh!) The Fcb is the focal point of file
//  operations...since operations on the same FCB are actually on the same
//  file, synchronization is based on the Fcb rather than some higher level
//  (the levels described so far are lower, i.e.  farther from the user).
//  Again, we will provide for colocation of FCB/SRV_OPEN/FOBX to improve
//  paging behaviour.  We don't colocate the FCB and NET_ROOT because the
//  NET_ROOTs are not paged but FCBs usually are (i.e.  unless they are
//  paging files).
//
//  The Fcb record corresponds to every open file and directory and is is split up into
//  two portions a non paged part, i.e., an instance allocated in non paged pool and
//  a paged part. The former is the NON_PAGED_FCB and the later is referred to as FCB.
//  The FCB conatins a pointer to the corresponding NON_PAGED_FCB part. A backpointer
//  is maintained from the NON_PAGED_FCB to the FCB for debugging purposes in debug builds
//

typedef struct _NON_PAGED_FCB {

    //
    //  Struct type and size for debugging/tracking
    //

    NODE_TYPE_CODE     NodeTypeCode;
    NODE_BYTE_SIZE     NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  This resource is used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE HeaderResource;

    //
    //  This resource is also used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE PagingIoResource;

#ifdef USE_FILESIZE_LOCK

    //
    //  This mutex protect the filesize during read/write
    //

    FAST_MUTEX FileSizeLock;

#endif

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the FCB.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.
    //

    ULONG OutstandingAsyncWrites;

    //
    //  This event is set when OutstandingAsyncWrites transitions to zero.
    //

    PKEVENT OutstandingAsyncEvent;

    KEVENT TheActualEvent;

    //
    //  The mechanism for the mini redirectors to store additional information
    //

    PVOID MiniRdrContext[2];

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

    //
    // This resource is used to protect the buffered locks list
    //
    ERESOURCE BufferedLocksResource;

#if DBG
    PFCB FcbBackPointer;
#endif

} NON_PAGED_FCB, *PNON_PAGED_FCB;

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

//
//  A enumerated type distinguishing the varios contexts under which the FCB resource
//  is accquired.
//

typedef enum _RX_FCBTRACKER_CASES {
    RX_FCBTRACKER_CASE_NORMAL,
    RX_FCBTRACKER_CASE_NULLCONTEXT,
    RX_FCBTRACKER_CASE_CBS_CONTEXT,
    RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT,
    RX_FCBTRACKER_CASE_MAXIMUM
} RX_FCBTRACKER_CASES;

typedef struct _FCB_LOCK {
    struct _FCB_LOCK    *Next;
    LARGE_INTEGER       Length;
    LARGE_INTEGER       BytesOffset;
    ULONG               Key;
    BOOLEAN             ExclusiveLock;
} FCB_LOCK, *PFCB_LOCK;

typedef struct _FCB_BUFFERED_LOCKS {
    struct _FCB_LOCK    *List;
    ULONG               PendingLockOps;
    PERESOURCE          Resource;
} FCB_BUFFERED_LOCKS, *PFCB_BUFFERED_LOCKS;

#ifdef __cplusplus
typedef struct _FCB : public MRX_FCB {
#else //  !__cplusplus
typedef struct _FCB {
    
    //
    //  Entries are reference counted. ordinarily this would be at the beginning but
    //  in the case of FCB's it will follows the common header and fixed part
    //

    union {
        MRX_FCB;
        struct {
           FSRTL_ADVANCED_FCB_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  !__cplusplus

    //
    //  VNetroot for this FCB, if any
    //

    PV_NET_ROOT VNetRoot;  

    //
    //  Structure for fields that must be in non-paged pool.
    //

    PNON_PAGED_FCB NonPaged;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The resource accquisition mechanism gives preference to buffering state change
    //  processing over other requests. Therefor when a buffering state change is
    //  indicated all subsequent requests are shunted off to wait on a buffering state
    //  change completion event. This enables the actual buffering state change processing
    //  to complete in a timely fashion.
    //

    PKEVENT pBufferingStateChangeCompletedEvent;

    //
    //  Number of contexts awaiting buffering state change processing completion
    //

    LONG NumberOfBufferingStateChangeWaiters;

    //
    //  the name in the table is always a suffix of the name as viewed by the mini
    //  redirector. the string in the prefix entry is the name in the table....
    //  the "alreadyprefixedname: points to the whole name.
    //

    RX_FCB_TABLE_ENTRY FcbTableEntry;

    //
    //  the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name
    //

    UNICODE_STRING PrivateAlreadyPrefixedName;

    //
    //  Indicates that the V_NET_ROOT related processing on finalization is complete
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  the present state of the FCB, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Pointer to the private dispatch table, if any.
    //

    PRX_FSD_DISPATCH_VECTOR PrivateDispatchVector;

    //
    //  the device object that owns this fcb
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PMINIRDR_DISPATCH MRxDispatch;

    //
    //	private fast dispatch table, if any. This allows lwio to add it's own hooks
    //

    PFAST_IO_DISPATCH MRxFastIoDispatch;

    //
    //  Whenever a  FCB instance is created a correpsonding SRV_OPEN and FOBX instance
    //  is also created. More than one SRV_OPEN can be associated with a given FCB and
    //  more than one FOBX is associated with a given SRV_OPEN. In a majority of the
    //  cases the number of SRV_OPENs associated with an FCB is one and the number of
    //  FOBX associated with a given SRV_OPEN is 1. In order to improve the spatial
    //  locality and the paging behaviour in such cases the allocation for the
    //  FCB also involves an allocation for the SRV_OPEN and FOBX.
    //

    //
    //  set initially to the internally allocated srv_open
    //

    PSRV_OPEN InternalSrvOpen;

    //
    //  set to internal fobx until allocated
    //

    PFOBX InternalFobx;

    //
    //  the shared access for each time this file/directory is opened.
    //

    SHARE_ACCESS ShareAccess;
    SHARE_ACCESS ShareAccessPerSrvOpens;

    //
    //  this information is returned when the file is opened. ..might as well
    //  cache it so that so that tandard info query can be handled on the client
    //  side
    //

    ULONG NumberOfLinks;

    //
    //  Cache these entries..... speeds up RxFastQueryBasicInfo().
    //

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastChangeTime;

    //
    //  this thread is one who has acquired the FCB for CreateSection. it is used
    //  to deduce whether certain operations (notably queryfileinfo) have preacquired
    //  the resources and will, therefore, run without blocking.
    //

    PETHREAD CreateSectionThread;

    //
    //  used to check by mini redirs in order to decide whether to update the FCB
    //

    ULONG ulFileSizeVersion;

    //
    //  The following union is cased off of the node type code for the fcb.
    //  There is a seperate case for the directory versus file fcbs.
    //

    union {

        //
        //  A File Control Block (Fcb)
        //

        struct {
            
            //
            //  The following field will be used by the oplock module
            //  to maintain current oplock information. BUT we dont do it
            //  yet
            //

            //  OPLOCK Oplock;

            //
            //  The following field is used by the filelock module
            //  to maintain current byte range locking information.
            //

            FILE_LOCK FileLock;

            //
            //  This pointer is used to detect writes that eminated in the
            //  cache manager's lazywriter.  It prevents lazy writer threads,
            //  who already have the Fcb shared, from trying to acquire it
            //  exclusive, and thus causing a deadlock.
            //

            PVOID LazyWriteThread;

            //
            //  do this wierdly so that I can call stuff be the inner or outer names
            //

            union {
#ifndef __cplusplus
                LOWIO_PER_FCB_INFO;
#endif // __cplusplus
                LOWIO_PER_FCB_INFO LowIoPerFcbInfo;
            };

#ifdef USE_FILESIZE_LOCK
            PFAST_MUTEX FileSizeLock;
#endif

        } Fcb;

    } Specific;

    //
    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Fobx.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.
    //

    ULONG EaModificationCount;

    FCB_BUFFERED_LOCKS  BufferedLocks;

#if DBG
    PNON_PAGED_FCB CopyOfNonPaged;     //  copy of NonPaged so we can zap the real pointer and still find it
#endif
#ifdef RDBSS_TRACKER
    ULONG FcbAcquires[RX_FCBTRACKER_CASE_MAXIMUM]; //  there are four types
    ULONG FcbReleases[RX_FCBTRACKER_CASE_MAXIMUM];
#else
#error tracker must be defined
#endif

    PCHAR PagingIoResourceFile;
    ULONG PagingIoResourceLine;

} FCB, *PFCB;

//
//  Here are the Fcb state fields.
//

#define FCB_STATE_SRVOPEN_USED                   ( 0x80000000 )
#define FCB_STATE_FOBX_USED                      ( 0x40000000 )
#define FCB_STATE_ADDEDBACKSLASH                 ( 0x20000000 )
#define FCB_STATE_NAME_ALREADY_REMOVED           ( 0x10000000 )
#define FCB_STATE_WRITECACHEING_ENABLED          ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHEING_ENABLED           ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )
#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )
#define FCB_STATE_SPECIAL_PATH                   ( 0x00020000 )
#define FCB_STATE_FILE_IS_SHADOWED               ( 0x00010000 )
#define FCB_STATE_FILE_IS_DISK_COMPRESSED        ( 0x00008000 )
#define FCB_STATE_FILE_IS_BUF_COMPRESSED         ( 0x00004000 )
#define FCB_STATE_BUFFERSTATE_CHANGING           ( 0x00002000 )
#define FCB_STATE_FAKEFCB                        ( 0x00001000 )
#define FCB_STATE_DELAY_CLOSE                    ( 0x00000800 )
#define FCB_STATE_READAHEAD_DEFERRED             ( 0x00000100 )
#define FCB_STATE_ORPHANED                       ( 0x00000080 )
#define FCB_STATE_BUFFERING_STATE_CHANGE_PENDING ( 0x00000040 )
#define FCB_STATE_TEMPORARY                      ( 0x00000020 )
#define FCB_STATE_DISABLE_LOCAL_BUFFERING        ( 0x00000010 )
#define FCB_STATE_LWIO_ENABLED                   ( 0x00000008 )
#define FCB_STATE_PAGING_FILE                    ( 0x00000004 )
#define FCB_STATE_TRUNCATE_ON_CLOSE              ( 0x00000002 )
#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

#define FCB_STATE_BUFFERING_STATE_MASK    \
                    (( FCB_STATE_WRITECACHEING_ENABLED          \
                          | FCB_STATE_WRITEBUFFERING_ENABLED    \
                          | FCB_STATE_READCACHEING_ENABLED      \
                          | FCB_STATE_READBUFFERING_ENABLED     \
                          | FCB_STATE_OPENSHARING_ENABLED       \
                          | FCB_STATE_COLLAPSING_ENABLED        \
                          | FCB_STATE_LOCK_BUFFERING_ENABLED    \
                          | FCB_STATE_FILESIZECACHEING_ENABLED  \
                          | FCB_STATE_FILETIMECACHEING_ENABLED  ))
//
//  This is the MAX recursive resource limit.
//

#define MAX_FCB_ASYNC_ACQUIRE            (0xf000)

typedef struct _FCB_INIT_PACKET {
    PULONG pAttributes;             //  in the fcb this is DirentRxFlags;
    PULONG pNumLinks;               //  in the fcb this is NumberOfLinks;
    PLARGE_INTEGER pCreationTime;   //  these fields are the same as for the Fcb
    PLARGE_INTEGER pLastAccessTime;
    PLARGE_INTEGER pLastWriteTime;
    PLARGE_INTEGER pLastChangeTime;
    PLARGE_INTEGER pAllocationSize; //  common header fields
    PLARGE_INTEGER pFileSize;
    PLARGE_INTEGER pValidDataLength;
} FCB_INIT_PACKET;

//
//  A SRV_OPEN contains
//      0) signature and refcount
//      a) backpointer to the FCB
//      b) backpointer to the NET_ROOT   //maybe
//      c) a list of FOXB structures
//      d) access rights and collapsability status
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The SRV_OPEN points to a structure describing a spevific open on the
//  server; multiple file objects and fileobject extensions (FOBXs) can
//  share the same srvopen if the access rights are correct.  For example,
//  this would be where the FID is stored for SMBs.  A list of these hangs
//  from the FCB.  Similarly, all fileobject extensionss that share the same
//  serverside open are listed together here.  Also here is information
//  about whether a new open of this FCB can share this serverside open
//  context; obviously the guys that pass the test on the list.
//

//
//  The SRVOPEN flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define SRVOPEN_FLAG_ENCLOSED_ALLOCATED  (0x10000)
#define SRVOPEN_FLAG_FOBX_USED           (0x20000)
#define SRVOPEN_FLAG_SHAREACCESS_UPDATED (0x40000)

#ifdef __cplusplus
typedef struct _SRV_OPEN : public MRX_SRV_OPEN {
#else //  !__cplusplus
typedef struct _SRV_OPEN {

    //
    //  the portion of SRV_OPEN visible to all the mini redirectors.
    //

    union {
        MRX_SRV_OPEN;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PFCB Fcb;       //  the Fcb for this srv_open
        };
    };
#endif //  !__cplusplus

    BOOLEAN UpperFinalizationDone;

    //
    //  the current condition of the SRV_OPEN, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Buffering state manager token
    //

    LONG BufferingToken;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the SRV_OPEN.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Head for the list of FOBXs associated with this SRV_OPEN
    //

    LIST_ENTRY FobxList;

    //
    //  The colocated instance of FOBX that is allocated whenever a SRV_OPEN
    //  instance is allocated.
    //

    PFOBX InternalFobx;

    //
    //  the data structure for maintaining the mapping between the key
    //  associated with the SRV_OPEN instance by the mini redirector and
    //  the SRV_OPEN instance
    //

    union {
       LIST_ENTRY SrvOpenKeyList;
       ULONG SequenceNumber;
    };
    NTSTATUS OpenStatus;
} SRV_OPEN, *PSRV_OPEN;

#define RxWriteCacheingAllowed(Fcb,SrvOpen) \
      (FlagOn( (Fcb)->FcbState, FCB_STATE_WRITECACHEING_ENABLED ) && \
       !FlagOn( (SrvOpen)->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING ))


#define SRVOPEN_INIT_KEY (0)

//
//  A FOBX contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the SRV_OPEN
//     c) context information about this open
//     ...
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FOBX points to the "fileobject extension", i.e.  all the stuff that
//  is per fileobject is not stored there because the IO system provides
//  fixed size filesystem objects (not a dig BTW, that's just the decision).
//  The FOBX for any file object is referenced by the FsContext2 field in
//  the fileobject.  Even tho the FOBX is ordinarily a terminus in the
//  structure, it is currently refcounted anyway.

//  The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define FOBX_FLAG_MATCH_ALL               (0x10000)

//
//  This tells us whether we allocated buffers to hold search templates.
//

#define FOBX_FLAG_FREE_UNICODE            (0x20000)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define FOBX_FLAG_USER_SET_LAST_WRITE     (0x40000)
#define FOBX_FLAG_USER_SET_LAST_ACCESS    (0x80000)
#define FOBX_FLAG_USER_SET_CREATION       (0x100000)
#define FOBX_FLAG_USER_SET_LAST_CHANGE    (0x200000)

//
//  This bit says the file object associated with this Fobx was opened for
//  read only access.
//

#define FOBX_FLAG_READ_ONLY               (0x400000)

//
//  the delete on close flag is used to track a file object that was opened with delete-on-close;
//  when this object is closed, we copy the bit to the fcb and make it global
//

#define FOBX_FLAG_DELETE_ON_CLOSE         (0x800000)

//
//  this bits is used by minirdrs that do not have NT semantics. for example, the smbmini has
//  to close a file before it can try a rename or delete. after the operation, we prevent people from
//  getting back in.
//

#define FOBX_FLAG_SRVOPEN_CLOSED          (0x1000000)

//
//  this bit is used to tell whether the original name was a UNC name so that
//  we can return the name the same way
//

#define FOBX_FLAG_UNC_NAME                (0x2000000)

//
//  this flag tells if this fobx is allocated as part of a larger structure
//

#define FOBX_FLAG_ENCLOSED_ALLOCATED      (0x4000000)

//
//  this flag specfies if the FOBX was included in the count of dormant
//  files against the server.
//

#define FOBX_FLAG_MARKED_AS_DORMANT       (0x8000000)

//
//  this flag notes down the fact that some writes have been issued on this FOBX
//  this is used to issue flushes on close
//

#define FOBX_FLAG_WRITES_ISSUED           (0x10000000)

//
//  This flag signals whether this file has been extended via this FOBX.  It is
//  used during cleanup to see if we need to hint to the file system that it
//  should update its directory information.  This allows us to delay close and
//  yet still have the directory information reflect the new size.
//

#define FOBX_FLAG_FILE_EXTENDED           (0x20000000)


#ifdef __cplusplus
typedef struct _FOBX : public MRX_FOBX {
#else //  !__cplusplus
typedef struct _FOBX {
    //
    //  the portion of FOBX visible to the mini redirectors
    //

    union {
        MRX_FOBX;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_OPEN SrvOpen;
        };
    };
#endif //  __cplusplus

    //
    //  a serial number....it wraps but not often
    //

    ULONG FobxSerialNumber;

    //
    //  list entry to wire the FOBX to the list of FOBXs maintained in
    //  the associated SRV_OPEN
    //

    LIST_ENTRY FobxQLinks;

    //
    //  list entry to gather all the FOBX instance marked for garbage collection
    //  scavenging
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  list entry to thread together all the FOBXs which have a pending close
    //  operation.
    //

    LIST_ENTRY ClosePendingList;

    LARGE_INTEGER CloseTime;

    BOOLEAN UpperFinalizationDone;
    BOOLEAN ContainsWildCards;
    BOOLEAN fOpenCountDecremented;

    //
    //  Parameters depending on the type of file opened, pipe/file etc.
    //

    union {

        struct {

            union {
#ifndef __cplusplus
                MRX_PIPE_HANDLE_INFORMATION;
#endif //  __cplusplus
                MRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;
            };

            LARGE_INTEGER CollectDataTime;
            ULONG CollectDataSize;
            THROTTLING_STATE ThrottlingState;   //  for peek and read om msgmodepipes

            //
            //  these serialization Qs must be together
            //  and read must be the first
            //

            LIST_ENTRY ReadSerializationQueue;
            LIST_ENTRY WriteSerializationQueue;
        } NamedPipe;

        struct {
            RXVBO PredictedReadOffset;
            RXVBO PredictedWriteOffset;
            THROTTLING_STATE LockThrottlingState;   //  for locks
            LARGE_INTEGER LastLockOffset;
            LARGE_INTEGER LastLockRange;
        } DiskFile;
    } Specific;

    //
    // Only required for the finalization
    // We do not take a reference on the RxDeviceObject when copied from 
    // the FCB as the FCB has a reference on this and the FCB finalization
    // happens only after the FOBx finalization
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

} FOBX, *PFOBX;


#define FOBX_NUMBER_OF_SERIALIZATION_QUEUES 2

//
//  The RDBSS wrapper relies upon ref. counting to mark the instances of
//  various data structures. The following macros implement a debugging
//  mechanism to track/log the reference counts associated with various
//  data structures. A fine grained control to monitor each data structure
//  separately is provided. Each of these can be further controlled to either
//  print the tracking info or log it.
//

#define RDBSS_REF_TRACK_SRVCALL  (0x00000001)
#define RDBSS_REF_TRACK_NETROOT  (0x00000002)
#define RDBSS_REF_TRACK_VNETROOT (0x00000004)
#define RDBSS_REF_TRACK_NETFOBX  (0x00000008)
#define RDBSS_REF_TRACK_NETFCB   (0x00000010)
#define RDBSS_REF_TRACK_SRVOPEN  (0x00000020)

#define RX_LOG_REF_TRACKING      (0x80000000)
#define RX_PRINT_REF_TRACKING    (0x40000000)

//
//  The reference count tracking mechanism is activated by setting the following
//  variable to the appropriate value defined above.
//

extern ULONG RdbssReferenceTracingValue;

//
//  Macros for tracking the line number and the file of each reference and
//  derefernce on the data structure. on Non DBG builds they are defined as
//  NOTHING. For each data structure the appropriate reference/dereference
//  macro is defined, These should be used instead of raw manipulation of
//  the reference counts.
//

#ifdef DBG
VOID
RxpTrackReference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

BOOLEAN
RxpTrackDereference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

#else
#define RxpTrackReference(Type,File,Line,Instance)    NOTHING
#define RxpTrackDereference(Type,File,Line,Instance)  NOTHING
#endif

#define REF_TRACING_ON(TraceMask)  (TraceMask & RdbssReferenceTracingValue)
#define PRINT_REF_COUNT(TYPE,Count)                                 \
        if (REF_TRACING_ON( RDBSS_REF_TRACK_ ## TYPE ) &&           \
            (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING)) { \
           DbgPrint("%ld\n",Count);                                 \
        }

#define RxReferenceSrvCallAtDpc(SrvCall)                                      \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   ASSERT( SrvCall->NodeReferenceCount > 1 );                                 \
   InterlockedIncrement( &SrvCall->NodeReferenceCount )

#define RxReferenceSrvCall(SrvCall)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxReference( SrvCall )

#define RxDereferenceSrvCall(SrvCall,LockHoldingState)                          \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxDereference(SrvCall, LockHoldingState )

#define RxReferenceNetRoot(NetRoot)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot ); \
   RxReference( NetRoot )

#define RxDereferenceNetRoot( NetRoot, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot );\
   RxDereference( NetRoot, LockHoldingState )

#define RxReferenceVNetRoot(VNetRoot)                                        \
   RxpTrackReference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot );\
   RxReference( VNetRoot )

#define RxDereferenceVNetRoot( VNetRoot, LockHoldingState )                       \
   RxpTrackDereference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot ); \
   RxDereference( VNetRoot, LockHoldingState )

#define RxReferenceNetFobx(Fobx)                                          \
   RxpTrackReference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );      \
   RxReference( Fobx )

#define RxDereferenceNetFobx(Fobx,LockHoldingState)                       \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );    \
   RxDereference( Fobx, LockHoldingState )

#define RxReferenceSrvOpen(SrvOpen)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen ); \
   RxReference( SrvOpen )

#define RxDereferenceSrvOpen( SrvOpen, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen); \
   RxDereference( SrvOpen, LockHoldingState )

#define RxReferenceNetFcb(Fcb)                                            \
  (RxpTrackReference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),  \
   RxpReferenceNetFcb( Fcb ))

//
//  the following macros manipulate the reference count and also return the
//  status of the final derefence or finalize call. This results in the usage
//  of the , operator.
//           

#define RxDereferenceNetFcb(Fcb)  ( \
   ((LONG)RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb )), \
   RxpDereferenceNetFcb( Fcb ))

#define RxDereferenceAndFinalizeNetFcb(Fcb,RxContext,RecursiveFinalize,ForceFinalize) ( \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),              \
   RxpDereferenceAndFinalizeNetFcb( Fcb, RxContext, RecursiveFinalize, ForceFinalize )) \

//
//  Check for structure alignment errors
//            

VOID
RxCheckFcbStructuresForAlignment(
    VOID
    );


//
//  SRV_CALL related routines.
//

PSRV_CALL
RxCreateSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING InnerNamePrefix OPTIONAL,
    IN PRX_CONNECTION_ID RxConnectionId
    );


#define RxWaitForStableSrvCall(SRVCALL,RXCONTEXT) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), NULL); \
    }

#define RxWaitForStableSrvCall_Async(SRVCALL,RXCONTEXT,PNTSTATUS) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), (PNTSTATUS) ); \
    }

#define RxTransitionSrvCall(SRVCALL,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvCall -- %lx Condition -- %ld\n",(SRVCALL),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList )

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// NET_ROOT related routines.
//

PNET_ROOT
RxCreateNetRoot (
    IN PSRV_CALL SrvCall,
    IN PUNICODE_STRING Name,
    IN ULONG NetRootFlags,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxFinishNetRootInitialization (
    IN OUT PNET_ROOT ThisNetRoot,
    IN PMINIRDR_DISPATCH Dispatch,
    IN PUNICODE_STRING  InnerNamePrefix,
    IN ULONG FcbSize,
    IN ULONG SrvOpenSize,
    IN ULONG FobxSize,
    IN ULONG NetRootFlags
    );


#define RxWaitForStableNetRoot(NETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetRoot -- %lx\n",(NETROOT)));    \
    RxWaitForStableCondition(&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetRoot(NETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetRoot -- %lx Condition -- %ld\n",(NETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList)

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// V_NET_ROOT related routines
//

NTSTATUS
RxInitializeVNetRootParameters (
   PRX_CONTEXT RxContext,
   OUT LUID *LogonId,
   OUT PULONG SessionId,
   OUT PUNICODE_STRING *UserNamePtr,
   OUT PUNICODE_STRING *UserDomainNamePtr,
   OUT PUNICODE_STRING *PasswordPtr,
   OUT PULONG Flags
   );

VOID
RxUninitializeVNetRootParameters (
   IN PUNICODE_STRING UserName,
   IN PUNICODE_STRING UserDomainName,
   IN PUNICODE_STRING Password,
   OUT PULONG Flags
   );

PV_NET_ROOT
RxCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PNET_ROOT NetRoot,
    IN PUNICODE_STRING CanonicalName,
    IN PUNICODE_STRING LocalNetRootName,
    IN PUNICODE_STRING FilePath,
    IN PRX_CONNECTION_ID RxConnectionId
    );

BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#define RxWaitForStableVNetRoot(VNETROOT,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableVNetRoot -- %lx\n",(VNETROOT)) );    \
    RxWaitForStableCondition( &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionVNetRoot(VNETROOT,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionVNetRoot -- %lx Condition -- %ld\n", (VNETROOT), (CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList )

#ifdef USE_FILESIZE_LOCK

//
//  FCB related routines.
//

#define RxAcquireFileSizeLock(PFCB) { \
    ExAcquireFastMutex( (PFCB)->Specific.Fcb.FileSizeLock ); \
}
#define RxReleaseFileSizeLock(PFCB) { \
    ExReleaseFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}

#endif

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN PLONGLONG FileSize
    );

VOID
RxGetFileSizeWithLock (
    IN PFCB Fcb,
    OUT PLONGLONG FileSize
    );

PFCB
RxCreateNetFcb (
    OUT PRX_CONTEXT RxContext,
    IN PV_NET_ROOT VNetRoot,
    IN PUNICODE_STRING Name
    );

#define RxWaitForStableNetFcb(FCB,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(FCB)));    \
    RxWaitForStableCondition( &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionNetFcb(FCB,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetFcb -- %lx Condition -- %ld\n",(FCB),(CONDITION))); \
    RxUpdateCondition( (CONDITION), &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList )


#define RxFormInitPacket(IP,I1,I1a,I2,I3,I4a,I4b,I5,I6,I7) (\
            IP.pAttributes = I1, \
            IP.pNumLinks = I1a, \
            IP.pCreationTime = I2, \
            IP.pLastAccessTime = I3, \
            IP.pLastWriteTime = I4a, \
            IP.pLastChangeTime = I4b, \
            IP.pAllocationSize = I5, \
            IP.pFileSize = I6, \
            IP.pValidDataLength = I7, \
          &IP)

#if DBG
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb) {\
    ASSERT( ___thisfcb->NonPaged == ___thisfcb->CopyOfNonPaged );       \
    ASSERT( ___thisfcb->NonPaged->FcbBackPointer == ___thisfcb );       \
    }
#else
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb)
#endif

#define ASSERT_CORRECT_FCB_STRUCTURE(THIS_FCB__) { \
    ASSERT( NodeTypeIsFcb(THIS_FCB__));                                 \
    ASSERT( THIS_FCB__->NonPaged != NULL );                             \
    ASSERT( NodeType(THIS_FCB__->NonPaged) == RDBSS_NTC_NONPAGED_FCB);  \
    ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(THIS_FCB__) \
    }

RX_FILE_TYPE
RxInferFileType (
    IN PRX_CONTEXT RxContext
    );

VOID
RxFinishFcbInitialization (
    IN OUT PMRX_FCB Fcb,
    IN RX_FILE_TYPE FileType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    );

#define RxWaitForStableSrvOpen(SRVOPEN,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableFcb -- %lx\n",(SRVOPEN)) );    \
    RxWaitForStableCondition( &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionSrvOpen(SRVOPEN,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvOpen -- %lx Condition -- %ld\n",(SRVOPEN),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList )

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    );

LONG
RxpReferenceNetFcb (
   PFCB Fcb
   );

LONG
RxpDereferenceNetFcb (
   PFCB Fcb
   );

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if DBG
extern BOOLEAN RxLoudFcbOpsOnExes;
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING Name
    );
#else
#define RxLoudFcbMsg(a,b) (FALSE)
#endif


//
//  SRV_OPEN related methods
//

PSRV_OPEN
RxCreateSrvOpen (
    IN PV_NET_ROOT VNetRoot,
    IN OUT PFCB Fcb
    );

VOID
RxTransitionSrvOpenState (
    OUT PSRV_OPEN ThisSrvOpen,
    IN RX_BLOCK_CONDITION Condition
    );

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if 0
#else
INLINE 
PUNICODE_STRING
GET_ALREADY_PREFIXED_NAME (
    PMRX_SRV_OPEN SrvOpen,
    PMRX_FCB Fcb)
{
    PFCB ThisFcb = (PFCB)Fcb;

#if DBG
    if (SrvOpen != NULL ) {
        ASSERT( NodeType( SrvOpen ) == RDBSS_NTC_SRVOPEN );
        ASSERT( ThisFcb != NULL );
        ASSERT( NodeTypeIsFcb( Fcb) );
        ASSERT( SrvOpen->pFcb == Fcb );
        ASSERT( SrvOpen->pAlreadyPrefixedName == &ThisFcb->PrivateAlreadyPrefixedName );
    }
#endif

    return( &ThisFcb->PrivateAlreadyPrefixedName);
}
#endif

#define GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(Rxcontext) \
        (GET_ALREADY_PREFIXED_NAME( (Rxcontext)->pRelevantSrvOpen, (Rxcontext)->pFcb ))

//
//  FOBX related routines
//

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT RxContext,
    IN PMRX_SRV_OPEN MrxSrvOpen
    );

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#endif // _FCB_STRUCTS_DEFINED_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Fcb.h

Abstract:

    This module defines File Control Block data structures, by which we mean:

       1) File Control Blocks     (FCB)
       2) File Object Extensions  (FOXB)
       3) Net Roots               (NET_ROOT)
       4) ServerSide Open Context (SRV_OPEN)
       5) Server Call Context     (SRV_CALL)
       6) View of Net Roots       (V_NET_ROOT)

    The more complete description follows the prototypes.

Author:
--*/

#ifndef _FCB_STRUCTS_DEFINED_
#define _FCB_STRUCTS_DEFINED_

#include "fcbtable.h"
#include "buffring.h"

typedef NODE_TYPE_CODE TYPE_OF_OPEN;

struct _FCB_INIT_PACKET;
typedef struct _FCB_INIT_PACKET *PFCB_INIT_PACKET;


/* -----------------------------------------------------------
       There are six important data structures in the wrapper that are shared with the
       various mini redirectors. These data structures come in two flavours -- the
       mini redirector flavour which contains only those fields that can be manipulated
       by the mini redirector and the RDBSS flavour defined here. The mini redirector
       flavour carries the prefix MRX_.

       The six data structures are SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and FOBX
       respectively.

       The global view of these structures is the following (information on each of the
       data structures follows the locking description )

       L O C K I N G  <-------

       There are two levels of lookup tables used: a global table for srvcalls
       and netroots and a table-per-netroot for fcbs.  This allows directory
       operations on different netroots to be almost completely noninterfering
       (once the connections are established).  Directory operations on the
       same netroot do intefere slightly.  The following table describes what
       locks you need:

       OPERATION         DATATYPE              LOCK REQUIRED

       create/finalize   srvcall/(v)netroot    exclusive on netnametablelock
       ref/deref/lookup  srvcall/(v)netroot    shared on netnametablelock (at least)

       create/finalize   fcb/srvopen/fobx      exclusive on netroot->fcbtablelock
       ref/deref/lookup  fcb/srvopen/fobx      shared on netroot->fcbtablelock

       Note that manipulations on srvopens and fobxs require the same lock as
       fcbs....this is simply a memory saving idea.  It would be
       straightforward to add another resource at the fcb level to remove this;
       a set of sharted resources could be used to decrease the probability of
       collision to an acceptably low level.

       R E F   C O U N T S  <---------------

       Each of the structures is reference counted. The counts are the
       following:

       refcount(srvcall) = number of netroots pointing to srvcall + DYNAMIC
       refcount(netroot) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fcb)     = number of fcbs pointing to netroot + DYNAMIC
       refcount(srvopen) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fobx)    = DYNAMIC

       In each case, dynamic refers to the number of callers that have
       referenced the structure without dereferencing it. The static part of
       the refcount is maintained by the routines themselves; for example,
       CreateNetRoot increments the refcount for the associated srvcall.
       Reference and Successful Lookups increment the reference counts;
       dereference decrements the count. Creates set the reference counts to 1,

       If you require both locks (like FinalizeNetFcb), you take the fcblock
       first AND THEN the global table lock. obviously, you release in the
       opposite order.

----------------------------------*/


// SRV_CALL
//
// A global list of the SRV_CALL structures is maintained in the global
// data.  Each SrvCall structure has stuff that is unique to a srv_call.
// Now, the rx doesn't know what this stuff is except for
//
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) a list of associated NET_ROOTs
//     c) a set of timing parameters that control how often the subrx wants
//        to be called by the rx in different circumstances (i.e. idle timouts)
//     d) the minirdr id
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// In fact, the Unicode name of the structure is carried in the structure itself
// at the end.  The extra space begins at the end of the known stuff so that a
// mini redirector can just refer to his extra space using the context fields

// These flags are not visible to the mini redirectors.

#define SRVCALL_FLAG_NO_CONNECTION_ALLOWED (0x10000)
#define SRVCALL_FLAG_NO_WRITES_ALLOWED     (0x20000)
#define SRVCALL_FLAG_NO_DELETES_ALLOWED    (0x40000)

typedef struct _SRV_CALL {
    // The portion of SRV_CALL visible to mini redirectors.

    union {
        MRX_SRV_CALL;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };

    // The finalization of a SRV_CALL instance consists of two parts,
    // destroying the association with all NET_ROOTS etc and freeing the
    // memory. There can be a delay between these two and this field
    // prevents thefirst step from being duplicated.

    BOOLEAN              UpperFinalizationDone;

    // Name and Prefixtable entry for name lookups

    RX_PREFIX_ENTRY      PrefixEntry;

    // Current condition of the SRV_CALL, i.e., good/bad/in transition

    RX_BLOCK_CONDITION   Condition;

    ULONG                SerialNumberForEnum;

    // Number of delayed close files

    LONG                 NumberOfCloseDelayedFiles;

    // List of Contexts which are waiting for the SRV_CALL transitioning
    // to be completed before resumption of processing. This typically
    // happens when concurrent requests are directed at a server. One of
    // these requests initiates the construction while the other requests
    // are queued.

    LIST_ENTRY           TransitionWaitList;

    // List Entry to thread together all the SRV_CALL instances marked
    // for garbage collection/scavenging.

    LIST_ENTRY           ScavengerFinalizationList;

    // Synchronization context for coordinating the purge operations on the
    // files opened at this server.

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    // The Buffering manager for coordinating/processing the buffering state
    // change requests of the files opened at the server.

    RX_BUFFERING_MANAGER BufferingManager;
} SRV_CALL;


// A NET_ROOT contains
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) backpointer to the SRV_CALL structure
//     c) size information for the various substructures
//     d) a lookuptable of FCB structures
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// A NET_ROOT is what the rx wants to deal with.....not a server.
// Accordingly, the rx calls down to open a netroot and the subrx is
// responsible for opening a server and calling up to put the right
// structures.

#define NETROOT_FLAG_ENCLOSED_ALLOCATED       ( 0x00010000 )
#define NETROOT_FLAG_DEVICE_NETROOT           ( 0x00020000 )
#define NETROOT_FLAG_FINALIZATION_IN_PROGRESS ( 0x00040000 )
#define NETROOT_FLAG_NAME_ALREADY_REMOVED     ( 0x00080000 )

#define NETROOT_INIT_KEY (0)

typedef struct _NET_ROOT {
    // The porion of NET_ROOT instance visible to mini redirectors.
    union {
        MRX_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_CALL SrvCall;
        };
    };

    // The finalization of a NET_ROOT instance consists of two parts,
    // destroying the association with all V_NET_ROOTS etc and freeing the
    // memory. There can be a delay between these two and this field
    // prevents thefirst step from being duplicated.

    BOOLEAN            UpperFinalizationDone;

    // Current condition of the NET_ROOT, i.e., good/bad/in transition

    RX_BLOCK_CONDITION Condition;

    // List of Contexts which are waiting for the NET_ROOT transitioning
    // to be completed before resumption of processing. This typically
    // happens when concurrent requests are directed at a server. One of
    // these requests initiates the construction while the other requests
    // are queued.

    LIST_ENTRY         TransitionWaitList;

    // List Entry to thread together all the NET_ROOT instances marked
    // for garbage collection/scavenging.

    LIST_ENTRY         ScavengerFinalizationList;

    // Synchronization context for coordinating the purge operations on the
    // files opened for this NET_ROOt

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    // The default V_NET_ROOT instance to be used on this NET_ROOT

    struct _V_NET_ROOT *DefaultVNetRoot;

    // list of V_NET_ROOTs associated with the NET_ROOT

    LIST_ENTRY         VirtualNetRoots;

    // the count of V_NET_ROOT instances associated with the NET_ROOT

    ULONG              NumberOfVirtualNetRoots;


    ULONG              SerialNumberForEnum;

    // NET_ROOT name and prefix table entry

    RX_PREFIX_ENTRY    PrefixEntry;

    // the FCB's associated with this NET_ROOT

    RX_FCB_TABLE    FcbTable;
} NET_ROOT;


// A V_NETROOT contains
//    0) signature and refcount
//    a) ptr to netroot and links.
//    b) name info for table lookup (prefix)
//    c) name for a prefix to be added to whatever name you see. this is for simulating a netroot
//    mapped not at the root of the actual netroot.

typedef struct _V_NET_ROOT {
    // the portion of V_NET_ROOT visible to mini redirectors
    union {
        MRX_V_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };

    // The finalization of a V_NET_ROOT instance consists of two parts,
    // destroying the association with all FCBs etc and freeing the
    // memory. There can be a delay between these two and this field
    // prevents thefirst step from being duplicated.

    BOOLEAN            UpperFinalizationDone;

    BOOLEAN            ConnectionFinalizationDone;

    // Current condition of the V_NET_ROOT, i.e., good/bad/in transition

    RX_BLOCK_CONDITION Condition;

    // Additional reference for the Delete FSCTL. This field is long as
    // opposed to a BOOLEAN eventhough it can have only one of two values
    // 0 or 1. This enables the usage of interlocked instructions

    LONG    AdditionalReferenceForDeleteFsctlTaken;

    // Prefix table entry and V_NET_ROOT name ( prefix table entry is inserted
    // in the RxNetNameTable)

    RX_PREFIX_ENTRY    PrefixEntry;

    // this name is prepended to all fcbs (not currently used)

    UNICODE_STRING     NamePrefix;

    // amount of bytes required to get past the netroot

    ULONG              PrefixOffsetInBytes;

    // List entry to wire the V_NET_ROOT instance into a list of V_NET_ROOTS
    // maintained in the NET_ROOT

    LIST_ENTRY         NetRootListEntry;

    ULONG              SerialNumberForEnum;

    // List of Contexts which are waiting for the NET_ROOT transitioning
    // to be completed before resumption of processing. This typically
    // happens when concurrent requests are directed at a server. One of
    // these requests initiates the construction while the other requests
    // are queued.

    LIST_ENTRY         TransitionWaitList;

    // List Entry to thread together all the V_NET_ROOT instances marked
    // for garbage collection/scavenging.

    LIST_ENTRY         ScavengerFinalizationList;
} V_NET_ROOT;

#define FILESIZE_LOCK_DISABLED(x)
// An FCB contains
//     0) FSRTL_COMMON_HEADER
//     1) a reference count
//     a) a name and associated table stuff
//     b) backpointer to the NET_ROOT structure
//     c) a list of SRV_OPEN structures
//     d) device object
//     e) dispatch table (not yet)
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// The FCB is pointed to by the FsContext Field in the file object.  The
// rule is that all the guys sharing an FCB are talking about the same
// file.  (unfortuantely, SMB servers are implemented today in such a way
// that names are aliased so that two different names could be the same
// actual file.....sigh!) The Fcb is the focal point of file
// operations...since operations on the same FCB are actually on the same
// file, synchronization is based on the Fcb rather than some higher level
// (the levels described so far are lower, i.e.  farther from the user).
// Again, we will provide for colocation of FCB/SRV_OPEN/FOBX to improve
// paging behaviour.  We don't colocate the FCB and NET_ROOT because the
// NET_ROOTs are not paged but FCBs usually are (i.e.  unless they are
// paging files).
//
// The Fcb record corresponds to every open file and directory and is is split up into
// two portions a non paged part, i.e., an instance allocated in non paged pool and
// a paged part. The former is the NON_PAGED_FCB and the later is referred to as FCB.
// The FCB conatins a pointer to the corresponding NON_PAGED_FCB part. A backpointer
// is maintained from the NON_PAGED_FCB to the FCB for debugging purposes in debug builds
//

typedef struct _NON_PAGED_FCB {
    // Struct type and size for debugging/tracking
    NODE_TYPE_CODE     NodeTypeCode;
    NODE_BYTE_SIZE     NodeByteSize;

    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //  This resource is used in the common fsrtl routines....allocated here for
    // space locality.

    ERESOURCE HeaderResource;

    //  This resource is also used in the common fsrtl routines....allocated here for
    // space locality.

    ERESOURCE PagingIoResource;

    // This mutex protect the filesize during read/write

    FILESIZE_LOCK_DISABLED(FAST_MUTEX FileSizeLock;)

    // The list of contexts whose processing has been suspended pending the state
    // transition of the FCB.


    LIST_ENTRY TransitionWaitList;

    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.

    ULONG OutstandingAsyncWrites;

    //  This event is set when OutstandingAsyncWrites transitions to zero.

    PKEVENT OutstandingAsyncEvent;

    KEVENT  TheActualEvent;

    // The mechanism for the mini redirectors to store additional information

    PVOID MiniRdrContext[2];

#if DBG
    PFCB FcbBackPointer;
#endif

} NON_PAGED_FCB;

typedef NON_PAGED_FCB *PNON_PAGED_FCB;

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

// A enumerated type distinguishing the varios contexts under which the FCB resource
// is accquired.

typedef enum _RX_FCBTRACKER_CASES {
    RX_FCBTRACKER_CASE_NORMAL,
    RX_FCBTRACKER_CASE_NULLCONTEXT,
    RX_FCBTRACKER_CASE_CBS_CONTEXT,
    RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT,
    RX_FCBTRACKER_CASE_MAXIMUM
} RX_FCBTRACKER_CASES;

typedef struct _FCB {
    // Entries are reference counted. ordinarily this would be at the beginning but
    // in the case of FCB's it will follows the common header and fixed part

    union {
        MRX_FCB;
        struct {
           FSRTL_COMMON_FCB_HEADER spacer;
           PNET_ROOT               NetRoot;
        };
    };

    PV_NET_ROOT             VNetRoot;  //  VNetroot for this FCB, if any

    // Structure for fields that must be in non-paged pool.

    PNON_PAGED_FCB NonPaged;

    // List Entry to thread together all the FCB instances marked
    // for garbage collection/scavenging.

    LIST_ENTRY ScavengerFinalizationList;

    // The resource accquisition mechanism gives preference to buffering state change
    // processing over other requests. Therefor when a buffering state change is
    // indicated all subsequent requests are shunted off to wait on a buffering state
    // change completion event. This enables the actual buffering state change processing
    // to complete in a timely fashion.

    PKEVENT pBufferingStateChangeCompletedEvent;

    // Number of contexts awaiting buffering state change processing completion

    LONG    NumberOfBufferingStateChangeWaiters;

    // the name in the table is always a suffix of the name as viewed by the mini
    // redirector. the string in the prefix entry is the name in the table....
    // the "alreadyprefixedname: points to the whole name.

    RX_FCB_TABLE_ENTRY  FcbTableEntry;

    // the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name

    UNICODE_STRING PrivateAlreadyPrefixedName;

    // Indicates that the V_NET_ROOT related processing on finalization is complete

    BOOLEAN            UpperFinalizationDone;

    // the present state of the FCB, good/bad/in transition

    RX_BLOCK_CONDITION Condition;

    //  Pointer to the private dispatch table, if any.

    PRX_FSD_DISPATCH_VECTOR PrivateDispatchVector;

    //  the device object that owns this fcb

    PRDBSS_DEVICE_OBJECT    RxDeviceObject;

    PMINIRDR_DISPATCH       MRxDispatch;

    // Whenever a  FCB instance is created a correpsonding SRV_OPEN and FOBX instance
    // is also created. More than one SRV_OPEN can be associated with a given FCB and
    // more than one FOBX is associated with a given SRV_OPEN. In a majority of the
    // cases the number of SRV_OPENs associated with an FCB is one and the number of
    // FOBX associated with a given SRV_OPEN is 1. In order to improve the spatial
    // locality and the paging behaviour in such cases the allocation for the
    // FCB also involves an allocation for the SRV_OPEN and FOBX.

    //  set initially to the internally allocated srv_open

    PSRV_OPEN               InternalSrvOpen;

    //  set to internal fobx until allocated

    PFOBX                   InternalFobx;

    //
    //  the shared access for each time this file/directory is opened.
    //

    SHARE_ACCESS            ShareAccess;
    SHARE_ACCESS            ShareAccessPerSrvOpens;

    //  this information is returned when the file is opened. ..might as well
    // cache it so that so that tandard info query can be handled on the client
    // side

    ULONG                   NumberOfLinks;

    //  Cache these entries..... speeds up RxFastQueryBasicInfo().

    LARGE_INTEGER           CreationTime;
    LARGE_INTEGER           LastAccessTime;
    LARGE_INTEGER           LastWriteTime;
    LARGE_INTEGER           LastChangeTime;

    //  this thread is one who has acquired the FCB for CreateSection. it is used
    //  to deduce whether certain operations (notably queryfileinfo) have preacquired
    //  the resources and will, therefore, run without blocking.

    PETHREAD                CreateSectionThread;

    // used to check by mini redirs in order to decide whether to update the FCB
    ULONG   ulFileSizeVersion;
        
    //  The following union is cased off of the node type code for the fcb.
    //  There is a seperate case for the directory versus file fcbs.

    union {

        //
        //  A Directory Control Block (Dcb)
        //

        struct {
            ULONG Dummy;
        } Dcb;

        //
        //  A File Control Block (Fcb)
        //

        struct {
            //
            //  The following field will be used by the oplock module
            //  to maintain current oplock information. BUT we dont do it
            //  yet
            //

            //  OPLOCK Oplock;


            //  The following field is used by the filelock module
            //  to maintain current byte range locking information.
            //

            FILE_LOCK FileLock;

            //
            //  This pointer is used to detect writes that eminated in the
            //  cache manager's lazywriter.  It prevents lazy writer threads,
            //  who already have the Fcb shared, from trying to acquire it
            //  exclusive, and thus causing a deadlock.
            //

            PVOID LazyWriteThread;

            //do this wierdly so that I can call stuff be the inner or outer names
            union {
                LOWIO_PER_FCB_INFO;
                LOWIO_PER_FCB_INFO LowIoPerFcbInfo;
            };

            FILESIZE_LOCK_DISABLED(PFAST_MUTEX FileSizeLock;)


        } Fcb;

    } Specific;

    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Fobx.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.

    ULONG EaModificationCount;

#if DBG
    PNON_PAGED_FCB CopyOfNonPaged;     //copy of NonPaged so we can zap the real pointer and still find it
#endif
#ifdef RDBSS_TRACKER
    ULONG FcbAcquires[RX_FCBTRACKER_CASE_MAXIMUM]; //there are four types
    ULONG FcbReleases[RX_FCBTRACKER_CASE_MAXIMUM];
#else
#error tracker must be defined
#endif

} FCB;
typedef FCB *PFCB;

//
//  Here are the Fcb state fields.
//

#define FCB_STATE_SRVOPEN_USED                   ( 0x80000000 )
#define FCB_STATE_FOBX_USED                      ( 0x40000000 )
#define FCB_STATE_ADDEDBACKSLASH                 ( 0x20000000 )
#define FCB_STATE_NAME_ALREADY_REMOVED           ( 0x10000000 )
#define FCB_STATE_WRITECACHEING_ENABLED          ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHEING_ENABLED           ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )
#define FCB_STATE_FILE_IS_SHADOWED               ( 0x00010000 )
#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )
#define FCB_STATE_FILE_IS_DISK_COMPRESSED        ( 0x00008000 )
#define FCB_STATE_FILE_IS_BUF_COMPRESSED         ( 0x00004000 )
#define FCB_STATE_BUFFERSTATE_CHANGING           ( 0x00002000 )
#define FCB_STATE_FAKEFCB                        ( 0x00001000 )
#define FCB_STATE_DELAY_CLOSE                    ( 0x00000800 )
#define FCB_STATE_READAHEAD_DEFERRED             ( 0x00000100 )
#define FCB_STATE_ORPHANED                       ( 0x00000080 )
#define FCB_STATE_BUFFERING_STATE_CHANGE_PENDING ( 0x00000040 )
#define FCB_STATE_TEMPORARY                      ( 0x00000020 )
#define FCB_STATE_RESERVED2                      ( 0x00000010 )
#define FCB_STATE_RESERVED1                      ( 0x00000008 )
#define FCB_STATE_PAGING_FILE                    ( 0x00000004 )
#define FCB_STATE_TRUNCATE_ON_CLOSE              ( 0x00000002 )
#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

#define FCB_STATE_BUFFERING_STATE_MASK    \
                    (( FCB_STATE_WRITECACHEING_ENABLED          \
                          | FCB_STATE_WRITEBUFFERING_ENABLED    \
                          | FCB_STATE_READCACHEING_ENABLED      \
                          | FCB_STATE_READBUFFERING_ENABLED     \
                          | FCB_STATE_OPENSHARING_ENABLED       \
                          | FCB_STATE_COLLAPSING_ENABLED        \
                          | FCB_STATE_LOCK_BUFFERING_ENABLED    \
                          | FCB_STATE_FILESIZECACHEING_ENABLED  \
                          | FCB_STATE_FILETIMECACHEING_ENABLED  ))
//
//  This is the MAX recursive resource limit.
//

#define MAX_FCB_ASYNC_ACQUIRE            (0xf000)

//
//  This is the slack allocation in the Dcb part of the UNION above
//

#define DCB_UNION_SLACK_SPACE ((ULONG)                       \
    (FIELD_OFFSET(DCB, EaModificationCount) -                \
     FIELD_OFFSET(DCB, Specific.Dcb.FreeDirentBitmapBuffer)) \
)

typedef struct _FCB_INIT_PACKET {
    PULONG pAttributes;             // in the fcb this is DirentRxFlags;
    PULONG pNumLinks;               // in the fcb this is NumberOfLinks;
    PLARGE_INTEGER pCreationTime;   // these fields are the same as for the Fcb
    PLARGE_INTEGER pLastAccessTime;
    PLARGE_INTEGER pLastWriteTime;
    PLARGE_INTEGER pLastChangeTime;
    PLARGE_INTEGER pAllocationSize; // common header fields
    PLARGE_INTEGER pFileSize;
    PLARGE_INTEGER pValidDataLength;
} FCB_INIT_PACKET;

// A SRV_OPEN contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the NET_ROOT   //maybe
//     c) a list of FOXB structures
//     d) access rights and collapsability status
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// The SRV_OPEN points to a structure describing a spevific open on the
// server; multiple file objects and fileobject extensions (FOBXs) can
// share the same srvopen if the access rights are correct.  For example,
// this would be where the FID is stored for SMBs.  A list of these hangs
// from the FCB.  Similarly, all fileobject extensionss that share the same
// serverside open are listed together here.  Also here is information
// about whether a new open of this FCB can share this serverside open
// context; obviously the guys that pass the test on the list.

// The SRVOPEN flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
// The visible ones are defined above and the definitions for the invisible ones can be found
// in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
// to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
// enforced in defining new flags.

#define SRVOPEN_FLAG_ENCLOSED_ALLOCATED  (0x10000)
#define SRVOPEN_FLAG_FOBX_USED           (0x20000)
#define SRVOPEN_FLAG_SHAREACCESS_UPDATED (0x40000)

typedef struct _SRV_OPEN {
    // the portion of SRV_OPEN visible to all the mini redirectors.
    union {
        MRX_SRV_OPEN;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PFCB                   Fcb;       // the Fcb for this srv_open
        };
    };

    BOOLEAN            UpperFinalizationDone;

    // the current condition of the SRV_OPEN, good/bad/in transition

    RX_BLOCK_CONDITION Condition;

    // Buffering state manager token
    LONG        BufferingToken;

    // List Entry to thread together all the FCB instances marked
    // for garbage collection/scavenging.

    LIST_ENTRY    ScavengerFinalizationList;

    // The list of contexts whose processing has been suspended pending the state
    // transition of the SRV_OPEN.

    LIST_ENTRY    TransitionWaitList;

    // List Head for the list of FOBXs associated with this SRV_OPEN

    LIST_ENTRY    FobxList;

    // The colocated instance of FOBX that is allocated whenever a SRV_OPEN
    // instance is allocated.

    PFOBX         InternalFobx;

    // the data structure for maintaining the mapping between the key
    // associated with the SRV_OPEN instance by the mini redirector and
    // the SRV_OPEN instance

    union {
       LIST_ENTRY SrvOpenKeyList;
       ULONG      SequenceNumber;
    };

    // Field indicating the success of the open when the Condition field is
    // set to Condition_Bad so that the status that led a different thread
    // to fail can be returned.
    NTSTATUS      OpenStatus;
} SRV_OPEN;

#define RxWriteCacheingAllowed(Fcb,SrvOpen) \
      ( FlagOn((Fcb)->FcbState,FCB_STATE_WRITECACHEING_ENABLED) \
            && !FlagOn((SrvOpen)->Flags,SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING)  )


#define SRVOPEN_INIT_KEY (0)

// An FOBX contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the SRV_OPEN
//     c) context information about this open
//     ...
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// The FOBX points to the "fileobject extension", i.e.  all the stuff that
// is per fileobject is not stored there because the IO system provides
// fixed size filesystem objects (not a dig BTW, that's just the decision).
// The FOBX for any file object is referenced by the FsContext2 field in
// the fileobject.  Even tho the FOBX is ordinarily a terminus in the
// structure, it is currently refcounted anyway.

// The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
// The visible ones are defined above and the definitions for the invisible ones can be found
// in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
// to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
// enforced in defining new flags.


#define FOBX_FLAG_MATCH_ALL               (0x10000)

//  This tells us whether we allocated buffers to hold search templates.
//

#define FOBX_FLAG_FREE_UNICODE            (0x20000)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define FOBX_FLAG_USER_SET_LAST_WRITE     (0x40000)
#define FOBX_FLAG_USER_SET_LAST_ACCESS    (0x80000)
#define FOBX_FLAG_USER_SET_CREATION       (0x100000)
#define FOBX_FLAG_USER_SET_LAST_CHANGE    (0x200000)

//
//  This bit says the file object associated with this Fobx was opened for
//  read only access.

#define FOBX_FLAG_READ_ONLY               (0x400000)

//
//   the delete on close flag is used to track a file object that was opened with delete-on-close;
//   when this object is closed, we copy the bit to the fcb and make it global

#define FOBX_FLAG_DELETE_ON_CLOSE         (0x800000)

// this bits is used by minirdrs that do not have NT semantics. for example, the smbmini has
// to close a file before it can try a rename or delete. after the operation, we prevent people from
// getting back in.

#define FOBX_FLAG_SRVOPEN_CLOSED          (0x1000000)

//
// this bit is used to tell whether the original name was a UNC name so that
// we can return the name the same way

#define FOBX_FLAG_UNC_NAME                (0x2000000)

//
// this flag tells if this fobx is allocated as part of a larger structure

#define FOBX_FLAG_ENCLOSED_ALLOCATED      (0x4000000)


// this flag specfies if the FOBX was included in the count of dormant
// files against the server.
//

#define FOBX_FLAG_MARKED_AS_DORMANT       (0x8000000)

// this flag notes down the fact that some writes have been issued on this FOBX
// this is used to issue flushes on close

#define FOBX_FLAG_WRITES_ISSUED           (0x10000000)

typedef struct _FOBX {
    // the portion of FOBX visible to the mini redirectors
    union {
        MRX_FOBX;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_OPEN              SrvOpen;
        };
    };

    // a serial number....it wraps but not often
    ULONG         FobxSerialNumber;

    // list entry to wire the FOBX to the list of FOBXs maintained in
    // the associated SRV_OPEN

    LIST_ENTRY    FobxQLinks;

    // list entry to gather all the FOBX instance marked for garbage collection
    // scavenging

    LIST_ENTRY    ScavengerFinalizationList;

    // list entry to thread together all the FOBXs which have a pending close
    // operation.

    LIST_ENTRY    ClosePendingList;

    BOOLEAN       UpperFinalizationDone;
    BOOLEAN       ContainsWildCards;
    BOOLEAN       fOpenCountDecremented;

    ////
    ////  The field is compared with the similar field in the Fcb to determine
    ////  if the Ea's for a file have been modified.
    ////
    //
    //ULONG EaModificationCount;


    // Parameters depending on the type of file opened, pipe/file etc.

    union {

        struct {

            union {
                MRX_PIPE_HANDLE_INFORMATION;
                MRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;
            };

            LARGE_INTEGER CollectDataTime;
            ULONG         CollectDataSize;
            THROTTLING_STATE ThrottlingState;   //for peek and read om msgmodepipes

            // these serialization Qs must be together
            // and read must be the first

            LIST_ENTRY    ReadSerializationQueue;
            LIST_ENTRY    WriteSerializationQueue;
        } NamedPipe;

        struct {
            RXVBO PredictedReadOffset;
            RXVBO PredictedWriteOffset;
            THROTTLING_STATE LockThrottlingState;   //for locks
            LARGE_INTEGER LastLockOffset;
            LARGE_INTEGER LastLockRange;
        } DiskFile;
    } Specific;
} FOBX;
typedef FOBX *PFOBX;

#define FOBX_NUMBER_OF_SERIALIZATION_QUEUES 2

// The RDBSS wrapper relies upon ref. counting to mark the instances of
// various data structures. The following macros implement a debugging
// mechanism to track/log the reference counts associated with various
// data structures. A fine grained control to monitor each data structure
// separately is provided. Each of these can be further controlled to either
// print the tracking info or log it.

#define RDBSS_REF_TRACK_SRVCALL  (0x00000001)
#define RDBSS_REF_TRACK_NETROOT  (0x00000002)
#define RDBSS_REF_TRACK_VNETROOT (0x00000004)
#define RDBSS_REF_TRACK_NETFOBX  (0x00000008)
#define RDBSS_REF_TRACK_NETFCB   (0x00000010)
#define RDBSS_REF_TRACK_SRVOPEN  (0x00000020)

#define RX_LOG_REF_TRACKING      (0x80000000)
#define RX_PRINT_REF_TRACKING    (0x40000000)

// The reference count tracking mechanism is activated by setting the following
// variable to the appropriate value defined above.

extern ULONG RdbssReferenceTracingValue;

// Macros for tracking the line number and the file of each reference and
// derefernce on the data structure. on Non DBG builds they are defined as
// NOTHING. For each data structure the appropriate reference/dereference
// macro is defined, These should be used instead of raw manipulation of
// the reference counts.

#ifdef DBG
VOID
RxpTrackReference(
      ULONG   TraceType,
      PCHAR   FileName,
      ULONG   Line,
      PVOID   pInstance);

BOOLEAN
RxpTrackDereference(
      ULONG   TraceType,
      PCHAR   FileName,
      ULONG   Line,
      PVOID   pInstance);

#else
#define RxpTrackReference(Type,File,Line,pInstance)    NOTHING
#define RxpTrackDereference(Type,File,Line,pInstance)  NOTHING
#endif

#define REF_TRACING_ON(TraceMask)  (TraceMask & RdbssReferenceTracingValue)
#define PRINT_REF_COUNT(TYPE,Count)                                 \
        if (REF_TRACING_ON( RDBSS_REF_TRACK_ ## TYPE ) &&           \
            (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING)) { \
           DbgPrint("%ld\n",Count);                                 \
        }

#define RxReferenceSrvCallAtDpc(SrvCall)                                     \
   RxpTrackReference(RDBSS_REF_TRACK_SRVCALL,__FILE__,__LINE__,SrvCall);     \
   ASSERT(SrvCall->NodeReferenceCount > 1);                                  \
   InterlockedIncrement(&pSrvCall->NodeReferenceCount)

#define RxReferenceSrvCall(SrvCall)                                          \
   RxpTrackReference(RDBSS_REF_TRACK_SRVCALL,__FILE__,__LINE__,SrvCall);     \
   RxReference(SrvCall)

#define RxDereferenceSrvCall(SrvCall,LockHoldingState)                       \
   RxpTrackDereference(RDBSS_REF_TRACK_SRVCALL,__FILE__,__LINE__,SrvCall);   \
   RxDereference(SrvCall,LockHoldingState)

#define RxReferenceNetRoot(NetRoot)                                          \
   RxpTrackReference(RDBSS_REF_TRACK_NETROOT,__FILE__,__LINE__,NetRoot);     \
   RxReference(NetRoot)

#define RxDereferenceNetRoot(NetRoot,LockHoldingState)                       \
   RxpTrackDereference(RDBSS_REF_TRACK_NETROOT,__FILE__,__LINE__,NetRoot);   \
   RxDereference(NetRoot,LockHoldingState)

#define RxReferenceVNetRoot(VNetRoot)                                        \
   RxpTrackReference(RDBSS_REF_TRACK_VNETROOT,__FILE__,__LINE__,VNetRoot);   \
   RxReference(VNetRoot)

#define RxDereferenceVNetRoot(VNetRoot,LockHoldingState)                     \
   RxpTrackDereference(RDBSS_REF_TRACK_VNETROOT,__FILE__,__LINE__,VNetRoot); \
   RxDereference(VNetRoot,LockHoldingState)

#define RxReferenceNetFobx(NetFobx)                                          \
   RxpTrackReference(RDBSS_REF_TRACK_NETFOBX,__FILE__,__LINE__,NetFobx);     \
   RxReference(NetFobx)

#define RxDereferenceNetFobx(NetFobx,LockHoldingState)                       \
   RxpTrackDereference(RDBSS_REF_TRACK_NETFOBX,__FILE__,__LINE__,NetFobx);   \
   RxDereference(NetFobx,LockHoldingState)

#define RxReferenceSrvOpen(SrvOpen)                                          \
   RxpTrackReference(RDBSS_REF_TRACK_SRVOPEN,__FILE__,__LINE__,SrvOpen);     \
   RxReference(SrvOpen)

#define RxDereferenceSrvOpen(SrvOpen,LockHoldingState)                       \
   RxpTrackDereference(RDBSS_REF_TRACK_SRVOPEN,__FILE__,__LINE__,SrvOpen);   \
   RxDereference(SrvOpen,LockHoldingState)

#define RxReferenceNetFcb(NetFcb)                                            \
   RxpTrackReference(RDBSS_REF_TRACK_NETFCB,__FILE__,__LINE__,NetFcb);       \
   RxpReferenceNetFcb(NetFcb)

// the following macros manipulate the reference count and also return the
// status of the final derefence or finalize call. This results in the usage
// of the , operator.

#define RxDereferenceNetFcb(NetFcb)  ( \
   ((LONG)RxpTrackDereference(RDBSS_REF_TRACK_NETFCB,__FILE__,__LINE__,NetFcb)),     \
   RxpDereferenceNetFcb(NetFcb) )

#define RxDereferenceAndFinalizeNetFcb(NetFcb,RxContext,RecursiveFinalize,ForceFinalize) (\
   RxpTrackDereference(RDBSS_REF_TRACK_NETFCB,__FILE__,__LINE__,NetFcb),                 \
   RxpDereferenceAndFinalizeNetFcb(NetFcb,RxContext,RecursiveFinalize,ForceFinalize))    \

// Check for structure alignment errors

VOID
RxCheckFcbStructuresForAlignment(void);


//
// SRV_CALL related routines.
//

PSRV_CALL
RxCreateSrvCall (
    IN  PRX_CONTEXT      RxContext,
    IN  PUNICODE_STRING  Name,
    IN  PUNICODE_STRING  InnerNamePrefix       OPTIONAL
    );


#define RxWaitForStableSrvCall(SRVCALL,RXCONTEXT) {                                  \
    RxDbgTrace(0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)));    \
    RxWaitForStableCondition(&(SRVCALL)->Condition,&(SRVCALL)->TransitionWaitList,(RXCONTEXT),NULL); \
    }

#define RxWaitForStableSrvCall_Async(SRVCALL,RXCONTEXT,PNTSTATUS) {                                  \
    RxDbgTrace(0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)));    \
    RxWaitForStableCondition(&(SRVCALL)->Condition,&(SRVCALL)->TransitionWaitList,(RXCONTEXT),(PNTSTATUS)); \
    }

#define RxTransitionSrvCall(SRVCALL,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionSrvCall -- %lx Condition -- %ld\n",(SRVCALL),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(SRVCALL)->Condition,&(SRVCALL)->TransitionWaitList)

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    );


//
// NET_ROOT related routines.
//

PNET_ROOT
RxCreateNetRoot (
    IN  PSRV_CALL        SrvCall,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            NetRootFlags
    );

VOID
RxFinishNetRootInitialization (
    IN OUT PNET_ROOT        ThisNetRoot,
    IN  PMINIRDR_DISPATCH Dispatch,
    IN  PUNICODE_STRING  InnerNamePrefix,
    IN  ULONG            FcbSize,
    IN  ULONG            SrvOpenSize,
    IN  ULONG            FobxSize,
    IN  ULONG            NetRootFlags
    );


#define RxWaitForStableNetRoot(NETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetRoot -- %lx\n",(NETROOT)));    \
    RxWaitForStableCondition(&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetRoot(NETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetRoot -- %lx Condition -- %ld\n",(NETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList)

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    );

//
// V_NET_ROOT related routines
//

NTSTATUS
RxInitializeVNetRootParameters(
   PRX_CONTEXT RxContext,
   LUID             *pLogonId,
   ULONG            *pSessionId,
   PUNICODE_STRING  *pUserNamePtr,
   PUNICODE_STRING  *pUserDomainNamePtr,
   PUNICODE_STRING  *pPasswordPtr,
   ULONG            *pFlags
   );

VOID
RxUninitializeVNetRootParameters(
   PUNICODE_STRING  pUserName,
   PUNICODE_STRING  pUserDomainName,
   PUNICODE_STRING  pPassword,
   ULONG            *pFlags
   );

PV_NET_ROOT
RxCreateVNetRoot (
    IN  PRX_CONTEXT      RxContext,
    IN  PNET_ROOT        NetRoot,
    IN  PUNICODE_STRING  CanonicalName,
    IN  PUNICODE_STRING  LocalNetRootName,
    IN  PUNICODE_STRING  FilePath
    );

BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    );

#define RxWaitForStableVNetRoot(VNETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableVNetRoot -- %lx\n",(VNETROOT)));    \
    RxWaitForStableCondition(&(VNETROOT)->Condition,&(VNETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionVNetRoot(VNETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionVNetRoot -- %lx Condition -- %ld\n",(VNETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(VNETROOT)->Condition,&(VNETROOT)->TransitionWaitList)

//
// FCB related routines.
//

#define RxAcquireFileSizeLock(PFCB) { \
    ExAcquireFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}
#define RxReleaseFileSizeLock(PFCB) { \
    ExReleaseFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN     PLONGLONG FileSize
    );

VOID
RxGetFileSizeWithLock (
    IN     PFCB Fcb,
    OUT    PLONGLONG FileSize
    );

PFCB
RxCreateNetFcb (
    OUT PRX_CONTEXT     RxContext,
    IN  PV_NET_ROOT     VNetRoot,
    IN  PUNICODE_STRING Name
    );

#define RxWaitForStableNetFcb(FCB,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(FCB)));    \
    RxWaitForStableCondition(&(FCB)->Condition,&(FCB)->NonPaged->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetFcb(FCB,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetFcb -- %lx Condition -- %ld\n",(FCB),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(FCB)->Condition,&(FCB)->NonPaged->TransitionWaitList)


#define RxFormInitPacket(IP,I1,I1a,I2,I3,I4a,I4b,I5,I6,I7) (\
            IP.pAttributes = I1, \
            IP.pNumLinks = I1a, \
            IP.pCreationTime = I2, \
            IP.pLastAccessTime = I3, \
            IP.pLastWriteTime = I4a, \
            IP.pLastChangeTime = I4b, \
            IP.pAllocationSize = I5, \
            IP.pFileSize = I6, \
            IP.pValidDataLength = I7, \
          &IP)

#if DBG
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb) {\
    ASSERT( ___thisfcb->NonPaged == ___thisfcb->CopyOfNonPaged );       \
    ASSERT( ___thisfcb->NonPaged->FcbBackPointer == ___thisfcb );       \
    }
#else
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb)
#endif

#define ASSERT_CORRECT_FCB_STRUCTURE(THIS_FCB__) { \
    ASSERT( NodeTypeIsFcb(THIS_FCB__));                                 \
    ASSERT( THIS_FCB__->NonPaged != NULL );                             \
    ASSERT( NodeType(THIS_FCB__->NonPaged) == RDBSS_NTC_NONPAGED_FCB);  \
    ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(THIS_FCB__) \
    }

RX_FILE_TYPE
RxInferFileType(
    IN PRX_CONTEXT RxContext
    );

VOID
RxFinishFcbInitialization(
    IN OUT PMRX_FCB Fcb,
    IN RX_FILE_TYPE FileType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    );

#define RxWaitForStableSrvOpen(SRVOPEN,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(SRVOPEN)));    \
    RxWaitForStableCondition(&(SRVOPEN)->Condition,&(SRVOPEN)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionSrvOpen(SRVOPEN,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionSrvOpen -- %lx Condition -- %ld\n",(SRVOPEN),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(SRVOPEN)->Condition,&(SRVOPEN)->TransitionWaitList)

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    );

VOID
RxpReferenceNetFcb(
   PFCB pFcb);

LONG
RxpDereferenceNetFcb(
   PFCB                pFcb);

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN  PRX_CONTEXT pRxContext,
    IN  BOOLEAN     RecursiveFinalize,
    IN  BOOLEAN     ForceFinalize
    );


#if DBG
extern BOOLEAN RxLoudFcbOpsOnExes;
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING   Name
    );
#else
#define RxLoudFcbMsg(a,b) (FALSE)
#endif


//
// SRV_OPEN related methods
//

PSRV_OPEN
RxCreateSrvOpen (
    IN     PV_NET_ROOT pVNetRoot,
    IN OUT PFCB        pFcb);

VOID
RxTransitionSrvOpenState (
    OUT PSRV_OPEN ThisSrvOpen,
    IN  RX_BLOCK_CONDITION Condition
    );

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    );

#if 0
#else
INLINE PUNICODE_STRING
GET_ALREADY_PREFIXED_NAME(
    PMRX_SRV_OPEN SrvOpen,
    PMRX_FCB      pFcb)
{
    PFCB capFcb = (PFCB)pFcb;

#if DBG
    if (SrvOpen != NULL ) {
        ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
        ASSERT( pFcb != NULL );
        ASSERT( NodeTypeIsFcb(pFcb) );
        ASSERT( SrvOpen->pFcb == pFcb );
        ASSERT( SrvOpen->pAlreadyPrefixedName == &capFcb->PrivateAlreadyPrefixedName );
    }
#endif

    return(&capFcb->PrivateAlreadyPrefixedName);
}
#endif

#define GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(rxcontext) \
        (GET_ALREADY_PREFIXED_NAME((rxcontext)->pRelevantSrvOpen,(rxcontext)->pFcb))


//
// FOBX related routines
//

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT    RxContext,
    IN  PMRX_SRV_OPEN  mrxSrvOpen
    );

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize
    );

#endif // _FCB_STRUCTS_DEFINED_









#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\filterpipeline.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for filterpipeline.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __filterpipeline_h__
#define __filterpipeline_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPrintReadStream_FWD_DEFINED__
#define __IPrintReadStream_FWD_DEFINED__
typedef interface IPrintReadStream IPrintReadStream;
#endif 	/* __IPrintReadStream_FWD_DEFINED__ */


#ifndef __IPrintWriteStream_FWD_DEFINED__
#define __IPrintWriteStream_FWD_DEFINED__
typedef interface IPrintWriteStream IPrintWriteStream;
#endif 	/* __IPrintWriteStream_FWD_DEFINED__ */


#ifndef __IInterFilterCommunicator_FWD_DEFINED__
#define __IInterFilterCommunicator_FWD_DEFINED__
typedef interface IInterFilterCommunicator IInterFilterCommunicator;
#endif 	/* __IInterFilterCommunicator_FWD_DEFINED__ */


#ifndef __IPrintPipelineManagerControl_FWD_DEFINED__
#define __IPrintPipelineManagerControl_FWD_DEFINED__
typedef interface IPrintPipelineManagerControl IPrintPipelineManagerControl;
#endif 	/* __IPrintPipelineManagerControl_FWD_DEFINED__ */


#ifndef __IPrintPipelinePropertyBag_FWD_DEFINED__
#define __IPrintPipelinePropertyBag_FWD_DEFINED__
typedef interface IPrintPipelinePropertyBag IPrintPipelinePropertyBag;
#endif 	/* __IPrintPipelinePropertyBag_FWD_DEFINED__ */


#ifndef __IPrintPipelineProgressReport_FWD_DEFINED__
#define __IPrintPipelineProgressReport_FWD_DEFINED__
typedef interface IPrintPipelineProgressReport IPrintPipelineProgressReport;
#endif 	/* __IPrintPipelineProgressReport_FWD_DEFINED__ */


#ifndef __IPrintClassObjectFactory_FWD_DEFINED__
#define __IPrintClassObjectFactory_FWD_DEFINED__
typedef interface IPrintClassObjectFactory IPrintClassObjectFactory;
#endif 	/* __IPrintClassObjectFactory_FWD_DEFINED__ */


#ifndef __IPrintPipelineFilter_FWD_DEFINED__
#define __IPrintPipelineFilter_FWD_DEFINED__
typedef interface IPrintPipelineFilter IPrintPipelineFilter;
#endif 	/* __IPrintPipelineFilter_FWD_DEFINED__ */


#ifndef __IXpsDocumentProvider_FWD_DEFINED__
#define __IXpsDocumentProvider_FWD_DEFINED__
typedef interface IXpsDocumentProvider IXpsDocumentProvider;
#endif 	/* __IXpsDocumentProvider_FWD_DEFINED__ */


#ifndef __IXpsDocumentConsumer_FWD_DEFINED__
#define __IXpsDocumentConsumer_FWD_DEFINED__
typedef interface IXpsDocumentConsumer IXpsDocumentConsumer;
#endif 	/* __IXpsDocumentConsumer_FWD_DEFINED__ */


#ifndef __IXpsDocument_FWD_DEFINED__
#define __IXpsDocument_FWD_DEFINED__
typedef interface IXpsDocument IXpsDocument;
#endif 	/* __IXpsDocument_FWD_DEFINED__ */


#ifndef __IFixedDocumentSequence_FWD_DEFINED__
#define __IFixedDocumentSequence_FWD_DEFINED__
typedef interface IFixedDocumentSequence IFixedDocumentSequence;
#endif 	/* __IFixedDocumentSequence_FWD_DEFINED__ */


#ifndef __IFixedDocument_FWD_DEFINED__
#define __IFixedDocument_FWD_DEFINED__
typedef interface IFixedDocument IFixedDocument;
#endif 	/* __IFixedDocument_FWD_DEFINED__ */


#ifndef __IPartBase_FWD_DEFINED__
#define __IPartBase_FWD_DEFINED__
typedef interface IPartBase IPartBase;
#endif 	/* __IPartBase_FWD_DEFINED__ */


#ifndef __IFixedPage_FWD_DEFINED__
#define __IFixedPage_FWD_DEFINED__
typedef interface IFixedPage IFixedPage;
#endif 	/* __IFixedPage_FWD_DEFINED__ */


#ifndef __IPartImage_FWD_DEFINED__
#define __IPartImage_FWD_DEFINED__
typedef interface IPartImage IPartImage;
#endif 	/* __IPartImage_FWD_DEFINED__ */


#ifndef __IPartFont_FWD_DEFINED__
#define __IPartFont_FWD_DEFINED__
typedef interface IPartFont IPartFont;
#endif 	/* __IPartFont_FWD_DEFINED__ */


#ifndef __IPartFont2_FWD_DEFINED__
#define __IPartFont2_FWD_DEFINED__
typedef interface IPartFont2 IPartFont2;
#endif 	/* __IPartFont2_FWD_DEFINED__ */


#ifndef __IPartThumbnail_FWD_DEFINED__
#define __IPartThumbnail_FWD_DEFINED__
typedef interface IPartThumbnail IPartThumbnail;
#endif 	/* __IPartThumbnail_FWD_DEFINED__ */


#ifndef __IPartPrintTicket_FWD_DEFINED__
#define __IPartPrintTicket_FWD_DEFINED__
typedef interface IPartPrintTicket IPartPrintTicket;
#endif 	/* __IPartPrintTicket_FWD_DEFINED__ */


#ifndef __IPartColorProfile_FWD_DEFINED__
#define __IPartColorProfile_FWD_DEFINED__
typedef interface IPartColorProfile IPartColorProfile;
#endif 	/* __IPartColorProfile_FWD_DEFINED__ */


#ifndef __IPartResourceDictionary_FWD_DEFINED__
#define __IPartResourceDictionary_FWD_DEFINED__
typedef interface IPartResourceDictionary IPartResourceDictionary;
#endif 	/* __IPartResourceDictionary_FWD_DEFINED__ */


#ifndef __IXpsPartIterator_FWD_DEFINED__
#define __IXpsPartIterator_FWD_DEFINED__
typedef interface IXpsPartIterator IXpsPartIterator;
#endif 	/* __IXpsPartIterator_FWD_DEFINED__ */


#ifndef __IPrintReadStreamFactory_FWD_DEFINED__
#define __IPrintReadStreamFactory_FWD_DEFINED__
typedef interface IPrintReadStreamFactory IPrintReadStreamFactory;
#endif 	/* __IPrintReadStreamFactory_FWD_DEFINED__ */


#ifndef __IPartDiscardControl_FWD_DEFINED__
#define __IPartDiscardControl_FWD_DEFINED__
typedef interface IPartDiscardControl IPartDiscardControl;
#endif 	/* __IPartDiscardControl_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "imgerror.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_filterpipeline_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#define E_ELEMENT_NOT_FOUND  HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
#define XPS_FP_PRINTER_NAME         L"PrinterName"
#define XPS_FP_PROGRESS_REPORT      L"ProgressReport"
#define XPS_FP_PRINTER_HANDLE       L"PrinterHandle"
#define XPS_FP_USER_PRINT_TICKET    L"PerUserPrintTicket"
#define XPS_FP_USER_TOKEN           L"UserSecurityToken"
#define XPS_FP_JOB_ID               L"PrintJobId"
#define XPS_FP_PRINT_CLASS_FACTORY  L"PrintClassFactory"






















typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_filterpipeline_0000_0000_0001
    {	Compression_NotCompressed	= 0,
	Compression_Normal	= ( Compression_NotCompressed + 1 ) ,
	Compression_Small	= ( Compression_Normal + 1 ) ,
	Compression_Fast	= ( Compression_Small + 1 ) 
    } 	EXpsCompressionOptions;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_filterpipeline_0000_0000_0002
    {	Font_Normal	= 0,
	Font_Obfusticate	= ( Font_Normal + 1 ) 
    } 	EXpsFontOptions;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_filterpipeline_0000_0000_0003
    {	XpsJob_DocumentSequenceAdded	= 0,
	XpsJob_FixedDocumentAdded	= ( XpsJob_DocumentSequenceAdded + 1 ) ,
	XpsJob_FixedPageAdded	= ( XpsJob_FixedDocumentAdded + 1 ) 
    } 	EXpsJobConsumption;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_filterpipeline_0000_0000_0004
    {	Xps_Restricted_Font_Installable	= 0,
	Xps_Restricted_Font_NoEmbedding	= 0x2,
	Xps_Restricted_Font_PreviewPrint	= 0x4,
	Xps_Restricted_Font_Editable	= 0x8
    } 	EXpsFontRestriction;



extern RPC_IF_HANDLE __MIDL_itf_filterpipeline_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_filterpipeline_0000_0000_v0_0_s_ifspec;

#ifndef __IPrintReadStream_INTERFACE_DEFINED__
#define __IPrintReadStream_INTERFACE_DEFINED__

/* interface IPrintReadStream */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintReadStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d47a67c-66cc-4430-850e-daf466fe5bc4")
    IPrintReadStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LONGLONG dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULONGLONG *plibNewPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadBytes( 
            /* [length_is][size_is][out] */ void *pvBuffer,
            /* [in] */ ULONG cbRequested,
            /* [out] */ ULONG *pcbRead,
            /* [out] */ BOOL *pbEndOfFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintReadStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintReadStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintReadStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintReadStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IPrintReadStream * This,
            /* [in] */ LONGLONG dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULONGLONG *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *ReadBytes )( 
            IPrintReadStream * This,
            /* [length_is][size_is][out] */ void *pvBuffer,
            /* [in] */ ULONG cbRequested,
            /* [out] */ ULONG *pcbRead,
            /* [out] */ BOOL *pbEndOfFile);
        
        END_INTERFACE
    } IPrintReadStreamVtbl;

    interface IPrintReadStream
    {
        CONST_VTBL struct IPrintReadStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintReadStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintReadStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintReadStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintReadStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IPrintReadStream_ReadBytes(This,pvBuffer,cbRequested,pcbRead,pbEndOfFile)	\
    ( (This)->lpVtbl -> ReadBytes(This,pvBuffer,cbRequested,pcbRead,pbEndOfFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintReadStream_INTERFACE_DEFINED__ */


#ifndef __IPrintWriteStream_INTERFACE_DEFINED__
#define __IPrintWriteStream_INTERFACE_DEFINED__

/* interface IPrintWriteStream */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintWriteStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65bb7f1b-371e-4571-8ac7-912f510c1a38")
    IPrintWriteStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WriteBytes( 
            /* [size_is][in] */ const void *pvBuffer,
            /* [in] */ ULONG cbBuffer,
            /* [out] */ ULONG *pcbWritten) = 0;
        
        virtual void STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintWriteStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintWriteStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintWriteStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintWriteStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteBytes )( 
            IPrintWriteStream * This,
            /* [size_is][in] */ const void *pvBuffer,
            /* [in] */ ULONG cbBuffer,
            /* [out] */ ULONG *pcbWritten);
        
        void ( STDMETHODCALLTYPE *Close )( 
            IPrintWriteStream * This);
        
        END_INTERFACE
    } IPrintWriteStreamVtbl;

    interface IPrintWriteStream
    {
        CONST_VTBL struct IPrintWriteStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintWriteStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintWriteStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintWriteStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintWriteStream_WriteBytes(This,pvBuffer,cbBuffer,pcbWritten)	\
    ( (This)->lpVtbl -> WriteBytes(This,pvBuffer,cbBuffer,pcbWritten) ) 

#define IPrintWriteStream_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintWriteStream_INTERFACE_DEFINED__ */


#ifndef __IInterFilterCommunicator_INTERFACE_DEFINED__
#define __IInterFilterCommunicator_INTERFACE_DEFINED__

/* interface IInterFilterCommunicator */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IInterFilterCommunicator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4daf1e69-81fd-462d-940f-8cd3ddf56fca")
    IInterFilterCommunicator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestReader( 
            /* [out] */ void **ppIReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestWriter( 
            /* [out] */ void **ppIWriter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInterFilterCommunicatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInterFilterCommunicator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInterFilterCommunicator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInterFilterCommunicator * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestReader )( 
            IInterFilterCommunicator * This,
            /* [out] */ void **ppIReader);
        
        HRESULT ( STDMETHODCALLTYPE *RequestWriter )( 
            IInterFilterCommunicator * This,
            /* [out] */ void **ppIWriter);
        
        END_INTERFACE
    } IInterFilterCommunicatorVtbl;

    interface IInterFilterCommunicator
    {
        CONST_VTBL struct IInterFilterCommunicatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterFilterCommunicator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInterFilterCommunicator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInterFilterCommunicator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInterFilterCommunicator_RequestReader(This,ppIReader)	\
    ( (This)->lpVtbl -> RequestReader(This,ppIReader) ) 

#define IInterFilterCommunicator_RequestWriter(This,ppIWriter)	\
    ( (This)->lpVtbl -> RequestWriter(This,ppIWriter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInterFilterCommunicator_INTERFACE_DEFINED__ */


#ifndef __IPrintPipelineManagerControl_INTERFACE_DEFINED__
#define __IPrintPipelineManagerControl_INTERFACE_DEFINED__

/* interface IPrintPipelineManagerControl */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintPipelineManagerControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa3e4910-5889-4681-91ef-823ad4ed4e44")
    IPrintPipelineManagerControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestShutdown( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ IImgErrorInfo *pReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterFinished( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintPipelineManagerControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintPipelineManagerControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintPipelineManagerControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintPipelineManagerControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestShutdown )( 
            IPrintPipelineManagerControl * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ IImgErrorInfo *pReason);
        
        HRESULT ( STDMETHODCALLTYPE *FilterFinished )( 
            IPrintPipelineManagerControl * This);
        
        END_INTERFACE
    } IPrintPipelineManagerControlVtbl;

    interface IPrintPipelineManagerControl
    {
        CONST_VTBL struct IPrintPipelineManagerControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintPipelineManagerControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintPipelineManagerControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintPipelineManagerControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintPipelineManagerControl_RequestShutdown(This,hrReason,pReason)	\
    ( (This)->lpVtbl -> RequestShutdown(This,hrReason,pReason) ) 

#define IPrintPipelineManagerControl_FilterFinished(This)	\
    ( (This)->lpVtbl -> FilterFinished(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintPipelineManagerControl_INTERFACE_DEFINED__ */


#ifndef __IPrintPipelinePropertyBag_INTERFACE_DEFINED__
#define __IPrintPipelinePropertyBag_INTERFACE_DEFINED__

/* interface IPrintPipelinePropertyBag */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintPipelinePropertyBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b8c99dc-7892-4a95-8a04-57422e9fbb47")
    IPrintPipelinePropertyBag : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProperty( 
            /* [string][in] */ const wchar_t *pszName,
            /* [in] */ const VARIANT *pVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [string][in] */ const wchar_t *pszName,
            /* [out] */ VARIANT *pVar) = 0;
        
        virtual BOOL STDMETHODCALLTYPE DeleteProperty( 
            /* [string][in] */ const wchar_t *pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintPipelinePropertyBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintPipelinePropertyBag * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintPipelinePropertyBag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintPipelinePropertyBag * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddProperty )( 
            IPrintPipelinePropertyBag * This,
            /* [string][in] */ const wchar_t *pszName,
            /* [in] */ const VARIANT *pVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IPrintPipelinePropertyBag * This,
            /* [string][in] */ const wchar_t *pszName,
            /* [out] */ VARIANT *pVar);
        
        BOOL ( STDMETHODCALLTYPE *DeleteProperty )( 
            IPrintPipelinePropertyBag * This,
            /* [string][in] */ const wchar_t *pszName);
        
        END_INTERFACE
    } IPrintPipelinePropertyBagVtbl;

    interface IPrintPipelinePropertyBag
    {
        CONST_VTBL struct IPrintPipelinePropertyBagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintPipelinePropertyBag_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintPipelinePropertyBag_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintPipelinePropertyBag_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintPipelinePropertyBag_AddProperty(This,pszName,pVar)	\
    ( (This)->lpVtbl -> AddProperty(This,pszName,pVar) ) 

#define IPrintPipelinePropertyBag_GetProperty(This,pszName,pVar)	\
    ( (This)->lpVtbl -> GetProperty(This,pszName,pVar) ) 

#define IPrintPipelinePropertyBag_DeleteProperty(This,pszName)	\
    ( (This)->lpVtbl -> DeleteProperty(This,pszName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintPipelinePropertyBag_INTERFACE_DEFINED__ */


#ifndef __IPrintPipelineProgressReport_INTERFACE_DEFINED__
#define __IPrintPipelineProgressReport_INTERFACE_DEFINED__

/* interface IPrintPipelineProgressReport */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintPipelineProgressReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("edc12c7c-ed40-4ea5-96a6-5e4397497a61")
    IPrintPipelineProgressReport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [in] */ EXpsJobConsumption update) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintPipelineProgressReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintPipelineProgressReport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintPipelineProgressReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintPipelineProgressReport * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReportProgress )( 
            IPrintPipelineProgressReport * This,
            /* [in] */ EXpsJobConsumption update);
        
        END_INTERFACE
    } IPrintPipelineProgressReportVtbl;

    interface IPrintPipelineProgressReport
    {
        CONST_VTBL struct IPrintPipelineProgressReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintPipelineProgressReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintPipelineProgressReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintPipelineProgressReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintPipelineProgressReport_ReportProgress(This,update)	\
    ( (This)->lpVtbl -> ReportProgress(This,update) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintPipelineProgressReport_INTERFACE_DEFINED__ */


#ifndef __IPrintClassObjectFactory_INTERFACE_DEFINED__
#define __IPrintClassObjectFactory_INTERFACE_DEFINED__

/* interface IPrintClassObjectFactory */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintClassObjectFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9af593dd-9b02-48a8-9bad-69ace423f88b")
    IPrintClassObjectFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrintClassObject( 
            /* [string][in] */ const wchar_t *pszPrinterName,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppNewObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintClassObjectFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintClassObjectFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintClassObjectFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintClassObjectFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintClassObject )( 
            IPrintClassObjectFactory * This,
            /* [string][in] */ const wchar_t *pszPrinterName,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppNewObject);
        
        END_INTERFACE
    } IPrintClassObjectFactoryVtbl;

    interface IPrintClassObjectFactory
    {
        CONST_VTBL struct IPrintClassObjectFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintClassObjectFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintClassObjectFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintClassObjectFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintClassObjectFactory_GetPrintClassObject(This,pszPrinterName,riid,ppNewObject)	\
    ( (This)->lpVtbl -> GetPrintClassObject(This,pszPrinterName,riid,ppNewObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintClassObjectFactory_INTERFACE_DEFINED__ */


#ifndef __IPrintPipelineFilter_INTERFACE_DEFINED__
#define __IPrintPipelineFilter_INTERFACE_DEFINED__

/* interface IPrintPipelineFilter */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintPipelineFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cdb62fc0-8bed-434e-86fb-a2cae55f19ea")
    IPrintPipelineFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFilter( 
            /* [in] */ IInterFilterCommunicator *pINegotiation,
            /* [in] */ IPrintPipelinePropertyBag *pIPropertyBag,
            /* [in] */ IPrintPipelineManagerControl *pIPipelineControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShutdownOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartOperation( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintPipelineFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintPipelineFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintPipelineFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintPipelineFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFilter )( 
            IPrintPipelineFilter * This,
            /* [in] */ IInterFilterCommunicator *pINegotiation,
            /* [in] */ IPrintPipelinePropertyBag *pIPropertyBag,
            /* [in] */ IPrintPipelineManagerControl *pIPipelineControl);
        
        HRESULT ( STDMETHODCALLTYPE *ShutdownOperation )( 
            IPrintPipelineFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartOperation )( 
            IPrintPipelineFilter * This);
        
        END_INTERFACE
    } IPrintPipelineFilterVtbl;

    interface IPrintPipelineFilter
    {
        CONST_VTBL struct IPrintPipelineFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintPipelineFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintPipelineFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintPipelineFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintPipelineFilter_InitializeFilter(This,pINegotiation,pIPropertyBag,pIPipelineControl)	\
    ( (This)->lpVtbl -> InitializeFilter(This,pINegotiation,pIPropertyBag,pIPipelineControl) ) 

#define IPrintPipelineFilter_ShutdownOperation(This)	\
    ( (This)->lpVtbl -> ShutdownOperation(This) ) 

#define IPrintPipelineFilter_StartOperation(This)	\
    ( (This)->lpVtbl -> StartOperation(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintPipelineFilter_INTERFACE_DEFINED__ */


#ifndef __IXpsDocumentProvider_INTERFACE_DEFINED__
#define __IXpsDocumentProvider_INTERFACE_DEFINED__

/* interface IXpsDocumentProvider */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IXpsDocumentProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b8cf8530-5562-47c4-ab67-b1f69ecf961e")
    IXpsDocumentProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetXpsPart( 
            /* [out] */ IUnknown **ppIXpsPart) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsDocumentProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsDocumentProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsDocumentProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsDocumentProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetXpsPart )( 
            IXpsDocumentProvider * This,
            /* [out] */ IUnknown **ppIXpsPart);
        
        END_INTERFACE
    } IXpsDocumentProviderVtbl;

    interface IXpsDocumentProvider
    {
        CONST_VTBL struct IXpsDocumentProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsDocumentProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsDocumentProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsDocumentProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsDocumentProvider_GetXpsPart(This,ppIXpsPart)	\
    ( (This)->lpVtbl -> GetXpsPart(This,ppIXpsPart) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsDocumentProvider_INTERFACE_DEFINED__ */


#ifndef __IXpsDocumentConsumer_INTERFACE_DEFINED__
#define __IXpsDocumentConsumer_INTERFACE_DEFINED__

/* interface IXpsDocumentConsumer */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IXpsDocumentConsumer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4368d8a2-4181-4a9f-b295-3d9a38bb9ba0")
    IXpsDocumentConsumer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendXpsUnknown( 
            /* [in] */ IUnknown *pUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendXpsDocument( 
            /* [in] */ IXpsDocument *pIXpsDocument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendFixedDocumentSequence( 
            /* [in] */ IFixedDocumentSequence *pIFixedDocumentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendFixedDocument( 
            /* [in] */ IFixedDocument *pIFixedDocument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendFixedPage( 
            /* [in] */ IFixedPage *pIFixedPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseSender( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNewEmptyPart( 
            /* [string][in] */ const wchar_t *uri,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppNewObject,
            /* [out] */ IPrintWriteStream **ppWriteStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsDocumentConsumerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsDocumentConsumer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsDocumentConsumer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsDocumentConsumer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendXpsUnknown )( 
            IXpsDocumentConsumer * This,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *SendXpsDocument )( 
            IXpsDocumentConsumer * This,
            /* [in] */ IXpsDocument *pIXpsDocument);
        
        HRESULT ( STDMETHODCALLTYPE *SendFixedDocumentSequence )( 
            IXpsDocumentConsumer * This,
            /* [in] */ IFixedDocumentSequence *pIFixedDocumentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *SendFixedDocument )( 
            IXpsDocumentConsumer * This,
            /* [in] */ IFixedDocument *pIFixedDocument);
        
        HRESULT ( STDMETHODCALLTYPE *SendFixedPage )( 
            IXpsDocumentConsumer * This,
            /* [in] */ IFixedPage *pIFixedPage);
        
        HRESULT ( STDMETHODCALLTYPE *CloseSender )( 
            IXpsDocumentConsumer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewEmptyPart )( 
            IXpsDocumentConsumer * This,
            /* [string][in] */ const wchar_t *uri,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppNewObject,
            /* [out] */ IPrintWriteStream **ppWriteStream);
        
        END_INTERFACE
    } IXpsDocumentConsumerVtbl;

    interface IXpsDocumentConsumer
    {
        CONST_VTBL struct IXpsDocumentConsumerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsDocumentConsumer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsDocumentConsumer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsDocumentConsumer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsDocumentConsumer_SendXpsUnknown(This,pUnknown)	\
    ( (This)->lpVtbl -> SendXpsUnknown(This,pUnknown) ) 

#define IXpsDocumentConsumer_SendXpsDocument(This,pIXpsDocument)	\
    ( (This)->lpVtbl -> SendXpsDocument(This,pIXpsDocument) ) 

#define IXpsDocumentConsumer_SendFixedDocumentSequence(This,pIFixedDocumentSequence)	\
    ( (This)->lpVtbl -> SendFixedDocumentSequence(This,pIFixedDocumentSequence) ) 

#define IXpsDocumentConsumer_SendFixedDocument(This,pIFixedDocument)	\
    ( (This)->lpVtbl -> SendFixedDocument(This,pIFixedDocument) ) 

#define IXpsDocumentConsumer_SendFixedPage(This,pIFixedPage)	\
    ( (This)->lpVtbl -> SendFixedPage(This,pIFixedPage) ) 

#define IXpsDocumentConsumer_CloseSender(This)	\
    ( (This)->lpVtbl -> CloseSender(This) ) 

#define IXpsDocumentConsumer_GetNewEmptyPart(This,uri,riid,ppNewObject,ppWriteStream)	\
    ( (This)->lpVtbl -> GetNewEmptyPart(This,uri,riid,ppNewObject,ppWriteStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsDocumentConsumer_INTERFACE_DEFINED__ */


#ifndef __IXpsDocument_INTERFACE_DEFINED__
#define __IXpsDocument_INTERFACE_DEFINED__

/* interface IXpsDocument */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IXpsDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e8d907db-62a9-4a95-abe7-e01763dd30f8")
    IXpsDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThumbnail( 
            /* [out] */ IPartThumbnail **ppThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnail( 
            /* [in] */ IPartThumbnail *pThumbnail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnail )( 
            IXpsDocument * This,
            /* [out] */ IPartThumbnail **ppThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnail )( 
            IXpsDocument * This,
            /* [in] */ IPartThumbnail *pThumbnail);
        
        END_INTERFACE
    } IXpsDocumentVtbl;

    interface IXpsDocument
    {
        CONST_VTBL struct IXpsDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsDocument_GetThumbnail(This,ppThumbnail)	\
    ( (This)->lpVtbl -> GetThumbnail(This,ppThumbnail) ) 

#define IXpsDocument_SetThumbnail(This,pThumbnail)	\
    ( (This)->lpVtbl -> SetThumbnail(This,pThumbnail) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsDocument_INTERFACE_DEFINED__ */


#ifndef __IFixedDocumentSequence_INTERFACE_DEFINED__
#define __IFixedDocumentSequence_INTERFACE_DEFINED__

/* interface IFixedDocumentSequence */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IFixedDocumentSequence;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8028d181-2c32-4249-8493-1bfb22045574")
    IFixedDocumentSequence : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUri( 
            /* [out] */ BSTR *uri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicket( 
            /* [out] */ IPartPrintTicket **ppPrintTicket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicket( 
            /* [in] */ IPartPrintTicket *pPrintTicket) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFixedDocumentSequenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFixedDocumentSequence * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFixedDocumentSequence * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFixedDocumentSequence * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IFixedDocumentSequence * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicket )( 
            IFixedDocumentSequence * This,
            /* [out] */ IPartPrintTicket **ppPrintTicket);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicket )( 
            IFixedDocumentSequence * This,
            /* [in] */ IPartPrintTicket *pPrintTicket);
        
        END_INTERFACE
    } IFixedDocumentSequenceVtbl;

    interface IFixedDocumentSequence
    {
        CONST_VTBL struct IFixedDocumentSequenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFixedDocumentSequence_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFixedDocumentSequence_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFixedDocumentSequence_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFixedDocumentSequence_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IFixedDocumentSequence_GetPrintTicket(This,ppPrintTicket)	\
    ( (This)->lpVtbl -> GetPrintTicket(This,ppPrintTicket) ) 

#define IFixedDocumentSequence_SetPrintTicket(This,pPrintTicket)	\
    ( (This)->lpVtbl -> SetPrintTicket(This,pPrintTicket) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFixedDocumentSequence_INTERFACE_DEFINED__ */


#ifndef __IFixedDocument_INTERFACE_DEFINED__
#define __IFixedDocument_INTERFACE_DEFINED__

/* interface IFixedDocument */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IFixedDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f222ca9f-9968-4db9-81bd-abaebf15f93f")
    IFixedDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUri( 
            /* [out] */ BSTR *uri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicket( 
            /* [out] */ IPartPrintTicket **ppPrintTicket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicket( 
            /* [in] */ IPartPrintTicket *pPrintTicket) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFixedDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFixedDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFixedDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFixedDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IFixedDocument * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicket )( 
            IFixedDocument * This,
            /* [out] */ IPartPrintTicket **ppPrintTicket);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicket )( 
            IFixedDocument * This,
            /* [in] */ IPartPrintTicket *pPrintTicket);
        
        END_INTERFACE
    } IFixedDocumentVtbl;

    interface IFixedDocument
    {
        CONST_VTBL struct IFixedDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFixedDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFixedDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFixedDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFixedDocument_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IFixedDocument_GetPrintTicket(This,ppPrintTicket)	\
    ( (This)->lpVtbl -> GetPrintTicket(This,ppPrintTicket) ) 

#define IFixedDocument_SetPrintTicket(This,pPrintTicket)	\
    ( (This)->lpVtbl -> SetPrintTicket(This,pPrintTicket) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFixedDocument_INTERFACE_DEFINED__ */


#ifndef __IPartBase_INTERFACE_DEFINED__
#define __IPartBase_INTERFACE_DEFINED__

/* interface IPartBase */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartBase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36d51e28-369e-43ba-a666-9540c62c3f58")
    IPartBase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUri( 
            /* [out] */ BSTR *uri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [out] */ IPrintReadStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPartCompression( 
            /* [out] */ EXpsCompressionOptions *pCompression) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPartCompression( 
            /* [in] */ EXpsCompressionOptions compression) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartBaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartBase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartBase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartBase * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartBase * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartBase * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartBase * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartBase * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        END_INTERFACE
    } IPartBaseVtbl;

    interface IPartBase
    {
        CONST_VTBL struct IPartBaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartBase_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartBase_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartBase_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartBase_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartBase_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartBase_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartBase_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartBase_INTERFACE_DEFINED__ */


#ifndef __IFixedPage_INTERFACE_DEFINED__
#define __IFixedPage_INTERFACE_DEFINED__

/* interface IFixedPage */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IFixedPage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d9f6448-7e95-4cb5-94fb-0180c2883a57")
    IFixedPage : public IPartBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicket( 
            /* [out] */ IPartPrintTicket **ppPrintTicket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPagePart( 
            /* [string][in] */ const wchar_t *uri,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriteStream( 
            /* [out] */ IPrintWriteStream **ppWriteStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicket( 
            /* [in] */ IPartPrintTicket *ppPrintTicket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPagePart( 
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteResource( 
            /* [string][in] */ const wchar_t *uri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXpsPartIterator( 
            /* [out] */ IXpsPartIterator **pXpsPartIt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFixedPageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFixedPage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFixedPage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFixedPage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IFixedPage * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IFixedPage * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IFixedPage * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IFixedPage * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicket )( 
            IFixedPage * This,
            /* [out] */ IPartPrintTicket **ppPrintTicket);
        
        HRESULT ( STDMETHODCALLTYPE *GetPagePart )( 
            IFixedPage * This,
            /* [string][in] */ const wchar_t *uri,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriteStream )( 
            IFixedPage * This,
            /* [out] */ IPrintWriteStream **ppWriteStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicket )( 
            IFixedPage * This,
            /* [in] */ IPartPrintTicket *ppPrintTicket);
        
        HRESULT ( STDMETHODCALLTYPE *SetPagePart )( 
            IFixedPage * This,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteResource )( 
            IFixedPage * This,
            /* [string][in] */ const wchar_t *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetXpsPartIterator )( 
            IFixedPage * This,
            /* [out] */ IXpsPartIterator **pXpsPartIt);
        
        END_INTERFACE
    } IFixedPageVtbl;

    interface IFixedPage
    {
        CONST_VTBL struct IFixedPageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFixedPage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFixedPage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFixedPage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFixedPage_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IFixedPage_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IFixedPage_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IFixedPage_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#define IFixedPage_GetPrintTicket(This,ppPrintTicket)	\
    ( (This)->lpVtbl -> GetPrintTicket(This,ppPrintTicket) ) 

#define IFixedPage_GetPagePart(This,uri,ppUnk)	\
    ( (This)->lpVtbl -> GetPagePart(This,uri,ppUnk) ) 

#define IFixedPage_GetWriteStream(This,ppWriteStream)	\
    ( (This)->lpVtbl -> GetWriteStream(This,ppWriteStream) ) 

#define IFixedPage_SetPrintTicket(This,ppPrintTicket)	\
    ( (This)->lpVtbl -> SetPrintTicket(This,ppPrintTicket) ) 

#define IFixedPage_SetPagePart(This,pUnk)	\
    ( (This)->lpVtbl -> SetPagePart(This,pUnk) ) 

#define IFixedPage_DeleteResource(This,uri)	\
    ( (This)->lpVtbl -> DeleteResource(This,uri) ) 

#define IFixedPage_GetXpsPartIterator(This,pXpsPartIt)	\
    ( (This)->lpVtbl -> GetXpsPartIterator(This,pXpsPartIt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFixedPage_INTERFACE_DEFINED__ */


#ifndef __IPartImage_INTERFACE_DEFINED__
#define __IPartImage_INTERFACE_DEFINED__

/* interface IPartImage */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("725f2e3c-401a-4705-9de0-fe6f1353b87f")
    IPartImage : public IPartBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImageProperties( 
            /* [out] */ BSTR *pContentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageContent( 
            /* [string][in] */ const wchar_t *pContentType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartImage * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartImage * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartImage * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartImage * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageProperties )( 
            IPartImage * This,
            /* [out] */ BSTR *pContentType);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageContent )( 
            IPartImage * This,
            /* [string][in] */ const wchar_t *pContentType);
        
        END_INTERFACE
    } IPartImageVtbl;

    interface IPartImage
    {
        CONST_VTBL struct IPartImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartImage_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartImage_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartImage_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartImage_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#define IPartImage_GetImageProperties(This,pContentType)	\
    ( (This)->lpVtbl -> GetImageProperties(This,pContentType) ) 

#define IPartImage_SetImageContent(This,pContentType)	\
    ( (This)->lpVtbl -> SetImageContent(This,pContentType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartImage_INTERFACE_DEFINED__ */


#ifndef __IPartFont_INTERFACE_DEFINED__
#define __IPartFont_INTERFACE_DEFINED__

/* interface IPartFont */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartFont;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e07fe0ab-1124-43d0-a865-e8ffb6a3ea82")
    IPartFont : public IPartBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFontProperties( 
            /* [out] */ BSTR *pContentType,
            /* [out] */ EXpsFontOptions *pFontOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFontContent( 
            /* [string][in] */ const wchar_t *pContentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFontOptions( 
            /* [in] */ EXpsFontOptions options) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartFontVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartFont * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartFont * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartFont * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartFont * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartFont * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartFont * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartFont * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontProperties )( 
            IPartFont * This,
            /* [out] */ BSTR *pContentType,
            /* [out] */ EXpsFontOptions *pFontOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontContent )( 
            IPartFont * This,
            /* [string][in] */ const wchar_t *pContentType);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontOptions )( 
            IPartFont * This,
            /* [in] */ EXpsFontOptions options);
        
        END_INTERFACE
    } IPartFontVtbl;

    interface IPartFont
    {
        CONST_VTBL struct IPartFontVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartFont_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartFont_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartFont_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartFont_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartFont_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartFont_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartFont_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#define IPartFont_GetFontProperties(This,pContentType,pFontOptions)	\
    ( (This)->lpVtbl -> GetFontProperties(This,pContentType,pFontOptions) ) 

#define IPartFont_SetFontContent(This,pContentType)	\
    ( (This)->lpVtbl -> SetFontContent(This,pContentType) ) 

#define IPartFont_SetFontOptions(This,options)	\
    ( (This)->lpVtbl -> SetFontOptions(This,options) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartFont_INTERFACE_DEFINED__ */


#ifndef __IPartFont2_INTERFACE_DEFINED__
#define __IPartFont2_INTERFACE_DEFINED__

/* interface IPartFont2 */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartFont2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("511e025f-d6cb-43be-bf65-63fe88515a39")
    IPartFont2 : public IPartFont
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFontRestriction( 
            /* [out] */ EXpsFontRestriction *pRestriction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartFont2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartFont2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartFont2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartFont2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartFont2 * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartFont2 * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartFont2 * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartFont2 * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontProperties )( 
            IPartFont2 * This,
            /* [out] */ BSTR *pContentType,
            /* [out] */ EXpsFontOptions *pFontOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontContent )( 
            IPartFont2 * This,
            /* [string][in] */ const wchar_t *pContentType);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontOptions )( 
            IPartFont2 * This,
            /* [in] */ EXpsFontOptions options);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontRestriction )( 
            IPartFont2 * This,
            /* [out] */ EXpsFontRestriction *pRestriction);
        
        END_INTERFACE
    } IPartFont2Vtbl;

    interface IPartFont2
    {
        CONST_VTBL struct IPartFont2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartFont2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartFont2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartFont2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartFont2_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartFont2_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartFont2_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartFont2_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#define IPartFont2_GetFontProperties(This,pContentType,pFontOptions)	\
    ( (This)->lpVtbl -> GetFontProperties(This,pContentType,pFontOptions) ) 

#define IPartFont2_SetFontContent(This,pContentType)	\
    ( (This)->lpVtbl -> SetFontContent(This,pContentType) ) 

#define IPartFont2_SetFontOptions(This,options)	\
    ( (This)->lpVtbl -> SetFontOptions(This,options) ) 


#define IPartFont2_GetFontRestriction(This,pRestriction)	\
    ( (This)->lpVtbl -> GetFontRestriction(This,pRestriction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartFont2_INTERFACE_DEFINED__ */


#ifndef __IPartThumbnail_INTERFACE_DEFINED__
#define __IPartThumbnail_INTERFACE_DEFINED__

/* interface IPartThumbnail */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartThumbnail;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("027ed1c9-ba39-4cc5-aa55-7ec3a0de171a")
    IPartThumbnail : public IPartBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThumbnailProperties( 
            /* [out] */ BSTR *pContentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnailContent( 
            /* [string][in] */ const wchar_t *pContentType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartThumbnailVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartThumbnail * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartThumbnail * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartThumbnail * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartThumbnail * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartThumbnail * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartThumbnail * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartThumbnail * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnailProperties )( 
            IPartThumbnail * This,
            /* [out] */ BSTR *pContentType);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailContent )( 
            IPartThumbnail * This,
            /* [string][in] */ const wchar_t *pContentType);
        
        END_INTERFACE
    } IPartThumbnailVtbl;

    interface IPartThumbnail
    {
        CONST_VTBL struct IPartThumbnailVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartThumbnail_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartThumbnail_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartThumbnail_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartThumbnail_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartThumbnail_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartThumbnail_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartThumbnail_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#define IPartThumbnail_GetThumbnailProperties(This,pContentType)	\
    ( (This)->lpVtbl -> GetThumbnailProperties(This,pContentType) ) 

#define IPartThumbnail_SetThumbnailContent(This,pContentType)	\
    ( (This)->lpVtbl -> SetThumbnailContent(This,pContentType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartThumbnail_INTERFACE_DEFINED__ */


#ifndef __IPartPrintTicket_INTERFACE_DEFINED__
#define __IPartPrintTicket_INTERFACE_DEFINED__

/* interface IPartPrintTicket */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartPrintTicket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a0f50f6-f9a2-41f0-99e7-5ae955be8e9e")
    IPartPrintTicket : public IPartBase
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPartPrintTicketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartPrintTicket * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartPrintTicket * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartPrintTicket * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartPrintTicket * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartPrintTicket * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartPrintTicket * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartPrintTicket * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        END_INTERFACE
    } IPartPrintTicketVtbl;

    interface IPartPrintTicket
    {
        CONST_VTBL struct IPartPrintTicketVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartPrintTicket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartPrintTicket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartPrintTicket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartPrintTicket_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartPrintTicket_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartPrintTicket_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartPrintTicket_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartPrintTicket_INTERFACE_DEFINED__ */


#ifndef __IPartColorProfile_INTERFACE_DEFINED__
#define __IPartColorProfile_INTERFACE_DEFINED__

/* interface IPartColorProfile */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartColorProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63cca95b-7d18-4762-b15e-98658693d24a")
    IPartColorProfile : public IPartBase
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPartColorProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartColorProfile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartColorProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartColorProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartColorProfile * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartColorProfile * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartColorProfile * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartColorProfile * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        END_INTERFACE
    } IPartColorProfileVtbl;

    interface IPartColorProfile
    {
        CONST_VTBL struct IPartColorProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartColorProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartColorProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartColorProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartColorProfile_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartColorProfile_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartColorProfile_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartColorProfile_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartColorProfile_INTERFACE_DEFINED__ */


#ifndef __IPartResourceDictionary_INTERFACE_DEFINED__
#define __IPartResourceDictionary_INTERFACE_DEFINED__

/* interface IPartResourceDictionary */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartResourceDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16cfce6d-e744-4fb3-b474-f1d54f024a01")
    IPartResourceDictionary : public IPartBase
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPartResourceDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartResourceDictionary * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartResourceDictionary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartResourceDictionary * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUri )( 
            IPartResourceDictionary * This,
            /* [out] */ BSTR *uri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPartResourceDictionary * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartCompression )( 
            IPartResourceDictionary * This,
            /* [out] */ EXpsCompressionOptions *pCompression);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartCompression )( 
            IPartResourceDictionary * This,
            /* [in] */ EXpsCompressionOptions compression);
        
        END_INTERFACE
    } IPartResourceDictionaryVtbl;

    interface IPartResourceDictionary
    {
        CONST_VTBL struct IPartResourceDictionaryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartResourceDictionary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartResourceDictionary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartResourceDictionary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartResourceDictionary_GetUri(This,uri)	\
    ( (This)->lpVtbl -> GetUri(This,uri) ) 

#define IPartResourceDictionary_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPartResourceDictionary_GetPartCompression(This,pCompression)	\
    ( (This)->lpVtbl -> GetPartCompression(This,pCompression) ) 

#define IPartResourceDictionary_SetPartCompression(This,compression)	\
    ( (This)->lpVtbl -> SetPartCompression(This,compression) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartResourceDictionary_INTERFACE_DEFINED__ */


#ifndef __IXpsPartIterator_INTERFACE_DEFINED__
#define __IXpsPartIterator_INTERFACE_DEFINED__

/* interface IXpsPartIterator */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IXpsPartIterator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0021d3cd-af6f-42ab-9999-14bc82a62d2e")
    IXpsPartIterator : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Current( 
            /* [out] */ BSTR *pUri,
            /* [out] */ IUnknown **ppXpsPart) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsDone( void) = 0;
        
        virtual void STDMETHODCALLTYPE Next( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsPartIteratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsPartIterator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsPartIterator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsPartIterator * This);
        
        void ( STDMETHODCALLTYPE *Reset )( 
            IXpsPartIterator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Current )( 
            IXpsPartIterator * This,
            /* [out] */ BSTR *pUri,
            /* [out] */ IUnknown **ppXpsPart);
        
        BOOL ( STDMETHODCALLTYPE *IsDone )( 
            IXpsPartIterator * This);
        
        void ( STDMETHODCALLTYPE *Next )( 
            IXpsPartIterator * This);
        
        END_INTERFACE
    } IXpsPartIteratorVtbl;

    interface IXpsPartIterator
    {
        CONST_VTBL struct IXpsPartIteratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsPartIterator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsPartIterator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsPartIterator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsPartIterator_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IXpsPartIterator_Current(This,pUri,ppXpsPart)	\
    ( (This)->lpVtbl -> Current(This,pUri,ppXpsPart) ) 

#define IXpsPartIterator_IsDone(This)	\
    ( (This)->lpVtbl -> IsDone(This) ) 

#define IXpsPartIterator_Next(This)	\
    ( (This)->lpVtbl -> Next(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsPartIterator_INTERFACE_DEFINED__ */


#ifndef __IPrintReadStreamFactory_INTERFACE_DEFINED__
#define __IPrintReadStreamFactory_INTERFACE_DEFINED__

/* interface IPrintReadStreamFactory */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPrintReadStreamFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("acb971e3-df8d-4fc2-bee6-0609d15f3cf9")
    IPrintReadStreamFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [out] */ IPrintReadStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintReadStreamFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrintReadStreamFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrintReadStreamFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrintReadStreamFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPrintReadStreamFactory * This,
            /* [out] */ IPrintReadStream **ppStream);
        
        END_INTERFACE
    } IPrintReadStreamFactoryVtbl;

    interface IPrintReadStreamFactory
    {
        CONST_VTBL struct IPrintReadStreamFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrintReadStreamFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrintReadStreamFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrintReadStreamFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrintReadStreamFactory_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrintReadStreamFactory_INTERFACE_DEFINED__ */


#ifndef __IPartDiscardControl_INTERFACE_DEFINED__
#define __IPartDiscardControl_INTERFACE_DEFINED__

/* interface IPartDiscardControl */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IPartDiscardControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cc350c00-095b-42a5-bf0f-c8780edadb3c")
    IPartDiscardControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiscardProperties( 
            /* [out] */ BSTR *uriSentinelPage,
            /* [out] */ BSTR *uriPartToDiscard) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartDiscardControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartDiscardControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartDiscardControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartDiscardControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscardProperties )( 
            IPartDiscardControl * This,
            /* [out] */ BSTR *uriSentinelPage,
            /* [out] */ BSTR *uriPartToDiscard);
        
        END_INTERFACE
    } IPartDiscardControlVtbl;

    interface IPartDiscardControl
    {
        CONST_VTBL struct IPartDiscardControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartDiscardControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPartDiscardControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPartDiscardControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPartDiscardControl_GetDiscardProperties(This,uriSentinelPage,uriPartToDiscard)	\
    ( (This)->lpVtbl -> GetDiscardProperties(This,uriSentinelPage,uriPartToDiscard) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPartDiscardControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\filterpipelineutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------

#ifndef _PRINT_FILTER_UTIL_813b22ee_62f7_4200_
#define _PRINT_FILTER_UTIL_813b22ee_62f7_4200_

#if defined(__cplusplus)

//
// print filter pipeline
//
namespace pfp
{

//
// Helpful when you want to use a print read interface with XML SAX
// which needs an ISequentialStream
//
class PrintReadStreamToSeqStream : public ISequentialStream
{
public:

    PrintReadStreamToSeqStream(
        __in    IPrintReadStream    *pReadStream
        ) : m_cRef(1),
            m_pStream(pReadStream)
    {
        m_pStream->AddRef();
    }

    ~PrintReadStreamToSeqStream()
    {
        m_pStream->Release();
    }

    STDMETHODIMP_(ULONG)
    AddRef(
        VOID
        )
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release(
        VOID
        )
    {
        ULONG cRefCount = InterlockedDecrement(&m_cRef);

        if (cRefCount)
        {
            return cRefCount;
        }

        delete this;

        return 0;
    }

    STDMETHODIMP
    QueryInterface(
        __in      REFIID      riid,
        __out     VOID        **ppv
        )
    {
        HRESULT hRes = E_POINTER;

        if (ppv)
        {
            hRes = E_NOINTERFACE;

            *ppv = NULL;

            if (riid == IID_ISequentialStream)
            {
                *ppv = static_cast<ISequentialStream *>(this);
            }
            else if (riid == IID_IUnknown)
            {
                *ppv = static_cast<IUnknown *>(this);
            }

            if (*ppv)
            {
                AddRef();

                hRes = S_OK;
            }
        }

        return hRes;
    }

    STDMETHODIMP
    Read(
        __out_bcount(cb)   void*    pv,
        __in               ULONG    cb,
        __out              ULONG    *pcbRead
        )
    {
        BOOL bEof;

        return m_pStream->ReadBytes(pv, cb, pcbRead, &bEof);
    }

    STDMETHODIMP
    Write(
        __in_bcount(cb)    void const*    pv,
        __in               ULONG          cb,
        __out              ULONG          *pcbWritten
        )
    {
        UNREFERENCED_PARAMETER(pv);
        UNREFERENCED_PARAMETER(cb);
        UNREFERENCED_PARAMETER(pcbWritten);
        return E_NOTIMPL;
    }

private:

    LONG               m_cRef;
    IPrintReadStream  *m_pStream;
};

//
// Helpful when you want to use a print write interface with XML SAX
// which needs an ISequentialStream
//
class PrintWriteStreamToSeqStream : public ISequentialStream
{
public:

    PrintWriteStreamToSeqStream(
        __in    IPrintWriteStream    *pWriteStream
        ) : m_cRef(1),
            m_pStream(pWriteStream)
    {
        m_pStream->AddRef();
    }

    ~PrintWriteStreamToSeqStream()
    {
        m_pStream->Close();

        m_pStream->Release();
    }

    STDMETHODIMP_(ULONG)
    AddRef(
        VOID
        )
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release(
        VOID
        )
    {
        ULONG cRefCount = InterlockedDecrement(&m_cRef);

        if (cRefCount)
        {
            return cRefCount;
        }

        delete this;

        return 0;
    }

    STDMETHODIMP
    QueryInterface(
        __in      REFIID      riid,
        __out     VOID        **ppv
        )
    {
        HRESULT hRes = E_POINTER;

        if (ppv)
        {
            hRes = E_NOINTERFACE;

            *ppv = NULL;

            if (riid == IID_ISequentialStream)
            {
                *ppv = static_cast<ISequentialStream *>(this);
            }
            else if (riid == IID_IUnknown)
            {
                *ppv = static_cast<IUnknown *>(this);
            }

            if (*ppv)
            {
                AddRef();

                hRes = S_OK;
            }
        }

        return hRes;
    }

    STDMETHODIMP
    Read(
        __out_bcount(cb)   void*    pv,
        __in               ULONG    cb,
        __out              ULONG    *pcbRead
        )
    {
        UNREFERENCED_PARAMETER(pv);
        UNREFERENCED_PARAMETER(cb);
        UNREFERENCED_PARAMETER(pcbRead);
        return E_NOTIMPL;
    }

    STDMETHODIMP
    Write(
        __in_bcount(cb)    void const*    pv,
        __in               ULONG          cb,
        __out              ULONG          *pcbWritten
        )
    {
        return m_pStream->WriteBytes(pv, cb, pcbWritten);
    }

private:

    LONG               m_cRef;
    IPrintWriteStream  *m_pStream;
};

}; // namespace pfp

#endif // if defined(__cplusplus)

#endif // #ifndef _PRINT_FILTER_UTIL_813b22ee-62f7-4200-9c85-73d139eaa579_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fltsafe.h ===
#if (NTDDI_VERSION >= NTDDI_WINXP)
// fltsafe.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

// FLOATSAFE
//
// Saves floating point state on construction and restores on destruction.
//
struct FLOATSAFE
{
    KFLOATING_SAVE     FloatSave;
    NTSTATUS           ntStatus;

    FLOATSAFE::FLOATSAFE(void)
    {
        ntStatus = KeSaveFloatingPointState(&FloatSave);
    }

    FLOATSAFE::~FLOATSAFE(void)
    {
        if (NT_SUCCESS(ntStatus))
        {
            KeRestoreFloatingPointState(&FloatSave);
        }
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fltKernel.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    fltKernel.h

Abstract:

    This contains all of the global definitions for mini-filters.

Environment:

    Kernel mode

--*/

#ifndef __FLTKERNEL__
#define __FLTKERNEL__

#ifdef __cplusplus
extern "C" {
#endif

//
// IMPORTANT!!!!!
//
// This is how FltMgr was released (from oldest to newest)
// xpsp2, srv03 SP1, w2k sp4+URP, LH
//

//
//  The defines items that are part of the filter manager baseline
//

#define FLT_MGR_BASELINE (((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WIN2KSP4))) || \
                          ((OSVER(NTDDI_VERSION) == NTDDI_WINXP) && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WINXPSP2))) || \
                          ((OSVER(NTDDI_VERSION) == NTDDI_WS03)  && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WS03SP1))) || \
                          (NTDDI_VERSION >= NTDDI_VISTA))

//
//  This defines items that were added after XPSP2 was released.  This means
//  they are in Srv03 SP1, W2K SP4+URP, and Longhorn
//

#define FLT_MGR_AFTER_XPSP2 (((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WIN2KSP4))) || \
                             ((OSVER(NTDDI_VERSION) == NTDDI_WINXP) && (SPVER(NTDDI_VERSION) >  SPVER(NTDDI_WINXPSP2))) || \
                             ((OSVER(NTDDI_VERSION) == NTDDI_WS03)  && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WS03SP1))) || \
                             (NTDDI_VERSION >= NTDDI_VISTA))

//
//  This defines items that only exist in longhorn or later
//

#define FLT_MGR_LONGHORN (NTDDI_VERSION >= NTDDI_VISTA)



///////////////////////////////////////////////////////////////////////////////
//
//  Standard includes
//
///////////////////////////////////////////////////////////////////////////////

#include <ntifs.h>
#include <fltUserStructures.h>
#include <initguid.h>

#if FLT_MGR_BASELINE

///////////////////////////////////////////////////////////////////////////////
//
//  Miscellaneous macros useful for Filter Manager & mini-filters
//
///////////////////////////////////////////////////////////////////////////////

//
//  Handy macros for doing pointer arithmetic
//

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))
#define PtrOffset(B,O) ((ULONG)((ULONG_PTR)(O) - (ULONG_PTR)(B)))

//
//  This macro takes a length & rounds it up to a multiple of the alignment
//  Alignment is given as a power of 2
//

#define ROUND_TO_SIZE(_length, _alignment)                      \
            ((((ULONG_PTR)(_length)) + ((_alignment)-1)) & ~(ULONG_PTR) ((_alignment) - 1))

//
//  Checks if 1st argument is aligned on given power of 2 boundary specified
//  by 2nd argument
//

#define IS_ALIGNED(_pointer, _alignment)                        \
        ((((ULONG_PTR) (_pointer)) & ((_alignment) - 1)) == 0)


///////////////////////////////////////////////////////////////////////////////
//
//                  FltMgr Operation Definitions
//
///////////////////////////////////////////////////////////////////////////////

//
//  Along with the existing IRP_MJ_xxxx definitions (0 - 0x1b) in NTIFS.H,
//  this defines all of the operation IDs that can be sent to a mini-filter.
//

#define IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION   ((UCHAR)-1)
#define IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION   ((UCHAR)-2)
#define IRP_MJ_ACQUIRE_FOR_MOD_WRITE                 ((UCHAR)-3)
#define IRP_MJ_RELEASE_FOR_MOD_WRITE                 ((UCHAR)-4)
#define IRP_MJ_ACQUIRE_FOR_CC_FLUSH                  ((UCHAR)-5)
#define IRP_MJ_RELEASE_FOR_CC_FLUSH                  ((UCHAR)-6)


//
//  Leave space for additional FS_FILTER codes here
//

#define IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE             ((UCHAR)-13)
#define IRP_MJ_NETWORK_QUERY_OPEN                    ((UCHAR)-14)
#define IRP_MJ_MDL_READ                              ((UCHAR)-15)
#define IRP_MJ_MDL_READ_COMPLETE                     ((UCHAR)-16)
#define IRP_MJ_PREPARE_MDL_WRITE                     ((UCHAR)-17)
#define IRP_MJ_MDL_WRITE_COMPLETE                    ((UCHAR)-18)
#define IRP_MJ_VOLUME_MOUNT                          ((UCHAR)-19)
#define IRP_MJ_VOLUME_DISMOUNT                       ((UCHAR)-20)


#define FLT_INTERNAL_OPERATION_COUNT                 22

//
//  Not currently implemented
//

/*
#define IRP_MJ_READ_COMPRESSED                      ((UCHAR)-xx)
#define IRP_MJ_WRITE_COMPRESSED                     ((UCHAR)-xx)
#define IRP_MJ_MDL_READ_COMPLETE_REQUEST            ((UCHAR)-xx)
#define IRP_MJ_MDL_WRITE_COMPLETE_COMPRESSED        ((UCHAR)-xx)
*/

//
//  Marks the end of the operation list for registration
//

#define IRP_MJ_OPERATION_END                        ((UCHAR)0x80)


///////////////////////////////////////////////////////////////////////////////
//
//  Basic Filter data types
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _FLT_FILTER *PFLT_FILTER;
typedef struct _FLT_VOLUME *PFLT_VOLUME;
typedef struct _FLT_INSTANCE *PFLT_INSTANCE;
typedef struct _FLT_PORT *PFLT_PORT;

typedef PVOID PFLT_CONTEXT;
#define NULL_CONTEXT ((PFLT_CONTEXT)NULL)   //EMPTY context

#if !FLT_MGR_LONGHORN
//
//  For non-longhorn environments we need to define this structure since
//  it is used elsewhere.  In longhorn and later it is part of ntifs.h
//

typedef struct _KTRANSACTION *PKTRANSACTION;

#endif // !FLT_MGR_LONGHORN



///////////////////////////////////////////////////////////////////////////////
//
//  This defines the standard parameter block that is passed to every
//  callback.
//
///////////////////////////////////////////////////////////////////////////////

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

typedef union _FLT_PARAMETERS {

    //
    //  IRP_MJ_CREATE
    //

    struct {
        PIO_SECURITY_CONTEXT SecurityContext;

        //
        //  The low 24 bits contains CreateOptions flag values.
        //  The high 8 bits contains the CreateDisposition values.
        //

        ULONG Options;

        USHORT POINTER_ALIGNMENT FileAttributes;
        USHORT ShareAccess;
        ULONG POINTER_ALIGNMENT EaLength;

        PVOID EaBuffer;                 //Not in IO_STACK_LOCATION parameters list
        LARGE_INTEGER AllocationSize;   //Not in IO_STACK_LOCATION parameters list
    } Create;

    //
    //  IRP_MJ_CREATE_NAMED_PIPE
    //
    //  Notice that the fields in the following parameter structure must
    //  match those for the create structure other than the last longword.
    //  This is so that no distinctions need be made by the I/O system's
    //  parse routine other than for the last longword.
    //

    struct {
        PIO_SECURITY_CONTEXT SecurityContext;
        ULONG Options;
        USHORT POINTER_ALIGNMENT Reserved;
        USHORT ShareAccess;
        PVOID Parameters; // PNAMED_PIPE_CREATE_PARAMETERS
    } CreatePipe;

    //
    //  IRP_MJ_CREATE_MAILSLOT
    //
    //  Notice that the fields in the following parameter structure must
    //  match those for the create structure other than the last longword.
    //  This is so that no distinctions need be made by the I/O system's
    //  parse routine other than for the last longword.
    //

    struct {
        PIO_SECURITY_CONTEXT SecurityContext;
        ULONG Options;
        USHORT POINTER_ALIGNMENT Reserved;
        USHORT ShareAccess;
        PVOID Parameters; // PMAILSLOT_CREATE_PARAMETERS
    } CreateMailslot;

    //
    //  IRP_MJ_READ
    //

    struct {
        ULONG Length;                   //Length of transfer
        ULONG POINTER_ALIGNMENT Key;
        LARGE_INTEGER ByteOffset;       //Offset to read from

        PVOID ReadBuffer;       //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } Read;

    //
    //  IRP_MJ_WRITE
    //

    struct {
        ULONG Length;                   //Length of transfer
        ULONG POINTER_ALIGNMENT Key;
        LARGE_INTEGER ByteOffset;       //Offset to write to

        PVOID WriteBuffer;      //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } Write;

    //
    //  IRP_MJ_QUERY_INFORMATION
    //

    struct {
        ULONG Length;           //Length of buffer
        FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass; //Class of information to query

        PVOID InfoBuffer;       //Not in IO_STACK_LOCATION parameters list
    } QueryFileInformation;

    //
    //  IRP_MJ_SET_INFORMATION
    //

    struct {
        ULONG Length;
        FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        PFILE_OBJECT ParentOfTarget;
        union {
            struct {
                BOOLEAN ReplaceIfExists;
                BOOLEAN AdvanceOnly;
            };
            ULONG ClusterCount;
            HANDLE DeleteHandle;
        };

        PVOID InfoBuffer;       //Not in IO_STACK_LOCATION parameters list
    } SetFileInformation;

    //
    //  IRP_MJ_QUERY_EA
    //

    struct {
        ULONG Length;
        PVOID EaList;
        ULONG EaListLength;
        ULONG POINTER_ALIGNMENT EaIndex;

        PVOID EaBuffer;         //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } QueryEa;

    //
    //  IRP_MJ_SET_EA
    //

    struct {
        ULONG Length;

        PVOID EaBuffer;         //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } SetEa;

    //
    //  IRP_MJ_QUERY_VOLUME_INFORMATION
    //

    struct {
        ULONG Length;
        FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;

        PVOID VolumeBuffer;     //Not in IO_STACK_LOCATION parameters list
    } QueryVolumeInformation;

    //
    //  IRP_MJ_SET_VOLUME_INFORMATION
    //

    struct {
        ULONG Length;
        FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;

        PVOID VolumeBuffer;     //Not in IO_STACK_LOCATION parameters list
    } SetVolumeInformation;

    //
    //  IRP_MJ_DIRECTORY_CONTROL
    //

    union {

        //
        //  IRP_MN_QUERY_DIRECTORY or IRP_MN_QUERY_OLE_DIRECTORY
        //

        struct {
            ULONG Length;
            PUNICODE_STRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
            ULONG POINTER_ALIGNMENT FileIndex;

            PVOID DirectoryBuffer;  //Not in IO_STACK_LOCATION parameters list
            PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
        } QueryDirectory;

        //
        //  IRP_MN_NOTIFY_CHANGE_DIRECTORY
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT CompletionFilter;

            //
            // These spares ensure that the offset of DirectoryBuffer is
            // exactly the same as that for QueryDirectory minor code. This
            // needs to be the same because filter manager code makes the assumption
            // they are the same
            //

            ULONG POINTER_ALIGNMENT Spare1;
            ULONG POINTER_ALIGNMENT Spare2;

            PVOID DirectoryBuffer;  //Not in IO_STACK_LOCATION parameters list
            PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
        } NotifyDirectory;

    } DirectoryControl;

    //
    //  IRP_MJ_FILE_SYSTEM_CONTROL
    //
    //  Note that the user's output buffer is stored in the UserBuffer field
    //  and the user's input buffer is stored in the SystemBuffer field.
    //

    union {

        //
        //  IRP_MN_VERIFY_VOLUME
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        //  IRP_MN_KERNEL_CALL and IRP_MN_USER_FS_REQUEST
        //  The parameters are broken out into 3 separate unions based on the
        //  method of the FSCTL Drivers should use the method-appropriate
        //  union for accessing parameters
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
        } Common;

        //
        //  METHOD_NEITHER Fsctl parameters
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;

            //
            //  Type3InputBuffer: name changed from IO_STACK_LOCATION parameters
            //  Note for this mothod, both input & output buffers are 'raw',
            //  i.e. unbuffered, and should be treated with caution ( either
            //  probed & captured before access, or use try-except to enclose
            //  access to the buffer)
            //

            PVOID InputBuffer;
            PVOID OutputBuffer;

            //
            //  Mdl address for the output buffer  (maybe NULL)
            //

            PMDL OutputMdlAddress;
        } Neither;

        //
        //  METHOD_BUFFERED Fsctl parameters
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;

            //
            //  For method buffered, this buffer is used both for input and
            //  output
            //

            PVOID SystemBuffer;

        } Buffered;

        //
        //  METHOD_IN_DIRECT/METHOD_OUT_DIRECT Fsctl parameters
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;

            //
            //  Note the input buffer is already captured & buffered here - so
            //  can be safely accessed from kernel mode.  The output buffer is
            //  locked down - so also safe to access, however the OutputBuffer
            //  pointer is the user virtual address, so if the driver wishes to
            //  access the buffer in a different process context than that of
            //  the original i/o - it will have to obtain the system address
            //  from the MDL
            //

            PVOID InputSystemBuffer;

            //
            //  User virtual address of output buffer
            //

            PVOID OutputBuffer;

            //
            //  Mdl address for the locked down output buffer (should be
            //  non-NULL)
            //

            PMDL OutputMdlAddress;
        } Direct;

    } FileSystemControl;

    //
    //  IRP_MJ_DEVICE_CONTROL or IRP_MJ_INTERNAL_DEVICE_CONTROL
    //

    union {

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
        } Common;

        //
        //  The parameters are broken out into 3 separate unions based on the
        //  method of the IOCTL.  Drivers should use the method-appropriate
        //  union for accessing parameters.
        //

        //
        //  METHOD_NEITHER Ioctl parameters for IRP path
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;

            //
            //  Type3InputBuffer: name changed from IO_STACK_LOCATION parameters
            //  Note for this mothod, both input & output buffers are 'raw',
            //  i.e. unbuffered, and should be treated with caution ( either
            //  probed & captured before access, or use try-except to enclose
            //  access to the buffer)
            //

            PVOID InputBuffer;
            PVOID OutputBuffer;

            //
            //  Mdl address for the output buffer  (maybe NULL)
            //

            PMDL OutputMdlAddress;
        } Neither;

        //
        //  METHOD_BUFFERED Ioctl parameters for IRP path
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;

            //
            //  For method buffered, this buffer is used both for input and
            //  output
            //

            PVOID SystemBuffer;

        } Buffered;

        //
        //  METHOD_IN_DIRECT/METHOD_OUT_DIRECT Ioctl parameters
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;

            //
            //  Note the input buffer is already captured & buffered here - so
            //  can be safely accessed from kernel mode.  The output buffer is
            //  locked down - so also safe to access, however the OutputBuffer
            //  pointer is the user virtual address, so if the driver wishes to
            //  access the buffer in a different process context than that of
            //  the original i/o - it will have to obtain the system address
            //  from the MDL
            //

            PVOID InputSystemBuffer;

            //
            //  User virtual address of output buffer
            //

            PVOID OutputBuffer;

            //
            //  Mdl address for the locked down output buffer (should be non-NULL)
            //

            PMDL OutputMdlAddress;
        } Direct;

        //
        //  Regardless of method, if the CALLBACK_DATA represents a fast i/o
        //  device IOCTL, this structure must be used to access the parameters
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;

            //
            //  Both buffers are 'raw', i.e. unbuffered
            //

            PVOID InputBuffer;
            PVOID OutputBuffer;

        } FastIo;

    } DeviceIoControl;

    //
    //  IRP_MJ_LOCK_CONTROL
    //

    struct {
        PLARGE_INTEGER Length;
        ULONG POINTER_ALIGNMENT Key;
        LARGE_INTEGER ByteOffset;

        PEPROCESS ProcessId;        //  Only meaningful for FastIo locking operations.
        BOOLEAN FailImmediately;    //  Only meaningful for FastIo locking operations.
        BOOLEAN ExclusiveLock;      //  Only meaningful for FastIo locking operations.
    } LockControl;

    //
    //  IRP_MJ_QUERY_SECURITY
    //

    struct {
        SECURITY_INFORMATION SecurityInformation;
        ULONG POINTER_ALIGNMENT Length;

        PVOID SecurityBuffer;   //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } QuerySecurity;

    //
    //  IRP_MJ_SET_SECURITY
    //

    struct {
        SECURITY_INFORMATION SecurityInformation;
        PSECURITY_DESCRIPTOR SecurityDescriptor;
    } SetSecurity;

    //
    //  IRP_MJ_SYSTEM_CONTROL
    //

    struct {
        ULONG_PTR ProviderId;
        PVOID DataPath;
        ULONG BufferSize;
        PVOID Buffer;
    } WMI;

    //
    //  IRP_MJ_QUERY_QUOTA
    //

    struct {
        ULONG Length;
        PSID StartSid;
        PFILE_GET_QUOTA_INFORMATION SidList;
        ULONG SidListLength;

        PVOID QuotaBuffer;      //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } QueryQuota;

    //
    //  IRP_MJ_SET_QUOTA
    //

    struct {
        ULONG Length;

        PVOID QuotaBuffer;      //Not in IO_STACK_LOCATION parameters list
        PMDL MdlAddress;        //Mdl address for the buffer  (maybe NULL)
    } SetQuota;

    //
    //  IRP_MJ_PNP
    //

    union {

        //
        //  IRP_MN_START_DEVICE
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;

        //
        //  IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        //  IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;

        //
        //  IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        //  IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        //  IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        //  IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        //  IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        //  IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        //  IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

    } Pnp;

    //
    //  ***** Start of Emulated IRP definitions
    //

    //
    //  IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION
    //

    struct {
        FS_FILTER_SECTION_SYNC_TYPE SyncType;
        ULONG PageProtection;
    } AcquireForSectionSynchronization;

    //
    //  IRP_MJ_ACQUIRE_FOR_MOD_WRITE
    //

    struct {
        PLARGE_INTEGER EndingOffset;
        PERESOURCE *ResourceToRelease;
    } AcquireForModifiedPageWriter;

    //
    //  IRP_MJ_RELEASE_FOR_MOD_WRITE
    //

    struct {
        PERESOURCE ResourceToRelease;
    } ReleaseForModifiedPageWriter;


    //
    //  FAST_IO_CHECK_IF_POSSIBLE
    //

    struct {
        LARGE_INTEGER FileOffset;
        ULONG Length;
        ULONG POINTER_ALIGNMENT LockKey;
        BOOLEAN POINTER_ALIGNMENT CheckForReadOperation;
    } FastIoCheckIfPossible;

    //
    //  IRP_MJ_NETWORK_QUERY_OPEN
    //

    struct {
        PIRP Irp;
        PFILE_NETWORK_OPEN_INFORMATION NetworkInformation;
    } NetworkQueryOpen;

    //
    //  IRP_MJ_MDL_READ
    //

    struct {
        LARGE_INTEGER FileOffset;
        ULONG POINTER_ALIGNMENT Length;
        ULONG POINTER_ALIGNMENT Key;
        PMDL *MdlChain;
    } MdlRead;

    //
    //  IRP_MJ_MDL_READ_COMPLETE
    //

    struct {
        PMDL MdlChain;
    } MdlReadComplete;

    //
    //  IRP_MJ_PREPARE_MDL_WRITE
    //

    struct {
        LARGE_INTEGER FileOffset;
        ULONG POINTER_ALIGNMENT Length;
        ULONG POINTER_ALIGNMENT Key;
        PMDL *MdlChain;
    } PrepareMdlWrite;

    //
    //  IRP_MJ_MDL_WRITE_COMPLETE
    //

    struct {
        LARGE_INTEGER FileOffset;
        PMDL MdlChain;
    } MdlWriteComplete;

    //
    //  IRP_MJ_VOLUME_MOUNT
    //

    struct {
        ULONG DeviceType;
    } MountVolume;


    //
    // Others - driver-specific
    //

    struct {
        PVOID Argument1;
        PVOID Argument2;
        PVOID Argument3;
        PVOID Argument4;
        PVOID Argument5;
        LARGE_INTEGER Argument6;
    } Others;

} FLT_PARAMETERS, *PFLT_PARAMETERS;

#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif


///////////////////////////////////////////////////////////////////////////////
//
//                      CALLBACK DATA definition
//
///////////////////////////////////////////////////////////////////////////////

//
//  Changeable portion of the callback data. Any of the parameters in this
//  structure that are passed in via CallbackData->Px,  can be changed by
//  a mini-filter.  However if filter changes ANY of the parameters in this
//  structure, it needs to issue FltSetCallbackDataDirty()  on the
//  callback-data or the changes will not be honored & unpredictable failures
//  may occur.
//

typedef struct _FLT_IO_PARAMETER_BLOCK {


    //
    //  Fields from IRP
    //  Flags

    ULONG IrpFlags;

    //
    //  Major/minor functions from IRP
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  The flags associated with operations.
    //  The IO_STACK_LOCATION.Flags field in the old model (SL_* flags)
    //

    UCHAR OperationFlags;

    //
    //  For alignment
    //

    UCHAR Reserved;


    //
    //  The FileObject that is the target for this
    //  IO operation.
    //

    PFILE_OBJECT TargetFileObject;

    //
    //  Instance that i/o is directed to
    //

    PFLT_INSTANCE TargetInstance;

    //
    //  Normalized parameters for the operation
    //

    FLT_PARAMETERS Parameters;

} FLT_IO_PARAMETER_BLOCK, *PFLT_IO_PARAMETER_BLOCK;


//
//  Flag Bit definitions for the Flags variable of FLT_CALLBACK_DATA
//

typedef ULONG FLT_CALLBACK_DATA_FLAGS;

    //
    //  Flags passed to mini-filters
    //

    //
    //  This mask designates the flags that describe the the type of i/o
    //  and parameters
    //
    #define FLTFL_CALLBACK_DATA_REISSUE_MASK           0x0000FFFF

    //
    //  The below 3 flags are mutually exclusive.
    //  i.e. only ONE and exacly one hould be set for the callback data.
    //  Once set they should never change
    //
    #define FLTFL_CALLBACK_DATA_IRP_OPERATION           0x00000001    // Set for Irp operations
    #define FLTFL_CALLBACK_DATA_FAST_IO_OPERATION       0x00000002    // Set for Fast Io operations
    #define FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION     0x00000004    // Set for Fs Filter operations
    //
    //  In principle this flag can be set for any operation. Once set it shouldn't change
    //
    #define FLTFL_CALLBACK_DATA_SYSTEM_BUFFER           0x00000008    // Set if the buffer passed in for the i/o was a system buffer



    //
    //  Below flags are relevant only for IRP-based i/o - i.e. only
    //  if FLTFL_CALLBACK_DATA_IRP_OPERATION was set. If the i/o was reissued
    //  both flags will necessarily be set
    //
    #define FLTFL_CALLBACK_DATA_GENERATED_IO            0x00010000    // Set if this is I/O generated by a mini-filter
    #define FLTFL_CALLBACK_DATA_REISSUED_IO             0x00020000    // Set if this I/O was reissued

    //
    //  Below 2 flags are set only for post-callbacks.
    //
    #define FLTFL_CALLBACK_DATA_DRAINING_IO             0x00040000    // set if this operation is being drained. If set,
    #define FLTFL_CALLBACK_DATA_POST_OPERATION          0x00080000    // Set if this is a POST operation

    //
    //  Flags set by mini-filters: these are set by the minifilters and may be reset
    //  by filter manager.
    //
    #define FLTFL_CALLBACK_DATA_DIRTY                   0x80000000    // Set by caller if parameters were changed


//
//  This defines the standard information passed to a mini-filter for
//  every operation callback.
//

typedef struct _FLT_CALLBACK_DATA {

    //
    //  Flags
    //

    FLT_CALLBACK_DATA_FLAGS Flags;

    //
    //  Thread that initiated this operation.
    //

    PETHREAD CONST Thread;

    //
    //  Pointer to the changeable i/o parameters
    //

    PFLT_IO_PARAMETER_BLOCK CONST Iopb;

    //
    //  For pre-op calls: if filter returns STATUS_IO_COMPLETE, then it should
    //  set the return i/o status here.  For post-operation calls, this is set
    //  by filter-manager indicating the completed i/o status.
    //

    IO_STATUS_BLOCK IoStatus;


    struct _FLT_TAG_DATA_BUFFER *TagData;

    union {
        struct {

            //
            //  Queue links if the FltMgr queue is used to
            //  pend the callback
            //

            LIST_ENTRY QueueLinks;

            //
            //  Additional context
            //

            PVOID QueueContext[2];
        };

        //
        //  The following are available to filters to use
        //  in whatever manner desired if not using the filter manager
        //  queues.
        //  NOTE:  These fields are only valid while the filter is
        //         processing this operation which is inside the operation
        //         callback or while the operation is pended.
        //

        PVOID FilterContext[4];
    };

    //
    //  Original requester mode of caller
    //

    KPROCESSOR_MODE RequestorMode;

} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;


//
//  Routines to manipulate callback data dirty state
//

VOID
FLTAPI
FltSetCallbackDataDirty(
    __inout PFLT_CALLBACK_DATA Data
    );

VOID
FLTAPI
FltClearCallbackDataDirty(
    __inout PFLT_CALLBACK_DATA Data
    );

BOOLEAN
FLTAPI
FltIsCallbackDataDirty(
    __in PFLT_CALLBACK_DATA Data
    );


//
//  These used to be macros and our now routines.  This was done for greater
//  flexibility in the future.  I have kept the macros around for compatibility
//  with existing filters.
//

#define FLT_SET_CALLBACK_DATA_DIRTY(Data)   FltSetCallbackDataDirty(Data)
#define FLT_CLEAR_CALLBACK_DATA_DIRTY(Data) FltClearCallbackDataDirty(Data)
#define FLT_IS_CALLBACK_DATA_DIRTY(Data)    FltIsCallbackDataDirty(Data)

//
//  These just check the kind of operation for the CallbackData
//  All of them take callback data as the parameter
//

#define FLT_IS_IRP_OPERATION(Data)          (FlagOn( (Data)->Flags, FLTFL_CALLBACK_DATA_IRP_OPERATION ))
#define FLT_IS_FASTIO_OPERATION(Data)       (FlagOn( (Data)->Flags, FLTFL_CALLBACK_DATA_FAST_IO_OPERATION ))
#define FLT_IS_FS_FILTER_OPERATION(Data)    (FlagOn( (Data)->Flags, FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION ))

//
//  Bunch of other miscellaneous i/o characteristics
//

#define FLT_IS_REISSUED_IO(Data)            (FlagOn( (Data)->Flags, FLTFL_CALLBACK_DATA_REISSUED_IO ))

//
//  This test only is useful for IRP operations to check if the passed in buffer is a system buffer
//

#define FLT_IS_SYSTEM_BUFFER(Data)          (FlagOn( (Data)->Flags, FLTFL_CALLBACK_DATA_SYSTEM_BUFFER ))


///////////////////////////////////////////////////////////////////////////////
//
//                        Context Definitions
//
///////////////////////////////////////////////////////////////////////////////

//
//  Definitions for the types of contexts that are available.
//

typedef USHORT FLT_CONTEXT_TYPE;

    #define FLT_VOLUME_CONTEXT          0x0001
    #define FLT_INSTANCE_CONTEXT        0x0002
    #define FLT_FILE_CONTEXT            0x0004
    #define FLT_STREAM_CONTEXT          0x0008
    #define FLT_STREAMHANDLE_CONTEXT    0x0010
    #define FLT_TRANSACTION_CONTEXT     0x0020

    #define FLT_CONTEXT_END             0xffff

//
//  Definition for ALL contexts
//

#define FLT_ALL_CONTEXTS (FLT_VOLUME_CONTEXT |      \
                          FLT_INSTANCE_CONTEXT |    \
                          FLT_FILE_CONTEXT |        \
                          FLT_STREAM_CONTEXT |      \
                          FLT_STREAMHANDLE_CONTEXT |\
                          FLT_TRANSACTION_CONTEXT)

//
//  This structure is passed to a filter's pre/post operation callback
//  routines and defines all of the handles associated with the given
//  operation.
//

typedef struct _FLT_RELATED_OBJECTS {

    USHORT CONST Size;
    USHORT CONST TransactionContext;            //TxF mini-version
    PFLT_FILTER CONST Filter;
    PFLT_VOLUME CONST Volume;
    PFLT_INSTANCE CONST Instance;
    PFILE_OBJECT CONST FileObject;
    PKTRANSACTION CONST Transaction;

} FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;

typedef CONST struct _FLT_RELATED_OBJECTS *PCFLT_RELATED_OBJECTS;

//
//  Structure used by a filter to get/release multiple contexts at once.
//

typedef struct _FLT_RELATED_CONTEXTS {

    PFLT_CONTEXT VolumeContext;
    PFLT_CONTEXT InstanceContext;
    PFLT_CONTEXT FileContext;
    PFLT_CONTEXT StreamContext;
    PFLT_CONTEXT StreamHandleContext;
    PFLT_CONTEXT TransactionContext;

} FLT_RELATED_CONTEXTS, *PFLT_RELATED_CONTEXTS;

//
//  Prototype for Context Cleanup routine.  This routine is called by the
//  filterManager when it has determined it is time to free a context.
//  The called filter should cleanup any allocated memory they have inside
//  this context structure.  FLTMGR will free the context upon return.
//

typedef VOID
(FLTAPI *PFLT_CONTEXT_CLEANUP_CALLBACK) (
    __in PFLT_CONTEXT Context,
    __in FLT_CONTEXT_TYPE ContextType
    );

//
//  Function prototypes for Allocation and Free callbacks that may be used by
//  advanced filters that want to manage context allocation directly.
//
//  NOTE:  Most filters do not need to use this feature since the default
//         mechanism built into FltMgr does this efficiently.
//

typedef PVOID
(FLTAPI *PFLT_CONTEXT_ALLOCATE_CALLBACK)(
    __in POOL_TYPE PoolType,
    __in SIZE_T Size,
    __in FLT_CONTEXT_TYPE ContextType
    );

typedef VOID
(FLTAPI *PFLT_CONTEXT_FREE_CALLBACK)(
    __in PVOID Pool,
    __in FLT_CONTEXT_TYPE ContextType
    );

//
//  Defines context registration flags
//

typedef USHORT FLT_CONTEXT_REGISTRATION_FLAGS;

    //
    //  By default, the FltMgr matches exactly a given context allocation
    //  request with a size specified at context registration time.  If
    //  this flag is specified, then the FltMgr will use a given registered
    //  size definition if the requested size is <= to it.  Note that the
    //  FltMgr sorts multiple size definions into ascending order.
    //
    //  This flag is ignored on entries with FLT_VARIABLE_SIZED_CONTEXTS
    //  specified or Alloc/Free routines specified
    //

    #define FLTFL_CONTEXT_REGISTRATION_NO_EXACT_SIZE_MATCH 0x0001


//
//  When this value is used in the "Size" field of the FLT_CONTEXT_REGISTRATION
//  structure, then this registered context entry has no explicit size.
//  When allocation requests are made, FltMgr directly allocates and frees
//  the memory from pool.
//
//  For a given context and pool type, only one entry may have this value.
//  This may be included with multiple explicitly sized entries.  This will
//  always be sorted to the end of the list.
//

#define FLT_VARIABLE_SIZED_CONTEXTS ((SIZE_T)-1)

//
//  An array of this structure is used for registering the different kinds of
//  contexts used by this mini-filter.
//
//  At least one of these records must be speicifed to allocate a context of a
//  given type.
//

typedef struct _FLT_CONTEXT_REGISTRATION {

    //
    //  Identifies the type of this context
    //

    FLT_CONTEXT_TYPE ContextType;

    //
    //  Local flags
    //

    FLT_CONTEXT_REGISTRATION_FLAGS Flags;

    //
    //  Routine to call to cleanup the context before it is deleted.
    //  This may be NULL if not cleanup is needed.
    //

    PFLT_CONTEXT_CLEANUP_CALLBACK ContextCleanupCallback;

    //
    //  Defines the size & pool tag the mini-filter wants for the given context.
    //  FLT_VARIABLE_SIZED_CONTEXTS may be specified for the size if variable
    //  sized contexts are used.  A size of zero is valid.  If an empty pooltag
    //  value is specified, the FLTMGR will use a context type specific tag.
    //
    //  If an explicit size is specified, the FLTMGR internally optimizes the
    //  allocation of that entry.
    //
    //  NOTE:  These fields are ignored if Allocate & Free routines are
    //         specifed.
    //

    SIZE_T Size;
    ULONG PoolTag;

    //
    //  Specifies the ALLOCATE and FREE routines that should be used
    //  when allocating a context for this mini-filter.
    //
    //  NOTE: The above size & PoolTag fields are ignored when these routines
    //        are defined.
    //

    PFLT_CONTEXT_ALLOCATE_CALLBACK ContextAllocateCallback;
    PFLT_CONTEXT_FREE_CALLBACK ContextFreeCallback;

    //
    //  Reserved for future expansion
    //

    PVOID Reserved1;

} FLT_CONTEXT_REGISTRATION, *PFLT_CONTEXT_REGISTRATION;

typedef const FLT_CONTEXT_REGISTRATION *PCFLT_CONTEXT_REGISTRATION;


///////////////////////////////////////////////////////////////////////////////
//
//                  Known File System Types
//
///////////////////////////////////////////////////////////////////////////////

//
//  The enum FLT_FILESYSTEM_TYPE has been moved to FltUserStructures.h
//  so it can be referenced by both user mode and kernel mode components
//


///////////////////////////////////////////////////////////////////////////////
//
//              Instance attach/detach callback definitions
//
///////////////////////////////////////////////////////////////////////////////

//
//                ******** Instance setup ********
//

//
//  Flags identifying why the given instance attach callback routine was
//  called.  More then one bit may be set.
//

typedef ULONG FLT_INSTANCE_SETUP_FLAGS;

    //
    //  If set, this is an automatic instance attachment notification.  These
    //  occur when the filter is first loaded for all existing volumes, and
    //  when a new volume is mounted.
    //

    #define FLTFL_INSTANCE_SETUP_AUTOMATIC_ATTACHMENT   0x00000001

    //
    //  If set, this is a manual instance attachment request via FilterAttach
    //  (user mode) or FltAttachVolume.
    //

    #define FLTFL_INSTANCE_SETUP_MANUAL_ATTACHMENT      0x00000002

    //
    //  If set, this is an automatic instance notification for a volume that
    //  has just been mounted in the system.
    //

    #define FLTFL_INSTANCE_SETUP_NEWLY_MOUNTED_VOLUME   0x00000004

#if FLT_MGR_LONGHORN
    //
    //  If set, this volume is not currently attached to a storage stack.
    //  This usually means the volume is dismounted but it does not always
    //  mean that.  There are scnearios with certain file systems (fat & cdfs
    //  being some) where a volume can become reattached after it has detached.
    //  This flag is only set in Longhorn or later.
    //

    #define FLTFL_INSTANCE_SETUP_DETACHED_VOLUME        0x00000008

#endif // FLT_MGR_LONGHORN


//
//  This is called whenever a new instance is being created.  This gives the
//  filter the opportunity to decide if they want to attach to the given
//  volume or not.
//
//  A SUCCESS return value will cause the instance to be attached to the given
//  volume.  A WARNING or ERROR return value will cause the instance to NOT be
//  attached to the given volume.  Following are reasonable sample return
//  values:
//      STATUS_SUCCESS
//      STATUS_FLT_DO_NOT_ATTACH
//
//  If no callback is defined the given instance will be attached.
//

typedef NTSTATUS
(FLTAPI *PFLT_INSTANCE_SETUP_CALLBACK) (
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in FLT_INSTANCE_SETUP_FLAGS Flags,
    __in DEVICE_TYPE VolumeDeviceType,
    __in FLT_FILESYSTEM_TYPE VolumeFilesystemType
    );


//
//          ******** Instance Query Detach ********
//

//
//  Flags identifying why the given instance query detach callback routine was
//  called.  More then one bit may be set.
//

typedef ULONG FLT_INSTANCE_QUERY_TEARDOWN_FLAGS;

  //
  //  No flags currently defined
  //

//
//  This is called whenever a manual detachment request is made for the given
//  instance.  This is not called for mandatory detachment requests (like
//  filter unload or volume dismount).  This gives the filter the opportunity
//  to decide if they want to detach from the given volume or not.
//
//  A SUCCESS return value will cause the instance to be detached from the
//  given volume.  A WARNING or ERROR return value will cause the instance to
//  NOT be detached from the given volume.  Following are reasonable sample
//  return values:
//      STATUS_SUCCESS
//      STATUS_FLT_DO_NOT_DETACH
//
//  If no callback is defined the given instance will NOT be detached.
//

typedef NTSTATUS
(FLTAPI *PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK) (
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags
    );


//
//          ******** Instance teardown ********
//

//
//  Flag identifying why the given instance detach callback routine was called.
//  More then one bit may be set.
//

typedef ULONG FLT_INSTANCE_TEARDOWN_FLAGS;

    //
    //  If set, this is a manual instance detach request via FilterDetach
    //  (user mode) or FltDetachVolume (kernel mode).
    //

    #define FLTFL_INSTANCE_TEARDOWN_MANUAL                  0x00000001

    //
    //  If set, the filter is being unloaded.
    //

    #define FLTFL_INSTANCE_TEARDOWN_FILTER_UNLOAD           0x00000002

    //
    //  If set, the filter is being unloaded.
    //

    #define FLTFL_INSTANCE_TEARDOWN_MANDATORY_FILTER_UNLOAD 0x00000004

    //
    //  If set, the volume is being dismounted.
    //

    #define FLTFL_INSTANCE_TEARDOWN_VOLUME_DISMOUNT         0x00000008

    //
    //  If set, an error occurred while doing instance setup (like running
    //  out of memory).
    //

    #define FLTFL_INSTANCE_TEARDOWN_INTERNAL_ERROR          0x00000010


//
//  This is the prototype for two different teardown callback routines.
//
//  The TEARDOWN_START routine is called at the beginning of teardown process.
//  There may still be operation callbacks in progress.  This is called to give
//  the filter the oppertunity to do the following things:
//  - Restart any pended operations
//  - Set state so that minimual processing will be performed on future
//    operation callbacks.
//  - Unregister from other OS callback APIs
//

//
//  The TEARDOWN_COMPLETE routine is called after teardown has been finished.
//  The system guarentees that all existing callbacks have been completed
//  before this routine is called.  This is called to give the filter the
//  oppertunity to:
//  - Close any open files.
//  - do other instance state cleanup.
//

typedef VOID
(FLTAPI *PFLT_INSTANCE_TEARDOWN_CALLBACK) (
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in FLT_INSTANCE_TEARDOWN_FLAGS Reason
    );

//////////////////////////////////////////////////////////////////////////////
//
//                  Pre/Post Operation Callback definitions
//
///////////////////////////////////////////////////////////////////////////////

//
//  Values returned from the pre-operation callback routine defining what
//  to do next.
//

typedef enum _FLT_PREOP_CALLBACK_STATUS {

    FLT_PREOP_SUCCESS_WITH_CALLBACK,
    FLT_PREOP_SUCCESS_NO_CALLBACK,
    FLT_PREOP_PENDING,
    FLT_PREOP_DISALLOW_FASTIO,
    FLT_PREOP_COMPLETE,
    FLT_PREOP_SYNCHRONIZE

} FLT_PREOP_CALLBACK_STATUS, *PFLT_PREOP_CALLBACK_STATUS;

//
//  Pre-operation callback prototype.
//

typedef FLT_PREOP_CALLBACK_STATUS
(FLTAPI *PFLT_PRE_OPERATION_CALLBACK) (
    __inout PFLT_CALLBACK_DATA Data,
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __deref_out_opt PVOID *CompletionContext
    );


//
//  Values returned from the post-operation callback routine defining what
//  to od next.
//

typedef enum _FLT_POSTOP_CALLBACK_STATUS {

    FLT_POSTOP_FINISHED_PROCESSING,
    FLT_POSTOP_MORE_PROCESSING_REQUIRED

} FLT_POSTOP_CALLBACK_STATUS, *PFLT_POSTOP_CALLBACK_STATUS;

//
//  Flag BITS sent to the post-operation callback routine
//

typedef ULONG FLT_POST_OPERATION_FLAGS;

    //
    //  If set, this instance is being detached and this post-operation
    //  routine has been called for cleanup processing (drained).  Since this
    //  instance is going away, you should perform a minimum of operations
    //  while processing this completion.
    //

    #define FLTFL_POST_OPERATION_DRAINING               0x00000001

//
//  Post-operation callback prototype
//

typedef FLT_POSTOP_CALLBACK_STATUS
(FLTAPI *PFLT_POST_OPERATION_CALLBACK) (
    __inout PFLT_CALLBACK_DATA Data,
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in_opt PVOID CompletionContext,
    __in FLT_POST_OPERATION_FLAGS Flags
    );

//
//  Post operation callbacks may be called at DPC level.  This routine may be
//  used to transfer completion processing to a "safe" IRQL level.  This
//  routine will determine if it is safe to call the "SafePostCallback" now
//  or if it must post the request to a worker thread.  If posting to a worker
//  thread is needed it determines it is safe to do so (some operations can
//  not be posted like paging IO).
//

BOOLEAN
FLTAPI
FltDoCompletionProcessingWhenSafe(
    __in PFLT_CALLBACK_DATA Data,
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in_opt PVOID CompletionContext,
    __in FLT_POST_OPERATION_FLAGS Flags,
    __in PFLT_POST_OPERATION_CALLBACK SafePostCallback,
    __out PFLT_POSTOP_CALLBACK_STATUS RetPostOperationStatus
    );

//
//  Defines current operation callback flags.
//

typedef ULONG FLT_OPERATION_REGISTRATION_FLAGS;

    //
    //  If set, the filter's callbacks for this operation will not be called,
    //  if it's a paging i/o operation. This flag is relevant only for IRP-based
    //  operations & ignored for non-IRP operations
    //

    #define FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO     0x00000001

    //
    //  If set read/write operations that are not non-cached will be skipped:
    //  i.e. the mini-filters callback for this operation will be bypassed.
    //  This flag is relevant only for IRP_MJ_READ & IRP_MJ_WRITE
    //  This of course implies that fast i/o reads and writes will be skipped,
    //  since those imply cached i/o by default
    //

    #define FLTFL_OPERATION_REGISTRATION_SKIP_CACHED_IO     0x00000002


//
//  Structure used for registering operation callback routines
//

typedef struct _FLT_OPERATION_REGISTRATION {

    UCHAR MajorFunction;
    FLT_OPERATION_REGISTRATION_FLAGS Flags;
    PFLT_PRE_OPERATION_CALLBACK PreOperation;
    PFLT_POST_OPERATION_CALLBACK PostOperation;

    PVOID Reserved1;

} FLT_OPERATION_REGISTRATION, *PFLT_OPERATION_REGISTRATION;


///////////////////////////////////////////////////////////////////////////////
//
//  This defines structures and flags for reparse point tag notifications
//  that a filter uses to register.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _FLT_TAG_DATA_BUFFER {
    ULONG FileTag;
    USHORT TagDataLength;
    USHORT UnparsedNameLength;
    union {
        struct {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            ULONG  Flags;
            WCHAR  PathBuffer[1];
        } SymbolicLinkReparseBuffer;

        struct {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            WCHAR PathBuffer[1];
        } MountPointReparseBuffer;

        struct {
            UCHAR  DataBuffer[1];
        } GenericReparseBuffer;

        //
        //  Used for non-Microsoft reparse points
        //

        struct {
            GUID TagGuid;
            UCHAR DataBuffer[1];
        } GenericGUIDReparseBuffer;
    };
} FLT_TAG_DATA_BUFFER, *PFLT_TAG_DATA_BUFFER;

#define FLT_TAG_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(FLT_TAG_DATA_BUFFER, GenericReparseBuffer)



///////////////////////////////////////////////////////////////////////////////
//
//                      Filter Unload Definitions
//
///////////////////////////////////////////////////////////////////////////////

typedef ULONG FLT_FILTER_UNLOAD_FLAGS;

    //
    //  If set, the OS has requested to unload this filter and the operation
    //  can not be failed.
    //

    #define FLTFL_FILTER_UNLOAD_MANDATORY               0x00000001


//
//  Callback to notify a filter it is being unloaded.  If the filter returns
//  a SUCCESS code, then the filter is unloaded.  If a WARNING or ERROR
//  code is returned then the filter is not unloaded.  If not callback is
//  defined the filter will not be unloaded.
//

typedef NTSTATUS
(FLTAPI *PFLT_FILTER_UNLOAD_CALLBACK) (
    FLT_FILTER_UNLOAD_FLAGS Flags
    );

/////////////////////////////////////////////////////////////////////////
//
//  Routines and structures for Name Providing Filter (filters that modify
//  names in the namespace).
//
////////////////////////////////////////////////////////////////////////

//
//  The FLT_NAME_CONTROL structure is used to efficiently manage a name buffer
//  as a name is generated by a filter that modifies the namespace.
//
//  The filter should never free or try to replace the buffer in the Name
//  UNICODE_STRING directly.  It should call FltNameControlCheckAndGrow to
//  varify that the buffer is large enough for more data to be added and grow
//  the buffer as needed.
//

typedef struct _FLT_NAME_CONTROL {

    //
    //  The unicode string where the name should be set.
    //

    UNICODE_STRING Name;

} FLT_NAME_CONTROL, *PFLT_NAME_CONTROL;

NTSTATUS
FLTAPI
FltCheckAndGrowNameControl (
    __inout PFLT_NAME_CONTROL NameCtrl,
    __in USHORT NewSize
    );

//
//  Define this hear for the PFLT_GENERATE_FILE_NAME signature.  This is defined
//  again later at the point where the flags are defined.
//

typedef ULONG FLT_FILE_NAME_OPTIONS;

typedef NTSTATUS
(FLTAPI *PFLT_GENERATE_FILE_NAME) (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in_opt PFLT_CALLBACK_DATA CallbackData,
    __in FLT_FILE_NAME_OPTIONS NameOptions,
    __out PBOOLEAN CacheFileNameInformation,
    __out PFLT_NAME_CONTROL FileName
    );

typedef ULONG FLT_NORMALIZE_NAME_FLAGS;

//
//  Normalize name flags
//

    #define FLTFL_NORMALIZE_NAME_CASE_SENSITIVE         0x01
    #define FLTFL_NORMALIZE_NAME_DESTINATION_FILE_NAME  0x02

typedef NTSTATUS
(FLTAPI *PFLT_NORMALIZE_NAME_COMPONENT) (
    __in PFLT_INSTANCE Instance,
    __in PCUNICODE_STRING ParentDirectory,
    __in USHORT VolumeNameLength,
    __in PCUNICODE_STRING Component,
    __out_bcount(ExpandCompnentNameLength) PFILE_NAMES_INFORMATION ExpandComponentName,
    __in ULONG ExpandComponentNameLength,
    __in FLT_NORMALIZE_NAME_FLAGS Flags,
    __deref_out_opt PVOID *NormalizationContext
    );

typedef NTSTATUS
(FLTAPI *PFLT_NORMALIZE_NAME_COMPONENT_EX) (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in PCUNICODE_STRING ParentDirectory,
    __in USHORT VolumeNameLength,
    __in PCUNICODE_STRING Component,
    __out_bcount(ExpandCompnentNameLength) PFILE_NAMES_INFORMATION ExpandComponentName,
    __in ULONG ExpandComponentNameLength,
    __in FLT_NORMALIZE_NAME_FLAGS Flags,
    __deref_out_opt PVOID *NormalizationContext
    );

typedef VOID
(FLTAPI *PFLT_NORMALIZE_CONTEXT_CLEANUP) (
    __in_opt PVOID *NormalizationContext
    );

NTSTATUS
FLTAPI
FltPurgeFileNameInformationCache (
    __in PFLT_INSTANCE Instance,
    __in_opt PFILE_OBJECT FileObject
    );

///////////////////////////////////////////////////////////////////////////////
//
//                 Transaction callback definitions
//
///////////////////////////////////////////////////////////////////////////////

#if FLT_MGR_LONGHORN

typedef NTSTATUS
(FLTAPI *PFLT_TRANSACTION_NOTIFICATION_CALLBACK) (
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in PFLT_CONTEXT TransactionContext,
    __in ULONG NotificationMask
    );

#endif // FLT_MGR_LONGHORN


//////////////////////////////////////////////////////////////////////////////
//
//  This structure is used at registration time to define what callbacks
//  this driver wishes to receive.
//
///////////////////////////////////////////////////////////////////////////////

//
//  This defines the MAJOR/MINOR version number to be passed in at registration
//  time.  The filter manager uses this number to validate / process the
//  parameters passed in.  Note that the minor version number can change and
//  you will still be able to register.  If the major version number changes
//  then the filter will no longer load.
//

//
//  Registration version for XP SP2 and W2K3 SP1
//

#define FLT_REGISTRATION_VERSION_0200  0x0200

//
//  Registration version for Vista Beta 2
//  (adds PFLT_TRANSACTION_NOTIFICATION_CALLBACK)
//

#define FLT_REGISTRATION_VERSION_0201  0x0201

//
//  Registration version for Vista RTM
//  (adds PFLT_NORMALIZE_NAME_COMPONENT_EX)
//

#define FLT_REGISTRATION_VERSION_0202  0x0202

//
//  NOTE:  You should always pass in this defined value (do not explicitly
//         specify older values)

#if FLT_MGR_LONGHORN
    #define FLT_REGISTRATION_VERSION   FLT_REGISTRATION_VERSION_0202  // Current version is 2.02
#else
    #define FLT_REGISTRATION_VERSION   FLT_REGISTRATION_VERSION_0200  // Current version is 2.00
#endif

//
//  Defines current registration flags
//

typedef ULONG FLT_REGISTRATION_FLAGS;

    //
    //  If set, this filter does not support a service stop request. This is
    //  is how the OS unloads drivers.
    //

    #define FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP  0x00000001

//
//  Registration structure
//

typedef struct _FLT_REGISTRATION {

    //
    //  The size, in bytes, of this registration structure.
    //

    USHORT Size;
    USHORT Version;

    //
    //  Flag values
    //

    FLT_REGISTRATION_FLAGS Flags;

    //
    //  Variable length array of routines that are used to manage contexts in
    //  the system.
    //

    CONST FLT_CONTEXT_REGISTRATION *ContextRegistration;

    //
    //  Variable length array of routines used for processing pre- and post-
    //  file system operations.
    //

    CONST FLT_OPERATION_REGISTRATION *OperationRegistration;

    //
    //  This is called before a filter is unloaded.  If an ERROR or WARNING
    //  status is returned then the filter is NOT unloaded.  A mandatory unload
    //  can not be failed.
    //
    //  If a NULL is specified for this routine, then the filter can never be
    //  unloaded.
    //

    PFLT_FILTER_UNLOAD_CALLBACK FilterUnloadCallback;

    //
    //  This is called to see if a filter would like to attach an instance
    //  to the given volume.  If an ERROR or WARNING status is returned, an
    //  attachment is not made.
    //
    //  If a NULL is specified for this routine, the attachment is always made.
    //

    PFLT_INSTANCE_SETUP_CALLBACK InstanceSetupCallback;

    //
    //  This is called to see if the filter wants to detach from the given
    //  volume.  This is only called for manual detach requests.  If an
    //  ERROR or WARNING status is returned, the filter is not detached.
    //
    //  If a NULL is specified for this routine, then instances can never be
    //  manually detached.
    //

    PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK InstanceQueryTeardownCallback;

    //
    //  This is called at the start of a filter detaching from a volume.
    //
    //  It is OK for this field to be NULL.
    //

    PFLT_INSTANCE_TEARDOWN_CALLBACK InstanceTeardownStartCallback;

    //
    //  This is called at the end of a filter detaching from a volume.  All
    //  outstanding operations have been completed by the time this routine
    //  is called.
    //
    //  It is OK for this field to be NULL.
    //

    PFLT_INSTANCE_TEARDOWN_CALLBACK InstanceTeardownCompleteCallback;

    //
    //  The following callbacks are provided by a filter only if it is
    //  interested in modifying the name space.
    //
    //  If NULL is specified for these callbacks, it is assumed that the
    //  filter would not affect the name being requested.
    //

    PFLT_GENERATE_FILE_NAME GenerateFileNameCallback;

    PFLT_NORMALIZE_NAME_COMPONENT NormalizeNameComponentCallback;

    PFLT_NORMALIZE_CONTEXT_CLEANUP NormalizeContextCleanupCallback;

    //
    //  The PFLT_NORMALIZE_NAME_COMPONENT_EX callback is also a name
    //  provider callback. It is not included here along with the
    //  other name provider callbacks to take care of the registration
    //  structure versioning issues.
    //

#if FLT_MGR_LONGHORN

    //
    //  This is called for transaction notifications received from the KTM
    //  when a filter has enlisted on that transaction.
    //

    PFLT_TRANSACTION_NOTIFICATION_CALLBACK TransactionNotificationCallback;

    //
    //  This is the extended normalize name component callback
    //  If a mini-filter provides this callback, then  this callback
    //  will be used as opposed to using PFLT_NORMALIZE_NAME_COMPONENT
    //
    //  The PFLT_NORMALIZE_NAME_COMPONENT_EX provides an extra parameter
    //  (PFILE_OBJECT) in addition to the parameters provided to
    //  PFLT_NORMALIZE_NAME_COMPONENT. A mini-filter may use this parameter
    //  to get to additional information like the TXN_PARAMETER_BLOCK.
    //
    //  A mini-filter that has no use for the additional parameter may
    //  only provide a PFLT_NORMALIZE_NAME_COMPONENT callback.
    //
    //  A mini-filter may provide both a PFLT_NORMALIZE_NAME_COMPONENT
    //  callback and a PFLT_NORMALIZE_NAME_COMPONENT_EX callback. The
    //  PFLT_NORMALIZE_NAME_COMPONENT_EX callback will be used by fltmgr
    //  versions that understand this callback (Vista RTM and beyond)
    //  and PFLT_NORMALIZE_NAME_COMPONENT callback will be used by fltmgr
    //  versions that do not understand the PFLT_NORMALIZE_NAME_COMPONENT_EX
    //  callback (prior to Vista RTM). This allows the same mini-filter
    //  binary to run with all versions of fltmgr.
    //

    PFLT_NORMALIZE_NAME_COMPONENT_EX NormalizeNameComponentExCallback;

#endif // FLT_MGR_LONGHORN

} FLT_REGISTRATION, *PFLT_REGISTRATION;



///////////////////////////////////////////////////////////////////////////////
//
// Callback routine for async i/o operations
//
///////////////////////////////////////////////////////////////////////////////

typedef VOID
(FLTAPI *PFLT_COMPLETED_ASYNC_IO_CALLBACK)(
    __in PFLT_CALLBACK_DATA CallbackData,
    __in PFLT_CONTEXT Context
    );


///////////////////////////////////////////////////////////////////////////////
//
// Flags that can be specified in Flt* APIs to indicate the nature of the
// i/o operation
//
// FltReadFile/FltWriteFile will accept these flags for example
//
///////////////////////////////////////////////////////////////////////////////

typedef ULONG FLT_IO_OPERATION_FLAGS;

    //
    //  If set, the given read/write request will be non-cached.
    //

    #define FLTFL_IO_OPERATION_NON_CACHED                   0x00000001

    //
    //  If set, the given read/write request will have the
    //  IRP_PAGING_IO flag set
    //

    #define FLTFL_IO_OPERATION_PAGING                       0x00000002

    //
    //  If set, the given read/write request will not update the
    //  file object's current byte offset.
    //

    #define FLTFL_IO_OPERATION_DO_NOT_UPDATE_BYTE_OFFSET    0x00000004

#if FLT_MGR_LONGHORN
    //
    //  If set, the given read/write request will have the
    //  IRP_SYNCHRONOUS_PAGING_IO flag set
    //

    #define FLTFL_IO_OPERATION_SYNCHRONOUS_PAGING           0x00000008

#endif // FLT_MGR_LONGHORN


///////////////////////////////////////////////////////////////////////////////
//
//  These routines are used to register/unregister all callback routines for a
//  give file system mini-filter driver.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltRegisterFilter (
    __in PDRIVER_OBJECT Driver,
    __in CONST FLT_REGISTRATION *Registration,
    __deref_out PFLT_FILTER *RetFilter
    );

VOID
FLTAPI
FltUnregisterFilter (
    __in PFLT_FILTER Filter
    );

NTSTATUS
FLTAPI
FltStartFiltering (
    __in PFLT_FILTER Filter
    );

PVOID
FLTAPI
FltGetRoutineAddress (
    __in PCSTR FltMgrRoutineName
    );

///////////////////////////////////////////////////////////////////////////////
//
//  Pending support routines
//
///////////////////////////////////////////////////////////////////////////////


VOID
FLTAPI
FltCompletePendedPreOperation (
    __in PFLT_CALLBACK_DATA CallbackData,
    __in FLT_PREOP_CALLBACK_STATUS CallbackStatus,
    __in_opt PVOID Context
    );

VOID
FLTAPI
FltCompletePendedPostOperation (
    __in PFLT_CALLBACK_DATA CallbackData
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for requesting operation status.  This is used to get the result
//  returned by IoCallDriver for operations where STATUS_PENDING is treated
//  as a success code.  This occurs with oplocks and directory change
//  notifications
//
///////////////////////////////////////////////////////////////////////////////

typedef VOID
(FLTAPI *PFLT_GET_OPERATION_STATUS_CALLBACK)(
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in PFLT_IO_PARAMETER_BLOCK IopbSnapshot,
    __in NTSTATUS OperationStatus,
    __in_opt PVOID RequesterContext
    );


NTSTATUS
FLTAPI
FltRequestOperationStatusCallback(
    __in PFLT_CALLBACK_DATA Data,
    __in PFLT_GET_OPERATION_STATUS_CALLBACK CallbackRoutine,
    __in_opt PVOID RequesterContext
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Memory support routines
//
///////////////////////////////////////////////////////////////////////////////


PVOID
FLTAPI
FltAllocatePoolAlignedWithTag (
    __in PFLT_INSTANCE Instance,
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    );

VOID
FLTAPI
FltFreePoolAlignedWithTag (
    __in PFLT_INSTANCE Instance,
    __in PVOID Buffer,
    __in ULONG Tag
    );

///////////////////////////////////////////////////////////////////////////////
//
//  Routines for getting file, directory and volume names.
//
///////////////////////////////////////////////////////////////////////////////

//
//  The FLT_FILE_NAME_OPTIONS is a ULONG that gets broken down into three
//  sections:
//   bits 0-7:  enumeration representing the file name formats available
//   bits 8-15: enumeration representing the querying methods available
//   bits 16-23:  Currently unused
//   bits 24-31:  Flags
//

typedef ULONG FLT_FILE_NAME_OPTIONS;

//
//  Name format options
//

#define FLT_VALID_FILE_NAME_FORMATS 0x000000ff

    #define FLT_FILE_NAME_NORMALIZED    0x01
    #define FLT_FILE_NAME_OPENED        0x02
    #define FLT_FILE_NAME_SHORT         0x03

#define FltGetFileNameFormat( _NameOptions ) \
    ((_NameOptions) & FLT_VALID_FILE_NAME_FORMATS)

//
//  Name query methods.
//

#define FLT_VALID_FILE_NAME_QUERY_METHODS 0x0000ff00

    //
    //  In the default mode, if it is safe to query the file system,
    //  the Filter Manager try to retrieve the name from the cache first, and,
    //  if a name is not found, the name will be generated by querying the file
    //  system.
    //
    #define FLT_FILE_NAME_QUERY_DEFAULT     0x0100

    //
    //  Query the Filter Manager's name cache for the name, but don't try
    //  to query the file system if the name is not in the cache.
    //
    #define FLT_FILE_NAME_QUERY_CACHE_ONLY  0x0200

    //
    //  Only query the file system for the name, bypassing the Filter Manager's
    //  name cache completely.  Any name retrieved will not be cached.
    //
    #define FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY 0x0300

    //
    //  Query the Filter Manager's name cache, but if the name is not
    //  found try to query the file system if it is safe to do so.
    //
    #define FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP 0x0400

#define FltGetFileNameQueryMethod( _NameOptions ) \
    ((_NameOptions) & FLT_VALID_FILE_NAME_QUERY_METHODS)

//
//  File name option flags
//

#define FLT_VALID_FILE_NAME_FLAGS 0xff000000

    //
    //  This flag is to be used by name provider filters to specify that a name
    //  query request they are making should be redirected to their filter rather
    //  than being satified by the name providers lower in the stack.
    //
    #define FLT_FILE_NAME_REQUEST_FROM_CURRENT_PROVIDER 0x01000000

    //
    //  This flag denotes that the name retrieved from this query should not
    //  be cached.  This is used by name providers as they perform intermediate
    //  queries to generate a name.
    //
    #define FLT_FILE_NAME_DO_NOT_CACHE                  0x02000000

#if FLT_MGR_AFTER_XPSP2

    //
    //  This flag denotes that it is safe to query the name in post-CREATE if
    //  STATUS_REPARSE was returned.  To ensure the name returned is valid,
    //  the call must know that the FileObject->FileName was not changed before
    //  STATUS_REPARSE was returned.
    //
    #define FLT_FILE_NAME_ALLOW_QUERY_ON_REPARSE        0x04000000

#endif

//
//  The flags are used to tell the file name routines which types of names
//  you would like parsed from the full name.  They are also used to specify
//  which names have been filled in for a given FLT_FILE_NAME_INFORMATION
//  structure.
//

typedef USHORT FLT_FILE_NAME_PARSED_FLAGS;

    #define FLTFL_FILE_NAME_PARSED_FINAL_COMPONENT      0x0001
    #define FLTFL_FILE_NAME_PARSED_EXTENSION            0x0002
    #define FLTFL_FILE_NAME_PARSED_STREAM               0x0004
    #define FLTFL_FILE_NAME_PARSED_PARENT_DIR           0x0008

//
//  This structure holds the different types of name information that
//  can be given for a file.  The NamesParsed field will have the
//  appropriate flags set to denote which names are filled in inside
//  the structure.
//

typedef struct _FLT_FILE_NAME_INFORMATION {

    USHORT Size;

    //
    //  For each bit that is set in the NamesParsed flags field, the
    //  corresponding substring from Name has been appropriately
    //  parsed into one of the unicode strings below.
    //

    FLT_FILE_NAME_PARSED_FLAGS NamesParsed;

    //
    //  The name format that this FLT_FILE_NAME_INFORMATION structure
    //  represents.
    //

    FLT_FILE_NAME_OPTIONS Format;

    //
    //  For normalized and opened names, this name contains the version of
    //  name in the following format:
    //
    //    [Volume name][Full path to file][File name][Stream Name]
    //
    //    For example, the above components would map to this example name as
    //    follows:
    //
    //    \Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1
    //
    //    [Volume name] = "\Device\HarddiskVolume1"
    //    [Full path to file] = "\Documents and Settings\MyUser\My Documents\"
    //    [File name] = "Test Results.txt"
    //    [Stream name] = ":stream1"
    //
    //  For short names, only the short name for the final name component is
    //  returned in the Name unicode string.  Therefore, if you requested
    //  the short name of the file object representing an open on the file:
    //
    //    \Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt
    //
    //  The name returned in Name will be at most 8 characters followed by a '.'
    //  then at most 3 more characters, like:
    //
    //    testre~1.txt
    //

    UNICODE_STRING Name;

    //
    //  The Volume is only filled in for name requested in normalized and opened
    //  formats.
    //

    UNICODE_STRING Volume;

    //
    //  The share component of the file name requested.  This will only be
    //  set for normalized and opened name formats on files that opened across
    //  redirectors.  For local files, this string will always be 0 length.
    //

    UNICODE_STRING Share;

    //
    //  To exemplify what each of the following substrings refer to, let's
    //  look again at the first example string from above:
    //
    //    \Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1
    //
    //  Extension = "txt"
    //  Stream = ":stream1"
    //  FinalComponent = "Test Results.txt:stream1"
    //  ParentDir = "\Documents and Settings\MyUser\My Documents\"
    //

    //
    //  This can be parsed from a normalized, opened, or short name.
    //

    UNICODE_STRING Extension;

    //
    //  The following parse formats are only available for normalized and
    //  opened name formats, but not short names.
    //

    UNICODE_STRING Stream;
    UNICODE_STRING FinalComponent;
    UNICODE_STRING ParentDir;

} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;

NTSTATUS
FLTAPI
FltGetFileNameInformation (
    __in PFLT_CALLBACK_DATA CallbackData,
    __in FLT_FILE_NAME_OPTIONS NameOptions,
    __deref_out PFLT_FILE_NAME_INFORMATION *FileNameInformation
    );

NTSTATUS
FLTAPI
FltGetFileNameInformationUnsafe (
    __in PFILE_OBJECT FileObject,
    __in_opt PFLT_INSTANCE Instance,
    __in FLT_FILE_NAME_OPTIONS NameOptions,
    __deref_out PFLT_FILE_NAME_INFORMATION *FileNameInformation
    );

VOID
FLTAPI
FltReleaseFileNameInformation (
    __in PFLT_FILE_NAME_INFORMATION FileNameInformation
    );

VOID
FLTAPI
FltReferenceFileNameInformation (
    __in PFLT_FILE_NAME_INFORMATION FileNameInformation
    );

NTSTATUS
FLTAPI
FltParseFileName (
    __in PCUNICODE_STRING FileName,
    __inout_opt PUNICODE_STRING Extension,
    __inout_opt PUNICODE_STRING Stream,
    __inout_opt PUNICODE_STRING FinalComponent
    );

NTSTATUS
FLTAPI
FltParseFileNameInformation (
    __inout PFLT_FILE_NAME_INFORMATION FileNameInformation
    );

NTSTATUS
FLTAPI
FltGetTunneledName (
    __in PFLT_CALLBACK_DATA CallbackData,
    __in PFLT_FILE_NAME_INFORMATION FileNameInformation,
    __deref_out_opt PFLT_FILE_NAME_INFORMATION *RetTunneledFileNameInformation
    );

NTSTATUS
FLTAPI
FltGetVolumeName (
    __in PFLT_VOLUME Volume,
    __inout_opt PUNICODE_STRING VolumeName,
    __out_opt PULONG BufferSizeNeeded
    );

NTSTATUS
FLTAPI
FltGetDestinationFileNameInformation (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in_opt HANDLE RootDirectory,
    __in_bcount(FileNameLength) PWSTR FileName,
    __in ULONG FileNameLength,
    __in FLT_FILE_NAME_OPTIONS NameOptions,
    __deref_out PFLT_FILE_NAME_INFORMATION *RetFileNameInformation
    );

NTSTATUS
FLTAPI
FltIsDirectory (
    __in PFILE_OBJECT FileObject,
    __in PFLT_INSTANCE Instance,
    __out PBOOLEAN IsDirectory
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for loading and unloading Filters
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltLoadFilter (
    __in PCUNICODE_STRING FilterName
    );

NTSTATUS
FLTAPI
FltUnloadFilter (
    __in PCUNICODE_STRING FilterName
    );

NTSTATUS
FLTAPI
FltAttachVolume (
    __inout PFLT_FILTER Filter,
    __inout PFLT_VOLUME Volume,
    __in_opt PCUNICODE_STRING InstanceName,
    __deref_opt_out_opt PFLT_INSTANCE *RetInstance
    );

NTSTATUS
FLTAPI
FltAttachVolumeAtAltitude (
    __inout PFLT_FILTER Filter,
    __inout PFLT_VOLUME Volume,
    __in PCUNICODE_STRING Altitude,
    __in_opt PCUNICODE_STRING InstanceName,
    __deref_opt_out_opt PFLT_INSTANCE *RetInstance
    );

NTSTATUS
FLTAPI
FltDetachVolume (
    __inout PFLT_FILTER Filter,
    __inout PFLT_VOLUME Volume,
    __in_opt PCUNICODE_STRING InstanceName
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for initiating I/O from within a filter.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltAllocateCallbackData (
    __in PFLT_INSTANCE Instance,
    __in_opt PFILE_OBJECT FileObject,
    __deref_out PFLT_CALLBACK_DATA *RetNewCallbackData
    );

VOID
FLTAPI
FltFreeCallbackData(
    __in PFLT_CALLBACK_DATA CallbackData
    );

VOID
FLTAPI
FltReuseCallbackData (
    __inout PFLT_CALLBACK_DATA CallbackData
    );

VOID
FLTAPI
FltPerformSynchronousIo (
    __inout PFLT_CALLBACK_DATA CallbackData
    );


NTSTATUS
FLTAPI
FltPerformAsynchronousIo (
    __inout PFLT_CALLBACK_DATA CallbackData,
    __in PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,
    __in PVOID CallbackContext
    );


#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltCreateFileEx2 (
    __in PFLT_FILTER Filter,
    __in_opt PFLT_INSTANCE Instance,
    __out PHANDLE FileHandle,
    __deref_opt_out PFILE_OBJECT *FileObject,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in ULONG FileAttributes,
    __in ULONG ShareAccess,
    __in ULONG CreateDisposition,
    __in ULONG CreateOptions,
    __in_bcount_opt(EaLength) PVOID EaBuffer,
    __in ULONG EaLength,
    __in ULONG Flags,
    __in_opt PIO_DRIVER_CREATE_CONTEXT DriverContext
    );

#endif

#if FLT_MGR_AFTER_XPSP2

//
//  Old version, please use the Ex2 version of this API when possible
//

NTSTATUS
FLTAPI
FltCreateFileEx (
    __in PFLT_FILTER Filter,
    __in_opt PFLT_INSTANCE Instance,
    __out PHANDLE FileHandle,
    __deref_opt_out PFILE_OBJECT *FileObject,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in ULONG FileAttributes,
    __in ULONG ShareAccess,
    __in ULONG CreateDisposition,
    __in ULONG CreateOptions,
    __in_bcount_opt(EaLength) PVOID EaBuffer,
    __in ULONG EaLength,
    __in ULONG Flags
    );

#endif

//
//  Old version, please use the Ex2 version of this API when possible
//

NTSTATUS
FLTAPI
FltCreateFile (
    __in PFLT_FILTER Filter,
    __in_opt PFLT_INSTANCE Instance,
    __out PHANDLE   FileHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_opt PLARGE_INTEGER AllocationSize,
    __in ULONG FileAttributes,
    __in ULONG ShareAccess,
    __in ULONG CreateDisposition,
    __in ULONG CreateOptions,
    __in_bcount_opt(EaLength)PVOID EaBuffer,
    __in ULONG EaLength,
    __in ULONG Flags
    );

#if FLT_MGR_AFTER_XPSP2

NTSTATUS
FLTAPI
FltOpenVolume (
    __in PFLT_INSTANCE Instance,
    __out PHANDLE VolumeHandle,
    __deref_opt_out PFILE_OBJECT *VolumeFileObject
    );

#endif

NTSTATUS
FLTAPI
FltReadFile (
    __in PFLT_INSTANCE InitiatingInstance,
    __in PFILE_OBJECT FileObject,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in ULONG Length,
    __out_bcount_part(Length,*BytesRead) PVOID Buffer,
    __in FLT_IO_OPERATION_FLAGS Flags,
    __out_opt PULONG BytesRead,
    __in_opt PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,
    __in_opt PVOID CallbackContext
    );

NTSTATUS
FLTAPI
FltTagFile (
    __in PFLT_INSTANCE InitiatingInstance,
    __in PFILE_OBJECT FileObject,
    __in ULONG FileTag,
    __in_opt GUID *Guid,
    __in_bcount(DataBufferLength) PVOID DataBuffer,
    __in USHORT DataBufferLength
    );

NTSTATUS
FLTAPI
FltUntagFile(
    __in PFLT_INSTANCE InitiatingInstance,
    __in PFILE_OBJECT FileObject,
    __in ULONG FileTag,
    __in_opt GUID *Guid
    );

NTSTATUS
FLTAPI
FltWriteFile (
    __in PFLT_INSTANCE InitiatingInstance,
    __in PFILE_OBJECT FileObject,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in ULONG Length,
    __in_bcount(Length) PVOID Buffer,
    __in FLT_IO_OPERATION_FLAGS Flags,
    __out_opt PULONG BytesWritten,
    __in_opt PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,
    __in_opt PVOID CallbackContext
    );

NTSTATUS
FLTAPI
FltQueryInformationFile (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __out_bcount_part(Length,*LengthReturned) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass,
    __out_opt PULONG LengthReturned
    );

NTSTATUS
FLTAPI
FltSetInformationFile (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltQueryDirectoryFile (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass,
    __in BOOLEAN ReturnSingleEntry,
    __in_opt PUNICODE_STRING FileName,
    __in BOOLEAN RestartScan,
    __out_opt PULONG LengthReturned
    );

#endif

#if FLT_MGR_AFTER_XPSP2

NTSTATUS
FLTAPI
FltQueryEaFile(
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __out_bcount_part(Length,*LengthReturned) PVOID ReturnedEaData,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in_bcount_opt(EaListLength) PVOID EaList,
    __in ULONG EaListLength,
    __in_opt PULONG EaIndex,
    __in BOOLEAN RestartScan,
    __out_opt PULONG LengthReturned
    );

NTSTATUS
FLTAPI
FltSetEaFile(
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in_bcount(Length) PVOID EaBuffer,
    __in ULONG Length
    );

#endif

NTSTATUS
FLTAPI
FltQueryVolumeInformationFile (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __out_bcount_part(Length,*LengthReturned) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass,
    __out_opt PULONG LengthReturned
    );

NTSTATUS
FLTAPI
FltQuerySecurityObject (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in SECURITY_INFORMATION SecurityInformation,
    __inout_bcount_opt(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG Length,
    __out PULONG LengthNeeded
    );

NTSTATUS
FLTAPI
FltSetSecurityObject (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
FLTAPI
FltFlushBuffers (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject
    );

NTSTATUS
FLTAPI
FltFsControlFile (
    __in PFLT_INSTANCE Instance,
    __in  PFILE_OBJECT FileObject,
    __in ULONG FsControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_part_opt(OutputBufferLength,*LengthReturned) PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __out_opt PULONG LengthReturned
    );

NTSTATUS
FLTAPI
FltDeviceIoControlFile (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in ULONG IoControlCode,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_part_opt(OutputBufferLength,*LengthReturned) PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __out_opt PULONG LengthReturned
    );

VOID
FLTAPI
FltReissueSynchronousIo (
   __in PFLT_INSTANCE InitiatingInstance,
   __in PFLT_CALLBACK_DATA CallbackData
   );

NTSTATUS
FLTAPI
FltClose(
   __in HANDLE FileHandle
   );

VOID
FLTAPI
FltCancelFileOpen (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject
    );

NTSTATUS
FLTAPI
FltCreateSystemVolumeInformationFolder (
    __in PFLT_INSTANCE Instance
    );

///////////////////////////////////////////////////////////////////////////////
//
//                  CONTEXT routines
//
///////////////////////////////////////////////////////////////////////////////

//
//  Returns TRUE if the given file object supports the given type of context.
//  FALSE otherwise.
//

#if FLT_MGR_LONGHORN

BOOLEAN
FLTAPI
FltSupportsFileContextsEx (
    __in PFILE_OBJECT FileObject,
    __in PFLT_INSTANCE Instance
    );

#endif

BOOLEAN
FLTAPI
FltSupportsFileContexts (
    __in PFILE_OBJECT FileObject
    );

BOOLEAN
FLTAPI
FltSupportsStreamContexts (
    __in PFILE_OBJECT FileObject
    );

BOOLEAN
FLTAPI
FltSupportsStreamHandleContexts (
    __in PFILE_OBJECT FileObject
    );


//
//  Called to allocate a context.  All context must be allocated via
//  this routine.
//

NTSTATUS
FLTAPI
FltAllocateContext (
    __in PFLT_FILTER Filter,
    __in FLT_CONTEXT_TYPE ContextType,
    __in SIZE_T ContextSize,
    __in POOL_TYPE PoolType,
    __deref_out_bcount(ContextSize) PFLT_CONTEXT *ReturnedContext
    );

//
//  Get and release multiple contexts
//

VOID
FLTAPI
FltGetContexts (
    __in PCFLT_RELATED_OBJECTS FltObjects,
    __in FLT_CONTEXT_TYPE DesiredContexts,
    __out PFLT_RELATED_CONTEXTS Contexts
    );

VOID
FLTAPI
FltReleaseContexts (
    __in PFLT_RELATED_CONTEXTS Contexts
    );


//
//  State values for the SetContext routines
//

typedef enum _FLT_SET_CONTEXT_OPERATION {

    //
    //  If a context already exists, replace with the given context.
    //  Return the old context.
    //

    FLT_SET_CONTEXT_REPLACE_IF_EXISTS,

    //
    //  If a context already exists, keep the old context and return an
    //  error status.  Return the old context (yes, we really do want to
    //  return the old context, the caller already has the new context).
    //  The context returned must later be released.
    //

    FLT_SET_CONTEXT_KEEP_IF_EXISTS

} FLT_SET_CONTEXT_OPERATION, *PFLT_SET_CONTEXT_OPERATION;

//
//  Routines for setting a context on a given object.  Once a context has
//  been set, it can not be freed except in the free context callback
//  routine.
//

NTSTATUS
FLTAPI
FltSetVolumeContext (
    __in PFLT_VOLUME Volume,
    __in FLT_SET_CONTEXT_OPERATION Operation,
    __in PFLT_CONTEXT NewContext,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltSetInstanceContext (
    __in PFLT_INSTANCE Instance,
    __in FLT_SET_CONTEXT_OPERATION Operation,
    __in PFLT_CONTEXT NewContext,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltSetFileContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in FLT_SET_CONTEXT_OPERATION Operation,
    __in PFLT_CONTEXT NewContext,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltSetStreamContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in FLT_SET_CONTEXT_OPERATION Operation,
    __in PFLT_CONTEXT NewContext,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltSetStreamHandleContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __in FLT_SET_CONTEXT_OPERATION Operation,
    __in PFLT_CONTEXT NewContext,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltSetTransactionContext (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in FLT_SET_CONTEXT_OPERATION Operation,
    __in PFLT_CONTEXT NewContext,
    __deref_opt_out PFLT_CONTEXT *OldContext
    );

#endif // FLT_MGR_LONGHORN

//
//  Routines for deleting a context on a given object.
//

VOID
FLTAPI
FltDeleteContext (
    __in PFLT_CONTEXT Context
    );

NTSTATUS
FLTAPI
FltDeleteVolumeContext (
    __in PFLT_FILTER Filter,
    __in PFLT_VOLUME Volume,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltDeleteInstanceContext (
    __in PFLT_INSTANCE Instance,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltDeleteFileContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltDeleteStreamContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );

NTSTATUS
FLTAPI
FltDeleteStreamHandleContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __deref_opt_out_opt PFLT_CONTEXT *OldContext
    );


#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltDeleteTransactionContext (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __deref_opt_out PFLT_CONTEXT *OldContext
    );

#endif // FLT_MGR_LONGHORN

//
//  Routines for getting/releasing contexts.  Any time a filter gets a context,
//  a corresponding release must be called.
//

NTSTATUS
FLTAPI
FltGetVolumeContext (
    __in PFLT_FILTER Filter,
    __in PFLT_VOLUME Volume,
    __deref_out PFLT_CONTEXT *Context
    );

NTSTATUS
FLTAPI
FltGetInstanceContext (
    __in PFLT_INSTANCE Instance,
    __deref_out PFLT_CONTEXT *Context
    );

NTSTATUS
FLTAPI
FltGetFileContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __deref_out PFLT_CONTEXT *Context
    );

NTSTATUS
FLTAPI
FltGetStreamContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __deref_out PFLT_CONTEXT *Context
    );

NTSTATUS
FLTAPI
FltGetStreamHandleContext (
    __in PFLT_INSTANCE Instance,
    __in PFILE_OBJECT FileObject,
    __deref_out PFLT_CONTEXT *Context
    );

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltGetTransactionContext (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __deref_out PFLT_CONTEXT *Context
    );

#endif // FLT_MGR_LONGHORN

//
//  This adds a reference to the given context structure.  The added reference
//  must be explicitly removed by a call to FltReleaseContext.
//

VOID
FLTAPI
FltReferenceContext (
    __in PFLT_CONTEXT Context
    );

//
//  Routine to release contexts
//

VOID
FLTAPI
FltReleaseContext (
    __in PFLT_CONTEXT Context
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for getting handles to Filters, Instances,
//  and Volumes.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltGetFilterFromName (
    __in PCUNICODE_STRING FilterName,
    __deref_out PFLT_FILTER *RetFilter
    );

NTSTATUS
FLTAPI
FltGetVolumeFromName (
    __in PFLT_FILTER Filter,
    __in PCUNICODE_STRING VolumeName,
    __deref_out PFLT_VOLUME *RetVolume
    );

NTSTATUS
FLTAPI
FltGetVolumeInstanceFromName (
    __in_opt PFLT_FILTER Filter,
    __in PFLT_VOLUME Volume,
    __in_opt PCUNICODE_STRING InstanceName,
    __deref_out PFLT_INSTANCE *RetInstance
    );

NTSTATUS
FLTAPI
FltGetVolumeFromInstance (
    __in PFLT_INSTANCE Instance,
    __deref_out PFLT_VOLUME *RetVolume
    );

NTSTATUS
FLTAPI
FltGetFilterFromInstance (
    __in PFLT_INSTANCE Instance,
    __deref_out PFLT_FILTER *RetFilter
    );

NTSTATUS
FLTAPI
FltGetVolumeFromFileObject (
    __in PFLT_FILTER Filter,
    __in PFILE_OBJECT FileObject,
    __deref_out PFLT_VOLUME *RetVolume
    );

NTSTATUS
FLTAPI
FltGetVolumeFromDeviceObject (
    __in PFLT_FILTER Filter,
    __in PDEVICE_OBJECT DeviceObject,
    __deref_out PFLT_VOLUME *RetVolume
    );

#if FLT_MGR_LONGHORN

BOOLEAN
FLTAPI
FltIsFltMgrVolumeDeviceObject(
    __in PDEVICE_OBJECT DeviceObject
    );

#endif

NTSTATUS
FLTAPI
FltGetDeviceObject (
    __in PFLT_VOLUME Volume,
    __deref_out PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
FLTAPI
FltGetDiskDeviceObject(
    __in PFLT_VOLUME Volume,
    __deref_out PDEVICE_OBJECT *DiskDeviceObject
    );

NTSTATUS
FLTAPI
FltGetLowerInstance (
    __in PFLT_INSTANCE CurrentInstance,
    __deref_out PFLT_INSTANCE *LowerInstance
    );

NTSTATUS
FLTAPI
FltGetUpperInstance (
    __in PFLT_INSTANCE CurrentInstance,
    __deref_out PFLT_INSTANCE *UpperInstance
    );

NTSTATUS
FLTAPI
FltGetTopInstance (
    __in PFLT_VOLUME Volume,
    __deref_out PFLT_INSTANCE *Instance
    );

NTSTATUS
FLTAPI
FltGetBottomInstance (
    __in PFLT_VOLUME Volume,
    __deref_out PFLT_INSTANCE *Instance
    );

LONG
FLTAPI
FltCompareInstanceAltitudes (
    __in PFLT_INSTANCE Instance1,
    __in PFLT_INSTANCE Instance2
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for getting information on Filters and Filter Instances.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltGetFilterInformation (
    __in PFLT_FILTER Filter,
    __in FILTER_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize, *BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );

NTSTATUS
FLTAPI
FltGetInstanceInformation (
    __in PFLT_INSTANCE Instance,
    __in INSTANCE_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize,*BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltGetVolumeInformation (
    __in PFLT_VOLUME Volume,
    __in FILTER_VOLUME_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize,*BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );

#endif // FLT_MGR_LONGHORN

///////////////////////////////////////////////////////////////////////////////
//
//  Routines for getting information about Volumes.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _FLT_VOLUME_PROPERTIES {

    //
    //  The possible DeviceTypes are defined in NTIFS.H and begin with
    //  FILE_DEVICE_
    //

    DEVICE_TYPE DeviceType;

    //
    //  The possible DeviceCharacteristics flags are defined in NTIFS.H.
    //  Potential values are:
    //      FILE_REMOVABLE_MEDIA
    //      FILE_READ_ONLY_DEVICE
    //      FILE_FLOPPY_DISKETTE
    //      FILE_WRITE_ONCE_MEDIA
    //      FILE_REMOTE_DEVICE
    //      FILE_DEVICE_IS_MOUNTED
    //      FILE_VIRTUAL_VOLUME
    //      FILE_AUTOGENERATED_DEVICE_NAME
    //      FILE_DEVICE_SECURE_OPEN
    //

    ULONG DeviceCharacteristics;

    //
    //  The possible DeviceObjectFlags are define in NTIFS.H.  All potential
    //  values begin with DO_.
    //

    ULONG DeviceObjectFlags;

    ULONG AlignmentRequirement;

    USHORT SectorSize;

    USHORT Reserved0;

    //
    //  The name of the file system driver associated with this device.
    //
    //  The buffer for this unicode string is contiguous with this structure and
    //  does not need to be initialized before calling FltGetVolumeProperties.
    //

    UNICODE_STRING FileSystemDriverName;

    //
    //  The name of the file system device associated with this device.
    //
    //  The buffer for this unicode string is contiguous with this structure and
    //  does not need to be initialized before calling FltGetVolumeProperties.
    //

    UNICODE_STRING FileSystemDeviceName;

    //
    //  The name of the real device object associated with this device.  This
    //  is empty for network file systems.
    //
    //  The buffer for this unicode string is contiguous with this structure and
    //  does not need to be initialized before calling FltGetVolumeProperties.
    //

    UNICODE_STRING RealDeviceName;

} FLT_VOLUME_PROPERTIES, *PFLT_VOLUME_PROPERTIES;

NTSTATUS
FLTAPI
FltGetVolumeProperties (
    __in PFLT_VOLUME Volume,
    __out_bcount_part_opt(VolumePropertiesLength,*LengthReturned) PFLT_VOLUME_PROPERTIES VolumeProperties,
    __in ULONG VolumePropertiesLength,
    __out PULONG LengthReturned
    );

NTSTATUS
FLTAPI
FltGetFileSystemType (
    __in PVOID FltObject,
    __out PFLT_FILESYSTEM_TYPE FileSystemType
    );

NTSTATUS
FLTAPI
FltIsVolumeWritable (
    __in PVOID FltObject,
    __out PBOOLEAN IsWritable
    );

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltIsVolumeSnapshot (
    __in PVOID FltObject,
    __out PBOOLEAN IsSnapshotVolume
    );

#endif // FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltGetVolumeGuidName (
    __in PFLT_VOLUME Volume,
    __out PUNICODE_STRING VolumeGuidName,
    __out_opt PULONG BufferSizeNeeded
    );

NTSTATUS
FLTAPI
FltQueryVolumeInformation(
    __in PFLT_INSTANCE Instance,
    __out PIO_STATUS_BLOCK Iosb,
    __out_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );

NTSTATUS
FLTAPI
FltSetVolumeInformation(
    __in PFLT_INSTANCE Instance,
    __out PIO_STATUS_BLOCK Iosb,
    __out_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for enumerating Filter information, Instance informations and
//  Filter Instances in the system.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltEnumerateFilters (
    __out_ecount_part_opt(FilterListSize,*NumberFiltersReturned) PFLT_FILTER *FilterList,
    __in ULONG FilterListSize,
    __out PULONG NumberFiltersReturned
    );

NTSTATUS
FLTAPI
FltEnumerateVolumes (
    __in PFLT_FILTER Filter,
    __out_ecount_part_opt(VolumeListSize,*NumberVolumesReturned) PFLT_VOLUME *VolumeList,
    __in ULONG VolumeListSize,
    __out PULONG NumberVolumesReturned
    );

NTSTATUS
FLTAPI
FltEnumerateInstances (
    __in_opt PFLT_VOLUME Volume,
    __in_opt PFLT_FILTER Filter,
    __out_ecount_part_opt(InstanceListSize,*NumberInstancesReturned) PFLT_INSTANCE *InstanceList,
    __in ULONG InstanceListSize,
    __out PULONG NumberInstancesReturned
    );

NTSTATUS
FLTAPI
FltEnumerateFilterInformation (
    __in ULONG Index,
    __in FILTER_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize,*BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );

NTSTATUS
FLTAPI
FltEnumerateInstanceInformationByFilter (
    __in PFLT_FILTER Filter,
    __in ULONG Index,
    __in INSTANCE_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize,*BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );

NTSTATUS
FLTAPI
FltEnumerateInstanceInformationByVolume (
    __in PFLT_VOLUME Volume,
    __in ULONG Index,
    __in INSTANCE_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize,*BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );

NTSTATUS
FLTAPI
FltEnumerateVolumeInformation (
    __in PFLT_FILTER Filter,
    __in ULONG Index,
    __in FILTER_VOLUME_INFORMATION_CLASS InformationClass,
    __out_bcount_part_opt(BufferSize,*BytesReturned) PVOID Buffer,
    __in ULONG BufferSize,
    __out PULONG BytesReturned
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines for referencing and closing FLT_VOLUMEs, FLT_INSTANCEs, and
//  FLT_FILTERs.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
FLTAPI
FltObjectReference (
    __inout PVOID FltObject
    );

VOID
FLTAPI
FltObjectDereference (
    __inout PVOID FltObject
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines & defs for sending messages from a filter to a user-mode component.
//
///////////////////////////////////////////////////////////////////////////////

//
//  Access masks for filter communication ports
//

#define FLT_PORT_CONNECT        0x0001
#define FLT_PORT_ALL_ACCESS     (FLT_PORT_CONNECT | STANDARD_RIGHTS_ALL)

//
//  Callback to notify a filter it has received a message from a user App
//

typedef NTSTATUS
(FLTAPI *PFLT_MESSAGE_NOTIFY) (
    __in_opt PVOID PortCookie,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_part_opt(OutputBufferLength,*ReturnOutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __out PULONG ReturnOutputBufferLength
    );

//
//  Callback to notify a filter when a new connection to a port is established
//

typedef NTSTATUS
(FLTAPI *PFLT_CONNECT_NOTIFY) (
      __in PFLT_PORT ClientPort,
      __in_opt PVOID ServerPortCookie,
      __in_bcount_opt(SizeOfContext) PVOID ConnectionContext,
      __in ULONG SizeOfContext,
      __deref_out_opt PVOID *ConnectionPortCookie
      );

//
//  Callback to notify a filter when a connection to a port is being torn down
//

typedef VOID
(FLTAPI *PFLT_DISCONNECT_NOTIFY) (
      __in_opt PVOID ConnectionCookie
      );

NTSTATUS
FLTAPI
FltCreateCommunicationPort (
    __in PFLT_FILTER Filter,
    __deref_out PFLT_PORT *ServerPort,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PVOID ServerPortCookie,
    __in PFLT_CONNECT_NOTIFY ConnectNotifyCallback,
    __in PFLT_DISCONNECT_NOTIFY DisconnectNotifyCallback,
    __in_opt PFLT_MESSAGE_NOTIFY MessageNotifyCallback,
    __in LONG MaxConnections
    );

VOID
FLTAPI
FltCloseCommunicationPort (
    __in PFLT_PORT ServerPort
    );

VOID
FLTAPI
FltCloseClientPort (
    __in PFLT_FILTER Filter,
    __deref_out PFLT_PORT *ClientPort
    );

NTSTATUS
FLTAPI
FltSendMessage (
    __in PFLT_FILTER Filter,
    __deref_in PFLT_PORT *ClientPort,
    __in_bcount(SenderBufferLength) PVOID SenderBuffer,
    __in ULONG SenderBufferLength,
    __out_bcount_opt(*ReplyLength) PVOID ReplyBuffer,
    __inout_opt PULONG ReplyLength,
    __in_opt PLARGE_INTEGER Timeout
    );

NTSTATUS
FLTAPI
FltBuildDefaultSecurityDescriptor(
     __deref_out PSECURITY_DESCRIPTOR *SecurityDescriptor,
     __in ACCESS_MASK DesiredAccess
     );

VOID
FLTAPI
FltFreeSecurityDescriptor(
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );

///////////////////////////////////////////////////////////////////////////////
//
//  Plain cancel support. Note that using callback data queues and
//  setting the cancel routine manually is not supported
//
///////////////////////////////////////////////////////////////////////////////

typedef VOID
(FLTAPI *PFLT_COMPLETE_CANCELED_CALLBACK) (
    __in PFLT_CALLBACK_DATA CallbackData
);

BOOLEAN
FLTAPI
FltCancelIo(
    __in PFLT_CALLBACK_DATA CallbackData
    );

NTSTATUS
FLTAPI
FltSetCancelCompletion (
    __in PFLT_CALLBACK_DATA CallbackData,
    __in PFLT_COMPLETE_CANCELED_CALLBACK CanceledCallback
    );

NTSTATUS
FLTAPI
FltClearCancelCompletion(
    __in PFLT_CALLBACK_DATA CallbackData
    );

BOOLEAN
FLTAPI
FltIsIoCanceled(
    __in PFLT_CALLBACK_DATA CallbackData
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Workqueue wrappers
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _FLT_DEFERRED_IO_WORKITEM *PFLT_DEFERRED_IO_WORKITEM;
typedef struct _FLT_GENERIC_WORKITEM *PFLT_GENERIC_WORKITEM;

typedef VOID
(FLTAPI *PFLT_DEFERRED_IO_WORKITEM_ROUTINE) (
    __in PFLT_DEFERRED_IO_WORKITEM FltWorkItem,
    __in PFLT_CALLBACK_DATA CallbackData,
    __in_opt PVOID Context
    );

typedef VOID
(FLTAPI *PFLT_GENERIC_WORKITEM_ROUTINE) (
    __in PFLT_GENERIC_WORKITEM FltWorkItem,
    __in PVOID FltObject,
    __in_opt PVOID Context
    );

PFLT_DEFERRED_IO_WORKITEM
FLTAPI
FltAllocateDeferredIoWorkItem(
    VOID
    );

VOID
FLTAPI
FltFreeDeferredIoWorkItem (
    __in PFLT_DEFERRED_IO_WORKITEM FltWorkItem
    );

PFLT_GENERIC_WORKITEM
FLTAPI
FltAllocateGenericWorkItem(
    VOID
    );

VOID
FLTAPI
FltFreeGenericWorkItem (
    __in PFLT_GENERIC_WORKITEM FltWorkItem
    );

NTSTATUS
FLTAPI
FltQueueDeferredIoWorkItem (
    __in PFLT_DEFERRED_IO_WORKITEM FltWorkItem,
    __in PFLT_CALLBACK_DATA Data,
    __in PFLT_DEFERRED_IO_WORKITEM_ROUTINE WorkerRoutine,
    __in WORK_QUEUE_TYPE QueueType,
    __in PVOID Context
    );

NTSTATUS
FLTAPI
FltQueueGenericWorkItem (
    __in PFLT_GENERIC_WORKITEM FltWorkItem,
    __in PVOID FltObject,
    __in PFLT_GENERIC_WORKITEM_ROUTINE WorkerRoutine,
    __in WORK_QUEUE_TYPE QueueType,
    __in_opt PVOID Context
    );



///////////////////////////////////////////////////////////////////////////////
//
//  Routines for decoding params, locking data buffers etc.
//
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
FLTAPI
FltLockUserBuffer(
    __in PFLT_CALLBACK_DATA CallbackData
    );

NTSTATUS
FLTAPI
FltDecodeParameters(
    __in PFLT_CALLBACK_DATA CallbackData,
    __deref_opt_out PMDL **MdlAddressPointer,
    __deref_opt_out_bcount(**Length) PVOID  **Buffer,
    __deref_opt_out PULONG *Length,
    __out_opt LOCK_OPERATION *DesiredAccess
    );

PMDL
FASTCALL
FltGetSwappedBufferMdlAddress(
    __in PFLT_CALLBACK_DATA CallbackData
    );

VOID
FASTCALL
FltRetainSwappedBufferMdlAddress(
    __in PFLT_CALLBACK_DATA CallbackData
    );

///////////////////////////////////////////////////////////////////////////////
//
//  Routines for accessing cancel-safe queue abstraction provided by
//  filter manager
//
///////////////////////////////////////////////////////////////////////////////

//
// The cancel safe queue is not exposed in the w2k DDK headers, so we
// define what is neccesary here.
//

typedef IO_CSQ_IRP_CONTEXT FLT_CALLBACK_DATA_QUEUE_IO_CONTEXT, *PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT;

//
// Forward define callback data queue
//

typedef struct _FLT_CALLBACK_DATA_QUEUE FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;

//
// Routines that insert/remove callback data's
//

typedef NTSTATUS
(FLTAPI *PFLT_CALLBACK_DATA_QUEUE_INSERT_IO)(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in PFLT_CALLBACK_DATA Cbd,
    __in_opt PVOID InsertContext
    );

typedef VOID
(FLTAPI *PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO)(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in PFLT_CALLBACK_DATA Cbd
    );

//
// Retrieves the next callback data from the queue. NULL if none are left.
// If Cbd is NULL, returns the entry at the head of the queue. Does not remove
// Cbd from queue.
//

typedef PFLT_CALLBACK_DATA
(FLTAPI *PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO)(
    __in PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in_opt PFLT_CALLBACK_DATA Cbd,
    __in_opt PVOID PeekContext
    );

//
//  Lock routine that protects the cancel safe queue
//

typedef VOID
(FLTAPI *PFLT_CALLBACK_DATA_QUEUE_ACQUIRE)(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __out PKIRQL Irql
    );

typedef VOID
(FLTAPI *PFLT_CALLBACK_DATA_QUEUE_RELEASE)(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in KIRQL Irql
    );

//
//  Cancel routine callback for queued callback data's
//

typedef VOID
(FLTAPI *PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO)(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __inout PFLT_CALLBACK_DATA Cbd
    );


typedef enum _FLT_CALLBACK_DATA_QUEUE_FLAGS FLT_CALLBACK_DATA_QUEUE_FLAGS;
//
// Following structure is opaque to filters, but allocated by them.
//

typedef struct _FLT_CALLBACK_DATA_QUEUE {

    //
    //  Embedded IRP cancel queue: this is opaque to minifilters
    //

    IO_CSQ Csq;

    //
    //  Flags .. These are private to filter manager
    //

    FLT_CALLBACK_DATA_QUEUE_FLAGS Flags;

    //
    //  Instance that is using this queue
    //

    PFLT_INSTANCE Instance;

    //
    //  Cancel-safe queue callbacks
    //

    PFLT_CALLBACK_DATA_QUEUE_INSERT_IO                   InsertIo;
    PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO                   RemoveIo;
    PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO                PeekNextIo;
    PFLT_CALLBACK_DATA_QUEUE_ACQUIRE                     Acquire;
    PFLT_CALLBACK_DATA_QUEUE_RELEASE                     Release;
    PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO        CompleteCanceledIo;


} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;


NTSTATUS
FLTAPI
FltCbdqInitialize(
    __in PFLT_INSTANCE                                       Instance,
    __inout PFLT_CALLBACK_DATA_QUEUE                         Cbdq,
    __in PFLT_CALLBACK_DATA_QUEUE_INSERT_IO                  CbdqInsertIo,
    __in PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO                  CbdqRemoveIo,
    __in PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO               CbdqPeekNextIo,
    __in PFLT_CALLBACK_DATA_QUEUE_ACQUIRE                    CbdqAcquire,
    __in PFLT_CALLBACK_DATA_QUEUE_RELEASE                    CbdqRelease,
    __in PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO       CbdqCompleteCanceledIo
    );

VOID
FLTAPI
FltCbdqEnable(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq
    );

VOID
FLTAPI
FltCbdqDisable(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq
    );

NTSTATUS
FLTAPI
FltCbdqInsertIo(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in PFLT_CALLBACK_DATA Cbd,
    __in_opt PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context,
    __in_opt PVOID InsertContext
    );

PFLT_CALLBACK_DATA
FLTAPI
FltCbdqRemoveIo(
    __inout PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context
    );

PFLT_CALLBACK_DATA
FLTAPI
FltCbdqRemoveNextIo(
    __inout  PFLT_CALLBACK_DATA_QUEUE Cbdq,
    __in_opt  PVOID     PeekContext
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Routines and callbacks for handling oplocks provided by filter manager
//
///////////////////////////////////////////////////////////////////////////////

typedef
VOID
(FLTAPI *PFLTOPLOCK_WAIT_COMPLETE_ROUTINE) (
    __in PFLT_CALLBACK_DATA CallbackData,
    __in_opt PVOID Context
    );

typedef
VOID
(FLTAPI *PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE) (
    __in PFLT_CALLBACK_DATA CallbackData,
    __in_opt PVOID Context
    );

//
// Oplock support routines.
//

VOID
FLTAPI
FltInitializeOplock (
    __out POPLOCK Oplock
    );

VOID
FLTAPI
FltUninitializeOplock (
    __in POPLOCK Oplock
    );

FLT_PREOP_CALLBACK_STATUS
FLTAPI
FltOplockFsctrl (
    __in POPLOCK Oplock,
    __in PFLT_CALLBACK_DATA CallbackData,
    __in ULONG OpenCount
    );

FLT_PREOP_CALLBACK_STATUS
FLTAPI
FltCheckOplock (
    __in POPLOCK Oplock,
    __in PFLT_CALLBACK_DATA CallbackData,
    __in PVOID Context,
    __in_opt PFLTOPLOCK_WAIT_COMPLETE_ROUTINE WaitCompletionRoutine,
    __in_opt PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE PrePostCallbackDataRoutine
    );

BOOLEAN
FLTAPI
FltOplockIsFastIoPossible (
    __in POPLOCK Oplock
    );

BOOLEAN
FLTAPI
FltCurrentBatchOplock (
    __in POPLOCK Oplock
    );

///////////////////////////////////////////////////////////////////////////////
//
//  Routines and callbacks for handling file lock support provided by filter manager
//
///////////////////////////////////////////////////////////////////////////////

typedef
NTSTATUS
(*PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE) (
    __in_opt PVOID Context,
    __in PFLT_CALLBACK_DATA CallbackData
    );

VOID
FLTAPI
FltInitializeFileLock (
    __out PFILE_LOCK FileLock
    );

VOID
FLTAPI
FltUninitializeFileLock (
    __in PFILE_LOCK FileLock
    );

PFILE_LOCK
FLTAPI
FltAllocateFileLock (
    __in_opt PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,
    __in_opt PUNLOCK_ROUTINE UnlockRoutine
    );

VOID
FLTAPI
FltFreeFileLock (
    __in PFILE_LOCK FileLock
    );

FLT_PREOP_CALLBACK_STATUS
FLTAPI
FltProcessFileLock (
    __in PFILE_LOCK FileLock,
    __in PFLT_CALLBACK_DATA CallbackData,
    __in_opt PVOID Context
    );

BOOLEAN
FLTAPI
FltCheckLockForReadAccess (
    __in PFILE_LOCK FileLock,
    __in PFLT_CALLBACK_DATA CallbackData
    );

BOOLEAN
FLTAPI
FltCheckLockForWriteAccess (
    __in PFILE_LOCK FileLock,
    __in PFLT_CALLBACK_DATA CallbackData
    );


///////////////////////////////////////////////////////////////////////////////
//
//                          Locking Primitives
//
///////////////////////////////////////////////////////////////////////////////

//
//  EResource APIs which do proper wrapping of KeEnterCriticalRegion and
//  KeExitCriticalRegion to disable APCs (except Special Kernel APCs) while
//  the lock is held
//
//  Use ExInitializeResourceLite() to init the resource
//  Use ExDeleteResourceLite() to delete the resource
//

VOID
FLTAPI
FltAcquireResourceExclusive(
    __inout PERESOURCE Resource
    );

VOID
FLTAPI
FltAcquireResourceShared(
    __inout PERESOURCE Resource
    );

VOID
FLTAPI
FltReleaseResource(
    __inout PERESOURCE Resource
    );


//
//  PUSHLOCK APIs which do proper wrapping of KeEnterCriticalRegion and
//  KeExitCriticalRegion to disable APCs (except Special Kernel APCs) while
//  the lock is held
//

VOID
FLTAPI
FltInitializePushLock(
    __out PEX_PUSH_LOCK PushLock
    );

VOID
FLTAPI
FltDeletePushLock(
    __in PEX_PUSH_LOCK PushLock
    );

VOID
FLTAPI
FltAcquirePushLockExclusive(
    __inout PEX_PUSH_LOCK PushLock
    );

VOID
FLTAPI
FltAcquirePushLockShared(
    __inout PEX_PUSH_LOCK PushLock
    );

VOID
FLTAPI
FltReleasePushLock(
    __inout PEX_PUSH_LOCK PushLock
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Synchronization support routines
//
///////////////////////////////////////////////////////////////////////////////

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltCancellableWaitForSingleObject(
    __in PVOID Object,
    __in_opt PLARGE_INTEGER Timeout,
    __in_opt PFLT_CALLBACK_DATA CallbackData
    );

NTSTATUS
FLTAPI
FltCancellableWaitForMultipleObjects(
    __in ULONG Count,
    __in_ecount(Count) PVOID ObjectArray[],
    __in WAIT_TYPE WaitType,
    __in_opt PLARGE_INTEGER Timeout,
    __in_opt PKWAIT_BLOCK WaitBlockArray,
    __in PFLT_CALLBACK_DATA CallbackData
    );

#endif // FLT_MGR_LONGHORN


///////////////////////////////////////////////////////////////////////////////
//
//  General support routines
//
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
FLTAPI
FltIsOperationSynchronous (
    __in PFLT_CALLBACK_DATA CallbackData
    );

BOOLEAN
FLTAPI
FltIs32bitProcess (
    __in_opt PFLT_CALLBACK_DATA CallbackData
    );

PEPROCESS
FLTAPI
FltGetRequestorProcess (
    __in PFLT_CALLBACK_DATA CallbackData
    );

ULONG
FLTAPI
FltGetRequestorProcessId (
    __in PFLT_CALLBACK_DATA CallbackData
    );

#if FLT_MGR_LONGHORN

HANDLE
FLTAPI
FltGetRequestorProcessIdEx (
    __in PFLT_CALLBACK_DATA CallbackData
    );

#endif // FLT_MGR_LONGHORN

VOID
FLTAPI
FltNotifyFilterChangeDirectory (
    __inout PNOTIFY_SYNC NotifySync,
    __inout PLIST_ENTRY NotifyList,
    __in PVOID FsContext,
    __in PSTRING FullDirectoryName,
    __in BOOLEAN WatchTree,
    __in BOOLEAN IgnoreBuffer,
    __in ULONG CompletionFilter,
    __in PFLT_CALLBACK_DATA NotifyCallbackData,
    __in_opt PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in_opt PFILTER_REPORT_CHANGE FilterCallback
    );


///////////////////////////////////////////////////////////////////////////////
//
//  Transaction (TxF) support routines
//
///////////////////////////////////////////////////////////////////////////////

#if FLT_MGR_LONGHORN

//
//  Select ALL transaction notification values
//

#define FLT_MAX_TRANSACTION_NOTIFICATIONS \
                (TRANSACTION_NOTIFY_PREPREPARE | \
                 TRANSACTION_NOTIFY_PREPARE | \
                 TRANSACTION_NOTIFY_COMMIT | \
                 TRANSACTION_NOTIFY_ROLLBACK | \
                 TRANSACTION_NOTIFY_COMMIT_FINALIZE)

NTSTATUS
FLTAPI
FltEnlistInTransaction (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in PFLT_CONTEXT TransactionContext,
    __in NOTIFICATION_MASK NotificationMask
    );

NTSTATUS
FLTAPI
FltRollbackEnlistment (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in_opt PFLT_CONTEXT TransactionContext
    );

NTSTATUS
FLTAPI
FltPrePrepareComplete (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in_opt PFLT_CONTEXT TransactionContext
    );

NTSTATUS
FLTAPI
FltPrepareComplete (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in_opt PFLT_CONTEXT TransactionContext
    );

NTSTATUS
FLTAPI
FltCommitComplete (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in_opt PFLT_CONTEXT TransactionContext
    );

NTSTATUS
FLTAPI
FltCommitFinalizeComplete (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in_opt PFLT_CONTEXT TransactionContext
    );

NTSTATUS
FLTAPI
FltRollbackComplete (
    __in PFLT_INSTANCE Instance,
    __in PKTRANSACTION Transaction,
    __in_opt PFLT_CONTEXT TransactionContext
    );

//
//  Some Kernel routines related to ECP manipulation
//      ZwCreateTransactionManager
//      ZwCreateResourceManager
//      TmEnableCallbacks
//      IoGetTransactionParameterBlock
//      TmCreateEnlistment
//      TmPrePrepareComplete
//      TmPrepareComplete
//      TmCommitComplete
//      TmRollbackComplete
//      TmRollbackEnlistment
//

#endif // FLT_MGR_LONGHORN



///////////////////////////////////////////////////////////////////////////////
//
//  Extra Create Parameter (ECP) support routines
//
///////////////////////////////////////////////////////////////////////////////

#if FLT_MGR_LONGHORN

NTSTATUS
FLTAPI
FltAllocateExtraCreateParameterList (
    __in PFLT_FILTER Filter,
    __in FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,
    __deref_out PECP_LIST *EcpList
    );

NTSTATUS
FLTAPI
FltAllocateExtraCreateParameter (
    __in PFLT_FILTER Filter,
    __in LPCGUID EcpType,
    __in_bound ULONG SizeOfContext,
    __in FSRTL_ALLOCATE_ECP_FLAGS Flags,
    __in_opt PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    __in ULONG PoolTag,
    __deref_out PVOID *EcpContext
    );

VOID
FLTAPI
FltInitExtraCreateParameterLookasideList (
    __in PFLT_FILTER Filter,
    __inout PVOID Lookaside,
    __in FSRTL_ECP_LOOKASIDE_FLAGS Flags,
    __in SIZE_T Size,
    __in ULONG Tag
    );

VOID
FLTAPI
FltDeleteExtraCreateParameterLookasideList (
    __in PFLT_FILTER Filter,
    __inout PVOID Lookaside,
    __in FSRTL_ECP_LOOKASIDE_FLAGS Flags
    );

NTSTATUS
FLTAPI
FltAllocateExtraCreateParameterFromLookasideList (
    __in PFLT_FILTER Filter,
    __in LPCGUID EcpType,
    __in ULONG SizeOfContext,
    __in FSRTL_ALLOCATE_ECP_FLAGS Flags,
    __in_opt PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,
    __inout PVOID LookasideList,
    __deref_out PVOID *EcpContext
    );

NTSTATUS
FLTAPI
FltInsertExtraCreateParameter (
    __in PFLT_FILTER Filter,
    __inout PECP_LIST EcpList,
    __inout PVOID EcpContext
    );

NTSTATUS
FLTAPI
FltFindExtraCreateParameter (
    __in PFLT_FILTER Filter,
    __in PECP_LIST EcpList,
    __in LPCGUID EcpType,
    __deref_opt_out PVOID *EcpContext,
    __out_opt ULONG *EcpContextSize
    );

NTSTATUS
FLTAPI
FltRemoveExtraCreateParameter (
    __in PFLT_FILTER Filter,
    __inout PECP_LIST EcpList,
    __in LPCGUID EcpType,
    __deref_out PVOID *EcpContext,
    __out_opt ULONG *EcpContextSize
    );

VOID
FLTAPI
FltFreeExtraCreateParameterList (
    __in PFLT_FILTER Filter,
    __in PECP_LIST EcpList
    );

VOID
FLTAPI
FltFreeExtraCreateParameter (
    __in PFLT_FILTER Filter,
    __in PVOID EcpContext
    );

NTSTATUS
FLTAPI
FltGetEcpListFromCallbackData (
    __in PFLT_FILTER Filter,
    __in PFLT_CALLBACK_DATA CallbackData,
    __out PECP_LIST *EcpList
    );

NTSTATUS
FLTAPI
FltSetEcpListIntoCallbackData (
    __in PFLT_FILTER Filter,
    __in PFLT_CALLBACK_DATA CallbackData,
    __in PECP_LIST EcpList
    );

NTSTATUS
FLTAPI
FltGetNextExtraCreateParameter (
    __in PFLT_FILTER Filter,
    __in PECP_LIST EcpList,
    __in_opt PVOID CurrentEcpContext,
    __out_opt LPGUID NextEcpType,
    __deref_opt_out PVOID *NextEcpContext,
    __out_opt ULONG *NextEcpContextSize
    );

VOID
FLTAPI
FltAcknowledgeEcp (
    __in PFLT_FILTER Filter,
    __in PVOID EcpContext
    );

BOOLEAN
FLTAPI
FltIsEcpAcknowledged (
    __in PFLT_FILTER Filter,
    __in PVOID EcpContext
    );

BOOLEAN
FLTAPI
FltIsEcpFromUserMode (
    __in PFLT_FILTER Filter,
    __in PVOID EcpContext
    );

//
//  Some Kernel routines related to ECP manipulation
//
//      FsRtlAllocateExtraCreateParameterList
//      FsRtlFreeExtraCreateParameterList
//      FsRtlAllocateExtraCreateParameter
//      FsRtlFreeExtraCreateParameter
//      FsRtlInitExtraCreateParameterLookasideList
//      FsRtlDeleteExtraCreateParameterLookasideList
//      FsRtlAllocateExtraCreateParameterFromLookasideList
//      FsRtlInsertExtraCreateParameter
//      FsRtlRemoveExtraCreateParameter
//      FsRtlGetEcpListFromIrp
//      FsRtlSetEcpListIntoIrp
//      FsRtlGetNextExtraCreateParameter
//      FsRtlAcknowledgeEcp
//      FsRtlIsEcpAcknowledged
//      FsRtlIsEcpFromUserMode
//

#endif // FLT_MGR_LONGHORN


///////////////////////////////////////////////////////////////////////////////
//
//  IoPriorityHint support routines
//
///////////////////////////////////////////////////////////////////////////////

#if FLT_MGR_LONGHORN

//
//  Some Kernel routines related to IoPriorityHint manipulation
//
//      IoInitializePriorityInfo
//      IoSetIoPriorityHint
//      IoGetIoPriorityHint
//      ZwSetInformationFile (FileIoPriorityHintInformation class)
//      ZwQueryInformationFile (FileIoPriorityHintInformation class)
//

NTSTATUS
FLTAPI
FltRetrieveIoPriorityInfo (
    __in_opt PFLT_CALLBACK_DATA Data,
    __in_opt PFILE_OBJECT FileObject,
    __in_opt PETHREAD Thread,
    __inout PIO_PRIORITY_INFO PriorityInfo
    );

NTSTATUS
FLTAPI
FltApplyPriorityInfoThread(
    __in PIO_PRIORITY_INFO InputPriorityInfo,
    __out_opt PIO_PRIORITY_INFO OutputPriorityInfo,
    __in PETHREAD Thread
    );

#endif // FLT_MGR_LONGHORN


///////////////////////////////////////////////////////////////////////////////
//
//                      Debug support routines
//
///////////////////////////////////////////////////////////////////////////////

PCHAR
FLTAPI
FltGetIrpName (
    __in UCHAR IrpMajorCode
    );


///////////////////////////////////////////////////////////////////////////////
//
//  End of MAIN conditional compilation variables
//
///////////////////////////////////////////////////////////////////////////////

#else
#   pragma message("You are building for a target that does not have FilterManager Support!")
#endif // FLT_MGR_BASELINE

#ifdef __cplusplus
}       //  Balance extern "C" above
#endif

#endif  //__FLTKERNEL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fltUser.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    fltUser.h

Abstract:
    Header file which contains the structures, type definitions,
    constants, global variables and function prototypes that are
    visible to user mode applications that interact with filters.

Environment:

    User mode

--*/
#ifndef __FLTUSER_H__
#define __FLTUSER_H__

//
// IMPORTANT!!!!!
//
// This is how FltMgr was released (from oldest to newest)
// xpsp2, (srv03, w2ksp5), LH
//

//
//  The defines items that are part of the filter manager baseline
//

#define FLT_MGR_BASELINE (((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WIN2KSP4))) || \
                          ((OSVER(NTDDI_VERSION) == NTDDI_WINXP) && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WINXPSP2))) || \
                          ((OSVER(NTDDI_VERSION) == NTDDI_WS03)  && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WS03SP1))) || \
                          (NTDDI_VERSION >= NTDDI_VISTA))

//
//  This defines items that were added after XPSP2 was released.  This means
//  they are in Srv03 SP1, W2K SP5, and Longhorn
//

#define FLT_MGR_AFTER_XPSP2 (((OSVER(NTDDI_VERSION) == NTDDI_WIN2K) && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WIN2KSP4))) || \
                             ((OSVER(NTDDI_VERSION) == NTDDI_WINXP) && (SPVER(NTDDI_VERSION) >  SPVER(NTDDI_WINXPSP2))) || \
                             ((OSVER(NTDDI_VERSION) == NTDDI_WS03)  && (SPVER(NTDDI_VERSION) >= SPVER(NTDDI_WS03SP1))) || \
                             (NTDDI_VERSION >= NTDDI_VISTA))

//
//  This defines items that only exist in longhorn or later
//

#define FLT_MGR_LONGHORN (NTDDI_VERSION >= NTDDI_VISTA)



///////////////////////////////////////////////////////////////////////////////
//
//  Standard includes
//
///////////////////////////////////////////////////////////////////////////////

#include <fltUserStructures.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// These are all of the baseline set of user-mode functions in FltMgr.
//

#if FLT_MGR_BASELINE

//
//  Functions for loading, unloading and monitoring Filters
//

HRESULT
WINAPI
FilterLoad (
    __in LPCWSTR lpFilterName
    );

HRESULT
WINAPI
FilterUnload (
    __in LPCWSTR lpFilterName
    );


//****************************************************************************
//
//  Functions for creating and closing handles
//
//****************************************************************************

//
//  Filter
//

HRESULT
WINAPI
FilterCreate (
    __in LPCWSTR lpFilterName,
    __deref_out HFILTER *hFilter
    );

HRESULT
WINAPI
FilterClose(
    __in HFILTER hFilter
    );

//
//  FilterInstance
//

HRESULT
WINAPI
FilterInstanceCreate (
    __in LPCWSTR lpFilterName,
    __in LPCWSTR lpVolumeName,
    __in_opt LPCWSTR lpInstanceName,
   __deref_out HFILTER_INSTANCE *hInstance
    );

HRESULT
WINAPI
FilterInstanceClose(
    __in HFILTER_INSTANCE hInstance
    );


//****************************************************************************
//
//  Functions for creating and deleting FilterInstances in the
//  device stack.
//
//****************************************************************************

HRESULT
WINAPI
FilterAttach (
    __in LPCWSTR lpFilterName,
    __in LPCWSTR lpVolumeName,
    __in_opt LPCWSTR lpInstanceName ,
    __in_opt DWORD dwCreatedInstanceNameLength ,
    __out_bcount_opt(dwCreatedInstanceNameLength) LPWSTR lpCreatedInstanceName
    );

HRESULT
WINAPI
FilterAttachAtAltitude (
    __in LPCWSTR lpFilterName,
    __in LPCWSTR lpVolumeName,
    __in LPCWSTR lpAltitude,
    __in_opt LPCWSTR lpInstanceName ,
    __in_opt DWORD dwCreatedInstanceNameLength ,
    __out_bcount_opt(dwCreatedInstanceNameLength) LPWSTR lpCreatedInstanceName
    );

HRESULT
WINAPI
FilterDetach (
    __in LPCWSTR lpFilterName,
    __in LPCWSTR lpVolumeName,
    __in_opt LPCWSTR lpInstanceName
    );


//****************************************************************************
//
//  Functions for iterating through Filters and FilterInstances and
//  getting information on a Filter or FilterInstance.
//
//****************************************************************************

//
//  Functions for iterating through Filters
//

HRESULT
WINAPI
FilterFindFirst (
    __in FILTER_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned,
    __out LPHANDLE lpFilterFind
    );

HRESULT
WINAPI
FilterFindNext (
    __in HANDLE hFilterFind,
    __in FILTER_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned
    );

HRESULT
WINAPI
FilterFindClose(
    __in HANDLE hFilterFind
    );


HRESULT
WINAPI
FilterVolumeFindFirst (
    __in FILTER_VOLUME_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned,
    __out PHANDLE lpVolumeFind
    );

HRESULT
WINAPI
FilterVolumeFindNext (
    __in HANDLE hVolumeFind,
    __in FILTER_VOLUME_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned
    );

HRESULT
WINAPI
FilterVolumeFindClose(
    __in HANDLE hVolumeFind
    );

//
//  Functions for iterating through FilterInstances
//

HRESULT
WINAPI
FilterInstanceFindFirst (
    __in LPCWSTR lpFilterName,
    __in INSTANCE_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned,
    __out LPHANDLE lpFilterInstanceFind
    );

HRESULT
WINAPI
FilterInstanceFindNext (
    __in HANDLE hFilterInstanceFind,
    __in INSTANCE_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned
    );

HRESULT
WINAPI
FilterInstanceFindClose(
    __in HANDLE hFilterInstanceFind
    );


//
//  Functions for iterating through VolumeInstances
//

HRESULT
WINAPI
FilterVolumeInstanceFindFirst (
    __in LPCWSTR lpVolumeName,
    __in INSTANCE_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned,
    __out LPHANDLE lpVolumeInstanceFind
    );

HRESULT
WINAPI
FilterVolumeInstanceFindNext (
    __in HANDLE hVolumeInstanceFind,
    __in INSTANCE_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned
    );

HRESULT
WINAPI
FilterVolumeInstanceFindClose(
    __in HANDLE hVolumeInstanceFind
    );


//
//  Functions for getting information on Filters and FilterInstances
//

HRESULT
WINAPI
FilterGetInformation (
    __in HFILTER hFilter,
    __in FILTER_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned
    );

HRESULT
WINAPI
FilterInstanceGetInformation (
    __in HFILTER_INSTANCE hInstance,
    __in INSTANCE_INFORMATION_CLASS dwInformationClass,
    __out_bcount_part(dwBufferSize,*lpBytesReturned) LPVOID lpBuffer,
    __in DWORD dwBufferSize,
    __out LPDWORD lpBytesReturned
    );


//****************************************************************************
//
//  Functions for communicating with Filters and FilterInstances
//
//****************************************************************************

HRESULT
WINAPI
FilterConnectCommunicationPort(
    __in LPCWSTR lpPortName,
    __in DWORD dwOptions,
    __in_bcount_opt(wSizeOfContext) LPCVOID lpContext,
    __in WORD wSizeOfContext,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes ,
    __deref_out HANDLE *hPort
    );

HRESULT
WINAPI
FilterSendMessage (
    __in HANDLE hPort,
    __in_bcount_opt(dwInBufferSize) LPVOID lpInBuffer,
    __in DWORD dwInBufferSize,
    __out_bcount_part_opt(dwOutBufferSize,*lpBytesReturned) LPVOID lpOutBuffer,
    __in DWORD dwOutBufferSize,
    __out LPDWORD lpBytesReturned
    );

HRESULT
WINAPI
FilterGetMessage (
    __in HANDLE hPort,
    __out_bcount(dwMessageBufferSize) PFILTER_MESSAGE_HEADER lpMessageBuffer,
    __in DWORD dwMessageBufferSize,
    __inout LPOVERLAPPED lpOverlapped
    );

HRESULT
WINAPI
FilterReplyMessage (
    __in HANDLE hPort,
    __in_bcount(dwReplyBufferSize) PFILTER_REPLY_HEADER lpReplyBuffer,
    __in DWORD dwReplyBufferSize
    );

//****************************************************************************
//
//  Other support functions
//
//****************************************************************************

HRESULT
WINAPI
FilterGetDosName (
    __in LPCWSTR lpVolumeName,
    __out_ecount(dwDosNameBufferSize) LPWSTR lpDosName,
    __in DWORD dwDosNameBufferSize
    );

#endif // end the FLT_MGR_BASELINE

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif /* __FLTUSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fltUserStructures.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    fltUserStructures.h

Abstract:

    This contains structures, types, and defintiions that are common to both
    USER mode and KERNEL mode environments.

Environment:

    User mode

--*/
#ifndef __FLT_USER_STRUCTURES_H__
#define __FLT_USER_STRUCTURES_H__

#if FLT_MGR_BASELINE

//
//  Disable warning for this file
//

#define FLTAPI NTAPI

#define FILTER_NAME_MAX_CHARS     255
#define FILTER_NAME_MAX_BYTES     (FILTER_NAME_MAX_CHARS * sizeof( WCHAR ))

#define VOLUME_NAME_MAX_CHARS     1024
#define VOLUME_NAME_MAX_BYTES     (VOLUME_NAME_MAX_CHARS * sizeof( WCHAR ))

#define INSTANCE_NAME_MAX_CHARS   255
#define INSTANCE_NAME_MAX_BYTES   (INSTANCE_NAME_MAX_CHARS * sizeof( WCHAR ))

typedef HANDLE  HFILTER;
typedef HANDLE  HFILTER_INSTANCE;
typedef HANDLE  HFILTER_VOLUME;


//
//  Note: this may be removed in future when all translations from NTSTATUS to
//  Win32 error codes are checked in. This is interim - since there the
//  translation is not in for all filter manager error codes,
//  apps will have to access NTSTATUS codes directly
//

typedef LONG NTSTATUS, *PNTSTATUS;

///////////////////////////////////////////////////////////////////////////////
//
//                      Known File System Types
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _FLT_FILESYSTEM_TYPE {

    FLT_FSTYPE_UNKNOWN,         //an UNKNOWN file system type
    FLT_FSTYPE_RAW,             //Microsoft's RAW file system       (\FileSystem\RAW)
    FLT_FSTYPE_NTFS,            //Microsoft's NTFS file system      (\FileSystem\Ntfs)
    FLT_FSTYPE_FAT,             //Microsoft's FAT file system       (\FileSystem\Fastfat)
    FLT_FSTYPE_CDFS,            //Microsoft's CDFS file system      (\FileSystem\Cdfs)
    FLT_FSTYPE_UDFS,            //Microsoft's UDFS file system      (\FileSystem\Udfs)
    FLT_FSTYPE_LANMAN,          //Microsoft's LanMan Redirector     (\FileSystem\MRxSmb)
    FLT_FSTYPE_WEBDAV,          //Microsoft's WebDav redirector     (\FileSystem\MRxDav)
    FLT_FSTYPE_RDPDR,           //Microsoft's Terminal Server redirector    (\Driver\rdpdr)
    FLT_FSTYPE_NFS,             //Microsoft's NFS file system       (\FileSystem\NfsRdr)
    FLT_FSTYPE_MS_NETWARE,      //Microsoft's NetWare redirector    (\FileSystem\nwrdr)
    FLT_FSTYPE_NETWARE,         //Novell's NetWare redirector
    FLT_FSTYPE_BSUDF,           //The BsUDF CD-ROM driver           (\FileSystem\BsUDF)
    FLT_FSTYPE_MUP,             //Microsoft's Mup redirector        (\FileSystem\Mup)
    FLT_FSTYPE_RSFX,            //Microsoft's WinFS redirector      (\FileSystem\RsFxDrv)
    FLT_FSTYPE_ROXIO_UDF1,      //Roxio's UDF writeable file system (\FileSystem\cdudf_xp)
    FLT_FSTYPE_ROXIO_UDF2,      //Roxio's UDF readable file system  (\FileSystem\UdfReadr_xp)
    FLT_FSTYPE_ROXIO_UDF3,      //Roxio's DVD file system           (\FileSystem\DVDVRRdr_xp)
    FLT_FSTYPE_TACIT,           //Tacit FileSystem                  (\Device\TCFSPSE)
    FLT_FSTYPE_FS_REC,          //Microsoft's File system recognizer (\FileSystem\Fs_rec)
    FLT_FSTYPE_INCD,            //Nero's InCD file system           (\FileSystem\InCDfs)
    FLT_FSTYPE_INCD_FAT,        //Nero's InCD FAT file system       (\FileSystem\InCDFat)
    FLT_FSTYPE_EXFAT,           //Microsoft's EXFat FILE SYSTEM     (\FileSystem\exfat)
    FLT_FSTYPE_PSFS             //PolyServ's file system            (\FileSystem\psfs)

} FLT_FILESYSTEM_TYPE, *PFLT_FILESYSTEM_TYPE;


/////////////////////////////////////////////////////////////////////////////
//
//  The different types information that can be return on an Filter.
//
//  Note: Entries with "Aggregate" in the name return information for
//        both LEGACY and MINI filters.
//
/////////////////////////////////////////////////////////////////////////////


//
// In xpsp2 we do not have the concept of enumerating legacy filters
// For this reason there is no FilterAggregateBasicInfo in the V1 version
// of the enum
//

typedef enum _FILTER_INFORMATION_CLASS {

    FilterFullInformation,
    FilterAggregateBasicInformation,        //Added to XP SP2 via QFE
    FilterAggregateStandardInformation      //Longhorn and later

} FILTER_INFORMATION_CLASS, *PFILTER_INFORMATION_CLASS;

//
//  The structures for the information returned from the query of
//  information on a Filter.
//

typedef struct _FILTER_FULL_INFORMATION {

    ULONG NextEntryOffset;

    ULONG FrameID;

    ULONG NumberOfInstances;

    USHORT FilterNameLength;
    WCHAR FilterNameBuffer[1];

} FILTER_FULL_INFORMATION, *PFILTER_FULL_INFORMATION;


//
//  This structure returns information for both legacy filters and mini
//  filters.
//
//  NOTE: Support for this structures exists in all OS's that support
//        filter manager except XP SP2.  It was added later to XP SP2
//        via a QFE.
//

typedef struct _FILTER_AGGREGATE_BASIC_INFORMATION {

    ULONG NextEntryOffset;

    //
    //  ABI - Aggregate Basic Information flags
    //

    ULONG Flags;
        #define FLTFL_AGGREGATE_INFO_IS_MINIFILTER      0x00000001
        #define FLTFL_AGGREGATE_INFO_IS_LEGACYFILTER    0x00000002

    union {

        //
        //  Minifilter FULL information
        //

        struct {

            ULONG FrameID;

            ULONG NumberOfInstances;

            USHORT FilterNameLength;
            USHORT FilterNameBufferOffset;

            USHORT FilterAltitudeLength;
            USHORT FilterAltitudeBufferOffset;

        } MiniFilter;

        //
        //  Legacyfilter information
        //

        struct {

            USHORT FilterNameLength;
            USHORT FilterNameBufferOffset;

        } LegacyFilter;

    } Type;

} FILTER_AGGREGATE_BASIC_INFORMATION, *PFILTER_AGGREGATE_BASIC_INFORMATION;


//
//  This structure returns information for both legacy filters and mini
//  filters.
//
//  NOTE: Support for this structures exists in Vista and Later
//

#if FLT_MGR_LONGHORN
typedef struct _FILTER_AGGREGATE_STANDARD_INFORMATION {

    ULONG NextEntryOffset;

    //
    //  ASI - Aggregate Standard Information flags
    //

    ULONG Flags;
        #define FLTFL_ASI_IS_MINIFILTER      0x00000001
        #define FLTFL_ASI_IS_LEGACYFILTER    0x00000002

    union {

        //
        //  Minifilter FULL information
        //

        struct {

            //
            //  ASIM - Aggregate Standard Information Minifilter flags
            //

            ULONG Flags;


            ULONG FrameID;

            ULONG NumberOfInstances;

            USHORT FilterNameLength;
            USHORT FilterNameBufferOffset;

            USHORT FilterAltitudeLength;
            USHORT FilterAltitudeBufferOffset;

        } MiniFilter;

        //
        //  Legacyfilter information
        //

        struct {

            //
            //  ASIL - Aggregate Standard Information LegacyFilter flags
            //

            ULONG Flags;


            USHORT FilterNameLength;
            USHORT FilterNameBufferOffset;

            USHORT FilterAltitudeLength;
            USHORT FilterAltitudeBufferOffset;

        } LegacyFilter;

    } Type;

} FILTER_AGGREGATE_STANDARD_INFORMATION, *PFILTER_AGGREGATE_STANDARD_INFORMATION;
#endif // FLT_MGR_LONGHORN


/////////////////////////////////////////////////////////////////////////////
//
//  The different types information that can be return for a Volume
//
/////////////////////////////////////////////////////////////////////////////

typedef enum _FILTER_VOLUME_INFORMATION_CLASS {

    FilterVolumeBasicInformation,
    FilterVolumeStandardInformation     //Longhorn and later

} FILTER_VOLUME_INFORMATION_CLASS, *PFILTER_VOLUME_INFORMATION_CLASS;


//
//  Basic information about a volume (its name)
//

typedef struct _FILTER_VOLUME_BASIC_INFORMATION {

   //
   //  Length of name
   //

   USHORT FilterVolumeNameLength;

   //
   //  Buffer containing name (it's NOT NULL-terminated)
   //

   WCHAR FilterVolumeName[1];

} FILTER_VOLUME_BASIC_INFORMATION, *PFILTER_VOLUME_BASIC_INFORMATION;

//
//  Additional volume information.
//
//  NOTE: Only available in LONGHORN and later OS's
//

#if FLT_MGR_LONGHORN
typedef struct _FILTER_VOLUME_STANDARD_INFORMATION {

    ULONG NextEntryOffset;

    //
    //  VSI - VOlume Standard Information flags
    //

    ULONG Flags;

        //
        //  If set this volume is not current attached to a storage stack
        //

        #define FLTFL_VSI_DETACHED_VOLUME 0x00000001

    //
    //  Identifies which frame this volume structure is in
    //

    ULONG FrameID;

    //
    //  Identifies the type of file system being used on the volume
    //

    FLT_FILESYSTEM_TYPE FileSystemType;

    //
    //  Length of name
    //

    USHORT FilterVolumeNameLength;

    //
    //  Buffer containing name (it's NOT NULL-terminated)
    //

    WCHAR FilterVolumeName[1];

} FILTER_VOLUME_STANDARD_INFORMATION, *PFILTER_VOLUME_STANDARD_INFORMATION;
#endif // FLT_MGR_LONGHORN



/////////////////////////////////////////////////////////////////////////////
//
//  The different types information that can be return on an Instance.
//
/////////////////////////////////////////////////////////////////////////////

typedef enum _INSTANCE_INFORMATION_CLASS {

    InstanceBasicInformation,
    InstancePartialInformation,
    InstanceFullInformation,
    InstanceAggregateStandardInformation    //LONGHORN and later

} INSTANCE_INFORMATION_CLASS, *PINSTANCE_INFORMATION_CLASS;


//
//  The structures for the information returned from the query of the information
//  on the Instance.
//

typedef __struct_bcount(sizeof(INSTANCE_BASIC_INFORMATION) * InstanceNameLength) struct _INSTANCE_BASIC_INFORMATION {

    ULONG NextEntryOffset;

    USHORT InstanceNameLength;
    USHORT InstanceNameBufferOffset;

} INSTANCE_BASIC_INFORMATION, *PINSTANCE_BASIC_INFORMATION;

typedef __struct_bcount(sizeof(INSTANCE_PARTIAL_INFORMATION) + InstanceNameLength + AltitudeLength) struct _INSTANCE_PARTIAL_INFORMATION {

    ULONG NextEntryOffset;

    USHORT InstanceNameLength;
    USHORT InstanceNameBufferOffset;

    USHORT AltitudeLength;
    USHORT AltitudeBufferOffset;

} INSTANCE_PARTIAL_INFORMATION, *PINSTANCE_PARTIAL_INFORMATION;

typedef __struct_bcount(sizeof(INSTANCE_FULL_INFORMATION) + InstanceNameLength + AltitudeLength + VolumeNameLength + FilterNameLength) struct _INSTANCE_FULL_INFORMATION {

    ULONG NextEntryOffset;

    USHORT InstanceNameLength;
    USHORT InstanceNameBufferOffset;

    USHORT AltitudeLength;
    USHORT AltitudeBufferOffset;

    USHORT VolumeNameLength;
    USHORT VolumeNameBufferOffset;

    USHORT FilterNameLength;
    USHORT FilterNameBufferOffset;

} INSTANCE_FULL_INFORMATION, *PINSTANCE_FULL_INFORMATION;


//
//  This information class is used to return instance information about both
//  legacy filters and minifilters.
//

#if FLT_MGR_LONGHORN
typedef struct _INSTANCE_AGGREGATE_STANDARD_INFORMATION {

    ULONG NextEntryOffset;

    //
    //  IASI - Instance Aggregate Standard Information flags
    //

    ULONG Flags;
        #define FLTFL_IASI_IS_MINIFILTER      0x00000001
        #define FLTFL_IASI_IS_LEGACYFILTER    0x00000002

    union {

        //
        //  MiniFilter information
        //

        struct {

            //
            //  IASIM - Instance Aggregate Standard Information Minifilter flags
            //

            ULONG Flags;

                //
                //  If set this volume is not current attached to a storage stack
                //

                #define FLTFL_IASIM_DETACHED_VOLUME 0x00000001

            //
            //  Identifies which frame this volume structure is in
            //

            ULONG FrameID;

            //
            //  The type of file system this instance is attached to
            //

            FLT_FILESYSTEM_TYPE VolumeFileSystemType;

            //
            //  The name of this instance
            //

            USHORT InstanceNameLength;
            USHORT InstanceNameBufferOffset;

            //
            //  The altitude of this instance
            //

            USHORT AltitudeLength;
            USHORT AltitudeBufferOffset;

            //
            //  The volume name this instance is attached to
            //

            USHORT VolumeNameLength;
            USHORT VolumeNameBufferOffset;

            //
            //  The name of the minifilter associated with this instace
            //

            USHORT FilterNameLength;
            USHORT FilterNameBufferOffset;

        } MiniFilter;

        //
        //  Legacyfilter information
        //

        struct {

            //
            //  IASIL - Instance Aggregate Standard Information LegacyFilter flags
            //

            ULONG Flags;

                //
                //  If set this volume is not current attached to a storage stack
                //

                #define FLTFL_IASIL_DETACHED_VOLUME 0x00000001

            //
            //  The altitude of this attachment
            //

            USHORT AltitudeLength;
            USHORT AltitudeBufferOffset;

            //
            //  The volume name this filter is attached to
            //

            USHORT VolumeNameLength;
            USHORT VolumeNameBufferOffset;

            //
            //  The name of the filter associated with this attachment
            //

            USHORT FilterNameLength;
            USHORT FilterNameBufferOffset;

        } LegacyFilter;

    } Type;

} INSTANCE_AGGREGATE_STANDARD_INFORMATION, *PINSTANCE_AGGREGATE_STANDARD_INFORMATION;
#endif // FLT_MGR_LONGHORN


/////////////////////////////////////////////////////////////////////////////
//
//  Message defintitions
//
/////////////////////////////////////////////////////////////////////////////

typedef struct _FILTER_MESSAGE_HEADER {

    //
    //  OUT
    //
    //  Total buffer length in bytes, including the FILTER_REPLY_HEADER, of
    //  the expected reply.  If no reply is expected, 0 is returned.
    //

    ULONG ReplyLength;

    //
    //  OUT
    //
    //  Unique Id for this message.  This will be set when the kernel message
    //  satifies this FilterGetMessage or FilterInstanceGetMessage request.
    //  If replying to this message, this is the MessageId that should be used.
    //

    ULONGLONG MessageId;

    //
    //  General filter-specific buffer data follows...
    //

} FILTER_MESSAGE_HEADER, *PFILTER_MESSAGE_HEADER;

typedef struct _FILTER_REPLY_HEADER {

    //
    //  IN.
    //
    //  Status of this reply. This status will be returned back to the filter
    //  driver who is waiting for a reply.
    //

    NTSTATUS Status;

    //
    //  IN
    //
    //  Unique Id for this message.  This id was returned in the
    //  FILTER_MESSAGE_HEADER from the kernel message to which we are replying.
    //

    ULONGLONG MessageId;

    //
    //  General filter-specific buffer data follows...
    //

} FILTER_REPLY_HEADER, *PFILTER_REPLY_HEADER;

#endif //FLT_MGR_BASELINE

#endif /* __FLT_USER_STRUCTURES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hbapiwmi.h ===
#ifndef _hbapiwmi_h_
#define _hbapiwmi_h_

// MSFC_HBAPortStatistics - MSFC_HBAPortStatistics


//***************************************************************************
//
//  hbapiwmi.h
// 
//  Module: WDM classes to expose HBA api data from drivers
//
//  Purpose: Contains WDM classes that specify the HBA data to be exposed 
//           via the HBA api set.
//
//  NOTE: This file contains information that is based upon:
//        SM-HBA Version 1.0 and FC-HBA 2.18 specification.
//
//        Please specify which WMI interfaces the provider will implement by
//        defining MS_SM_HBA_API or MSFC_HBA_API before including this file.
//        That is:
//
//        #define MS_SM_HBA_API
//        #include <hbapiwmi.h>
//
//        - or -
//
//        #define MSFC_HBA_API
//        #include <hbapiwmi.h>
//
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************


#define MSFC_HBAPortStatisticsGuid \
    { 0x3ce7904f,0x459f,0x480d, { 0x9a,0x3c,0x01,0x3e,0xde,0x3b,0xdd,0xe8 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAPortStatistics_GUID, \
            0x3ce7904f,0x459f,0x480d,0x9a,0x3c,0x01,0x3e,0xde,0x3b,0xdd,0xe8);
#endif


typedef struct _MSFC_HBAPortStatistics
{
    // 
    LONGLONG SecondsSinceLastReset;
    #define MSFC_HBAPortStatistics_SecondsSinceLastReset_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_SecondsSinceLastReset_ID 1

    // 
    LONGLONG TxFrames;
    #define MSFC_HBAPortStatistics_TxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_TxFrames_ID 2

    // 
    LONGLONG TxWords;
    #define MSFC_HBAPortStatistics_TxWords_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_TxWords_ID 3

    // 
    LONGLONG RxFrames;
    #define MSFC_HBAPortStatistics_RxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_RxFrames_ID 4

    // 
    LONGLONG RxWords;
    #define MSFC_HBAPortStatistics_RxWords_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_RxWords_ID 5

    // 
    LONGLONG LIPCount;
    #define MSFC_HBAPortStatistics_LIPCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LIPCount_ID 6

    // 
    LONGLONG NOSCount;
    #define MSFC_HBAPortStatistics_NOSCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_NOSCount_ID 7

    // 
    LONGLONG ErrorFrames;
    #define MSFC_HBAPortStatistics_ErrorFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_ErrorFrames_ID 8

    // 
    LONGLONG DumpedFrames;
    #define MSFC_HBAPortStatistics_DumpedFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_DumpedFrames_ID 9

    // 
    LONGLONG LinkFailureCount;
    #define MSFC_HBAPortStatistics_LinkFailureCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LinkFailureCount_ID 10

    // 
    LONGLONG LossOfSyncCount;
    #define MSFC_HBAPortStatistics_LossOfSyncCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LossOfSyncCount_ID 11

    // 
    LONGLONG LossOfSignalCount;
    #define MSFC_HBAPortStatistics_LossOfSignalCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LossOfSignalCount_ID 12

    // 
    LONGLONG PrimitiveSeqProtocolErrCount;
    #define MSFC_HBAPortStatistics_PrimitiveSeqProtocolErrCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_PrimitiveSeqProtocolErrCount_ID 13

    // 
    LONGLONG InvalidTxWordCount;
    #define MSFC_HBAPortStatistics_InvalidTxWordCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_InvalidTxWordCount_ID 14

    // 
    LONGLONG InvalidCRCCount;
    #define MSFC_HBAPortStatistics_InvalidCRCCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_InvalidCRCCount_ID 15

} MSFC_HBAPortStatistics, *PMSFC_HBAPortStatistics;

#define MSFC_HBAPortStatistics_SIZE (FIELD_OFFSET(MSFC_HBAPortStatistics, InvalidCRCCount) + MSFC_HBAPortStatistics_InvalidCRCCount_SIZE)

// HBAFC3MgmtInfo - HBAFC3MgmtInfo
// This class exposes FC3 Management information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define HBAFC3MgmtInfoGuid \
    { 0x5966a24f,0x6aa5,0x418e, { 0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFC3MgmtInfo_GUID, \
            0x5966a24f,0x6aa5,0x418e,0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18);
#endif


typedef struct _HBAFC3MgmtInfo
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define HBAFC3MgmtInfo_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define HBAFC3MgmtInfo_UniqueAdapterId_ID 1

    // 
    UCHAR wwn[8];
    #define HBAFC3MgmtInfo_wwn_SIZE sizeof(UCHAR[8])
    #define HBAFC3MgmtInfo_wwn_ID 2

    // 
    ULONG unittype;
    #define HBAFC3MgmtInfo_unittype_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_unittype_ID 3

    // 
    ULONG PortId;
    #define HBAFC3MgmtInfo_PortId_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_PortId_ID 4

    // 
    ULONG NumberOfAttachedNodes;
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_ID 5

    // 
    USHORT IPVersion;
    #define HBAFC3MgmtInfo_IPVersion_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_IPVersion_ID 6

    // 
    USHORT UDPPort;
    #define HBAFC3MgmtInfo_UDPPort_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_UDPPort_ID 7

    // 
    UCHAR IPAddress[16];
    #define HBAFC3MgmtInfo_IPAddress_SIZE sizeof(UCHAR[16])
    #define HBAFC3MgmtInfo_IPAddress_ID 8

    // 
    USHORT reserved;
    #define HBAFC3MgmtInfo_reserved_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_reserved_ID 9

    // 
    USHORT TopologyDiscoveryFlags;
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_ID 10

    // 
    ULONG reserved1;
    #define HBAFC3MgmtInfo_reserved1_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_reserved1_ID 11

} HBAFC3MgmtInfo, *PHBAFC3MgmtInfo;

#define HBAFC3MgmtInfo_SIZE (FIELD_OFFSET(HBAFC3MgmtInfo, reserved1) + HBAFC3MgmtInfo_reserved1_SIZE)

// HBAScsiID - HBAScsiID
#define HBAScsiIDGuid \
    { 0xa76f5058,0xb1f0,0x4622, { 0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAScsiID_GUID, \
            0xa76f5058,0xb1f0,0x4622,0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a);
#endif


typedef struct _HBAScsiID
{
    // 
    ULONG ScsiBusNumber;
    #define HBAScsiID_ScsiBusNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiBusNumber_ID 1

    // 
    ULONG ScsiTargetNumber;
    #define HBAScsiID_ScsiTargetNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiTargetNumber_ID 2

    // 
    ULONG ScsiOSLun;
    #define HBAScsiID_ScsiOSLun_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiOSLun_ID 3



   //******************************************************************
   //
   //  This used to be a string type, but we made this a fixed length
   //  array so the WmiSizeIs() will work correctly for structs that 
   //  contain this type.
   //  Please note that this should still be treated as a string.
   //  The first uint16 must hold the length of string (in bytes).
   //
   //******************************************************************


    // 
    USHORT OSDeviceName[257];
    #define HBAScsiID_OSDeviceName_SIZE sizeof(USHORT[257])
    #define HBAScsiID_OSDeviceName_ID 4

} HBAScsiID, *PHBAScsiID;

#define HBAScsiID_SIZE (FIELD_OFFSET(HBAScsiID, OSDeviceName) + HBAScsiID_OSDeviceName_SIZE)

// MSFC_LinkEvent - MSFC_LinkEvent
// This class surfaces HBA link events




//
// Event types.
//
// These match the definitions in hbaapi.h and must be kept in sync.
//
   /* Adapter Level Events */
#define HBA_EVENT_ADAPTER_UNKNOWN       0x100
#define HBA_EVENT_ADAPTER_ADD           0x101
#define HBA_EVENT_ADAPTER_REMOVE        0x102
#define HBA_EVENT_ADAPTER_CHANGE        0x103

   /* Port Level Events */
#define HBA_EVENT_PORT_UNKNOWN          0x200
#define HBA_EVENT_PORT_OFFLINE          0x201
#define HBA_EVENT_PORT_ONLINE           0x202
#define HBA_EVENT_PORT_NEW_TARGETS      0x203
#define HBA_EVENT_PORT_FABRIC           0x204
#define HBA_EVENT_PORT_BROADCAST_CHANGE 0x205
#define HBA_EVENT_PORT_BROADCAST_D24_0  0x206
#define HBA_EVENT_PORT_BROADCAST_D27_4  0x207
#define HBA_EVENT_PORT_BROADCAST_SES    0x208
#define HBA_EVENT_PORT_BROADCAST_D01_4  0x209
#define HBA_EVENT_PORT_BROADCAST_D04_7  0x20a
#define HBA_EVENT_PORT_BROADCAST_D16_7  0x20b
#define HBA_EVENT_PORT_BROADCAST_D29_7  0x20c
#define HBA_EVENT_PORT_ALL              0x2ff
   
   /* Port Statistics Events */
#define HBA_EVENT_PORT_STAT_THRESHOLD   0x301
#define HBA_EVENT_PORT_STAT_GROWTH      0x302

/* Phy Statistics Events */
#define HBA_EVENT_PHY_STAT_THRESHOLD    0x351
#define HBA_EVENT_PHY_STAT_GROWTH       0x352

   /* Target Level Events */
#define HBA_EVENT_TARGET_UNKNOWN        0x400
#define HBA_EVENT_TARGET_OFFLINE        0x401
#define HBA_EVENT_TARGET_ONLINE         0x402
#define HBA_EVENT_TARGET_REMOVED        0x403

   /* Fabric Link  Events */
#define HBA_EVENT_LINK_UNKNOWN          0x500
#define HBA_EVENT_LINK_INCIDENT         0x501

#define MSFC_LinkEventGuid \
    { 0xc66015ee,0x014b,0x498a, { 0x94,0x51,0x99,0xfe,0xad,0x0a,0xb4,0x51 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_LinkEvent_GUID, \
            0xc66015ee,0x014b,0x498a,0x94,0x51,0x99,0xfe,0xad,0x0a,0xb4,0x51);
#endif


typedef struct _MSFC_LinkEvent
{
    // Type of event
    ULONG EventType;
    #define MSFC_LinkEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_LinkEvent_EventType_ID 1

    // Discovered Port WWN
    UCHAR AdapterWWN[8];
    #define MSFC_LinkEvent_AdapterWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_LinkEvent_AdapterWWN_ID 2

    // Size of RLIR buffer
    ULONG RLIRBufferSize;
    #define MSFC_LinkEvent_RLIRBufferSize_SIZE sizeof(ULONG)
    #define MSFC_LinkEvent_RLIRBufferSize_ID 3

    // Size of RLIR buffer
    UCHAR RLIRBuffer[1];
    #define MSFC_LinkEvent_RLIRBuffer_ID 4

} MSFC_LinkEvent, *PMSFC_LinkEvent;

// MSFC_FCAdapterHBAAttributes - MSFC_FCAdapterHBAAttributes
// This class exposes attribute information associated with a fibre channel adapter. There should be one instance of this class for each adapter


#ifndef MS_SM_HBA_API
#ifndef MSFC_HBA_API
//
// if neither defined then default to MSFC
//
#define MSFC_HBA_API
#endif
#endif


#ifdef MSFC_HBA_API

#define MSFC_FCAdapterHBAAttributesGuid \
    { 0xf8f3ea26,0xab2c,0x4593, { 0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FCAdapterHBAAttributes_GUID, \
            0xf8f3ea26,0xab2c,0x4593,0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb);
#endif


typedef struct _MSFC_FCAdapterHBAAttributes
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_ID 2

    // 
    UCHAR NodeWWN[8];
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_ID 3

    // 
    ULONG VendorSpecificID;
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_ID 4

    // 
    ULONG NumberOfPorts;
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_ID 5



   //******************************************************************
   //
   //  The string type is variable length (up to MaxLen).              
   //  Each string starts with a ushort that holds the strings length  
   //  (in bytes) followed by the WCHARs that make up the string.      
   //
   //  This struct is packed so the offset for SerialNumber must be    
   //  computed from the offset of Manufacturer.                       
   //   i.e. SerialNumber = Manufacturer+sizeof(USHORT)+Manufacturer[0]
   //
   //  similarly Model's offset must be computed from SerialNumber etc.
   //
   //******************************************************************


    // 
    WCHAR Manufacturer[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_Manufacturer_ID 6

    // 
    WCHAR SerialNumber[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_SerialNumber_ID 7

    // 
    WCHAR Model[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_Model_ID 8

    // 
    WCHAR ModelDescription[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_ModelDescription_ID 9

    // 
    WCHAR NodeSymbolicName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_NodeSymbolicName_ID 10

    // 
    WCHAR HardwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_HardwareVersion_ID 11

    // 
    WCHAR DriverVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverVersion_ID 12

    // 
    WCHAR OptionROMVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_OptionROMVersion_ID 13

    // 
    WCHAR FirmwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_FirmwareVersion_ID 14

    // 
    WCHAR DriverName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverName_ID 15

    // 
    WCHAR MfgDomain[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_MfgDomain_ID 16

} MSFC_FCAdapterHBAAttributes, *PMSFC_FCAdapterHBAAttributes;

// MSFC_HBAPortAttributesResults - MSFC_HBAPortAttributesResults
#define MSFC_HBAPortAttributesResultsGuid \
    { 0xa76bd4e3,0x9961,0x4d9b, { 0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAPortAttributesResults_GUID, \
            0xa76bd4e3,0x9961,0x4d9b,0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68);
#endif


typedef struct _MSFC_HBAPortAttributesResults
{
    // 
    UCHAR NodeWWN[8];
    #define MSFC_HBAPortAttributesResults_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_NodeWWN_ID 1

    // 
    UCHAR PortWWN[8];
    #define MSFC_HBAPortAttributesResults_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_PortWWN_ID 2

    // 
    ULONG PortFcId;
    #define MSFC_HBAPortAttributesResults_PortFcId_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortFcId_ID 3

    // 
    ULONG PortType;
    #define MSFC_HBAPortAttributesResults_PortType_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortType_ID 4

    // 
    ULONG PortState;
    #define MSFC_HBAPortAttributesResults_PortState_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortState_ID 5

    // 
    ULONG PortSupportedClassofService;
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_ID 6

    // 
    UCHAR PortSupportedFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_ID 7

    // 
    UCHAR PortActiveFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_ID 8

    // 
    ULONG PortSupportedSpeed;
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_ID 9

    // 
    ULONG PortSpeed;
    #define MSFC_HBAPortAttributesResults_PortSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSpeed_ID 10

    // 
    ULONG PortMaxFrameSize;
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_ID 11

    // 
    UCHAR FabricName[8];
    #define MSFC_HBAPortAttributesResults_FabricName_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_FabricName_ID 12

    // 
    ULONG NumberofDiscoveredPorts;
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_ID 13

} MSFC_HBAPortAttributesResults, *PMSFC_HBAPortAttributesResults;

#define MSFC_HBAPortAttributesResults_SIZE (FIELD_OFFSET(MSFC_HBAPortAttributesResults, NumberofDiscoveredPorts) + MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_SIZE)

// MSFC_FibrePortHBAAttributes - MSFC_FibrePortHBAAttributes
// This class exposes attribute information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAAttributesGuid \
    { 0x61b397fd,0xf5ae,0x4950, { 0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FibrePortHBAAttributes_GUID, \
            0x61b397fd,0xf5ae,0x4950,0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6);
#endif


typedef struct _MSFC_FibrePortHBAAttributes
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAAttributes_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAAttributes_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAAttributes_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults Attributes;
    #define MSFC_FibrePortHBAAttributes_Attributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define MSFC_FibrePortHBAAttributes_Attributes_ID 3

} MSFC_FibrePortHBAAttributes, *PMSFC_FibrePortHBAAttributes;

#define MSFC_FibrePortHBAAttributes_SIZE (FIELD_OFFSET(MSFC_FibrePortHBAAttributes, Attributes) + MSFC_FibrePortHBAAttributes_Attributes_SIZE)

// MSFC_FibrePortHBAStatistics - MSFC_FibrePortHBAStatistics
// This class exposes statistical information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAStatisticsGuid \
    { 0x27efaba4,0x362a,0x4f20, { 0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FibrePortHBAStatistics_GUID, \
            0x27efaba4,0x362a,0x4f20,0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5);
#endif


typedef struct _MSFC_FibrePortHBAStatistics
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAStatistics_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAStatistics_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAStatistics_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAStatistics_HBAStatus_ID 2

    // 
    MSFC_HBAPortStatistics Statistics;
    #define MSFC_FibrePortHBAStatistics_Statistics_SIZE sizeof(MSFC_HBAPortStatistics)
    #define MSFC_FibrePortHBAStatistics_Statistics_ID 3

} MSFC_FibrePortHBAStatistics, *PMSFC_FibrePortHBAStatistics;

#define MSFC_FibrePortHBAStatistics_SIZE (FIELD_OFFSET(MSFC_FibrePortHBAStatistics, Statistics) + MSFC_FibrePortHBAStatistics_Statistics_SIZE)

// MSFC_FibrePortHBAMethods - MSFC_FibrePortHBAMethods
// This class exposes operations that can be performed on a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAMethodsGuid \
    { 0xe693553e,0xedf6,0x4d57, { 0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FibrePortHBAMethods_GUID, \
            0xe693553e,0xedf6,0x4d57,0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c);
#endif

//
// Method id definitions for MSFC_FibrePortHBAMethods
#define ResetStatistics     1

// MSFC_FC4STATISTICS - MSFC_FC4STATISTICS
#define MSFC_FC4STATISTICSGuid \
    { 0xca8e7fe6,0xb85e,0x497f, { 0x88,0x58,0x9b,0x5d,0x93,0xa6,0x6f,0xe1 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FC4STATISTICS_GUID, \
            0xca8e7fe6,0xb85e,0x497f,0x88,0x58,0x9b,0x5d,0x93,0xa6,0x6f,0xe1);
#endif


typedef struct _MSFC_FC4STATISTICS
{
    // 
    ULONGLONG InputRequests;
    #define MSFC_FC4STATISTICS_InputRequests_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_InputRequests_ID 1

    // 
    ULONGLONG OutputRequests;
    #define MSFC_FC4STATISTICS_OutputRequests_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_OutputRequests_ID 2

    // 
    ULONGLONG ControlRequests;
    #define MSFC_FC4STATISTICS_ControlRequests_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_ControlRequests_ID 3

    // 
    ULONGLONG InputMegabytes;
    #define MSFC_FC4STATISTICS_InputMegabytes_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_InputMegabytes_ID 4

    // 
    ULONGLONG OutputMegabytes;
    #define MSFC_FC4STATISTICS_OutputMegabytes_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_OutputMegabytes_ID 5

} MSFC_FC4STATISTICS, *PMSFC_FC4STATISTICS;

#define MSFC_FC4STATISTICS_SIZE (FIELD_OFFSET(MSFC_FC4STATISTICS, OutputMegabytes) + MSFC_FC4STATISTICS_OutputMegabytes_SIZE)

// MSFC_EventBuffer - MSFC_EventBuffer
// 
#define MSFC_EventBufferGuid \
    { 0x623f4588,0xcf01,0x4f0e, { 0xb1,0x97,0xab,0xbe,0xe5,0xe0,0xcf,0xf3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_EventBuffer_GUID, \
            0x623f4588,0xcf01,0x4f0e,0xb1,0x97,0xab,0xbe,0xe5,0xe0,0xcf,0xf3);
#endif


typedef struct _MSFC_EventBuffer
{
    // 
    ULONG EventType;
    #define MSFC_EventBuffer_EventType_SIZE sizeof(ULONG)
    #define MSFC_EventBuffer_EventType_ID 1

    // 
    ULONG EventInfo[4];
    #define MSFC_EventBuffer_EventInfo_SIZE sizeof(ULONG[4])
    #define MSFC_EventBuffer_EventInfo_ID 2

} MSFC_EventBuffer, *PMSFC_EventBuffer;

#define MSFC_EventBuffer_SIZE (FIELD_OFFSET(MSFC_EventBuffer, EventInfo) + MSFC_EventBuffer_EventInfo_SIZE)

// MSFC_HBAAdapterMethods - MSFC_HBAAdapterMethods
// This class exposes port discovery operations that can be by a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_HBAAdapterMethodsGuid \
    { 0xdf87d4ed,0x4612,0x4d12, { 0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAAdapterMethods_GUID, \
            0xdf87d4ed,0x4612,0x4d12,0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c);
#endif

//
// Method id definitions for MSFC_HBAAdapterMethods
#define GetDiscoveredPortAttributes     1
typedef struct _GetDiscoveredPortAttributes_IN
{
    // 
    ULONG PortIndex;
    #define GetDiscoveredPortAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_PortIndex_ID 1

    // 
    ULONG DiscoveredPortIndex;
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_ID 2

} GetDiscoveredPortAttributes_IN, *PGetDiscoveredPortAttributes_IN;

#define GetDiscoveredPortAttributes_IN_SIZE (FIELD_OFFSET(GetDiscoveredPortAttributes_IN, DiscoveredPortIndex) + GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE)

typedef struct _GetDiscoveredPortAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_ID 3

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_ID 4

} GetDiscoveredPortAttributes_OUT, *PGetDiscoveredPortAttributes_OUT;

#define GetDiscoveredPortAttributes_OUT_SIZE (FIELD_OFFSET(GetDiscoveredPortAttributes_OUT, PortAttributes) + GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE)

#define GetPortAttributesByWWN     2
typedef struct _GetPortAttributesByWWN_IN
{
    // 
    UCHAR wwn[8];
    #define GetPortAttributesByWWN_IN_wwn_SIZE sizeof(UCHAR[8])
    #define GetPortAttributesByWWN_IN_wwn_ID 1

} GetPortAttributesByWWN_IN, *PGetPortAttributesByWWN_IN;

#define GetPortAttributesByWWN_IN_SIZE (FIELD_OFFSET(GetPortAttributesByWWN_IN, wwn) + GetPortAttributesByWWN_IN_wwn_SIZE)

typedef struct _GetPortAttributesByWWN_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetPortAttributesByWWN_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetPortAttributesByWWN_OUT_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetPortAttributesByWWN_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetPortAttributesByWWN_OUT_PortAttributes_ID 3

} GetPortAttributesByWWN_OUT, *PGetPortAttributesByWWN_OUT;

#define GetPortAttributesByWWN_OUT_SIZE (FIELD_OFFSET(GetPortAttributesByWWN_OUT, PortAttributes) + GetPortAttributesByWWN_OUT_PortAttributes_SIZE)

#define RefreshInformation     3
#define SendCTPassThru     4
typedef struct _SendCTPassThru_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendCTPassThru_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendCTPassThru_IN_PortWWN_ID 1

    // 
    ULONG RequestBufferCount;
    #define SendCTPassThru_IN_RequestBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_IN_RequestBufferCount_ID 2

    // 
    UCHAR RequestBuffer[1];
    #define SendCTPassThru_IN_RequestBuffer_ID 3

} SendCTPassThru_IN, *PSendCTPassThru_IN;

typedef struct _SendCTPassThru_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendCTPassThru_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_HBAStatus_ID 4

    // 
    ULONG TotalResponseBufferCount;
    #define SendCTPassThru_OUT_TotalResponseBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_TotalResponseBufferCount_ID 5

    // 
    ULONG ActualResponseBufferCount;
    #define SendCTPassThru_OUT_ActualResponseBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_ActualResponseBufferCount_ID 6


#define SendCTPassThru_OUT_ResponseBuffer_SIZE_HINT 768

    // 
    UCHAR ResponseBuffer[1];
    #define SendCTPassThru_OUT_ResponseBuffer_ID 7

} SendCTPassThru_OUT, *PSendCTPassThru_OUT;

#define SendRNID     5
typedef struct _SendRNID_IN
{
    // 
    UCHAR wwn[8];
    #define SendRNID_IN_wwn_SIZE sizeof(UCHAR[8])
    #define SendRNID_IN_wwn_ID 1

    // 
    ULONG wwntype;
    #define SendRNID_IN_wwntype_SIZE sizeof(ULONG)
    #define SendRNID_IN_wwntype_ID 2

} SendRNID_IN, *PSendRNID_IN;

#define SendRNID_IN_SIZE (FIELD_OFFSET(SendRNID_IN, wwntype) + SendRNID_IN_wwntype_SIZE)

typedef struct _SendRNID_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRNID_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRNID_OUT_HBAStatus_ID 3

    // 
    ULONG ResponseBufferCount;
    #define SendRNID_OUT_ResponseBufferCount_SIZE sizeof(ULONG)
    #define SendRNID_OUT_ResponseBufferCount_ID 4


#define SendRNID_OUT_ResponseBuffer_SIZE_HINT 76

    // 
    UCHAR ResponseBuffer[1];
    #define SendRNID_OUT_ResponseBuffer_ID 5

} SendRNID_OUT, *PSendRNID_OUT;

#define SendRNIDV2     6
typedef struct _SendRNIDV2_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRNIDV2_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRNIDV2_IN_PortWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SendRNIDV2_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SendRNIDV2_IN_DestWWN_ID 2

    // 
    ULONG DestFCID;
    #define SendRNIDV2_IN_DestFCID_SIZE sizeof(ULONG)
    #define SendRNIDV2_IN_DestFCID_ID 3

    // 
    ULONG NodeIdDataFormat;
    #define SendRNIDV2_IN_NodeIdDataFormat_SIZE sizeof(ULONG)
    #define SendRNIDV2_IN_NodeIdDataFormat_ID 4

} SendRNIDV2_IN, *PSendRNIDV2_IN;

#define SendRNIDV2_IN_SIZE (FIELD_OFFSET(SendRNIDV2_IN, NodeIdDataFormat) + SendRNIDV2_IN_NodeIdDataFormat_SIZE)

typedef struct _SendRNIDV2_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRNIDV2_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRNIDV2_OUT_HBAStatus_ID 5

    // 
    ULONG TotalRspBufferSize;
    #define SendRNIDV2_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRNIDV2_OUT_TotalRspBufferSize_ID 6

    // 
    ULONG ActualRspBufferSize;
    #define SendRNIDV2_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRNIDV2_OUT_ActualRspBufferSize_ID 7


#define SendRNIDV2_OUT_RspBuffer_SIZE_HINT 76

    // 
    UCHAR RspBuffer[1];
    #define SendRNIDV2_OUT_RspBuffer_ID 8

} SendRNIDV2_OUT, *PSendRNIDV2_OUT;

#define GetFC3MgmtInfo     7
typedef struct _GetFC3MgmtInfo_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFC3MgmtInfo_OUT_HBAStatus_ID 1

    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define GetFC3MgmtInfo_OUT_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define GetFC3MgmtInfo_OUT_MgmtInfo_ID 2

} GetFC3MgmtInfo_OUT, *PGetFC3MgmtInfo_OUT;

#define GetFC3MgmtInfo_OUT_SIZE (FIELD_OFFSET(GetFC3MgmtInfo_OUT, MgmtInfo) + GetFC3MgmtInfo_OUT_MgmtInfo_SIZE)

#define SetFC3MgmtInfo     8
typedef struct _SetFC3MgmtInfo_IN
{
    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define SetFC3MgmtInfo_IN_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define SetFC3MgmtInfo_IN_MgmtInfo_ID 1

} SetFC3MgmtInfo_IN, *PSetFC3MgmtInfo_IN;

#define SetFC3MgmtInfo_IN_SIZE (FIELD_OFFSET(SetFC3MgmtInfo_IN, MgmtInfo) + SetFC3MgmtInfo_IN_MgmtInfo_SIZE)

typedef struct _SetFC3MgmtInfo_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetFC3MgmtInfo_OUT_HBAStatus_ID 2

} SetFC3MgmtInfo_OUT, *PSetFC3MgmtInfo_OUT;

#define SetFC3MgmtInfo_OUT_SIZE (FIELD_OFFSET(SetFC3MgmtInfo_OUT, HBAStatus) + SetFC3MgmtInfo_OUT_HBAStatus_SIZE)

#define SendRPL     9
typedef struct _SendRPL_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRPL_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRPL_IN_PortWWN_ID 1

    // 
    UCHAR AgentWWN[8];
    #define SendRPL_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SendRPL_IN_AgentWWN_ID 2

    // 
    ULONG agent_domain;
    #define SendRPL_IN_agent_domain_SIZE sizeof(ULONG)
    #define SendRPL_IN_agent_domain_ID 3

    // 
    ULONG portIndex;
    #define SendRPL_IN_portIndex_SIZE sizeof(ULONG)
    #define SendRPL_IN_portIndex_ID 4

} SendRPL_IN, *PSendRPL_IN;

#define SendRPL_IN_SIZE (FIELD_OFFSET(SendRPL_IN, portIndex) + SendRPL_IN_portIndex_SIZE)

typedef struct _SendRPL_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRPL_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRPL_OUT_HBAStatus_ID 5

    // 
    ULONG TotalRspBufferSize;
    #define SendRPL_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPL_OUT_TotalRspBufferSize_ID 6

    // 
    ULONG ActualRspBufferSize;
    #define SendRPL_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPL_OUT_ActualRspBufferSize_ID 7


#define SendRPL_OUT_RspBuffer_SIZE_HINT 28 // 12+16*n

    // 
    UCHAR RspBuffer[1];
    #define SendRPL_OUT_RspBuffer_ID 8

} SendRPL_OUT, *PSendRPL_OUT;

#define SendRPS     10
typedef struct _SendRPS_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRPS_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRPS_IN_PortWWN_ID 1

    // 
    UCHAR AgentWWN[8];
    #define SendRPS_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SendRPS_IN_AgentWWN_ID 2

    // 
    UCHAR ObjectWWN[8];
    #define SendRPS_IN_ObjectWWN_SIZE sizeof(UCHAR[8])
    #define SendRPS_IN_ObjectWWN_ID 3

    // 
    ULONG AgentDomain;
    #define SendRPS_IN_AgentDomain_SIZE sizeof(ULONG)
    #define SendRPS_IN_AgentDomain_ID 4

    // 
    ULONG ObjectPortNumber;
    #define SendRPS_IN_ObjectPortNumber_SIZE sizeof(ULONG)
    #define SendRPS_IN_ObjectPortNumber_ID 5

} SendRPS_IN, *PSendRPS_IN;

#define SendRPS_IN_SIZE (FIELD_OFFSET(SendRPS_IN, ObjectPortNumber) + SendRPS_IN_ObjectPortNumber_SIZE)

typedef struct _SendRPS_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRPS_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRPS_OUT_HBAStatus_ID 6

    // 
    ULONG TotalRspBufferSize;
    #define SendRPS_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPS_OUT_TotalRspBufferSize_ID 7

    // 
    ULONG ActualRspBufferSize;
    #define SendRPS_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPS_OUT_ActualRspBufferSize_ID 8


#define SendRPS_OUT_RspBuffer_SIZE_HINT 64

    // 
    UCHAR RspBuffer[1];
    #define SendRPS_OUT_RspBuffer_ID 9

} SendRPS_OUT, *PSendRPS_OUT;

#define SendSRL     11
typedef struct _SendSRL_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendSRL_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendSRL_IN_PortWWN_ID 1

    // 
    UCHAR WWN[8];
    #define SendSRL_IN_WWN_SIZE sizeof(UCHAR[8])
    #define SendSRL_IN_WWN_ID 2

    // 
    ULONG Domain;
    #define SendSRL_IN_Domain_SIZE sizeof(ULONG)
    #define SendSRL_IN_Domain_ID 3

} SendSRL_IN, *PSendSRL_IN;

#define SendSRL_IN_SIZE (FIELD_OFFSET(SendSRL_IN, Domain) + SendSRL_IN_Domain_SIZE)

typedef struct _SendSRL_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendSRL_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendSRL_OUT_HBAStatus_ID 4

    // 
    ULONG TotalRspBufferSize;
    #define SendSRL_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendSRL_OUT_TotalRspBufferSize_ID 5

    // 
    ULONG ActualRspBufferSize;
    #define SendSRL_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendSRL_OUT_ActualRspBufferSize_ID 6


#define SendSRL_OUT_RspBuffer_SIZE_HINT 8

    // 
    UCHAR RspBuffer[1];
    #define SendSRL_OUT_RspBuffer_ID 7

} SendSRL_OUT, *PSendSRL_OUT;

#define SendLIRR     12
typedef struct _SendLIRR_IN
{
    // 
    UCHAR SourceWWN[8];
    #define SendLIRR_IN_SourceWWN_SIZE sizeof(UCHAR[8])
    #define SendLIRR_IN_SourceWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SendLIRR_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SendLIRR_IN_DestWWN_ID 2

    // 
    UCHAR Function;
    #define SendLIRR_IN_Function_SIZE sizeof(UCHAR)
    #define SendLIRR_IN_Function_ID 3

    // 
    UCHAR Type;
    #define SendLIRR_IN_Type_SIZE sizeof(UCHAR)
    #define SendLIRR_IN_Type_ID 4

} SendLIRR_IN, *PSendLIRR_IN;

#define SendLIRR_IN_SIZE (FIELD_OFFSET(SendLIRR_IN, Type) + SendLIRR_IN_Type_SIZE)

typedef struct _SendLIRR_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendLIRR_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendLIRR_OUT_HBAStatus_ID 5

    // 
    ULONG TotalRspBufferSize;
    #define SendLIRR_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendLIRR_OUT_TotalRspBufferSize_ID 6

    // 
    ULONG ActualRspBufferSize;
    #define SendLIRR_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendLIRR_OUT_ActualRspBufferSize_ID 7


#define SendLIRR_OUT_RspBuffer_SIZE_HINT 8

    // 
    UCHAR RspBuffer[1];
    #define SendLIRR_OUT_RspBuffer_ID 8

} SendLIRR_OUT, *PSendLIRR_OUT;

#define GetFC4Statistics     13
typedef struct _GetFC4Statistics_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetFC4Statistics_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetFC4Statistics_IN_PortWWN_ID 1

    // 
    UCHAR FC4Type;
    #define GetFC4Statistics_IN_FC4Type_SIZE sizeof(UCHAR)
    #define GetFC4Statistics_IN_FC4Type_ID 2

} GetFC4Statistics_IN, *PGetFC4Statistics_IN;

#define GetFC4Statistics_IN_SIZE (FIELD_OFFSET(GetFC4Statistics_IN, FC4Type) + GetFC4Statistics_IN_FC4Type_SIZE)

typedef struct _GetFC4Statistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFC4Statistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFC4Statistics_OUT_HBAStatus_ID 3

    // 
    MSFC_FC4STATISTICS FC4Statistics;
    #define GetFC4Statistics_OUT_FC4Statistics_SIZE sizeof(MSFC_FC4STATISTICS)
    #define GetFC4Statistics_OUT_FC4Statistics_ID 4

} GetFC4Statistics_OUT, *PGetFC4Statistics_OUT;

#define GetFC4Statistics_OUT_SIZE (FIELD_OFFSET(GetFC4Statistics_OUT, FC4Statistics) + GetFC4Statistics_OUT_FC4Statistics_SIZE)

#define GetFCPStatistics     14
typedef struct _GetFCPStatistics_IN
{
    // 
    HBAScsiID ScsiId;
    #define GetFCPStatistics_IN_ScsiId_SIZE sizeof(HBAScsiID)
    #define GetFCPStatistics_IN_ScsiId_ID 1

} GetFCPStatistics_IN, *PGetFCPStatistics_IN;

#define GetFCPStatistics_IN_SIZE (FIELD_OFFSET(GetFCPStatistics_IN, ScsiId) + GetFCPStatistics_IN_ScsiId_SIZE)

typedef struct _GetFCPStatistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFCPStatistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFCPStatistics_OUT_HBAStatus_ID 2

    // 
    MSFC_FC4STATISTICS FC4Statistics;
    #define GetFCPStatistics_OUT_FC4Statistics_SIZE sizeof(MSFC_FC4STATISTICS)
    #define GetFCPStatistics_OUT_FC4Statistics_ID 3

} GetFCPStatistics_OUT, *PGetFCPStatistics_OUT;

#define GetFCPStatistics_OUT_SIZE (FIELD_OFFSET(GetFCPStatistics_OUT, FC4Statistics) + GetFCPStatistics_OUT_FC4Statistics_SIZE)

#define ScsiInquiry     15
typedef struct _ScsiInquiry_IN
{
    // 
    UCHAR Cdb[6];
    #define ScsiInquiry_IN_Cdb_SIZE sizeof(UCHAR[6])
    #define ScsiInquiry_IN_Cdb_ID 1

    // 
    UCHAR HbaPortWWN[8];
    #define ScsiInquiry_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiInquiry_IN_HbaPortWWN_ID 2

    // 
    UCHAR DiscoveredPortWWN[8];
    #define ScsiInquiry_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiInquiry_IN_DiscoveredPortWWN_ID 3

    // 
    ULONGLONG FcLun;
    #define ScsiInquiry_IN_FcLun_SIZE sizeof(ULONGLONG)
    #define ScsiInquiry_IN_FcLun_ID 4

} ScsiInquiry_IN, *PScsiInquiry_IN;

#define ScsiInquiry_IN_SIZE (FIELD_OFFSET(ScsiInquiry_IN, FcLun) + ScsiInquiry_IN_FcLun_SIZE)

typedef struct _ScsiInquiry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define ScsiInquiry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_HBAStatus_ID 5

    // 
    ULONG ResponseBufferSize;
    #define ScsiInquiry_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_ResponseBufferSize_ID 6

    // 
    ULONG SenseBufferSize;
    #define ScsiInquiry_OUT_SenseBufferSize_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_SenseBufferSize_ID 7

    // 
    UCHAR ScsiStatus;
    #define ScsiInquiry_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiInquiry_OUT_ScsiStatus_ID 8


#define ScsiInquiry_OUT_ResponseBuffer_SIZE_HINT 96

    // 
    UCHAR ResponseBuffer[1];
    #define ScsiInquiry_OUT_ResponseBuffer_ID 9

    // 
//  UCHAR SenseBuffer[1];
    #define ScsiInquiry_OUT_SenseBuffer_ID 10

} ScsiInquiry_OUT, *PScsiInquiry_OUT;

#define ScsiReadCapacity     16
typedef struct _ScsiReadCapacity_IN
{
    // 
    UCHAR Cdb[10];
    #define ScsiReadCapacity_IN_Cdb_SIZE sizeof(UCHAR[10])
    #define ScsiReadCapacity_IN_Cdb_ID 1

    // 
    UCHAR HbaPortWWN[8];
    #define ScsiReadCapacity_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReadCapacity_IN_HbaPortWWN_ID 2

    // 
    UCHAR DiscoveredPortWWN[8];
    #define ScsiReadCapacity_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReadCapacity_IN_DiscoveredPortWWN_ID 3

    // 
    ULONGLONG FcLun;
    #define ScsiReadCapacity_IN_FcLun_SIZE sizeof(ULONGLONG)
    #define ScsiReadCapacity_IN_FcLun_ID 4

} ScsiReadCapacity_IN, *PScsiReadCapacity_IN;

#define ScsiReadCapacity_IN_SIZE (FIELD_OFFSET(ScsiReadCapacity_IN, FcLun) + ScsiReadCapacity_IN_FcLun_SIZE)

typedef struct _ScsiReadCapacity_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define ScsiReadCapacity_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_HBAStatus_ID 5

    // 
    ULONG ResponseBufferSize;
    #define ScsiReadCapacity_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_ResponseBufferSize_ID 6

    // 
    ULONG SenseBufferSize;
    #define ScsiReadCapacity_OUT_SenseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_SenseBufferSize_ID 7

    // 
    UCHAR ScsiStatus;
    #define ScsiReadCapacity_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiReadCapacity_OUT_ScsiStatus_ID 8


#define ScsiReadCapacity_OUT_ResponseBuffer_SIZE_HINT 16

    // 
    UCHAR ResponseBuffer[1];
    #define ScsiReadCapacity_OUT_ResponseBuffer_ID 9

    // 
//  UCHAR SenseBuffer[1];
    #define ScsiReadCapacity_OUT_SenseBuffer_ID 10

} ScsiReadCapacity_OUT, *PScsiReadCapacity_OUT;

#define ScsiReportLuns     17
typedef struct _ScsiReportLuns_IN
{
    // 
    UCHAR Cdb[12];
    #define ScsiReportLuns_IN_Cdb_SIZE sizeof(UCHAR[12])
    #define ScsiReportLuns_IN_Cdb_ID 1

    // 
    UCHAR HbaPortWWN[8];
    #define ScsiReportLuns_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReportLuns_IN_HbaPortWWN_ID 2

    // 
    UCHAR DiscoveredPortWWN[8];
    #define ScsiReportLuns_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReportLuns_IN_DiscoveredPortWWN_ID 3

} ScsiReportLuns_IN, *PScsiReportLuns_IN;

#define ScsiReportLuns_IN_SIZE (FIELD_OFFSET(ScsiReportLuns_IN, DiscoveredPortWWN) + ScsiReportLuns_IN_DiscoveredPortWWN_SIZE)

typedef struct _ScsiReportLuns_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define ScsiReportLuns_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_HBAStatus_ID 4

    // 
    ULONG ResponseBufferSize;
    #define ScsiReportLuns_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_ResponseBufferSize_ID 5

    // 
    ULONG SenseBufferSize;
    #define ScsiReportLuns_OUT_SenseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_SenseBufferSize_ID 6

    // 
    UCHAR ScsiStatus;
    #define ScsiReportLuns_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiReportLuns_OUT_ScsiStatus_ID 7


#define ScsiReportLuns_OUT_ResponseBuffer_SIZE_HINT 16 // 8+8*number_of_luns

    // 
    UCHAR ResponseBuffer[1];
    #define ScsiReportLuns_OUT_ResponseBuffer_ID 8

    // 
//  UCHAR SenseBuffer[1];
    #define ScsiReportLuns_OUT_SenseBuffer_ID 9

} ScsiReportLuns_OUT, *PScsiReportLuns_OUT;

#define GetEventBuffer     18
typedef struct _GetEventBuffer_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetEventBuffer_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetEventBuffer_OUT_HBAStatus_ID 1

    // 
    ULONG EventCount;
    #define GetEventBuffer_OUT_EventCount_SIZE sizeof(ULONG)
    #define GetEventBuffer_OUT_EventCount_ID 2

    // 
    MSFC_EventBuffer Events[1];
    #define GetEventBuffer_OUT_Events_ID 3

} GetEventBuffer_OUT, *PGetEventBuffer_OUT;

#define SendRLS     19
typedef struct _SendRLS_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRLS_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRLS_IN_PortWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SendRLS_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SendRLS_IN_DestWWN_ID 2

} SendRLS_IN, *PSendRLS_IN;

#define SendRLS_IN_SIZE (FIELD_OFFSET(SendRLS_IN, DestWWN) + SendRLS_IN_DestWWN_SIZE)

typedef struct _SendRLS_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRLS_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRLS_OUT_HBAStatus_ID 3

    // 
    ULONG TotalRspBufferSize;
    #define SendRLS_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRLS_OUT_TotalRspBufferSize_ID 4

    // 
    ULONG ActualRspBufferSize;
    #define SendRLS_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRLS_OUT_ActualRspBufferSize_ID 5


#define SendRLS_OUT_RspBuffer_SIZE_HINT 28

    // 
    UCHAR RspBuffer[1];
    #define SendRLS_OUT_RspBuffer_ID 6

} SendRLS_OUT, *PSendRLS_OUT;


// HBAFCPID - HBAFCPID
#define HBAFCPIDGuid \
    { 0xff02bc96,0x7fb0,0x4bac, { 0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPID_GUID, \
            0xff02bc96,0x7fb0,0x4bac,0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98);
#endif


typedef struct _HBAFCPID
{
    // 
    ULONG Fcid;
    #define HBAFCPID_Fcid_SIZE sizeof(ULONG)
    #define HBAFCPID_Fcid_ID 1

    // 
    UCHAR NodeWWN[8];
    #define HBAFCPID_NodeWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_NodeWWN_ID 2

    // 
    UCHAR PortWWN[8];
    #define HBAFCPID_PortWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_PortWWN_ID 3

    // 
    ULONGLONG FcpLun;
    #define HBAFCPID_FcpLun_SIZE sizeof(ULONGLONG)
    #define HBAFCPID_FcpLun_ID 4

} HBAFCPID, *PHBAFCPID;

#define HBAFCPID_SIZE (FIELD_OFFSET(HBAFCPID, FcpLun) + HBAFCPID_FcpLun_SIZE)

// HBAFCPScsiEntry - HBAFCPScsiEntry
#define HBAFCPScsiEntryGuid \
    { 0x77ca1248,0x1505,0x4221, { 0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPScsiEntry_GUID, \
            0x77ca1248,0x1505,0x4221,0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87);
#endif


typedef struct _HBAFCPScsiEntry
{
    // 
    HBAFCPID FCPId;
    #define HBAFCPScsiEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPScsiEntry_FCPId_ID 1

    // 
    UCHAR Luid[256];
    #define HBAFCPScsiEntry_Luid_SIZE sizeof(UCHAR[256])
    #define HBAFCPScsiEntry_Luid_ID 2

    // 
    HBAScsiID ScsiId;
    #define HBAFCPScsiEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPScsiEntry_ScsiId_ID 3

} HBAFCPScsiEntry, *PHBAFCPScsiEntry;

#define HBAFCPScsiEntry_SIZE (FIELD_OFFSET(HBAFCPScsiEntry, ScsiId) + HBAFCPScsiEntry_ScsiId_SIZE)

// HBAFCPBindingEntry - HBAFCPBindingEntry
#define HBAFCPBindingEntryGuid \
    { 0xfceff8b7,0x9d6b,0x4115, { 0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPBindingEntry_GUID, \
            0xfceff8b7,0x9d6b,0x4115,0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29);
#endif


typedef struct _HBAFCPBindingEntry
{
    // 
    ULONG Type;
    #define HBAFCPBindingEntry_Type_SIZE sizeof(ULONG)
    #define HBAFCPBindingEntry_Type_ID 1

    // 
    HBAFCPID FCPId;
    #define HBAFCPBindingEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPBindingEntry_FCPId_ID 2

    // 
    HBAScsiID ScsiId;
    #define HBAFCPBindingEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPBindingEntry_ScsiId_ID 3

} HBAFCPBindingEntry, *PHBAFCPBindingEntry;

#define HBAFCPBindingEntry_SIZE (FIELD_OFFSET(HBAFCPBindingEntry, ScsiId) + HBAFCPBindingEntry_ScsiId_SIZE)

// HBAFCPBindingEntry2 - HBAFCPBindingEntry2
#define HBAFCPBindingEntry2Guid \
    { 0x3a1e7679,0x4b1f,0x4f31, { 0xa8,0xae,0xfe,0x92,0x78,0x73,0x09,0x24 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPBindingEntry2_GUID, \
            0x3a1e7679,0x4b1f,0x4f31,0xa8,0xae,0xfe,0x92,0x78,0x73,0x09,0x24);
#endif


typedef struct _HBAFCPBindingEntry2
{
    // Ways of performing persistent binding
    ULONG Type;
    #define HBAFCPBindingEntry2_Type_SIZE sizeof(ULONG)
    #define HBAFCPBindingEntry2_Type_ID 1

    // 
    HBAFCPID FCPId;
    #define HBAFCPBindingEntry2_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPBindingEntry2_FCPId_ID 2

    // 
    UCHAR Luid[256];
    #define HBAFCPBindingEntry2_Luid_SIZE sizeof(UCHAR[256])
    #define HBAFCPBindingEntry2_Luid_ID 3

    // 
    HBAScsiID ScsiId;
    #define HBAFCPBindingEntry2_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPBindingEntry2_ScsiId_ID 4

} HBAFCPBindingEntry2, *PHBAFCPBindingEntry2;

#define HBAFCPBindingEntry2_SIZE (FIELD_OFFSET(HBAFCPBindingEntry2, ScsiId) + HBAFCPBindingEntry2_ScsiId_SIZE)

// MSFC_HBAFCPInfo - MSFC_HBAFCPInfo
// This class exposes operations associated with FCP on a Fibre Channel adapter. There should be one instance of this class for each adapter.
#define MSFC_HBAFCPInfoGuid \
    { 0x7a1fc391,0x5b23,0x4c19, { 0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAFCPInfo_GUID, \
            0x7a1fc391,0x5b23,0x4c19,0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3);
#endif

//
// Method id definitions for MSFC_HBAFCPInfo
#define GetFcpTargetMapping     1
typedef struct _GetFcpTargetMapping_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define GetFcpTargetMapping_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define GetFcpTargetMapping_IN_HbaPortWWN_ID 1

    // 
    ULONG InEntryCount;
    #define GetFcpTargetMapping_IN_InEntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_IN_InEntryCount_ID 2

} GetFcpTargetMapping_IN, *PGetFcpTargetMapping_IN;

#define GetFcpTargetMapping_IN_SIZE (FIELD_OFFSET(GetFcpTargetMapping_IN, InEntryCount) + GetFcpTargetMapping_IN_InEntryCount_SIZE)

typedef struct _GetFcpTargetMapping_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFcpTargetMapping_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_HBAStatus_ID 3

    // 
    ULONG TotalEntryCount;
    #define GetFcpTargetMapping_OUT_TotalEntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_TotalEntryCount_ID 4

    // 
    ULONG OutEntryCount;
    #define GetFcpTargetMapping_OUT_OutEntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_OutEntryCount_ID 5

    // 
    HBAFCPScsiEntry Entry[1];
    #define GetFcpTargetMapping_OUT_Entry_ID 6

} GetFcpTargetMapping_OUT, *PGetFcpTargetMapping_OUT;

#define GetFcpPersistentBinding     2
typedef struct _GetFcpPersistentBinding_IN
{
    // 
    ULONG InEntryCount;
    #define GetFcpPersistentBinding_IN_InEntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_IN_InEntryCount_ID 1

} GetFcpPersistentBinding_IN, *PGetFcpPersistentBinding_IN;

#define GetFcpPersistentBinding_IN_SIZE (FIELD_OFFSET(GetFcpPersistentBinding_IN, InEntryCount) + GetFcpPersistentBinding_IN_InEntryCount_SIZE)

typedef struct _GetFcpPersistentBinding_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFcpPersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_HBAStatus_ID 2

    // 
    ULONG TotalEntryCount;
    #define GetFcpPersistentBinding_OUT_TotalEntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_TotalEntryCount_ID 3

    // 
    ULONG OutEntryCount;
    #define GetFcpPersistentBinding_OUT_OutEntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_OutEntryCount_ID 4

    // 
    HBAFCPBindingEntry Entry[1];
    #define GetFcpPersistentBinding_OUT_Entry_ID 5

} GetFcpPersistentBinding_OUT, *PGetFcpPersistentBinding_OUT;

#define GetBindingCapability     3
typedef struct _GetBindingCapability_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetBindingCapability_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetBindingCapability_IN_PortWWN_ID 1

} GetBindingCapability_IN, *PGetBindingCapability_IN;

#define GetBindingCapability_IN_SIZE (FIELD_OFFSET(GetBindingCapability_IN, PortWWN) + GetBindingCapability_IN_PortWWN_SIZE)

typedef struct _GetBindingCapability_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetBindingCapability_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetBindingCapability_OUT_HBAStatus_ID 2

    // Ways of performing persistent binding
    ULONG BindType;
    #define GetBindingCapability_OUT_BindType_SIZE sizeof(ULONG)
    #define GetBindingCapability_OUT_BindType_ID 3

} GetBindingCapability_OUT, *PGetBindingCapability_OUT;

#define GetBindingCapability_OUT_SIZE (FIELD_OFFSET(GetBindingCapability_OUT, BindType) + GetBindingCapability_OUT_BindType_SIZE)

#define GetBindingSupport     4
typedef struct _GetBindingSupport_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetBindingSupport_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetBindingSupport_IN_PortWWN_ID 1

} GetBindingSupport_IN, *PGetBindingSupport_IN;

#define GetBindingSupport_IN_SIZE (FIELD_OFFSET(GetBindingSupport_IN, PortWWN) + GetBindingSupport_IN_PortWWN_SIZE)

typedef struct _GetBindingSupport_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetBindingSupport_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetBindingSupport_OUT_HBAStatus_ID 2

    // Ways of performing persistent binding
    ULONG BindType;
    #define GetBindingSupport_OUT_BindType_SIZE sizeof(ULONG)
    #define GetBindingSupport_OUT_BindType_ID 3

} GetBindingSupport_OUT, *PGetBindingSupport_OUT;

#define GetBindingSupport_OUT_SIZE (FIELD_OFFSET(GetBindingSupport_OUT, BindType) + GetBindingSupport_OUT_BindType_SIZE)

#define SetBindingSupport     5
typedef struct _SetBindingSupport_IN
{
    // 
    UCHAR PortWWN[8];
    #define SetBindingSupport_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SetBindingSupport_IN_PortWWN_ID 1

    // Ways of performing persistent binding
    ULONG BindType;
    #define SetBindingSupport_IN_BindType_SIZE sizeof(ULONG)
    #define SetBindingSupport_IN_BindType_ID 2

} SetBindingSupport_IN, *PSetBindingSupport_IN;

#define SetBindingSupport_IN_SIZE (FIELD_OFFSET(SetBindingSupport_IN, BindType) + SetBindingSupport_IN_BindType_SIZE)

typedef struct _SetBindingSupport_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetBindingSupport_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetBindingSupport_OUT_HBAStatus_ID 3

} SetBindingSupport_OUT, *PSetBindingSupport_OUT;

#define SetBindingSupport_OUT_SIZE (FIELD_OFFSET(SetBindingSupport_OUT, HBAStatus) + SetBindingSupport_OUT_HBAStatus_SIZE)

#define GetPersistentBinding2     6
typedef struct _GetPersistentBinding2_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetPersistentBinding2_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetPersistentBinding2_IN_PortWWN_ID 1

    // 
    ULONG InEntryCount;
    #define GetPersistentBinding2_IN_InEntryCount_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_IN_InEntryCount_ID 2

} GetPersistentBinding2_IN, *PGetPersistentBinding2_IN;

#define GetPersistentBinding2_IN_SIZE (FIELD_OFFSET(GetPersistentBinding2_IN, InEntryCount) + GetPersistentBinding2_IN_InEntryCount_SIZE)

typedef struct _GetPersistentBinding2_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetPersistentBinding2_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_OUT_HBAStatus_ID 3

    // 
    ULONG TotalEntryCount;
    #define GetPersistentBinding2_OUT_TotalEntryCount_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_OUT_TotalEntryCount_ID 4

    // 
    ULONG OutEntryCount;
    #define GetPersistentBinding2_OUT_OutEntryCount_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_OUT_OutEntryCount_ID 5

    // 
    HBAFCPBindingEntry2 Bindings[1];
    #define GetPersistentBinding2_OUT_Bindings_ID 6

} GetPersistentBinding2_OUT, *PGetPersistentBinding2_OUT;



//*********************************************************************
//
//  A call to HBA_SetPersistentBindingV2 will call SetPersistentEntry
//  once for each binding entry.
//  Each binding entry that SetPersistentEntry accepts will be stored
//  in the registry.
//
//  Persistent bindings are stored in the registry under:
//
//     System\CurrentControlSet\Control\Storage\FC\<PortWWN>
//
//         under the REG_BINARY key Bindings  is the struct:
//
//             typedef struct {
//                 ULONG            Version;
//                 HBA_FCPBINDING2  Bindings;
//             } HBAP_PERSISTENT_BINDINGS, *PHBAP_PERSISTENT_BINDINGS;
//
//  This is done so that storport capable drivers may have access to
//  this information during boot
//
//********************************************************************

#define HBA_REGISTRY_BINDING_VERSION        (1)
#define HBA_REGISTRY_BINDING_RELATIVE_PATH  L"System\\CurrentControlSet\\Control\\Storage\\FC"
#define HBA_REGISTRY_BINDING_KEY            L"Bindings"


#define SetPersistentEntry     7
typedef struct _SetPersistentEntry_IN
{
    // 
    UCHAR PortWWN[8];
    #define SetPersistentEntry_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SetPersistentEntry_IN_PortWWN_ID 1

    // 
    HBAFCPBindingEntry2 Binding;
    #define SetPersistentEntry_IN_Binding_SIZE sizeof(HBAFCPBindingEntry2)
    #define SetPersistentEntry_IN_Binding_ID 2

} SetPersistentEntry_IN, *PSetPersistentEntry_IN;

#define SetPersistentEntry_IN_SIZE (FIELD_OFFSET(SetPersistentEntry_IN, Binding) + SetPersistentEntry_IN_Binding_SIZE)

typedef struct _SetPersistentEntry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetPersistentEntry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetPersistentEntry_OUT_HBAStatus_ID 3

} SetPersistentEntry_OUT, *PSetPersistentEntry_OUT;

#define SetPersistentEntry_OUT_SIZE (FIELD_OFFSET(SetPersistentEntry_OUT, HBAStatus) + SetPersistentEntry_OUT_HBAStatus_SIZE)

#define RemovePersistentEntry     8
typedef struct _RemovePersistentEntry_IN
{
    // 
    UCHAR PortWWN[8];
    #define RemovePersistentEntry_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define RemovePersistentEntry_IN_PortWWN_ID 1

    // 
    HBAFCPBindingEntry2 Binding;
    #define RemovePersistentEntry_IN_Binding_SIZE sizeof(HBAFCPBindingEntry2)
    #define RemovePersistentEntry_IN_Binding_ID 2

} RemovePersistentEntry_IN, *PRemovePersistentEntry_IN;

#define RemovePersistentEntry_IN_SIZE (FIELD_OFFSET(RemovePersistentEntry_IN, Binding) + RemovePersistentEntry_IN_Binding_SIZE)

typedef struct _RemovePersistentEntry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemovePersistentEntry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemovePersistentEntry_OUT_HBAStatus_ID 3

} RemovePersistentEntry_OUT, *PRemovePersistentEntry_OUT;

#define RemovePersistentEntry_OUT_SIZE (FIELD_OFFSET(RemovePersistentEntry_OUT, HBAStatus) + RemovePersistentEntry_OUT_HBAStatus_SIZE)


// MSFC_AdapterEvent - MSFC_AdapterEvent
// This class surfaces HBA adapter events
#define MSFC_AdapterEventGuid \
    { 0xe9e47403,0xd1d7,0x43f8, { 0x8e,0xe3,0x53,0xcd,0xbf,0xff,0x56,0x46 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_AdapterEvent_GUID, \
            0xe9e47403,0xd1d7,0x43f8,0x8e,0xe3,0x53,0xcd,0xbf,0xff,0x56,0x46);
#endif


typedef struct _MSFC_AdapterEvent
{
    // Event Type
    ULONG EventType;
    #define MSFC_AdapterEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_AdapterEvent_EventType_ID 1

    // Adapter WWN
    UCHAR PortWWN[8];
    #define MSFC_AdapterEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_AdapterEvent_PortWWN_ID 2

} MSFC_AdapterEvent, *PMSFC_AdapterEvent;

#define MSFC_AdapterEvent_SIZE (FIELD_OFFSET(MSFC_AdapterEvent, PortWWN) + MSFC_AdapterEvent_PortWWN_SIZE)

// MSFC_PortEvent - MSFC_PortEvent
// This class surfaces HBA port events
#define MSFC_PortEventGuid \
    { 0x095fbe97,0x3876,0x48ef, { 0x8a,0x04,0x1c,0x55,0x93,0x5d,0x0d,0xf5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_PortEvent_GUID, \
            0x095fbe97,0x3876,0x48ef,0x8a,0x04,0x1c,0x55,0x93,0x5d,0x0d,0xf5);
#endif


typedef struct _MSFC_PortEvent
{
    // Type of event
    ULONG EventType;
    #define MSFC_PortEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_PortEvent_EventType_ID 1

    // Fabric port id
    ULONG FabricPortId;
    #define MSFC_PortEvent_FabricPortId_SIZE sizeof(ULONG)
    #define MSFC_PortEvent_FabricPortId_ID 2

    // Port WWN
    UCHAR PortWWN[8];
    #define MSFC_PortEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_PortEvent_PortWWN_ID 3

} MSFC_PortEvent, *PMSFC_PortEvent;

#define MSFC_PortEvent_SIZE (FIELD_OFFSET(MSFC_PortEvent, PortWWN) + MSFC_PortEvent_PortWWN_SIZE)

// MSFC_TargetEvent - MSFC_TargetEvent
// This class surfaces HBA target events
#define MSFC_TargetEventGuid \
    { 0xcfa6ef26,0x8675,0x4e27, { 0x9a,0x0b,0xb4,0xa8,0x60,0xdd,0xd0,0xf3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_TargetEvent_GUID, \
            0xcfa6ef26,0x8675,0x4e27,0x9a,0x0b,0xb4,0xa8,0x60,0xdd,0xd0,0xf3);
#endif


typedef struct _MSFC_TargetEvent
{
    // Type of event
    ULONG EventType;
    #define MSFC_TargetEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_TargetEvent_EventType_ID 1

    // Port WWN
    UCHAR PortWWN[8];
    #define MSFC_TargetEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_TargetEvent_PortWWN_ID 2

    // Discovered Port WWN
    UCHAR DiscoveredPortWWN[8];
    #define MSFC_TargetEvent_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_TargetEvent_DiscoveredPortWWN_ID 3

} MSFC_TargetEvent, *PMSFC_TargetEvent;

#define MSFC_TargetEvent_SIZE (FIELD_OFFSET(MSFC_TargetEvent, DiscoveredPortWWN) + MSFC_TargetEvent_DiscoveredPortWWN_SIZE)

// MSFC_EventControl - MSFC_EventControl
// This class defines the port statistics thresholds that will cause a HBA_EVENT_PORT_STAT_THRESHOLD event to occur
#define MSFC_EventControlGuid \
    { 0xa251ccb3,0x5ab0,0x411b, { 0x87,0x71,0x54,0x30,0xef,0x53,0xa2,0x6c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_EventControl_GUID, \
            0xa251ccb3,0x5ab0,0x411b,0x87,0x71,0x54,0x30,0xef,0x53,0xa2,0x6c);
#endif

//
// Method id definitions for MSFC_EventControl
#define AddTarget     10
typedef struct _AddTarget_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define AddTarget_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define AddTarget_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define AddTarget_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define AddTarget_IN_DiscoveredPortWWN_ID 2

    // 
    ULONG AllTargets;
    #define AddTarget_IN_AllTargets_SIZE sizeof(ULONG)
    #define AddTarget_IN_AllTargets_ID 3

} AddTarget_IN, *PAddTarget_IN;

#define AddTarget_IN_SIZE (FIELD_OFFSET(AddTarget_IN, AllTargets) + AddTarget_IN_AllTargets_SIZE)

typedef struct _AddTarget_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define AddTarget_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define AddTarget_OUT_HBAStatus_ID 4

} AddTarget_OUT, *PAddTarget_OUT;

#define AddTarget_OUT_SIZE (FIELD_OFFSET(AddTarget_OUT, HBAStatus) + AddTarget_OUT_HBAStatus_SIZE)

#define RemoveTarget     11
typedef struct _RemoveTarget_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define RemoveTarget_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define RemoveTarget_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define RemoveTarget_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define RemoveTarget_IN_DiscoveredPortWWN_ID 2

    // 
    ULONG AllTargets;
    #define RemoveTarget_IN_AllTargets_SIZE sizeof(ULONG)
    #define RemoveTarget_IN_AllTargets_ID 3

} RemoveTarget_IN, *PRemoveTarget_IN;

#define RemoveTarget_IN_SIZE (FIELD_OFFSET(RemoveTarget_IN, AllTargets) + RemoveTarget_IN_AllTargets_SIZE)

typedef struct _RemoveTarget_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemoveTarget_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemoveTarget_OUT_HBAStatus_ID 4

} RemoveTarget_OUT, *PRemoveTarget_OUT;

#define RemoveTarget_OUT_SIZE (FIELD_OFFSET(RemoveTarget_OUT, HBAStatus) + RemoveTarget_OUT_HBAStatus_SIZE)

#define AddPort     20
typedef struct _AddPort_IN
{
    // 
    UCHAR PortWWN[8];
    #define AddPort_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define AddPort_IN_PortWWN_ID 1

} AddPort_IN, *PAddPort_IN;

#define AddPort_IN_SIZE (FIELD_OFFSET(AddPort_IN, PortWWN) + AddPort_IN_PortWWN_SIZE)

typedef struct _AddPort_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define AddPort_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define AddPort_OUT_HBAStatus_ID 2

} AddPort_OUT, *PAddPort_OUT;

#define AddPort_OUT_SIZE (FIELD_OFFSET(AddPort_OUT, HBAStatus) + AddPort_OUT_HBAStatus_SIZE)

#define RemovePort     21
typedef struct _RemovePort_IN
{
    // 
    UCHAR PortWWN[8];
    #define RemovePort_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define RemovePort_IN_PortWWN_ID 1

} RemovePort_IN, *PRemovePort_IN;

#define RemovePort_IN_SIZE (FIELD_OFFSET(RemovePort_IN, PortWWN) + RemovePort_IN_PortWWN_SIZE)

typedef struct _RemovePort_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemovePort_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemovePort_OUT_HBAStatus_ID 2

} RemovePort_OUT, *PRemovePort_OUT;

#define RemovePort_OUT_SIZE (FIELD_OFFSET(RemovePort_OUT, HBAStatus) + RemovePort_OUT_HBAStatus_SIZE)

#define AddLink     30
typedef struct _AddLink_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define AddLink_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define AddLink_OUT_HBAStatus_ID 1

} AddLink_OUT, *PAddLink_OUT;

#define AddLink_OUT_SIZE (FIELD_OFFSET(AddLink_OUT, HBAStatus) + AddLink_OUT_HBAStatus_SIZE)

#define RemoveLink     31
typedef struct _RemoveLink_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemoveLink_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemoveLink_OUT_HBAStatus_ID 1

} RemoveLink_OUT, *PRemoveLink_OUT;

#define RemoveLink_OUT_SIZE (FIELD_OFFSET(RemoveLink_OUT, HBAStatus) + RemoveLink_OUT_HBAStatus_SIZE)


// MS_SM_AdapterInformationQuery - MS_SM_AdapterInformationQuery
// This class exposes the SM-HBA Adapter attributes. This will include the number of ports on this adapter.


#endif // MSFC_HBA_API

#ifdef MS_SM_HBA_API

#define MS_SM_AdapterInformationQueryGuid \
    { 0xbdc67efa,0xe5e7,0x4777, { 0xb1,0x3c,0x62,0x14,0x59,0x65,0x70,0x99 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_AdapterInformationQuery_GUID, \
            0xbdc67efa,0xe5e7,0x4777,0xb1,0x3c,0x62,0x14,0x59,0x65,0x70,0x99);
#endif


typedef struct _MS_SM_AdapterInformationQuery
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define MS_SM_AdapterInformationQuery_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MS_SM_AdapterInformationQuery_UniqueAdapterId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MS_SM_AdapterInformationQuery_HBAStatus_SIZE sizeof(ULONG)
    #define MS_SM_AdapterInformationQuery_HBAStatus_ID 2

    // 
    ULONG NumberOfPorts;
    #define MS_SM_AdapterInformationQuery_NumberOfPorts_SIZE sizeof(ULONG)
    #define MS_SM_AdapterInformationQuery_NumberOfPorts_ID 3

    // 
    ULONG VendorSpecificID;
    #define MS_SM_AdapterInformationQuery_VendorSpecificID_SIZE sizeof(ULONG)
    #define MS_SM_AdapterInformationQuery_VendorSpecificID_ID 4



   //******************************************************************
   //
   //  The string type is variable length (up to MaxLen).              
   //  Each string starts with a ushort that holds the strings length  
   //  (in bytes) followed by the WCHARs that make up the string.      
   //
   //  This struct is packed so the offset for SerialNumber must be    
   //  computed from the offset of Manufacturer.                       
   //   i.e. SerialNumber = Manufacturer+sizeof(USHORT)+Manufacturer[0]
   //
   //  similarly Model's offset must be computed from SerialNumber etc.
   //
   //******************************************************************


    // 
    WCHAR Manufacturer[64 + 1];
    #define MS_SM_AdapterInformationQuery_Manufacturer_ID 5

    // 
    WCHAR SerialNumber[64 + 1];
    #define MS_SM_AdapterInformationQuery_SerialNumber_ID 6

    // 
    WCHAR Model[256 + 1];
    #define MS_SM_AdapterInformationQuery_Model_ID 7

    // 
    WCHAR ModelDescription[256 + 1];
    #define MS_SM_AdapterInformationQuery_ModelDescription_ID 8

    // 
    WCHAR HardwareVersion[256 + 1];
    #define MS_SM_AdapterInformationQuery_HardwareVersion_ID 9

    // 
    WCHAR DriverVersion[256 + 1];
    #define MS_SM_AdapterInformationQuery_DriverVersion_ID 10

    // 
    WCHAR OptionROMVersion[256 + 1];
    #define MS_SM_AdapterInformationQuery_OptionROMVersion_ID 11

    // 
    WCHAR FirmwareVersion[256 + 1];
    #define MS_SM_AdapterInformationQuery_FirmwareVersion_ID 12

    // 
    WCHAR DriverName[256 + 1];
    #define MS_SM_AdapterInformationQuery_DriverName_ID 13

    // 
    WCHAR HBASymbolicName[256 + 1];
    #define MS_SM_AdapterInformationQuery_HBASymbolicName_ID 14

    // 
    WCHAR RedundantOptionROMVersion[256 + 1];
    #define MS_SM_AdapterInformationQuery_RedundantOptionROMVersion_ID 15

    // 
    WCHAR RedundantFirmwareVersion[256 + 1];
    #define MS_SM_AdapterInformationQuery_RedundantFirmwareVersion_ID 16

    // 
    WCHAR MfgDomain[256 + 1];
    #define MS_SM_AdapterInformationQuery_MfgDomain_ID 17

} MS_SM_AdapterInformationQuery, *PMS_SM_AdapterInformationQuery;

// MS_SMHBA_FC_Port - MS_SMHBA_FC_Port
// This class is the FC_Port attributes
#define MS_SMHBA_FC_PortGuid \
    { 0x96b827a7,0x2b4a,0x49c8, { 0x90,0x97,0x07,0x82,0x00,0xc5,0xa5,0xcd } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_FC_Port_GUID, \
            0x96b827a7,0x2b4a,0x49c8,0x90,0x97,0x07,0x82,0x00,0xc5,0xa5,0xcd);
#endif


typedef struct _MS_SMHBA_FC_Port
{
    // 
    UCHAR NodeWWN[8];
    #define MS_SMHBA_FC_Port_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_FC_Port_NodeWWN_ID 1

    // 
    UCHAR PortWWN[8];
    #define MS_SMHBA_FC_Port_PortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_FC_Port_PortWWN_ID 2

    // 
    ULONG FcId;
    #define MS_SMHBA_FC_Port_FcId_SIZE sizeof(ULONG)
    #define MS_SMHBA_FC_Port_FcId_ID 3

    // 
    ULONG PortSupportedClassofService;
    #define MS_SMHBA_FC_Port_PortSupportedClassofService_SIZE sizeof(ULONG)
    #define MS_SMHBA_FC_Port_PortSupportedClassofService_ID 4

    // 
    UCHAR PortSupportedFc4Types[32];
    #define MS_SMHBA_FC_Port_PortSupportedFc4Types_SIZE sizeof(UCHAR[32])
    #define MS_SMHBA_FC_Port_PortSupportedFc4Types_ID 5

    // 
    UCHAR PortActiveFc4Types[32];
    #define MS_SMHBA_FC_Port_PortActiveFc4Types_SIZE sizeof(UCHAR[32])
    #define MS_SMHBA_FC_Port_PortActiveFc4Types_ID 6

    // 
    UCHAR FabricName[8];
    #define MS_SMHBA_FC_Port_FabricName_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_FC_Port_FabricName_ID 7

    // 
    ULONG NumberofDiscoveredPorts;
    #define MS_SMHBA_FC_Port_NumberofDiscoveredPorts_SIZE sizeof(ULONG)
    #define MS_SMHBA_FC_Port_NumberofDiscoveredPorts_ID 8

    // 
    UCHAR NumberofPhys;
    #define MS_SMHBA_FC_Port_NumberofPhys_SIZE sizeof(UCHAR)
    #define MS_SMHBA_FC_Port_NumberofPhys_ID 9

    // 
    WCHAR PortSymbolicName[256 + 1];
    #define MS_SMHBA_FC_Port_PortSymbolicName_ID 10

} MS_SMHBA_FC_Port, *PMS_SMHBA_FC_Port;

// MS_SMHBA_SAS_Port - MS_SMHBA_SAS_Port
// This class is the SAS_Port attributes
#define MS_SMHBA_SAS_PortGuid \
    { 0xb914e34f,0x7b80,0x46b0, { 0x80,0x34,0x6d,0x9b,0x68,0x9e,0x1d,0xdd } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_SAS_Port_GUID, \
            0xb914e34f,0x7b80,0x46b0,0x80,0x34,0x6d,0x9b,0x68,0x9e,0x1d,0xdd);
#endif


typedef struct _MS_SMHBA_SAS_Port
{
    // 
    ULONG PortProtocol;
    #define MS_SMHBA_SAS_Port_PortProtocol_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_Port_PortProtocol_ID 1

    // 
    UCHAR LocalSASAddress[8];
    #define MS_SMHBA_SAS_Port_LocalSASAddress_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_SAS_Port_LocalSASAddress_ID 2

    // 
    UCHAR AttachedSASAddress[8];
    #define MS_SMHBA_SAS_Port_AttachedSASAddress_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_SAS_Port_AttachedSASAddress_ID 3

    // 
    ULONG NumberofDiscoveredPorts;
    #define MS_SMHBA_SAS_Port_NumberofDiscoveredPorts_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_Port_NumberofDiscoveredPorts_ID 4

    // 
    ULONG NumberofPhys;
    #define MS_SMHBA_SAS_Port_NumberofPhys_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_Port_NumberofPhys_ID 5

} MS_SMHBA_SAS_Port, *PMS_SMHBA_SAS_Port;

#define MS_SMHBA_SAS_Port_SIZE (FIELD_OFFSET(MS_SMHBA_SAS_Port, NumberofPhys) + MS_SMHBA_SAS_Port_NumberofPhys_SIZE)

// MS_SMHBA_PORTATTRIBUTES - MS_SMHBA_PORTATTRIBUTES
#define MS_SMHBA_PORTATTRIBUTESGuid \
    { 0x50a97b2d,0x99ad,0x4cf9, { 0x84,0x37,0xb4,0xea,0x0c,0x07,0xbe,0x4c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_PORTATTRIBUTES_GUID, \
            0x50a97b2d,0x99ad,0x4cf9,0x84,0x37,0xb4,0xea,0x0c,0x07,0xbe,0x4c);
#endif


typedef struct _MS_SMHBA_PORTATTRIBUTES
{
    // 
    ULONG PortType;
    #define MS_SMHBA_PORTATTRIBUTES_PortType_SIZE sizeof(ULONG)
    #define MS_SMHBA_PORTATTRIBUTES_PortType_ID 1

    // 
    ULONG PortState;
    #define MS_SMHBA_PORTATTRIBUTES_PortState_SIZE sizeof(ULONG)
    #define MS_SMHBA_PORTATTRIBUTES_PortState_ID 2

    // Size of MS_SMHBA_SAS_Port or MS_SMHBA_FC_Port
    ULONG PortSpecificAttributesSize;
    #define MS_SMHBA_PORTATTRIBUTES_PortSpecificAttributesSize_SIZE sizeof(ULONG)
    #define MS_SMHBA_PORTATTRIBUTES_PortSpecificAttributesSize_ID 3

    // 
    WCHAR OSDeviceName[256 + 1];
    #define MS_SMHBA_PORTATTRIBUTES_OSDeviceName_ID 4

    // 
    ULONGLONG Reserved;
    #define MS_SMHBA_PORTATTRIBUTES_Reserved_SIZE sizeof(ULONGLONG)
    #define MS_SMHBA_PORTATTRIBUTES_Reserved_ID 5

    //  MS_SMHBA_SAS_Port or MS_SMHBA_FC_Port Buffer
    UCHAR PortSpecificAttributes[1];
    #define MS_SMHBA_PORTATTRIBUTES_PortSpecificAttributes_ID 6

} MS_SMHBA_PORTATTRIBUTES, *PMS_SMHBA_PORTATTRIBUTES;

// MS_SMHBA_PROTOCOLSTATISTICS - MS_SMHBA_PROTOCOLSTATISTICS
#define MS_SMHBA_PROTOCOLSTATISTICSGuid \
    { 0xb557bd86,0x4128,0x4d5c, { 0xb6,0xe6,0xb6,0x5f,0x9b,0xd6,0x87,0x22 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_PROTOCOLSTATISTICS_GUID, \
            0xb557bd86,0x4128,0x4d5c,0xb6,0xe6,0xb6,0x5f,0x9b,0xd6,0x87,0x22);
#endif


typedef struct _MS_SMHBA_PROTOCOLSTATISTICS
{
    // 
    LONGLONG SecondsSinceLastReset;
    #define MS_SMHBA_PROTOCOLSTATISTICS_SecondsSinceLastReset_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_PROTOCOLSTATISTICS_SecondsSinceLastReset_ID 1

    // 
    LONGLONG InputRequests;
    #define MS_SMHBA_PROTOCOLSTATISTICS_InputRequests_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_PROTOCOLSTATISTICS_InputRequests_ID 2

    // 
    LONGLONG OutputRequests;
    #define MS_SMHBA_PROTOCOLSTATISTICS_OutputRequests_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_PROTOCOLSTATISTICS_OutputRequests_ID 3

    // 
    LONGLONG ControlRequests;
    #define MS_SMHBA_PROTOCOLSTATISTICS_ControlRequests_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_PROTOCOLSTATISTICS_ControlRequests_ID 4

    // 
    LONGLONG InputMegabytes;
    #define MS_SMHBA_PROTOCOLSTATISTICS_InputMegabytes_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_PROTOCOLSTATISTICS_InputMegabytes_ID 5

    // 
    LONGLONG OutputMegabytes;
    #define MS_SMHBA_PROTOCOLSTATISTICS_OutputMegabytes_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_PROTOCOLSTATISTICS_OutputMegabytes_ID 6

} MS_SMHBA_PROTOCOLSTATISTICS, *PMS_SMHBA_PROTOCOLSTATISTICS;

#define MS_SMHBA_PROTOCOLSTATISTICS_SIZE (FIELD_OFFSET(MS_SMHBA_PROTOCOLSTATISTICS, OutputMegabytes) + MS_SMHBA_PROTOCOLSTATISTICS_OutputMegabytes_SIZE)

// MS_SMHBA_SASPHYSTATISTICS - MS_SMHBA_SASPHYSTATISTICS
#define MS_SMHBA_SASPHYSTATISTICSGuid \
    { 0xbd458e7d,0xc40a,0x4401, { 0xa1,0x79,0x11,0x91,0x9c,0xbc,0xc5,0xc6 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_SASPHYSTATISTICS_GUID, \
            0xbd458e7d,0xc40a,0x4401,0xa1,0x79,0x11,0x91,0x9c,0xbc,0xc5,0xc6);
#endif


typedef struct _MS_SMHBA_SASPHYSTATISTICS
{
    // 
    LONGLONG SecondsSinceLastReset;
    #define MS_SMHBA_SASPHYSTATISTICS_SecondsSinceLastReset_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_SecondsSinceLastReset_ID 1

    // 
    LONGLONG TxFrames;
    #define MS_SMHBA_SASPHYSTATISTICS_TxFrames_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_TxFrames_ID 2

    // 
    LONGLONG TxWords;
    #define MS_SMHBA_SASPHYSTATISTICS_TxWords_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_TxWords_ID 3

    // 
    LONGLONG RxFrames;
    #define MS_SMHBA_SASPHYSTATISTICS_RxFrames_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_RxFrames_ID 4

    // 
    LONGLONG RxWords;
    #define MS_SMHBA_SASPHYSTATISTICS_RxWords_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_RxWords_ID 5

    // 
    LONGLONG InvalidDwordCount;
    #define MS_SMHBA_SASPHYSTATISTICS_InvalidDwordCount_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_InvalidDwordCount_ID 6

    // 
    LONGLONG RunningDisparityErrorCount;
    #define MS_SMHBA_SASPHYSTATISTICS_RunningDisparityErrorCount_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_RunningDisparityErrorCount_ID 7

    // 
    LONGLONG LossofDwordSyncCount;
    #define MS_SMHBA_SASPHYSTATISTICS_LossofDwordSyncCount_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_LossofDwordSyncCount_ID 8

    // 
    LONGLONG PhyResetProblemCount;
    #define MS_SMHBA_SASPHYSTATISTICS_PhyResetProblemCount_SIZE sizeof(LONGLONG)
    #define MS_SMHBA_SASPHYSTATISTICS_PhyResetProblemCount_ID 9

} MS_SMHBA_SASPHYSTATISTICS, *PMS_SMHBA_SASPHYSTATISTICS;

#define MS_SMHBA_SASPHYSTATISTICS_SIZE (FIELD_OFFSET(MS_SMHBA_SASPHYSTATISTICS, PhyResetProblemCount) + MS_SMHBA_SASPHYSTATISTICS_PhyResetProblemCount_SIZE)

// MS_SMHBA_FC_PHY - MS_SMHBA_FC_PHY
#define MS_SMHBA_FC_PHYGuid \
    { 0xfb66c8fe,0x1da0,0x48a2, { 0x92,0xdb,0x02,0xc3,0x41,0x14,0x3c,0x46 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_FC_PHY_GUID, \
            0xfb66c8fe,0x1da0,0x48a2,0x92,0xdb,0x02,0xc3,0x41,0x14,0x3c,0x46);
#endif


typedef struct _MS_SMHBA_FC_PHY
{
    // 
    ULONG PhySupportSpeed;
    #define MS_SMHBA_FC_PHY_PhySupportSpeed_SIZE sizeof(ULONG)
    #define MS_SMHBA_FC_PHY_PhySupportSpeed_ID 1

    // 
    ULONG PhySpeed;
    #define MS_SMHBA_FC_PHY_PhySpeed_SIZE sizeof(ULONG)
    #define MS_SMHBA_FC_PHY_PhySpeed_ID 2

    // 
    UCHAR PhyType;
    #define MS_SMHBA_FC_PHY_PhyType_SIZE sizeof(UCHAR)
    #define MS_SMHBA_FC_PHY_PhyType_ID 3

    // 
    ULONG MaxFrameSize;
    #define MS_SMHBA_FC_PHY_MaxFrameSize_SIZE sizeof(ULONG)
    #define MS_SMHBA_FC_PHY_MaxFrameSize_ID 4

} MS_SMHBA_FC_PHY, *PMS_SMHBA_FC_PHY;

#define MS_SMHBA_FC_PHY_SIZE (FIELD_OFFSET(MS_SMHBA_FC_PHY, MaxFrameSize) + MS_SMHBA_FC_PHY_MaxFrameSize_SIZE)

// MS_SMHBA_SAS_PHY - MS_SMHBA_SAS_PHY
#define MS_SMHBA_SAS_PHYGuid \
    { 0xdde0a090,0x96bc,0x452b, { 0x9a,0x64,0x6f,0xbb,0x6a,0x19,0xc4,0x7d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_SAS_PHY_GUID, \
            0xdde0a090,0x96bc,0x452b,0x9a,0x64,0x6f,0xbb,0x6a,0x19,0xc4,0x7d);
#endif


typedef struct _MS_SMHBA_SAS_PHY
{
    // 
    UCHAR PhyIdentifier;
    #define MS_SMHBA_SAS_PHY_PhyIdentifier_SIZE sizeof(UCHAR)
    #define MS_SMHBA_SAS_PHY_PhyIdentifier_ID 1

    // 
    ULONG NegotiatedLinkRate;
    #define MS_SMHBA_SAS_PHY_NegotiatedLinkRate_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_PHY_NegotiatedLinkRate_ID 2

    // 
    ULONG ProgrammedMinLinkRate;
    #define MS_SMHBA_SAS_PHY_ProgrammedMinLinkRate_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_PHY_ProgrammedMinLinkRate_ID 3

    // 
    ULONG HardwareMinLinkRate;
    #define MS_SMHBA_SAS_PHY_HardwareMinLinkRate_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_PHY_HardwareMinLinkRate_ID 4

    // 
    ULONG ProgrammedMaxLinkRate;
    #define MS_SMHBA_SAS_PHY_ProgrammedMaxLinkRate_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_PHY_ProgrammedMaxLinkRate_ID 5

    // 
    ULONG HardwareMaxLinkRate;
    #define MS_SMHBA_SAS_PHY_HardwareMaxLinkRate_SIZE sizeof(ULONG)
    #define MS_SMHBA_SAS_PHY_HardwareMaxLinkRate_ID 6

    // 
    UCHAR domainPortWWN[8];
    #define MS_SMHBA_SAS_PHY_domainPortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_SAS_PHY_domainPortWWN_ID 7

} MS_SMHBA_SAS_PHY, *PMS_SMHBA_SAS_PHY;

#define MS_SMHBA_SAS_PHY_SIZE (FIELD_OFFSET(MS_SMHBA_SAS_PHY, domainPortWWN) + MS_SMHBA_SAS_PHY_domainPortWWN_SIZE)

// MS_SM_PortInformationMethods - MS_SM_PortInformationMethods
// This class exposes port information operations that can be determined from the adapter.  There should be one instance of  this class for each adapter
#define MS_SM_PortInformationMethodsGuid \
    { 0x5b6a8b86,0x708d,0x4ec6, { 0x82,0xa6,0x39,0xad,0xcf,0x6f,0x64,0x33 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_PortInformationMethods_GUID, \
            0x5b6a8b86,0x708d,0x4ec6,0x82,0xa6,0x39,0xad,0xcf,0x6f,0x64,0x33);
#endif

//
// Method id definitions for MS_SM_PortInformationMethods
#define SM_GetPortType     1
typedef struct _SM_GetPortType_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetPortType_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetPortType_IN_PortIndex_ID 1

} SM_GetPortType_IN, *PSM_GetPortType_IN;

#define SM_GetPortType_IN_SIZE (FIELD_OFFSET(SM_GetPortType_IN, PortIndex) + SM_GetPortType_IN_PortIndex_SIZE)

typedef struct _SM_GetPortType_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetPortType_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetPortType_OUT_HBAStatus_ID 2

    // 
    ULONG PortType;
    #define SM_GetPortType_OUT_PortType_SIZE sizeof(ULONG)
    #define SM_GetPortType_OUT_PortType_ID 3

} SM_GetPortType_OUT, *PSM_GetPortType_OUT;

#define SM_GetPortType_OUT_SIZE (FIELD_OFFSET(SM_GetPortType_OUT, PortType) + SM_GetPortType_OUT_PortType_SIZE)

#define SM_GetAdapterPortAttributes     2
typedef struct _SM_GetAdapterPortAttributes_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetAdapterPortAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetAdapterPortAttributes_IN_PortIndex_ID 1


#define SM_PORT_SPECIFIC_ATTRIBUTES_MAXSIZE  max(sizeof(MS_SMHBA_FC_Port),  sizeof(MS_SMHBA_SAS_Port))
    // 
    ULONG PortSpecificAttributesMaxSize;
    #define SM_GetAdapterPortAttributes_IN_PortSpecificAttributesMaxSize_SIZE sizeof(ULONG)
    #define SM_GetAdapterPortAttributes_IN_PortSpecificAttributesMaxSize_ID 2

} SM_GetAdapterPortAttributes_IN, *PSM_GetAdapterPortAttributes_IN;

#define SM_GetAdapterPortAttributes_IN_SIZE (FIELD_OFFSET(SM_GetAdapterPortAttributes_IN, PortSpecificAttributesMaxSize) + SM_GetAdapterPortAttributes_IN_PortSpecificAttributesMaxSize_SIZE)

typedef struct _SM_GetAdapterPortAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetAdapterPortAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetAdapterPortAttributes_OUT_HBAStatus_ID 3

    // 
    MS_SMHBA_PORTATTRIBUTES PortAttributes;
    #define SM_GetAdapterPortAttributes_OUT_PortAttributes_SIZE sizeof(MS_SMHBA_PORTATTRIBUTES)
    #define SM_GetAdapterPortAttributes_OUT_PortAttributes_ID 4

} SM_GetAdapterPortAttributes_OUT, *PSM_GetAdapterPortAttributes_OUT;

#define SM_GetAdapterPortAttributes_OUT_SIZE (FIELD_OFFSET(SM_GetAdapterPortAttributes_OUT, PortAttributes) + SM_GetAdapterPortAttributes_OUT_PortAttributes_SIZE)

#define SM_GetDiscoveredPortAttributes     3
typedef struct _SM_GetDiscoveredPortAttributes_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetDiscoveredPortAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetDiscoveredPortAttributes_IN_PortIndex_ID 1

    // 
    ULONG DiscoveredPortIndex;
    #define SM_GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE sizeof(ULONG)
    #define SM_GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_ID 2

    // 
    ULONG PortSpecificAttributesMaxSize;
    #define SM_GetDiscoveredPortAttributes_IN_PortSpecificAttributesMaxSize_SIZE sizeof(ULONG)
    #define SM_GetDiscoveredPortAttributes_IN_PortSpecificAttributesMaxSize_ID 3

} SM_GetDiscoveredPortAttributes_IN, *PSM_GetDiscoveredPortAttributes_IN;

#define SM_GetDiscoveredPortAttributes_IN_SIZE (FIELD_OFFSET(SM_GetDiscoveredPortAttributes_IN, PortSpecificAttributesMaxSize) + SM_GetDiscoveredPortAttributes_IN_PortSpecificAttributesMaxSize_SIZE)

typedef struct _SM_GetDiscoveredPortAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetDiscoveredPortAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetDiscoveredPortAttributes_OUT_HBAStatus_ID 4

    // 
    MS_SMHBA_PORTATTRIBUTES PortAttributes;
    #define SM_GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE sizeof(MS_SMHBA_PORTATTRIBUTES)
    #define SM_GetDiscoveredPortAttributes_OUT_PortAttributes_ID 5

} SM_GetDiscoveredPortAttributes_OUT, *PSM_GetDiscoveredPortAttributes_OUT;

#define SM_GetDiscoveredPortAttributes_OUT_SIZE (FIELD_OFFSET(SM_GetDiscoveredPortAttributes_OUT, PortAttributes) + SM_GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE)

#define SM_GetPortAttributesByWWN     4
typedef struct _SM_GetPortAttributesByWWN_IN
{
    // 
    UCHAR PortWWN[8];
    #define SM_GetPortAttributesByWWN_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetPortAttributesByWWN_IN_PortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_GetPortAttributesByWWN_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetPortAttributesByWWN_IN_DomainPortWWN_ID 2

    // 
    ULONG PortSpecificAttributesMaxSize;
    #define SM_GetPortAttributesByWWN_IN_PortSpecificAttributesMaxSize_SIZE sizeof(ULONG)
    #define SM_GetPortAttributesByWWN_IN_PortSpecificAttributesMaxSize_ID 3

} SM_GetPortAttributesByWWN_IN, *PSM_GetPortAttributesByWWN_IN;

#define SM_GetPortAttributesByWWN_IN_SIZE (FIELD_OFFSET(SM_GetPortAttributesByWWN_IN, PortSpecificAttributesMaxSize) + SM_GetPortAttributesByWWN_IN_PortSpecificAttributesMaxSize_SIZE)

typedef struct _SM_GetPortAttributesByWWN_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetPortAttributesByWWN_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetPortAttributesByWWN_OUT_HBAStatus_ID 4

    // 
    MS_SMHBA_PORTATTRIBUTES PortAttributes;
    #define SM_GetPortAttributesByWWN_OUT_PortAttributes_SIZE sizeof(MS_SMHBA_PORTATTRIBUTES)
    #define SM_GetPortAttributesByWWN_OUT_PortAttributes_ID 5

} SM_GetPortAttributesByWWN_OUT, *PSM_GetPortAttributesByWWN_OUT;

#define SM_GetPortAttributesByWWN_OUT_SIZE (FIELD_OFFSET(SM_GetPortAttributesByWWN_OUT, PortAttributes) + SM_GetPortAttributesByWWN_OUT_PortAttributes_SIZE)

#define SM_GetProtocolStatistics     5
typedef struct _SM_GetProtocolStatistics_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetProtocolStatistics_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetProtocolStatistics_IN_PortIndex_ID 1

    // 
    ULONG ProtocolType;
    #define SM_GetProtocolStatistics_IN_ProtocolType_SIZE sizeof(ULONG)
    #define SM_GetProtocolStatistics_IN_ProtocolType_ID 2

} SM_GetProtocolStatistics_IN, *PSM_GetProtocolStatistics_IN;

#define SM_GetProtocolStatistics_IN_SIZE (FIELD_OFFSET(SM_GetProtocolStatistics_IN, ProtocolType) + SM_GetProtocolStatistics_IN_ProtocolType_SIZE)

typedef struct _SM_GetProtocolStatistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetProtocolStatistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetProtocolStatistics_OUT_HBAStatus_ID 3

    // 
    MS_SMHBA_PROTOCOLSTATISTICS ProtocolStatistics;
    #define SM_GetProtocolStatistics_OUT_ProtocolStatistics_SIZE sizeof(MS_SMHBA_PROTOCOLSTATISTICS)
    #define SM_GetProtocolStatistics_OUT_ProtocolStatistics_ID 4

} SM_GetProtocolStatistics_OUT, *PSM_GetProtocolStatistics_OUT;

#define SM_GetProtocolStatistics_OUT_SIZE (FIELD_OFFSET(SM_GetProtocolStatistics_OUT, ProtocolStatistics) + SM_GetProtocolStatistics_OUT_ProtocolStatistics_SIZE)

#define SM_GetPhyStatistics     6
typedef struct _SM_GetPhyStatistics_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetPhyStatistics_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetPhyStatistics_IN_PortIndex_ID 1

    // 
    ULONG PhyIndex;
    #define SM_GetPhyStatistics_IN_PhyIndex_SIZE sizeof(ULONG)
    #define SM_GetPhyStatistics_IN_PhyIndex_ID 2

    // 
    ULONG InNumOfPhyCounters;
    #define SM_GetPhyStatistics_IN_InNumOfPhyCounters_SIZE sizeof(ULONG)
    #define SM_GetPhyStatistics_IN_InNumOfPhyCounters_ID 3

} SM_GetPhyStatistics_IN, *PSM_GetPhyStatistics_IN;

#define SM_GetPhyStatistics_IN_SIZE (FIELD_OFFSET(SM_GetPhyStatistics_IN, InNumOfPhyCounters) + SM_GetPhyStatistics_IN_InNumOfPhyCounters_SIZE)

typedef struct _SM_GetPhyStatistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetPhyStatistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetPhyStatistics_OUT_HBAStatus_ID 4

    // 
    ULONG TotalNumOfPhyCounters;
    #define SM_GetPhyStatistics_OUT_TotalNumOfPhyCounters_SIZE sizeof(ULONG)
    #define SM_GetPhyStatistics_OUT_TotalNumOfPhyCounters_ID 5

    // 
    ULONG OutNumOfPhyCounters;
    #define SM_GetPhyStatistics_OUT_OutNumOfPhyCounters_SIZE sizeof(ULONG)
    #define SM_GetPhyStatistics_OUT_OutNumOfPhyCounters_ID 6

    // 
    LONGLONG PhyCounter[1];
    #define SM_GetPhyStatistics_OUT_PhyCounter_ID 7

} SM_GetPhyStatistics_OUT, *PSM_GetPhyStatistics_OUT;

#define SM_GetFCPhyAttributes     7
typedef struct _SM_GetFCPhyAttributes_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetFCPhyAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetFCPhyAttributes_IN_PortIndex_ID 1

    // 
    ULONG PhyIndex;
    #define SM_GetFCPhyAttributes_IN_PhyIndex_SIZE sizeof(ULONG)
    #define SM_GetFCPhyAttributes_IN_PhyIndex_ID 2

} SM_GetFCPhyAttributes_IN, *PSM_GetFCPhyAttributes_IN;

#define SM_GetFCPhyAttributes_IN_SIZE (FIELD_OFFSET(SM_GetFCPhyAttributes_IN, PhyIndex) + SM_GetFCPhyAttributes_IN_PhyIndex_SIZE)

typedef struct _SM_GetFCPhyAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetFCPhyAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetFCPhyAttributes_OUT_HBAStatus_ID 3

    // 
    MS_SMHBA_FC_PHY PhyType;
    #define SM_GetFCPhyAttributes_OUT_PhyType_SIZE sizeof(MS_SMHBA_FC_PHY)
    #define SM_GetFCPhyAttributes_OUT_PhyType_ID 4

} SM_GetFCPhyAttributes_OUT, *PSM_GetFCPhyAttributes_OUT;

#define SM_GetFCPhyAttributes_OUT_SIZE (FIELD_OFFSET(SM_GetFCPhyAttributes_OUT, PhyType) + SM_GetFCPhyAttributes_OUT_PhyType_SIZE)

#define SM_GetSASPhyAttributes     8
typedef struct _SM_GetSASPhyAttributes_IN
{
    // 
    ULONG PortIndex;
    #define SM_GetSASPhyAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_GetSASPhyAttributes_IN_PortIndex_ID 1

    // 
    ULONG PhyIndex;
    #define SM_GetSASPhyAttributes_IN_PhyIndex_SIZE sizeof(ULONG)
    #define SM_GetSASPhyAttributes_IN_PhyIndex_ID 2

} SM_GetSASPhyAttributes_IN, *PSM_GetSASPhyAttributes_IN;

#define SM_GetSASPhyAttributes_IN_SIZE (FIELD_OFFSET(SM_GetSASPhyAttributes_IN, PhyIndex) + SM_GetSASPhyAttributes_IN_PhyIndex_SIZE)

typedef struct _SM_GetSASPhyAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetSASPhyAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetSASPhyAttributes_OUT_HBAStatus_ID 3

    // 
    MS_SMHBA_SAS_PHY PhyType;
    #define SM_GetSASPhyAttributes_OUT_PhyType_SIZE sizeof(MS_SMHBA_SAS_PHY)
    #define SM_GetSASPhyAttributes_OUT_PhyType_ID 4

} SM_GetSASPhyAttributes_OUT, *PSM_GetSASPhyAttributes_OUT;

#define SM_GetSASPhyAttributes_OUT_SIZE (FIELD_OFFSET(SM_GetSASPhyAttributes_OUT, PhyType) + SM_GetSASPhyAttributes_OUT_PhyType_SIZE)

#define SM_RefreshInformation     10

// MS_SMHBA_PORTLUN - MS_SMHBA_PORTLUN
#define MS_SMHBA_PORTLUNGuid \
    { 0x0669d100,0x066e,0x4e49, { 0xa6,0x8c,0xe0,0x51,0x99,0x59,0x61,0x32 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_PORTLUN_GUID, \
            0x0669d100,0x066e,0x4e49,0xa6,0x8c,0xe0,0x51,0x99,0x59,0x61,0x32);
#endif


typedef struct _MS_SMHBA_PORTLUN
{
    // 
    UCHAR PortWWN[8];
    #define MS_SMHBA_PORTLUN_PortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_PORTLUN_PortWWN_ID 1

    // 
    UCHAR domainPortWWN[8];
    #define MS_SMHBA_PORTLUN_domainPortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SMHBA_PORTLUN_domainPortWWN_ID 2

    // 
    ULONGLONG TargetLun;
    #define MS_SMHBA_PORTLUN_TargetLun_SIZE sizeof(ULONGLONG)
    #define MS_SMHBA_PORTLUN_TargetLun_ID 3

} MS_SMHBA_PORTLUN, *PMS_SMHBA_PORTLUN;

#define MS_SMHBA_PORTLUN_SIZE (FIELD_OFFSET(MS_SMHBA_PORTLUN, TargetLun) + MS_SMHBA_PORTLUN_TargetLun_SIZE)

// MS_SMHBA_SCSIENTRY - MS_SMHBA_SCSIENTRY
#define MS_SMHBA_SCSIENTRYGuid \
    { 0x125d41bc,0x7643,0x4155, { 0xb8,0x1c,0xe2,0xf1,0x28,0xad,0x1f,0xb4 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_SCSIENTRY_GUID, \
            0x125d41bc,0x7643,0x4155,0xb8,0x1c,0xe2,0xf1,0x28,0xad,0x1f,0xb4);
#endif


typedef struct _MS_SMHBA_SCSIENTRY
{
    // 
    MS_SMHBA_PORTLUN PortLun;
    #define MS_SMHBA_SCSIENTRY_PortLun_SIZE sizeof(MS_SMHBA_PORTLUN)
    #define MS_SMHBA_SCSIENTRY_PortLun_ID 1

    // 
    UCHAR LUID[256];
    #define MS_SMHBA_SCSIENTRY_LUID_SIZE sizeof(UCHAR[256])
    #define MS_SMHBA_SCSIENTRY_LUID_ID 2

    // 
    HBAScsiID ScsiId;
    #define MS_SMHBA_SCSIENTRY_ScsiId_SIZE sizeof(HBAScsiID)
    #define MS_SMHBA_SCSIENTRY_ScsiId_ID 3

} MS_SMHBA_SCSIENTRY, *PMS_SMHBA_SCSIENTRY;

#define MS_SMHBA_SCSIENTRY_SIZE (FIELD_OFFSET(MS_SMHBA_SCSIENTRY, ScsiId) + MS_SMHBA_SCSIENTRY_ScsiId_SIZE)

// MS_SMHBA_BINDINGENTRY - MS_SMHBA_BINDINGENTRY
#define MS_SMHBA_BINDINGENTRYGuid \
    { 0x65bfb548,0xd00a,0x4d4c, { 0xa3,0x57,0x7d,0xaa,0x23,0xbc,0x2e,0x3d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SMHBA_BINDINGENTRY_GUID, \
            0x65bfb548,0xd00a,0x4d4c,0xa3,0x57,0x7d,0xaa,0x23,0xbc,0x2e,0x3d);
#endif


typedef struct _MS_SMHBA_BINDINGENTRY
{
    // Ways of performing persistent binding
    ULONG type;
    #define MS_SMHBA_BINDINGENTRY_type_SIZE sizeof(ULONG)
    #define MS_SMHBA_BINDINGENTRY_type_ID 1

    // 
    MS_SMHBA_PORTLUN PortLun;
    #define MS_SMHBA_BINDINGENTRY_PortLun_SIZE sizeof(MS_SMHBA_PORTLUN)
    #define MS_SMHBA_BINDINGENTRY_PortLun_ID 2

    // 
    UCHAR LUID[256];
    #define MS_SMHBA_BINDINGENTRY_LUID_SIZE sizeof(UCHAR[256])
    #define MS_SMHBA_BINDINGENTRY_LUID_ID 3

    // HBA Status result for the query operation
    ULONG Status;
    #define MS_SMHBA_BINDINGENTRY_Status_SIZE sizeof(ULONG)
    #define MS_SMHBA_BINDINGENTRY_Status_ID 4

    // 
    HBAScsiID ScsiId;
    #define MS_SMHBA_BINDINGENTRY_ScsiId_SIZE sizeof(HBAScsiID)
    #define MS_SMHBA_BINDINGENTRY_ScsiId_ID 5

} MS_SMHBA_BINDINGENTRY, *PMS_SMHBA_BINDINGENTRY;

#define MS_SMHBA_BINDINGENTRY_SIZE (FIELD_OFFSET(MS_SMHBA_BINDINGENTRY, ScsiId) + MS_SMHBA_BINDINGENTRY_ScsiId_SIZE)

// MS_SM_TargetInformationMethods - MS_SM_TargetInformationMethods
// 
#define MS_SM_TargetInformationMethodsGuid \
    { 0x93545055,0xab4c,0x4e80, { 0x84,0xae,0x6a,0x86,0xa2,0xdc,0x4b,0x84 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_TargetInformationMethods_GUID, \
            0x93545055,0xab4c,0x4e80,0x84,0xae,0x6a,0x86,0xa2,0xdc,0x4b,0x84);
#endif

//
// Method id definitions for MS_SM_TargetInformationMethods
#define SM_GetTargetMapping     1
typedef struct _SM_GetTargetMapping_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_GetTargetMapping_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetTargetMapping_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_GetTargetMapping_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetTargetMapping_IN_DomainPortWWN_ID 2

    // 
    ULONG InEntryCount;
    #define SM_GetTargetMapping_IN_InEntryCount_SIZE sizeof(ULONG)
    #define SM_GetTargetMapping_IN_InEntryCount_ID 3

} SM_GetTargetMapping_IN, *PSM_GetTargetMapping_IN;

#define SM_GetTargetMapping_IN_SIZE (FIELD_OFFSET(SM_GetTargetMapping_IN, InEntryCount) + SM_GetTargetMapping_IN_InEntryCount_SIZE)

typedef struct _SM_GetTargetMapping_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetTargetMapping_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetTargetMapping_OUT_HBAStatus_ID 4

    // 
    ULONG TotalEntryCount;
    #define SM_GetTargetMapping_OUT_TotalEntryCount_SIZE sizeof(ULONG)
    #define SM_GetTargetMapping_OUT_TotalEntryCount_ID 5

    // 
    ULONG OutEntryCount;
    #define SM_GetTargetMapping_OUT_OutEntryCount_SIZE sizeof(ULONG)
    #define SM_GetTargetMapping_OUT_OutEntryCount_ID 6

    // 
    MS_SMHBA_SCSIENTRY Entry[1];
    #define SM_GetTargetMapping_OUT_Entry_ID 7

} SM_GetTargetMapping_OUT, *PSM_GetTargetMapping_OUT;

#define SM_GetBindingCapability     2
typedef struct _SM_GetBindingCapability_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_GetBindingCapability_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetBindingCapability_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_GetBindingCapability_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetBindingCapability_IN_DomainPortWWN_ID 2

} SM_GetBindingCapability_IN, *PSM_GetBindingCapability_IN;

#define SM_GetBindingCapability_IN_SIZE (FIELD_OFFSET(SM_GetBindingCapability_IN, DomainPortWWN) + SM_GetBindingCapability_IN_DomainPortWWN_SIZE)

typedef struct _SM_GetBindingCapability_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetBindingCapability_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetBindingCapability_OUT_HBAStatus_ID 3

    // 
    ULONG Flags;
    #define SM_GetBindingCapability_OUT_Flags_SIZE sizeof(ULONG)
    #define SM_GetBindingCapability_OUT_Flags_ID 4

} SM_GetBindingCapability_OUT, *PSM_GetBindingCapability_OUT;

#define SM_GetBindingCapability_OUT_SIZE (FIELD_OFFSET(SM_GetBindingCapability_OUT, Flags) + SM_GetBindingCapability_OUT_Flags_SIZE)

#define SM_GetBindingSupport     3
typedef struct _SM_GetBindingSupport_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_GetBindingSupport_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetBindingSupport_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_GetBindingSupport_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetBindingSupport_IN_DomainPortWWN_ID 2

} SM_GetBindingSupport_IN, *PSM_GetBindingSupport_IN;

#define SM_GetBindingSupport_IN_SIZE (FIELD_OFFSET(SM_GetBindingSupport_IN, DomainPortWWN) + SM_GetBindingSupport_IN_DomainPortWWN_SIZE)

typedef struct _SM_GetBindingSupport_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetBindingSupport_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetBindingSupport_OUT_HBAStatus_ID 3

    // 
    ULONG Flags;
    #define SM_GetBindingSupport_OUT_Flags_SIZE sizeof(ULONG)
    #define SM_GetBindingSupport_OUT_Flags_ID 4

} SM_GetBindingSupport_OUT, *PSM_GetBindingSupport_OUT;

#define SM_GetBindingSupport_OUT_SIZE (FIELD_OFFSET(SM_GetBindingSupport_OUT, Flags) + SM_GetBindingSupport_OUT_Flags_SIZE)

#define SM_SetBindingSupport     4
typedef struct _SM_SetBindingSupport_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SetBindingSupport_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SetBindingSupport_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_SetBindingSupport_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SetBindingSupport_IN_DomainPortWWN_ID 2

    // 
    ULONG Flags;
    #define SM_SetBindingSupport_IN_Flags_SIZE sizeof(ULONG)
    #define SM_SetBindingSupport_IN_Flags_ID 3

} SM_SetBindingSupport_IN, *PSM_SetBindingSupport_IN;

#define SM_SetBindingSupport_IN_SIZE (FIELD_OFFSET(SM_SetBindingSupport_IN, Flags) + SM_SetBindingSupport_IN_Flags_SIZE)

typedef struct _SM_SetBindingSupport_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SetBindingSupport_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SetBindingSupport_OUT_HBAStatus_ID 4

} SM_SetBindingSupport_OUT, *PSM_SetBindingSupport_OUT;

#define SM_SetBindingSupport_OUT_SIZE (FIELD_OFFSET(SM_SetBindingSupport_OUT, HBAStatus) + SM_SetBindingSupport_OUT_HBAStatus_SIZE)

#define SM_GetPersistentBinding     5
typedef struct _SM_GetPersistentBinding_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_GetPersistentBinding_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetPersistentBinding_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_GetPersistentBinding_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_GetPersistentBinding_IN_DomainPortWWN_ID 2

    // 
    ULONG InEntryCount;
    #define SM_GetPersistentBinding_IN_InEntryCount_SIZE sizeof(ULONG)
    #define SM_GetPersistentBinding_IN_InEntryCount_ID 3

} SM_GetPersistentBinding_IN, *PSM_GetPersistentBinding_IN;

#define SM_GetPersistentBinding_IN_SIZE (FIELD_OFFSET(SM_GetPersistentBinding_IN, InEntryCount) + SM_GetPersistentBinding_IN_InEntryCount_SIZE)

typedef struct _SM_GetPersistentBinding_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetPersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetPersistentBinding_OUT_HBAStatus_ID 4

    // 
    ULONG TotalEntryCount;
    #define SM_GetPersistentBinding_OUT_TotalEntryCount_SIZE sizeof(ULONG)
    #define SM_GetPersistentBinding_OUT_TotalEntryCount_ID 5

    // 
    ULONG OutEntryCount;
    #define SM_GetPersistentBinding_OUT_OutEntryCount_SIZE sizeof(ULONG)
    #define SM_GetPersistentBinding_OUT_OutEntryCount_ID 6

    // 
    MS_SMHBA_BINDINGENTRY Entry[1];
    #define SM_GetPersistentBinding_OUT_Entry_ID 7

} SM_GetPersistentBinding_OUT, *PSM_GetPersistentBinding_OUT;

#define SM_SetPersistentBinding     6
typedef struct _SM_SetPersistentBinding_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SetPersistentBinding_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SetPersistentBinding_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_SetPersistentBinding_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SetPersistentBinding_IN_DomainPortWWN_ID 2

    // 
    ULONG InEntryCount;
    #define SM_SetPersistentBinding_IN_InEntryCount_SIZE sizeof(ULONG)
    #define SM_SetPersistentBinding_IN_InEntryCount_ID 3

    // 
    MS_SMHBA_BINDINGENTRY Entry[1];
    #define SM_SetPersistentBinding_IN_Entry_ID 4

} SM_SetPersistentBinding_IN, *PSM_SetPersistentBinding_IN;

typedef struct _SM_SetPersistentBinding_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SetPersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SetPersistentBinding_OUT_HBAStatus_ID 5

    // 
    ULONG OutStatusCount;
    #define SM_SetPersistentBinding_OUT_OutStatusCount_SIZE sizeof(ULONG)
    #define SM_SetPersistentBinding_OUT_OutStatusCount_ID 6

    // 
    ULONG EntryStatus[1];
    #define SM_SetPersistentBinding_OUT_EntryStatus_ID 7

} SM_SetPersistentBinding_OUT, *PSM_SetPersistentBinding_OUT;

#define SM_RemovePersistentBinding     7
typedef struct _SM_RemovePersistentBinding_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_RemovePersistentBinding_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_RemovePersistentBinding_IN_HbaPortWWN_ID 1

    // 
    UCHAR DomainPortWWN[8];
    #define SM_RemovePersistentBinding_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_RemovePersistentBinding_IN_DomainPortWWN_ID 2

    // 
    ULONG EntryCount;
    #define SM_RemovePersistentBinding_IN_EntryCount_SIZE sizeof(ULONG)
    #define SM_RemovePersistentBinding_IN_EntryCount_ID 3

    // 
    MS_SMHBA_BINDINGENTRY Entry[1];
    #define SM_RemovePersistentBinding_IN_Entry_ID 4

} SM_RemovePersistentBinding_IN, *PSM_RemovePersistentBinding_IN;

typedef struct _SM_RemovePersistentBinding_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_RemovePersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_RemovePersistentBinding_OUT_HBAStatus_ID 5

} SM_RemovePersistentBinding_OUT, *PSM_RemovePersistentBinding_OUT;

#define SM_RemovePersistentBinding_OUT_SIZE (FIELD_OFFSET(SM_RemovePersistentBinding_OUT, HBAStatus) + SM_RemovePersistentBinding_OUT_HBAStatus_SIZE)

#define SM_GetLUNStatistics     8
typedef struct _SM_GetLUNStatistics_IN
{
    // 
    HBAScsiID Lunit;
    #define SM_GetLUNStatistics_IN_Lunit_SIZE sizeof(HBAScsiID)
    #define SM_GetLUNStatistics_IN_Lunit_ID 1

} SM_GetLUNStatistics_IN, *PSM_GetLUNStatistics_IN;

#define SM_GetLUNStatistics_IN_SIZE (FIELD_OFFSET(SM_GetLUNStatistics_IN, Lunit) + SM_GetLUNStatistics_IN_Lunit_SIZE)

typedef struct _SM_GetLUNStatistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetLUNStatistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetLUNStatistics_OUT_HBAStatus_ID 2

    // 
    MS_SMHBA_PROTOCOLSTATISTICS ProtocolStatistics;
    #define SM_GetLUNStatistics_OUT_ProtocolStatistics_SIZE sizeof(MS_SMHBA_PROTOCOLSTATISTICS)
    #define SM_GetLUNStatistics_OUT_ProtocolStatistics_ID 3

} SM_GetLUNStatistics_OUT, *PSM_GetLUNStatistics_OUT;

#define SM_GetLUNStatistics_OUT_SIZE (FIELD_OFFSET(SM_GetLUNStatistics_OUT, ProtocolStatistics) + SM_GetLUNStatistics_OUT_ProtocolStatistics_SIZE)


// MS_SM_ScsiInformationMethods - MS_SM_ScsiInformationMethods
// 
#define MS_SM_ScsiInformationMethodsGuid \
    { 0xb6661e6f,0x075e,0x4209, { 0xae,0x20,0xfe,0x81,0xdb,0x03,0xd9,0x79 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_ScsiInformationMethods_GUID, \
            0xb6661e6f,0x075e,0x4209,0xae,0x20,0xfe,0x81,0xdb,0x03,0xd9,0x79);
#endif

//
// Method id definitions for MS_SM_ScsiInformationMethods
#define SM_ScsiInquiry     1
typedef struct _SM_ScsiInquiry_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_ScsiInquiry_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiInquiry_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define SM_ScsiInquiry_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiInquiry_IN_DiscoveredPortWWN_ID 2

    // 
    UCHAR DomainPortWWN[8];
    #define SM_ScsiInquiry_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiInquiry_IN_DomainPortWWN_ID 3

    // 
    ULONGLONG SmhbaLUN;
    #define SM_ScsiInquiry_IN_SmhbaLUN_SIZE sizeof(ULONGLONG)
    #define SM_ScsiInquiry_IN_SmhbaLUN_ID 4

    // 
    UCHAR Cdb[6];
    #define SM_ScsiInquiry_IN_Cdb_SIZE sizeof(UCHAR[6])
    #define SM_ScsiInquiry_IN_Cdb_ID 5

    // 
    ULONG InRespBufferMaxSize;
    #define SM_ScsiInquiry_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_ScsiInquiry_IN_InRespBufferMaxSize_ID 6

    // 
    ULONG InSenseBufferMaxSize;
    #define SM_ScsiInquiry_IN_InSenseBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_ScsiInquiry_IN_InSenseBufferMaxSize_ID 7

} SM_ScsiInquiry_IN, *PSM_ScsiInquiry_IN;

#define SM_ScsiInquiry_IN_SIZE (FIELD_OFFSET(SM_ScsiInquiry_IN, InSenseBufferMaxSize) + SM_ScsiInquiry_IN_InSenseBufferMaxSize_SIZE)

typedef struct _SM_ScsiInquiry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_ScsiInquiry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_ScsiInquiry_OUT_HBAStatus_ID 8

    // 
    UCHAR ScsiStatus;
    #define SM_ScsiInquiry_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define SM_ScsiInquiry_OUT_ScsiStatus_ID 9

    // 
    ULONG OutRespBufferSize;
    #define SM_ScsiInquiry_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiInquiry_OUT_OutRespBufferSize_ID 10

    // 
    ULONG OutSenseBufferSize;
    #define SM_ScsiInquiry_OUT_OutSenseBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiInquiry_OUT_OutSenseBufferSize_ID 11

    // 
    UCHAR RespBuffer[1];
    #define SM_ScsiInquiry_OUT_RespBuffer_ID 12

    // 
//  UCHAR SenseBuffer[1];
    #define SM_ScsiInquiry_OUT_SenseBuffer_ID 13

} SM_ScsiInquiry_OUT, *PSM_ScsiInquiry_OUT;

#define SM_ScsiReportLuns     2
typedef struct _SM_ScsiReportLuns_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_ScsiReportLuns_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiReportLuns_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define SM_ScsiReportLuns_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiReportLuns_IN_DiscoveredPortWWN_ID 2

    // 
    UCHAR DomainPortWWN[8];
    #define SM_ScsiReportLuns_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiReportLuns_IN_DomainPortWWN_ID 3

    // 
    UCHAR Cdb[12];
    #define SM_ScsiReportLuns_IN_Cdb_SIZE sizeof(UCHAR[12])
    #define SM_ScsiReportLuns_IN_Cdb_ID 4

    // 
    ULONG InRespBufferMaxSize;
    #define SM_ScsiReportLuns_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_ScsiReportLuns_IN_InRespBufferMaxSize_ID 5

    // 
    ULONG InSenseBufferMaxSize;
    #define SM_ScsiReportLuns_IN_InSenseBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_ScsiReportLuns_IN_InSenseBufferMaxSize_ID 6

} SM_ScsiReportLuns_IN, *PSM_ScsiReportLuns_IN;

#define SM_ScsiReportLuns_IN_SIZE (FIELD_OFFSET(SM_ScsiReportLuns_IN, InSenseBufferMaxSize) + SM_ScsiReportLuns_IN_InSenseBufferMaxSize_SIZE)

typedef struct _SM_ScsiReportLuns_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_ScsiReportLuns_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_ScsiReportLuns_OUT_HBAStatus_ID 7

    // 
    UCHAR ScsiStatus;
    #define SM_ScsiReportLuns_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define SM_ScsiReportLuns_OUT_ScsiStatus_ID 8

    // 
    ULONG TotalRespBufferSize;
    #define SM_ScsiReportLuns_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiReportLuns_OUT_TotalRespBufferSize_ID 9

    // 
    ULONG OutRespBufferSize;
    #define SM_ScsiReportLuns_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiReportLuns_OUT_OutRespBufferSize_ID 10

    // 
    ULONG OutSenseBufferSize;
    #define SM_ScsiReportLuns_OUT_OutSenseBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiReportLuns_OUT_OutSenseBufferSize_ID 11

    // 
    UCHAR RespBuffer[1];
    #define SM_ScsiReportLuns_OUT_RespBuffer_ID 12

    // 
//  UCHAR SenseBuffer[1];
    #define SM_ScsiReportLuns_OUT_SenseBuffer_ID 13

} SM_ScsiReportLuns_OUT, *PSM_ScsiReportLuns_OUT;

#define SM_ScsiReadCapacity     3
typedef struct _SM_ScsiReadCapacity_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_ScsiReadCapacity_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiReadCapacity_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define SM_ScsiReadCapacity_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiReadCapacity_IN_DiscoveredPortWWN_ID 2

    // 
    UCHAR DomainPortWWN[8];
    #define SM_ScsiReadCapacity_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_ScsiReadCapacity_IN_DomainPortWWN_ID 3

    // 
    ULONGLONG SmhbaLUN;
    #define SM_ScsiReadCapacity_IN_SmhbaLUN_SIZE sizeof(ULONGLONG)
    #define SM_ScsiReadCapacity_IN_SmhbaLUN_ID 4

    // 
    UCHAR Cdb[16];
    #define SM_ScsiReadCapacity_IN_Cdb_SIZE sizeof(UCHAR[16])
    #define SM_ScsiReadCapacity_IN_Cdb_ID 5

    // 
    ULONG InRespBufferMaxSize;
    #define SM_ScsiReadCapacity_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_ScsiReadCapacity_IN_InRespBufferMaxSize_ID 6

    // 
    ULONG InSenseBufferMaxSize;
    #define SM_ScsiReadCapacity_IN_InSenseBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_ScsiReadCapacity_IN_InSenseBufferMaxSize_ID 7

} SM_ScsiReadCapacity_IN, *PSM_ScsiReadCapacity_IN;

#define SM_ScsiReadCapacity_IN_SIZE (FIELD_OFFSET(SM_ScsiReadCapacity_IN, InSenseBufferMaxSize) + SM_ScsiReadCapacity_IN_InSenseBufferMaxSize_SIZE)

typedef struct _SM_ScsiReadCapacity_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_ScsiReadCapacity_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_ScsiReadCapacity_OUT_HBAStatus_ID 8

    // 
    UCHAR ScsiStatus;
    #define SM_ScsiReadCapacity_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define SM_ScsiReadCapacity_OUT_ScsiStatus_ID 9

    // 
    ULONG OutRespBufferSize;
    #define SM_ScsiReadCapacity_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiReadCapacity_OUT_OutRespBufferSize_ID 10

    // 
    ULONG OutSenseBufferSize;
    #define SM_ScsiReadCapacity_OUT_OutSenseBufferSize_SIZE sizeof(ULONG)
    #define SM_ScsiReadCapacity_OUT_OutSenseBufferSize_ID 11

    // 
    UCHAR RespBuffer[1];
    #define SM_ScsiReadCapacity_OUT_RespBuffer_ID 12

    // 
//  UCHAR SenseBuffer[1];
    #define SM_ScsiReadCapacity_OUT_SenseBuffer_ID 13

} SM_ScsiReadCapacity_OUT, *PSM_ScsiReadCapacity_OUT;


// MS_SM_FabricAndDomainManagementMethods - MS_SM_FabricAndDomainManagementMethods
// 
#define MS_SM_FabricAndDomainManagementMethodsGuid \
    { 0x467fea10,0x701b,0x4388, { 0x91,0x7f,0x73,0x06,0x20,0xce,0xa3,0x28 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_FabricAndDomainManagementMethods_GUID, \
            0x467fea10,0x701b,0x4388,0x91,0x7f,0x73,0x06,0x20,0xce,0xa3,0x28);
#endif

//
// Method id definitions for MS_SM_FabricAndDomainManagementMethods
#define SM_SendTEST     1
typedef struct _SM_SendTEST_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendTEST_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendTEST_IN_HbaPortWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SM_SendTEST_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendTEST_IN_DestWWN_ID 2

    // 
    ULONG DestFCID;
    #define SM_SendTEST_IN_DestFCID_SIZE sizeof(ULONG)
    #define SM_SendTEST_IN_DestFCID_ID 3

    // 
    ULONG ReqBufferSize;
    #define SM_SendTEST_IN_ReqBufferSize_SIZE sizeof(ULONG)
    #define SM_SendTEST_IN_ReqBufferSize_ID 4

    // 
    UCHAR ReqBuffer[1];
    #define SM_SendTEST_IN_ReqBuffer_ID 5

} SM_SendTEST_IN, *PSM_SendTEST_IN;

typedef struct _SM_SendTEST_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendTEST_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendTEST_OUT_HBAStatus_ID 6

} SM_SendTEST_OUT, *PSM_SendTEST_OUT;

#define SM_SendTEST_OUT_SIZE (FIELD_OFFSET(SM_SendTEST_OUT, HBAStatus) + SM_SendTEST_OUT_HBAStatus_SIZE)

#define SM_SendECHO     2
typedef struct _SM_SendECHO_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendECHO_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendECHO_IN_HbaPortWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SM_SendECHO_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendECHO_IN_DestWWN_ID 2

    // 
    ULONG DestFCID;
    #define SM_SendECHO_IN_DestFCID_SIZE sizeof(ULONG)
    #define SM_SendECHO_IN_DestFCID_ID 3

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendECHO_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendECHO_IN_InRespBufferMaxSize_ID 4

    // 
    ULONG ReqBufferSize;
    #define SM_SendECHO_IN_ReqBufferSize_SIZE sizeof(ULONG)
    #define SM_SendECHO_IN_ReqBufferSize_ID 5

    // 
    UCHAR ReqBuffer[1];
    #define SM_SendECHO_IN_ReqBuffer_ID 6

} SM_SendECHO_IN, *PSM_SendECHO_IN;

typedef struct _SM_SendECHO_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendECHO_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendECHO_OUT_HBAStatus_ID 7

    // 
    ULONG OutRespBufferSize;
    #define SM_SendECHO_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendECHO_OUT_OutRespBufferSize_ID 8

    // 
    UCHAR RespBuffer[1];
    #define SM_SendECHO_OUT_RespBuffer_ID 9

} SM_SendECHO_OUT, *PSM_SendECHO_OUT;

#define SM_SendSMPPassThru     3
typedef struct _SM_SendSMPPassThru_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendSMPPassThru_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendSMPPassThru_IN_HbaPortWWN_ID 1

    // 
    UCHAR DestPortWWN[8];
    #define SM_SendSMPPassThru_IN_DestPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendSMPPassThru_IN_DestPortWWN_ID 2

    // 
    UCHAR DomainPortWWN[8];
    #define SM_SendSMPPassThru_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendSMPPassThru_IN_DomainPortWWN_ID 3

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendSMPPassThru_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendSMPPassThru_IN_InRespBufferMaxSize_ID 4

    // 
    ULONG ReqBufferSize;
    #define SM_SendSMPPassThru_IN_ReqBufferSize_SIZE sizeof(ULONG)
    #define SM_SendSMPPassThru_IN_ReqBufferSize_ID 5

    // 
    UCHAR ReqBuffer[1];
    #define SM_SendSMPPassThru_IN_ReqBuffer_ID 6

} SM_SendSMPPassThru_IN, *PSM_SendSMPPassThru_IN;

typedef struct _SM_SendSMPPassThru_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendSMPPassThru_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendSMPPassThru_OUT_HBAStatus_ID 7

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendSMPPassThru_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendSMPPassThru_OUT_TotalRespBufferSize_ID 8

    // 
    ULONG OutRespBufferSize;
    #define SM_SendSMPPassThru_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendSMPPassThru_OUT_OutRespBufferSize_ID 9

    // 
    UCHAR RespBuffer[1];
    #define SM_SendSMPPassThru_OUT_RespBuffer_ID 10

} SM_SendSMPPassThru_OUT, *PSM_SendSMPPassThru_OUT;

#define SM_SendCTPassThru     10
typedef struct _SM_SendCTPassThru_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendCTPassThru_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendCTPassThru_IN_HbaPortWWN_ID 1

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendCTPassThru_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendCTPassThru_IN_InRespBufferMaxSize_ID 2

    // 
    ULONG ReqBufferSize;
    #define SM_SendCTPassThru_IN_ReqBufferSize_SIZE sizeof(ULONG)
    #define SM_SendCTPassThru_IN_ReqBufferSize_ID 3

    // 
    UCHAR ReqBuffer[1];
    #define SM_SendCTPassThru_IN_ReqBuffer_ID 4

} SM_SendCTPassThru_IN, *PSM_SendCTPassThru_IN;

typedef struct _SM_SendCTPassThru_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendCTPassThru_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendCTPassThru_OUT_HBAStatus_ID 5

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendCTPassThru_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendCTPassThru_OUT_TotalRespBufferSize_ID 6

    // 
    ULONG OutRespBufferSize;
    #define SM_SendCTPassThru_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendCTPassThru_OUT_OutRespBufferSize_ID 7

    // 
    UCHAR RespBuffer[1];
    #define SM_SendCTPassThru_OUT_RespBuffer_ID 8

} SM_SendCTPassThru_OUT, *PSM_SendCTPassThru_OUT;

#define SM_GetRNIDMgmtInfo     11
typedef struct _SM_GetRNIDMgmtInfo_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_GetRNIDMgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_GetRNIDMgmtInfo_OUT_HBAStatus_ID 1

    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define SM_GetRNIDMgmtInfo_OUT_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define SM_GetRNIDMgmtInfo_OUT_MgmtInfo_ID 2

} SM_GetRNIDMgmtInfo_OUT, *PSM_GetRNIDMgmtInfo_OUT;

#define SM_GetRNIDMgmtInfo_OUT_SIZE (FIELD_OFFSET(SM_GetRNIDMgmtInfo_OUT, MgmtInfo) + SM_GetRNIDMgmtInfo_OUT_MgmtInfo_SIZE)

#define SM_SetRNIDMgmtInfo     12
typedef struct _SM_SetRNIDMgmtInfo_IN
{
    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define SM_SetRNIDMgmtInfo_IN_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define SM_SetRNIDMgmtInfo_IN_MgmtInfo_ID 1

} SM_SetRNIDMgmtInfo_IN, *PSM_SetRNIDMgmtInfo_IN;

#define SM_SetRNIDMgmtInfo_IN_SIZE (FIELD_OFFSET(SM_SetRNIDMgmtInfo_IN, MgmtInfo) + SM_SetRNIDMgmtInfo_IN_MgmtInfo_SIZE)

typedef struct _SM_SetRNIDMgmtInfo_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SetRNIDMgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SetRNIDMgmtInfo_OUT_HBAStatus_ID 2

} SM_SetRNIDMgmtInfo_OUT, *PSM_SetRNIDMgmtInfo_OUT;

#define SM_SetRNIDMgmtInfo_OUT_SIZE (FIELD_OFFSET(SM_SetRNIDMgmtInfo_OUT, HBAStatus) + SM_SetRNIDMgmtInfo_OUT_HBAStatus_SIZE)

#define SM_SendRNID     13
typedef struct _SM_SendRNID_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendRNID_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRNID_IN_HbaPortWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SM_SendRNID_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRNID_IN_DestWWN_ID 2

    // 
    ULONG DestFCID;
    #define SM_SendRNID_IN_DestFCID_SIZE sizeof(ULONG)
    #define SM_SendRNID_IN_DestFCID_ID 3

    // 
    ULONG NodeIdDataFormat;
    #define SM_SendRNID_IN_NodeIdDataFormat_SIZE sizeof(ULONG)
    #define SM_SendRNID_IN_NodeIdDataFormat_ID 4

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendRNID_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendRNID_IN_InRespBufferMaxSize_ID 5

} SM_SendRNID_IN, *PSM_SendRNID_IN;

#define SM_SendRNID_IN_SIZE (FIELD_OFFSET(SM_SendRNID_IN, InRespBufferMaxSize) + SM_SendRNID_IN_InRespBufferMaxSize_SIZE)

typedef struct _SM_SendRNID_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendRNID_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendRNID_OUT_HBAStatus_ID 6

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendRNID_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRNID_OUT_TotalRespBufferSize_ID 7

    // 
    ULONG OutRespBufferSize;
    #define SM_SendRNID_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRNID_OUT_OutRespBufferSize_ID 8

    // 
    UCHAR RespBuffer[1];
    #define SM_SendRNID_OUT_RespBuffer_ID 9

} SM_SendRNID_OUT, *PSM_SendRNID_OUT;

#define SM_SendRPL     14
typedef struct _SM_SendRPL_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendRPL_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRPL_IN_HbaPortWWN_ID 1

    // 
    UCHAR AgentWWN[8];
    #define SM_SendRPL_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRPL_IN_AgentWWN_ID 2

    // 
    ULONG AgentDomain;
    #define SM_SendRPL_IN_AgentDomain_SIZE sizeof(ULONG)
    #define SM_SendRPL_IN_AgentDomain_ID 3

    // 
    ULONG PortIndex;
    #define SM_SendRPL_IN_PortIndex_SIZE sizeof(ULONG)
    #define SM_SendRPL_IN_PortIndex_ID 4

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendRPL_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendRPL_IN_InRespBufferMaxSize_ID 5

} SM_SendRPL_IN, *PSM_SendRPL_IN;

#define SM_SendRPL_IN_SIZE (FIELD_OFFSET(SM_SendRPL_IN, InRespBufferMaxSize) + SM_SendRPL_IN_InRespBufferMaxSize_SIZE)

typedef struct _SM_SendRPL_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendRPL_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendRPL_OUT_HBAStatus_ID 6

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendRPL_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRPL_OUT_TotalRespBufferSize_ID 7

    // 
    ULONG OutRespBufferSize;
    #define SM_SendRPL_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRPL_OUT_OutRespBufferSize_ID 8

    // 
    UCHAR RespBuffer[1];
    #define SM_SendRPL_OUT_RespBuffer_ID 9

} SM_SendRPL_OUT, *PSM_SendRPL_OUT;

#define SM_SendRPS     15
typedef struct _SM_SendRPS_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendRPS_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRPS_IN_HbaPortWWN_ID 1

    // 
    UCHAR AgentWWN[8];
    #define SM_SendRPS_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRPS_IN_AgentWWN_ID 2

    // 
    UCHAR ObjectWWN[8];
    #define SM_SendRPS_IN_ObjectWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRPS_IN_ObjectWWN_ID 3

    // 
    ULONG AgentDomain;
    #define SM_SendRPS_IN_AgentDomain_SIZE sizeof(ULONG)
    #define SM_SendRPS_IN_AgentDomain_ID 4

    // 
    ULONG ObjectPortNumber;
    #define SM_SendRPS_IN_ObjectPortNumber_SIZE sizeof(ULONG)
    #define SM_SendRPS_IN_ObjectPortNumber_ID 5

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendRPS_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendRPS_IN_InRespBufferMaxSize_ID 6

} SM_SendRPS_IN, *PSM_SendRPS_IN;

#define SM_SendRPS_IN_SIZE (FIELD_OFFSET(SM_SendRPS_IN, InRespBufferMaxSize) + SM_SendRPS_IN_InRespBufferMaxSize_SIZE)

typedef struct _SM_SendRPS_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendRPS_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendRPS_OUT_HBAStatus_ID 7

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendRPS_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRPS_OUT_TotalRespBufferSize_ID 8

    // 
    ULONG OutRespBufferSize;
    #define SM_SendRPS_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRPS_OUT_OutRespBufferSize_ID 9

    // 
    UCHAR RespBuffer[1];
    #define SM_SendRPS_OUT_RespBuffer_ID 10

} SM_SendRPS_OUT, *PSM_SendRPS_OUT;

#define SM_SendSRL     16
typedef struct _SM_SendSRL_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendSRL_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendSRL_IN_HbaPortWWN_ID 1

    // 
    UCHAR WWN[8];
    #define SM_SendSRL_IN_WWN_SIZE sizeof(UCHAR[8])
    #define SM_SendSRL_IN_WWN_ID 2

    // 
    ULONG Domain;
    #define SM_SendSRL_IN_Domain_SIZE sizeof(ULONG)
    #define SM_SendSRL_IN_Domain_ID 3

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendSRL_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendSRL_IN_InRespBufferMaxSize_ID 4

} SM_SendSRL_IN, *PSM_SendSRL_IN;

#define SM_SendSRL_IN_SIZE (FIELD_OFFSET(SM_SendSRL_IN, InRespBufferMaxSize) + SM_SendSRL_IN_InRespBufferMaxSize_SIZE)

typedef struct _SM_SendSRL_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendSRL_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendSRL_OUT_HBAStatus_ID 5

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendSRL_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendSRL_OUT_TotalRespBufferSize_ID 6

    // 
    ULONG OutRespBufferSize;
    #define SM_SendSRL_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendSRL_OUT_OutRespBufferSize_ID 7

    // 
    UCHAR RespBuffer[1];
    #define SM_SendSRL_OUT_RespBuffer_ID 8

} SM_SendSRL_OUT, *PSM_SendSRL_OUT;

#define SM_SendLIRR     17
typedef struct _SM_SendLIRR_IN
{
    // 
    UCHAR SourceWWN[8];
    #define SM_SendLIRR_IN_SourceWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendLIRR_IN_SourceWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SM_SendLIRR_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendLIRR_IN_DestWWN_ID 2

    // 
    UCHAR Function;
    #define SM_SendLIRR_IN_Function_SIZE sizeof(UCHAR)
    #define SM_SendLIRR_IN_Function_ID 3

    // 
    UCHAR Type;
    #define SM_SendLIRR_IN_Type_SIZE sizeof(UCHAR)
    #define SM_SendLIRR_IN_Type_ID 4

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendLIRR_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendLIRR_IN_InRespBufferMaxSize_ID 5

} SM_SendLIRR_IN, *PSM_SendLIRR_IN;

#define SM_SendLIRR_IN_SIZE (FIELD_OFFSET(SM_SendLIRR_IN, InRespBufferMaxSize) + SM_SendLIRR_IN_InRespBufferMaxSize_SIZE)

typedef struct _SM_SendLIRR_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendLIRR_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendLIRR_OUT_HBAStatus_ID 6

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendLIRR_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendLIRR_OUT_TotalRespBufferSize_ID 7

    // 
    ULONG OutRespBufferSize;
    #define SM_SendLIRR_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendLIRR_OUT_OutRespBufferSize_ID 8

    // 
    UCHAR RespBuffer[1];
    #define SM_SendLIRR_OUT_RespBuffer_ID 9

} SM_SendLIRR_OUT, *PSM_SendLIRR_OUT;

#define SM_SendRLS     18
typedef struct _SM_SendRLS_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_SendRLS_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRLS_IN_HbaPortWWN_ID 1

    // 
    UCHAR DestWWN[8];
    #define SM_SendRLS_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SM_SendRLS_IN_DestWWN_ID 2

    // 
    ULONG InRespBufferMaxSize;
    #define SM_SendRLS_IN_InRespBufferMaxSize_SIZE sizeof(ULONG)
    #define SM_SendRLS_IN_InRespBufferMaxSize_ID 3

} SM_SendRLS_IN, *PSM_SendRLS_IN;

#define SM_SendRLS_IN_SIZE (FIELD_OFFSET(SM_SendRLS_IN, InRespBufferMaxSize) + SM_SendRLS_IN_InRespBufferMaxSize_SIZE)

typedef struct _SM_SendRLS_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_SendRLS_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_SendRLS_OUT_HBAStatus_ID 4

    // 
    ULONG TotalRespBufferSize;
    #define SM_SendRLS_OUT_TotalRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRLS_OUT_TotalRespBufferSize_ID 5

    // 
    ULONG OutRespBufferSize;
    #define SM_SendRLS_OUT_OutRespBufferSize_SIZE sizeof(ULONG)
    #define SM_SendRLS_OUT_OutRespBufferSize_ID 6

    // 
    UCHAR RespBuffer[1];
    #define SM_SendRLS_OUT_RespBuffer_ID 7

} SM_SendRLS_OUT, *PSM_SendRLS_OUT;


// MS_SM_AdapterEvent - MS_SM_AdapterEvent
// This class surfaces HBA adapter events
#define MS_SM_AdapterEventGuid \
    { 0x7944cf67,0x697b,0x4432, { 0x95,0x3e,0x1f,0xda,0xda,0x88,0x43,0x61 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_AdapterEvent_GUID, \
            0x7944cf67,0x697b,0x4432,0x95,0x3e,0x1f,0xda,0xda,0x88,0x43,0x61);
#endif


typedef struct _MS_SM_AdapterEvent
{
    // Event Type
    ULONG EventType;
    #define MS_SM_AdapterEvent_EventType_SIZE sizeof(ULONG)
    #define MS_SM_AdapterEvent_EventType_ID 1

    // Adapter WWN
    UCHAR PortWWN[8];
    #define MS_SM_AdapterEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SM_AdapterEvent_PortWWN_ID 2

} MS_SM_AdapterEvent, *PMS_SM_AdapterEvent;

#define MS_SM_AdapterEvent_SIZE (FIELD_OFFSET(MS_SM_AdapterEvent, PortWWN) + MS_SM_AdapterEvent_PortWWN_SIZE)

// MS_SM_PortEvent - MS_SM_PortEvent
// This class surfaces HBA port events
#define MS_SM_PortEventGuid \
    { 0x0f760256,0x8fc6,0x47ad, { 0x9d,0x2e,0xf0,0xd6,0x98,0x01,0xde,0x7c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_PortEvent_GUID, \
            0x0f760256,0x8fc6,0x47ad,0x9d,0x2e,0xf0,0xd6,0x98,0x01,0xde,0x7c);
#endif


typedef struct _MS_SM_PortEvent
{
    // Type of event
    ULONG EventType;
    #define MS_SM_PortEvent_EventType_SIZE sizeof(ULONG)
    #define MS_SM_PortEvent_EventType_ID 1

    // Fabric port id
    ULONG FabricPortId;
    #define MS_SM_PortEvent_FabricPortId_SIZE sizeof(ULONG)
    #define MS_SM_PortEvent_FabricPortId_ID 2

    // Port WWN
    UCHAR PortWWN[8];
    #define MS_SM_PortEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SM_PortEvent_PortWWN_ID 3

} MS_SM_PortEvent, *PMS_SM_PortEvent;

#define MS_SM_PortEvent_SIZE (FIELD_OFFSET(MS_SM_PortEvent, PortWWN) + MS_SM_PortEvent_PortWWN_SIZE)

// MS_SM_TargetEvent - MS_SM_TargetEvent
// This class surfaces HBA target events
#define MS_SM_TargetEventGuid \
    { 0x6e2d8b73,0xf928,0x4da9, { 0xbd,0xa1,0xae,0x54,0x18,0x9a,0x38,0x25 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_TargetEvent_GUID, \
            0x6e2d8b73,0xf928,0x4da9,0xbd,0xa1,0xae,0x54,0x18,0x9a,0x38,0x25);
#endif


typedef struct _MS_SM_TargetEvent
{
    // Type of event
    ULONG EventType;
    #define MS_SM_TargetEvent_EventType_SIZE sizeof(ULONG)
    #define MS_SM_TargetEvent_EventType_ID 1

    // Port WWN
    UCHAR PortWWN[8];
    #define MS_SM_TargetEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SM_TargetEvent_PortWWN_ID 2

    // Discovered Port WWN
    UCHAR DiscoveredPortWWN[8];
    #define MS_SM_TargetEvent_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SM_TargetEvent_DiscoveredPortWWN_ID 3

    // Domain Port WWN
    UCHAR DomainPortWWN[8];
    #define MS_SM_TargetEvent_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define MS_SM_TargetEvent_DomainPortWWN_ID 4

} MS_SM_TargetEvent, *PMS_SM_TargetEvent;

#define MS_SM_TargetEvent_SIZE (FIELD_OFFSET(MS_SM_TargetEvent, DomainPortWWN) + MS_SM_TargetEvent_DomainPortWWN_SIZE)

// MS_SM_EventControl - MS_SM_EventControl
// This class defines the port statistics thresholds that will cause a HBA_EVENT_PORT_STAT_THRESHOLD event to occur
#define MS_SM_EventControlGuid \
    { 0xd6145693,0x5988,0x457f, { 0x85,0x81,0x9a,0x01,0x57,0xb5,0x86,0x90 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MS_SM_EventControl_GUID, \
            0xd6145693,0x5988,0x457f,0x85,0x81,0x9a,0x01,0x57,0xb5,0x86,0x90);
#endif

//
// Method id definitions for MS_SM_EventControl
#define SM_AddTarget     1
typedef struct _SM_AddTarget_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_AddTarget_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_AddTarget_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define SM_AddTarget_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_AddTarget_IN_DiscoveredPortWWN_ID 2

    // 
    UCHAR DomainPortWWN[8];
    #define SM_AddTarget_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_AddTarget_IN_DomainPortWWN_ID 3

    // 
    ULONG AllTargets;
    #define SM_AddTarget_IN_AllTargets_SIZE sizeof(ULONG)
    #define SM_AddTarget_IN_AllTargets_ID 4

} SM_AddTarget_IN, *PSM_AddTarget_IN;

#define SM_AddTarget_IN_SIZE (FIELD_OFFSET(SM_AddTarget_IN, AllTargets) + SM_AddTarget_IN_AllTargets_SIZE)

typedef struct _SM_AddTarget_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_AddTarget_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_AddTarget_OUT_HBAStatus_ID 5

} SM_AddTarget_OUT, *PSM_AddTarget_OUT;

#define SM_AddTarget_OUT_SIZE (FIELD_OFFSET(SM_AddTarget_OUT, HBAStatus) + SM_AddTarget_OUT_HBAStatus_SIZE)

#define SM_RemoveTarget     2
typedef struct _SM_RemoveTarget_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define SM_RemoveTarget_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_RemoveTarget_IN_HbaPortWWN_ID 1

    // 
    UCHAR DiscoveredPortWWN[8];
    #define SM_RemoveTarget_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_RemoveTarget_IN_DiscoveredPortWWN_ID 2

    // 
    UCHAR DomainPortWWN[8];
    #define SM_RemoveTarget_IN_DomainPortWWN_SIZE sizeof(UCHAR[8])
    #define SM_RemoveTarget_IN_DomainPortWWN_ID 3

    // 
    ULONG AllTargets;
    #define SM_RemoveTarget_IN_AllTargets_SIZE sizeof(ULONG)
    #define SM_RemoveTarget_IN_AllTargets_ID 4

} SM_RemoveTarget_IN, *PSM_RemoveTarget_IN;

#define SM_RemoveTarget_IN_SIZE (FIELD_OFFSET(SM_RemoveTarget_IN, AllTargets) + SM_RemoveTarget_IN_AllTargets_SIZE)

typedef struct _SM_RemoveTarget_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_RemoveTarget_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_RemoveTarget_OUT_HBAStatus_ID 5

} SM_RemoveTarget_OUT, *PSM_RemoveTarget_OUT;

#define SM_RemoveTarget_OUT_SIZE (FIELD_OFFSET(SM_RemoveTarget_OUT, HBAStatus) + SM_RemoveTarget_OUT_HBAStatus_SIZE)

#define SM_AddPort     3
typedef struct _SM_AddPort_IN
{
    // 
    UCHAR PortWWN[8];
    #define SM_AddPort_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SM_AddPort_IN_PortWWN_ID 1

    // 
    ULONG EventType;
    #define SM_AddPort_IN_EventType_SIZE sizeof(ULONG)
    #define SM_AddPort_IN_EventType_ID 2

} SM_AddPort_IN, *PSM_AddPort_IN;

#define SM_AddPort_IN_SIZE (FIELD_OFFSET(SM_AddPort_IN, EventType) + SM_AddPort_IN_EventType_SIZE)

typedef struct _SM_AddPort_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_AddPort_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_AddPort_OUT_HBAStatus_ID 3

} SM_AddPort_OUT, *PSM_AddPort_OUT;

#define SM_AddPort_OUT_SIZE (FIELD_OFFSET(SM_AddPort_OUT, HBAStatus) + SM_AddPort_OUT_HBAStatus_SIZE)

#define SM_RemovePort     4
typedef struct _SM_RemovePort_IN
{
    // 
    UCHAR PortWWN[8];
    #define SM_RemovePort_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SM_RemovePort_IN_PortWWN_ID 1

    // 
    ULONG EventType;
    #define SM_RemovePort_IN_EventType_SIZE sizeof(ULONG)
    #define SM_RemovePort_IN_EventType_ID 2

} SM_RemovePort_IN, *PSM_RemovePort_IN;

#define SM_RemovePort_IN_SIZE (FIELD_OFFSET(SM_RemovePort_IN, EventType) + SM_RemovePort_IN_EventType_SIZE)

typedef struct _SM_RemovePort_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_RemovePort_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_RemovePort_OUT_HBAStatus_ID 3

} SM_RemovePort_OUT, *PSM_RemovePort_OUT;

#define SM_RemovePort_OUT_SIZE (FIELD_OFFSET(SM_RemovePort_OUT, HBAStatus) + SM_RemovePort_OUT_HBAStatus_SIZE)

#define SM_AddLink     10
typedef struct _SM_AddLink_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_AddLink_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_AddLink_OUT_HBAStatus_ID 1

} SM_AddLink_OUT, *PSM_AddLink_OUT;

#define SM_AddLink_OUT_SIZE (FIELD_OFFSET(SM_AddLink_OUT, HBAStatus) + SM_AddLink_OUT_HBAStatus_SIZE)

#define SM_RemoveLink     11
typedef struct _SM_RemoveLink_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SM_RemoveLink_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SM_RemoveLink_OUT_HBAStatus_ID 1

} SM_RemoveLink_OUT, *PSM_RemoveLink_OUT;

#define SM_RemoveLink_OUT_SIZE (FIELD_OFFSET(SM_RemoveLink_OUT, HBAStatus) + SM_RemoveLink_OUT_HBAStatus_SIZE)


// MSFC_TM - MSFC_TM
// 

#endif // MS_SM_HBA_API

#define MSFC_TMGuid \
    { 0x8cf4c7eb,0xa286,0x409d, { 0x9e,0xb9,0x29,0xd7,0xe0,0xe9,0xf4,0xfa } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_TM_GUID, \
            0x8cf4c7eb,0xa286,0x409d,0x9e,0xb9,0x29,0xd7,0xe0,0xe9,0xf4,0xfa);
#endif


typedef struct _MSFC_TM
{
    // 
    ULONG tm_sec;
    #define MSFC_TM_tm_sec_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_sec_ID 1

    // 
    ULONG tm_min;
    #define MSFC_TM_tm_min_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_min_ID 2

    // 
    ULONG tm_hour;
    #define MSFC_TM_tm_hour_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_hour_ID 3

    // 
    ULONG tm_mday;
    #define MSFC_TM_tm_mday_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_mday_ID 4

    // 
    ULONG tm_mon;
    #define MSFC_TM_tm_mon_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_mon_ID 5

    // 
    ULONG tm_year;
    #define MSFC_TM_tm_year_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_year_ID 6

    // 
    ULONG tm_wday;
    #define MSFC_TM_tm_wday_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_wday_ID 7

    // 
    ULONG tm_yday;
    #define MSFC_TM_tm_yday_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_yday_ID 8

    // 
    ULONG tm_isdst;
    #define MSFC_TM_tm_isdst_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_isdst_ID 9

} MSFC_TM, *PMSFC_TM;

#define MSFC_TM_SIZE (FIELD_OFFSET(MSFC_TM, tm_isdst) + MSFC_TM_tm_isdst_SIZE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fltWinError.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1989-2002  Microsoft Corporation.  All rights reserved.

Module Name:

    fltWinError.h

Abstract:

    Constant definitions for the HRESULTS values defined by the Filter Manager.

Environment:

    User mode

--*/

#ifndef _FLT_WINERROR_
#define _FLT_WINERROR_

//
// For Windows version 6.00 and later, these error codes are defined in
// winerror.h.  Only use these definitions if not already defined
//
#if NTDDI_VERSION < NTDDI_VISTA
#ifndef FACILITY_USERMODE_FILTER_MANAGER

//
//  HRESULT
//  FILTER_HRESULT_FROM_FLT_NTSTATUS (
//      IN NTSTATUS FltNtStatus
//      )
//
//  Macro Description:
//
//      This macro does the translation from a Filter Manager defined NTSTATUS
//      code to a Filter Manager Library HRESULT.  The Filter Manager Library
//      error code is built as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-+-+-+-+-----------------------+-------------------------------+
//      |S|R|C|R|   FltMgr Facility     |(Code part of FltNtStatus)     |
//      | | | | |                       |     bit-wise or'd with 0x0000 |
//      +-+-+-+-+-----------------------+-------------------------------+
//
//      where
//
//         S - Severity - 1 to indicate FAILURE
//
//         R - reserved portion of the facility code, corresponds to NT's
//             second severity bit.
//
//         C - is the Customer code flag
//
//         R - is a reserved bit
//
//         Facility - FACILITY_USERMODE_FILTER_MANAGER
//
//         Code - Code portion of the NTSTATUS
//
//  Arguments:
//
//      FltNtStatus - The NTSTATUS error code with the Filter Manager facility
//          code to translate to an Filter Manager Library HRESULT.
//
//  Return Value:
//
//      The appropriate HRESULT.
//

#define FILTER_HRESULT_FROM_FLT_NTSTATUS(x) (ASSERT((x & 0xfff0000) == 0x001c0000),(HRESULT) (((x) & 0x8000FFFF) | (FACILITY_USERMODE_FILTER_MANAGER << 16)))


//////////////////////////////////////////////////////////////////////
//
//  HRESULTs for Filter Manager defined NTSTATUS codes
//
//////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_USERMODE_FILTER_MANAGER 0x1F


//
// Define the severity codes
//


//
// MessageId: ERROR_FLT_IO_COMPLETE
//
// MessageText:
//
// The IO was completed by a filter.
//
#define ERROR_FLT_IO_COMPLETE            ((HRESULT)0x001F0001L)

//
// MessageId: ERROR_FLT_NO_HANDLER_DEFINED
//
// MessageText:
//
// A handler was not defined by the filter for this operation.
//
#define ERROR_FLT_NO_HANDLER_DEFINED     ((HRESULT)0x801F0001L)

//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_DEFINED
//
// MessageText:
//
// A context is already defined for this object.
//
#define ERROR_FLT_CONTEXT_ALREADY_DEFINED ((HRESULT)0x801F0002L)

//
// MessageId: ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST
//
// MessageText:
//
// Asynchronous requests are not valid for this operation.
//
#define ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST ((HRESULT)0x801F0003L)

//
// MessageId: ERROR_FLT_DISALLOW_FAST_IO
//
// MessageText:
//
// Disallow the Fast IO path for this operation.
//
#define ERROR_FLT_DISALLOW_FAST_IO       ((HRESULT)0x801F0004L)

//
// MessageId: ERROR_FLT_INVALID_NAME_REQUEST
//
// MessageText:
//
// An invalid name request was made.  The name requested cannot be retrieved at this time.
//
#define ERROR_FLT_INVALID_NAME_REQUEST   ((HRESULT)0x801F0005L)

//
// MessageId: ERROR_FLT_NOT_SAFE_TO_POST_OPERATION
//
// MessageText:
//
// Posting this operation to a worker thread for further processing is not safe
// at this time because it could lead to a system deadlock.
//
#define ERROR_FLT_NOT_SAFE_TO_POST_OPERATION ((HRESULT)0x801F0006L)

//
// MessageId: ERROR_FLT_NOT_INITIALIZED
//
// MessageText:
//
// The Filter Manager was not initialized when a filter tried to register.  Make
// sure that the Filter Manager is getting loaded as a driver.
//
#define ERROR_FLT_NOT_INITIALIZED        ((HRESULT)0x801F0007L)

//
// MessageId: ERROR_FLT_FILTER_NOT_READY
//
// MessageText:
//
// The filter is not ready for attachment to volumes because it has not finished
// initializing (FltStartFiltering has not been called).
//
#define ERROR_FLT_FILTER_NOT_READY       ((HRESULT)0x801F0008L)

//
// MessageId: ERROR_FLT_POST_OPERATION_CLEANUP
//
// MessageText:
//
// The filter must cleanup any operation specific context at this time because
// it is being removed from the system before the operation is completed by
// the lower drivers.
//
#define ERROR_FLT_POST_OPERATION_CLEANUP ((HRESULT)0x801F0009L)

//
// MessageId: ERROR_FLT_INTERNAL_ERROR
//
// MessageText:
//
// The Filter Manager had an internal error from which it cannot recover,
// therefore the operation has been failed.  This is usually the result
// of a filter returning an invalid value from a pre-operation callback.
//
#define ERROR_FLT_INTERNAL_ERROR         ((HRESULT)0x801F000AL)

//
// MessageId: ERROR_FLT_DELETING_OBJECT
//
// MessageText:
//
// The object specified for this action is in the process of being
// deleted, therefore the action requested cannot be completed at
// this time.
//
#define ERROR_FLT_DELETING_OBJECT        ((HRESULT)0x801F000BL)

//
// MessageId: ERROR_FLT_MUST_BE_NONPAGED_POOL
//
// MessageText:
//
// Non-paged pool must be used for this type of context.
//
#define ERROR_FLT_MUST_BE_NONPAGED_POOL  ((HRESULT)0x801F000CL)

//
// MessageId: ERROR_FLT_DUPLICATE_ENTRY
//
// MessageText:
//
// A duplicate handler definition has been provided for an operation.
//
#define ERROR_FLT_DUPLICATE_ENTRY        ((HRESULT)0x801F000DL)

//
// MessageId: ERROR_FLT_CBDQ_DISABLED
//
// MessageText:
//
// The callback data queue has been disabled.
//
#define ERROR_FLT_CBDQ_DISABLED          ((HRESULT)0x801F000EL)

//
// MessageId: ERROR_FLT_DO_NOT_ATTACH
//
// MessageText:
//
// Do not attach the filter to the volume at this time.
//
#define ERROR_FLT_DO_NOT_ATTACH          ((HRESULT)0x801F000FL)

//
// MessageId: ERROR_FLT_DO_NOT_DETACH
//
// MessageText:
//
// Do not detach the filter from the volume at this time.
//
#define ERROR_FLT_DO_NOT_DETACH          ((HRESULT)0x801F0010L)

//
// MessageId: ERROR_FLT_INSTANCE_ALTITUDE_COLLISION
//
// MessageText:
//
// An instance already exists at this altitude on the volume specified.
//
#define ERROR_FLT_INSTANCE_ALTITUDE_COLLISION ((HRESULT)0x801F0011L)

//
// MessageId: ERROR_FLT_INSTANCE_NAME_COLLISION
//
// MessageText:
//
// An instance already exists with this name on the volume specified.
//
#define ERROR_FLT_INSTANCE_NAME_COLLISION ((HRESULT)0x801F0012L)

//
// MessageId: ERROR_FLT_FILTER_NOT_FOUND
//
// MessageText:
//
// The system could not find the filter specified.
//
#define ERROR_FLT_FILTER_NOT_FOUND       ((HRESULT)0x801F0013L)

//
// MessageId: ERROR_FLT_VOLUME_NOT_FOUND
//
// MessageText:
//
// The system could not find the volume specified.
//
#define ERROR_FLT_VOLUME_NOT_FOUND       ((HRESULT)0x801F0014L)

//
// MessageId: ERROR_FLT_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The system could not find the instance specified.
//
#define ERROR_FLT_INSTANCE_NOT_FOUND     ((HRESULT)0x801F0015L)

//
// MessageId: ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND
//
// MessageText:
//
// No registered context allocation definition was found for the given request.
//
#define ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND ((HRESULT)0x801F0016L)

//
// MessageId: ERROR_FLT_INVALID_CONTEXT_REGISTRATION
//
// MessageText:
//
// An invalid parameter was specified during context registration.
//
#define ERROR_FLT_INVALID_CONTEXT_REGISTRATION ((HRESULT)0x801F0017L)

//
// MessageId: ERROR_FLT_NAME_CACHE_MISS
//
// MessageText:
//
// The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.
//
#define ERROR_FLT_NAME_CACHE_MISS        ((HRESULT)0x801F0018L)

//
// MessageId: ERROR_FLT_NO_DEVICE_OBJECT
//
// MessageText:
//
// The requested device object does not exist for the given volume.
//
#define ERROR_FLT_NO_DEVICE_OBJECT       ((HRESULT)0x801F0019L)

//
// MessageId: ERROR_FLT_VOLUME_ALREADY_MOUNTED
//
// MessageText:
//
// The specified volume is already mounted.
//
#define ERROR_FLT_VOLUME_ALREADY_MOUNTED ((HRESULT)0x801F001AL)

//
// MessageId: ERROR_FLT_NO_WAITER_FOR_REPLY
//
// MessageText:
//
// No waiter is present for the filter's reply to this message.
//
#define ERROR_FLT_NO_WAITER_FOR_REPLY    ((HRESULT)0x801F0020L)

#endif // !FACILITY_USERMODE_FILTER_MANAGER
#endif //NTDDIVER < WIN_LH
#endif //_FLT_WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hdaudio.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Assumptions for the type definitions:
//    ULONGLONG = 64bit unsigned integer
//    ULONG     = 32bit unsigned integer
//    USHORT    = 16bit unsigned integer
//    UCHAR     = 8bit unsigned integer
//
#ifndef _HDAUDIO_H_
#define _HDAUDIO_H_

#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

//
// The HDAUDIO_BUS_INTERFACE interface GUID
//
// {D2EAF88B-AB18-41a8-B664-8D592167671B}
DEFINE_GUID (GUID_HDAUDIO_BUS_INTERFACE, 
0xd2eaf88b, 0xab18, 0x41a8, 0xb6, 0x64, 0x8d, 0x59, 0x21, 0x67, 0x67, 0x1b);

//
// The HDAUDIO_BUS_INTERFACE_BDL interface GUID
//
// {B4D65397-5634-40b0-B068-F5B9F8B967A5}
DEFINE_GUID(GUID_HDAUDIO_BUS_INTERFACE_BDL, 
0xb4d65397, 0x5634, 0x40b0, 0xb0, 0x68, 0xf5, 0xb9, 0xf8, 0xb9, 0x67, 0xa5);

//
// The HDAUDIO_BUS_INTERFACE_V2 interface GUID
//
// {B52AF5FB-424B-4BB9-A160-5B38BE94E568}
DEFINE_GUID (GUID_HDAUDIO_BUS_INTERFACE_V2,
0xb52af5fb, 0x424b, 0x4bb9, 0xa1, 0x60, 0x5b, 0x38, 0xbe, 0x94, 0xe5, 0x68);

//
// The HDAudio bus class GUID
//
// {BBD1A745-ADD6-4575-9C2E-9B428D1C3266}
DEFINE_GUID (GUID_HDAUDIO_BUS_CLASS,
  0xbbd1a745, 0xadd6, 0x4575, 0x9c, 0x2e, 0x9b, 0x42, 0x8d, 0x1c, 0x32, 0x66);

#ifndef _HDAUDIO_CODEC_TRANSFER_
#define _HDAUDIO_CODEC_TRANSFER_
//
// Structure for a codec command.
//
typedef struct _HDAUDIO_CODEC_COMMAND
{
  union
  {
    struct
    {
      ULONG Data    : 8;
      ULONG VerbId  : 12;
      ULONG Node    : 8;
      ULONG CodecAddress : 4;
    } Verb8;
    struct
    {
      ULONG Data    : 16;
      ULONG VerbId  : 4;
      ULONG Node    : 8;
      ULONG CodecAddress : 4;
    } Verb16;
    ULONG Command;
  };
} HDAUDIO_CODEC_COMMAND, *PHDAUDIO_CODEC_COMMAND;

//
// Structure to access a codec response.
//
typedef struct _HDAUDIO_CODEC_RESPONSE
{
  union
  {
    struct
    {
      union
      {
        struct
        {
          ULONG Response : 26;
          ULONG Tag : 6;
        } Unsolicited;
        ULONG Response;
      };
      ULONG SDataIn : 4;
      ULONG IsUnsolicitedResponse : 1;
      ULONG :25;
      ULONG HasFifoOverrun : 1;
      ULONG IsValid : 1;
    };
    ULONGLONG CompleteResponse;   // Mostly used for debug print messages.
  };
} HDAUDIO_CODEC_RESPONSE, *PHDAUDIO_CODEC_RESPONSE;

//
// The structure passed in for sending CODEC verbs.
//
typedef struct _HDAUDIO_CODEC_TRANSFER
{
  HDAUDIO_CODEC_COMMAND  Output;
  HDAUDIO_CODEC_RESPONSE Input;
} HDAUDIO_CODEC_TRANSFER, *PHDAUDIO_CODEC_TRANSFER;
#endif

//
// Replacement for WAVEFORMATEXTENSIBLE which has fields that are not used.
//
typedef struct _HDAUDIO_STREAM_FORMAT
{
  ULONG   SampleRate;
  USHORT  ValidBitsPerSample;
  USHORT  ContainerSize;
  USHORT  NumberOfChannels;
} HDAUDIO_STREAM_FORMAT, *PHDAUDIO_STREAM_FORMAT;

//
// The stream descriptor format used to program the input/output converters.
//
typedef struct _HDAUDIO_CONVERTER_FORMAT
{
  union
  {
    struct
    {
      USHORT NumberOfChannels : 4;
      USHORT BitsPerSample : 3;
      USHORT : 1;
      USHORT SampleRate : 7;
      USHORT StreamType : 1;        // Is always set to 0 by bus driver DDI
    };
    USHORT  ConverterFormat;
  };
} HDAUDIO_CONVERTER_FORMAT, *PHDAUDIO_CONVERTER_FORMAT;

//
// The different stream states supported by HDAudio -> STOP (reset), PAUSE or RUN
//
typedef enum _HDAUDIO_STREAM_STATE
{
  ResetState = 0,
  StopState  = 1,
  PauseState = 1,
  RunState   = 2
} HDAUDIO_STREAM_STATE, *PHDAUDIO_STREAM_STATE;

//
// HDAudio codec transfer complete callback function
//
typedef VOID (*PHDAUDIO_TRANSFER_COMPLETE_CALLBACK)(HDAUDIO_CODEC_TRANSFER *, PVOID);

//
// HDAudio unsolicited response callback function
//
typedef VOID (*PHDAUDIO_UNSOLICITED_RESPONSE_CALLBACK)(HDAUDIO_CODEC_RESPONSE, PVOID);

//
// HDAudio device information structure
//
typedef struct _HDAUDIO_DEVICE_INFORMATION
{
  USHORT  Size;                 // size of this structure
  USHORT  DeviceVersion;        // maj.min (maj is high byte, min is low byte)
  USHORT  DriverVersion;        // maj.min (maj is high byte, min is low byte)
  USHORT  CodecsDetected;       // mask of codecs present. Bit number == SDI line number
  BOOLEAN IsStripingSupported;  // TRUE if striping (2 SDO lines) is supported
} HDAUDIO_DEVICE_INFORMATION, *PHDAUDIO_DEVICE_INFORMATION;

//
// HDAudio Buffer Descriptor list entry
//
typedef struct _HDAUDIO_BUFFER_DESCRIPTOR
{
  PHYSICAL_ADDRESS  Address;
  ULONG             Length;
  ULONG             InterruptOnCompletion;
} HDAUDIO_BUFFER_DESCRIPTOR, *PHDAUDIO_BUFFER_DESCRIPTOR;


typedef NTSTATUS (*PTRANSFER_CODEC_VERBS) (IN PVOID _context, IN ULONG Count, IN OUT PHDAUDIO_CODEC_TRANSFER CodecTransfer, IN PHDAUDIO_TRANSFER_COMPLETE_CALLBACK Callback, IN PVOID Context);
typedef NTSTATUS (*PALLOCATE_CAPTURE_DMA_ENGINE) (IN PVOID _context, IN UCHAR CodecAddress, IN PHDAUDIO_STREAM_FORMAT StreamFormat, OUT PHANDLE Handle, OUT PHDAUDIO_CONVERTER_FORMAT ConverterFormat);
typedef NTSTATUS (*PALLOCATE_RENDER_DMA_ENGINE) (IN PVOID _context, IN PHDAUDIO_STREAM_FORMAT StreamFormat, IN BOOLEAN Stripe, OUT PHANDLE Handle, OUT PHDAUDIO_CONVERTER_FORMAT ConverterFormat);
typedef NTSTATUS (*PCHANGE_BANDWIDTH_ALLOCATION) (IN PVOID _context, IN HANDLE Handle, IN PHDAUDIO_STREAM_FORMAT StreamFormat, OUT PHDAUDIO_CONVERTER_FORMAT ConverterFormat);
typedef NTSTATUS (*PALLOCATE_DMA_BUFFER) (IN PVOID _context, IN HANDLE Handle, IN SIZE_T RequestedBufferSize, OUT PMDL *BufferMdl, OUT PSIZE_T AllocatedBufferSize, OUT PUCHAR StreamId, OUT PULONG FifoSize);
typedef NTSTATUS (*PFREE_DMA_BUFFER) (IN PVOID _context, IN HANDLE Handle);
typedef NTSTATUS (*PFREE_DMA_ENGINE) (IN PVOID _context, IN HANDLE Handle);
typedef NTSTATUS (*PSET_DMA_ENGINE_STATE) (IN PVOID _context, IN HDAUDIO_STREAM_STATE StreamState, IN ULONG NumberOfHandles, IN PHANDLE Handles);
typedef VOID     (*PGET_WALL_CLOCK_REGISTER) (IN PVOID _context, OUT PULONG *Wallclock);
typedef NTSTATUS (*PGET_LINK_POSITION_REGISTER) (IN PVOID _context, IN HANDLE Handle, OUT PULONG *Position);
typedef NTSTATUS (*PREGISTER_EVENT_CALLBACK) (IN PVOID _context, IN PHDAUDIO_UNSOLICITED_RESPONSE_CALLBACK Routine, IN PVOID Context, OUT PUCHAR Tag);
typedef NTSTATUS (*PUNREGISTER_EVENT_CALLBACK) (IN PVOID _context, IN UCHAR Tag);
typedef NTSTATUS (*PGET_DEVICE_INFORMATION) (IN PVOID _context, IN OUT PHDAUDIO_DEVICE_INFORMATION DeviceInformation);
typedef VOID     (*PGET_RESOURCE_INFORMATION) (IN PVOID _context, OUT PUCHAR CodecAddress, OUT PUCHAR FunctionGroupStartNode);

typedef struct _HDAUDIO_BUS_INTERFACE
{
  //
  // First we define the standard INTERFACE structure ...
  //
  USHORT                    Size;
  USHORT                    Version;
  PVOID                     Context;
  PINTERFACE_REFERENCE      InterfaceReference;
  PINTERFACE_DEREFERENCE    InterfaceDereference;

  //
  // Then we expand the structure with our interface specific data
  //
  PTRANSFER_CODEC_VERBS           TransferCodecVerbs;
  PALLOCATE_CAPTURE_DMA_ENGINE    AllocateCaptureDmaEngine;
  PALLOCATE_RENDER_DMA_ENGINE     AllocateRenderDmaEngine;
  PCHANGE_BANDWIDTH_ALLOCATION    ChangeBandwidthAllocation;
  PALLOCATE_DMA_BUFFER            AllocateDmaBuffer;
  PFREE_DMA_BUFFER                FreeDmaBuffer;
  PFREE_DMA_ENGINE                FreeDmaEngine;
  PSET_DMA_ENGINE_STATE           SetDmaEngineState;
  PGET_WALL_CLOCK_REGISTER        GetWallClockRegister;
  PGET_LINK_POSITION_REGISTER     GetLinkPositionRegister;
  PREGISTER_EVENT_CALLBACK        RegisterEventCallback;
  PUNREGISTER_EVENT_CALLBACK      UnregisterEventCallback;
  PGET_DEVICE_INFORMATION         GetDeviceInformation;
  PGET_RESOURCE_INFORMATION       GetResourceInformation;
} HDAUDIO_BUS_INTERFACE, *PHDAUDIO_BUS_INTERFACE;

//
// To support the Bdl interface...
//
//
// ISR Callback definition for Bdl interface
//
typedef void (*PHDAUDIO_BDL_ISR) (IN VOID *Context, IN ULONG InterruptBitMask); 

//
// Additional BDL interface functions.
//
typedef NTSTATUS (*PALLOCATE_CONTIGUOUS_DMA_BUFFER) (IN PVOID _context, IN HANDLE Handle,
  ULONG RequestedBufferSize, OUT PVOID *DataBuffer, OUT PHDAUDIO_BUFFER_DESCRIPTOR *BdlBuffer);
typedef NTSTATUS (*PFREE_CONTIGUOUS_DMA_BUFFER) (IN PVOID _context, IN HANDLE Handle);
typedef NTSTATUS (*PSETUP_DMA_ENGINE_WITH_BDL) (IN PVOID _context, IN HANDLE Handle, IN ULONG BufferLength,
  IN ULONG Lvi, IN PHDAUDIO_BDL_ISR Isr, IN PVOID Context, OUT PUCHAR StreamId, OUT PULONG FifoSize);

typedef struct _HDAUDIO_BUS_INTERFACE_BDL
{
  //
  // First we define the standard INTERFACE structure ...
  //
  USHORT                    Size;
  USHORT                    Version;
  PVOID                     Context;
  PINTERFACE_REFERENCE      InterfaceReference;
  PINTERFACE_DEREFERENCE    InterfaceDereference;

  //
  // Then we expand the structure with the HDAUDIO_BUS_INTERFACE_BDL stuff.
  // Many functions are identical (and derived) from the HDAUDIO_BUS_INTERFACE
  // interface. PrepareDmaEngineWithBdl was added instead of PrepareDmaEngine
  // and GetDeviceInformationBdl instead of GetDeviceInformation.
  //
  PTRANSFER_CODEC_VERBS           TransferCodecVerbs;
  PALLOCATE_CAPTURE_DMA_ENGINE    AllocateCaptureDmaEngine;
  PALLOCATE_RENDER_DMA_ENGINE     AllocateRenderDmaEngine;
  PCHANGE_BANDWIDTH_ALLOCATION    ChangeBandwidthAllocation;
  PALLOCATE_CONTIGUOUS_DMA_BUFFER AllocateContiguousDmaBuffer;
  PSETUP_DMA_ENGINE_WITH_BDL      SetupDmaEngineWithBdl;
  PFREE_CONTIGUOUS_DMA_BUFFER     FreeContiguousDmaBuffer;
  PFREE_DMA_ENGINE                FreeDmaEngine;
  PSET_DMA_ENGINE_STATE           SetDmaEngineState;
  PGET_WALL_CLOCK_REGISTER        GetWallClockRegister;
  PGET_LINK_POSITION_REGISTER     GetLinkPositionRegister;
  PREGISTER_EVENT_CALLBACK        RegisterEventCallback;
  PUNREGISTER_EVENT_CALLBACK      UnregisterEventCallback;
  PGET_DEVICE_INFORMATION         GetDeviceInformation;
  PGET_RESOURCE_INFORMATION       GetResourceInformation;
} HDAUDIO_BUS_INTERFACE_BDL, *PHDAUDIO_BUS_INTERFACE_BDL;

//
// Additional interface functions for DMA notification support
//
typedef NTSTATUS (*PALLOCATE_DMA_BUFFER_WITH_NOTIFICATION) (IN PVOID _context,
                                                            IN HANDLE Handle, 
                                                            IN ULONG NotificationCount,
                                                            IN SIZE_T RequestedBufferSize,
                                                            OUT PMDL *BufferMdl,
                                                            OUT PSIZE_T AllocatedBufferSize,
                                                            OUT PSIZE_T OffsetFromFirstPage,
                                                            OUT PUCHAR StreamId,
                                                            OUT PULONG FifoSize);

typedef NTSTATUS (*PFREE_DMA_BUFFER_WITH_NOTIFICATION) (IN PVOID _context,
                                                        IN HANDLE Handle,
                                                        IN PMDL BufferMdl,
                                                        IN SIZE_T BufferSize);

typedef NTSTATUS (*PREGISTER_NOTIFICATION_EVENT) (IN PVOID _context,
                                                  IN HANDLE Handle,
                                                  IN PKEVENT NotificationEvent);

typedef NTSTATUS (*PUNREGISTER_NOTIFICATION_EVENT) (IN PVOID _context,
                                                    IN HANDLE Handle,
                                                    IN PKEVENT NotificationEvent);

typedef struct _HDAUDIO_BUS_INTERFACE_V2
{
    //
    // First we define the standard INTERFACE structure ...
    //
    USHORT                    Size;
    USHORT                    Version;
    PVOID                     Context;
    PINTERFACE_REFERENCE      InterfaceReference;
    PINTERFACE_DEREFERENCE    InterfaceDereference;

    //
    // Then we expand the structure with the HDAUDIO_BUS_INTERFACE_PING_PONG stuff.
    // Many functions are identical (and derived) from the HDAUDIO_BUS_INTERFACE
    // interface. 

    PTRANSFER_CODEC_VERBS           TransferCodecVerbs;
    PALLOCATE_CAPTURE_DMA_ENGINE    AllocateCaptureDmaEngine;
    PALLOCATE_RENDER_DMA_ENGINE     AllocateRenderDmaEngine;
    PCHANGE_BANDWIDTH_ALLOCATION    ChangeBandwidthAllocation;
    PALLOCATE_DMA_BUFFER            AllocateDmaBuffer;
    PFREE_DMA_BUFFER                FreeDmaBuffer;
    PFREE_DMA_ENGINE                FreeDmaEngine;
    PSET_DMA_ENGINE_STATE           SetDmaEngineState;
    PGET_WALL_CLOCK_REGISTER        GetWallClockRegister;
    PGET_LINK_POSITION_REGISTER     GetLinkPositionRegister;
    PREGISTER_EVENT_CALLBACK        RegisterEventCallback;
    PUNREGISTER_EVENT_CALLBACK      UnregisterEventCallback;
    PGET_DEVICE_INFORMATION         GetDeviceInformation;
    PGET_RESOURCE_INFORMATION       GetResourceInformation;
    PALLOCATE_DMA_BUFFER_WITH_NOTIFICATION AllocateDmaBufferWithNotification;
    PFREE_DMA_BUFFER_WITH_NOTIFICATION FreeDmaBufferWithNotification;
    PREGISTER_NOTIFICATION_EVENT    RegisterNotificationEvent;
    PUNREGISTER_NOTIFICATION_EVENT  UnregisterNotificationEvent;
} HDAUDIO_BUS_INTERFACE_V2, *PHDAUDIO_BUS_INTERFACE_V2;

#pragma warning(default:4201)
#pragma warning(default:4214)

#endif  // _HDAUDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\fsctlbuf.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtlBuf.h

Abstract:

    This module defines routines that get the buffers for the various types of ioctl/fsctls. It is essntially
    just the reverse of the IopXXXControlFile routine in io\internal.c, the appropriate parts of which are
    reproduced here.

Author:
Revision History:

--*/

#ifndef _fsctlbuf_
#define _fsctlbuf_

// the presentation here is in three pieces: the macros for METHODBUFFERED, METHODDIRECT, AND METHODNEITHER.
// it's set up this way so that you can find out what you've got just by reading this and not looking thru
// IO system....

/*  here is the code for case 0
    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //

        try {

            if (InputBufferLength || OutputBufferLength) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType,
                                    (InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength );

                if (ARGUMENT_PRESENT( InputBuffer )) {
                    RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                                   InputBuffer,
                                   InputBufferLength );
                }
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
                irp->UserBuffer = OutputBuffer;
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    irp->Flags |= IRP_INPUT_OPERATION;
                }
            } else {
                irp->Flags = 0;
                irp->UserBuffer = (PVOID) NULL;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
              <<<elided>>>
        }

        break;

So, the bottom line is that irp->AssociatedIrp.SystemBuffer is a buffer of length (I-length+O-length) and
is preloaded with the input. Even though the original outputbuffer is passed thru in irp->UserBuffer, it is not to be used
in the FS; rather the FS writes its answer into the same buffer.  we get the
following macros:

*/
#define METHODBUFFERED_SharedBuffer(IRP)     (IRP)->AssociatedIrp.SystemBuffer


/* for 1 and 2

    case 1:
    case 2:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that the buffer length parameters have been jammed to zero for
        // users if the buffer parameter was not passed.  (Kernel callers
        // should be calling the service correctly in the first place.)
        //
        // Note also that it doesn't make a whole lot of sense to specify
        // either method #1 or #2 if the IOCTL does not require the caller
        // to specify an output buffer.
        //

        try {

            if (InputBufferLength && ARGUMENT_PRESENT( InputBuffer )) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType, InputBufferLength );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = 0;
            }

            if (OutputBufferLength != 0) {
                irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                                 OutputBufferLength,
                                                 FALSE,
                                                 TRUE,
                                                 irp  );
                if (irp->MdlAddress == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( irp->MdlAddress,
                                     requestorMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            <<<ELIDED>>>
        }

        break;

So the deal is that the input buffer has been copied in as in case 0 but what we have is an MDL for
the output buffer. this leads to the following
*/


#define METHODDIRECT_BufferedInputBuffer(IRP)   ((IRP)->AssociatedIrp.SystemBuffer)
#define METHODDIRECT_DirectBuffer(IRP)  (((IRP)->MdlAddress) \
                                                 ? MmGetSystemAddressForMdlSafe((IRP)->MdlAddress,NormalPagePriority):NULL)

/* and finally
    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

So we can get 'em.....but we don't really know how they're gonna be used. Nevertheless.......
*/

#define METHODNEITHER_OriginalInputBuffer(IRPSP)   ((IRPSP)->Parameters.DeviceIoControl.Type3InputBuffer)
#define METHODNEITHER_OriginalOutputBuffer(IRP)    ((IRP)->UserBuffer)


#endif    // _fsctlbuf_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtlBuf.h

Abstract:

    This module defines routines that get the buffers for the various types of ioctl/fsctls. It is essntially
    just the reverse of the IopXXXControlFile routine in io\internal.c, the appropriate parts of which are
    reproduced here.

Author:
Revision History:

--*/

#ifndef _fsctlbuf_
#define _fsctlbuf_

// the presentation here is in three pieces: the macros for METHODBUFFERED, METHODDIRECT, AND METHODNEITHER.
// it's set up this way so that you can find out what you've got just by reading this and not looking thru
// IO system....

/*  here is the code for case 0
    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //

        try {

            if (InputBufferLength || OutputBufferLength) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType,
                                    (InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength );

                if (ARGUMENT_PRESENT( InputBuffer )) {
                    RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                                   InputBuffer,
                                   InputBufferLength );
                }
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
                irp->UserBuffer = OutputBuffer;
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    irp->Flags |= IRP_INPUT_OPERATION;
                }
            } else {
                irp->Flags = 0;
                irp->UserBuffer = (PVOID) NULL;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
              <<<elided>>>
        }

        break;

So, the bottom line is that irp->AssociatedIrp.SystemBuffer is a buffer of length (I-length+O-length) and
is preloaded with the input. Even though the original outputbuffer is passed thru in irp->UserBuffer, it is not to be used
in the FS; rather the FS writes its answer into the same buffer.  we get the
following macros:

*/
#define METHODBUFFERED_SharedBuffer(IRP)     (IRP)->AssociatedIrp.SystemBuffer


/* for 1 and 2

    case 1:
    case 2:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that the buffer length parameters have been jammed to zero for
        // users if the buffer parameter was not passed.  (Kernel callers
        // should be calling the service correctly in the first place.)
        //
        // Note also that it doesn't make a whole lot of sense to specify
        // either method #1 or #2 if the IOCTL does not require the caller
        // to specify an output buffer.
        //

        try {

            if (InputBufferLength && ARGUMENT_PRESENT( InputBuffer )) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType, InputBufferLength );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = 0;
            }

            if (OutputBufferLength != 0) {
                irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                                 OutputBufferLength,
                                                 FALSE,
                                                 TRUE,
                                                 irp  );
                if (irp->MdlAddress == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( irp->MdlAddress,
                                     requestorMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            <<<ELIDED>>>
        }

        break;

So the deal is that the input buffer has been copied in as in case 0 but what we have is an MDL for
the output buffer. this leads to the following
*/


#define METHODDIRECT_BufferedInputBuffer(IRP)   ((IRP)->AssociatedIrp.SystemBuffer)
#define METHODDIRECT_DirectBuffer(IRP)  (((IRP)->MdlAddress) \
                                                 ? MmGetSystemAddressForMdlSafe((IRP)->MdlAddress,NormalPagePriority):NULL)

/* and finally
    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

So we can get 'em.....but we don't really know how they're gonna be used. Nevertheless.......
*/

#define METHODNEITHER_OriginalInputBuffer(IRPSP)   ((IRPSP)->Parameters.DeviceIoControl.Type3InputBuffer)
#define METHODNEITHER_OriginalOutputBuffer(IRP)    ((IRP)->UserBuffer)


#endif    // _fsctlbuf_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtlBuf.h

Abstract:

    This module defines routines that get the buffers for the various types of ioctl/fsctls. It is essntially
    just the reverse of the IopXXXControlFile routine in io\internal.c, the appropriate parts of which are
    reproduced here.

Author:
Revision History:

--*/

#ifndef _fsctlbuf_
#define _fsctlbuf_

// the presentation here is in three pieces: the macros for METHODBUFFERED, METHODDIRECT, AND METHODNEITHER.
// it's set up this way so that you can find out what you've got just by reading this and not looking thru
// IO system....

/*  here is the code for case 0
    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //

        try {

            if (InputBufferLength || OutputBufferLength) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType,
                                    (InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength );

                if (ARGUMENT_PRESENT( InputBuffer )) {
                    RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                                   InputBuffer,
                                   InputBufferLength );
                }
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
                irp->UserBuffer = OutputBuffer;
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    irp->Flags |= IRP_INPUT_OPERATION;
                }
            } else {
                irp->Flags = 0;
                irp->UserBuffer = (PVOID) NULL;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
              <<<elided>>>
        }

        break;

So, the bottom line is that irp->AssociatedIrp.SystemBuffer is a buffer of length (I-length+O-length) and
is preloaded with the input. Even though the original outputbuffer is passed thru in irp->UserBuffer, it is not to be used
in the FS; rather the FS writes its answer into the same buffer.  we get the
following macros:

*/
#define METHODBUFFERED_SharedBuffer(IRP)     (IRP)->AssociatedIrp.SystemBuffer


/* for 1 and 2

    case 1:
    case 2:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that the buffer length parameters have been jammed to zero for
        // users if the buffer parameter was not passed.  (Kernel callers
        // should be calling the service correctly in the first place.)
        //
        // Note also that it doesn't make a whole lot of sense to specify
        // either method #1 or #2 if the IOCTL does not require the caller
        // to specify an output buffer.
        //

        try {

            if (InputBufferLength && ARGUMENT_PRESENT( InputBuffer )) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType, InputBufferLength );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = 0;
            }

            if (OutputBufferLength != 0) {
                irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                                 OutputBufferLength,
                                                 FALSE,
                                                 TRUE,
                                                 irp  );
                if (irp->MdlAddress == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( irp->MdlAddress,
                                     requestorMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            <<<ELIDED>>>
        }

        break;

So the deal is that the input buffer has been copied in as in case 0 but what we have is an MDL for
the output buffer. this leads to the following
*/


#define METHODDIRECT_BufferedInputBuffer(IRP)   ((IRP)->AssociatedIrp.SystemBuffer)
#define METHODDIRECT_DirectBuffer(IRP)  (((IRP)->MdlAddress) \
                                                 ? MmGetSystemAddressForMdlSafe((IRP)->MdlAddress,NormalPagePriority):NULL)

/* and finally
    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

So we can get 'em.....but we don't really know how they're gonna be used. Nevertheless.......
*/

#define METHODNEITHER_OriginalInputBuffer(IRPSP)   ((IRPSP)->Parameters.DeviceIoControl.Type3InputBuffer)
#define METHODNEITHER_OriginalOutputBuffer(IRP)    ((IRP)->UserBuffer)


#endif    // _fsctlbuf_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hidclass.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    hidclass.h

Abstract

    Definitions that are common to clients of the HID class driver.

Environment:

    Kernel mode only

Revision History:


--*/

#include <basetyps.h>

//
//  Define the HID class guid *OUTSIDE* the #ifndef/#endif to allow
//  multiple includes with precompiled headers.
//
DEFINE_GUID( GUID_DEVINTERFACE_HID, 0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, \
             0x11, 0x11, 0x00, 0x00, 0x30);
// Obsolete GUID naming convention.
#define GUID_CLASS_INPUT GUID_DEVINTERFACE_HID

//
// 2c4e2e88-25e6-4c33-882f-3d82e6073681
//
DEFINE_GUID( GUID_HID_INTERFACE_NOTIFY, 0x2c4e2e88L, 0x25e6, 0x4c33, 0x88, 0x2f, 0x3d, 0x82, 0xe6, 0x07, 0x36, 0x81 );

// {F5C315A5-69AC-4bc2-9279-D0B64576F44B}
DEFINE_GUID( GUID_HID_INTERFACE_HIDPARSE, 0xf5c315a5, 0x69ac, 0x4bc2, 0x92, 0x79, 0xd0, 0xb6, 0x45, 0x76, 0xf4, 0x4b );


#ifndef __HIDCLASS_H__
#define __HIDCLASS_H__


#define GUID_CLASS_INPUT_STR "4D1E55B2-F16F-11CF-88CB-001111000030"

//
// HID_REVISION specifies the minimum revision of HIDCLASS.SYS
// required to support minidrivers compiled with this header file.
//
#define HID_REVISION    0x00000001

//
// Macro for defining HID ioctls
//
#define HID_CTL_CODE(id)    \
    CTL_CODE(FILE_DEVICE_KEYBOARD, (id), METHOD_NEITHER, FILE_ANY_ACCESS)
#define HID_BUFFER_CTL_CODE(id)  \
    CTL_CODE(FILE_DEVICE_KEYBOARD, (id), METHOD_BUFFERED, FILE_ANY_ACCESS)
#define HID_IN_CTL_CODE(id)  \
    CTL_CODE(FILE_DEVICE_KEYBOARD, (id), METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define HID_OUT_CTL_CODE(id)  \
    CTL_CODE(FILE_DEVICE_KEYBOARD, (id), METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

//
// IOCTLs supported by the upper edge of the HID class driver
//

#define IOCTL_HID_GET_DRIVER_CONFIG             HID_BUFFER_CTL_CODE(100)
#define IOCTL_HID_SET_DRIVER_CONFIG             HID_BUFFER_CTL_CODE(101)
#define IOCTL_HID_GET_POLL_FREQUENCY_MSEC       HID_BUFFER_CTL_CODE(102)
#define IOCTL_HID_SET_POLL_FREQUENCY_MSEC       HID_BUFFER_CTL_CODE(103)
#define IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS      HID_BUFFER_CTL_CODE(104)
#define IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS      HID_BUFFER_CTL_CODE(105)
#define IOCTL_HID_GET_COLLECTION_INFORMATION    HID_BUFFER_CTL_CODE(106)

#define IOCTL_HID_GET_COLLECTION_DESCRIPTOR     HID_CTL_CODE(100)
#define IOCTL_HID_FLUSH_QUEUE                   HID_CTL_CODE(101)

#define IOCTL_HID_SET_FEATURE                   HID_IN_CTL_CODE(100)
#if (NTDDI_VERSION >= NTDDI_WINXP) 
#define IOCTL_HID_SET_OUTPUT_REPORT             HID_IN_CTL_CODE(101)
#endif

#define IOCTL_HID_GET_FEATURE                   HID_OUT_CTL_CODE(100)
#define IOCTL_GET_PHYSICAL_DESCRIPTOR           HID_OUT_CTL_CODE(102)
#define IOCTL_HID_GET_HARDWARE_ID               HID_OUT_CTL_CODE(103)
#if (NTDDI_VERSION >= NTDDI_WINXP) 
#define IOCTL_HID_GET_INPUT_REPORT              HID_OUT_CTL_CODE(104)
#endif

/*
 *  No more IOCTL_HID_GET_FRIENDLY_NAME - use one of the following:
 */
#define IOCTL_HID_GET_MANUFACTURER_STRING       HID_OUT_CTL_CODE(110)
#define IOCTL_HID_GET_PRODUCT_STRING            HID_OUT_CTL_CODE(111)
#define IOCTL_HID_GET_SERIALNUMBER_STRING       HID_OUT_CTL_CODE(112)

#define IOCTL_HID_GET_INDEXED_STRING            HID_OUT_CTL_CODE(120)
#if (NTDDI_VERSION >= NTDDI_WINXP) 
#define IOCTL_HID_GET_MS_GENRE_DESCRIPTOR       HID_OUT_CTL_CODE(121)

#define IOCTL_HID_ENABLE_SECURE_READ 	  	HID_CTL_CODE(130)      
#define IOCTL_HID_DISABLE_SECURE_READ		HID_CTL_CODE(131)
#endif

/*
 *  This is used to pass write-report and feature-report information
 *  from HIDCLASS to a minidriver.
 */
typedef struct _HID_XFER_PACKET {
    PUCHAR  reportBuffer;
    ULONG   reportBufferLen;
    UCHAR   reportId;
} HID_XFER_PACKET, *PHID_XFER_PACKET;

#ifdef NT_INCLUDED

enum DeviceObjectState {
    DeviceObjectStarted,
    DeviceObjectStopped,
    DeviceObjectRemoved
};

typedef VOID (*PHID_STATUS_CHANGE)(PVOID Context, enum DeviceObjectState State);

typedef struct _HID_INTERFACE_NOTIFY_PNP
{
#ifndef __cplusplus
    INTERFACE;
#else
    INTERFACE i;
#endif
    PHID_STATUS_CHANGE StatusChangeFn;
    PVOID CallbackContext;
} HID_INTERFACE_NOTIFY_PNP, *PHID_INTERFACE_NOTIFY_PNP;


#ifdef __HIDPI_H__

typedef NTSTATUS (__stdcall *PHIDP_GETCAPS) (IN PHIDP_PREPARSED_DATA PreparsedData, OUT PHIDP_CAPS Capabilities);

typedef struct _HID_INTERFACE_HIDPARSE
{
#ifndef __cplusplus
    INTERFACE;
#else
    INTERFACE i;
#endif
    PHIDP_GETCAPS HidpGetCaps;
} HID_INTERFACE_HIDPARSE, *PHID_INTERFACE_HIDPARSE;

#endif // __HIDPI_H__

#endif // NT_INCLUDED

//
// Structure passed by IOCTL_HID_GET_COLLECTION_INFORMATION
//

typedef struct _HID_COLLECTION_INFORMATION {

    //
    // DescriptorSize is the size of the input buffer required to accept
    // the collection descriptor returned by
    // IOCTL_HID_GET_COLLECTION_DESCRIPTOR.
    //

    ULONG   DescriptorSize;

    //
    // Polled is TRUE if this collection is a polled collection.
    //

    BOOLEAN Polled;

    //
    // Reserved1 must be set to zero.
    //

    UCHAR   Reserved1[ 1 ];

    //
    // Vendor ids of this hid device
    //
    USHORT  VendorID;
    USHORT  ProductID;
    USHORT  VersionNumber;

    //
    // Additional fields, if any, will be added at the end of this structure.
    //

} HID_COLLECTION_INFORMATION, *PHID_COLLECTION_INFORMATION;

//
// Structure passed by IOCTL_HID_GET_DRIVER_CONFIG and
// IOCTL_HID_SET_DRIVER_CONFIG
//

typedef struct _HID_DRIVER_CONFIG {

    //
    // Size must be set to the size of this structure.
    //

    ULONG   Size;

    //
    // Size of the input report queue (in reports).  This value can be set.
    //

    ULONG   RingBufferSize;

} HID_DRIVER_CONFIG, *PHID_DRIVER_CONFIG;

#endif  // __HIDCLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hidpddi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    HIDPDDI.H

Abstract:

    This module contains the PUBLIC definitions for the
    code that implements the driver side of the parsing library.

Environment:

    Kernel mode

--*/

#ifndef _HIDPDDI_H
#define _HIDPDDI_H

#include "hidusage.h"
#include "hidpi.h"


typedef struct _HIDP_COLLECTION_DESC
{
   USAGE       UsagePage;
   USAGE       Usage;

   UCHAR       CollectionNumber;
   UCHAR       Reserved [15]; // Must be zero

   USHORT      InputLength;
   USHORT      OutputLength;
   USHORT      FeatureLength;
   USHORT      PreparsedDataLength;

   PHIDP_PREPARSED_DATA             PreparsedData;
} HIDP_COLLECTION_DESC, *PHIDP_COLLECTION_DESC;

typedef struct _HIDP_REPORT_IDS
{
   UCHAR             ReportID;
   UCHAR             CollectionNumber;
   USHORT            InputLength;
   USHORT            OutputLength;
   USHORT            FeatureLength;
} HIDP_REPORT_IDS, *PHIDP_REPORT_IDS;

typedef struct _HIDP_GETCOLDESC_DBG
{
   ULONG    BreakOffset;
   ULONG    ErrorCode;
   ULONG    Args[6];
} HIDP_GETCOLDESC_DBG, *PHIDP_GETCOLDESC_DBG;

typedef struct _HIDP_DEVICE_DESC
{
   PHIDP_COLLECTION_DESC    CollectionDesc; // Array allocated By Parser
   ULONG                    CollectionDescLength;
   PHIDP_REPORT_IDS         ReportIDs; // Array allocated By Parsre
   ULONG                    ReportIDsLength;
   HIDP_GETCOLDESC_DBG      Dbg;
} HIDP_DEVICE_DESC, *PHIDP_DEVICE_DESC;

NTSTATUS
HidP_GetCollectionDescription (
   IN  PHIDP_REPORT_DESCRIPTOR   ReportDesc,
   IN  ULONG                     DescLength,
   IN  POOL_TYPE                 PoolType,
   OUT PHIDP_DEVICE_DESC         DeviceDescription
   );
/*++
Routine Description:
    Given a RAW report descriptor, this function fills in the DeviceDescription
    block with a linked list of collection descriptors and the corresponding 
    report ID information that is described by the given report descriptor. 
    The memory for the collection information and the ReportID information is
    allocated from PoolType.

Arguments:
   ReportDesc            the raw report descriptor.
   DescLength            the length of the report descriptor.
   PoolType              pool type from which to allocate the linked lists
   DeviceDescription     device description block that will be filled in
                         with the above lists

Return Value:
  STATUS_SUCCESS                   -- if there were no errors which parsing
                                      the report descriptor and allocating the
                                      memory blocks necessary to describe the
                                      device.
  STATUS_NO_DATA_DETECTED          -- if there were no top-level collections
                                      in the report descriptor
  STATUS_COULD_NOT_INTERPRET       -- if an error was detected in the report 
                                      descriptor. see the error code as set in
                                      Dbg field of the device description block
                                      for more information on the parsing error
  STATUS_BUFFER_TOO_SMALL          -- if while parsing an item, the function
                                      hits the end of the report descriptor
                                      when it expects more data to exist
  STATUS_INSUFFICIENT_RESOURCES    -- if a memory allocation failed 
  STATUS_ILLEGAL_INSTRUCTION       -- if there is an item in the report 
                                      descriptor that is not recognized 
                                      by the parser
  HIDP_STATUS_INVALID_REPORT_TYPE  -- if a report ID of zero was found in the
                                      descriptor
--*/

VOID
HidP_FreeCollectionDescription (
    IN  PHIDP_DEVICE_DESC   DeviceDescription
    );
/*++
Routine Description:
    This function frees the resources in DeviceDescription that were 
    allocated by HidP_GetCollectionDescription.  It does not, however,
    free the the DeviceDescription block itself.

Arguments:
   DeviceDescription        HIDP_DEVICE_DESC block that was previously filled
                            in by a call to HidP_GetCollectionDescription
--*/

//
// HIDP_POWER_EVENT is an entry point into hidparse.sys that will answer the
// Power iocontrol "IOCTL_GET_SYS_BUTTON_EVENT".
//
// HidPacket is the from the device AFTER modifying to add the
// obligatory report ID.  Remember that in order to use this parser the data
// from the device must be formated such that if the device does not return a
// report ID as the first byte that the report is appended to a report id byte
// of zero.
//
NTSTATUS
HidP_SysPowerEvent (
    __in_bcount(HidPacketLength) PCHAR HidPacket,
    __in USHORT HidPacketLength,
    __in PHIDP_PREPARSED_DATA Ppd,
    __out PULONG OutputBuffer
    );

//
// HIDP_POWER_CAPS answers IOCTL_GET_SYS_POWER_BUTTON_CAPS
//
NTSTATUS
HidP_SysPowerCaps (
    IN  PHIDP_PREPARSED_DATA    Ppd,
    OUT PULONG                  OutputBuffer
    );


#define HIDP_GETCOLDESC_SUCCESS              0x00
#define HIDP_GETCOLDESC_RESOURCES            0x01
// Insufficient resources to allocate needed memory.

#define HIDP_GETCOLDESC_BUFFER               0x02
#define HIDP_GETCOLDESC_LINK_RESOURCES       0x03
#define HIDP_GETCOLDESC_UNEXP_END_COL        0x04 
// An extra end collection token was found.

#define HIDP_GETCOLDESC_PREPARSE_RESOURCES   0x05
// Insufficient resources to allocate memory for preparsing.

#define HIDP_GETCOLDESC_ONE_BYTE             0x06
#define HIDP_GETCOLDESC_TWO_BYTE             0x07
#define HIDP_GETCOLDESC_FOUR_BYTE            0x08
// One two and four more byte were expected but not found.

#define HIDP_GETCOLDESC_BYTE_ALLIGN          0x09
// A given report was not byte aligned
// Args[0] -- Collection number of the offending collection
// Args[1] -- Report ID of offending report
// Args[2] -- Length (in bits) of the Input report for this ID
// Args[3] -- Length (in bits) of the Output report for this ID
// Args[4] -- Length (in bits) of the Feature report for this ID

#define HIDP_GETCOLDESC_MAIN_ITEM_NO_USAGE   0x0A
// A non constant main item was declaired without a corresponding usage.
// Only constant main items (used as padding) are allowed with no usage 

#define HIDP_GETCOLDESC_TOP_COLLECTION_USAGE 0x0B
// A top level collection (Arg[0]) was declared without a usage or with
//  more than one usage
// Args[0] -- Collection number of the offending collection

#define HIDP_GETCOLDESC_PUSH_RESOURCES       0x10
// Insufficient resources required to push more items to either the global
//  items stack or the usage stack

#define HIDP_GETCOLDESC_ITEM_UNKNOWN         0x12
// An unknown item was found in the report descriptor
// Args[0] -- The item value of the unknown item

#define HIDP_GETCOLDESC_REPORT_ID            0x13
// Report ID declaration found outside of top level collection. Report ID's
//  must be defined within the context of a top level collection
// Args[0] -- Report ID of the offending report

#define HIDP_GETCOLDESC_BAD_REPORT_ID        0x14
// A bad report ID value was found...Report IDs must be within the range
//  of 1-255

#define HIDP_GETCOLDESC_NO_REPORT_ID         0x15
// The parser discovered a top level collection in a complex device (more
// than one top level collection) that had no declared report ID or a 
// report ID spanned multiple collections
// Args[0] -- Collection number of the offending collection

#define HIDP_GETCOLDESC_DEFAULT_ID_ERROR     0x16
// The parser detected a condition where a main item was declared without 
//  a global report ID so the default report ID was used.  After this main
//  item declaration, the parser detected either another main item that had
//  an explicitly defined report ID or it detected a second top-level collection
//  The default report ID is only allowed for devices with one top-level
//  collection and don't have any report IDs explicitly declared.  
//
// The parser detects this error upon finding the second collection or upon
//  finding the main item declaration with the explicit report ID.  
//
//  Args[0] -- Contains the collection number being processed when the 
//             error was detected.

#define HIDP_GETCOLDESC_NO_DATA              0x1A
// No top level collections were found in this device.

#define HIDP_GETCOLDESC_INVALID_MAIN_ITEM    0x1B
// A main item was detected outside of a top level collection.

#define HIDP_GETCOLDESC_NO_CLOSE_DELIMITER   0x20
// A start delimiter token was found with no corresponding end delimiter

#define HIDP_GETCOLDESC_NOT_VALID_DELIMITER  0x21
// The parser detected a non-usage item with a delimiter declaration
// Args[0] -- item code for the offending item

#define HIDP_GETCOLDESC_MISMATCH_OC_DELIMITER   0x22
// The parser detected either a close delimiter without a corresponding open
//  delimiter or detected a nested open delimiter

#define HIDP_GETCOLDESC_UNSUPPORTED          0x40
// The given report descriptor was found to have a valid report descriptor
// containing a scenario that this parser does not support.
// For instance, declaring an ARRAY style main item with delimiters.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hbaapi.h ===
//***************************************************************************
//
//  hbaapi.h
// 
//  Module: Windows HBA API implmentation
//
//      This header is consistent with www.t11.org SM-HBA Draft Dec 2005
//
//  Purpose: Contains HBA api header
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#ifndef HBAAPI_H
#define HBAAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#define SM_HBA_API   // include SM-HBA specific functions

#include <time.h>

#ifdef _HBAAPIP_
#define HBA_API __cdecl
#else
#define HBA_API DECLSPEC_IMPORT __cdecl
#endif

#define HBA_VERSION   2

typedef ULONGLONG   HBA_UINT64;
typedef LONGLONG    HBA_INT64;
typedef ULONG       HBA_UINT32;
typedef USHORT      HBA_UINT16;
typedef UCHAR       HBA_UINT8;
typedef signed char HBA_INT8;

typedef HBA_UINT32 HBA_HANDLE;

typedef HBA_UINT32 HBA_STATUS;

#define HBA_STATUS_OK                        0

#define HBA_STATUS_ERROR                     1   /* Error */
#define HBA_STATUS_ERROR_NOT_SUPPORTED       2   /* Function not supported.*/
#define HBA_STATUS_ERROR_INVALID_HANDLE      3   /* invalid handle */
#define HBA_STATUS_ERROR_ARG                 4   /* Bad argument */
#define HBA_STATUS_ERROR_ILLEGAL_WWN         5   /* WWN not recognized */
#define HBA_STATUS_ERROR_ILLEGAL_INDEX       6   /* Index not recognized */
#define HBA_STATUS_ERROR_MORE_DATA           7   /* Larger buffer required */

/* Information has changed since the last call to HBA_RefreshInformation */
#define HBA_STATUS_ERROR_STALE_DATA          8  

/* SCSI Check Condition reported*/
#define HBA_STATUS_SCSI_CHECK_CONDITION      9

/* Adapter busy or reserved, retry may be effective*/
#define HBA_STATUS_ERROR_BUSY               10 

/* Request timed out, retry may be effective */
#define HBA_STATUS_ERROR_TRY_AGAIN          11 

/* Referenced HBA has been removed or deactivated */
#define HBA_STATUS_ERROR_UNAVAILABLE        12   

/* The requested ELS was rejected  by the local adapter */
#define HBA_STATUS_ERROR_ELS_REJECT         13   

/* The specified LUN is not provided  by the specified adapter */
#define HBA_STATUS_ERROR_INVALID_LUN        14   

/* An incompatibility has been detected among the library and driver modules */
/* invoked which will cause one or more functions in the highest version */ 
/* that all support to operate incorrectly.  */
/* The differing function sets of software modules implementing different */
/* versions of the HBA API specification does not in itself constitute an */
/* incompatibility. */
/* Known interoperability bugs among supposedly compatible versions */
/* should be reported as incompatibilities, */
/* but not all such interoperability bugs may be known. */
/* This value may be returned by any function which calls a */
/* Vendor Specific Library,  and by HBA_LoadLibrary and HBA_GetAdapterName. */

#define HBA_STATUS_ERROR_INCOMPATIBLE       15   


/* Multiple adapters have a matching WWN. */
/* This could occur if the NodeWWN of multiple adapters is identical. */
#define HBA_STATUS_ERROR_AMBIGUOUS_WWN      16   

/* A persistent binding request included a bad local SCSI bus number */
#define HBA_STATUS_ERROR_LOCAL_BUS          17   

/* A persistent binding request included a bad local SCSI target number */
#define HBA_STATUS_ERROR_LOCAL_TARGET       18   

/* A persistent binding request included a bad local SCSI logical unit number */
#define HBA_STATUS_ERROR_LOCAL_LUN          19   

/* A persistent binding set request included */
/* a local SCSI ID that was already bound */
#define HBA_STATUS_ERROR_LOCAL_SCSIID_BOUND 20   

/* A persistent binding request included a bad or unlocatable FCP Target FCID */
#define HBA_STATUS_ERROR_TARGET_FCID        21   

/* A persistent binding request included a bad FCP Target Node WWN */
#define HBA_STATUS_ERROR_TARGET_NODE_WWN    22   

/* A persistent binding request included a bad FCP Target Port WWN */
#define HBA_STATUS_ERROR_TARGET_PORT_WWN    23   

/* A persistent binding request included */
/* an FCP Logical Unit Number not defined by the identified Target*/
#define HBA_STATUS_ERROR_TARGET_LUN         24   

/* A persistent binding request included */
/* an undefined or otherwise inaccessible Logical Unit Unique Identifier */
#define HBA_STATUS_ERROR_TARGET_LUID        25   

/* A persistent binding remove request included */
/* a binding which did not match a binding established by the specified port */
#define HBA_STATUS_ERROR_NO_SUCH_BINDING    26 

/* A SCSI command was requested to an Nx_Port that was not a SCSI Target Port */
#define HBA_STATUS_ERROR_NOT_A_TARGET       27   

/* A request was made concerning an unsupported FC-4 protocol */
#define HBA_STATUS_ERROR_UNSUPPORTED_FC4    28   

/* A request was made to enable unimplemented capabilities for a port */
#define HBA_STATUS_ERROR_INCAPABLE          29 

/* A SCSI function was rejected to prevent causing */
/* a SCSI overlapped command condition (see SAM-3) */
#define HBA_STATUS_ERROR_TARGET_BUSY        30  

/* A call was made to HBA_FreeLibrary when no library was loaded */
#define HBA_STATUS_ERROR_NOT_LOADED         31   

/* A call was made to HBA_LoadLibrary when a library was already loaded */
#define HBA_STATUS_ERROR_ALREADY_LOADED     32

/* The Address Identifier specified in a call to HBA_SendRNIDV2 */
/* violates access control rules for that call */
#define HBA_STATUS_ERROR_ILLEGAL_FCID       33

#define HBA_STATUS_ERROR_NOT_ASCSIDEVICE    34

#define HBA_STATUS_ERROR_INVALID_PROTOCOL_TYPE 35

#define HBA_STATUS_ERROR_BAD_EVENT_TYPE     36


typedef HBA_UINT8  HBA_BOOLEAN;     /* Use this for a single true/false flag */

typedef HBA_UINT32 HBA_PORTTYPE;

#define HBA_PORTTYPE_UNKNOWN      1 /* Unknown */
#define HBA_PORTTYPE_OTHER        2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT   3 /* Not present */
#define HBA_PORTTYPE_NPORT        5 /* Fabric */
#define HBA_PORTTYPE_NLPORT       6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT       7 /* Fabric on a Loop */
#define HBA_PORTTYPE_FPORT        8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT        9 /* Fabric expansion port */ // obsolete?
#define HBA_PORTTYPE_GPORT       10 /* Generic Fabric Port */   // obsolete?
#define HBA_PORTTYPE_LPORT       20 /* Private Loop */
#define HBA_PORTTYPE_PTP         21 /* Point to Point */
#define HBA_PORTTYPE_SASDEVICE   30 /* SAS (SSP or STP) */
#define HBA_PORTTYPE_SATADEVICE  31 /* SATA Device, i.e. Direct Attach SATA */
#define HBA_PORTTYPE_SASEXPANDER 32 /* SAS Expander */

typedef HBA_UINT32 HBA_PORTSTATE;
#define HBA_PORTSTATE_UNKNOWN     1 /* Unknown */
#define HBA_PORTSTATE_ONLINE      2 /* Operational */
#define HBA_PORTSTATE_OFFLINE     3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED    4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS 5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN    6 /* Link Down */
#define HBA_PORTSTATE_ERROR       7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK    8 /* Loopback */
#define HBA_PORTSTATE_DEGRADED    9 /* Degraded, but Operational mode */

typedef HBA_UINT32 HBA_PORTSPEED;
typedef HBA_UINT32 HBA_FCPHYSPEED, HBA_SASPHYSPEED, HBA_PHYSPEED;

#define HBA_PORTSPEED_UNKNOWN     0    /* Unknown - transceiver incapable */
                                       /* of reporting */
#define HBA_PORTSPEED_1GBIT       1    /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT       2    /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT      4    /* 10 GBit/sec */
#define HBA_PORTSPEED_4GBIT       8    /* 4 GBit/sec */


#define HBA_FCSPEED_UNKNOWN       0    /* Unknown - transceiver incapable */
                                       /* of reporting */
#define HBA_FCPHYSPEED_8GBIT     16    /* 8 GBit/sec */
#define HBA_FCPHYSPEED_16GBIT    32    /* 16 GBit/sec */

#define HBA_PORTSPEED_NOT_NEGOTIATED (1 << 15) /* Speed not established */


typedef HBA_UINT8 HBA_FCPHYTYPE;

#define HBA_FCPHYTYPE_UNKNOWN     1    /* Unknown Phy type */
#define HBA_FCPHYTYPE_OPTICAL     2    /* Optical Phy */
#define HBA_FCPHYTYPE_COPPER      4    /* Copper Phy */


#define HBA_SASSTATE_UNKNOWN     0x00  /* Phy is enabled. Speed is unknown   */
#define HBA_SASSTATE_DISABLED    0x01  /* Phy is disabled. */

#define HBA_SASSTATE_FAILED      0x02  /* Phy is enabled. But failed speed   */
                                       /* negotiation. */

#define HBA_SASSTATE_SATASPINUP  0x03  /* Phy is enabled. Detected a SATA    */
                                       /* device and entered the SATA Spinup */
                                       /* hold state */

#define HBA_SASSTATE_SATAPORTSEL 0x04  /* The phy is attached to a */
                                       /* Port Selector (see SATA-2.5). */

#define HBA_SASSPEED_1_5GBIT     0x08  /* 1.5 GBit/sec */
#define HBA_SASSPEED_3GBIT       0x09  /* 3 GBit/sec   */


typedef struct HBA_wwn {
    HBA_UINT8 wwn[8];
} HBA_WWN, *PHBA_WWN;


typedef struct SMHBA_FC_Phy {
    HBA_FCPHYSPEED  PhySupportSpeed;   /* PhySupportedSpeed */
    HBA_FCPHYSPEED  PhySpeed;          /* PhySpeed */
    HBA_FCPHYTYPE   PhyType;          
    HBA_UINT32      MaxFrameSize;      /* MaxFrameSize */
} SMHBA_FC_PHY, *PSMHBA_FC_PHY;

typedef struct SMHBA_SAS_Phy {
    HBA_UINT8        PhyIdentifier;
    HBA_SASPHYSPEED  NegotiatedLinkRate;
    HBA_SASPHYSPEED  ProgrammedMinLinkRate;
    HBA_SASPHYSPEED  HardwareMinLinkRate;
    HBA_SASPHYSPEED  ProgrammedMaxLinkRate;
    HBA_SASPHYSPEED  HardwareMaxLinkRate;
    HBA_WWN          domainPortWWN;
} SMHBA_SAS_PHY, *PSMHBA_SAS_PHY;



typedef HBA_UINT32 HBA_COS;

typedef struct HBA_fc4types {
    HBA_UINT8 bits[32];     /* See FC-4 TYPEs - Format in FC-GS-4 */
} HBA_FC4TYPES, *PHBA_FC4TYPES;

typedef struct HBA_ipaddress {
    int ipversion; // see enumerations in RNID
    union
    {
        unsigned char ipv4address[4];
        unsigned char ipv6address[16];
    } ipaddress;
} HBA_IPADDRESS, *PHBA_IPADDRESS;

typedef struct HBA_AdapterAttributes {
    char       Manufacturer[64];      
    char       SerialNumber[64];     
    char       Model[256];          
    char       ModelDescription[256]; 
    HBA_WWN    NodeWWN;
    char       NodeSymbolicName[256]; /* From GS-2 */
    char       HardwareVersion[256];  /* Vendor use */
    char       DriverVersion[256];    /* Vendor use */
    char       OptionROMVersion[256]; /* Vendor use - i.e. hardware boot ROM*/
    char       FirmwareVersion[256];  /* Vendor use */
    HBA_UINT32 VendorSpecificID;      /* Vendor specific */
    HBA_UINT32 NumberOfPorts;
    char       DriverName[256];       /* Binary path and/or name of driver file. */
} HBA_ADAPTERATTRIBUTES, *PHBA_ADAPTERATTRIBUTES;


typedef struct SMHBA_AdapterAttributes {
    char       Manufacturer[64];      
    char       SerialNumber[64];      
    char       Model[256];            
    char       ModelDescription[256]; 
    char       HardwareVersion[256];  
    char       DriverVersion[256];    
    char       OptionROMVersion[256]; 
    char       FirmwareVersion[256];  
    HBA_UINT32 VendorSpecificID;      
    char       DriverName[256];      
    char       HBASymbolicName[256];
    char       RedundantOptionROMVersion[256]; 
    char       RedundantFirmwareVersion[256];  
} SMHBA_ADAPTERATTRIBUTES, *PSMHBA_ADAPTERATTRIBUTES;


typedef struct HBA_PortAttributes {
    HBA_WWN       NodeWWN;
    HBA_WWN       PortWWN;
    HBA_UINT32    PortFcId;
    HBA_PORTTYPE  PortType;            /*PTP, Fabric, etc. */
    HBA_PORTSTATE PortState;
    HBA_COS       PortSupportedClassofService;
    HBA_FC4TYPES  PortSupportedFc4Types;
    HBA_FC4TYPES  PortActiveFc4Types;
    char          PortSymbolicName[256];
    char          OSDeviceName[256];   
    HBA_PORTSPEED PortSupportedSpeed;
    HBA_PORTSPEED PortSpeed;
    HBA_UINT32    PortMaxFrameSize;
    HBA_WWN       FabricName;
    HBA_UINT32    NumberofDiscoveredPorts;
} HBA_PORTATTRIBUTES, *PHBA_PORTATTRIBUTES;


typedef HBA_UINT32 HBA_SASPORTPROTOCOL;

#define HBA_SASPORTPROTOCOL_SSP  1  /* Serial Attached SCSI Port */
#define HBA_SASPORTPROTOCOL_STP  2  /* Serial ATA Tunneling Protocol Port */
#define HBA_SASPORTPROTOCOL_SMP  4  /* Serial Management Protocol Port */
#define HBA_SASPORTPROTOCOL_SATA 8  /* SATA Device, Direct Attached or */
                                    /* anywhere in the domain */


typedef struct SMHBA_FC_Port {
    HBA_WWN       NodeWWN;
    HBA_WWN       PortWWN;
    HBA_UINT32    FcId;
    HBA_COS       PortSupportedClassofService;
    HBA_FC4TYPES  PortSupportedFc4Types;
    HBA_FC4TYPES  PortActiveFc4Types;
    HBA_WWN       FabricName;
    char          PortSymbolicName[256];
    HBA_UINT32    NumberofDiscoveredPorts;
    HBA_UINT8     NumberofPhys;
} SMHBA_FC_PORT, *PSMHBA_FC_PORT;

typedef struct SMHBA_SAS_Port {
    HBA_SASPORTPROTOCOL  PortProtocol;
    HBA_WWN              LocalSASAddress;
    HBA_WWN              AttachedSASAddress;
    HBA_UINT32           NumberofDiscoveredPorts;
    HBA_UINT32           NumberofPhys;
} SMHBA_SAS_PORT, *PSMHBA_SAS_PORT;

typedef union SMHBA_Port {
    SMHBA_FC_PORT  *FCPort;
    SMHBA_SAS_PORT *SASPort;
} SMHBA_PORT, *PSMHBA_PORT;

typedef struct SMHBA_PortAttributes {
    HBA_PORTTYPE  PortType;  
    HBA_PORTSTATE PortState;
    char          OSDeviceName[256];   
    SMHBA_PORT    PortSpecificAttribute;
} SMHBA_PORTATTRIBUTES, *PSMHBA_PORTATTRIBUTES;


/* Statistical counters for FC-0, FC-1 and FC-2 */

typedef struct HBA_PortStatistics {
    HBA_INT64 SecondsSinceLastReset;
    HBA_INT64 TxFrames;
    HBA_INT64 TxWords;
    HBA_INT64 RxFrames;
    HBA_INT64 RxWords;
    HBA_INT64 LIPCount;
    HBA_INT64 NOSCount;
    HBA_INT64 ErrorFrames;
    HBA_INT64 DumpedFrames;
    HBA_INT64 LinkFailureCount;
    HBA_INT64 LossOfSyncCount;
    HBA_INT64 LossOfSignalCount;
    HBA_INT64 PrimitiveSeqProtocolErrCount;
    HBA_INT64 InvalidTxWordCount;
    HBA_INT64 InvalidCRCCount;
} HBA_PORTSTATISTICS, *PHBA_PORTSTATISTICS;


/* Statistical counters for FC-4 protocols */

typedef struct HBA_FC4Statistics {
    HBA_INT64 InputRequests;
    HBA_INT64 OutputRequests;
    HBA_INT64 ControlRequests;
    HBA_INT64 InputMegabytes;
    HBA_INT64 OutputMegabytes;
} HBA_FC4STATISTICS, *PHBA_FC4STATISTICS;


/* Statistical counters for FC-4, SSP, STP, SMP protocols */

typedef struct SMHBA_ProtocolStatistics {
    HBA_INT64 SecondsSinceLastReset;
    HBA_INT64 InputRequests;
    HBA_INT64 OutputRequests;
    HBA_INT64 ControlRequests;
    HBA_INT64 InputMegabytes;
    HBA_INT64 OutputMegabytes;
} SMHBA_PROTOCOLSTATISTICS, *PSMHBA_PROTOCOLSTATISTICS;


typedef struct SMHBA_SASPhyStatistics {
    HBA_INT64 SecondsSinceLastReset;
    HBA_INT64 TxFrames;
    HBA_INT64 TxWords;
    HBA_INT64 RxFrames;
    HBA_INT64 RxWords;
    HBA_INT64 InvalidDwordCount;
    HBA_INT64 RunningDisparityErrorCount;
    HBA_INT64 LossofDwordSyncCount;
    HBA_INT64 PhyResetProblemCount;
} SMHBA_SASPHYSTATISTICS, *PSMHBA_SASPHYSTATISTICS;


/* Statistical counters for FC-0, FC-1, and FC-2 */

typedef HBA_PORTSTATISTICS SMHBA_FCPHYSTATISTICS, *PSMHBA_FCPHYSTATISTICS;

typedef union SMHBA_PhyStatistics {
    SMHBA_SASPHYSTATISTICS *SASPhyStatistics;
    SMHBA_FCPHYSTATISTICS  *FCPhyStatistics;
} SMHBA_PHYSTATISTICS, *PSMHBA_PHYSTATISTICS;



/* HBA_FCPBINDINGTYPE was used in Rev 1.0.  Add TO_OTHER for older calls to 
   indicate other binding types for HBA_GetPersistentBinding.  To support 
   multiple types a new flag has been created to allow for multiple bindings
   supported */

typedef enum HBA_fcpbindingtype { TO_D_ID, TO_WWN, TO_OTHER } HBA_FCPBINDINGTYPE;


/* A bit mask of Rev 2.0 persistent binding capabilities */

typedef HBA_UINT32 HBA_BIND_CAPABILITY;   

/* The following are bit flags indicating persistent binding capabilities */

#define HBA_CAN_BIND_TO_D_ID     0x0001
#define HBA_CAN_BIND_TO_WWPN     0x0002
#define HBA_CAN_BIND_TO_WWNN     0x0004
#define HBA_CAN_BIND_TO_LUID     0x0008
#define HBA_CAN_BIND_ANY_LUNS    0x0400
#define HBA_CAN_BIND_TARGETS     0x0800
#define HBA_CAN_BIND_AUTOMAP     0x1000
#define HBA_CAN_BIND_CONFIGURED  0x2000

/* A bit mask of Rev 2.0 persistent binding setting types */

typedef HBA_UINT32 HBA_BIND_TYPE;

/* The following are bit flags indicating persistent binding setting types */

#define HBA_BIND_TO_D_ID     0x0001
#define HBA_BIND_TO_WWPN     0x0002
#define HBA_BIND_TO_WWNN     0x0004
#define HBA_BIND_TO_LUID     0x0008
#define HBA_BIND_TARGETS     0x0800

typedef struct HBA_LUID {
    char  buffer[256];
} HBA_LUID, *PHBA_LUID;

typedef struct HBA_ScsiId {
    char       OSDeviceName[256]; /* \device\ScsiPort3 */
    HBA_UINT32 ScsiBusNumber;     /* Bus on the HBA */
    HBA_UINT32 ScsiTargetNumber;  /* SCSI Target ID to OS */
    HBA_UINT32 ScsiOSLun;
} HBA_SCSIID, *PHBA_SCSIID;

typedef struct HBA_FcpId {
    HBA_UINT32 FcId;
    HBA_WWN    NodeWWN;
    HBA_WWN    PortWWN;
    HBA_UINT64 FcpLun;
} HBA_FCPID, *PHBA_FCPID;

typedef struct HBA_FcpScsiEntry {
    HBA_SCSIID ScsiId;
    HBA_FCPID  FcpId;
} HBA_FCPSCSIENTRY, *PHBA_FCPSCSIENTRY;

typedef struct HBA_FcpScsiEntryV2 {
    HBA_SCSIID ScsiId;
    HBA_FCPID  FcpId;
    HBA_LUID   LUID;
} HBA_FCPSCSIENTRYV2, *PHBA_FCPSCSIENTRYV2;

typedef struct HBA_FCPTargetMapping {
    HBA_UINT32       NumberOfEntries;
    HBA_FCPSCSIENTRY entry[1];  /* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPING, *PHBA_FCPTARGETMAPPING;

typedef struct HBA_FCPTargetMappingV2 {
    HBA_UINT32         NumberOfEntries;
    HBA_FCPSCSIENTRYV2 entry[1]; /* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPINGV2, *PHBA_FCPTARGETMAPPINGV2;


typedef struct HBA_FCPBindingEntry {
    HBA_FCPBINDINGTYPE type;
    HBA_SCSIID         ScsiId;
    HBA_FCPID          FcpId;
    HBA_UINT32         FcId;
} HBA_FCPBINDINGENTRY, *PHBA_FCPBINDINGENTRY;

typedef struct HBA_FCPBinding {
    HBA_UINT32          NumberOfEntries;
    HBA_FCPBINDINGENTRY entry[1]; /* Variable length array */
} HBA_FCPBINDING, *PHBA_FCPBINDING;

typedef struct HBA_FCPBindingEntry2 {
    HBA_BIND_TYPE  type;
    HBA_SCSIID     ScsiId;
    HBA_FCPID      FcpId;
    HBA_LUID       LUID;
    HBA_STATUS     Status;
} HBA_FCPBINDINGENTRY2, *PHBA_FCPBINDINGENTRY2;

typedef struct HBA_FCPBinding2 {
    HBA_UINT32           NumberOfEntries;
    HBA_FCPBINDINGENTRY2 entry[1]; /* Variable length array */
} HBA_FCPBINDING2, *PHBA_FCPBINDING2;


typedef HBA_UINT32 SMHBA_BIND_CAPABILITY;

#define SMHBA_CAN_BIND_TO_WWPN  0x0001
#define SMHBA_CAN_BIND_TO_LUID  0x0002
#define SMHBA_CAN_BIND_ANY_LUNS 0x0400
#define SMHBA_CAN_BIND_AUTOMAP  0x0800

typedef HBA_UINT32 SMHBA_BIND_TYPE;

#define SMHBA_BIND_TO_WWPN 0x0001
#define SMHBA_BIND_TO_LUID 0x0002

typedef struct SMHBA_ScsiId {
    char       OSDeviceName[256];
    HBA_UINT32 ScsiBusNumber;
    HBA_UINT32 ScsiTargetNumber;
    HBA_UINT32 ScsiOSLun;
} SMHBA_SCSIID, *PSMHBA_SCSIID;

typedef struct SMHBA_LUID {
    char buffer[256];
} SMHBA_LUID, *PSMHBA_LUID;

typedef HBA_UINT64 HBA_SCSILUN;

typedef struct SMHBA_SCSILUN {
    HBA_UINT8 lun[8];
} SMHBA_SCSILUN;

typedef struct SMHBA_PORTLUN {
    HBA_WWN     PortWWN;
    HBA_WWN     domainPortWWN;
    HBA_SCSILUN TargetLun;
} SMHBA_PORTLUN, *PSMHBA_PORTLUN;

typedef struct SMHBA_ScsiEntry {
    SMHBA_SCSIID  ScsiId;
    SMHBA_PORTLUN PortLun;
    SMHBA_LUID    LUID;
} SMHBA_SCSIENTRY, *PSMHBA_SCSIENTRY;

typedef struct SMHBA_TargetMapping {
    HBA_UINT32      NumberOfEntries;
    SMHBA_SCSIENTRY entry[1]; /* Variable length array containing mappings*/
} SMHBA_TARGETMAPPING, *PSMHBA_TARGETMAPPING;

typedef struct SMHBA_BindingEntry {
    SMHBA_BIND_TYPE type;
    SMHBA_SCSIID    ScsiId;
    SMHBA_PORTLUN   PortLun;
    SMHBA_LUID      LUID;
    HBA_STATUS      Status;
} SMHBA_BINDINGENTRY, *PSMHBA_BINDINGENTRY;

typedef struct SMHBA_Binding {
    HBA_UINT32         NumberOfEntries;
    SMHBA_BINDINGENTRY entry[1]; /* Variable length array */
} SMHBA_BINDING, *PSMHBA_BINDING;


typedef enum HBA_wwntype { NODE_WWN, PORT_WWN } HBA_WWNTYPE;

typedef struct HBA_MgmtInfo {
    HBA_WWN    wwn;
    HBA_UINT32 unittype;
    HBA_UINT32 PortId;
    HBA_UINT32 NumberOfAttachedNodes;
    HBA_UINT16 IPVersion;
    HBA_UINT16 UDPPort;
    HBA_UINT8  IPAddress[16];
    HBA_UINT16 reserved;
    HBA_UINT16 TopologyDiscoveryFlags;
} HBA_MGMTINFO, *PHBA_MGMTINFO;

#define HBA_EVENT_LIP_OCCURRED       1
#define HBA_EVENT_LINK_UP            2
#define HBA_EVENT_LINK_DOWN          3
#define HBA_EVENT_LIP_RESET_OCCURRED 4
#define HBA_EVENT_RSCN               5
#define HBA_EVENT_PROPRIETARY        0xFFFF

typedef struct HBA_Link_EventInfo {
    HBA_UINT32 PortFcId;   /* Port which this event occurred */
    HBA_UINT32 Reserved[3];
} HBA_LINK_EVENTINFO, *PHBA_LINK_EVENTINFO;

typedef struct HBA_RSCN_EventInfo {
    HBA_UINT32 PortFcId;  /* Port which this event occurred */
    HBA_UINT32 NPortPage; /* Reference FC-FS for RSCN ELS "Affected N-Port Pages"*/
    HBA_UINT32 Reserved[2];
} HBA_RSCN_EVENTINFO, *PHBA_RSCN_EVENTINFO;

typedef struct HBA_Pty_EventInfo {
    HBA_UINT32 PtyData[4]; /* Proprietary data */
} HBA_PTY_EVENTINFO, *PHBA_PTY_EVENTINFO;

typedef struct HBA_EventInfo {
    HBA_UINT32 EventCode;
    union {
        HBA_LINK_EVENTINFO Link_EventInfo;
        HBA_RSCN_EVENTINFO RSCN_EventInfo;
        HBA_PTY_EVENTINFO  Pty_EventInfo;
    } Event;
} HBA_EVENTINFO, *PHBA_EVENTINFO;

typedef PVOID PHBA_ENTRYPOINTS;
typedef PVOID PHBA_ENTRYPOINTSV2;
typedef PVOID PSMHBA_ENTRYPOINTS;

HBA_STATUS HBA_API HBA_RegisterLibrary(PHBA_ENTRYPOINTS entrypoints);
HBA_STATUS HBA_API HBA_RegisterLibraryV2(PHBA_ENTRYPOINTSV2 entrypoints);


HBA_UINT32 HBA_API HBA_GetVersion();
HBA_STATUS HBA_API HBA_LoadLibrary();
HBA_STATUS HBA_API HBA_FreeLibrary();


HBA_UINT32 HBA_API HBA_GetNumberOfAdapters();

HBA_STATUS HBA_API 
HBA_GetAdapterName(
    IN HBA_UINT32 AdapterIndex, 
    OUT PCHAR AdapterName
    );

HBA_HANDLE HBA_API 
HBA_OpenAdapter(
    IN PCHAR AdapterName
    );

void HBA_API 
HBA_CloseAdapter(
    IN HBA_HANDLE handle
    );

HBA_STATUS HBA_API 
HBA_GetAdapterAttributes(
    IN  HBA_HANDLE             Handle,
    OUT HBA_ADAPTERATTRIBUTES *HbaAttributes
    );

HBA_STATUS HBA_API 
HBA_GetAdapterPortAttributes(
    IN  HBA_HANDLE          Handle,
    IN  HBA_UINT32          PortIndex,
    OUT HBA_PORTATTRIBUTES *PortAttributes
    );


HBA_STATUS HBA_API 
HBA_GetPortStatistics(
    IN  HBA_HANDLE          Handle,
    IN  HBA_UINT32          PortIndex,
    OUT HBA_PORTSTATISTICS *PortStatistics
    );

HBA_STATUS HBA_API 
HBA_GetDiscoveredPortAttributes(
    IN  HBA_HANDLE          Handle,
    IN  HBA_UINT32          PortIndex,
    IN  HBA_UINT32          DiscoveredPortIndex,
    OUT HBA_PORTATTRIBUTES *PortAttributes
    );

HBA_STATUS HBA_API 
HBA_GetPortAttributesByWWN(
    IN  HBA_HANDLE          Handle,
    IN  HBA_WWN             PortWWN,
    OUT HBA_PORTATTRIBUTES *PortAttributes
    );


HBA_STATUS HBA_API 
HBA_SendCTPassThru(
    IN  HBA_HANDLE Handle,
    IN  void      *pReqBuffer,
    IN  HBA_UINT32 ReqBufferSize,
    OUT void      *pRspBuffer,
    IN  HBA_UINT32 RspBufferSize
    );

HBA_STATUS HBA_API 
HBA_GetEventBuffer(
    IN     HBA_HANDLE      Handle,
    OUT    PHBA_EVENTINFO  EventBuffer,
    IN OUT HBA_UINT32     *EventCount
    );

HBA_STATUS HBA_API 
HBA_SetRNIDMgmtInfo(
    IN HBA_HANDLE    Handle,
    IN HBA_MGMTINFO *pInfo
    );

HBA_STATUS HBA_API 
HBA_GetRNIDMgmtInfo(
    IN  HBA_HANDLE    Handle,
    OUT HBA_MGMTINFO *pInfo
    );

HBA_STATUS HBA_API 
HBA_SendRNID(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     Wwn,
    IN     HBA_WWNTYPE WnnType,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *RspBufferSize
    );

HBA_STATUS HBA_API 
HBA_GetFcpTargetMapping(
    IN     HBA_HANDLE            Handle,
    IN OUT PHBA_FCPTARGETMAPPING Mapping
    );

HBA_STATUS HBA_API 
HBA_GetFcpPersistentBinding(
    IN     HBA_HANDLE      Handle,
    IN OUT PHBA_FCPBINDING Binding
    );

HBA_STATUS HBA_API 
HBA_SendScsiInquiry(
    IN  HBA_HANDLE  Handle,
    IN  HBA_WWN     PortWWN,
    IN  HBA_UINT64  FcLUN,
    IN  HBA_UINT8   EVPD,
    IN  HBA_UINT32  PageCode,
    OUT void       *pRspBuffer,
    IN  HBA_UINT32  RspBufferSize,
    OUT void       *pSenseBuffer,
    IN  HBA_UINT32  SenseBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendReportLUNs(
    IN  HBA_HANDLE  Handle,
    IN  HBA_WWN     PortWWN,
    OUT void       *pRspBuffer,
    IN  HBA_UINT32  RspBufferSize,
    OUT void       *pSenseBuffer,
    IN  HBA_UINT32  SenseBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendReadCapacity(
    IN  HBA_HANDLE  Handle,
    IN  HBA_WWN     PortWWN,
    IN  HBA_UINT64  FcLUN,
    OUT void       *pRspBuffer,
    IN  HBA_UINT32  RspBufferSize,
    OUT void       *pSenseBuffer,
    IN  HBA_UINT32  SenseBufferSize
    );

void HBA_API 
HBA_RefreshInformation(
    IN HBA_HANDLE Handle
    );

void HBA_API
HBA_ResetStatistics(
    IN HBA_HANDLE Handle,
    IN HBA_UINT32 PortIndex
    );


typedef void *HBA_CALLBACKHANDLE;

typedef HBA_CALLBACKHANDLE *PHBA_CALLBACKHANDLE;

/* Adapter Level Events */
#define HBA_EVENT_ADAPTER_UNKNOWN    0x100
#define HBA_EVENT_ADAPTER_ADD        0x101
#define HBA_EVENT_ADAPTER_REMOVE     0x102
#define HBA_EVENT_ADAPTER_CHANGE     0x103

/* Port Level Events */
#define HBA_EVENT_PORT_UNKNOWN          0x200
#define HBA_EVENT_PORT_OFFLINE          0x201
#define HBA_EVENT_PORT_ONLINE           0x202
#define HBA_EVENT_PORT_NEW_TARGETS      0x203
#define HBA_EVENT_PORT_FABRIC           0x204
#define HBA_EVENT_PORT_BROADCAST_CHANGE 0x205
#define HBA_EVENT_PORT_BROADCAST_D24_0  0x206
#define HBA_EVENT_PORT_BROADCAST_D27_4  0x207
#define HBA_EVENT_PORT_BROADCAST_SES    0x208
#define HBA_EVENT_PORT_BROADCAST_D01_4  0x209
#define HBA_EVENT_PORT_BROADCAST_D04_7  0x20a
#define HBA_EVENT_PORT_BROADCAST_D16_7  0x20b
#define HBA_EVENT_PORT_BROADCAST_D29_7  0x20c
#define HBA_EVENT_PORT_ALL              0x2ff

/* Port Statistics Events */
#define HBA_EVENT_PORT_STAT_THRESHOLD   0x301
#define HBA_EVENT_PORT_STAT_GROWTH      0x302

/* Phy Statistics Events */
#define HBA_EVENT_PHY_STAT_THRESHOLD    0x351
#define HBA_EVENT_PHY_STAT_GROWTH       0x352

/* Target Level Events */
#define HBA_EVENT_TARGET_UNKNOWN    0x400
#define HBA_EVENT_TARGET_OFFLINE    0x401
#define HBA_EVENT_TARGET_ONLINE     0x402
#define HBA_EVENT_TARGET_REMOVED    0x403

/* Fabric Link  Events */
#define HBA_EVENT_LINK_UNKNOWN      0x500
#define HBA_EVENT_LINK_INCIDENT     0x501

HBA_STATUS HBA_API
HBA_RemoveCallback(
    IN HBA_CALLBACKHANDLE callbackHandle
    );

HBA_STATUS HBA_API
HBA_RegisterForAdapterAddEvents(
    IN  void (*callback) (void *pData, HBA_WWN PortWWN, HBA_UINT32 eventType), 
    IN  void               *pUserData,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
HBA_RegisterForAdapterEvents(
    IN  void (*callback) (void *pData, HBA_WWN PortWWN, HBA_UINT32 eventType),
    IN  void               *pUserData, 
    IN  HBA_HANDLE          Handle,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
HBA_RegisterForAdapterPortEvents(
    IN  void (*callback) (void      *pData, 
                          HBA_WWN    PortWWN,
                          HBA_UINT32 eventType, 
                          HBA_UINT32 fabricPortID),
    IN  void               *UserData,
    IN  HBA_HANDLE          Handle,
    IN  HBA_WWN             PortWWN,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
HBA_RegisterForAdapterPortStatEvents(
    IN  void (*callback)(void      *pData, 
                         HBA_WWN    PortWWN, 
                         HBA_UINT32 eventType),
    IN  void               *pUserData,
    IN  HBA_HANDLE          Handle,
    IN  HBA_WWN             PortWWN,
    IN  HBA_PORTSTATISTICS  stats,
    IN  HBA_UINT32          statType,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
HBA_RegisterForTargetEvents(
    IN  void (*callback)(void      *pData, 
                         HBA_WWN    hbaPortWWN,
                         HBA_WWN    discoveredPortWWN, 
                         HBA_UINT32 eventType),
    IN  void               *pUserData,
    IN  HBA_HANDLE          Handle, 
    IN  HBA_WWN             HbaPortWWN,
    IN  HBA_WWN             DiscoveredPortWWN,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle,
    IN  HBA_UINT32          AllTargets
    );

HBA_STATUS HBA_API
HBA_RegisterForLinkEvents(
    IN  void (*callback)(void *data, HBA_WWN adapterWWN, HBA_UINT32 eventType,
                     void *pRLIRBuffer, HBA_UINT32 RLIRBufferSize),
    IN  void               *userData,
    IN  void               *pRLIRBuffer,
    IN  HBA_UINT32          RLIRBufferSize,
    IN  HBA_HANDLE          Handle, 
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );


HBA_STATUS HBA_API 
HBA_OpenAdapterByWWN(
    OUT HBA_HANDLE *HbaHandle,
    IN  HBA_WWN     Wwn
    );

void HBA_API 
HBA_RefreshAdapterConfiguration(
    );

HBA_STATUS HBA_API 
HBA_SendCTPassThruV2(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     HbaPortWWN,
    IN     void       *pReqBuffer,
    IN     HBA_UINT32  ReqBufferSize,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendRNIDV2(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DestWWN,
    IN     HBA_UINT32  DestFCID,
    IN     HBA_UINT32  NodeIdDataFormat,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendRPL(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     Agent_wwn,
    IN     HBA_UINT32  Agent_domain,
    IN     HBA_UINT32  PortIndex,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendRPS(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     Agent_wwn,
    IN     HBA_UINT32  Agent_domain,
    IN     HBA_WWN     Object_wwn,
    IN     HBA_UINT32  Object_port_number,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendSRL(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     Wwn,
    IN     HBA_UINT32  Domain,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API 
HBA_SendLIRR(
    IN     HBA_HANDLE  Handle,
    IN     HBA_WWN     SourceWWN,
    IN     HBA_WWN     DestWWN,
    IN     HBA_UINT8   Function,
    IN     HBA_UINT8   Type,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API
HBA_SendRLS(
    IN     HBA_HANDLE  HbaHandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DestWWN,
    OUT    void       *pRspBuffer,
    IN OUT HBA_UINT32 *pRspBufferSize
    );


HBA_STATUS HBA_API 
HBA_GetFC4Statistics(
    IN  HBA_HANDLE         Handle,
    IN  HBA_WWN            PortWWN,
    IN  HBA_UINT8          FC4type,
    OUT HBA_FC4STATISTICS *Statistics
    );

HBA_STATUS HBA_API
HBA_GetFCPStatistics(
    IN  HBA_HANDLE         Handle,
    IN  const HBA_SCSIID  *Lunit,
    OUT HBA_FC4STATISTICS *Statistics
    );



typedef struct HBA_LibraryAttributes {
    HBA_BOOLEAN final;
    char        LibPath[256];
    char        VName[256];
    char        VVersion[256];
    struct tm   build_date;
} HBA_LIBRARYATTRIBUTES, *PHBA_LIBRARYATTRIBUTES;

typedef struct SMHBA_LibraryAttributes {
    char        LibPath[256];
    char        VName[256];
    char        VVersion[256];
    struct {
        int tm_mday;  /* day of the month - [1,31] */
        int tm_mon;   /* months since January - [0,11] */
        int tm_year;  /* years since 1900 */
    } build_date;
} SMHBA_LIBRARYATTRIBUTES, *PSMHBA_LIBRARYATTRIBUTES;


HBA_UINT32 HBA_API 
HBA_GetWrapperLibraryAttributes(
    OUT HBA_LIBRARYATTRIBUTES *Attributes
    );

HBA_UINT32 HBA_API 
HBA_GetVendorLibraryAttributes(
    IN  HBA_UINT32             AdapterIndex,
    OUT HBA_LIBRARYATTRIBUTES *Attributes
    );


HBA_STATUS HBA_API
HBA_ScsiReadCapacityV2(
    IN     HBA_HANDLE  HbaHandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DiscoveredPortWWN,
    IN     HBA_UINT64  FcLUN,
    OUT    void       *pRespBuffer,
    IN OUT HBA_UINT32 *pRespBufferSize,
    OUT    HBA_UINT8  *pScsiStatus,
    OUT    void       *pSenseBuffer,
    IN OUT HBA_UINT32 *pSenseBufferSize
    );

HBA_STATUS HBA_API
HBA_ScsiReportLUNsV2(
    IN     HBA_HANDLE  Hbahandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DiscoveredPortWWN,
    OUT    void       *pRespBuffer,
    IN OUT HBA_UINT32 *pRespBufferSize,
    OUT    HBA_UINT8  *pScsiStatus,
    OUT    void       *pSenseBuffer,
    IN OUT HBA_UINT32 *pSenseBufferSize
    );

HBA_STATUS HBA_API 
HBA_ScsiInquiryV2 (
    IN     HBA_HANDLE  HbaHandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DiscoveredPortWWN,
    IN     HBA_UINT64  FcLUN,
    IN     HBA_UINT8   CDB_Byte1,
    IN     HBA_UINT8   CDB_Byte2,
    OUT    void       *pRespBuffer,
    IN OUT HBA_UINT32 *pRespBufferSize,
    OUT    HBA_UINT8  *pScsiStatus,
    OUT    void       *pSenseBuffer,
    IN OUT HBA_UINT32 *pSenseBufferSize
    );


HBA_STATUS HBA_API 
HBA_GetFcpTargetMappingV2(
    IN     HBA_HANDLE              HbaHandle,
    IN     HBA_WWN                 HbaPortWWN,
    IN OUT HBA_FCPTARGETMAPPINGV2 *Mapping
    );

HBA_STATUS HBA_API
HBA_GetBindingCapability(
    IN  HBA_HANDLE           Handle,
    IN  HBA_WWN              HbaPortWWN,
    OUT HBA_BIND_CAPABILITY *Flags
    );

HBA_STATUS HBA_API
HBA_GetBindingSupport(
    IN  HBA_HANDLE           Handle,
    IN  HBA_WWN              HbaPortWWN,
    OUT HBA_BIND_CAPABILITY *Flags
    );

HBA_STATUS HBA_API
HBA_SetBindingSupport(
    IN HBA_HANDLE          Handle,
    IN HBA_WWN             HbaPortWWN,
    IN HBA_BIND_CAPABILITY Flags
    );


HBA_STATUS HBA_API
HBA_GetPersistentBindingV2(
    IN     HBA_HANDLE       Handle,
    IN     HBA_WWN          HbaPortWWN,
    IN OUT PHBA_FCPBINDING2 Binding
    );

HBA_STATUS HBA_API
HBA_SetPersistentBindingV2(
    IN HBA_HANDLE       Handle,
    IN HBA_WWN          HbaPortWWN,
    IN PHBA_FCPBINDING2 Binding
    );

HBA_STATUS HBA_API
HBA_RemovePersistentBinding(
    IN HBA_HANDLE       Handle,
    IN HBA_WWN          HbaPortWWN,
    IN PHBA_FCPBINDING2 Binding
    );

HBA_STATUS HBA_API
HBA_RemoveAllPersistentBindings(
    IN HBA_HANDLE  Handle,
    IN HBA_WWN     HbaPortWWN
    );


#if 0

//
// stubs for unsupported SB functions
//

typedef PVOID PHBA_SBTARGETMAPPING;

typedef struct HBA_SBDevId {
    char  OSDeviceName[256];
} HBA_SBDEVID, *PHBA_SBDEVID;


typedef struct HBA_Ned {
    HBA_UINT32  NEDWord0;
    HBA_UINT32  NelId[7];
} HBA_NED, *PHBA_NED;

typedef struct HBA_DeviceSelfDesc {
    HBA_NED  TokenNED;
    HBA_NED  DeviceNED;
} HBA_DEVICESELFDESC, *PHBA_DEVICESELFDESC;

typedef PVOID PHBA_SBSTATISTICS;

typedef struct HBA_SBDskCapacity {
    HBA_INT32  SCSIFormatLBA;          /* SCSI Read Capacity Format */
    HBA_INT32  SCSIFormatBlkLen;       /* SCSI Read Capacity Format */
    HBA_INT32  SBDskNumberOfCylinders; /* cyls */
    HBA_INT32  SBDskTracksPerCylinder; /* tracks per cyl */
    HBA_INT32  SBDskMaxUsableTrackLen; /* usable track capcacity */
} HBA_SBDSKCAPACITY, *PHBA_SBDSKCAPACITY;
   

HBA_STATUS HBA_API
HBA_GetSBTargetMapping(
    IN  HBA_HANDLE           HbaHandle,
    IN  HBA_WWN              HbaPortWWN,
    OUT PHBA_SBTARGETMAPPING Mapping
    );

HBA_STATUS HBA_API
HBA_GetSBStatistics(
    IN  HBA_HANDLE         HbaHandle,
    IN  const HBA_SBDEVID *Device,
    OUT PHBA_SBSTATISTICS  Statistics
    );

HBA_STATUS HBA_API
HBA_SBDskGetCapacity(
    IN  HBA_DEVICESELFDESC  DeviceSelfDesc,
    OUT PHBA_SBDSKCAPACITY  PSbDskCapacity
    );

#endif

#ifdef SM_HBA_API

//
// SM-HBA Library Control Functions
//

#define SMHBA_VERSION 1

HBA_UINT32 HBA_API SMHBA_GetVersion();
HBA_STATUS HBA_API SMHBA_RegisterLibrary(PSMHBA_ENTRYPOINTS entrypoints);

HBA_UINT32 HBA_API
SMHBA_GetWrapperLibraryAttributes(
    OUT SMHBA_LIBRARYATTRIBUTES *Attributes
    );

HBA_UINT32 HBA_API
SMHBA_GetVendorLibraryAttributes(
    IN  HBA_UINT32                AdapterIndex,
    OUT SMHBA_LIBRARYATTRIBUTES  *Attributes
    );


//
// SM-HBA Adapter, FC_Port and SAS_Port Information Functions
//

HBA_STATUS HBA_API 
SMHBA_GetProtocolStatistics(
    IN  HBA_HANDLE                Handle,
    IN  HBA_UINT32                PortIndex,
    IN  HBA_UINT32                ProtocolType,
    OUT SMHBA_PROTOCOLSTATISTICS *ProtocolStatistics
    );

HBA_STATUS HBA_API
SMHBA_GetNumberOfPorts(
    IN  HBA_HANDLE  Handle,
    OUT HBA_UINT32 *NumberOfPorts
    );

HBA_STATUS HBA_API 
SMHBA_GetAdapterAttributes(
    IN  HBA_HANDLE               Handle,
    OUT SMHBA_ADAPTERATTRIBUTES *AdapterAttributes
    );

HBA_STATUS HBA_API 
SMHBA_GetPhyStatistics(
    IN  HBA_HANDLE           Handle,
    IN  HBA_UINT32           PortIndex,
    IN  HBA_UINT32           PhyIndex,
    OUT SMHBA_PHYSTATISTICS *PhyStatistics
    );

HBA_STATUS HBA_API 
SMHBA_GetDiscoveredPortAttributes(
    IN  HBA_HANDLE            Handle,
    IN  HBA_UINT32            PortIndex,
    IN  HBA_UINT32            DiscoveredPortIndex,
    OUT SMHBA_PORTATTRIBUTES *PortAttributes
    );

HBA_STATUS HBA_API 
SMHBA_GetPortAttributesByWWN(
    IN  HBA_HANDLE            Handle,
    IN  HBA_WWN               PortWWN,
    IN  HBA_WWN               DomainPortWWN,
    OUT SMHBA_PORTATTRIBUTES *PortAttributes
    );

HBA_STATUS HBA_API
SMHBA_GetPortType(
    IN  HBA_HANDLE    Handle,
    IN  HBA_UINT32    PortIndex,
    OUT HBA_PORTTYPE *PortType
    );

HBA_STATUS HBA_API 
SMHBA_GetAdapterPortAttributes(
    IN  HBA_HANDLE            Handle,
    IN  HBA_UINT32            PortIndex,
    OUT SMHBA_PORTATTRIBUTES *PortAttributes
    );

HBA_STATUS HBA_API 
SMHBA_GetFCPhyAttributes(
    IN  HBA_HANDLE    Handle,
    IN  HBA_UINT32    PortIndex,
    IN  HBA_UINT32    PhyIndex,
    OUT SMHBA_FC_PHY *PhyType
    );

HBA_STATUS HBA_API 
SMHBA_GetSASPhyAttributes(
    IN  HBA_HANDLE     Handle,
    IN  HBA_UINT32     PortIndex,
    IN  HBA_UINT32     PhyIndex,
    OUT SMHBA_SAS_PHY *PhyType
    );

//
// SM-HBA Target Information Functions
//

HBA_STATUS HBA_API
SMHBA_GetLUNStatistics(
    IN  HBA_HANDLE                Handle,
    IN  const HBA_SCSIID         *Lunit,
    OUT SMHBA_PROTOCOLSTATISTICS *ProtocolStatistics
    );

HBA_STATUS HBA_API 
SMHBA_GetTargetMapping(
    IN     HBA_HANDLE           HbaHandle,
    IN     HBA_WWN              HbaPortWWN,
    IN     HBA_WWN              DomainPortWWN,
    IN OUT SMHBA_TARGETMAPPING *Mapping
    );

HBA_STATUS HBA_API
SMHBA_GetBindingCapability(
    IN  HBA_HANDLE             Handle,
    IN  HBA_WWN                HbaPortWWN,
    IN  HBA_WWN                DomainPortWWN,
    OUT SMHBA_BIND_CAPABILITY *Flags
    );

HBA_STATUS HBA_API
SMHBA_GetBindingSupport(
    IN  HBA_HANDLE             Handle,
    IN  HBA_WWN                HbaPortWWN,
    IN  HBA_WWN                DomainPortWWN,
    OUT SMHBA_BIND_CAPABILITY *Flags
    );

HBA_STATUS HBA_API
SMHBA_SetBindingSupport(
    IN HBA_HANDLE            Handle,
    IN HBA_WWN               HbaPortWWN,
    IN HBA_WWN               DomainPortWWN,
    IN SMHBA_BIND_CAPABILITY Flags
    );

HBA_STATUS HBA_API
SMHBA_GetPersistentBinding(
    IN     HBA_HANDLE     Handle,
    IN     HBA_WWN        HbaPortWWN,
    IN     HBA_WWN        DomainPortWWN,
    IN OUT SMHBA_BINDING *Binding
    );

HBA_STATUS HBA_API
SMHBA_SetPersistentBinding(
    IN HBA_HANDLE           Handle,
    IN HBA_WWN              HbaPortWWN,
    IN HBA_WWN              DomainPortWWN,
    IN OUT SMHBA_BINDING   *Binding
    );

HBA_STATUS HBA_API
SMHBA_RemovePersistentBinding(
    IN HBA_HANDLE           Handle,
    IN HBA_WWN              HbaPortWWN,
    IN HBA_WWN              DomainPortWWN,
    IN const SMHBA_BINDING *Binding
    );

HBA_STATUS HBA_API
SMHBA_RemoveAllPersistentBindings(
    IN HBA_HANDLE  Handle,
    IN HBA_WWN     HbaPortWWN,
    IN HBA_WWN     DomainPortWWN
    );

//
// SCSI Information Functions
//

HBA_STATUS HBA_API 
SMHBA_ScsiInquiry(
    IN     HBA_HANDLE  HbaHandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DiscoveredPortWWN,
    IN     HBA_WWN     DomainPortWWN,
    IN     HBA_SCSILUN SmhbaLUN,
    IN     HBA_UINT8   CDB_Byte1,
    IN     HBA_UINT8   CDB_Byte2,
    OUT    void       *pRespBuffer,
    IN OUT HBA_UINT32 *pRespBufferSize,
    OUT    HBA_UINT8  *pScsiStatus,
    OUT    void       *pSenseBuffer,
    IN OUT HBA_UINT32 *pSenseBufferSize
    );

HBA_STATUS HBA_API
SMHBA_ScsiReportLuns(
    IN     HBA_HANDLE  Hbahandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DiscoveredPortWWN,
    IN     HBA_WWN     DomainPortWWN,
    OUT    void       *pRespBuffer,
    IN OUT HBA_UINT32 *pRespBufferSize,
    OUT    HBA_UINT8  *pScsiStatus,
    OUT    void       *pSenseBuffer,
    IN OUT HBA_UINT32 *pSenseBufferSize
    );

HBA_STATUS HBA_API
SMHBA_ScsiReadCapacity(
    IN     HBA_HANDLE  HbaHandle,
    IN     HBA_WWN     HbaPortWWN,
    IN     HBA_WWN     DiscoveredPortWWN,
    IN     HBA_WWN     DomainPortWWN,
    IN     HBA_SCSILUN SmhbaLUN,
    OUT    void       *pRespBuffer,
    IN OUT HBA_UINT32 *pRespBufferSize,
    OUT    HBA_UINT8  *pScsiStatus,
    OUT    void       *pSenseBuffer,
    IN OUT HBA_UINT32 *pSenseBufferSize
    );

//
// Fabric and Domain Management Functions
//

// new FC specific

HBA_STATUS HBA_API
SMHBA_SendTEST(
    IN HBA_HANDLE  Handle,
    IN HBA_WWN     HbaPortWWN,
    IN HBA_WWN     DestWWN,
    IN HBA_UINT32  DestFCID,
    IN void       *ReqBuffer,
    IN HBA_UINT32  ReqBufferSize
    );

// new FC specific

HBA_STATUS HBA_API
SMHBA_SendECHO(
    IN HBA_HANDLE      Handle,
    IN HBA_WWN         HbaPortWWN,
    IN HBA_WWN         DestWWN,
    IN HBA_UINT32      DestFCID,
    IN void           *ReqBuffer,
    IN HBA_UINT32      ReqBufferSize,
    OUT    void       *RspBuffer,
    IN OUT HBA_UINT32 *RspBufferSize
    );

// new SAS specific

HBA_STATUS HBA_API
SMHBA_SendSMPPassThru(
    IN HBA_HANDLE      Handle,
    IN HBA_WWN         HbaPortWWN,
    IN HBA_WWN         DestPortWWN,
    IN HBA_WWN         DomainPortWWN,
    IN void           *ReqBuffer,
    IN HBA_UINT32      ReqBufferSize,
    OUT    void       *RspBuffer,
    IN OUT HBA_UINT32 *RspBufferSize
    );


//
// Event Handling Functions
//


HBA_STATUS HBA_API
SMHBA_RegisterForAdapterAddEvents(
    IN  void (*callback)(void *pData, HBA_WWN PortWWN, HBA_UINT32 eventType), 
    IN  void               *pUserData,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
SMHBA_RegisterForAdapterEvents(
    IN  void (*callback)(void *pData, HBA_WWN PortWWN, HBA_UINT32 eventType),
    IN  void               *pUserData, 
    IN  HBA_HANDLE          Handle,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
SMHBA_RegisterForAdapterPortEvents(
    IN  void (*callback)(void      *pData, 
                         HBA_WWN    PortWWN,
                         HBA_UINT32 eventType, 
                         HBA_UINT32 fabricPortID),
    IN  void               *pUserData,
    IN  HBA_HANDLE          Handle,
    IN  HBA_WWN             PortWWN,
    IN  HBA_UINT32          SpecificEventType,
    OUT HBA_CALLBACKHANDLE *pCallbackHandle
    );

HBA_STATUS HBA_API
SMHBA_RegisterForAdapterPortStatEvents(
    IN  void (*callback)(void      *pData, 
                         HBA_WWN    PortWWN, 
                         HBA_UINT32 ProtocolType,
                         HBA_UINT32 EventType),
    IN  void                     *pUserData,
    IN  HBA_HANDLE                Handle,
    IN  HBA_WWN                   PortWWN,
    IN  HBA_UINT32                ProtocolType,
    IN  SMHBA_PROTOCOLSTATISTICS  Stats,
    IN  HBA_UINT32                StatType,
    OUT HBA_CALLBACKHANDLE       *pCallbackHandle
    );

HBA_STATUS HBA_API
SMHBA_RegisterForAdapterPhyStatEvents(
    IN  void (*callback)(void      *pData, 
                         HBA_WWN    PortWWN,
                         HBA_UINT32 PhyIndex,
                         HBA_UINT32 EventType),
    IN  void                *pUserData,
    IN  HBA_HANDLE           Handle, 
    IN  HBA_WWN              PortWWN,
    IN  HBA_UINT32           PhyIndex,
    IN  SMHBA_PHYSTATISTICS  Stats,
    IN  HBA_UINT32           StatType,
    OUT HBA_CALLBACKHANDLE  *pCallbackHandle
    );

HBA_STATUS HBA_API
SMHBA_RegisterForTargetEvents(
    IN  void (*callback)(void      *pData, 
                         HBA_WWN    HbaPortWWN, 
                         HBA_WWN    DiscoveredPortWWN, 
                         HBA_WWN    DomainPortWWN, 
                         HBA_UINT32 EventType),
    IN  void               *pUserData,
    IN  HBA_HANDLE          Handle, 
    IN  HBA_WWN             HbaPortWWN, 
    IN  HBA_WWN             DiscoveredPortWWN, 
    IN  HBA_WWN             DomainPortWWN, 
    OUT HBA_CALLBACKHANDLE *pCallbackHandle,
    IN  HBA_UINT32          AllTargets
    );

#endif // _SM_HBA_API_

#ifdef __cplusplus
};
#endif

#endif // HBAAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hidport.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hidmini.h

Abstract

    Definitions that are common to all HID minidrivers.

Authors:

    Forrest Foltz
    Ervin Peretz

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef __HIDPORT_H__
#define __HIDPORT_H__

#include    <hidclass.h>

//
// HID_MINIDRIVER_REGISTRATION is a packet of information describing the
// HID minidriver to the class driver.  It must be filled in by the minidriver
// and passed to the class driver via HidRegisterMinidriver() from the
// minidriver's DriverEntry() routine.
//

typedef struct _HID_MINIDRIVER_REGISTRATION {

    //
    // Revision must be set to HID_REVISION by the minidriver
    //

    ULONG           Revision;

    //
    // DriverObject is a pointer to the minidriver's DriverObject that it
    // received as a DriverEntry() parameter.
    //

    PDRIVER_OBJECT  DriverObject;

    //
    // RegistryPath is a pointer to the minidriver's RegistryPath that it
    // received as a DriverEntry() parameter.
    //

    PUNICODE_STRING RegistryPath;

    //
    // DeviceExtensionSize is the size of the minidriver's per-device
    // extension.
    //

    ULONG           DeviceExtensionSize;

    //
    // Either all or none of the devices driven by a given minidriver are polled.
    //
    BOOLEAN         DevicesArePolled;
    UCHAR           Reserved[3];

} HID_MINIDRIVER_REGISTRATION, *PHID_MINIDRIVER_REGISTRATION;

//
// HID_DEVICE_EXTENSION is the public part of the device extension of a HID
// functional device object.
//

typedef struct _HID_DEVICE_EXTENSION {

    //
    // PhysicalDeviceObject... normally IRPs are not passed to this.
    //

    PDEVICE_OBJECT  PhysicalDeviceObject;

    //
    // NextDeviceObject... IRPs are sent here by the minidriver.  Note that
    // NextDeviceObject and PhysicalDeviceObject are the same unless someone
    // has inserted a 'filter' device object, in which case they are not the
    // same.  Sending IRPs to NextDeviceObject will hit the filter device
    // objects on the way down.
    //

    PDEVICE_OBJECT  NextDeviceObject;

    //
    // MiniDeviceExtension is the per-device extension area for use by
    // the minidriver.  It's size is determined by the DeviceExtensionSize
    // parameter passed in to HidAddDevice().
    //
    // So, given a Functional Device Object, a mininidriver finds this
    // structure by:
    //
    //    HidDeviceExtension = (PHID_DEVICE_EXTENSION)(Fdo->DeviceExtension);
    //
    // And of course it's per-device extension is found by:
    //
    //    MiniDeviceExtension = HidDeviceExtension->MiniDeviceExtension;
    //

    PVOID           MiniDeviceExtension;

} HID_DEVICE_EXTENSION, *PHID_DEVICE_EXTENSION;

typedef struct _HID_DEVICE_ATTRIBUTES {

    ULONG           Size;
    //
    // sizeof (struct _HID_DEVICE_ATTRIBUTES)
    //

    //
    // Vendor ids of this hid device
    //
    USHORT          VendorID;
    USHORT          ProductID;
    USHORT          VersionNumber;
    USHORT          Reserved[11];

} HID_DEVICE_ATTRIBUTES, * PHID_DEVICE_ATTRIBUTES;


#include <pshpack1.h>
typedef struct _HID_DESCRIPTOR
{
    UCHAR   bLength;
    UCHAR   bDescriptorType;
    USHORT  bcdHID;
    UCHAR   bCountry;
    UCHAR   bNumDescriptors;

    /*
     *  This is an array of one OR MORE descriptors.
     */
    struct _HID_DESCRIPTOR_DESC_LIST {
       UCHAR   bReportType;
       USHORT  wReportLength;
    } DescriptorList [1];

} HID_DESCRIPTOR, * PHID_DESCRIPTOR;
#include <poppack.h>


typedef 
VOID
(*HID_SEND_IDLE_CALLBACK)(
    PVOID Context
    );

typedef struct _HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO {
    HID_SEND_IDLE_CALLBACK IdleCallback;
    PVOID IdleContext;
} HID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO, *PHID_SUBMIT_IDLE_NOTIFICATION_CALLBACK_INFO;

//
// Function prototypes for the HID services exported by the hid class driver
// follow.
//

NTSTATUS
HidRegisterMinidriver(
    IN PHID_MINIDRIVER_REGISTRATION  MinidriverRegistration
    );
   
#if(NTDDI_VERSION>=NTDDI_WINXPSP1) // Available on XP XP1 and above
NTSTATUS
HidNotifyPresence(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN IsPresent
    );
#endif    

//
// Internal IOCTLs for the class/mini driver interface.
//

#define IOCTL_HID_GET_DEVICE_DESCRIPTOR             HID_CTL_CODE(0)
#define IOCTL_HID_GET_REPORT_DESCRIPTOR             HID_CTL_CODE(1)
#define IOCTL_HID_READ_REPORT                       HID_CTL_CODE(2)
#define IOCTL_HID_WRITE_REPORT                      HID_CTL_CODE(3)
#define IOCTL_HID_GET_STRING                        HID_CTL_CODE(4)
#define IOCTL_HID_ACTIVATE_DEVICE                   HID_CTL_CODE(7)
#define IOCTL_HID_DEACTIVATE_DEVICE                 HID_CTL_CODE(8)
#define IOCTL_HID_GET_DEVICE_ATTRIBUTES             HID_CTL_CODE(9)
#define IOCTL_HID_SEND_IDLE_NOTIFICATION_REQUEST    HID_CTL_CODE(10)

/*
 *  Codes for HID-specific descriptor types, from HID USB spec.
 */
#define HID_HID_DESCRIPTOR_TYPE             0x21
#define HID_REPORT_DESCRIPTOR_TYPE          0x22
#define HID_PHYSICAL_DESCRIPTOR_TYPE        0x23    // for body part associations



/*
 *  These are string IDs for use with IOCTL_HID_GET_STRING
 *  They match the string field offsets in Chapter 9 of the USB Spec.
 */
#define HID_STRING_ID_IMANUFACTURER     14
#define HID_STRING_ID_IPRODUCT          15
#define HID_STRING_ID_ISERIALNUMBER     16



#endif  // __HIDPORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hubbusif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    hubbusif.h

Abstract:

    Services exported by the Port driver for use by the hub driver.

Environment:

    Kernel mode
   
--*/

#ifndef   __HUBBUSIF_H__
#define   __HUBBUSIF_H__

/*
  Bus interfaces are supported for Windows XP and later only
*/

#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef PVOID PUSB_DEVICE_HANDLE;

typedef struct _ROOTHUB_PDO_EXTENSION {

    ULONG Signature;

} ROOTHUB_PDO_EXTENSION, *PROOTHUB_PDO_EXTENSION;

// legacy flags
#define USBD_DEVHACK_SLOW_ENUMERATION   0x00000001
#define USBD_DEVHACK_DISABLE_SN         0x00000002
#define USBD_DEVHACK_SET_DIAG_ID        0x00000004



#ifndef USB_BUSIFFN
#define USB_BUSIFFN __stdcall
#endif

/****************************************************************************************************

Module: hubbusif.h

name:  Bus interface for USB Hub
Copyright (c) Microsoft Corporation. All rights reserved

Revision History:

    6-20-99 : created
    1-5-03 : revised 


*******************************************************************************************************/


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_CREATE_USB_DEVICE) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE *,
        IN PUSB_DEVICE_HANDLE,
        IN USHORT,
        IN USHORT
    );


#define CD_ERR_V1       0x00000001

typedef enum _USBPORT_CREATEDEV_ERROR {
    CreateDevErrNotSet = 0,
    CreateDevBadHubDevHandle,
    CreateDevFailedAllocDevHandle,
    CreateDevFailedOpenEndpoint,
    CreateDevFailedAllocDsBuff,
    CreateDevFailedGetDs,
    CreateDevTtNotFound,
    CreateDevBadDevHandlePtr
} USBPORT_CREATEDEV_ERROR;

typedef struct _USB_CD_ERROR_INFORMATION {

    ULONG Version;
    USBPORT_CREATEDEV_ERROR PathError;
    ULONG UlongArg1;
    ULONG UlongArg2;
    NTSTATUS NtStatus;
    UCHAR XtraInfo[64];

} USB_CD_ERROR_INFORMATION, *PUSB_CD_ERROR_INFORMATION;


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_CREATE_USB_DEVICE_EX) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE *,
        IN PUSB_DEVICE_HANDLE,
        IN USHORT,
        IN USHORT,
        IN OUT PUSB_CD_ERROR_INFORMATION,
        IN USHORT
    );


#define ID_ERR_V1       0x00000001

typedef enum _USBPORT_INITDEV_ERROR {
    InitDevErrNotSet = 0,
    InitDevFailedSetAddress,
    InitDevFailedPokeEndpoint,
    InitDevBadDeviceDescriptor,
} USBPORT_INITDEV_ERROR;

typedef struct _USB_ID_ERROR_INFORMATION {

    ULONG Version;
    USBPORT_INITDEV_ERROR PathError;
    ULONG Arg1;
    ULONG UsbAddress;
    NTSTATUS NtStatus;
    USBD_STATUS UsbdStatus;
    UCHAR XtraInfo[64];

} USB_ID_ERROR_INFORMATION, *PUSB_ID_ERROR_INFORMATION;


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_INITIALIZE_USB_DEVICE) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE
    );

typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_INITIALIZE_USB_DEVICE_EX) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE,
        IN OUT PUSB_ID_ERROR_INFORMATION
    );


/*
flags passed to remove device
*/

#define USBD_KEEP_DEVICE_DATA   0x00000001
#define USBD_MARK_DEVICE_BUSY   0x00000002


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_REMOVE_USB_DEVICE) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE,
        IN ULONG
    );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_USB_DESCRIPTORS) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE,
        IN OUT PUCHAR,
        IN OUT PULONG,
        IN OUT PUCHAR,
        IN OUT PULONG
    );

typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_RESTORE_DEVICE) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE,
        IN OUT PUSB_DEVICE_HANDLE
    );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_POTRTHACK_FLAGS) (
        IN PVOID,
        IN OUT PULONG
        );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_DEVICE_INFORMATION) (
        IN PVOID,
        IN PUSB_DEVICE_HANDLE,
        IN OUT PVOID,
        IN ULONG,
        IN OUT PULONG
        );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION) (
        IN PVOID,
        IN OUT PVOID,
        IN ULONG,
        IN OUT PULONG
        );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND) (
        IN PVOID,
        IN BOOLEAN
        );

/*
    Not supported in LH
*/
typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO) (
        IN PVOID,
        IN PDEVICE_OBJECT,
        IN OUT PVOID,
        IN ULONG,
        IN OUT PULONG
        );

/*
    Not supported in LH
*/
typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME) (
        IN PVOID,
        IN OUT PVOID,
        IN ULONG,
        IN OUT PULONG
        );

typedef PVOID
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT) (
        IN PVOID,
        IN PVOID
        );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_INITIALIZE_20HUB) (
        IN PVOID,
        IN PUSB_DEVICE_HANDLE,
        IN ULONG
        );


typedef BOOLEAN
    (USB_BUSIFFN *PUSB_BUSIFFN_IS_ROOT) (
        IN PVOID,
        IN PVOID
    );


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_ACQUIRE_SEMAPHORE) (
        IN PVOID
    );


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_RELEASE_SEMAPHORE) (
        IN PVOID
    );


typedef VOID
    (__stdcall *PRH_INIT_CALLBACK) (
        IN PVOID
        );

typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY) (
        IN PVOID,
        IN PVOID,
        IN PRH_INIT_CALLBACK
        );



typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_FLUSH_TRANSFERS) (
        IN PVOID,
        IN PVOID
    );


typedef ULONG
    (USB_BUSIFFN *PUSB_BUSIFFN_CALC_PIPE_BANDWIDTH) (
        IN PVOID,
        IN PUSBD_PIPE_INFORMATION,
        IN USB_DEVICE_SPEED
    );


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_SET_BUS_WAKE_MODE) (
        IN PVOID,
        IN ULONG
    );


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_SET_DEVICE_FLAG) (
        IN PVOID,
        IN GUID *,
        IN PVOID,
        IN ULONG
    );


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_SET_DEVHANDLE_DATA) (
        IN PVOID,
        IN PVOID,
        IN PDEVICE_OBJECT
    );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_TEST_POINT) (
        IN PVOID,
        IN PVOID,
        IN ULONG,
        IN PVOID
    );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO) (
        IN PVOID,
        IN PUSB_DEVICE_HANDLE,
        IN OUT PVOID,
        IN ULONG,
        IN OUT PULONG
        );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_WAIT_ASYNC_POWERUP) (
        IN PVOID
        );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_GET_DEVICE_ADDRESS) (
        IN PVOID,
        IN PUSB_DEVICE_HANDLE,
        IN OUT PUSHORT DeviceAddress
        );


typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_DEREF_DEVICE_HANDLE) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE,
        IN PVOID,
        IN ULONG
    );


typedef NTSTATUS
    (USB_BUSIFFN *PUSB_BUSIFFN_REF_DEVICE_HANDLE) (
        IN PVOID,
        IN OUT PUSB_DEVICE_HANDLE,
        IN PVOID,
        IN ULONG
    );


#define USB_IDLE_NOT_READY                      0
#define USB_IDLE_READY                          1

typedef ULONG
    (USB_BUSIFFN *PUSB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE) (
        IN PVOID,
        IN PUSB_DEVICE_HANDLE,
        IN ULONG
    );



#define USB_BUSIF_HUB_VERSION_0         0x0000
#define USB_BUSIF_HUB_VERSION_1         0x0001
#define USB_BUSIF_HUB_VERSION_2         0x0002
#define USB_BUSIF_HUB_VERSION_3         0x0003
#define USB_BUSIF_HUB_VERSION_4         0x0004
#define USB_BUSIF_HUB_VERSION_5         0x0005
#define USB_BUSIF_HUB_VERSION_6         0x0006

/* {B2BB8C0A-5AB4-11d3-A8CD-00C04F68747A}*/
DEFINE_GUID(USB_BUS_INTERFACE_HUB_GUID,
0xb2bb8c0a, 0x5ab4, 0x11d3, 0xa8, 0xcd, 0x0, 0xc0, 0x4f, 0x68, 0x74, 0x7a);

typedef struct _USB_BUS_INTERFACE_HUB_V0 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

} USB_BUS_INTERFACE_HUB_V0, *PUSB_BUS_INTERFACE_HUB_V0;


typedef struct _USB_BUS_INTERFACE_HUB_V1 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

    //
    // functions for the hub driver
    //
    PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
    PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
    PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
    PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
    PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;

    PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
    PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;


} USB_BUS_INTERFACE_HUB_V1, *PUSB_BUS_INTERFACE_HUB_V1;

/*
*/

typedef struct _USB_BUS_INTERFACE_HUB_V2 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

    //
    // functions for the hub driver
    //
    PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
    PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
    PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
    PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
    PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;

    PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
    PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;

    //
    // new functions for version 2
    //
    PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
    PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
    PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
    PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
    PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;    
    PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;

} USB_BUS_INTERFACE_HUB_V2, *PUSB_BUS_INTERFACE_HUB_V2;


typedef struct _USB_BUS_INTERFACE_HUB_V3 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

    //
    // functions for the hub driver
    //
    PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
    PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
    PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
    PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
    PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;

    PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
    PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;

    //
    // new functions for version 2
    //
    PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
    PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
    PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
    PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
    PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
    PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;

    //
    // new for version 3
    //

    PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;

} USB_BUS_INTERFACE_HUB_V3, *PUSB_BUS_INTERFACE_HUB_V3;


typedef struct _USB_BUS_INTERFACE_HUB_V4 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

    //
    // functions for the hub driver
    //
    PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
    PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
    PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
    PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
    PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;

    PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
    PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;

    //
    // new functions for version 2
    //
    PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
    PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
    PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
    PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
    PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
    PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;

    //
    // new for version 3
    //

    PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;

    //
    // new for version 4
    //

    PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;

} USB_BUS_INTERFACE_HUB_V4, *PUSB_BUS_INTERFACE_HUB_V4;


typedef struct _USB_BUS_INTERFACE_HUB_V5 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

    //
    // functions for the hub driver
    //
    PUSB_BUSIFFN_CREATE_USB_DEVICE CreateUsbDevice;
    PUSB_BUSIFFN_INITIALIZE_USB_DEVICE InitializeUsbDevice;
    PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
    PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
    PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;

    PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
    PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;

    //
    // new functions for version 2
    //
    PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
    PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
    PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
    PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
    PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
    PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;

    //
    // new for version 3
    //

    PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;

    //
    // new for version 4
    //

    PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;

    // new for version 5

    PUSB_BUSIFFN_SET_DEVHANDLE_DATA SetDeviceHandleData;

} USB_BUS_INTERFACE_HUB_V5, *PUSB_BUS_INTERFACE_HUB_V5;


typedef struct _USB_BUS_INTERFACE_HUB_V6 {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    // interface specific entries go here

    //
    // functions for the hub driver
    //
    PUSB_BUSIFFN_CREATE_USB_DEVICE_EX CreateUsbDevice;
    PUSB_BUSIFFN_INITIALIZE_USB_DEVICE_EX InitializeUsbDevice;
    PUSB_BUSIFFN_GET_USB_DESCRIPTORS GetUsbDescriptors;
    PUSB_BUSIFFN_REMOVE_USB_DEVICE RemoveUsbDevice;
    PUSB_BUSIFFN_RESTORE_DEVICE RestoreUsbDevice;

    PUSB_BUSIFFN_GET_POTRTHACK_FLAGS GetPortHackFlags;
    PUSB_BUSIFFN_GET_DEVICE_INFORMATION QueryDeviceInformation;

    //
    // new functions for version 2
    //
    PUSB_BUSIFFN_GET_CONTROLLER_INFORMATION GetControllerInformation;
    PUSB_BUSIFFN_CONTROLLER_SELECTIVE_SUSPEND ControllerSelectiveSuspend;
    PUSB_BUSIFFN_GET_EXTENDED_HUB_INFO GetExtendedHubInformation;
    PUSB_BUSIFFN_GET_ROOTHUB_SYM_NAME GetRootHubSymbolicName;
    PUSB_BUSIFFN_GET_DEVICE_BUSCONTEXT GetDeviceBusContext;
    PUSB_BUSIFFN_INITIALIZE_20HUB Initialize20Hub;

    //
    // new for version 3
    //

    PUSB_BUSIFFN_ROOTHUB_INIT_NOTIFY RootHubInitNotification;

    //
    // new for version 4
    //

    PUSB_BUSIFFN_FLUSH_TRANSFERS FlushTransfers;

    // new for version 5

    PUSB_BUSIFFN_SET_DEVHANDLE_DATA SetDeviceHandleData;

    // new for version 6 - Longhorn

    PUSB_BUSIFFN_IS_ROOT HubIsRoot;
    PUSB_BUSIFFN_ACQUIRE_SEMAPHORE AcquireBusSemaphore;
    PUSB_BUSIFFN_RELEASE_SEMAPHORE ReleaseBusSemaphore;
    PUSB_BUSIFFN_CALC_PIPE_BANDWIDTH CaculatePipeBandwidth;
    PUSB_BUSIFFN_SET_BUS_WAKE_MODE SetBusSystemWakeMode;
    PUSB_BUSIFFN_SET_DEVICE_FLAG SetDeviceFlag;
    PUSB_BUSIFFN_TEST_POINT HubTestPoint;
    PUSB_BUSIFFN_GET_DEVICE_PERFORMANCE_INFO GetDevicePerformanceInfo;
    PUSB_BUSIFFN_WAIT_ASYNC_POWERUP WaitAsyncPowerUp;
    PUSB_BUSIFFN_GET_DEVICE_ADDRESS GetDeviceAddress;
    PUSB_BUSIFFN_REF_DEVICE_HANDLE RefDeviceHandle;
    PUSB_BUSIFFN_DEREF_DEVICE_HANDLE DerefDeviceHandle;
    PUSB_BUSIFFN_SET_DEVICE_HANDLE_IDLE_READY_STATE SetDeviceHandleIdleReadyState;

} USB_BUS_INTERFACE_HUB_V6, *PUSB_BUS_INTERFACE_HUB_V6;


#define USB_BUSIF_HUB_MIDUMP_VERSION_0         0x0000

/* {c5485f21-4e81-4a23-a8f9-d8518af45c3d} */
DEFINE_GUID(USB_BUS_INTERFACE_HUB_MINIDUMP_GUID,
0xc5485f21, 0x4e81, 0x4a23, 0xa8, 0xf9, 0xd8, 0x51, 0x8a, 0xf4, 0x5c, 0x38);



typedef VOID
    (USB_BUSIFFN *PUSB_BUSIFFN_SET_MINIDUMP_FLAGS) (
        IN PVOID
    );



/*
*/

typedef struct _USB_BUS_INTERFACE_HUB_MINIDUMP {

    USHORT Size;
    USHORT Version;
    // returns
    PVOID BusContext;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // functions for the hub driver
    //

    PUSB_BUSIFFN_SET_MINIDUMP_FLAGS SetUsbPortMiniDumpFlags;

} USB_BUS_INTERFACE_HUB_MINIDUMP, *PUSB_BUS_INTERFACE_HUB_MINIDUMP;


/*
    The following structures are used by the GetDeviceInformation APIs
*/

#include <pshpack1.h>

typedef struct _USB_PIPE_INFORMATION_0 {

    /* pad descriptors to maintain DWORD alignment */
    USB_ENDPOINT_DESCRIPTOR EndpointDescriptor;
    UCHAR ED_Pad[1];

    ULONG ScheduleOffset;
} USB_PIPE_INFORMATION_0, *PUSB_PIPE_INFORMATION_0;

typedef struct _USB_LEVEL_INFORMATION {

    /* inputs: information level requested */
    ULONG InformationLevel;

    /* outputs: */
    ULONG ActualLength;

} USB_LEVEL_INFORMATION, *PUSB_LEVEL_INFORMATION;

typedef struct _USB_DEVICE_INFORMATION_0 {

    /* inputs: information level requested */
    ULONG InformationLevel;

    /* outputs: */
    ULONG ActualLength;

    /* begin level_0 information */
    ULONG PortNumber;

    /* pad descriptors to maintain DWORD alignment */
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
    UCHAR DD_pad[2];

    UCHAR CurrentConfigurationValue;
    UCHAR ReservedMBZ;
    USHORT DeviceAddress;

    ULONG HubAddress;

    USB_DEVICE_SPEED DeviceSpeed;
    USB_DEVICE_TYPE DeviceType;

    ULONG NumberOfOpenPipes;

    USB_PIPE_INFORMATION_0 PipeList[1];

} USB_DEVICE_INFORMATION_0, *PUSB_DEVICE_INFORMATION_0;



typedef struct _USB_CONTROLLER_INFORMATION_0 {

    ULONG InformationLevel;
    ULONG ActualLength;
    BOOLEAN SelectiveSuspendEnabled;
    BOOLEAN IsHighSpeedController;

} USB_CONTROLLER_INFORMATION_0, *PUSB_CONTROLLER_INFORMATION_0;


typedef struct _USB_CONTROLLER_INFORMATION_1 {

    ULONG InformationLevel;
    ULONG ActualLength;
    BOOLEAN SelectiveSuspendEnabled;
    BOOLEAN IsHighSpeedController;
    ULONG HcBusNumber;
    ULONG HcBusDevice;
    ULONG HcBusFunction;

} USB_CONTROLLER_INFORMATION_1, *PUSB_CONTROLLER_INFORMATION_1;



/*
    Structures that define extended hub port characteristics
*/

typedef struct _USB_EXTPORT_INFORMATION_0 {
    /*
       physical port ie number passed in control commands 1, 2, 3..255
    */
    ULONG                 PhysicalPortNumber;
    /*
       label on port may not natch the physical number
     */
    ULONG                 PortLabelNumber;

    USHORT                VidOverride;
    USHORT                PidOverride;
    /*
       extended port attributes as defined in usb.h
    */
    ULONG                 PortAttributes;
} USB_EXTPORT_INFORMATION_0, *PUSB_EXTPORT_INFORMATION;


typedef struct _USB_EXTHUB_INFORMATION_0 {

    /* inputs: information level requested */
    ULONG InformationLevel;

    /* begin level_0 information */
    ULONG NumberOfPorts;

    /* hubs don't have > 255 ports */
    USB_EXTPORT_INFORMATION_0 Port[255];

} USB_EXTHUB_INFORMATION_0, *PUSB_EXTHUB_INFORMATION_0;

/*
* Structures used by the GetPerformanceInfo APIs
*/

typedef struct _USB_DEVICE_PERFORMANCE_INFO_0 {

    /* inputs: information level requested */
    ULONG InformationLevel;

    /* outputs: */
    ULONG ActualLength;

    // total BulkBytes transfered for this device
    ULONG BulkBytes;
    ULONG BulkUrbCount;

    // total control bytes transfered for this device
    ULONG ControlDataBytes;
    ULONG ControlUrbCount;

    // total iso bytes transfered for this device
    ULONG IsoBytes;
    ULONG IsoUrbCount;

    // total interrupt bytes transfered for this device
    ULONG InterruptBytes;
    ULONG InterruptUrbCount;

    // BW in bytes alloced in bits/32ms
    ULONG AllocedInterrupt[6];
    ULONG AllocedIso;

    // Total BW available on the bus in bits/32ms
    ULONG Total32secBandwidth;
    
    // Total BW available on the device's TT in bits/32ms
    ULONG TotalTtBandwidth;
    
    // Count of the total time left between scheduling iso transfers and their start frame
    ULONG TotalIsoLatency;
    
    // ISO packet errors, etc, that are NOT late
    ULONG DroppedIsoPackets;
    
    // Number of transfer URBs completing with errors
    ULONG TransferErrors;

} USB_DEVICE_PERFORMANCE_INFO_0, *PUSB_DEVICE_PERFORMANCE_INFO_0;

#include <poppack.h>

#endif

#endif  /* __HUBBUSIF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\hvgdk.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    HvGdk.h

Abstract:

    Type definitions for the hypervisor guest interface.

Author:

    Hypervisor Engineering Team 01-May-2005

--*/

#if !defined(_HVGDK_)
#define _HVGDK_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#ifdef _NTDDK_
#if(NTDDI_VERSION >= NTDDI_WS08) // available in Windows Server 2008 and above
#define HVGDK_CURRENT_DDI_VERSION     1
#endif // available in Windows Server 2008 and above
#endif

#pragma warning(disable:4200) // zero length array
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int
#pragma warning(disable:4324) // structure was padded due to __declspec(align())


//
// Define a 128bit type.
//
typedef struct DECLSPEC_ALIGN(16) _HV_UINT128 {

    UINT64  Low64;
    UINT64  High64;

} HV_UINT128, *PHV_UINT128;


//
// Define an alignment for structures passed via hypercall.
//
#define HV_CALL_ALIGNMENT   8

#define HV_CALL_ATTRIBUTES DECLSPEC_ALIGN(HV_CALL_ALIGNMENT)
#define HV_CALL_ATTRIBUTES_ALIGNED(__alignment__) DECLSPEC_ALIGN(__alignment__)

//
// Memory Types
//
//
// System physical addresses (SPAs) define the physical address space of the underlying
// hardware. There is only one system physical address space for the entire machine.
//
// Guest physical addresses (GPAs) define the guest's view of physical memory.
// GPAs can be mapped to underlying SPAs. There is one guest physical address space per
// partition.
//
// Guest virtual addresses (GVAs) are used within the guest when it enables address
// translation and provides a valid guest page table.
//

typedef UINT64 HV_SPA, *PHV_SPA;
typedef UINT64 HV_GPA, *PHV_GPA;
typedef UINT64 HV_GVA, *PHV_GVA;

#define HV_X64_PAGE_SIZE (4096)
#define HV_PAGE_SIZE HV_X64_PAGE_SIZE

typedef UINT64 HV_SPA_PAGE_NUMBER, *PHV_SPA_PAGE_NUMBER;
typedef UINT64 HV_GPA_PAGE_NUMBER, *PHV_GPA_PAGE_NUMBER;
typedef UINT64 HV_GVA_PAGE_NUMBER, *PHV_GVA_PAGE_NUMBER;

typedef const HV_SPA_PAGE_NUMBER *PCHV_SPA_PAGE_NUMBER;
typedef const HV_GPA_PAGE_NUMBER *PCHV_GPA_PAGE_NUMBER;
typedef const HV_GVA_PAGE_NUMBER *PCHV_GVA_PAGE_NUMBER;

typedef UINT16 HV_IO_PORT, *PHV_IO_PORT;

//
// Forward declare the loader block.
//
typedef struct _HV_LOADER_BLOCK *PHV_LOADER_BLOCK;
//
// Status codes for hypervisor operations.
//
typedef UINT16 HV_STATUS, *PHV_STATUS;

//
// MessageId: HV_STATUS_SUCCESS
//
// MessageText:
//
// The specified hypercall succeeded
//
#define HV_STATUS_SUCCESS                ((HV_STATUS)0x0000)

//
// MessageId: HV_STATUS_INVALID_HYPERCALL_CODE
//
// MessageText:
//
// The hypervisor does not support the operation because the specified hypercall code is not supported.
//
#define HV_STATUS_INVALID_HYPERCALL_CODE ((HV_STATUS)0x0002)

//
// MessageId: HV_STATUS_INVALID_HYPERCALL_INPUT
//
// MessageText:
//
// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
//
#define HV_STATUS_INVALID_HYPERCALL_INPUT ((HV_STATUS)0x0003)

//
// MessageId: HV_STATUS_INVALID_ALIGNMENT
//
// MessageText:
//
// The hypervisor could not perform the operation beacuse a parameter has an invalid alignment.
//
#define HV_STATUS_INVALID_ALIGNMENT      ((HV_STATUS)0x0004)

//
// MessageId: HV_STATUS_INVALID_PARAMETER
//
// MessageText:
//
// The hypervisor could not perform the operation beacuse an invalid parameter was specified.
//
#define HV_STATUS_INVALID_PARAMETER      ((HV_STATUS)0x0005)

//
// MessageId: HV_STATUS_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified object was denied.
//
#define HV_STATUS_ACCESS_DENIED          ((HV_STATUS)0x0006)

//
// MessageId: HV_STATUS_INVALID_PARTITION_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
//
#define HV_STATUS_INVALID_PARTITION_STATE ((HV_STATUS)0x0007)

//
// MessageId: HV_STATUS_OPERATION_DENIED
//
// MessageText:
//
// The operation is not allowed in the current state.
//
#define HV_STATUS_OPERATION_DENIED       ((HV_STATUS)0x0008)

//
// MessageId: HV_STATUS_UNKNOWN_PROPERTY
//
// MessageText:
//
// The hypervisor does not recognize the specified partition property.
//
#define HV_STATUS_UNKNOWN_PROPERTY       ((HV_STATUS)0x0009)

//
// MessageId: HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The specified value of a partition property is out of range or violates an invariant.
//
#define HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE ((HV_STATUS)0x000A)

//
// MessageId: HV_STATUS_INSUFFICIENT_MEMORY
//
// MessageText:
//
// There is not enough memory in the hypervisor pool to complete the operation.
//
#define HV_STATUS_INSUFFICIENT_MEMORY    ((HV_STATUS)0x000B)

//
// MessageId: HV_STATUS_PARTITION_TOO_DEEP
//
// MessageText:
//
// The maximum partition depth has been exceeded for the partition hierarchy.
//
#define HV_STATUS_PARTITION_TOO_DEEP     ((HV_STATUS)0x000C)

//
// MessageId: HV_STATUS_INVALID_PARTITION_ID
//
// MessageText:
//
// A partition with the specified partition Id does not exist.
//
#define HV_STATUS_INVALID_PARTITION_ID   ((HV_STATUS)0x000D)

//
// MessageId: HV_STATUS_INVALID_VP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified VP index is invalid.
//
#define HV_STATUS_INVALID_VP_INDEX       ((HV_STATUS)0x000E)

//
// MessageId: HV_STATUS_NOT_FOUND
//
// MessageText:
//
// The iteration is complete; no addition items in the iteration could be found.
//
#define HV_STATUS_NOT_FOUND              ((HV_STATUS)0x0010)

//
// MessageId: HV_STATUS_INVALID_PORT_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified port identifier is invalid.
//
#define HV_STATUS_INVALID_PORT_ID        ((HV_STATUS)0x0011)

//
// MessageId: HV_STATUS_INVALID_CONNECTION_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified connection identifier is invalid.
//
#define HV_STATUS_INVALID_CONNECTION_ID  ((HV_STATUS)0x0012)

//
// MessageId: HV_STATUS_INSUFFICIENT_BUFFERS
//
// MessageText:
//
// You did not supply enough message buffers to send a message.
//
#define HV_STATUS_INSUFFICIENT_BUFFERS   ((HV_STATUS)0x0013)

//
// MessageId: HV_STATUS_NOT_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has not been acknowledged.
//
#define HV_STATUS_NOT_ACKNOWLEDGED       ((HV_STATUS)0x0014)

//
// MessageId: HV_STATUS_INVALID_VP_STATE
//
// MessageText:
//
// A virtual processor is not in the correct state for the performance of the indicated operation.
//
#define HV_STATUS_INVALID_VP_STATE       ((HV_STATUS)0x0015)

//
// MessageId: HV_STATUS_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has already been acknowledged.
//
#define HV_STATUS_ACKNOWLEDGED           ((HV_STATUS)0x0016)

//
// MessageId: HV_STATUS_INVALID_SAVE_RESTORE_STATE
//
// MessageText:
//
// The indicated partition is not in a valid state for saving or restoring.
//
#define HV_STATUS_INVALID_SAVE_RESTORE_STATE ((HV_STATUS)0x0017)

//
// MessageId: HV_STATUS_INVALID_SYNIC_STATE
//
// MessageText:
//
// The hypervisor could not complete the operation because a required feature of the synthetic interrupt controller (SynIC) was disabled.
//
#define HV_STATUS_INVALID_SYNIC_STATE    ((HV_STATUS)0x0018)

//
// MessageId: HV_STATUS_OBJECT_IN_USE
//
// MessageText:
//
// The hypervisor could not perform the operation because the object or value was either already in use or being used for a purpose that would not permit completing the operation.
//
#define HV_STATUS_OBJECT_IN_USE          ((HV_STATUS)0x0019)

//
// MessageId: HV_STATUS_INVALID_PROXIMITY_DOMAIN_INFO
//
// MessageText:
//
// The proximity domain information is invalid.
//
#define HV_STATUS_INVALID_PROXIMITY_DOMAIN_INFO ((HV_STATUS)0x001A)

//
// MessageId: HV_STATUS_NO_DATA
//
// MessageText:
//
// An attempt to retrieve debugging data failed because none was available.
//
#define HV_STATUS_NO_DATA                ((HV_STATUS)0x001B)

//
// MessageId: HV_STATUS_INACTIVE
//
// MessageText:
//
// The physical connection being used for debuggging has not recorded any receive activity since the last operation.
//
#define HV_STATUS_INACTIVE               ((HV_STATUS)0x001C)

//
// MessageId: HV_STATUS_NO_RESOURCES
//
// MessageText:
//
// There are not enough resources to complete the operation.
//
#define HV_STATUS_NO_RESOURCES           ((HV_STATUS)0x001D)

//
// MessageId: HV_STATUS_FEATURE_UNAVAILABLE
//
// MessageText:
//
// A hypervisor feature is not available to the user.
//
#define HV_STATUS_FEATURE_UNAVAILABLE    ((HV_STATUS)0x001E)

//
// MessageId: HV_STATUS_PARTIAL_PACKET
//
// MessageText:
//
// The debug packet returned is only a partial packet due to an io error.
//
#define HV_STATUS_PARTIAL_PACKET         ((HV_STATUS)0x001F)



//
// Time in the hypervisor is measured in 100 nanosecond units
//
typedef UINT64 HV_NANO100_TIME,     *PHV_NANO100_TIME;
typedef UINT64 HV_NANO100_DURATION, *PHV_NANO100_DURATION;

//
// An architecture is a set of processor instruction sets and operating modes
//

typedef enum _HV_ARCHITECTURE
{
    HvArchitectureX64,
    HvArchitectureX86,
    HvArchitectureMaximum
} HV_ARCHITECTURE, *PHV_ARCHITECTURE;

typedef union _HV_X64_FP_REGISTER
{
    HV_UINT128 AsUINT128;
    struct
    {
        UINT64 Mantissa;
        UINT64 BiasedExponent:15;
        UINT64 Sign:1;
        UINT64 Reserved:48;
    };
} HV_X64_FP_REGISTER, *PHV_X64_FP_REGISTER;

typedef union _HV_X64_FP_CONTROL_STATUS_REGISTER
{
    HV_UINT128 AsUINT128;
    struct
    {
        UINT16 FpControl;
        UINT16 FpStatus;
        UINT8  FpTag;
        UINT8  IgnNe:1;
        UINT8  Reserved:7;
        UINT16 LastFpOp;
        union
        {
            // Long Mode
            UINT64 LastFpRip;
            // 32 Bit Mode
            struct
            {
                UINT32 LastFpEip;
                UINT16 LastFpCs;
            };
        };
    };
} HV_X64_FP_CONTROL_STATUS_REGISTER, *PHV_X64_FP_CONTROL_STATUS_REGISTER;

typedef union _HV_X64_XMM_CONTROL_STATUS_REGISTER
{
    HV_UINT128 AsUINT128;
    struct
    {
        union
        {
            // Long Mode
            UINT64 LastFpRdp;
            // 32 Bit Mode
            struct
            {
                UINT32 LastFpDp;
                UINT16 LastFpDs;
            };
        };
        UINT32 XmmStatusControl;
        UINT32 XmmStatusControlMask;
    };
} HV_X64_XMM_CONTROL_STATUS_REGISTER, *PHV_X64_XMM_CONTROL_STATUS_REGISTER;

typedef struct _HV_X64_SEGMENT_REGISTER
{
    UINT64 Base;
    UINT32 Limit;
    UINT16 Selector;
    union
    {
        struct
        {
            UINT16 SegmentType:4;
            UINT16 NonSystemSegment:1;
            UINT16 DescriptorPrivilegeLevel:2;
            UINT16 Present:1;
            UINT16 Reserved:4;
            UINT16 Available:1;
            UINT16 Long:1;
            UINT16 Default:1;
            UINT16 Granularity:1;
        };
        UINT16 Attributes;
    };

} HV_X64_SEGMENT_REGISTER, *PHV_X64_SEGMENT_REGISTER;

typedef struct _HV_X64_TABLE_REGISTER
{
    UINT16     Pad[3];
    UINT16     Limit;
    UINT64     Base;
} HV_X64_TABLE_REGISTER, *PHV_X64_TABLE_REGISTER;

typedef union _HV_X64_FP_MMX_REGISTER
{
    HV_UINT128          AsUINT128;
    HV_X64_FP_REGISTER  Fp;
    UINT64              Mmx;
} HV_X64_FP_MMX_REGISTER, *PHV_X64_FP_MMX_REGISTER;

typedef DECLSPEC_ALIGN(16) union _HV_X64_FX_REGISTERS
{
    struct
    {
        HV_X64_FP_CONTROL_STATUS_REGISTER   FpControlStatus;
        HV_X64_XMM_CONTROL_STATUS_REGISTER  XmmControlStatus;
        HV_X64_FP_MMX_REGISTER              FpMmx[8];
        HV_UINT128                          Xmm[16];
    };

    //
    // The FX Save Area is defined to be 512 bytes in size
    //
    UINT8 FxSaveArea[512];

} HV_X64_FX_REGISTERS, *PHV_X64_FX_REGISTERS;

typedef struct _HV_X64_CONTEXT
{

    //
    // The Initial APIC ID pseudo register. This is the value returned
    // by CPUID.
    //
    UINT64 InitialApicId;

    //
    // 16 64 bit general purpose registers, instruction pointer and
    // flags
    //

    UINT64 Rax;
    UINT64 Rbx;
    UINT64 Rcx;
    UINT64 Rdx;
    UINT64 Rsi;
    UINT64 Rdi;
    UINT64 Rbp;
    UINT64 Rsp;
    UINT64 R8;
    UINT64 R9;
    UINT64 R10;
    UINT64 R11;
    UINT64 R12;
    UINT64 R13;
    UINT64 R14;
    UINT64 R15;

    UINT64 Rip;
    UINT64 Rflags;

    //
    // Control Registers - on 32 bit platforms the upper 32 bits are
    // ignored. Efer is actually an Msr but it acts as an extension to
    // Cr4 and as such is treated as a processor register. Cr8 is only
    // valid on 64 bit systems.
    //

    UINT64 Cr0;
    UINT64 Cr2;
    UINT64 Cr3;
    UINT64 Cr4;
    UINT64 Cr8;
    UINT64 Efer;

    //
    // Debug Registers - on 32 bit platforms the upper 32 bits are
    // ignored
    //

    UINT64 Dr0;
    UINT64 Dr1;
    UINT64 Dr2;
    UINT64 Dr3;
    UINT64 Dr6;
    UINT64 Dr7;

    //
    // Global and Interrupt Descriptor tables
    //

    HV_X64_TABLE_REGISTER Idtr;
    HV_X64_TABLE_REGISTER Gdtr;

    //
    // Segment selector registers together with their hidden state.
    //

    HV_X64_SEGMENT_REGISTER Cs;
    HV_X64_SEGMENT_REGISTER Ds;
    HV_X64_SEGMENT_REGISTER Es;
    HV_X64_SEGMENT_REGISTER Fs;
    HV_X64_SEGMENT_REGISTER Gs;
    HV_X64_SEGMENT_REGISTER Ss;
    HV_X64_SEGMENT_REGISTER Tr;
    HV_X64_SEGMENT_REGISTER Ldtr;

    //
    // MSRs needed for virtualization
    //

    UINT64 KernelGsBase;
    UINT64 Star;
    UINT64 Lstar;
    UINT64 Cstar;
    UINT64 Sfmask;
    UINT64 SysenterCs;
    UINT64 SysenterEip;
    UINT64 SysenterEsp;

    UINT64 MsrCrPat;

    //
    // Local APIC state.
    //

    UINT32 LocalApicId;
    UINT32 LocalApicVersion;
    UINT32 LocalApicLdr;
    UINT32 LocalApicDfr;
    UINT32 LocalApicSpurious;
    UINT32 LocalApicIcrLow;
    UINT32 LocalApicIcrHigh;
    UINT32 LocalApicIsr[8];
    UINT32 LocalApicTmr[8];
    UINT32 LocalApicLvtTimer;
    UINT32 LocalApicLvtPerfmon;
    UINT32 LocalApicLvtLint0;
    UINT32 LocalApicLvtLint1;
    UINT32 LocalApicCurrentCount;
    UINT32 LocalApicInitialCount;
    UINT32 LocalApicDivider;
    UINT64 LocalApicBaseMsr;

    //
    // x87 Floating point, MMX and XMM registers formatted as by
    // fxsave/fxrstor
    //

    HV_X64_FX_REGISTERS FxRegisters;

} HV_X64_CONTEXT, *PHV_X64_CONTEXT;

#define HV_VIRTUAL_PROCESSOR_REGISTERS_VERSION 1

typedef struct _HV_VP_CONTEXT
{
    //
    // The version of the HV_VP_CONTEXT structure
    //

    UINT32 Version;

    //
    // The architecture of these registers
    //

    HV_ARCHITECTURE Architecture;

    union
    {
        HV_X64_CONTEXT x64;
    };

} HV_VP_CONTEXT, *PHV_VP_CONTEXT;

typedef UINT16  HV_STATISTICS_GROUP_TYPE;
typedef UINT16  HV_STATISTICS_GROUP_LENGTH;

typedef struct _HV_STATISTICS_GROUP_VERSION
{
    UINT16    Minor;
    UINT16    Major;

} HV_STATISTICS_GROUP_VERSION;

//
// Group header
//
typedef struct DECLSPEC_ALIGN(2) _HV_STATISTICS_GROUP_HEADER
{

    HV_STATISTICS_GROUP_TYPE    Type;
    HV_STATISTICS_GROUP_VERSION Version;
    HV_STATISTICS_GROUP_LENGTH  Length;

} HV_STATISTICS_GROUP_HEADER, *PHV_STATISTICS_GROUP_HEADER;

#define HV_STATISTICS_GROUP_END_OF_LIST         0
#define HV_STATISTICS_GROUP_END_OF_PAGE         1

//
// Pseudo-group to use in manifest for counters accessible through hypercalls.
//
#define HV_STATISTICS_GROUP_HYPERCALL_BASED     15

//
// Definitions for the hypervisor counters statistics page
//
#define HV_STATISTICS_GROUP_HVA_ID              2
#define HV_STATISTICS_GROUP_HVA_VERSION         0x00010000
#define HV_STATISTICS_GROUP_HVV_ID              3
#define HV_STATISTICS_GROUP_HVV_VERSION         0x00010000
#define HV_STATISTICS_GROUP_HVI_ID              14
#define HV_STATISTICS_GROUP_HVI_VERSION         0x00010000

//
// Definitions for the logical processor counters statistics page
//
#define HV_STATISTICS_GROUP_LPA_ID              2
#define HV_STATISTICS_GROUP_LPA_VERSION         0x00010000
#define HV_STATISTICS_GROUP_LPV_ID              3
#define HV_STATISTICS_GROUP_LPV_VERSION         0x00010000
#define HV_STATISTICS_GROUP_LPI_ID              14
#define HV_STATISTICS_GROUP_LPI_VERSION         0x00010000

//
// Definitions for the partition counters statistics page
//
#define HV_STATISTICS_GROUP_PTA_ID              2
#define HV_STATISTICS_GROUP_PTA_VERSION         0x00010000
#define HV_STATISTICS_GROUP_PTV_ID              3
#define HV_STATISTICS_GROUP_PTV_VERSION         0x00010000
#define HV_STATISTICS_GROUP_PTI_ID              14
#define HV_STATISTICS_GROUP_PTI_VERSION         0x00010000

//
// Definitions for the virtual processor statistics page
//
#define HV_STATISTICS_GROUP_VPA_ID              2
#define HV_STATISTICS_GROUP_VPA_VERSION         0x00010000
#define HV_STATISTICS_GROUP_VPV_ID              3
#define HV_STATISTICS_GROUP_VPV_VERSION         0x00010000
#define HV_STATISTICS_GROUP_VPI_ID              14
#define HV_STATISTICS_GROUP_VPI_VERSION         0x00010000

//
// Maximum counters allowed per group. Calculated for the case when group
// occupies full page: there will be two headers (one for the group and one
// terminating the list).
//

#define HV_ST_MAX_COUNTERS_PER_GROUP \
    ((HV_PAGE_SIZE - 2 * sizeof(HV_STATISTICS_GROUP_HEADER)) / sizeof(UINT64))

//
// Definition of the counters structure.
//

typedef struct _HV_STATS_PAGE
{
    UINT64      Data[HV_PAGE_SIZE / sizeof(UINT64)];

} HV_STATS_PAGE, *PHV_STATS_PAGE;

//
// Definition for the stats object types.
//

typedef enum _HV_STATS_OBJECT_TYPE
{
    //
    // Global stats objects
    //

    HvStatsObjectHypervisor       = 0x00000001,
    HvStatsObjectLogicalProcessor = 0x00000002,

    //
    // Local stats objects
    //

    HvStatsObjectPartition        = 0x00010001,
    HvStatsObjectVp               = 0x00010002

} HV_STATS_OBJECT_TYPE;

//
// Namespace definition helper macros.
//

#define ST_DECLARE_HV_COUNTER(x,id)     StHvCounter##x = id,
#define ST_DECLARE_LP_COUNTER(x,id)     StLpCounter##x = id,
#define ST_DECLARE_PT_COUNTER(x,id)     StPtCounter##x = id,
#define ST_DECLARE_VP_COUNTER(x,id)     StVpCounter##x = id,

//
// Conversion macros: from "human" to prefixed index names.
//

#define ST_HV_COUNTER_NAME(x)           StHvCounter##x
#define ST_LP_COUNTER_NAME(x)           StLpCounter##x
#define ST_PT_COUNTER_NAME(x)           StPtCounter##x
#define ST_VP_COUNTER_NAME(x)           StVpCounter##x

//
// Hypervisor global counter set
//
typedef enum _HV_HYPERVISOR_COUNTER 
{

    ST_DECLARE_HV_COUNTER(LogicalProcessors, 1)
    ST_DECLARE_HV_COUNTER(Partitions, 2)
    ST_DECLARE_HV_COUNTER(TotalPages, 3)
    ST_DECLARE_HV_COUNTER(VirtualProcessors, 4)
    ST_DECLARE_HV_COUNTER(MonitoredNotifications, 5)

    ST_HV_COUNTER_NAME(MAXIMUM)

} HV_HYPERVISOR_COUNTER;

#define HV_STATISTICS_GROUP_HVA_LENGTH 40
#define HV_STATISTICS_GROUP_HVV_LENGTH 0

//
// Hypervisor Logical Processor counter set
//
typedef enum _HV_CPU_COUNTER 
{

    ST_DECLARE_LP_COUNTER(GlobalTime, 1)
    ST_DECLARE_LP_COUNTER(TotalRunTime, 2)
    ST_DECLARE_LP_COUNTER(HypervisorRunTime, 3)
    ST_DECLARE_LP_COUNTER(HardwareInterrupts, 4)
    ST_DECLARE_LP_COUNTER(ContextSwitches, 5)
    ST_DECLARE_LP_COUNTER(InterProcessorInterrupts, 6)
    ST_DECLARE_LP_COUNTER(SchedulerInterrupts, 7)
    ST_DECLARE_LP_COUNTER(TimerInterrupts, 8)
    ST_DECLARE_LP_COUNTER(InterProcessorInterruptsSent, 9)
    ST_DECLARE_LP_COUNTER(ProcessorHalts, 10)
    ST_DECLARE_LP_COUNTER(MonitorTransitionCost, 11)
    ST_DECLARE_LP_COUNTER(ContextSwitchTime, 12)
    ST_DECLARE_LP_COUNTER(C1TransitionsCount, 13)
    ST_DECLARE_LP_COUNTER(C1RunTime, 14)
    ST_DECLARE_LP_COUNTER(C2TransitionsCount, 15)
    ST_DECLARE_LP_COUNTER(C2RunTime, 16)
    ST_DECLARE_LP_COUNTER(C3TransitionsCount, 17)
    ST_DECLARE_LP_COUNTER(C3RunTime, 18)

    ST_LP_COUNTER_NAME(MAXIMUM)

} HV_CPU_COUNTER;

#define HV_STATISTICS_GROUP_LPA_LENGTH 144
#define HV_STATISTICS_GROUP_LPV_LENGTH 0

//
// Partition counter set
//
typedef enum _HV_PROCESS_COUNTER 
{

    ST_DECLARE_PT_COUNTER(VirtualProcessors, 1)

    ST_DECLARE_PT_COUNTER(PageTables, 3)
    ST_DECLARE_PT_COUNTER(AddressSpaces, 4)
    ST_DECLARE_PT_COUNTER(DepositedPages, 5)
    ST_DECLARE_PT_COUNTER(GpaPages, 6)
    ST_DECLARE_PT_COUNTER(GpaSpaceModifications, 7)
    ST_DECLARE_PT_COUNTER(VirtualTlbFlushEntires, 8)
    ST_DECLARE_PT_COUNTER(RecommendedTlbSize, 9)
    ST_PT_COUNTER_NAME(MAXIMUM)

} HV_PROCESS_COUNTER;

#define HV_STATISTICS_GROUP_PTA_LENGTH 8
#define HV_STATISTICS_GROUP_PTV_LENGTH 56

//
// Hypervisor Virtual Processor counter set
//
typedef enum _HV_THREAD_COUNTER 
{

    ST_DECLARE_VP_COUNTER(TotalRunTime, 1)
    ST_DECLARE_VP_COUNTER(HypervisorRunTime, 2)

    ST_DECLARE_VP_COUNTER(HypercallsCount, 4)
    ST_DECLARE_VP_COUNTER(HypercallsTime, 5)
    ST_DECLARE_VP_COUNTER(PageInvalidationsCount, 6)
    ST_DECLARE_VP_COUNTER(PageInvalidationsTime, 7)
    ST_DECLARE_VP_COUNTER(ControlRegisterAccessesCount, 8)
    ST_DECLARE_VP_COUNTER(ControlRegisterAccessesTime, 9)
    ST_DECLARE_VP_COUNTER(IoInstructionsCount, 10)
    ST_DECLARE_VP_COUNTER(IoInstructionsTime, 11)
    ST_DECLARE_VP_COUNTER(HltInstructionsCount, 12)
    ST_DECLARE_VP_COUNTER(HltInstructionsTime, 13)
    ST_DECLARE_VP_COUNTER(MwaitInstructionsCount, 14)
    ST_DECLARE_VP_COUNTER(MwaitInstructionsTime, 15)
    ST_DECLARE_VP_COUNTER(CpuidInstructionsCount, 16)
    ST_DECLARE_VP_COUNTER(CpuidInstructionsTime, 17)
    ST_DECLARE_VP_COUNTER(MsrAccessesCount, 18)
    ST_DECLARE_VP_COUNTER(MsrAccessesTime, 19)
    ST_DECLARE_VP_COUNTER(OtherInterceptsCount, 20)
    ST_DECLARE_VP_COUNTER(OtherInterceptsTime, 21)
    ST_DECLARE_VP_COUNTER(ExternalInterruptsCount, 22)
    ST_DECLARE_VP_COUNTER(ExternalInterruptsTime, 23)
    ST_DECLARE_VP_COUNTER(PendingInterruptsCount, 24)
    ST_DECLARE_VP_COUNTER(PendingInterruptsTime, 25)
    ST_DECLARE_VP_COUNTER(EmulatedInstructionsCount, 26)
    ST_DECLARE_VP_COUNTER(EmulatedInstructionsTime, 27)
    ST_DECLARE_VP_COUNTER(DebugRegisterAccessesCount, 28)
    ST_DECLARE_VP_COUNTER(DebugRegisterAccessesTime, 29)
    ST_DECLARE_VP_COUNTER(PageFaultInterceptsCount, 30)
    ST_DECLARE_VP_COUNTER(PageFaultInterceptsTime, 31)
    ST_DECLARE_VP_COUNTER(GuestPageTableMaps, 32)
    ST_DECLARE_VP_COUNTER(LargePageTlbFills, 33)
    ST_DECLARE_VP_COUNTER(SmallPageTlbFills, 34)
    ST_DECLARE_VP_COUNTER(ReflectedGuestPageFaults, 35)
    ST_DECLARE_VP_COUNTER(ApicMmioAccesses, 36)
    ST_DECLARE_VP_COUNTER(IoInterceptMessages, 37)
    ST_DECLARE_VP_COUNTER(MemoryInterceptMessages, 38)
    ST_DECLARE_VP_COUNTER(ApicEoiAccesses, 39)
    ST_DECLARE_VP_COUNTER(OtherMessages, 40)
    ST_DECLARE_VP_COUNTER(PageTableAllocations, 41)
    ST_DECLARE_VP_COUNTER(LogicalProcessorMigrations, 42)
    ST_DECLARE_VP_COUNTER(AddressSpaceEvictions, 43)
    ST_DECLARE_VP_COUNTER(AddressSpaceSwitches, 44)
    ST_DECLARE_VP_COUNTER(AddressDomainFlushes, 45)
    ST_DECLARE_VP_COUNTER(AddressSpaceFlushes, 46)
    ST_DECLARE_VP_COUNTER(GlobalGvaRangeFlushes, 47)
    ST_DECLARE_VP_COUNTER(LocalGvaRangeFlushes, 48)
    ST_DECLARE_VP_COUNTER(PageTableEvictions, 49)
    ST_DECLARE_VP_COUNTER(PageTableReclamations, 50)
    ST_DECLARE_VP_COUNTER(PageTableResets, 51)
    ST_DECLARE_VP_COUNTER(PageTableValidations, 52)
    ST_DECLARE_VP_COUNTER(ApicTprAccesses, 53)
    ST_DECLARE_VP_COUNTER(PageTableWriteIntercepts, 54)
    ST_DECLARE_VP_COUNTER(SyntheticInterrupts, 55)
    ST_DECLARE_VP_COUNTER(VirtualInterrupts, 56)
    ST_DECLARE_VP_COUNTER(ApicIpisSent, 57)
    ST_DECLARE_VP_COUNTER(ApicSelfIpisSent, 58)
    ST_DECLARE_VP_COUNTER(GpaSpaceHypercalls, 59)
    ST_DECLARE_VP_COUNTER(LogicalProcessorHypercalls, 60)
    ST_DECLARE_VP_COUNTER(LongSpinWaitHypercalls, 61)
    ST_DECLARE_VP_COUNTER(OtherHypercalls, 62)
    ST_DECLARE_VP_COUNTER(SyntheticInterruptHypercalls, 63)
    ST_DECLARE_VP_COUNTER(VirtualInterruptHypercalls, 64)
    ST_DECLARE_VP_COUNTER(VirtualMmuHypercalls, 65)
    ST_DECLARE_VP_COUNTER(VirtualProcessorHypercalls, 66)
    ST_VP_COUNTER_NAME(MAXIMUM)

} HV_THREAD_COUNTER;

#define HV_STATISTICS_GROUP_VPA_LENGTH 16
#define HV_STATISTICS_GROUP_VPV_LENGTH 504



//
// Declare the timestamp type.
//
typedef UINT64 HV_TIME_STAMP, *PHV_TIME_STAMP;

//
// Logical processors are defined by a 32-bit index
//
typedef UINT32 HV_LOGICAL_PROCESSOR_INDEX, *PHV_LOGICAL_PROCESSOR_INDEX;

//
// This described the various methods for changing power state
// 
typedef enum _HV_X64_POWER_CHANGE_METHOD
{
    HvX64PowerChangeIssueHlt,
    HvX64PowerChangeReadIoThenIssueHlt,
    HvX64PowerChangeReadIo,
    HvX64PowerChangeIssueMwait
} HV_X64_POWER_CHANGE_METHOD, *PHV_X64_POWER_CHANGE_METHOD;

//
// This described a recipe to take the processor to a specific low power state.
// 
typedef union _HV_X64_MSR_POWER_STATE_CONFIG
{
    UINT64 AsUINT64;

    struct
    {
        UINT64 TypeSpecific:52;
        UINT64 ChangeType:4;    // use HV_X64_POWER_CHANGE_METHOD values
        UINT64 CheckBM_STS:1;
        UINT64 SetBM_RST:1;
        UINT64 ClearBM_RST:1;
        UINT64 SetARB_DIS:1;
        UINT64 Reserved:4;
    };

    struct
    {   
        UINT64 Reserved:52;
    } Hlt;

    struct
    {
        UINT16 Port;
        UINT16 Reserved1;
        UINT32 Reserved2:20;
    } Io;

    struct
    {
        UINT64 Address:52;      // x64 has a 52 bit physical address space
    } Memory;

    struct
    {
        UINT32 Hints;           
        UINT32 BreakOnMaskedInterrupt:1;
        UINT32 Reserved:19;
    } Mwait;

} HV_X64_MSR_POWER_STATE_CONFIG, *PHV_X64_MSR_POWER_STATE_CONFIG;

//
// Reading from the trigger register takes the processor idle from the 
// perspecive of the power management partition.  Upon wakeup the value returned
// contains information on the the idle operation attempted.
// 
typedef union _HV_X64_MSR_POWER_STATE_TRIGGER
{
    UINT64 AsUINT64;
    struct
    {
        UINT8 IdleEntryCount;
        UINT8 Reserved[3];
        UINT32 Reserved2:31;
        UINT32 ActiveBM_STS:1;
    };

} HV_X64_MSR_POWER_STATE_TRIGGER, *PHV_X64_MSR_POWER_STATE_TRIGGER;

//
// The following virtual MSRs are used to configure and trigger the C1-C3 power 
// states.  Space is reserved for power states C4-C15 should they ever be
// defined by ACPI.
// 

#define HV_X64_MSR_POWER_STATE_TRIGGER_C1   0x400000C1
#define HV_X64_MSR_POWER_STATE_TRIGGER_C2   0x400000C2
#define HV_X64_MSR_POWER_STATE_TRIGGER_C3   0x400000C3

#define HV_X64_MSR_POWER_STATE_CONFIG_C1    0x400000D1
#define HV_X64_MSR_POWER_STATE_CONFIG_C2    0x400000D2
#define HV_X64_MSR_POWER_STATE_CONFIG_C3    0x400000D3


//
// Define interrupt types.
//
typedef enum _HV_INTERRUPT_TYPE
{
    //
    // Explicit interrupt types.
    //
    HvX64InterruptTypeFixed             = 0x0000,
    HvX64InterruptTypeLowestPriority    = 0x0001,
    HvX64InterruptTypeNmi               = 0x0004,
    HvX64InterruptTypeInit              = 0x0005,
    HvX64InterruptTypeSipi              = 0x0006,
    HvX64InterruptTypeExtInt            = 0x0007,

    //
    // Maximum (exclusive) value of interrupt type.
    //
    HvX64InterruptTypeMaximum           = 0x008

} HV_INTERRUPT_TYPE, *PHV_INTERRUPT_TYPE;

//
// Define interrupt vector type.
//
typedef UINT32 HV_INTERRUPT_VECTOR, *PHV_INTERRUPT_VECTOR;

//
// Define special "no interrupt vector" value used by hypercalls that indicate
// whether the previous virtual interrupt was acknowledged.
//
#define HV_INTERRUPT_VECTOR_NONE 0xFFFFFFFF

//
// In a NUMA system processors, memory and devices may reside in different
// firmware described proximity domains.
//
// On a non-NUMA system everything resides in proximity domain 0.
//

typedef UINT32 HV_PROXIMITY_DOMAIN_ID, *PHV_PROXIMITY_DOMAIN_ID;

//
// Define the proximity domain information flags.
//

typedef struct _HV_PROXIMITY_DOMAIN_FLAGS
{
    //
    // This flag specifies whether the proximity information is preferred. If
    // so, then the memory allocations are done preferentially from the
    // specified proximity domain. In case there is insufficient memory in the
    // specified domain, other domains are tried. If this flag is false, then
    // all memory allocation must come from the specified domain.
    //
    UINT32 ProximityPreferred:1;

    UINT32 Reserved:30;

    //
    // This flag specifies that the specified proximity domain is valid. If
    // this flag is false then the memory allocation can come from any
    // proximity domain.
    //
    UINT32 ProximityInfoValid:1;

} HV_PROXIMITY_DOMAIN_FLAGS, *PHV_PROXIMITY_DOMAIN_FLAGS;

//
// Define the proximiy domain information structure.
//

typedef struct _HV_PROXIMITY_DOMAIN_INFO
{
    HV_PROXIMITY_DOMAIN_ID Id;
    HV_PROXIMITY_DOMAIN_FLAGS Flags;
} HV_PROXIMITY_DOMAIN_INFO, *PHV_PROXIMITY_DOMAIN_INFO;

//
// The HV_PROCESSOR_INFO structures contains additional information about
// each physical processor
//

typedef struct _HV_PROCESSOR_INFO
{
    //
    // The Local APIC ID for the processor.
    //
    UINT32 LocalApicId;

    //
    // The proximity domain the processor resides in
    //
    HV_PROXIMITY_DOMAIN_ID ProximityDomainId;

} HV_PROCESSOR_INFO, *PHV_PROCESSOR_INFO;

//
// The following structure contains the definition of a memory range.
//

typedef struct _HV_MEMORY_RANGE_INFO
{
    //
    // The system physical address where this range begins
    //
    HV_SPA BaseAddress;

    //
    // The length of this range of memory in bytes.
    //
    UINT64 Length;

    //
    // The proximity domain this memory range resides in.
    //
    HV_PROXIMITY_DOMAIN_ID ProximityDomainId;

} HV_MEMORY_RANGE_INFO, *PHV_MEMORY_RANGE_INFO;

typedef const HV_MEMORY_RANGE_INFO* PCHV_MEMORY_RANGE_INFO;


#if defined(_HV_ICECAP_ENABLED_)

//
// Declare MSR used to configure the sampling profiler
//

#define HV_X64_MSR_PROFILER_CONFIG  0x400000C0

typedef union _HV_X64_MSR_PROFILER_CONFIG_CONTENTS
{
    UINT64 AsUINT64;

    struct
    {
        UINT64 Period:48;
        UINT64 EventType:4;
        UINT64 Reserved:12;
    };
    
} HV_X64_MSR_PROFILER_CONFIG_CONTENTS, *PHV_X64_MSR_PROFILER_CONFIG_CONTENTS;


#endif

//
// Define the trace buffer index type.
//

typedef UINT32 HV_EVENTLOG_BUFFER_INDEX, *PHV_EVENTLOG_BUFFER_INDEX;

#define HV_EVENTLOG_BUFFER_INDEX_NONE 0xffffffff

//
// Define all the trace buffer types.
//

typedef enum
{
    HvEventLogTypeGlobalSystemEvents = 0x00000000,
    HvEventLogTypeLocalDiagnostics   = 0x00000001,
} HV_EVENTLOG_TYPE;


//
// Define all the trace buffer states.
//

typedef enum
{
    HvEventLogBufferStateStandby  = 0,
    HvEventLogBufferStateFree     = 1,
    HvEventLogBufferStateInUse    = 2,
    HvEventLogBufferStateComplete = 3,
    HvEventLogBufferStateReady    = 4
} HV_EVENTLOG_BUFFER_STATE;


//
// Define trace message header structure.
//

typedef struct _HV_EVENTLOG_MESSAGE_PAYLOAD
{

    HV_EVENTLOG_TYPE EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;

} HV_EVENTLOG_MESSAGE_PAYLOAD, *PHV_EVENTLOG_MESSAGE_PAYLOAD;


//
// Define time source enum and structure.
//

typedef enum
{
    HvEventLogEntryTimeReference = 0,
    HvEventLogEntryTimeTsc       = 1
} HV_EVENTLOG_ENTRY_TIME_BASIS;

typedef union
{

    HV_NANO100_TIME ReferenceTime;
    UINT64          TimeStamp;

} HV_EVENTLOG_ENTRY_TIME;


//
// Define trace buffer header.
//

typedef struct _HV_EVENTLOG_BUFFER_HEADER
{
    UINT32                         BufferSize;        // BufferSize
    HV_EVENTLOG_BUFFER_INDEX       BufferIndex;       // SavedOffset
    UINT32                         EventsLost;        // CurrentOffset
    volatile UINT32                ReferenceCounter;  // ReferenceCount

    union
    {
        UINT64                     TimeStamp;
        HV_NANO100_TIME            ReferenceTime;
    };
    UINT64                         Reserved1;

    UINT64                         Reserved2;
    struct                                            // ClientContext
    {
        UINT8                      LogicalProcessor;  // ProcessorNumber
        UINT8                      Alignment;
        UINT16                     LoggerId;
    };
    volatile HV_EVENTLOG_BUFFER_STATE BufferState;    // (Free/GeneralLogging/Flush)

    UINT32                         NextBufferOffset;  // Offset
    HV_EVENTLOG_TYPE               Type;              // BufferFlag and BufferType
    HV_EVENTLOG_BUFFER_INDEX       NextBufferIndex;   // Padding1
    UINT32                         Reserved3;         // Padding1

    UINT32                         Reserved4[2];      // Padding1

} HV_EVENTLOG_BUFFER_HEADER, *PHV_EVENTLOG_BUFFER_HEADER;


//
// Define trace entry header.
//
typedef struct _HV_EVENTLOG_ENTRY_HEADER
{
    UINT32              Context;    // Marker
    UINT16              Size;       // Size in WMI_TRACE_PACKET
    UINT16              Type;       // HookId in WMI_TRACE_PACKET

    union
    {
        UINT64          TimeStamp;
        HV_NANO100_TIME ReferenceTime;
    };
} HV_EVENTLOG_ENTRY_HEADER, *PHV_EVENTLOG_ENTRY_HEADER;

//
// Definition of the HvCallAllocateBufferGroup hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_CREATE_EVENTLOG_BUFFER
{

    HV_EVENTLOG_TYPE   EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;
    HV_PROXIMITY_DOMAIN_INFO ProximityInfo;

} HV_INPUT_CREATE_EVENTLOG_BUFFER, *PHV_INPUT_CREATE_EVENTLOG_BUFFER;


//
// Definition of the HvCallCreateEventLogBuffer hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_DELETE_EVENTLOG_BUFFER
{

    HV_EVENTLOG_TYPE EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;

} HV_INPUT_DELETE_EVENTLOG_BUFFER, *PHV_INPUT_DELETE_EVENTLOG_BUFFER;

//
// Definition of the HvCallRequestEventLogGroupFlush hypercall input
// structure.
//


typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_FLUSH_EVENTLOG_BUFFER
{

    HV_EVENTLOG_TYPE EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;

} HV_INPUT_FLUSH_EVENTLOG_BUFFER, *PHV_INPUT_FLUSH_EVENTLOG_BUFFER;


//
// Definition of the HvCallInitialzeEventLogBufferGroup hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_INITIALIZE_EVENTLOG_BUFFER_GROUP
{

    HV_EVENTLOG_TYPE EventLogType;
    UINT32 MaximumBufferCount;
    UINT32 BufferSizeInPages;
    UINT32 Threshold;
    HV_EVENTLOG_ENTRY_TIME_BASIS TimeBasis;
    HV_NANO100_TIME SystemTime;
} HV_INPUT_INITIALIZE_EVENTLOG_BUFFER_GROUP,
*PHV_INPUT_INITIALIZE_EVENTLOG_BUFFER_GROUP;


//
// Definition of the HvCallFinalizeEventLogBufferGroup hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_FINALIZE_EVENTLOG_BUFFER_GROUP
{

    HV_EVENTLOG_TYPE EventLogType;

} HV_INPUT_FINALIZE_EVENTLOG_BUFFER_GROUP,
*PHV_INPUT_FINALIZE_EVENTLOG_BUFFER_GROUP;

//
// Definition of the HvCallMapEventLogBuffer hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_MAP_EVENTLOG_BUFFER
{

    HV_EVENTLOG_TYPE EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;

} HV_INPUT_MAP_EVENTLOG_BUFFER, *PHV_INPUT_MAP_EVENTLOG_BUFFER;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_MAP_EVENTLOG_BUFFER
{

    HV_GPA_PAGE_NUMBER GpaPageNumbers[512];

} HV_OUTPUT_MAP_EVENTLOG_BUFFER, *PHV_OUTPUT_MAP_EVENTLOG_BUFFER;


//
// Definition of the HvCallUnmapEventLogBuffer hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_UNMAP_EVENTLOG_BUFFER
{

    HV_EVENTLOG_TYPE EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;

} HV_INPUT_UNMAP_EVENTLOG_BUFFER, *PHV_INPUT_UNMAP_EVENTLOG_BUFFER;
//
// Definition of the HvCallSetEventLogGroupSources hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_EVENTLOG_SET_EVENTS
{

    HV_EVENTLOG_TYPE EventLogType;
    UINT64           EnableFlags;

} HV_INPUT_EVENTLOG_SET_EVENTS, *PHV_INPUT_EVENTLOG_SET_EVENTS;

//
// Definition of the HvCallReleaseEventLogBuffer hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_EVENTLOG_RELEASE_BUFFER
{

    HV_EVENTLOG_TYPE EventLogType;
    HV_EVENTLOG_BUFFER_INDEX BufferIndex;

} HV_INPUT_EVENTLOG_RELEASE_BUFFER, *PHV_INPUT_EVENTLOG_RELEASE_BUFFER;


//
// N.B. These constants are temporary until we have the ability to allocate bigger
// chunks of memory with our Hv Mm component.
//
#if defined(_HV_ICECAP_ENABLED_)

#define HV_TR_MAX_DIAG_BUFFER_SIZE  (1024*1024*32) // 32MB
#define HV_TR_MAX_DIAG_BUFFER_COUNT (2)

#else

#define HV_TR_MAX_DIAG_BUFFER_SIZE  (1024*1024*2) // 2MB
#define HV_TR_MAX_DIAG_BUFFER_COUNT (8)

#endif

//
// The following are the two hypervisor event groups defined by ETW. They
// need to be in sync with the two ETW constants defined in
// base\published\ntwmi.w:
//      #define EVENT_TRACE_GROUP_HYPERVISOR           0x1D00
//      #define EVENT_TRACE_GROUP_HYPERVISORX          0x1E00
//
// Note, only the high byte is used for group. The lower byte is used
// for the event types in the group.
//
#define HV_TR_EVENTLOG_GROUP_HYPERVISOR     0x1D00
#define HV_TR_EVENTLOG_GROUP_HYPERVISORX    0x1E00


//
// Event & Trace Groups.
//
#define HV_TR_GROUP_NONE            0x0000000000000000

//
// Event Groups (Admin, Operational, Audit, ...)
//
#define HV_EVENTLOG_ENABLE_AUDIT_SUCCESS    0x0000000000000001
#define HV_EVENTLOG_ENABLE_AUDIT_FAILURE    0x0000000000000002
#define HV_EVENTLOG_ENABLE_PARTITION        0x0000000000000004
#define HV_EVENTLOG_ENABLE_TEST             0x8000000000000000

//
// Diagnostic Trace Groups.
//
#define HV_TR_GROUP_ADMIN           0x0000000000000001
#define HV_TR_GROUP_DIAG            0x0000000000000002
#define HV_TR_GROUP_WARN            0x0000000000000003

//
// Retail Performance Trace Groups (starting at 0x0000000000000100)
//
#define HV_TR_GROUP_BM              0x0000000000000100
#define HV_TR_GROUP_DM              0x0000000000000200
#define HV_TR_GROUP_HC              0x0000000000000400
#define HV_TR_GROUP_IM              0x0000000000000800
#define HV_TR_GROUP_IC              0x0000000000001000
#define HV_TR_GROUP_OB              0x0000000000002000
#define HV_TR_GROUP_PT              0x0000000000004000
#define HV_TR_GROUP_VP              0x0000000000008000
#define HV_TR_GROUP_SYNIC           0x0000000000010000
#define HV_TR_GROUP_SYNIC_TI        0x0000000000020000
#define HV_TR_GROUP_AM_GVA          0x0000000000040000
#define HV_TR_GROUP_AM              0x0000000000080000
#define HV_TR_GROUP_VAL             0x0000000000100000
#define HV_TR_GROUP_VM              0x0000000000200000
#define HV_TR_GROUP_SCH             0x0000000000400000
#define HV_TR_GROUP_TH              0x0000000000800000
#define HV_TR_GROUP_TI              0x0000000001000000
#define HV_TR_GROUP_KE              0x0000000002000000
#define HV_TR_GROUP_MM              0x0000000004000000

#define HV_TR_ALL_GROUPS (HV_TR_GROUP_BM | HV_TR_GROUP_DM | HV_TR_GROUP_HC | \
    HV_TR_GROUP_IM | HV_TR_GROUP_IC | HV_TR_GROUP_OB | \
    HV_TR_GROUP_PT | HV_TR_GROUP_VP | HV_TR_GROUP_SYNIC | \
    HV_TR_GROUP_SYNIC_TI | HV_TR_GROUP_AM_GVA | HV_TR_GROUP_AM | \
    HV_TR_GROUP_VAL | HV_TR_GROUP_VM | HV_TR_GROUP_SCH | \
    HV_TR_GROUP_TH | HV_TR_GROUP_TI | HV_TR_GROUP_KE | \
    HV_TR_GROUP_MM)

#define HV_TR_IS_GROUP_RETAIL(_Group_) \
    (((UINT64)(_Group_) > 0) && \
    (((UINT64)(_Group_) & HV_TR_ALL_GROUPS) != 0) && \
    (((UINT64)(_Group_) & ((UINT64)(_Group_) - 1)) == 0))


//
// Internal Debugging Trace Groups (starting at 0x0000010000000000)
//
#define HV_TR_GROUP_BM_INTERNAL       0x0000010000000000
#define HV_TR_GROUP_DM_INTERNAL       0x0000020000000000
#define HV_TR_GROUP_HC_INTERNAL       0x0000040000000000
#define HV_TR_GROUP_IM_INTERNAL       0x0000080000000000
#define HV_TR_GROUP_IC_INTERNAL       0x0000100000000000
#define HV_TR_GROUP_OB_INTERNAL       0x0000200000000000
#define HV_TR_GROUP_PT_INTERNAL       0x0000400000000000
#define HV_TR_GROUP_VP_INTERNAL       0x0000800000000000
#define HV_TR_GROUP_SYNIC_INTERNAL    0x0001000000000000
#define HV_TR_GROUP_SYNIC_TI_INTERNAL 0x0002000000000000
#define HV_TR_GROUP_AM_GVA_INTERNAL   0x0004000000000000
#define HV_TR_GROUP_AM_INTERNAL       0x0008000000000000
#define HV_TR_GROUP_VAL_INTERNAL      0x0010000000000000
#define HV_TR_GROUP_VM_INTERNAL       0x0020000000000000
#define HV_TR_GROUP_SCH_INTERNAL      0x0040000000000000
#define HV_TR_GROUP_TH_INTERNAL       0x0080000000000000
#define HV_TR_GROUP_TI_INTERNAL       0x0100000000000000
#define HV_TR_GROUP_KE_INTERNAL       0x0200000000000000
#define HV_TR_GROUP_MM_INTERNAL       0x0400000000000000
#define HV_TR_GROUP_PROFILER_INTERNAL 0x0800000000000000

//
// Tf, simulate full buffers and cyclic buffers are currently only
// supported for TEST_FEATURES_ENABLED builds.
//
#define HV_TR_GROUP_TF                0x1000000000000000
#define HV_TR_GROUP_SIMULATE_FULL     0x2000000000000000
#define HV_TR_GROUP_CYCLIC            0x4000000000000000

//
// IceCap Trace Group.
//
#define HV_TR_GROUP_ICE               0x8000000000000000

#define HV_TR_ALL_GROUPS_INTERNAL (HV_TR_GROUP_BM_INTERNAL | \
    HV_TR_GROUP_DM_INTERNAL | HV_TR_GROUP_HC_INTERNAL | \
    HV_TR_GROUP_IM_INTERNAL | HV_TR_GROUP_IC_INTERNAL | \
    HV_TR_GROUP_OB_INTERNAL | HV_TR_GROUP_PT_INTERNAL | \
    HV_TR_GROUP_VP_INTERNAL | HV_TR_GROUP_SYNIC_INTERNAL | \
    HV_TR_GROUP_SYNIC_TI_INTERNAL | HV_TR_GROUP_AM_GVA_INTERNAL | \
    HV_TR_GROUP_AM_INTERNAL | HV_TR_GROUP_VAL_INTERNAL | \
    HV_TR_GROUP_VM_INTERNAL | HV_TR_GROUP_SCH_INTERNAL | \
    HV_TR_GROUP_TH_INTERNAL | HV_TR_GROUP_TI_INTERNAL | \
    HV_TR_GROUP_KE_INTERNAL | HV_TR_GROUP_MM_INTERNAL | \
    HV_TR_GROUP_PROFILER_INTERNAL | HV_TR_GROUP_TF | \
    HV_TR_GROUP_SIMULATE_FULL | HV_TR_GROUP_CYCLIC | \
    HV_TR_GROUP_ICE)

#define HV_TR_IS_GROUP_INTERNAL(_Group_) \
    (((UINT64)(_Group_) > 0) && \
    (((UINT64)(_Group_) & HV_TR_ALL_GROUPS_INTERNAL) != 0) && \
    (((UINT64)(_Group_) & ((UINT64)(_Group_) - 1)) == 0))


//
// Trace Types for the administrative group.
//
#define HV_EVENTLOG_OPERATIONAL_PARTITION_CREATED           0x4101
#define HV_EVENTLOG_OPERATIONAL_PARTITION_DELETED           0x4102
#define HV_EVENTLOG_OPERATIONAL_PARTITION_CREATION_FAILED   0x2103
#define HV_EVENTLOG_ADMIN_TEST                              0x4001


//
// Trace Types for the diagnostic group.
//

//
// Retail Bm Trace Types (0x1D 00-0F)
//
// None.
//

//
// Retail Dm Trace Types (0x1D 10-19).
//
// None.
//

//
// Retail Hc Trace Types (0x1D 1A-1F).
//

#define HV_TR_HC_HYPERCALL                  0x1A

//
// Retail Im Trace Types (0x1D 20-3B).
//

#define HV_TR_IM_GUEST_EXCEPTION            0x20
#define HV_TR_IM_MSR_READ                   0x21
#define HV_TR_IM_MSR_WRITE                  0x22
#define HV_TR_IM_CR_READ                    0x23
#define HV_TR_IM_CR_WRITE                   0x24
#define HV_TR_IM_HLT_INSTRUCTION            0x25
#define HV_TR_IM_MWAIT_INSTRUCTION          0x26
#define HV_TR_IM_CPUID_INSTRUCTION          0x27
#define HV_TR_IM_IO_PORT_READ               0x28
#define HV_TR_IM_IO_PORT_WRITE              0x29
#define HV_TR_IM_EXTERNAL_INTERRUPT         0x2A
#define HV_TR_IM_INTERRUPT_PENDING          0x2B
#define HV_TR_IM_GUEST_SHUTDOWN             0x2C
#define HV_TR_IM_EMULATED_INSTRUCTION       0x2D
#define HV_TR_IM_NMI_INTERRUPT              0x2E
#define HV_TR_IM_INVLPG_INSTRUCTION         0x2F
#define HV_TR_IM_IRET_INSTRUCTION           0x30
#define HV_TR_IM_TASK_SWITCH                0x31
#define HV_TR_IM_INVD_INSTRUCTION           0x32
#define HV_TR_IM_DR_ACCESS                  0x33
#define HV_TR_IM_FERR_FREEZE                0x34
#define HV_TR_IM_REAL_MODE_INTERRUPT        0x35
#define HV_TR_IM_MEMORY_INTERCEPT           0x36
#define HV_TR_IM_REFLECTED_EXCEPTION        0x37

//
// Retail Ic Trace Types (0x1D 3C-3F).
//
// None.
//

//
// Retail Ob Trace Types (0x1D 40-45).
//

#define HV_TR_OB_CREATE_PARTITION           0x40
#define HV_TR_OB_DELETE_PARTITION           0x41

//
// Retail Pt Trace Types (0x1D 46-4A).
//
// None.
//

//
// Retail Vp Trace Types (0x1D 4B-4F).
//

#define HV_TR_VP_CREATE_VP                  0x4B
#define HV_TR_VP_DELETE_VP                  0x4C

//
// Retail Synic Trace Types (0x1D 50-65).
//
// None.
//

//
// Retail Synic Timer Trace Types (0x1D 66-6F).
//
// None.
//

//
// Retail Am GVA Trace Types (0x1D 70-97).
//

#define HV_TR_AM_GVA_GROW_VIRTUAL_TLB       0x70
#define HV_TR_AM_GVA_SHRINK_VIRTUAL_TLB     0x71
#define HV_TR_AM_GVA_FLUSH_VIRTUAL_TLB      0x72

//
// Retail Am Trace Types (0x1D 98-AF).
//
// None.
//

//
// Retail Val Trace Types (0x1D A0-A7).
//
// None.
//

//
// Retail Vm Trace Types (0x1D A8-AF).
//
// None.
//

//
// Retail Sch Trace Types (0x1D B0-CD).
//

#define HV_TR_SCH_CONTEXT_SWITCH            0xB0

//
// Retail Th Trace Types (0x1D CE-CF).
//
// None.
//

//
// Retail Ti Trace Types (0x1D D0-DF).
//
// None.
//

//
// Retail Ke Trace Types (0x1D E0-E9).
//

#define HV_TR_KE_OVERRUN                    0xE0
#define HV_TR_KE_OVERRUN_PARAMS             0xE1
#define HV_TR_KE_OVERRUN500                 0xE2
#define HV_TR_KE_OVERRUN500_PARAMS          0xE3

//
// Retail Mm Trace Types (0x1D EA-EF).
//
// None.
//


#if defined(_HV_TEST_FEATURES_ENABLED_) || defined(_PERF_FEATURES_ENABLED_)

//
// Internal Bm Trace Types (0x1E 00-0F)
//
// None.
//

//
// Internal Dm Trace Types (0x1E 10-19).
//

#define HV_TR_DMP_INTERCEPT                 0x10
#define HV_TR_DMP_DISPATCH_EVENTS           0x11

//
// Internal Hc Trace Types (0x1E 1A-1F).
//
// None.
//

//
// Internal Im Trace Types (0x1E 20-3B).
//

#define HV_TR_IMP_SEND_INTERCEPT_MESSAGE    0x20

//
// Internal Ic Trace Types (0x1E 3C-3F).
//

#define HV_TR_ICP_EMULATE_INSTR             0x3C

//
// Internal Ob Trace Types (0x1E 40-45).
//
// None.
//

//
// Internal Pt Trace Types (0x1E 46-4A).
//
// None.
//

//
// Internal Vp Trace Types (0x1E 4B-4F).
//
// None.
//

//
// Internal Synic Trace Types (0x1E 50-65).
//

#define HV_TR_SYNICP_ASSERT                 0x50
#define HV_TR_SYNICP_EVAL_LOW_PRI           0x51
#define HV_TR_SYNICP_EVAL_IMMEDIATE         0x52
#define HV_TR_SYNICP_EVAL_QUEUE             0x53
#define HV_TR_SYNICP_PENDING                0x54
#define HV_TR_SYNICP_EOI                    0x55
#define HV_TR_SYNICP_LATENCY_EXCEEDED       0x56
#define HV_TR_SYNICP_MARK_PENDING           0x57
#define HV_TR_SYNICP_EVAL_APIC_INTS         0x58
#define HV_TR_SYNICP_READ_APIC_GPA          0x59
#define HV_TR_SYNICP_WRITE_APIC_GPA         0x5A
#define HV_TR_SYNICP_READ_APIC_MSR          0x5B
#define HV_TR_SYNICP_WRITE_APIC_MSR         0x5C
#define HV_TR_SYNICP_EXTERNAL_INT           0x5D
#define HV_TR_SYNICP_APIC_IPI               0x5E
#define HV_TR_SYNICP_SIGNAL_EVENT_PORT      0x5F
#define HV_TR_SYNICP_POST_MESSAGE           0x60

//
// Internal Synic Timer Trace Types (0x1E 66-6F).
//

#define HV_TR_SYNICP_PERIODIC_TIMER_UPDATE  0x66
#define HV_TR_SYNICP_PERIODIC_TIMER_RESET   0x67
#define HV_TR_SYNICP_TIMER_SEND_MESSAGE     0x68
#define HV_TR_SYNICP_TIMER_SCAN_MESSAGE     0x69
#define HV_TR_SYNICP_TIMER_ASSIST_EXPIRE    0x6A

//
// Internal Am GVA Trace Types (0x1E 70-97).
//

#define HV_TR_AMP_GVA_PAGE_FAULT            0x70
#define HV_TR_AMP_GVA_VTLB_WRITABILITY_CHANGE 0x71
#define HV_TR_AMP_GVA_SWITCH_SPACE          0x72
#define HV_TR_AMP_GVA_FLUSH_VA_LOCAL        0x73
#define HV_TR_AMP_GVA_FLUSH_VA_GLOBAL       0x74
#define HV_TR_AMP_GVA_FLUSH_VTLB_RANGE      0x75
#define HV_TR_AMP_GVA_FLUSH_SPACE           0x76
#define HV_TR_AMP_GVA_FLUSH_DOMAIN          0x77
#define HV_TR_AMP_GVA_RESET_DOMAIN          0x78
#define HV_TR_AMP_GVA_TRANSLATE_VA          0x79
#define HV_TR_AMP_GVA_READ_VM               0x7A
#define HV_TR_AMP_GVA_WRITE_VM              0x7B
#define HV_TR_AMP_GVA_RESET_PT              0x7C
#define HV_TR_AMP_GVA_UNLINK_PT             0x7D
#define HV_TR_AMP_GVA_UNLINK_PT_VALIDATE    0x7E
#define HV_TR_AMP_GVA_UNLINK_PT_FILL        0x7F
#define HV_TR_AMP_GVA_UNLINK_PT_LINK        0x80
#define HV_TR_AMP_GVA_UNLINK_PT_RESET       0x81
#define HV_TR_AMP_GVA_UNLINK_PT_EVICT       0x82
#define HV_TR_AMP_GVA_UNLINK_PT_CLEAN       0x83
#define HV_TR_AMP_GVA_CONSTRUCT_PT          0x84
#define HV_TR_AMP_GVA_DESTRUCT_PT           0x85
#define HV_TR_AMP_GVA_WALK_PT               0x86
#define HV_TR_AMP_GVA_WAIT_FOR_PT_FILL      0x87
#define HV_TR_AMP_GVA_CLEAN_SAS             0x88
#define HV_TR_AMP_GVA_CLEAN_SAS_OVERFLOW    0x89
#define HV_TR_AMP_GVA_EVICT_PTS             0x8A
#define HV_TR_AMP_GVA_RECLAIM_PTS           0x8B
#define HV_TR_AMP_GVA_FREE_RECLAIMED_PTS    0x8C
#define HV_TR_AMP_GVA_HASH_PROCESSED        0x8D

//
// Internal Am Trace Types (0x1E 98-9F).
//

#define HV_TR_AMP_MAP_GPA                   0x98
#define HV_TR_AMP_UNMAP_GPA                 0x99

//
// Internal Val Trace Types (0x1E A0-A7).
//
// None.
//

//
// Internal Vm Trace Types (0x1E A8-AF).
//
// None.
//

//
// Internal Sch Trace Types (0x1E B0-CD).
//

#define HV_TR_SCHP_NEXT_THREAD              0xB0
#define HV_TR_SCHP_ADD_LOCAL                0xB1
#define HV_TR_SCHP_EVAL_PRI                 0xB2
#define HV_TR_SCHP_TIMESLICE_MIN            0xB3
#define HV_TR_SCHP_AFFINITY_CHANGE          0xB4
#define HV_TR_SCHP_ADD_DEFERRED             0xB6
#define HV_TR_SCHP_DEFERRED_READY_THREAD    0xB7
#define HV_TR_SCHP_TIMESLICE_END            0xB8
#define HV_TR_SCHP_EVAL_SEND                0xB9
#define HV_TR_SCHP_EVAL_RECV                0xBA
#define HV_TR_SCHP_YIELD                    0xBB
#define HV_TR_SCHP_SET_PRI                  0xBC
#define HV_TR_SCHP_EVAL_TIMESLICE           0xBD
#define HV_TR_SCHP_BLOCK_ON_EVENT           0xBE
#define HV_TR_SCHP_UNBLOCK_FROM_EVENT       0xBF
#define HV_TR_SCHP_SIGNAL_EVENT             0xC0
#define HV_TR_SCHP_EVENT_TIMER_END          0xC1
#define HV_TR_SCHP_LOAD_BALANCER            0xC2
#define HV_TR_SCHP_EVAL                     0xC3
#define HV_TR_SCHP_CPU_IDLE                 0xC4
#define HV_TR_SCHP_READY_UNBLOCKED_THREAD   0xC5
#define HV_TR_SCHP_EXPRESS_THREAD           0xC6
#define HV_TR_SCHP_EXPRESS_PROCESS          0xC7
#define HV_TR_SCHP_EVALUATE_CAPS            0xC8
#define HV_TR_SCHP_SET_CAPS_TIMER           0xC9

//
// Internal Th Trace Types (0x1E CE-CF).
//

#define HV_TR_THP_SEND_WORK                 0xCE

//
// Internal Ti Trace Types (0x1E D0-DF).
//

#define HV_TR_TIP_SET_APIC                  0xD0
#define HV_TR_TIP_INT                       0xD1
#define HV_TR_TIP_NEW_TIMER                 0xD2
#define HV_TR_TIP_INSERT_TIMER              0xD3
#define HV_TR_TIP_CALLBACK                  0xD4
#define HV_TR_TIP_REMOTE_REMOVE_TIMER       0xD5

//
// Internal Ke Trace Types (0x1E E0-E9).
//

#define HV_TR_KEP_FLUSH_ENTIRE_HW_TLB       0xE0
#define HV_TR_KEP_FLUSH_HV_HW_TLB           0xE1
#define HV_TR_KEP_FLUSH_MULTIPLE_HW_TLB     0xE2
#define HV_TR_KEP_SIGNAL_PROCESSORS         0xE3
#define HV_TR_KEP_RUN_GUEST                 0xE4
#define HV_TR_KEP_SEND_IPI                  0xE5
#define HV_TR_KEP_SEND_IPI_NO_IPI           0xE6
#define HV_TR_KEP_WAIT_FOR_IPI_BARRIER      0xE7

//
// Internal Mm Trace Types (0x1E EA-EF).
//
// None.
//

//
// Internal Tf Trace Types (0x1E FA-FF).
//

#define HV_TR_TF_INTERCEPT                  0xFA

#endif // defined(_HV_TEST_FEATURES_ENABLED_) || defined(_PERF_FEATURES_ENABLED_)


#if defined(_HV_ICECAP_ENABLED_)

//
// Internal IceCAP Trace Types (0x1E F0-F9).
//

#define HV_TR_ICE_CALL                      0xF0    // fixed (tffastcap.asm)
#define HV_TR_ICE_RETURN                    0xF1    // fixed (tffastcap.asm)
#define HV_TR_ICE_ACQUIRE                   0xF2
#define HV_TR_ICE_RELEASE                   0xF3

//
// Internal Profiler Type.
//

#define HV_TR_ICE_PROFILE                   0xF6

//
// Internal Custom Probe Type.
//

#define HV_TR_ICE_COMMENT                   0xF8

#endif // defined(_HV_ICECAP_ENABLED_)


//
// Thread ID for idle thread.
// HV_TR_THREAD_ID_TEST is a generic ID for all TFE-only threads.
//

#define HV_TR_THREAD_ID_IDLE                0
#define HV_TR_THREAD_ID_TEST                9


//
// Physical nodes are defined by a 32-bit index.
//

typedef UINT32 HV_PHYSICAL_NODE_INDEX, *PHV_PHYSICAL_NODE_INDEX;
#define HV_PHYSICAL_NODE_INDEX_UNSPECIFIED 0xFFFFFFFF

#define HV_X64_MSR_TIME_REF_COUNT      (0x40000020)
#define HV_X64_MSR_STIMER0_CONFIG      (0x400000b0)
#define HV_X64_MSR_STIMER0_COUNT       (0x400000b1)
#define HV_X64_MSR_STIMER1_CONFIG      (0x400000b2)
#define HV_X64_MSR_STIMER1_COUNT       (0x400000b3)
#define HV_X64_MSR_STIMER2_CONFIG      (0x400000b4)
#define HV_X64_MSR_STIMER2_COUNT       (0x400000b5)
#define HV_X64_MSR_STIMER3_CONFIG      (0x400000b6)
#define HV_X64_MSR_STIMER3_COUNT       (0x400000b7)

//
// Define the synthetic timer configuration structure
//
typedef struct _HV_X64_MSR_STIMER_CONFIG_CONTENTS
{
    union
    {
        UINT64 AsUINT64;
        struct
        {
            UINT64 Enable     : 1;
            UINT64 Periodic   : 1;
            UINT64 Lazy       : 1;
            UINT64 AutoEnable : 1;
            UINT64 Reserved1  :12;
            UINT64 SINTx      : 4;
            UINT64 Reserved2  :14;
        };
    };
} HV_X64_MSR_STIMER_CONFIG_CONTENTS, *PHV_X64_MSR_STIMER_CONFIG_CONTENTS;

typedef enum _HV_SAVE_RESTORE_STATE_RESULT
{
    HvStateComplete                 = 0,
    HvStateIncomplete               = 1,
    HvStateRestorable               = 2,
    HvStateCorruptData              = 3,
    HvStateUnsupportedVersion       = 4,
    HvStateProcessorFeatureMismatch = 5,
    HvStateHardwareFeatureMismatch  = 6,
    HvStateProcessorCountMismatch   = 7,
    HvStateProcessorFlagsMismatch   = 8,
    HvStateProcessorIndexMismatch   = 9
} HV_SAVE_RESTORE_STATE_RESULT, *PHV_SAVE_RESTORE_STATE_RESULT;

typedef UINT32 HV_SAVE_RESTORE_STATE_FLAGS, *PHV_SAVE_RESTORE_STATE_FLAGS;

#define HV_SAVE_RESTORE_STATE_START   0x00000001
#define HV_SAVE_RESTORE_STATE_SUMMARY 0x00000002

//
// NTRAID#WOOBR-999338-2007/10/05-andrewth -- Remove ExposeHyperthreads
// partition privilege completely after ensuring there are no issues with
// shipped products (Vista Gold & Win Server 2K8).
//

typedef union _HV_PARTITION_PRIVILEGE_MASK
{
    UINT64 AsUINT64;
    struct
    {
        //
        // Access to virtual MSRs
        //
        UINT64  AccessVpRunTimeMsr:1;
        UINT64  AccessPartitionReferenceCounter:1;
        UINT64  AccessSynicMsrs:1;
        UINT64  AccessSyntheticTimerMsrs:1;
        UINT64  AccessApicMsrs:1;
        UINT64  AccessHypercallMsrs:1;
        UINT64  AccessVpIndex:1;
        UINT64  Reserved1:25;

        //
        // Access to hypercalls
        //
        UINT64  CreatePartitions:1;
        UINT64  AccessPartitionId:1;
        UINT64  AccessMemoryPool:1;
        UINT64  AdjustMessageBuffers:1;
        UINT64  PostMessages:1;
        UINT64  SignalEvents:1;
        UINT64  CreatePort:1;
        UINT64  ConnectPort:1;
        UINT64  AccessStats:1;
        UINT64  IteratePhysicalHardware:1;
        UINT64  DeprecatedExposeHyperthreads:1;
        UINT64  Debugging:1;
        UINT64  CpuPowerManagement:1;
        UINT64  Reserved2:19;
    };

} HV_PARTITION_PRIVILEGE_MASK, *PHV_PARTITION_PRIVILEGE_MASK;

typedef union _HV_EXPLICIT_SUSPEND_REGISTER
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 Suspended:1;
        UINT64 Reserved:63;
    };
} HV_EXPLICIT_SUSPEND_REGISTER, *PHV_EXPLICIT_SUSPEND_REGISTER;

typedef union _HV_INTERCEPT_SUSPEND_REGISTER
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 Suspended:1;
        UINT64 TlbLocked:1;
        UINT64 Reserved:62;
    };
} HV_INTERCEPT_SUSPEND_REGISTER, *PHV_INTERCEPT_SUSPEND_REGISTER;

typedef union _HV_X64_INTERRUPT_STATE_REGISTER
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 InterruptShadow:1;
        UINT64 NmiMasked:1;
        UINT64 Reserved:62;
    };
} HV_X64_INTERRUPT_STATE_REGISTER, *PHV_X64_INTERRUPT_STATE_REGISTER;

typedef enum _HV_X64_PENDING_INTERRUPTION_TYPE
{
    HvX64PendingInterrupt           = 0,
    HvX64PendingNmi                 = 2,
    HvX64PendingException           = 3,
    HvX64PendingSoftwareInterrupt   = 4
} HV_X64_PENDING_INTERRUPTION_TYPE, *PHV_X64_PENDING_INTERRUPTION_TYPE;

typedef union _HV_X64_PENDING_INTERRUPTION_REGISTER
{
    UINT64 AsUINT64;
    struct
    {
        UINT32 InterruptionPending:1;
        UINT32 InterruptionType:3;
        UINT32 DeliverErrorCode:1;
        UINT32 Reserved:11;
        UINT32 InterruptionVector:16;
        UINT32 ErrorCode;
    };
} HV_X64_PENDING_INTERRUPTION_REGISTER, *PHV_X64_PENDING_INTERRUPTION_REGISTER;

typedef union _HV_REGISTER_VALUE
{
    HV_UINT128                              Reg128;
    UINT64                                  Reg64;
    UINT32                                  Reg32;
    UINT16                                  Reg16;
    UINT8                                   Reg8;
    HV_X64_FP_REGISTER                      Fp;
    HV_X64_FP_CONTROL_STATUS_REGISTER       FpControlStatus;
    HV_X64_XMM_CONTROL_STATUS_REGISTER      XmmControlStatus;
    HV_X64_SEGMENT_REGISTER                 Segment;
    HV_X64_TABLE_REGISTER                   Table;
    HV_EXPLICIT_SUSPEND_REGISTER            ExplicitSuspend;
    HV_INTERCEPT_SUSPEND_REGISTER           InterceptSuspend;
    HV_X64_INTERRUPT_STATE_REGISTER         InterruptState;
    HV_X64_PENDING_INTERRUPTION_REGISTER    PendingInterruption;
} HV_REGISTER_VALUE, *PHV_REGISTER_VALUE;
typedef const HV_REGISTER_VALUE *PCHV_REGISTER_VALUE;

//
// Define the intercept access types.
//

typedef UINT8 HV_INTERCEPT_ACCESS_TYPE;

#define HV_INTERCEPT_ACCESS_READ    0
#define HV_INTERCEPT_ACCESS_WRITE   1
#define HV_INTERCEPT_ACCESS_EXECUTE 2

typedef UINT32 HV_INTERCEPT_ACCESS_TYPE_MASK;

#define HV_INTERCEPT_ACCESS_MASK_NONE       0x00
#define HV_INTERCEPT_ACCESS_MASK_READ       0X01
#define HV_INTERCEPT_ACCESS_MASK_WRITE      0x02
#define HV_INTERCEPT_ACCESS_MASK_EXECUTE    0x04


//
// Define intercept types.
//
typedef enum _HV_INTERCEPT_TYPE
{
    //
    // Platform-specific intercept types.
    //
    HvInterceptTypeX64IoPort = 0x00000000,
    HvInterceptTypeX64Msr = 0x00000001,
    HvInterceptTypeX64Cpuid = 0x00000002,
    HvInterceptTypeX64Exception = 0x00000003,

} HV_INTERCEPT_TYPE, *PHV_INTERCEPT_TYPE;


//
// Define IO port type.
//
typedef UINT16 HV_X64_IO_PORT, *PHV_X64_IO_PORT;


//
// Define intercept parameters.
//
typedef union _HV_INTERCEPT_PARAMETERS
{
    //
    // HV_INTERCEPT_PARAMETERS is defined to be an 8-byte field.
    //
    UINT64 AsUINT64;

    //
    // HvInterceptTypeX64IoPort.
    //
    HV_X64_IO_PORT IoPort;

    //
    // HvInterceptTypeX64Cpuid.
    //
    UINT32 CpuidIndex;

    //
    // HvInterceptTypeX64Exception.
    //
    UINT16 ExceptionVector;

    //
    // N.B. Other intercept types do not have any paramaters.
    //

} HV_INTERCEPT_PARAMETERS, *PHV_INTERCEPT_PARAMETERS;


//
// Define intercept descriptor structure.
//
typedef struct  _HV_INTERCEPT_DESCRIPTOR
{
    HV_INTERCEPT_TYPE Type;
    HV_INTERCEPT_PARAMETERS Parameters;
} HV_INTERCEPT_DESCRIPTOR, *PHV_INTERCEPT_DESCRIPTOR;
typedef const HV_INTERCEPT_DESCRIPTOR *PCHV_INTERCEPT_DESCRIPTOR;

//
// Virtual Processor Indices
//
typedef UINT32 HV_VP_INDEX, *PHV_VP_INDEX;

#define HV_MAX_VP_INDEX (63)

//
// Declare the MSR for determining the current VP index.
//
#define HV_X64_MSR_VP_INDEX     0x40000002
#define HV_X64_MSR_RESET        0x40000003

//
// Declare the VP run time MSR.
//
#define HV_X64_MSR_VP_RUNTIME   0x40000010

//
// Scheduling control
//
typedef union _HV_SCHEDULING_CONTROL
{
    UINT64 AsUINT64;

    struct
    {
        UINT64  DeterministicTsc:1;
        UINT64  Reserved:63;
    };

} HV_SCHEDULING_CONTROL, *PHV_SCHEDULING_CONTROL;

//
// Typedefs for CPUID leaves on HvMicrosoftHypercallInterface-supporting
// hypervisors.
// =====================================================================
//

//
// Microsoft hypervisor interface signature.
//
typedef enum _HV_HYPERVISOR_INTERFACE
{
    HvMicrosoftHypervisorInterface = '1#vH'

} HV_HYPERVISOR_INTERFACE, *PHV_HYPERVISOR_INTERFACE;


//
// Version info reported by both guest OS's and hypervisors
//
typedef enum _HV_SERVICE_BRANCH
{
    //
    // [General Distribution Release (GDR) Branch]
    //
    // This branch extends main releases and service pack releases with
    // patches that are generally distributed and recommended to all customers,
    // such as critical fixes.
    //
    // Unmodified main releases and service pack releases are members of this
    // branch.
    //
    HvServiceBranchGdr = 0x00000000,

    //
    // [Quality Fix Engineering (QFE) Branch]
    //
    // This branch extends main releases and service pack releases with
    // patches that are not generally distributed to all customers, such as
    // feature enhancements.
    //
    HvServiceBranchQfe = 0x00000001

} HV_SERVICE_BRANCH, *PHV_SERVICE_BRANCH;

//
// Version info reported by hypervisors
//
typedef struct _HV_HYPERVISOR_VERSION_INFO
{
    UINT32 BuildNumber;

    UINT32 MinorVersion:16;
    UINT32 MajorVersion:16;

    UINT32 ServicePack;

    UINT32 ServiceNumber:24;
    UINT32 ServiceBranch:8; // Type is HV_SERVICE_BRANCH

} HV_HYPERVISOR_VERSION_INFO, *PHV_HYPERVISOR_VERSION_INFO;

//
// The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
// is set by CPUID(HvCpuIdFunctionVersionAndFeatures).
// ==========================================================================
//

typedef enum _HV_CPUID_FUNCTION
{
    HvCpuIdFunctionVersionAndFeatures           = 0x00000001,
    HvCpuIdFunctionHvVendorAndMaxFunction       = 0x40000000,
    HvCpuIdFunctionHvInterface                  = 0x40000001,

    //
    // The remaining functions depend on the value of HvCpuIdFunctionInterface
    //
    HvCpuIdFunctionMsHvVersion                  = 0x40000002,
    HvCpuIdFunctionMsHvFeatures                 = 0x40000003,
    HvCpuIdFunctionMsHvEnlightenmentInformation = 0x40000004,
    HvCpuIdFunctionMsHvImplementationLimits     = 0x40000005

} HV_CPUID_FUNCTION, *PHV_CPUID_FUNCTION;

typedef union _HV_CPUID_RESULT
{
    struct
    {
        UINT32 Eax;
        UINT32 Ebx;
        UINT32 Ecx;
        UINT32 Edx;
    };

    UINT32 AsUINT32[4];

    struct
    {
        //
        // Eax
        //
        UINT32 ReservedEax;

        //
        // Ebx
        //
        UINT32 ReservedEbx:24;
        UINT32 InitialApicId:8;

        //
        // Ecx
        //
        UINT32 ReservedEcx:31;
        UINT32 HypervisorPresent:1;

        //
        // Edx
        //
        UINT32 ReservedEdx;

    } VersionAndFeatures;

    struct
    {
        //
        // Eax
        //
        UINT32 MaxFunction;

        //
        // Ebx-Edx
        //
        UINT8 VendorName[12];

    } HvVendorAndMaxFunction;

    struct
    {
        //
        // Eax
        //
        UINT32 Interface; // HV_HYPERVISOR_INTERFACE

        //
        // Ebx
        //
        UINT32 ReservedEbx;

        //
        // Ecx
        //
        UINT32 ReservedEcx;

        //
        // Edx
        //
        UINT32 ReservedEdx;

    } HvInterface;

    //
    // Eax-Edx.
    //
    HV_HYPERVISOR_VERSION_INFO MsHvVersion;

    struct
    {
        //
        // Eax-Ebx
        //
        HV_PARTITION_PRIVILEGE_MASK PartitionPrivileges;

        //
        // Ecx - this indicates the power configuration for the current VP.
        //
        UINT32 MaxSupportedCState:4;
        UINT32 Reserved:28;

        //
        // Edx
        //
        UINT32 MwaitAvailable:1;
        UINT32 GuestDebuggingAvailable:1;
        UINT32 PerformanceMonitorsAvailable:1;
        UINT32 Reserved1:29;

    } MsHvFeatures;

    struct
    {
        //
        // Eax
        //
        UINT32 UseHypercallForAddressSpaceSwitch:1;
        UINT32 UseHypercallForLocalFlush:1;
        UINT32 UseHypercallForRemoteFlush:1;
        UINT32 UseApicMsrs:1;
        UINT32 UseMsrForReset:1;
        UINT32 UseRelaxedTiming:1;
        UINT32 Reserved:26;

        //
        // Ebx
        //
        UINT32 LongSpinWaitCount;

        //
        // Ecx
        //
        UINT32 ReservedEcx;

        //
        // Edx
        //
        UINT32 ReservedEdx;

    } MsHvEnlightenmentInformation;

    struct
    {
        //
        // Eax
        //
        UINT32 MaxVirtualProcessorCount;

        //
        // Ebx
        //
        UINT32 MaxLogicalProcessorCount;

        //
        // Ecx
        //
        UINT32 ReservedEcx;

        //
        // Edx
        //
        UINT32 ReservedEdx;

    } MsHvImplementationLimits;

} HV_CPUID_RESULT, *PHV_CPUID_RESULT;

#define HV_CPUID_HV_VENDOR_MICROSOFT_EBX 'rciM'
#define HV_CPUID_HV_VENDOR_MICROSOFT_ECX 'foso'
#define HV_CPUID_HV_VENDOR_MICROSOFT_EDX 'vH t'

//
// Address spaces presented by the guest.
//
typedef UINT64 HV_ADDRESS_SPACE_ID, *PHV_ADDRESS_SPACE_ID;

//
// Address space flush flags.
//
typedef UINT64 HV_FLUSH_FLAGS, *PHV_FLUSH_FLAGS;

#define HV_FLUSH_ALL_PROCESSORS              (0x00000001)
#define HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES  (0x00000002)
#define HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY    (0x00000004)
#define HV_FLUSH_MASK                        (HV_FLUSH_ALL_PROCESSORS | \
                                              HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES | \
                                              HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY)

//
// Address translation flags.
//

#define HV_TRANSLATE_GVA_VALIDATE_READ       (0x0001)
#define HV_TRANSLATE_GVA_VALIDATE_WRITE      (0x0002)
#define HV_TRANSLATE_GVA_VALIDATE_EXECUTE    (0x0004)
#define HV_TRANSLATE_GVA_PRIVILEGE_EXEMPT    (0x0008)
#define HV_TRANSLATE_GVA_SET_PAGE_TABLE_BITS (0x0010)
#define HV_TRANSLATE_GVA_TLB_FLUSH_INHIBIT   (0x0020)
#define HV_TRANSLATE_GVA_CONTROL_MASK        (0x003F)

typedef UINT64 HV_TRANSLATE_GVA_CONTROL_FLAGS, *PHV_TRANSLATE_GVA_CONTROL_FLAGS;

typedef enum _HV_TRANSLATE_GVA_RESULT_CODE
{
    HvTranslateGvaSuccess                 = 0,

    // Translation Failures
    HvTranslateGvaPageNotPresent          = 1,
    HvTranslateGvaPrivilegeViolation      = 2,
    HvTranslateGvaInvalidPageTableFlags   = 3,

    // GPA access failures
    HvTranslateGvaGpaUnmapped             = 4,
    HvTranslateGvaGpaNoReadAccess         = 5,
    HvTranslateGvaGpaNoWriteAccess        = 6,
    HvTranslateGvaGpaIllegalOverlayAccess = 7

} HV_TRANSLATE_GVA_RESULT_CODE, *PHV_TRANSLATE_GVA_RESULT_CODE;

typedef union _HV_TRANSLATE_GVA_RESULT
{
    UINT64 AsUINT64;
    struct
    {
        HV_TRANSLATE_GVA_RESULT_CODE ResultCode;
        UINT32 CacheType : 8;
        UINT32 OverlayPage : 1;
        UINT32 Reserved : 23;
    };
} HV_TRANSLATE_GVA_RESULT, *PHV_TRANSLATE_GVA_RESULT;

//
// Read and write GPA access flags.
//

typedef union _HV_ACCESS_GPA_CONTROL_FLAGS
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 CacheType : 8;  // Cache type for access
        UINT64 Reserved  : 56;
    };
} HV_ACCESS_GPA_CONTROL_FLAGS, *PHV_ACCESS_GPA_CONTROL_FLAGS;

typedef enum _HV_ACCESS_GPA_RESULT_CODE
{
    HvAccessGpaSuccess              = 0,

    // GPA access failures
    HvAccessGpaUnmapped             = 1,
    HvAccessGpaReadIntercept        = 2,
    HvAccessGpaWriteIntercept       = 3,
    HvAccessGpaIllegalOverlayAccess = 4

} HV_ACCESS_GPA_RESULT_CODE, *PHV_ACCESS_GPA_RESULT_CODE;

typedef union _HV_ACCESS_GPA_RESULT
{
    UINT64 AsUINT64;
    struct
    {
        HV_ACCESS_GPA_RESULT_CODE ResultCode;
        UINT32                    Reserved;
    };
} HV_ACCESS_GPA_RESULT, *PHV_ACCESS_GPA_RESULT;

//
// Cache types.
//
typedef enum _HV_CACHE_TYPE
{
    HvCacheTypeX64Uncached       = 0,
    HvCacheTypeX64WriteCombining = 1,
    HvCacheTypeX64WriteThrough   = 4,
    HvCacheTypeX64WriteProtected = 5,
    HvCacheTypeX64WriteBack      = 6
} HV_CACHE_TYPE, *PHV_CACHE_TYPE;

//
// Flags to describe the access a partition has to a GPA page.
//
typedef UINT32 HV_MAP_GPA_FLAGS;

#define HV_MAP_GPA_READABLE	(0x00000001)
#define HV_MAP_GPA_WRITABLE	(0x00000002)
#define HV_MAP_GPA_EXECUTABLE	(0x00000004)

//
// Gva Range
//
// The GVA range is a compressed range of GVA used by the TLB flush
// routines.
//

typedef union _HV_GVA_RANGE
{
    UINT64 AsUINT64;

    struct
    {
        //
        // Additional pages supplies the number of pages beyond one.
        //

        UINT64 AdditionalPages : 12;

        //
        // GvaPageNumber supplies the top 54 most significant bits of the
        // guest virtual address space.
        //

        UINT64 GvaPageNumber   : 52;
    };
} HV_GVA_RANGE, *PHV_GVA_RANGE;


//
// Define index of synthetic interrupt source that receives intercept messages.
//
#define HV_SYNIC_INTERCEPTION_SINT_INDEX ((HV_SYNIC_SINT_INDEX)0)


//
// Define the virtual APIC registers
//
#define HV_X64_MSR_EOI                  (0x40000070)
#define HV_X64_MSR_ICR                  (0x40000071)
#define HV_X64_MSR_TPR                  (0x40000072)
#define HV_X64_MSR_APIC_ASSIST_PAGE     (0x40000073)

//
// Define bit that enables the APIC assist page.
//
#define HV_X64_APIC_ASSIST_PAGE_ENABLE  0x1

//
// Define version of the synthetic interrupt controller.
//

#define HV_SYNIC_VERSION        (1)


//
// Define synthetic interrupt controller model specific registers.
//

#define HV_X64_MSR_SCONTROL   (0x40000080)
#define HV_X64_MSR_SVERSION   (0x40000081)
#define HV_X64_MSR_SIEFP      (0x40000082)
#define HV_X64_MSR_SIMP       (0x40000083)
#define HV_X64_MSR_EOM        (0x40000084)
#define HV_X64_MSR_SINT0      (0x40000090)
#define HV_X64_MSR_SINT1      (0x40000091)
#define HV_X64_MSR_SINT2      (0x40000092)
#define HV_X64_MSR_SINT3      (0x40000093)
#define HV_X64_MSR_SINT4      (0x40000094)
#define HV_X64_MSR_SINT5      (0x40000095)
#define HV_X64_MSR_SINT6      (0x40000096)
#define HV_X64_MSR_SINT7      (0x40000097)
#define HV_X64_MSR_SINT8      (0x40000098)
#define HV_X64_MSR_SINT9      (0x40000099)
#define HV_X64_MSR_SINT10     (0x4000009A)
#define HV_X64_MSR_SINT11     (0x4000009B)
#define HV_X64_MSR_SINT12     (0x4000009C)
#define HV_X64_MSR_SINT13     (0x4000009D)
#define HV_X64_MSR_SINT14     (0x4000009E)
#define HV_X64_MSR_SINT15     (0x4000009F)

//
// Define the expected SynIC version.
//
#define HV_SYNIC_VERSION_1 (0x1)

//
// Define synthetic interrupt controller message constants.
//

#define HV_MESSAGE_SIZE                 (256)
#define HV_MESSAGE_PAYLOAD_BYTE_COUNT   (240)
#define HV_MESSAGE_PAYLOAD_QWORD_COUNT  (30)
#define HV_ANY_VP                       (0xFFFFFFFF)

//
// Define synthetic interrupt controller flag constants.
//

#define HV_EVENT_FLAGS_COUNT        (256 * 8)
#define HV_EVENT_FLAGS_BYTE_COUNT   (256)
#define HV_EVENT_FLAGS_DWORD_COUNT  (256 / sizeof(UINT32))

//
// Define lowest permissible vector that can be sent or received by the local
// APIC.
//
#define HV_SYNIC_APIC_MINIMUM_VECTOR    0x10

//
// Define hypervisor message types.
//
typedef enum _HV_MESSAGE_TYPE
{
    HvMessageTypeNone = 0x00000000,

    //
    // Memory access messages.
    //
    HvMessageTypeUnmappedGpa = 0x80000000,
    HvMessageTypeGpaIntercept = 0x80000001,

    //
    // Timer notification messages.
    //
    HvMessageTimerExpired = 0x80000010,

    //
    // Error messages.
    //
    HvMessageTypeInvalidVpRegisterValue = 0x80000020,
    HvMessageTypeUnrecoverableException = 0x80000021,
    HvMessageTypeUnsupportedFeature = 0x80000022,

    //
    // Trace buffer complete messages.
    //
    HvMessageTypeEventLogBufferComplete = 0x80000040,

    //
    // Platform-specific processor intercept messages.
    //
    HvMessageTypeX64IoPortIntercept = 0x80010000,
    HvMessageTypeX64MsrIntercept = 0x80010001,
    HvMessageTypeX64CpuidIntercept = 0x80010002,
    HvMessageTypeX64ExceptionIntercept = 0x80010003,
    HvMessageTypeX64ApicEoi = 0x80010004,
    HvMessageTypeX64LegacyFpError = 0x80010005

} HV_MESSAGE_TYPE, *PHV_MESSAGE_TYPE;


#define HV_MESSAGE_TYPE_HYPERVISOR_MASK (0x80000000)


//
// Define APIC EOI message.
//
typedef struct _HV_X64_APIC_EOI_MESSAGE
{
    UINT32 VpIndex;
    UINT32 InterruptVector;
} HV_X64_APIC_EOI_MESSAGE, *PHV_X64_APIC_EOI_MESSAGE;


//
// Define the number of synthetic interrupt sources.
//

#define HV_SYNIC_SINT_COUNT (16)
#define HV_SYNIC_STIMER_COUNT (4)

//
// Define the synthetic interrupt source index type.
//

typedef UINT32 HV_SYNIC_SINT_INDEX, *PHV_SYNIC_SINT_INDEX;

//
// Define partition identifier type.
//

typedef UINT64 HV_PARTITION_ID, *PHV_PARTITION_ID;

//
// Define invalid partition identifier.
//
#define HV_PARTITION_ID_INVALID ((HV_PARTITION_ID) 0x0)

//
// Define connection identifier type.
//

typedef union _HV_CONNECTION_ID
{
    UINT32 AsUINT32;

    struct
    {
        UINT32 Id:24;
        UINT32 Reserved:8;
    };

} HV_CONNECTION_ID, *PHV_CONNECTION_ID;

//
// Define port identifier type.
//

typedef union _HV_PORT_ID
{
    UINT32 AsUINT32;

    struct
    {
        UINT32 Id:24;
        UINT32 Reserved:8;
    };

} HV_PORT_ID, *PHV_PORT_ID;

//
// Define port type.
//

typedef enum _HV_PORT_TYPE
{
    HvPortTypeMessage   = 1,
    HvPortTypeEvent     = 2,
    HvPortTypeMonitor   = 3
} HV_PORT_TYPE, *PHV_PORT_TYPE;

//
// Define port information structure.
//

typedef struct _HV_PORT_INFO
{
    HV_PORT_TYPE PortType;
    UINT32 Padding;

    union
    {
        struct
        {
            HV_SYNIC_SINT_INDEX TargetSint;
            HV_VP_INDEX TargetVp;
            UINT64 RsvdZ;
        } MessagePortInfo;

        struct
        {
            HV_SYNIC_SINT_INDEX TargetSint;
            HV_VP_INDEX TargetVp;
            UINT16 BaseFlagNumber;
            UINT16 FlagCount;
            UINT32 RsvdZ;
        } EventPortInfo;

        struct
        {
            HV_GPA MonitorAddress;
            UINT64 RsvdZ;
        } MonitorPortInfo;
    };
} HV_PORT_INFO, *PHV_PORT_INFO;

typedef const HV_PORT_INFO *PCHV_PORT_INFO;

typedef struct _HV_CONNECTION_INFO
{
    HV_PORT_TYPE PortType;
    UINT32 Padding;

    union
    {
        struct
        {
            UINT64 RsvdZ;
        } MessageConnectionInfo;

        struct
        {
            UINT64 RsvdZ;
        } EventConnectionInfo;

        struct
        {
            HV_GPA MonitorAddress;
        } MonitorConnectionInfo;
    };
} HV_CONNECTION_INFO, *PHV_CONNECTION_INFO;

typedef const HV_CONNECTION_INFO *PCHV_CONNECTION_INFO;

//
// Define type of port property.
//

typedef UINT64 HV_PORT_PROPERTY, *PHV_PORT_PROPERTY;

//
// Define enumeration of port property codes.
//

typedef enum _HV_PORT_PROPERTY_CODE
{
    HvPortPropertyPostCount = 0x00000000
} HV_PORT_PROPERTY_CODE, *PHV_PORT_PROPERTY_CODE;


//
// Define synthetic interrupt controller message flags.
//

typedef union _HV_MESSAGE_FLAGS
{
    UINT8 AsUINT8;
    struct
    {
        UINT8 MessagePending:1;
        UINT8 Reserved:7;
    };
} HV_MESSAGE_FLAGS, *PHV_MESSAGE_FLAGS;


//
// Define synthetic interrupt controller message header.
//

typedef struct _HV_MESSAGE_HEADER
{
    HV_MESSAGE_TYPE     MessageType;
    UINT8               PayloadSize;
    HV_MESSAGE_FLAGS    MessageFlags;
    UINT8               Reserved[2];
    union
    {
        HV_PARTITION_ID Sender;
        HV_PORT_ID      Port;
    };

} HV_MESSAGE_HEADER, *PHV_MESSAGE_HEADER;

//
// Define timer message payload structure.
//
typedef struct _HV_TIMER_MESSAGE_PAYLOAD
{
    UINT32          TimerIndex;
    UINT32          Reserved;
    HV_NANO100_TIME ExpirationTime;     // When the timer expired
    HV_NANO100_TIME DeliveryTime;       // When the message was delivered
} HV_TIMER_MESSAGE_PAYLOAD, *PHV_TIMER_MESSAGE_PAYLOAD;

//
// Define synthetic interrupt controller message format.
//

typedef struct _HV_MESSAGE
{
    HV_MESSAGE_HEADER Header;
    union
    {
        UINT64 Payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];
        HV_TIMER_MESSAGE_PAYLOAD TimerPayload;
        HV_EVENTLOG_MESSAGE_PAYLOAD TracePayload;
    };
} HV_MESSAGE, *PHV_MESSAGE;

//
// Define the number of message buffers associated with each port.
//

#define HV_PORT_MESSAGE_BUFFER_COUNT (16)

//
// Define the synthetic interrupt message page layout.
//

typedef struct _HV_MESSAGE_PAGE
{
    volatile HV_MESSAGE SintMessage[HV_SYNIC_SINT_COUNT];
} HV_MESSAGE_PAGE, *PHV_MESSAGE_PAGE;


//
// Define the synthetic interrupt controller event flags format.
//

typedef union _HV_SYNIC_EVENT_FLAGS
{
    UINT8 Flags8[HV_EVENT_FLAGS_BYTE_COUNT];
    UINT32 Flags32[HV_EVENT_FLAGS_DWORD_COUNT];
} HV_SYNIC_EVENT_FLAGS, *PHV_SYNIC_EVENT_FLAGS;


//
// Define the synthetic interrupt flags page layout.
//

typedef struct _HV_SYNIC_EVENT_FLAGS_PAGE
{
    volatile HV_SYNIC_EVENT_FLAGS SintEventFlags[HV_SYNIC_SINT_COUNT];
} HV_SYNIC_EVENT_FLAGS_PAGE, *PHV_SYNIC_EVENT_FLAGS_PAGE;


//
// Define SynIC control register.
//
typedef union _HV_SYNIC_SCONTROL
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 Enable:1;
        UINT64 Reserved:63;
    };
} HV_SYNIC_SCONTROL, *PHV_SYNIC_SCONTROL;

//
// Define synthetic interrupt source.
//

typedef union _HV_SYNIC_SINT
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 Vector    :8;
        UINT64 Reserved1 :8;
        UINT64 Masked    :1;
        UINT64 AutoEoi   :1;
        UINT64 Reserved2 :46;
    };
} HV_SYNIC_SINT, *PHV_SYNIC_SINT;

//
// Define the format of the SIMP register
//

typedef union _HV_SYNIC_SIMP
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 SimpEnabled : 1;
        UINT64 Preserved   : 11;
        UINT64 BaseSimpGpa : 52;
    };
} HV_SYNIC_SIMP, *PHV_SYNIC_SIMP;

//
// Define the format of the SIEFP register
//

typedef union _HV_SYNIC_SIEFP
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 SiefpEnabled : 1;
        UINT64 Preserved   : 11;
        UINT64 BaseSiefpGpa : 52;
    };
} HV_SYNIC_SIEFP, *PHV_SYNIC_SIEFP;

//
// Define virtual interrupt control structure.
//
typedef union _HV_INTERRUPT_CONTROL
{
    UINT64 AsUINT64;
    struct
    {
        HV_INTERRUPT_TYPE InterruptType;
        UINT32 LevelTriggered:1;
        UINT32 LogicalDestinationMode:1;
        UINT32 Reserved:30;
    };
} HV_INTERRUPT_CONTROL, *PHV_INTERRUPT_CONTROL;


//
// Emulated timer period
//
typedef union _HV_EMULATED_TIMER_PERIOD
{
    UINT64              AsUINT64;
    HV_NANO100_DURATION Period;

} HV_EMULATED_TIMER_PERIOD, *PHV_EMULATED_TIMER_PERIOD;

//
// Periodic Timer route
//
typedef union _HV_EMULATED_TIMER_CONTROL
{
    UINT64  AsUINT64;

    struct
    {
        UINT32  Vector                  :  8;
        UINT32  DeliveryMode            :  3;
        UINT32  LogicalDestinationMode  :  1;
        UINT32  Enabled                 :  1;
        UINT32  Reserved                : 19;
        UINT32  Mda                     : 32;
    };

} HV_EMULATED_TIMER_CONTROL, *PHV_EMULATED_TIMER_CONTROL;

//
// ACPI PM timer
//
typedef union _HV_PM_TIMER_INFO
{
    UINT64  AsUINT64;

    struct
    {
        UINT32  Port                : 16;
        UINT32  Width24             :  1;
        UINT32  Enabled             :  1;
        UINT32  Reserved1           : 14;
        UINT32  Reserved2           : 32;
    };

} HV_PM_TIMER_INFO, *PHV_PM_TIMER_INFO;

//
// Definitions for the monitored notification facility
//

typedef union _HV_MONITOR_TRIGGER_GROUP
{
    UINT64 AsUINT64;

    struct
    {
        UINT32 Pending;
        UINT32 Armed;
    };
    
} HV_MONITOR_TRIGGER_GROUP, *PHV_MONITOR_TRIGGER_GROUP;

typedef struct _HV_MONITOR_PARAMETER
{
    HV_CONNECTION_ID    ConnectionId;
    UINT16              FlagNumber;
    UINT16              RsvdZ;
} HV_MONITOR_PARAMETER, *PHV_MONITOR_PARAMETER;

typedef union _HV_MONITOR_TRIGGER_STATE
{
    UINT32 AsUINT32;
        
    struct
    {
        UINT32 GroupEnable : 4;
        UINT32 RsvdZ       : 28;
    };

} HV_MONITOR_TRIGGER_STATE, *PHV_MONITOR_TRIGGER_STATE;

//
// HV_MONITOR_PAGE Layout
// ------------------------------------------------------
// | 0   | TriggerState (4 bytes) | Rsvd1 (4 bytes)     |
// | 8   | TriggerGroup[0]                              |
// | 10  | TriggerGroup[1]                              |
// | 18  | TriggerGroup[2]                              |
// | 20  | TriggerGroup[3]                              |
// | 28  | Rsvd2[0]                                     |
// | 30  | Rsvd2[1]                                     |
// | 38  | Rsvd2[2]                                     |
// | 40  | NextCheckTime[0][0]    | NextCheckTime[0][1] |
// | ...                                                |
// | 240 | Latency[0][0..3]                             |
// | 340 | Rsvz3[0]                                     |
// | 440 | Parameter[0][0]                              |
// | 448 | Parameter[0][1]                              |
// | ...                                                |
// | 840 | Rsvd4[0]                                     |
// ------------------------------------------------------

typedef struct _HV_MONITOR_PAGE
{
    HV_MONITOR_TRIGGER_STATE TriggerState;
    UINT32                   RsvdZ1;

    HV_MONITOR_TRIGGER_GROUP TriggerGroup[4];
    UINT64                   RsvdZ2[3];

    INT32                    NextCheckTime[4][32];

    UINT16                   Latency[4][32];
    UINT64                   RsvdZ3[32];

    HV_MONITOR_PARAMETER     Parameter[4][32];

    UINT8                    RsvdZ4[1984];

} HV_MONITOR_PAGE, *PHV_MONITOR_PAGE;

typedef volatile HV_MONITOR_PAGE* PVHV_MONITOR_PAGE;


//
// Debug channel identifier
//
typedef UINT16 HV_DEBUG_CHANNEL_IDENTIFIER;

//
// Maximum size of the payload
//
#define HV_DEBUG_MAXIMUM_DATA_SIZE 4088

//
// Debug options for all calls
//
typedef UINT32 HV_DEBUG_OPTIONS;

//
// Options flags for HvPostDebugData
//
#define HV_DEBUG_POST_LOOP                  0x00000001

//
// Options flags for HvRetrieveDebugData
//
#define HV_DEBUG_RETRIEVE_LOOP              0x00000001
#define HV_DEBUG_RETRIEVE_TEST_ACTIVITY     0x00000002

//
// Options flags for HvResetDebugSession
//
#define HV_DEBUG_PURGE_INCOMING_DATA        0x00000001
#define HV_DEBUG_PURGE_OUTGOING_DATA        0x00000002

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_POST_DEBUG_DATA
{
    UINT32 Count;
    HV_DEBUG_OPTIONS Options;
    UINT8 Data[HV_DEBUG_MAXIMUM_DATA_SIZE];
} HV_INPUT_POST_DEBUG_DATA, *PHV_INPUT_POST_DEBUG_DATA;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_POST_DEBUG_DATA
{
    UINT32 PendingCount;
} HV_OUTPUT_POST_DEBUG_DATA, *PHV_OUTPUT_POST_DEBUG_DATA;

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_RETRIEVE_DEBUG_DATA
{
    UINT32 Count;
    HV_DEBUG_OPTIONS Options;
    HV_NANO100_DURATION Timeout;
} HV_INPUT_RETRIEVE_DEBUG_DATA, *PHV_INPUT_RETRIEVE_DEBUG_DATA;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_RETRIEVE_DEBUG_DATA
{
    UINT32 RetrievedCount;
    UINT32 RemainingCount;
    UINT8 Data[HV_DEBUG_MAXIMUM_DATA_SIZE];
} HV_OUTPUT_RETRIEVE_DEBUG_DATA, *PHV_OUTPUT_RETRIEVE_DEBUG_DATA;

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_RESET_DEBUG_SESSION
{
    HV_DEBUG_OPTIONS Options;
} HV_INPUT_RESET_DEBUG_SESSION, *PHV_INPUT_RESET_DEBUG_SESSION;

//
// Mux Protocol Defines
//
#define HV_MUX_PACKET_LEADER            0x11223344

#define HV_MUX_PACKET_TYPE_DATA             0x0001
#define HV_MUX_PACKET_TYPE_BREAKIN          0x0002
#define HV_MUX_PACKET_TYPE_QUERY_CHANNELS   0x0003

#define HV_MUX_PACKET_TYPE_MAXIMUM          HV_MUX_PACKET_TYPE_QUERY_CHANNELS

#define HV_MUX_PACKET_DUMMY_BYTE        0xEE

#pragma pack(1)
typedef struct _HV_MUX_PACKET_HEADER
{
    UINT32 Leader;
    UINT16 Type;
    UINT16 Length;
    UINT32 CRC;
    HV_DEBUG_CHANNEL_IDENTIFIER Channel;
    UINT16 Reserved;

} HV_MUX_PACKET_HEADER, *PHV_MUX_PACKET_HEADER;

//
// Channel data returned in a HV_MUX_PACKET_TYPE_QUERY_CHANNELS
// respone. The channelIds arrays is variable length array
// 

typedef struct 
{
    UINT32 Count;
    HV_DEBUG_CHANNEL_IDENTIFIER ChannelIds[1];

} MUX_CHANNEL_DATA, *PMUX_CHANNEL_DATA;

#pragma pack()

//
// Debug Channel Id
//
#define HV_DEBUG_CHANNEL_ID_HYPERVISOR      0x00000000
#define HV_DEBUG_CHANNEL_ID_ROOT            0x00000001
#define HV_DEBUG_CHANNEL_ID_DEFAULT         0x0000BADA
#define HV_DEBUG_CHANNEL_ID_ASSIGN_START    0x00000002
#define HV_DEBUG_CHANNEL_ID_FW_MAX          0x0000003E

//
// This structure is used to transfer crashdump information between the
// Hypervisor and the HvBoot.sys driver in the root Windows instance at the
// time of a Hypervisor BugCheck.  It is allocated by HvBoot.sys during the
// Hypervisor launch process, and its SPA is handed in to the Hypervisor via
// the loader block.
//

#define HV_CRASHDUMP_AREA_VERSION   1
#define HV_IMAGE_NAME_MAX_LENGTH    32
#define HV_DEFAULT_CRASHDUMP_SPA_PAGES 5

typedef struct _HV_CRASHDUMP_AREA
{
    //
    // Version of the Crashdump Area structure
    //

    UINT32 Version;

    //
    // Flags indicating content validity and other attributes of the
    // Crashdump Area
    //

    union
    {
        UINT32 FlagsAsUINT32;
        struct
        {
            //
            // Indicates the contents of the Crashdump Area are valid
            //

            UINT32  Valid:1;
            UINT32  Reserved:31;

        };

    };

    //
    //  Loaded Module Information
    //

    UINT64 HypervisorBase;
    UINT32 SizeOfImage;
    UINT16 ImageNameLength;
    WCHAR ImageName[HV_IMAGE_NAME_MAX_LENGTH];

    //
    // Bugcheck error code fields
    //

    UINT64 BugCheckData[5];
    void  *BugCheckErrorReturnAddress;

    //
    // The root of the page table needed to lookup virtual addresses
    // and the debugger data block. The debugger data block contains
    // all the information necc. for the debugger to interpret the 
    // dump file. Of particular interest within it is the prcb address 
    // that contain the processor state.
    //

    UINT64 PageTableBase;
    UINT64 PfnDataBase;
    UINT64 DebuggerDataBlock;
    UINT32 NumberProcessors;

    //
    //  Count and offset to a list of pfns to add to the dump 
    //

    UINT32 PfnCount;
    UINT32 PfnListOffset;

} HV_CRASHDUMP_AREA, *PHV_CRASHDUMP_AREA;




//
// Define virtual processor execution state bitfield.
//
typedef union _HV_X64_VP_EXECUTION_STATE
{
    UINT16 AsUINT16;
    struct
    {
        UINT16 Cpl:2;
        UINT16 Cr0Pe:1;
        UINT16 Cr0Am:1;
        UINT16 EferLma:1;
        UINT16 DebugActive:1;
        UINT16 InterruptionPending:1;
        UINT16 Reserved:9;
    };
} HV_X64_VP_EXECUTION_STATE, *PHV_X64_VP_EXECUTION_STATE;


//
// Define intercept message header structure.
//
typedef struct _HV_X64_INTERCEPT_MESSAGE_HEADER
{
    HV_VP_INDEX VpIndex;
    UINT8 InstructionLength;
    HV_INTERCEPT_ACCESS_TYPE InterceptAccessType;
    HV_X64_VP_EXECUTION_STATE ExecutionState;
    HV_X64_SEGMENT_REGISTER CsSegment;
    UINT64 Rip;
    UINT64 Rflags;
} HV_X64_INTERCEPT_MESSAGE_HEADER, *PHV_X64_INTERCEPT_MESSAGE_HEADER;


//
// Define memory access information structure.
//
typedef union _HV_X64_MEMORY_ACCESS_INFO
{
    UINT8 AsUINT8;
    struct
    {
        UINT8 GvaValid:1;
        UINT8 Reserved:7;
    };
} HV_X64_MEMORY_ACCESS_INFO, *PHV_X64_MEMORY_ACCESS_INFO;


//
// Define IO port access information structure.
//
typedef union _HV_X64_IO_PORT_ACCESS_INFO
{
    UINT8 AsUINT8;
    struct
    {
        UINT8 AccessSize:3;
        UINT8 StringOp:1;
        UINT8 RepPrefix:1;
        UINT8 Reserved:3;
    };
} HV_X64_IO_PORT_ACCESS_INFO, *PHV_X64_IO_PORT_ACCESS_INFO;


//
// Define exception information structure.
//
typedef union _HV_X64_EXCEPTION_INFO
{
    UINT8 AsUINT8;
    struct
    {
        UINT8 ErrorCodeValid:1;
        UINT8 Reserved:7;
    };
} HV_X64_EXCEPTION_INFO, *PHV_X64_EXCEPTION_INFO;


//
// Define memory access message structure. This message structure is used
// for memory intercepts, GPA not present intercepts and SPA access violation
// intercepts.
//
typedef struct _HV_X64_MEMORY_INTERCEPT_MESSAGE
{
    HV_X64_INTERCEPT_MESSAGE_HEADER Header;
    HV_CACHE_TYPE CacheType;
    UINT8 InstructionByteCount;
    HV_X64_MEMORY_ACCESS_INFO MemoryAccessInfo;
    UINT16 Reserved1;
    UINT64 GuestVirtualAddress;
    UINT64 GuestPhysicalAddress;
    UINT8 InstructionBytes[16];
    HV_X64_SEGMENT_REGISTER DsSegment;
    HV_X64_SEGMENT_REGISTER SsSegment;
    UINT64 Rax;
    UINT64 Rcx;
    UINT64 Rdx;
    UINT64 Rbx;
    UINT64 Rsp;
    UINT64 Rbp;
    UINT64 Rsi;
    UINT64 Rdi;
    UINT64 R8;
    UINT64 R9;
    UINT64 R10;
    UINT64 R11;
    UINT64 R12;
    UINT64 R13;
    UINT64 R14;
    UINT64 R15;
} HV_X64_MEMORY_INTERCEPT_MESSAGE, *PHV_X64_MEMORY_INTERCEPT_MESSAGE;


//
// Define CPUID intercept message structure.
//
typedef struct _HV_X64_CPUID_INTERCEPT_MESSAGE
{
    HV_X64_INTERCEPT_MESSAGE_HEADER Header;
    UINT64 Rax;
    UINT64 Rcx;
    UINT64 Rdx;
    UINT64 Rbx;
    UINT64 DefaultResultRax;
    UINT64 DefaultResultRcx;
    UINT64 DefaultResultRdx;
    UINT64 DefaultResultRbx;
} HV_X64_CPUID_INTERCEPT_MESSAGE, *PHV_X64_CPUID_INTERCEPT_MESSAGE;


//
// Define MSR intercept message structure.
//
typedef struct _HV_X64_MSR_INTERCEPT_MESSAGE
{
    HV_X64_INTERCEPT_MESSAGE_HEADER Header;
    UINT32 MsrNumber;
    UINT32 Reserved;
    UINT64 Rdx;
    UINT64 Rax;
} HV_X64_MSR_INTERCEPT_MESSAGE, *PHV_X64_MSR_INTERCEPT_MESSAGE;


//
// Define IO access intercept message structure.
//
typedef struct _HV_X64_IO_PORT_INTERCEPT_MESSAGE
{
    HV_X64_INTERCEPT_MESSAGE_HEADER Header;
    UINT16 PortNumber;
    HV_X64_IO_PORT_ACCESS_INFO AccessInfo;
    UINT8 InstructionByteCount;
    UINT32 Reserved;
    UINT64 Rax;
    UINT8 InstructionBytes[16];
    HV_X64_SEGMENT_REGISTER DsSegment;
    HV_X64_SEGMENT_REGISTER EsSegment;
    UINT64 Rcx;
    UINT64 Rsi;
    UINT64 Rdi;
} HV_X64_IO_PORT_INTERCEPT_MESSAGE, *PHV_X64_IO_PORT_INTERCEPT_MESSAGE;


//
// Define exception intercept message.
//
typedef struct _HV_X64_EXCEPTION_INTERCEPT_MESSAGE
{
    HV_X64_INTERCEPT_MESSAGE_HEADER Header;
    UINT16 ExceptionVector;
    HV_X64_EXCEPTION_INFO ExceptionInfo;
    UINT8 InstructionByteCount;
    UINT32 ErrorCode;
    UINT64 ExceptionParameter;
    UINT64 Reserved;
    UINT8 InstructionBytes[16];
    HV_X64_SEGMENT_REGISTER DsSegment;
    HV_X64_SEGMENT_REGISTER SsSegment;
    UINT64 Rax;
    UINT64 Rcx;
    UINT64 Rdx;
    UINT64 Rbx;
    UINT64 Rsp;
    UINT64 Rbp;
    UINT64 Rsi;
    UINT64 Rdi;
    UINT64 R8;
    UINT64 R9;
    UINT64 R10;
    UINT64 R11;
    UINT64 R12;
    UINT64 R13;
    UINT64 R14;
    UINT64 R15;
} HV_X64_EXCEPTION_INTERCEPT_MESSAGE, *PHV_X64_EXCEPTION_INTERCEPT_MESSAGE;


//
// Define legacy floating point error message.
//
typedef struct _HV_X64_LEGACY_FP_ERROR_MESSAGE
{
    UINT32 VpIndex;
    UINT32 Reserved;
} HV_X64_LEGACY_FP_ERROR_MESSAGE, *PHV_X64_LEGACY_FP_ERROR_MESSAGE;


//
// Define invalid virtual processor register message.
//
typedef struct _HV_X64_INVALID_VP_REGISTER_MESSAGE
{
    UINT32 VpIndex;
    UINT32 Reserved;
} HV_X64_INVALID_VP_REGISTER_MESSAGE, *PHV_X64_INVALID_VP_REGISTER_MESSAGE;


//
// Define virtual processor unrecoverable error message.
//
typedef struct _HV_X64_UNRECOVERABLE_EXCEPTION_MESSAGE
{
    HV_X64_INTERCEPT_MESSAGE_HEADER Header;
} HV_X64_UNRECOVERABLE_EXCEPTION_MESSAGE, *PHV_X64_UNRECOVERABLE_EXCEPTION_MESSAGE;


//
// Define unsupported feature message.
//
typedef struct _HV_X64_UNSUPPORTED_FEATURE_MESSAGE
{
    UINT32 VpIndex;
    UINT32 FeatureCode;
} HV_X64_UNSUPPORTED_FEATURE_MESSAGE, *PHV_X64_UNSUPPORTED_FEATURE_MESSAGE;


//
// Versioning definitions used for guests reporting themselves to the
// hypervisor, and visa versa.
// ==================================================================
//

//
// Version info reported by guest OS's
//
typedef enum _HV_GUEST_OS_VENDOR
{
    HvGuestOsVendorMicrosoft        = 0x0001

} HV_GUEST_OS_VENDOR, *PHV_GUEST_OS_VENDOR;

typedef enum _HV_GUEST_OS_MICROSOFT_IDS
{
    HvGuestOsMicrosoftUndefined     = 0x00,
    HvGuestOsMicrosoftMSDOS         = 0x01,
    HvGuestOsMicrosoftWindows3x     = 0x02,
    HvGuestOsMicrosoftWindows9x     = 0x03,
    HvGuestOsMicrosoftWindowsNT     = 0x04,
    HvGuestOsMicrosoftWindowsCE     = 0x05

} HV_GUEST_OS_MICROSOFT_IDS, *PHV_GUEST_OS_MICROSOFT_IDS;

//
// Declare the MSR used to identify the guest OS.
//
#define HV_X64_MSR_GUEST_OS_ID 0x40000000

typedef union _HV_X64_MSR_GUEST_OS_ID_CONTENTS
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 BuildNumber    : 16;
        UINT64 ServiceVersion : 8; // Service Pack, etc.
        UINT64 MinorVersion   : 8;
        UINT64 MajorVersion   : 8;
        UINT64 OsId           : 8; // HV_GUEST_OS_MICROSOFT_IDS (If Vendor=MS)
        UINT64 VendorId       : 16; // HV_GUEST_OS_VENDOR
    };
} HV_X64_MSR_GUEST_OS_ID_CONTENTS, *PHV_X64_MSR_GUEST_OS_ID_CONTENTS;

//
// Declare the MSR used to setup pages used to communicate with the hypervisor.
//
#define HV_X64_MSR_HYPERCALL 0x40000001

typedef union _HV_X64_MSR_HYPERCALL_CONTENTS
{
    UINT64 AsUINT64;
    struct
    {
        UINT64 Enable               : 1;
        UINT64 Reserved             : 11;
        UINT64 GuestPhysicalAddress : 52;
    };
} HV_X64_MSR_HYPERCALL_CONTENTS, *PHV_X64_MSR_HYPERCALL_CONTENTS;


//
// Hypercall structures, enumerations, and constants.
// ==================================================
//

//
// Partition Properties
//
typedef UINT64 HV_PARTITION_PROPERTY, *PHV_PARTITION_PROPERTY;

typedef enum
{
    //
    // Privilege properties
    //
    HvPartitionPropertyPrivilegeFlags       = 0x00010000,

    //
    // Scheduling properties
    //
    HvPartitionPropertySchedulingControl    = 0x00020000,
    HvPartitionPropertyCpuReserve           = 0x00020001,
    HvPartitionPropertyCpuCap               = 0x00020002,
    HvPartitionPropertyCpuWeight            = 0x00020003,

    //
    // Timer assist properties
    //
    HvPartitionPropertyEmulatedTimerPeriod  = 0x00030000,
    HvPartitionPropertyEmulatedTimerControl = 0x00030001,
    HvPartitionPropertyPmTimerAssist        = 0x00030002,

    //
    // Debugging properties
    //
    HvPartitionPropertyDebugChannelId       = 0x00040000,

    //
    // Resource properties
    //
    HvPartitionPropertyVirtualTlbPageCount  = 0x00050000

} HV_PARTITION_PROPERTY_CODE, *PHV_PARTITION_PROPERTY_CODE;

//
// Partition scheduling property ranges
//
#define HvPartitionPropertyMinimumCpuReserve    (0 << 16)
#define HvPartitionPropertyMaximumCpuReserve    (1 << 16)
#define HvPartitionPropertyMinimumCpuCap        (0 << 16)
#define HvPartitionPropertyMaximumCpuCap        (1 << 16)
#define HvPartitionPropertyMinimumCpuWeight     1
#define HvPartitionPropertyMaximumCpuWeight     10000

//
// Declare the input and output structures for the HvCreatePartition hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_CREATE_PARTITION
{
    UINT64 Flags;
    HV_PROXIMITY_DOMAIN_INFO ProximityDomainInfo;
} HV_INPUT_CREATE_PARTITION, *PHV_INPUT_CREATE_PARTITION;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_CREATE_PARTITION
{
    HV_PARTITION_ID NewPartitionId;
} HV_OUTPUT_CREATE_PARTITION, *PHV_OUTPUT_CREATE_PARTITION;

//
// Declare the input structure for the HvDeletePartition hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_DELETE_PARTITION
{
    HV_PARTITION_ID PartitionId;
} HV_INPUT_DELETE_PARTITION, *PHV_INPUT_DELETE_PARTITION;

//
// Declare the input structure for the HvFinalizePartition hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_FINALIZE_PARTITION
{
    HV_PARTITION_ID PartitionId;
} HV_INPUT_FINALIZE_PARTITION, *PHV_INPUT_FINALIZE_PARTITION;

//
// Declare the input structure for the HvInitializePartition hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_INITIALIZE_PARTITION
{
    HV_PARTITION_ID PartitionId;
} HV_INPUT_INITIALIZE_PARTITION, *PHV_INPUT_INITIALIZE_PARTITION;

//
// Declare the input and output structures for the HvGetPartitionProperty
// hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_PARTITION_PROPERTY
{
    HV_PARTITION_ID             PartitionId;
    HV_PARTITION_PROPERTY_CODE  PropertyCode;

} HV_INPUT_GET_PARTITION_PROPERTY, *PHV_INPUT_GET_PARTITION_PROPERTY;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_PARTITION_PROPERTY
{
    HV_PARTITION_PROPERTY       PropertyValue;

} HV_OUTPUT_GET_PARTITION_PROPERTY, *PHV_OUTPUT_GET_PARTITION_PROPERTY;

//
// Declare the input structure for the HvSetPartitionProperty hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_SET_PARTITION_PROPERTY
{
    HV_PARTITION_ID             PartitionId;
    HV_PARTITION_PROPERTY_CODE  PropertyCode;
    HV_PARTITION_PROPERTY       PropertyValue;

} HV_INPUT_SET_PARTITION_PROPERTY, *PHV_INPUT_SET_PARTITION_PROPERTY;

//
// Declare the output structure for the HvGetPartitionId hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_PARTITION_ID
{
    HV_PARTITION_ID             PartitionId;

} HV_OUTPUT_GET_PARTITION_ID, *PHV_OUTPUT_GET_PARTITION_ID;

//
// Declare the input and output structures for the
// HvGetNextChildPartition hypercall.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_NEXT_CHILD_PARTITION
{
    HV_PARTITION_ID ParentId;
    HV_PARTITION_ID PreviousChildId;
} HV_INPUT_GET_NEXT_CHILD_PARTITION, *PHV_INPUT_GET_NEXT_CHILD_PARTITION;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_NEXT_CHILD_PARTITION
{
    HV_PARTITION_ID NextChildId;
} HV_OUTPUT_GET_NEXT_CHILD_PARTITION, *PHV_OUTPUT_GET_NEXT_CHILD_PARTITION;

//
// Declare constants and structures for submitting hypercalls.
//
#define HV_X64_MAX_HYPERCALL_ELEMENTS ((1<<12) - 1)

typedef union _HV_X64_HYPERCALL_INPUT
{
    //
    // Input: The call code, argument sizes and calling convention
    //
    struct
    {
        UINT32 CallCode        : 16; // Least significant bits
        UINT32 IsFast          : 1;  // Uses the register based form
        UINT32 Reserved1       : 15;
        UINT32 CountOfElements : 12;
        UINT32 Reserved2       : 4;
        UINT32 RepStartIndex   : 12;
        UINT32 Reserved3       : 4;  // Most significant bits
    };
    UINT64 AsUINT64;

} HV_X64_HYPERCALL_INPUT, *PHV_X64_HYPERCALL_INPUT;

typedef union _HV_X64_HYPERCALL_OUTPUT
{
    //
    // Output: The result and returned data size
    //
    struct
    {
        UINT16 CallStatus;             // Least significant bits
        UINT16 Reserved1;
        UINT32 ElementsProcessed : 12;
        UINT32 Reserved2         : 20; // Most significant bits
    };
    UINT64 AsUINT64;

} HV_X64_HYPERCALL_OUTPUT, *PHV_X64_HYPERCALL_OUTPUT;

//
// Declare the various hypercall operations.
//
typedef enum _HV_CALL_CODE
{
    //
    // Reserved Feature Code
    //

    HvCallReserved0000                  = 0x0000,

    //
    // V1 Address space enlightment IDs
    //

    HvCallSwitchVirtualAddressSpace     = 0x0001,
    HvCallFlushVirtualAddressSpace      = 0x0002,
    HvCallFlushVirtualAddressList       = 0x0003,

    //
    // V1 Power Management and Run time metrics IDs
    //

    HvCallGetLogicalProcessorRunTime        = 0x0004,
    HvCallSetLogicalProcessorRunTimeGroup   = 0x0005,
    HvCallClearLogicalProcessorRunTimeGroup = 0x0006,
    HvCallDepricated0007                    = 0x0007,

    //
    // V1 Spinwait enlightenment IDs
    //

    HvCallNotifyLongSpinWait            = 0x0008,

    //
    // V1 enlightenment name space reservation.
    //

    HvCallReserved0009                  = 0x0009,
    HvCallReserved000a                  = 0x000a,
    HvCallReserved000b                  = 0x000b,
    HvCallReserved000c                  = 0x000c,
    HvCallReserved000d                  = 0x000d,
    HvCallReserved000e                  = 0x000e,
    HvCallReserved000f                  = 0x000f,
    HvCallReserved0010                  = 0x0010,
    HvCallReserved0011                  = 0x0011,
    HvCallReserved0012                  = 0x0012,
    HvCallReserved0013                  = 0x0013,
    HvCallReserved0014                  = 0x0014,
    HvCallReserved0015                  = 0x0015,
    HvCallReserved0016                  = 0x0016,
    HvCallReserved0017                  = 0x0017,
    HvCallReserved0018                  = 0x0018,
    HvCallReserved0019                  = 0x0019,
    HvCallReserved001a                  = 0x001a,
    HvCallReserved001b                  = 0x001b,
    HvCallReserved001c                  = 0x001c,
    HvCallReserved001d                  = 0x001d,
    HvCallReserved001e                  = 0x001e,
    HvCallReserved001f                  = 0x001f,
    HvCallReserved0020                  = 0x0020,
    HvCallReserved0021                  = 0x0021,
    HvCallReserved0022                  = 0x0022,
    HvCallReserved0023                  = 0x0023,
    HvCallReserved0024                  = 0x0024,
    HvCallReserved0025                  = 0x0025,
    HvCallReserved0026                  = 0x0026,
    HvCallReserved0027                  = 0x0027,
    HvCallReserved0028                  = 0x0028,
    HvCallReserved0029                  = 0x0029,
    HvCallReserved002a                  = 0x002a,
    HvCallReserved002b                  = 0x002b,
    HvCallReserved002c                  = 0x002c,
    HvCallReserved002d                  = 0x002d,
    HvCallReserved002e                  = 0x002e,
    HvCallReserved002f                  = 0x002f,
    HvCallReserved0030                  = 0x0030,
    HvCallReserved0031                  = 0x0031,
    HvCallReserved0032                  = 0x0032,
    HvCallReserved0033                  = 0x0033,
    HvCallReserved0034                  = 0x0034,
    HvCallReserved0035                  = 0x0035,
    HvCallReserved0036                  = 0x0036,
    HvCallReserved0037                  = 0x0037,
    HvCallReserved0038                  = 0x0038,
    HvCallReserved0039                  = 0x0039,
    HvCallReserved003a                  = 0x003a,
    HvCallReserved003b                  = 0x003b,
    HvCallReserved003c                  = 0x003c,
    HvCallReserved003d                  = 0x003d,
    HvCallReserved003e                  = 0x003e,
    HvCallReserved003f                  = 0x003f,

    //
    // V1 Partition Management IDs
    //

    HvCallCreatePartition               = 0x0040,
    HvCallInitializePartition           = 0x0041,
    HvCallFinalizePartition             = 0x0042,
    HvCallDeletePartition               = 0x0043,
    HvCallGetPartitionProperty          = 0x0044,
    HvCallSetPartitionProperty          = 0x0045,
    HvCallGetPartitionId                = 0x0046,
    HvCallGetNextChildPartition         = 0x0047,

    //
    // V1 Resource Management IDs
    //

    HvCallDepositMemory                 = 0x0048,
    HvCallWithdrawMemory                = 0x0049,
    HvCallGetMemoryBalance              = 0x004a,

    //
    // V1 Guest Physical Address Space Management IDs
    //

    HvCallMapGpaPages                   = 0x004b,
    HvCallUnmapGpaPages                 = 0x004c,

    //
    // V1 Intercept Management IDs
    //

    HvCallInstallIntercept              = 0x004d,

    //
    // V1 Virtual Processor Management IDs
    //

    HvCallCreateVp                      = 0x004e,
    HvCallDeleteVp                      = 0x004f,
    HvCallGetVpRegisters                = 0x0050,
    HvCallSetVpRegisters                = 0x0051,

    //
    // V1 Virtual TLB IDs
    //

    HvCallTranslateVirtualAddress       = 0x0052,
    HvCallReadGpa                       = 0x0053,
    HvCallWriteGpa                      = 0x0054,

    //
    // V1 Interrupt Management IDs
    //

    HvCallAssertVirtualInterrupt        = 0x0055,
    HvCallClearVirtualInterrupt         = 0x0056,

    //
    // V1 Port IDs
    //

    HvCallCreatePort                    = 0x0057,
    HvCallDeletePort                    = 0x0058,
    HvCallConnectPort                   = 0x0059,
    HvCallGetPortProperty               = 0x005a,
    HvCallDisconnectPort                = 0x005b,
    HvCallPostMessage                   = 0x005c,
    HvCallSignalEvent                   = 0x005d,

    //
    // V1 Partition State IDs
    //

    HvCallSavePartitionState            = 0x005e,
    HvCallRestorePartitionState         = 0x005f,

    //
    // V1 Trace IDs
    //

    HvCallInitializeEventLogBufferGroup  = 0x0060,
    HvCallFinalizeEventLogBufferGroup   = 0x0061,
    HvCallCreateEventLogBuffer          = 0x0062,
    HvCallDeleteEventLogBuffer          = 0x0063,
    HvCallMapEventLogBuffer             = 0x0064,
    HvCallUnmapEventLogBuffer           = 0x0065,
    HvCallSetEventLogGroupSources       = 0x0066,
    HvCallReleaseEventLogBuffer         = 0x0067,
    HvCallFlushEventLogBuffer           = 0x0068,

    //
    // V1 Dbg Call IDs
    //

    HvCallPostDebugData                 = 0x0069,
    HvCallRetrieveDebugData             = 0x006a,
    HvCallResetDebugSession             = 0x006b,

    //
    // V1 Stats IDs
    //

    HvCallMapStatsPage                  = 0x006c,
    HvCallUnmapStatsPage                = 0x006d,

    //
    // V1 Test IDs
    //

    HvCallOutputDebugCharacter,
    HvCallEchoIncrement,
    HvCallPerfNop,
    HvCallPerfNopInput,
    HvCallPerfNopOutput,

    //
    // Total of all V1 hypercalls
    //
    HvCallCount

} HV_CALL_CODE, *PHV_CALL_CODE;

//
// Partition save&restore definitions.
//

//
// Definition of the HvCallDepositMemory hypercall input structure.
// This call deposits memory into a child partition's memory pool.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_DEPOSIT_MEMORY
{
    //
    // Supplies the partition ID of the child partition to deposit the
    // memory into.
    //
    HV_PARTITION_ID PartitionId;

    //
    // Supplies the GPAs of the pages to be deposited.
    //
    HV_GPA_PAGE_NUMBER GpaPageList[];

} HV_INPUT_DEPOSIT_MEMORY, *PHV_INPUT_DEPOSIT_MEMORY;

//
// Definition of the HvCallWithdrawMemory hypercall input and output
// structures.  This call withdraws memory from a child partition's
// memory pool.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_WITHDRAW_MEMORY
{
    //
    // Supplies the partition ID of the child partition from which the
    // memory should be withdrawn.
    //
    HV_PARTITION_ID PartitionId;

    //
    // Supplies the proximity domain from which the memory should be
    // allocated.
    //
    HV_PROXIMITY_DOMAIN_INFO ProximityDomainInfo;

} HV_INPUT_WITHDRAW_MEMORY, *PHV_INPUT_WITHDRAW_MEMORY;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_WITHDRAW_MEMORY
{
    //
    // Returns the GPA of the memory withdrawn.
    //
    HV_GPA_PAGE_NUMBER GpaPageList[];

} HV_OUTPUT_WITHDRAW_MEMORY, *PHV_OUTPUT_WITHDRAW_MEMORY;

//
// Definition of the HvCallGetMemoryBalance hypercall input and output
// structures.  This call determines the hypervisor memory resource
// usage of a child partition's memory pool.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_MEMORY_BALANCE
{
    //
    // Supplies the partition ID of the child partition whose memory
    // pool should be queried.
    //
    HV_PARTITION_ID PartitionId;

    //
    // Supplies the proximity domain to query.
    //
    HV_PROXIMITY_DOMAIN_INFO ProximityDomainInfo;

} HV_INPUT_GET_MEMORY_BALANCE, *PHV_INPUT_GET_MEMORY_BALANCE;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_MEMORY_BALANCE
{
    //
    // Returns the number of pages available.
    //
    UINT64 PagesAvailable;

    //
    // Returns the number of pages actively being used for hypercall
    // datastructures.
    //
    UINT64 PagesInUse;

} HV_OUTPUT_GET_MEMORY_BALANCE, *PHV_OUTPUT_GET_MEMORY_BALANCE;

//
// Definition of the HvCallMapGpaPages hypercall input structure.
// This call maps a range of GPA to a supplied range of SPA.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_MAP_GPA_PAGES
{
    //
    // Supplies the partition ID of the partition that this request is for.
    //

    HV_PARTITION_ID TargetPartitionId;

    //
    // Supplies the base guest physical page number where the mapping
    // will begin.
    //

    HV_GPA_PAGE_NUMBER TargetGpaBase;

    //
    // Supplies the flags to use for the mapping.
    //

    HV_MAP_GPA_FLAGS MapFlags;

    //
    // Supplies an array of guest physical page numbers in the calling
    // partition that the range of GPA will be mapped to.
    //

    HV_GPA_PAGE_NUMBER SourceGpaPageList[];

} HV_INPUT_MAP_GPA_PAGES, *PHV_INPUT_MAP_GPA_PAGES;


//
// Definition of the HvCallUnmapGpaPages hypercall input structure.
// This call unmaps a range of GPA.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_UNMAP_GPA_PAGES
{

    //
    // Supplies the partition ID of the partition that this request is for.
    //

    HV_PARTITION_ID TargetPartitionId;

    //
    // Supplies the base guest physical page number where the GPA
    // space will be removed.
    //

    HV_GPA_PAGE_NUMBER TargetGpaBase;

} HV_INPUT_UNMAP_GPA_PAGES, *PHV_INPUT_UNMAP_GPA_PAGES;

//
// Definition of the HvCallTranslateVirtualAddress hypercall input and
// output structures.  This call translates a GVA to a GPA.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_TRANSLATE_VIRTUAL_ADDRESS
{
    //
    // Supplies the partition ID of the partition in which the
    // translation should take place.
    //

    HV_PARTITION_ID PartitionId;

    //
    // Supplies the virtual processor whose GVA space is to be
    // accessed.
    //

    HV_VP_INDEX VpIndex;

    //
    // Supplies the control flags governing the access.
    //

    HV_TRANSLATE_GVA_CONTROL_FLAGS ControlFlags;

    //
    // Supplies the GVA page number to translate.
    //

    HV_GVA_PAGE_NUMBER GvaPage;

} HV_INPUT_TRANSLATE_VIRTUAL_ADDRESS, *PHV_INPUT_TRANSLATE_VIRTUAL_ADDRESS;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_TRANSLATE_VIRTUAL_ADDRESS
{
    //
    // Flags to indicate the disposition of the translation.
    //

    HV_TRANSLATE_GVA_RESULT TranslationResult;

    //
    // The GPA to which the GVA translated.
    //

    HV_GPA_PAGE_NUMBER GpaPage;

} HV_OUTPUT_TRANSLATE_VIRTUAL_ADDRESS, *PHV_OUTPUT_TRANSLATE_VIRTUAL_ADDRESS;

//
// Definition of the HvCallReadGpa hypercall input and output
// structures.  This call reads from the indicated GPA.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_READ_GPA
{
    //
    // Supplies the partition ID of the partition whose GPA space is
    // to be read.
    //

    HV_PARTITION_ID PartitionId;

    //
    // Supplies the virtual processor whose GPA space is to be read
    // (virtual processor GPA spaces may differ, due to overlays).
    //

    HV_VP_INDEX VpIndex;

    //
    // Supplies the number of bytes to read.
    //

    UINT32 ByteCount;

    //
    // Supplies the start of the GPA range to read.
    //

    HV_GPA BaseGpa;

    //
    // Supplies the control flags governing the read.
    //

    HV_ACCESS_GPA_CONTROL_FLAGS ControlFlags;

} HV_INPUT_READ_GPA, *PHV_INPUT_READ_GPA;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_READ_GPA
{
    //
    // Flags to indicate the disposition of the read.
    //

    HV_ACCESS_GPA_RESULT AccessResult;

    //
    // The data which was read.
    //

    UINT8 Data[16];

} HV_OUTPUT_READ_GPA, *PHV_OUTPUT_READ_GPA;

//
// Definition of the HvCallWriteGpa hypercall input and output
// structures.  This call writes from the indicated GPA.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_WRITE_GPA
{
    //
    // Supplies the partition ID of the partition whose GPA space is
    // to be written.
    //

    HV_PARTITION_ID PartitionId;

    //
    // Supplies the virtual processor whose GPA space is to be written
    // (virtual processor GPA spaces may differ, due to overlays).
    //

    HV_VP_INDEX VpIndex;

    //
    // Supplies the number of bytes to write.
    //

    UINT32 ByteCount;

    //
    // Supplies the start of the GPA range to write.
    //

    HV_GPA BaseGpa;

    //
    // Supplies the control flags governing the write.
    //

    HV_ACCESS_GPA_CONTROL_FLAGS ControlFlags;

    //
    // Supplies the data to write.
    //

    UINT8 Data[16];

} HV_INPUT_WRITE_GPA, *PHV_INPUT_WRITE_GPA;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_WRITE_GPA
{
    //
    // Flags to indicate the disposition of the write.
    //

    HV_ACCESS_GPA_RESULT AccessResult;

} HV_OUTPUT_WRITE_GPA, *PHV_OUTPUT_WRITE_GPA;

//
// Definition of the HvCallInstallIntercept hypercall input
// structure.  This call sets an intercept.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_INSTALL_INTERCEPT
{
    HV_PARTITION_ID PartitionId;
    HV_INTERCEPT_ACCESS_TYPE_MASK AccessType;
    HV_INTERCEPT_TYPE InterceptType;
    HV_INTERCEPT_PARAMETERS InterceptParameter;
} HV_INPUT_INSTALL_INTERCEPT, *PHV_INPUT_INSTALL_INTERCEPT;


//
// Definition of the HvCallCreateVp hypercall input structure.
// This call creates a virtual processor.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_CREATE_VP
{
    HV_PARTITION_ID          PartitionId;
    HV_VP_INDEX              VpIndex;
    UINT32                   Padding;
    HV_PROXIMITY_DOMAIN_INFO ProximityDomainInfo;
    UINT64                   Flags;
} HV_INPUT_CREATE_VP, *PHV_INPUT_CREATE_VP;

//
// Definition of the HvCallDeleteVp hypercall input structure.
// This call deletes a virtual processor.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_DELETE_VP
{
    HV_PARTITION_ID PartitionId;
    HV_VP_INDEX     VpIndex;
} HV_INPUT_DELETE_VP, *PHV_INPUT_DELETE_VP;

//
// External names used to manupulate registers
//

typedef enum _HV_REGISTER_NAME
{
    // Suspend Registers
    HvRegisterExplicitSuspend   = 0x00000000,
    HvRegisterInterceptSuspend  = 0x00000001,

    // Pending Interruption Register
    HvX64RegisterPendingInterruption    = 0x00010002,

    // Interrupt State register
    HvX64RegisterInterruptState         = 0x00010003,

    // User-Mode Registers
    HvX64RegisterRax                = 0x00020000,
    HvX64RegisterRcx                = 0x00020001,
    HvX64RegisterRdx                = 0x00020002,
    HvX64RegisterRbx                = 0x00020003,
    HvX64RegisterRsp                = 0x00020004,
    HvX64RegisterRbp                = 0x00020005,
    HvX64RegisterRsi                = 0x00020006,
    HvX64RegisterRdi                = 0x00020007,
    HvX64RegisterR8                 = 0x00020008,
    HvX64RegisterR9                 = 0x00020009,
    HvX64RegisterR10                = 0x0002000A,
    HvX64RegisterR11                = 0x0002000B,
    HvX64RegisterR12                = 0x0002000C,
    HvX64RegisterR13                = 0x0002000D,
    HvX64RegisterR14                = 0x0002000E,
    HvX64RegisterR15                = 0x0002000F,
    HvX64RegisterRip                = 0x00020010,
    HvX64RegisterRflags             = 0x00020011,

    // Floating Point and Vector Registers
    HvX64RegisterXmm0               = 0x00030000,
    HvX64RegisterXmm1               = 0x00030001,
    HvX64RegisterXmm2               = 0x00030002,
    HvX64RegisterXmm3               = 0x00030003,
    HvX64RegisterXmm4               = 0x00030004,
    HvX64RegisterXmm5               = 0x00030005,
    HvX64RegisterXmm6               = 0x00030006,
    HvX64RegisterXmm7               = 0x00030007,
    HvX64RegisterXmm8               = 0x00030008,
    HvX64RegisterXmm9               = 0x00030009,
    HvX64RegisterXmm10              = 0x0003000A,
    HvX64RegisterXmm11              = 0x0003000B,
    HvX64RegisterXmm12              = 0x0003000C,
    HvX64RegisterXmm13              = 0x0003000D,
    HvX64RegisterXmm14              = 0x0003000E,
    HvX64RegisterXmm15              = 0x0003000F,
    HvX64RegisterFpMmx0             = 0x00030010,
    HvX64RegisterFpMmx1             = 0x00030011,
    HvX64RegisterFpMmx2             = 0x00030012,
    HvX64RegisterFpMmx3             = 0x00030013,
    HvX64RegisterFpMmx4             = 0x00030014,
    HvX64RegisterFpMmx5             = 0x00030015,
    HvX64RegisterFpMmx6             = 0x00030016,
    HvX64RegisterFpMmx7             = 0x00030017,
    HvX64RegisterFpControlStatus    = 0x00030018,
    HvX64RegisterXmmControlStatus   = 0x00030019,

    // Control Registers
    HvX64RegisterCr0                = 0x00040000,
    HvX64RegisterCr2                = 0x00040001,
    HvX64RegisterCr3                = 0x00040002,
    HvX64RegisterCr4                = 0x00040003,
    HvX64RegisterCr8                = 0x00040004,

    // Debug Registers
    HvX64RegisterDr0                = 0x00050000,
    HvX64RegisterDr1                = 0x00050001,
    HvX64RegisterDr2                = 0x00050002,
    HvX64RegisterDr3                = 0x00050003,
    HvX64RegisterDr6                = 0x00050004,
    HvX64RegisterDr7                = 0x00050005,

    // Segment Registers
    HvX64RegisterEs                 = 0x00060000,
    HvX64RegisterCs                 = 0x00060001,
    HvX64RegisterSs                 = 0x00060002,
    HvX64RegisterDs                 = 0x00060003,
    HvX64RegisterFs                 = 0x00060004,
    HvX64RegisterGs                 = 0x00060005,
    HvX64RegisterLdtr               = 0x00060006,
    HvX64RegisterTr                 = 0x00060007,

    // Table Registers
    HvX64RegisterIdtr               = 0x00070000,
    HvX64RegisterGdtr               = 0x00070001,

    // Virtualized MSRs
    HvX64RegisterTsc                = 0x00080000,
    HvX64RegisterEfer               = 0x00080001,
    HvX64RegisterKernelGsBase       = 0x00080002,
    HvX64RegisterApicBase           = 0x00080003,
    HvX64RegisterPat                = 0x00080004,
    HvX64RegisterSysenterCs         = 0x00080005,
    HvX64RegisterSysenterEip        = 0x00080006,
    HvX64RegisterSysenterEsp        = 0x00080007,
    HvX64RegisterStar               = 0x00080008,
    HvX64RegisterLstar              = 0x00080009,
    HvX64RegisterCstar              = 0x0008000A,
    HvX64RegisterSfmask             = 0x0008000B,
    HvX64RegisterInitialApicId      = 0x0008000C,

    //
    // Cache control MSRs
    //
    HvX64RegisterMsrMtrrCap         = 0x0008000D,
    HvX64RegisterMsrMtrrDefType     = 0x0008000E,
    HvX64RegisterMsrMtrrPhysBase0   = 0x00080010,
    HvX64RegisterMsrMtrrPhysBase1   = 0x00080011,
    HvX64RegisterMsrMtrrPhysBase2   = 0x00080012,
    HvX64RegisterMsrMtrrPhysBase3   = 0x00080013,
    HvX64RegisterMsrMtrrPhysBase4   = 0x00080014,
    HvX64RegisterMsrMtrrPhysBase5   = 0x00080015,
    HvX64RegisterMsrMtrrPhysBase6   = 0x00080016,
    HvX64RegisterMsrMtrrPhysBase7   = 0x00080017,
    HvX64RegisterMsrMtrrPhysMask0   = 0x00080040,
    HvX64RegisterMsrMtrrPhysMask1   = 0x00080041,
    HvX64RegisterMsrMtrrPhysMask2   = 0x00080042,
    HvX64RegisterMsrMtrrPhysMask3   = 0x00080043,
    HvX64RegisterMsrMtrrPhysMask4   = 0x00080044,
    HvX64RegisterMsrMtrrPhysMask5   = 0x00080045,
    HvX64RegisterMsrMtrrPhysMask6   = 0x00080046,
    HvX64RegisterMsrMtrrPhysMask7   = 0x00080047,
    HvX64RegisterMsrMtrrFix64k00000 = 0x00080070,
    HvX64RegisterMsrMtrrFix16k80000 = 0x00080071,
    HvX64RegisterMsrMtrrFix16kA0000 = 0x00080072,
    HvX64RegisterMsrMtrrFix4kC0000  = 0x00080073,
    HvX64RegisterMsrMtrrFix4kC8000  = 0x00080074,
    HvX64RegisterMsrMtrrFix4kD0000  = 0x00080075,
    HvX64RegisterMsrMtrrFix4kD8000  = 0x00080076,
    HvX64RegisterMsrMtrrFix4kE0000  = 0x00080077,
    HvX64RegisterMsrMtrrFix4kE8000  = 0x00080078,
    HvX64RegisterMsrMtrrFix4kF0000  = 0x00080079,
    HvX64RegisterMsrMtrrFix4kF8000  = 0x0008007A,

    // Hypervisor-defined MSRs (Misc)
    HvX64RegisterVpRuntime          = 0x00090000,
    HvX64RegisterHypercall          = 0x00090001,
    HvX64RegisterGuestOsId          = 0x00090002,
    HvX64RegisterVpIndex            = 0x00090003,

    // Hypervisor-defined MSRs (Synic)
    HvX64RegisterSint0              = 0x000A0000,
    HvX64RegisterSint1              = 0x000A0001,
    HvX64RegisterSint2              = 0x000A0002,
    HvX64RegisterSint3              = 0x000A0003,
    HvX64RegisterSint4              = 0x000A0004,
    HvX64RegisterSint5              = 0x000A0005,
    HvX64RegisterSint6              = 0x000A0006,
    HvX64RegisterSint7              = 0x000A0007,
    HvX64RegisterSint8              = 0x000A0008,
    HvX64RegisterSint9              = 0x000A0009,
    HvX64RegisterSint10             = 0x000A000A,
    HvX64RegisterSint11             = 0x000A000B,
    HvX64RegisterSint12             = 0x000A000C,
    HvX64RegisterSint13             = 0x000A000D,
    HvX64RegisterSint14             = 0x000A000E,
    HvX64RegisterSint15             = 0x000A000F,
    HvX64RegisterScontrol           = 0x000A0010,
    HvX64RegisterSversion           = 0x000A0011,
    HvX64RegisterSifp               = 0x000A0012,
    HvX64RegisterSipp               = 0x000A0013,
    HvX64RegisterEom                = 0x000A0014,

    // Hypervisor-defined MSRs (Synthetic Timers)
    HvX64RegisterStimer0Config      = 0x000B0000,
    HvX64RegisterStimer0Count       = 0x000B0001,
    HvX64RegisterStimer1Config      = 0x000B0002,
    HvX64RegisterStimer1Count       = 0x000B0003,
    HvX64RegisterStimer2Config      = 0x000B0004,
    HvX64RegisterStimer2Count       = 0x000B0005,
    HvX64RegisterStimer3Config      = 0x000B0006,
    HvX64RegisterStimer3Count       = 0x000B0007

} HV_REGISTER_NAME, *PHV_REGISTER_NAME;
typedef const HV_REGISTER_NAME *PCHV_REGISTER_NAME;

//
// Definiton of the HvCallGetVpRegister hypercall input structure.
// This call retrieves a Vp's register state.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_VP_REGISTERS
{
    HV_PARTITION_ID     PartitionId;
    HV_VP_INDEX         VpIndex;
    HV_REGISTER_NAME    Names[];
} HV_INPUT_GET_VP_REGISTERS, *PHV_INPUT_GET_VP_REGISTERS;

typedef struct _HV_REGISTER_ASSOC
{
    HV_REGISTER_NAME    Name;
    UINT32              Pad;
    HV_REGISTER_VALUE   Value;
} HV_REGISTER_ASSOC, *PHV_REGISTER_ASSOC;

typedef struct HV_CALL_ATTRIBUTES_ALIGNED(16) _HV_INPUT_SET_VP_REGISTERS
{
    HV_PARTITION_ID      PartitionId;
    HV_VP_INDEX          VpIndex;
    UINT32               RsvdZ;
    HV_REGISTER_ASSOC    Elements[];
} HV_INPUT_SET_VP_REGISTERS, *PHV_INPUT_SET_VP_REGISTERS;

//
// Definition of the HvCallGetVpRegisterCode hypercall input
// structure.  This call retrieves the valid Vp register codes.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_VP_REGISTER_CODE
{
    HV_PARTITION_ID PartitionId;
    UINT32          RegisterIndex;
} HV_INPUT_GET_VP_REGISTER_CODE, *PHV_INPUT_GET_VP_REGISTER_CODE;


//
// Definition of the HvCallSwitchVirtualAddressSpace hypercall input
// structure.  This call switches the guest's virtual address space.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_SWITCH_VIRTUAL_ADDRESS_SPACE
{
    HV_ADDRESS_SPACE_ID AddressSpace;
} HV_INPUT_SWITCH_VIRTUAL_ADDRESS_SPACE,
  *PHV_INPUT_SWITCH_VIRTUAL_ADDRESS_SPACE;


//
// Common header used by both list and space flush routines.
//

typedef struct _HV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE_HEADER
{
    HV_ADDRESS_SPACE_ID AddressSpace;
    HV_FLUSH_FLAGS      Flags;
    UINT64              ProcessorMask;
} HV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE_HEADER,
  *PHV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE_HEADER;

//
// Definition of the HvCallFlushVirtualAddressSpace hypercall input
// structure.  This call flushes the virtual TLB entries which belong
// to the indicated address space, on one or more processors.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE
{
    HV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE_HEADER Header;
} HV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE, *PHV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE;

//
// Definition of the HvCallFlushVirtualAddressList hypercall input
// structure.  This call invalidates portions of the virtual TLB which
// belong to the indicates address space, on one more more processors.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_FLUSH_VIRTUAL_ADDRESS_LIST
{
    HV_INPUT_FLUSH_VIRTUAL_ADDRESS_SPACE_HEADER Header;
    HV_GVA GvaList[];
} HV_INPUT_FLUSH_VIRTUAL_ADDRESS_LIST, *PHV_INPUT_FLUSH_VIRTUAL_ADDRESS_LIST;

//
// Definition of the HvAssertVirtualInterrupt hypercall input
// structure.  This call asserts an interrupt in a guest partition.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_ASSERT_VIRTUAL_INTERRUPT
{
    HV_PARTITION_ID         TargetPartition;
    HV_INTERRUPT_CONTROL    InterruptControl;
    UINT64                  DestinationAddress;
    HV_INTERRUPT_VECTOR     RequestedVector;
    UINT32                  Reserved;
} HV_INPUT_ASSERT_VIRTUAL_INTERRUPT, *PHV_INPUT_ASSERT_VIRTUAL_INTERRUPT;

//
// Definition of the HvClearVirtualInterrupt hypercall input
// structure. This call clears the acknowledged status of a previously
// acknowledged vector.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_CLEAR_VIRTUAL_INTERRUPT
{
    HV_PARTITION_ID         TargetPartition;
} HV_INPUT_CLEAR_VIRTUAL_INTERRUPT, *PHV_INPUT_CLEAR_VIRTUAL_INTERRUPT;

//
// Definition of the HvCreatePort hypercall input structure.  This
// call allocates a port object.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_CREATE_PORT
{
    HV_PARTITION_ID     PortPartition;
    HV_PORT_ID          PortId;
    UINT32              Padding;
    HV_PARTITION_ID     ConnectionPartition;
    HV_PORT_INFO        PortInfo;
} HV_INPUT_CREATE_PORT, *PHV_INPUT_CREATE_PORT;

//
// Definition of the HvDeletePort hypercall input structure.  This
// call deletes a port object.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_DELETE_PORT
{
    HV_PARTITION_ID PortPartition;
    HV_PORT_ID      PortId;
    UINT32          Reserved;
} HV_INPUT_DELETE_PORT, *PHV_INPUT_DELETE_PORT;

//
// Definition of the HvConnectPort hypercall input structure.  This
// call creates a connection to a previously-created port in another
// partition.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_CONNECT_PORT
{
    HV_PARTITION_ID     ConnectionPartition;
    HV_CONNECTION_ID    ConnectionId;
    UINT32              Reserved1;
    HV_PARTITION_ID     PortPartition;
    HV_PORT_ID          PortId;
    UINT32              Reserved2;
    HV_CONNECTION_INFO  ConnectionInfo;
} HV_INPUT_CONNECT_PORT, *PHV_INPUT_CONNECT_PORT;

//
// Definition of the HvGetPortProperty hypercall input and output
// structures.  This call retrieves a property of a previously-created
// port in the current or another partition.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_PORT_PROPERTY
{
    HV_PARTITION_ID       PortPartition;
    HV_PORT_ID            PortId;
    UINT32                Reserved;
    HV_PORT_PROPERTY_CODE PropertyCode;
} HV_INPUT_GET_PORT_PROPERTY, *PHV_INPUT_GET_PORT_PROPERTY;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_PORT_PROPERTY
{
    HV_PORT_PROPERTY PropertyValue;
} HV_OUTPUT_GET_PORT_PROPERTY, *PHV_OUTPUT_GET_PORT_PROPERTY;

//
// Definition of the HvDisconnectPort hypercall input structure.  This
// call disconnects an existing connection.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_DISCONNECT_PORT
{
    HV_PARTITION_ID     ConnectionPartition;
    HV_CONNECTION_ID    ConnectionId;
    UINT32              Reserved;
} HV_INPUT_DISCONNECT_PORT, *PHV_INPUT_DISCONNECT_PORT;

//
// Definition of the HvPostMessage hypercall input structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_POST_MESSAGE
{
    HV_CONNECTION_ID    ConnectionId;
    UINT32              Reserved;
    HV_MESSAGE_TYPE     MessageType;
    UINT32              PayloadSize;
    UINT64              Payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];
} HV_INPUT_POST_MESSAGE, *PHV_INPUT_POST_MESSAGE;


//
// Definition of the HvSignalEvent hypercall input structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_SIGNAL_EVENT
{
    HV_CONNECTION_ID ConnectionId;
    UINT16           FlagNumber;
    UINT16           RsvdZ;
} HV_INPUT_SIGNAL_EVENT, *PHV_INPUT_SIGNAL_EVENT;


//
// Define the scheduler run time hypercall input/output structures.
//

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_LOGICAL_PROCESSOR_RUN_TIME
{
    HV_NANO100_TIME GlobalTime;
    HV_NANO100_TIME LocalRunTime;
    HV_NANO100_TIME GroupRunTime;
    HV_NANO100_TIME HypervisorTime;
} HV_OUTPUT_GET_LOGICAL_PROCESSOR_RUN_TIME,
  *PHV_OUTPUT_GET_LOGICAL_PROCESSOR_RUN_TIME;


typedef struct HV_CALL_ATTRIBUTES
_HV_INPUT_SET_LOGICAL_PROCESSOR_RUN_TIME_GROUP
{
    UINT64 Flags;      // Reserved Zeroes.
    UINT64 ProcessorMask;
} HV_INPUT_SET_LOGICAL_PROCESSOR_RUN_TIME_GROUP,
  *PHV_INPUT_SET_LOGICAL_PROCESSOR_RUN_TIME_GROUP;


typedef struct HV_CALL_ATTRIBUTES
_HV_INPUT_CLEAR_LOGICAL_PROCESSOR_RUN_TIME_GROUP
{
    HV_VP_INDEX VpIndex;
} HV_INPUT_CLEAR_LOGICAL_PROCESSOR_RUN_TIME_GROUP,
  *PHV_INPUT_CLEAR_LOGICAL_PROCESSOR_RUN_TIME_GROUP;

//
// Definition of the HvGetNextLogicalProcessor hypercall input and
// output structures.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_NEXT_LOGICAL_PROCESSOR
{
    HV_LOGICAL_PROCESSOR_INDEX SearchStartIndex;
} HV_INPUT_GET_NEXT_LOGICAL_PROCESSOR, *PHV_INPUT_GET_NEXT_LOGICAL_PROCESSOR;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_NEXT_LOGICAL_PROCESSOR
{
    HV_LOGICAL_PROCESSOR_INDEX LogicalProcessorIndex;
    HV_PHYSICAL_NODE_INDEX PhysicalNode;
} HV_OUTPUT_GET_NEXT_LOGICAL_PROCESSOR, *PHV_OUTPUT_GET_NEXT_LOGICAL_PROCESSOR;

//
// Definition of the HvGetNextRamPageRange hypercall input and output
// structures.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_GET_NEXT_RAM_PAGE_RANGE
{
    HV_SPA_PAGE_NUMBER SearchStart;
} HV_INPUT_GET_NEXT_RAM_PAGE_RANGE, *PHV_INPUT_GET_NEXT_RAM_PAGE_RANGE;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_GET_NEXT_RAM_PAGE_RANGE
{
    HV_SPA_PAGE_NUMBER RangeStart;
    UINT64 PageCount;
    HV_PHYSICAL_NODE_INDEX PhysicalNode;
} HV_OUTPUT_GET_NEXT_RAM_PAGE_RANGE, *PHV_OUTPUT_GET_NEXT_RAM_PAGE_RANGE;

//
// Definition of the HvSavePartitionState hypercall input and output
// structures.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_SAVE_PARTITION_STATE
{
    HV_PARTITION_ID PartitionId;
    HV_SAVE_RESTORE_STATE_FLAGS Flags;
} HV_INPUT_SAVE_PARTITION_STATE, *PHV_INPUT_SAVE_PARTITION_STATE;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_SAVE_PARTITION_STATE
{
    UINT32 SaveDataCount;
    HV_SAVE_RESTORE_STATE_RESULT SaveState;
    UINT8 SaveData[4080];
} HV_OUTPUT_SAVE_PARTITION_STATE, *PHV_OUTPUT_SAVE_PARTITION_STATE;

//
// Definition of the HvRestorePartitionState hypercall input and
// output structures.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_RESTORE_PARTITION_STATE
{
    HV_PARTITION_ID PartitionId;
    HV_SAVE_RESTORE_STATE_FLAGS Flags;
    UINT32 RestoreDataCount;
    UINT8 RestoreData[4080];
} HV_INPUT_RESTORE_PARTITION_STATE, *PHV_INPUT_RESTORE_PARTITION_STATE;

typedef struct HV_CALL_ATTRIBUTES _HV_OUTPUT_RESTORE_PARTITION_STATE
{
    HV_SAVE_RESTORE_STATE_RESULT RestoreState;
    UINT32 RestoreDataConsumed;
} HV_OUTPUT_RESTORE_PARTITION_STATE, *PHV_OUTPUT_RESTORE_PARTITION_STATE;

//
// Definition of the HvSpecifyPreferredAffinity hypercall input
// structure.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_SPECIFY_PREFERRED_AFFINITY
{
    HV_PARTITION_ID PartitionId;
    HV_VP_INDEX VpIndex;
    HV_LOGICAL_PROCESSOR_INDEX PreferredAffinity;
} HV_INPUT_SPECIFY_PREFERRED_AFFINITY, *PHV_INPUT_SPECIFY_PREFERRED_AFFINITY;

//
// Definitions for the stats hypercall structures.
//

typedef union _HV_STATS_OBJECT_IDENTITY
{
    //
    // HvStatsObjectHypervisor
    //

    struct
    {
        UINT64  ReservedZ1[2];
    } Hypervisor;

    //
    // HvStatsObjectLogicalProcessor
    //

    struct
    {
        HV_LOGICAL_PROCESSOR_INDEX      LogicalProcessorIndex;
        UINT32                          ReservedZ2;
        UINT64                          ReservedZ3;
    } LogicalProcessor;

    //
    // HvStatsObjectPartition
    //

    struct
    {
        HV_PARTITION_ID PartitionId;
        UINT64          ReservedZ4;
    } Partition;

    //
    // HvStatsObjectVp
    //

    struct
    {
        HV_PARTITION_ID PartitionId;
        HV_VP_INDEX     VpIndex;
        UINT32          ReservedZ5;
    } Vp;

} HV_STATS_OBJECT_IDENTITY;

typedef const HV_STATS_OBJECT_IDENTITY *PCHV_STATS_OBJECT_IDENTITY;

//
// Definition of the HvMapStatsPage hypercall input structure.  This
// call allows a partition to map the page with statistics into
// the caller's GPA space.for child partition or for itself.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_MAP_STATS_PAGE
{
    HV_STATS_OBJECT_TYPE       StatsType;
    HV_STATS_OBJECT_IDENTITY   ObjectIdentity;
    HV_GPA_PAGE_NUMBER         MapLocation;
} HV_INPUT_MAP_STATS_PAGE, *PHV_INPUT_MAP_STATS_PAGE;


//
// Definition of the HvUnmapStatsPage hypercall input structure.  This
// call allows a partition to unmap the page with statistics from
// the caller's GPA space.
//

typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_UNMAP_STATS_PAGE
{
    HV_STATS_OBJECT_TYPE       StatsType;
    HV_STATS_OBJECT_IDENTITY   ObjectIdentity;
    HV_GPA_PAGE_NUMBER         MapLocation;
} HV_INPUT_UNMAP_STATS_PAGE, *PHV_INPUT_UNMAP_STATS_PAGE;

//
// Definition of the HcpHvNotifySpinlockAcquireFailure hypercall input
// structure.  This call switches notifies the hypervisor of a long running
// spinlock acquisition failure.
//
typedef struct HV_CALL_ATTRIBUTES _HV_INPUT_NOTIFY_LONG_SPINWAIT
{
    UINT64 InitialLongSpinWait;
} HV_INPUT_NOTIFY_LONG_SPINWAIT,
  *PHV_INPUT_NOTIFY_LONG_SPINWAIT;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#pragma warning(default:4201)
#pragma warning(default:4214)
#pragma warning(default:4324)
#endif

#endif //_HVGDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ioaccess.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/

//
// Note: IA64 is for 64 bits Merced. Under Merced compiler option, we don't have
// _X86_, instead, we use _IA64_. Same thing, _AXP64_ is for 64 bits compiler
// option for ALPHA
//
#if defined(_MIPS_) || defined(_X86_) || defined(_AMD64_)

//
// Memory barriers on X86 and MIPS are not required since the Io
// Operations are always garanteed to be executed in order
//

#define MEMORY_BARRIER()    0


#elif defined(_IA64_)

//
// Itanium requires memory barriers
//

void __mf();

#define MEMORY_BARRIER()    __mf()

#elif defined(_PPC_)

//
// A memory barrier function is provided by the PowerPC Enforce
// In-order Execution of I/O instruction (eieio).
//

#if defined(_M_PPC) && defined(_MSC_VER) && (_MSC_VER>=1000)
void __emit( unsigned const __int32 );
#define __builtin_eieio() __emit( 0x7C0006AC )
#else
void __builtin_eieio(void);
#endif

#define MEMORY_BARRIER()        __builtin_eieio()


#elif defined(_ALPHA_) || (_AXP64_)

//
// ALPHA requires memory barriers
//

#define MEMORY_BARRIER()  __MB()



#endif

#ifndef NO_PORT_MACROS



//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate MEMORY registers.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O ports.
//  (Use x86 in/out instructions.)
//


//
// inp(),inpw(), inpd(), outp(), outpw(), outpd() are X86 specific intrinsic
// inline functions. So for IA64, we have to put READ_PORT_USHORT() etc. back
// to it's supposed to be, defined in sdk\inc\wdm.h
//
#if defined(_IA64_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_X86_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  (UCHAR)(inp (Port))
#define READ_PORT_USHORT(Port)                 (USHORT)(inpw (Port))
#define READ_PORT_ULONG(Port)                  (ULONG)(inpd (Port))
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#elif defined(_PPC_) || defined(_MIPS_)

#define READ_REGISTER_UCHAR(x)      (*(volatile UCHAR * const)(x))
#define READ_REGISTER_USHORT(x)     (*(volatile USHORT * const)(x))
#define READ_REGISTER_ULONG(x)      (*(volatile ULONG * const)(x))
#define WRITE_REGISTER_UCHAR(x, y)  (*(volatile UCHAR * const)(x) = (y))
#define WRITE_REGISTER_USHORT(x, y) (*(volatile USHORT * const)(x) = (y))
#define WRITE_REGISTER_ULONG(x, y)  (*(volatile ULONG * const)(x) = (y))
#define READ_PORT_UCHAR(x)          READ_REGISTER_UCHAR(x)
#define READ_PORT_USHORT(x)         READ_REGISTER_USHORT(x)
#define READ_PORT_ULONG(x)          READ_REGISTER_ULONG(x)

//
// All these macros take a ULONG as a parameter so that we don't
// force an extra typecast in the code (which will cause the X86 to
// generate bad code).
//

#define WRITE_PORT_UCHAR(x, y)      WRITE_REGISTER_UCHAR(x, (UCHAR) (y))
#define WRITE_PORT_USHORT(x, y)     WRITE_REGISTER_USHORT(x, (USHORT) (y))
#define WRITE_PORT_ULONG(x, y)      WRITE_REGISTER_ULONG(x, (ULONG) (y))


#elif defined(_ALPHA_) || (_AXP64_)

//
// READ/WRITE_PORT/REGISTER_UCHAR_USHORT_ULONG are all functions that
// go to the HAL on ALPHA
//
// So we only put the prototypes here
//

__declspec(dllimport)
UCHAR
READ_REGISTER_UCHAR(
    PVOID Register
    );

__declspec(dllimport)
USHORT
READ_REGISTER_USHORT(
    PVOID Register
    );

__declspec(dllimport)
ULONG
READ_REGISTER_ULONG(
    PVOID Register
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_UCHAR(
    PVOID Register,
    UCHAR Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_USHORT(
    PVOID  Register,
    USHORT Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_ULONG(
    PVOID Register,
    ULONG Value
    );

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_AMD64_)

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)

LONG
_InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic(_InterlockedOr)


__inline
UCHAR
READ_REGISTER_UCHAR (
    PVOID Register
    )
{
    return *(UCHAR volatile *)Register;
}

__inline
USHORT
READ_REGISTER_USHORT (
    PVOID Register
    )
{
    return *(USHORT volatile *)Register;
}

__inline
ULONG
READ_REGISTER_ULONG (
    PVOID Register
    )
{
    return *(ULONG volatile *)Register;
}

__inline
VOID
WRITE_REGISTER_UCHAR (
    PVOID Register,
    UCHAR Value
    )
{
    LONG Synch;

    *(UCHAR volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
VOID
WRITE_REGISTER_USHORT (
    PVOID Register,
    USHORT Value
    )
{
    LONG Synch;

    *(USHORT volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
VOID
WRITE_REGISTER_ULONG (
    PVOID Register,
    ULONG Value
    )
{
    LONG Synch;

    *(ULONG volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
UCHAR
READ_PORT_UCHAR (
    PVOID Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__inline
USHORT
READ_PORT_USHORT (
    PVOID Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__inline
ULONG
READ_PORT_ULONG (
    PVOID Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}

__inline
VOID
WRITE_PORT_UCHAR (
    PVOID Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__inline
VOID
WRITE_PORT_USHORT (
    PVOID Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__inline
VOID
WRITE_PORT_ULONG (
    PVOID Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

#endif      // NO_PORT_MACROS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\i2cgpio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//==========================================================================;

#if 0
To access the IO functionality in a WDM driver or the VDD, WDM driver sends 
the following IRP to its parent.

MajorFunction = IRP_MJ_PNP;
MinorFunction = IRP_MN_QUERY_INTERFACE;

Guid = DEFINE_GUID( GUID_GPIO_INTERFACE, 
        0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

The QUERY_INTERFACE Irp will return an interface (set of function pointers)
of the type xxxxINTERFACE, defined below. This is essentially a table of
function pointers.

#endif

#ifndef __I2CGPIO_H__
#define __I2CGPIO_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Guids
//
// DEFINE_GUID requires that you include wdm.h before this file.
// #define INITGUID to actually initialize the guid in memory.
//
DEFINE_GUID( GUID_I2C_INTERFACE, 0x02295e86L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_GPIO_INTERFACE,0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_COPYPROTECTION_INTERFACE, 0x02295e88L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

//==========================================================================;
// used below if neccessary
#ifndef BYTE
#define BYTE UCHAR
#endif
#ifndef DWORD
#define DWORD ULONG
#endif
//==========================================================================;
//
// I2C section
//
// I2C Commands
#define I2C_COMMAND_NULL         0X0000
#define I2C_COMMAND_READ         0X0001
#define I2C_COMMAND_WRITE        0X0002
#define I2C_COMMAND_STATUS       0X0004
#define I2C_COMMAND_RESET        0X0008

// The following flags are provided on a READ or WRITE command
#define I2C_FLAGS_START          0X0001 // START + addx
#define I2C_FLAGS_STOP           0X0002 // STOP
#define I2C_FLAGS_DATACHAINING   0X0004 // STOP, START + addx 
#define I2C_FLAGS_ACK            0X0010 // ACKNOWLEDGE (normally set)

// The following status flags are returned on completion of the operation
#define I2C_STATUS_NOERROR       0X0000  
#define I2C_STATUS_BUSY          0X0001
#define I2C_STATUS_ERROR         0X0002

typedef struct _I2CControl {
        ULONG Command;          // I2C_COMMAND_*
        DWORD dwCookie;         // Context identifier returned on Open
        BYTE  Data;             // Data to write, or returned byte
        BYTE  Reserved[3];      // Filler
        ULONG Flags;            // I2C_FLAGS_*
        ULONG Status;           // I2C_STATUS_*
        ULONG ClockRate;        // Bus clockrate in Hz.
} I2CControl, *PI2CControl;

// this is the Interface definition for I2C
//
typedef NTSTATUS (STDMETHODCALLTYPE *I2COPEN)(PDEVICE_OBJECT, ULONG, PI2CControl);
typedef NTSTATUS (STDMETHODCALLTYPE *I2CACCESS)(PDEVICE_OBJECT, PI2CControl);

typedef struct {
    INTERFACE _vddInterface;
    I2COPEN   i2cOpen;
    I2CACCESS i2cAccess;
} I2CINTERFACE;

//==========================================================================;
//
// GPIO section
//
// GPIO Commands

#define GPIO_COMMAND_QUERY          0X0001      // get #pins and nBufferSize
#define GPIO_COMMAND_OPEN           0X0001      // old open
#define GPIO_COMMAND_OPEN_PINS      0X0002      // get dwCookie
#define GPIO_COMMAND_CLOSE_PINS     0X0004      // invalidate cookie
#define GPIO_COMMAND_READ_BUFFER    0X0008
#define GPIO_COMMAND_WRITE_BUFFER   0X0010

// The following flags are provided on a READ_BUFFER or WRITE_BUFFER command
// lpPins bits set MUST have contiguous bits set for a read/write command.
//
// On a READ, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, then zeros are returned for those positions. 
// on a WRITE, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, a read/modify/write is done on the port/mmio position
// that represents those bits.

#define GPIO_FLAGS_BYTE             0x0001  // do byte read/write
#define GPIO_FLAGS_WORD             0x0002  // do word read/write
#define GPIO_FLAGS_DWORD            0x0004  // do dword read/write

// The following status flags are returned on completion of the operation
#define GPIO_STATUS_NOERROR     0X0000  
#define GPIO_STATUS_BUSY        0X0001
#define GPIO_STATUS_ERROR       0X0002
#define GPIO_STATUS_NO_ASYNCH   0X0004  // gpio provider does not do asynch xfer

typedef struct _GPIOControl {
    ULONG Command;          // GPIO_COMMAND_*
    ULONG Flags;            // GPIO_FLAGS_*
    DWORD dwCookie;         // Context identifier returned on Open
    ULONG Status;           // GPIO_STATUS_*
    ULONG nBytes;           // # of bytes to send or recieved
    ULONG nBufferSize;      // max size of buffer
    ULONG nPins;            // number of GPIO pins returned by Open
    UCHAR *Pins;            // pointer to bitmask of pins to read/write
    UCHAR *Buffer;          // pointer to GPIO data to send/recieve
    void  (*AsynchCompleteCallback)(UCHAR *Buffer);
                            // NULL if synchronous xfer, valid ptr if asynch.
    GUID  PrivateInterfaceType;
    void  (*PrivateInterface)();
    
} GPIOControl, *PGPIOControl;

// This is the GPIO interface
//
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOOPEN)(PDEVICE_OBJECT, ULONG, PGPIOControl);
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOACCESS)(PDEVICE_OBJECT, PGPIOControl);

typedef struct {
    INTERFACE _vddInterface;
    GPIOOPEN   gpioOpen;
    GPIOACCESS gpioAccess;
} GPIOINTERFACE;

//==========================================================================;
#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__I2CGPIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iointex.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iointex.h

Abstract:

    This header exposes the new kernel APIs to connect and disconnect
    interrupts in a manner that makes it possible for drivers referencing
    these new APIs to run on downlevel systems.

--*/

#ifndef _IOINTEX_IOINTEX_H_
#define _IOINTEX_IOINTEX_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// Provide definitions for the types and structures which were introduced with
// the new interrupt connection APIs if they haven't already been defined by
// standard headers.  If this header is included in a driver being built for
// a downlevel OS, then it will include the version of ntddk.h or wdm.h that
// was current when that OS shipped.  As a result, we need to manually provide
// the required types in this case.
//
// See DDK documentation and the definition of these structures in the most
// recent standard headers for more information on the meaning of the
// individual types and fields.
//

#if !defined(CONNECT_FULLY_SPECIFIED)

typedef enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown,
    InterruptActiveHigh,
    InterruptActiveLow
} KINTERRUPT_POLARITY, *PKINTERRUPT_POLARITY;

typedef
BOOLEAN
(*PKMESSAGE_SERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext,
    IN ULONG MessageID
    );

//
// Interrupt message information table definition.
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {
    PHYSICAL_ADDRESS MessageAddress;
    KAFFINITY TargetProcessorSet;
    PKINTERRUPT InterruptObject;
    ULONG MessageData;
    ULONG Vector;
    KIRQL Irql;
    KINTERRUPT_MODE Mode;
    KINTERRUPT_POLARITY Polarity;
} IO_INTERRUPT_MESSAGE_INFO_ENTRY, *PIO_INTERRUPT_MESSAGE_INFO_ENTRY;

typedef struct _IO_INTERRUPT_MESSAGE_INFO {
    KIRQL UnifiedIrql;
    ULONG MessageCount;
    IO_INTERRUPT_MESSAGE_INFO_ENTRY MessageInfo[1];
} IO_INTERRUPT_MESSAGE_INFO, *PIO_INTERRUPT_MESSAGE_INFO;

//
// Fully specified, line based, and message based interrupt connection
// parameter structure definitions.
//

typedef struct _IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS {
    IN PDEVICE_OBJECT PhysicalDeviceObject;
    OUT PKINTERRUPT *InterruptObject;
    IN PKSERVICE_ROUTINE ServiceRoutine;
    IN PVOID ServiceContext;
    IN PKSPIN_LOCK SpinLock OPTIONAL;
    IN KIRQL SynchronizeIrql;
    IN BOOLEAN FloatingSave;
    IN BOOLEAN ShareVector;
    IN ULONG Vector;
    IN KIRQL Irql;
    IN KINTERRUPT_MODE InterruptMode;
    IN KAFFINITY ProcessorEnableMask;
} IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS; 

typedef struct _IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS {
    IN PDEVICE_OBJECT PhysicalDeviceObject;
    OUT PKINTERRUPT *InterruptObject;
    IN PKSERVICE_ROUTINE ServiceRoutine;
    IN PVOID ServiceContext;
    IN PKSPIN_LOCK SpinLock OPTIONAL;
    IN KIRQL SynchronizeIrql OPTIONAL;
    IN BOOLEAN FloatingSave;
} IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS;

typedef struct _IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS {
    IN PDEVICE_OBJECT PhysicalDeviceObject;
    union {
        OUT PVOID *Generic;
        OUT PIO_INTERRUPT_MESSAGE_INFO *InterruptMessageTable;
        OUT PKINTERRUPT *InterruptObject;
    } ConnectionContext;
    IN PKMESSAGE_SERVICE_ROUTINE MessageServiceRoutine;
    IN PVOID ServiceContext;
    IN PKSPIN_LOCK SpinLock OPTIONAL;
    IN KIRQL SynchronizeIrql OPTIONAL;
    IN BOOLEAN FloatingSave;
    IN PKSERVICE_ROUTINE FallBackServiceRoutine OPTIONAL;
} IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS,
  *PIO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS;

//
// Top level interrupt connection parameter definitions.
//

#define CONNECT_FULLY_SPECIFIED     0x1
#define CONNECT_LINE_BASED          0x2
#define CONNECT_MESSAGE_BASED       0x3
#define CONNECT_CURRENT_VERSION     0x3

typedef struct _IO_CONNECT_INTERRUPT_PARAMETERS {
    IN OUT ULONG Version;
    union {
        IO_CONNECT_INTERRUPT_FULLY_SPECIFIED_PARAMETERS FullySpecified;
        IO_CONNECT_INTERRUPT_LINE_BASED_PARAMETERS LineBased;
        IO_CONNECT_INTERRUPT_MESSAGE_BASED_PARAMETERS MessageBased;
    };
} IO_CONNECT_INTERRUPT_PARAMETERS, *PIO_CONNECT_INTERRUPT_PARAMETERS;

//
// Interrupt disconnection parameter structure definition.
//

typedef struct _IO_DISCONNECT_INTERRUPT_PARAMETERS {
    IN ULONG Version;
    union {
        IN PVOID Generic;
        IN PKINTERRUPT InterruptObject;
        IN PIO_INTERRUPT_MESSAGE_INFO InterruptMessageTable;
    } ConnectionContext;
} IO_DISCONNECT_INTERRUPT_PARAMETERS, *PIO_DISCONNECT_INTERRUPT_PARAMETERS;

#endif // !defined(CONNECT_FULLY_SPECIFIED)

//
// Supply an overrideable library implementation of IoConnectInterruptEx.
// See DDK documentation for more details on this API.
//

#undef IoConnectInterruptEx
#define IoConnectInterruptEx WdmlibIoConnectInterruptEx

NTSTATUS
WdmlibIoConnectInterruptEx (
    __inout PIO_CONNECT_INTERRUPT_PARAMETERS Parameters
    );

//
// Supply an overrideable library implementation of IoDisconnectInterruptEx.
// See DDK documentation for more details on this API.
//

#undef IoDisconnectInterruptEx
#define IoDisconnectInterruptEx WdmlibIoDisconnectInterruptEx

NTSTATUS
WdmlibIoDisconnectInterruptEx (
    __inout PIO_DISCONNECT_INTERRUPT_PARAMETERS Parameters
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif // !defined(_IOINTEX_IOINTEX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\imgerror.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for imgerror.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imgerror_h__
#define __imgerror_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IImgErrorInfo_FWD_DEFINED__
#define __IImgErrorInfo_FWD_DEFINED__
typedef interface IImgErrorInfo IImgErrorInfo;
#endif 	/* __IImgErrorInfo_FWD_DEFINED__ */


#ifndef __IImgCreateErrorInfo_FWD_DEFINED__
#define __IImgCreateErrorInfo_FWD_DEFINED__
typedef interface IImgCreateErrorInfo IImgCreateErrorInfo;
#endif 	/* __IImgCreateErrorInfo_FWD_DEFINED__ */


#ifndef __CoImgErrorInfo_FWD_DEFINED__
#define __CoImgErrorInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoImgErrorInfo CoImgErrorInfo;
#else
typedef struct CoImgErrorInfo CoImgErrorInfo;
#endif /* __cplusplus */

#endif 	/* __CoImgErrorInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_imgerror_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_imgerror_0000_0000_0001
    {
    BSTR description;
    GUID guid;
    DWORD helpContext;
    BSTR helpFile;
    BSTR source;
    BSTR devDescription;
    GUID errorID;
    ULONG cUserParameters;
    BSTR *aUserParameters;
    BSTR userFallback;
    DWORD exceptionID;
    } 	ImgErrorInfo;



extern RPC_IF_HANDLE __MIDL_itf_imgerror_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imgerror_0000_0000_v0_0_s_ifspec;

#ifndef __IImgErrorInfo_INTERFACE_DEFINED__
#define __IImgErrorInfo_INTERFACE_DEFINED__

/* interface IImgErrorInfo */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IImgErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2bce4ece-d30e-445a-9423-6829be945ad8")
    IImgErrorInfo : public IErrorInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeveloperDescription( 
            /* [out] */ BSTR *pbstrDevDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserErrorId( 
            /* [out] */ GUID *pErrorId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserParameterCount( 
            /* [out] */ ULONG *pcUserParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserParameter( 
            /* [in] */ ULONG cParam,
            /* [out] */ BSTR *pbstrParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserFallback( 
            /* [out] */ BSTR *pbstrFallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExceptionId( 
            /* [out] */ DWORD *pExceptionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetachErrorInfo( 
            /* [out] */ ImgErrorInfo *pErrorInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImgErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImgErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImgErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImgErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IImgErrorInfo * This,
            /* [out] */ GUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSource )( 
            IImgErrorInfo * This,
            /* [out] */ BSTR *pBstrSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IImgErrorInfo * This,
            /* [out] */ BSTR *pBstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpFile )( 
            IImgErrorInfo * This,
            /* [out] */ BSTR *pBstrHelpFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpContext )( 
            IImgErrorInfo * This,
            /* [out] */ DWORD *pdwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeveloperDescription )( 
            IImgErrorInfo * This,
            /* [out] */ BSTR *pbstrDevDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserErrorId )( 
            IImgErrorInfo * This,
            /* [out] */ GUID *pErrorId);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserParameterCount )( 
            IImgErrorInfo * This,
            /* [out] */ ULONG *pcUserParams);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserParameter )( 
            IImgErrorInfo * This,
            /* [in] */ ULONG cParam,
            /* [out] */ BSTR *pbstrParam);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserFallback )( 
            IImgErrorInfo * This,
            /* [out] */ BSTR *pbstrFallback);
        
        HRESULT ( STDMETHODCALLTYPE *GetExceptionId )( 
            IImgErrorInfo * This,
            /* [out] */ DWORD *pExceptionId);
        
        HRESULT ( STDMETHODCALLTYPE *DetachErrorInfo )( 
            IImgErrorInfo * This,
            /* [out] */ ImgErrorInfo *pErrorInfo);
        
        END_INTERFACE
    } IImgErrorInfoVtbl;

    interface IImgErrorInfo
    {
        CONST_VTBL struct IImgErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImgErrorInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImgErrorInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImgErrorInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImgErrorInfo_GetGUID(This,pGUID)	\
    ( (This)->lpVtbl -> GetGUID(This,pGUID) ) 

#define IImgErrorInfo_GetSource(This,pBstrSource)	\
    ( (This)->lpVtbl -> GetSource(This,pBstrSource) ) 

#define IImgErrorInfo_GetDescription(This,pBstrDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pBstrDescription) ) 

#define IImgErrorInfo_GetHelpFile(This,pBstrHelpFile)	\
    ( (This)->lpVtbl -> GetHelpFile(This,pBstrHelpFile) ) 

#define IImgErrorInfo_GetHelpContext(This,pdwHelpContext)	\
    ( (This)->lpVtbl -> GetHelpContext(This,pdwHelpContext) ) 


#define IImgErrorInfo_GetDeveloperDescription(This,pbstrDevDescription)	\
    ( (This)->lpVtbl -> GetDeveloperDescription(This,pbstrDevDescription) ) 

#define IImgErrorInfo_GetUserErrorId(This,pErrorId)	\
    ( (This)->lpVtbl -> GetUserErrorId(This,pErrorId) ) 

#define IImgErrorInfo_GetUserParameterCount(This,pcUserParams)	\
    ( (This)->lpVtbl -> GetUserParameterCount(This,pcUserParams) ) 

#define IImgErrorInfo_GetUserParameter(This,cParam,pbstrParam)	\
    ( (This)->lpVtbl -> GetUserParameter(This,cParam,pbstrParam) ) 

#define IImgErrorInfo_GetUserFallback(This,pbstrFallback)	\
    ( (This)->lpVtbl -> GetUserFallback(This,pbstrFallback) ) 

#define IImgErrorInfo_GetExceptionId(This,pExceptionId)	\
    ( (This)->lpVtbl -> GetExceptionId(This,pExceptionId) ) 

#define IImgErrorInfo_DetachErrorInfo(This,pErrorInfo)	\
    ( (This)->lpVtbl -> DetachErrorInfo(This,pErrorInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImgErrorInfo_INTERFACE_DEFINED__ */


#ifndef __IImgCreateErrorInfo_INTERFACE_DEFINED__
#define __IImgCreateErrorInfo_INTERFACE_DEFINED__

/* interface IImgCreateErrorInfo */
/* [ref][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IImgCreateErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c55a64c-07cd-4fb5-90f7-b753d91f0c9e")
    IImgCreateErrorInfo : public ICreateErrorInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AttachToErrorInfo( 
            /* [out][in] */ ImgErrorInfo *pErrorInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImgCreateErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImgCreateErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImgCreateErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImgCreateErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IImgCreateErrorInfo * This,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *SetSource )( 
            IImgCreateErrorInfo * This,
            /* [in] */ LPOLESTR szSource);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IImgCreateErrorInfo * This,
            /* [in] */ LPOLESTR szDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetHelpFile )( 
            IImgCreateErrorInfo * This,
            /* [in] */ LPOLESTR szHelpFile);
        
        HRESULT ( STDMETHODCALLTYPE *SetHelpContext )( 
            IImgCreateErrorInfo * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE *AttachToErrorInfo )( 
            IImgCreateErrorInfo * This,
            /* [out][in] */ ImgErrorInfo *pErrorInfo);
        
        END_INTERFACE
    } IImgCreateErrorInfoVtbl;

    interface IImgCreateErrorInfo
    {
        CONST_VTBL struct IImgCreateErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImgCreateErrorInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IImgCreateErrorInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IImgCreateErrorInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IImgCreateErrorInfo_SetGUID(This,rguid)	\
    ( (This)->lpVtbl -> SetGUID(This,rguid) ) 

#define IImgCreateErrorInfo_SetSource(This,szSource)	\
    ( (This)->lpVtbl -> SetSource(This,szSource) ) 

#define IImgCreateErrorInfo_SetDescription(This,szDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,szDescription) ) 

#define IImgCreateErrorInfo_SetHelpFile(This,szHelpFile)	\
    ( (This)->lpVtbl -> SetHelpFile(This,szHelpFile) ) 

#define IImgCreateErrorInfo_SetHelpContext(This,dwHelpContext)	\
    ( (This)->lpVtbl -> SetHelpContext(This,dwHelpContext) ) 


#define IImgCreateErrorInfo_AttachToErrorInfo(This,pErrorInfo)	\
    ( (This)->lpVtbl -> AttachToErrorInfo(This,pErrorInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IImgCreateErrorInfo_INTERFACE_DEFINED__ */



#ifndef __ImgErrorInfoLib_LIBRARY_DEFINED__
#define __ImgErrorInfoLib_LIBRARY_DEFINED__

/* library ImgErrorInfoLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ImgErrorInfoLib;

EXTERN_C const CLSID CLSID_CoImgErrorInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("a8055515-6adb-4e75-b84d-e0c46bc434b0")
CoImgErrorInfo;
#endif
#endif /* __ImgErrorInfoLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ip6firewall.h ===
/*++

Copyright (c) 2004-2005  Microsoft Corporation

Module Name:

    ip6firewall.h

Abstract:

    This module contains definitions for the IPv6 firewall hook.

Environment:

    Kernel mode only.

--*/

#if (NTDDI_VERSION < NTDDI_LONGHORN) 

#ifndef _IP6FIREWALL_
#define _IP6FIREWALL_

#pragma once

#include <ipinfo.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Types used by the firewall hook.
//

typedef enum {
    DirectionTransmit,
    DirectionReceive,
    DirectionMax
} IPv6Direction;

typedef enum {
    ActionAccept,
    ActionDrop,
    ActionMax
} IPv6Action;

typedef 
IPv6Action
(*IPv6FirewallHookProc) (
    const IPv6Addr *SourceAddress,
    const IPv6Addr *DestinationAddress,
    uint PayloadLength,
    uchar HeaderType,
    const uchar *HeaderData,
    const void *PacketContext,
    uint DataLength,
    uint InterfaceIndex,
    IPv6Direction Direction,
    BOOLEAN IsLoopBack
    );

typedef void
(*IPv6FirewallDeregistrationCompleteProc)(
    );

//
// Exported function declarations.
//

extern NTSTATUS
IPv6EnableFirewallHook(
    IPv6FirewallHookProc FirewallHookFunction
    );

extern void
IPv6DisableFirewallHook(
    IPv6FirewallDeregistrationCompleteProc CompletionRoutine
    );

extern const uchar *
IPv6ObtainPacketData(
    const void *PacketContext,
    uint DataLength,
    uint Alignment
    );

extern IP_STATUS
IPv6GetBestRouteInfo(
    const IPv6Addr *Addr,
    ulong ScopeId,
    ulong Index,
    IP6RouteEntry *Ire
    );
    
#ifdef __cplusplus
}
#endif

#endif // _IP6FIREWALL_

#endif //(NTDDI_VERSION < NTDDI_LONGHORN)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ipfirewall.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    ipfirewall.h

Abstract:

    Header file for IP firewall hook clients. 

--*/

#if (NTDDI_VERSION < NTDDI_LONGHORN) 

#pragma once

#define INVALID_IF_INDEX        0xffffffff
#define LOCAL_IF_INDEX          0

//
// Indicates whether it is a transmitted or received packet.
//

typedef enum _IP_DIRECTION_E {
    IP_TRANSMIT,
    IP_RECEIVE
} DIRECTION_E, *PDIRECTION_E;

typedef struct _FIREWALL_CONTEXT_T {
    DIRECTION_E Direction;
    void        *NTE;
    void        *LinkCtxt;
    NDIS_HANDLE LContext1;
    UINT        LContext2;
} FIREWALL_CONTEXT_T, *PFIREWALL_CONTEXT_T;

//  Definition of an IP receive buffer chain.
typedef struct IPRcvBuf {
    struct IPRcvBuf *ipr_next;          // Next buffer descriptor in chain.
    UINT            ipr_owner;          // Owner of buffer.
    __field_ecount(ipr_size) UCHAR           *ipr_buffer;        // Pointer to buffer.
    UINT            ipr_size;           // Buffer size.
    PMDL            ipr_pMdl;
    UINT            *ipr_pClientCnt;
    UCHAR           *ipr_RcvContext;
    UINT            ipr_RcvOffset;
#if (NTDDI_VERSION >= NTDDI_WINXP)
    ULONG           ipr_flags;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
    ULONG           ipr_promiscuous;
#endif
} IPRcvBuf;

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define IPR_FLAG_CHECKSUM_OFFLOAD   0x00000002
#endif

//
// Enum for values that may be returned from filter routine.
//

typedef enum _FORWARD_ACTION {
    FORWARD         = 0,
    DROP            = 1,
    ICMP_ON_DROP    = 2
} FORWARD_ACTION;


// Definiton for a firewall routine callout.
typedef FORWARD_ACTION
(*IPPacketFirewallPtr)(
    VOID        **pData,
    UINT        RecvInterfaceIndex,
    UINT        *pSendInterfaceIndex,
    UCHAR       *pDestinationType,
    VOID        *pContext,
    UINT        ContextLength,
    IPRcvBuf    **ppRcvBuf
    );

extern
int
IPAllocBuff(
    IPRcvBuf    *pRcvBuf,
    UINT        Size
    );

extern
VOID
IPFreeBuff(
    IPRcvBuf    *pRcvBuf
    );

extern
VOID
FreeIprBuff(
    IPRcvBuf    *pRcvBuf
    );

typedef enum _IPROUTEINFOCLASS {
    IPRouteNoInformation,
    IPRouteOutgoingFirewallContext,
    IPRouteOutgoingFilterContext,
    MaxIPRouteInfoClass
} IPROUTEINFOCLASS;

extern
NTSTATUS
LookupRouteInformation(
    IN      VOID*               RouteLookupData,
    OUT     VOID*               RouteEntry OPTIONAL,
    IN      IPROUTEINFOCLASS    RouteInfoClass OPTIONAL,
    OUT     VOID*               RouteInformation OPTIONAL,
    IN OUT  UINT*               RouteInfoLength OPTIONAL
    );

// Structure passed to the IPSetFirewallHook call

typedef struct _IP_SET_FIREWALL_HOOK_INFO {
    IPPacketFirewallPtr FirewallPtr;    // Packet filter callout.
    UINT                Priority;       // Priority of the hook
    BOOLEAN             Add;            // if TRUE then ADD else DELETE
} IP_SET_FIREWALL_HOOK_INFO, *PIP_SET_FIREWALL_HOOK_INFO;


#define DEST_LOCAL          0           // Destination is local.
#define DEST_BCAST          0x01        // Destination is net or local bcast.
#define DEST_SN_BCAST       0x03        // A subnet bcast.
#define DEST_MCAST          0x05        // A local mcast.
#define DEST_REMOTE         0x08        // Destination is remote.
#define DEST_REM_BCAST      0x0b        // Destination is a remote broadcast
#define DEST_REM_MCAST      0x0d        // Destination is a remote mcast.
#define DEST_INVALID        0xff        // Invalid destination

#define DEST_PROMIS         0x20        // Dest is promiscuous

#define DEST_BCAST_BIT      0x01
#define DEST_OFFNET_BIT     0x10        // Destination is offnet -
                                        // used only by upper layer
                                        // callers.
#define DEST_MCAST_BIT      0x05

#define DD_IP_DEVICE_NAME   L"\\Device\\Ip"

#define FSCTL_IP_BASE       FILE_DEVICE_NETWORK

#define _IP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IP_BASE, function, method, access)

#define IOCTL_IP_SET_FIREWALL_HOOK  \
            _IP_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif //(NTDDI_VERSION < NTDDI_LONGHORN)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
    ulong       ipsi_forwarding;
    ulong       ipsi_defaultttl;
    ulong       ipsi_inreceives;
    ulong       ipsi_inhdrerrors;
    ulong       ipsi_inaddrerrors;
    ulong       ipsi_forwdatagrams;
    ulong       ipsi_inunknownprotos;
    ulong       ipsi_indiscards;
    ulong       ipsi_indelivers;
    ulong       ipsi_outrequests;
    ulong       ipsi_routingdiscards;
    ulong       ipsi_outdiscards;
    ulong       ipsi_outnoroutes;
    ulong       ipsi_reasmtimeout;
    ulong       ipsi_reasmreqds;
    ulong       ipsi_reasmoks;
    ulong       ipsi_reasmfails;
    ulong       ipsi_fragoks;
    ulong       ipsi_fragfails;
    ulong       ipsi_fragcreates;
    ulong       ipsi_numif;
    ulong       ipsi_numaddr;
    ulong       ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_destunreachs;
    ulong       icmps_timeexcds;
    ulong       icmps_parmprobs;
    ulong       icmps_srcquenchs;
    ulong       icmps_redirects;
    ulong       icmps_echos;
    ulong       icmps_echoreps;
    ulong       icmps_timestamps;
    ulong       icmps_timestampreps;
    ulong       icmps_addrmasks;
    ulong       icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
    ICMPStats   icsi_instats;
    ICMPStats   icsi_outstats;
} ICMPSNMPInfo;

typedef struct ICMPv6Stats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_typecount[256];
} ICMPv6Stats;

typedef struct ICMPv6SNMPInfo {
    ICMPv6Stats   icsi_instats;
    ICMPv6Stats   icsi_outstats;
} ICMPv6SNMPInfo;

#define IP_FORWARDING       1
#define IP_NOT_FORWARDING   2

typedef struct IPAddrEntry {
    ulong       iae_addr;
    ulong       iae_index;
    ulong       iae_mask;
    ulong       iae_bcastaddr;
    ulong       iae_reasmsize;
    ushort      iae_context;
    ushort      iae_pad;
} IPAddrEntry;

//
// NT4 IPRouteEntry structure
//

typedef struct IPRouteEntry_V1 {
    ulong       ire_dest;
    ulong       ire_index;
    ulong       ire_metric1;
    ulong       ire_metric2;
    ulong       ire_metric3;
    ulong       ire_metric4;
    ulong       ire_nexthop;
    ulong       ire_type;
    ulong       ire_proto;
    ulong       ire_age;
    ulong       ire_mask;
    ulong       ire_metric5;
// removed ifdef NT because it was breaking route/inetmib1
// NT is not defined in route and inetmib1 sources file
    void        *ire_context;
} IPRouteEntry_V1;

//
// win2000(all SPs) IPRouteEntry structure
//

typedef struct IPRouteEntry_V2 {
    ulong       ire_dest;
    ulong       ire_index;
    ulong       ire_metric1;
    ulong       ire_metric2;
    ulong       ire_metric3;
    ulong       ire_metric4;
    ulong       ire_nexthop;
    ulong       ire_type;
    ulong       ire_proto;
    ulong       ire_age;
    ulong       ire_mask;
    ulong       ire_metric5;
#ifdef NT
    void        *ire_context;
#endif
} IPRouteEntry_V2;

//
// WinXP (RTM/SP1/SP2), Win2k3(RTM/SP1) and Vista (LHS/SP1)
// IPRouteEntry structure.
//

typedef struct IPRouteEntry_V3 {
    ulong       ire_dest;
    ulong       ire_index;
    ulong       ire_metric1;
    ulong       ire_metric2;
    ulong       ire_metric3;
    ulong       ire_metric4;
    ulong       ire_nexthop;
    ulong       ire_type;
    ulong       ire_proto;
    ulong       ire_age;
    ulong       ire_mask;
    ulong       ire_metric5;
#ifdef NT
    ulong       ire_context;
#endif
} IPRouteEntry_V3;

#if (NTDDI_VERSION < NTDDI_WIN2K)
typedef IPRouteEntry_V1 IPRouteEntry;
#elif (NTDDI_VERSION < NTDDI_WINXP)
typedef IPRouteEntry_V2 IPRouteEntry;
#else 
typedef IPRouteEntry_V3 IPRouteEntry;
#endif //NTDDI_VERSION < NTDDI_WIN2K

typedef struct IPRouteBlock {
    ulong       numofroutes;
    IPRouteEntry route[1];
} IPRouteBlock;

//
// Route with multiple nexthops and associated defns
//

//
// Win2000(all SPs) IPRouteNextHopEntry structure
//

typedef struct IPRouteNextHopEntry_V1 {
    ulong       ine_iretype;
    ulong       ine_nexthop;
    ulong       ine_ifindex;
#ifdef NT
    void        *ine_context;
#endif
} IPRouteNextHopEntry_V1;

//
// WinXP and later IPRouteNextHopEntry structure 
//

typedef struct IPRouteNextHopEntry_V2 {
    ulong       ine_iretype;
    ulong       ine_nexthop;
    ulong       ine_ifindex;
#ifdef NT
    ulong       ine_context;
#endif
} IPRouteNextHopEntry_V2;

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef IPRouteNextHopEntry_V1 IPRouteNextHopEntry;
#else 
typedef IPRouteNextHopEntry_V2 IPRouteNextHopEntry;
#endif //NTDDI_VERSION < NTDDI_WINXP

//
// Win2000(all SPs) IPMultihopRouteEntry structure
//

typedef struct IPMultihopRouteEntry_V1 {
    ulong               imre_numnexthops;
    IPRouteEntry        imre_routeinfo;
    IPRouteNextHopEntry imre_morenexthops[1];
} IPMultihopRouteEntry_V1;

//
// WinXP and later IPMultihopRouteEntry structure
//

typedef struct IPMultihopRouteEntry_V2 {
    ulong               imre_numnexthops;
    ulong               imre_flags;
    IPRouteEntry        imre_routeinfo;
    IPRouteNextHopEntry imre_morenexthops[1];
} IPMultihopRouteEntry_V2;

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef IPMultihopRouteEntry_V1 IPMultihopRouteEntry;
#else 
typedef IPMultihopRouteEntry_V2 IPMultihopRouteEntry;
#endif //NTDDI_VERSION < NTDDI_WINXP


#define IMRE_FLAG_DELETE_DEST   0x00000001

//
// Input context to pass when querying a route
//

typedef enum {
    IPNotifyNotification = 0,
    IPNotifySynchronization,
    IPNotifyMaximumVersion
} IPNotifyVersion;

typedef struct IPNotifyData {
    ulong       Version;   // See IPNotifyVersion above.
    ulong       Add;
    char        Info[1];
} IPNotifyData, *PIPNotifyData;

typedef struct IPNotifyOutput {
    ulong       ino_addr;
    ulong       ino_mask;
    ulong       ino_info[6];
} IPNotifyOutput, *PIPNotifyOutput;

typedef union IPRouteNotifyOutput {
    IPNotifyOutput irno_info;
    struct {
        ulong   irno_dest;
        ulong   irno_mask;
        ulong   irno_nexthop;
        ulong   irno_proto;
        ulong   irno_ifindex;
        ulong   irno_metric;
        ulong   irno_flags;
    };
} IPRouteNotifyOutput, *PIPRouteNotifyOutput;

#define IRNO_FLAG_ADD       0x00000001
#define IRNO_FLAG_DELETE    0x00000002

//
// Input context to pass when querying a route
//
typedef struct IPRouteLookupData {
    ulong       Version;   //version of this structure
    ulong       DestAdd;
    ulong       SrcAdd;
    char        Info[1];
} IPRouteLookupData, *PIPRouteLookupData;

typedef struct AddrXlatInfo {
    ulong       axi_count;
    ulong       axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

//
// IRE_PROTO_PERSIST_LOCAL was defined on W2k (all SPs),
// XP RTM, and XP SP1. It's been removed since XP SP2.
//
#if ((NTDDI_VERSION >= NTDDI_WIN2K) && (NTDDI_VERSION < NTDDI_WINXPSP2))
#define IRE_PROTO_PERSIST_LOCAL 10010
#endif 

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                 1
#define IP_MIB_RTCHANGE_NOTIFY_ID       2
#define ICMP_MIB_STATS_ID               1

#define AT_MIB_ADDRXLAT_INFO_ID         1
#define AT_MIB_ADDRXLAT_ENTRY_ID        0x101

#define IP_MIB_RTTABLE_ENTRY_ID         0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID       0x102
#define IP_MIB_RTTABLE_ENTRY_ID_EX      0x103

#define IP_INTFC_FLAG_P2P                 1
#define IP_INTFC_FLAG_P2MP                2
#define IP_INTFC_FLAG_UNIDIRECTIONAL      4


typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103
#define IP_MIB_SINGLE_RT_ENTRY_ID       0x104
#define IP_GET_BEST_SOURCE              0x105

//
// Pick up in6_addr type.
//
#include <in6addr.h>

//
// IP6RouteEntry_V1, defined on WinXP RTM, WinXP SP1, W2k3 RTM, 
// and Longhorn/Vista. 
//
typedef struct IP6RouteEntry_V1 {
    ulong           ire_Length;
    struct in6_addr ire_Source;
    ulong           ire_ScopeId;
    ulong           ire_IfIndex;
} IP6RouteEntry_V1;

//
// IP6RouteEntry_V2, defined on WinXP SP2, W2k3 SP1 
// (and possibly on subsequent service packs of XP and 2k3)
//
typedef struct IP6RouteEntry_V2 {
    ulong           ire_Length;
    ulong           ire_Type;
    ulong           ire_IfIndex;
    ulong           ire_SourceScopeId;
    ulong           ire_NextHopScopeId;
    struct in6_addr ire_Source;
    struct in6_addr ire_NextHop;
} IP6RouteEntry_V2;

#if (NTDDI_VERSION < NTDDI_WINXPSP2) //XPSP1 and before
typedef IP6RouteEntry_V1 IP6RouteEntry; 
#elif (NTDDI_VERSION < NTDDI_WS03) //[XPSP2, 2k3RTM)
typedef IP6RouteEntry_V2 IP6RouteEntry; 
#elif (NTDDI_VERSION < NTDDI_WS03SP1) //[2k3RTM]
typedef IP6RouteEntry_V1 IP6RouteEntry;
#elif (NTDDI_VERSION < NTDDI_LONGHORN) //[2k3SP1, Longhorn)
typedef IP6RouteEntry_V2 IP6RouteEntry;
#else //[Longhorn, ...]
typedef IP6RouteEntry_V1 IP6RouteEntry;
#endif //NTDDI_VERSION < NTDDI_WINXPSP2

#define IP6_MIB_STATS_ID       IP_MIB_STATS_ID
#define IP6_GET_BEST_ROUTE_ID  3
#define ICMP6_MIB_STATS_ID     4

#pragma warning(pop)

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsicfg.h ===
#ifndef _iscsicfg_h_
#define _iscsicfg_h_

// MSiSCSI_TCPIPConfig - MSiSCSI_TCPIPConfig


//***************************************************************************
//
//  iscsicfg.h
// 
//  Module: iScsi Discovery api
//
//  Purpose: Header defining interface between user mode configuration
//           apps and HBA driver miniport.
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#include <iscsidef.h>

//
//
// This class is required.
//
// TCP/IP configuration class, implement one instance for each IP address on
// your adapter. For example, if you adapter supports 3 IP addresses then
// your adapter would implement 3 instances of this class.
//
// This class uses PDO instance names with 1 instance for each TCP/IP interface.
//

#define MSiSCSI_TCPIPConfigGuid \
    { 0x7a2c6c2b,0xe5a5,0x49ad, { 0xad,0x68,0x13,0x30,0x89,0xac,0xd7,0x4d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_TCPIPConfig_GUID, \
            0x7a2c6c2b,0xe5a5,0x49ad,0xad,0x68,0x13,0x30,0x89,0xac,0xd7,0x4d);
#endif


typedef struct _MSiSCSI_TCPIPConfig
{
    // TRUE if the adapter should use an autogenerated and non routable (link local) address as its IP address.
    BOOLEAN UseLinkLocalAddress;
    #define MSiSCSI_TCPIPConfig_UseLinkLocalAddress_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_TCPIPConfig_UseLinkLocalAddress_ID 1

    // TRUE if the adapter should use DHCP to discovery its IP address information.
    BOOLEAN EnableDHCP;
    #define MSiSCSI_TCPIPConfig_EnableDHCP_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_TCPIPConfig_EnableDHCP_ID 2

    // TRUE if the adapter should use DHCP to discover DNS addresses.
    BOOLEAN UseDHCPForDNS;
    #define MSiSCSI_TCPIPConfig_UseDHCPForDNS_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_TCPIPConfig_UseDHCPForDNS_ID 3

    // IP Versions supported **Add #defines**
    ULONG IPVersions;
    #define MSiSCSI_TCPIPConfig_IPVersions_SIZE sizeof(ULONG)
    #define MSiSCSI_TCPIPConfig_IPVersions_ID 4

    // IP address of the adapter
    ISCSI_IP_Address IpAddress;
    #define MSiSCSI_TCPIPConfig_IpAddress_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_TCPIPConfig_IpAddress_ID 5

    // Static Default Gateway IP address
    ISCSI_IP_Address DefaultGateway;
    #define MSiSCSI_TCPIPConfig_DefaultGateway_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_TCPIPConfig_DefaultGateway_ID 6

    // Static Subnet Mask
    ISCSI_IP_Address SubnetMask;
    #define MSiSCSI_TCPIPConfig_SubnetMask_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_TCPIPConfig_SubnetMask_ID 7

    // Preferred DNS Server
    ISCSI_IP_Address PreferredDNSServer;
    #define MSiSCSI_TCPIPConfig_PreferredDNSServer_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_TCPIPConfig_PreferredDNSServer_ID 8

    // Alternate DNS Server
    ISCSI_IP_Address AlternateDNSServer;
    #define MSiSCSI_TCPIPConfig_AlternateDNSServer_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_TCPIPConfig_AlternateDNSServer_ID 9

} MSiSCSI_TCPIPConfig, *PMSiSCSI_TCPIPConfig;

#define MSiSCSI_TCPIPConfig_SIZE (FIELD_OFFSET(MSiSCSI_TCPIPConfig, AlternateDNSServer) + MSiSCSI_TCPIPConfig_AlternateDNSServer_SIZE)

// MSiSCSI_NICConfig - MSiSCSI_NICConfig

//
// This class is optional.
//
// NIC Port configuration class, implement one instance for each physical 
// network interface port on your adapter.
//
// This class uses PDO instance names with 1 instance for each physical
// network interface port on your adapter.
//

typedef enum 
{
    ISCSI_NIC_LINKSTATE_DISCONNECTED = 0,
    ISCSI_NIC_LINKSTATE_CONNECTED = 1
} ISCSI_NIC_LINKSTATE, *PISCSI_NIC_LINKSTATE;

#define MSiSCSI_NICConfigGuid \
    { 0xc75258e9,0xbe79,0x4a48, { 0xa2,0x3d,0xee,0xb6,0xf8,0xfb,0x94,0x0c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_NICConfig_GUID, \
            0xc75258e9,0xbe79,0x4a48,0xa2,0x3d,0xee,0xb6,0xf8,0xfb,0x94,0x0c);
#endif


typedef struct _MSiSCSI_NICConfig
{
    // Speed of network link in megabits per second.
    ULONG LinkSpeed;
    #define MSiSCSI_NICConfig_LinkSpeed_SIZE sizeof(ULONG)
    #define MSiSCSI_NICConfig_LinkSpeed_ID 1

    // Maximum Speed of network link in megabits per second.
    ULONG MaxLinkSpeed;
    #define MSiSCSI_NICConfig_MaxLinkSpeed_SIZE sizeof(ULONG)
    #define MSiSCSI_NICConfig_MaxLinkSpeed_ID 2

    // Link State **typedef**
    ULONG LinkState;
    #define MSiSCSI_NICConfig_LinkState_SIZE sizeof(ULONG)
    #define MSiSCSI_NICConfig_LinkState_ID 3

    // Maximum frame size
    ULONG MaxFrameSize;
    #define MSiSCSI_NICConfig_MaxFrameSize_SIZE sizeof(ULONG)
    #define MSiSCSI_NICConfig_MaxFrameSize_ID 4

    // Ethernet MAC Address
    UCHAR MacAddress[6];
    #define MSiSCSI_NICConfig_MacAddress_SIZE sizeof(UCHAR[6])
    #define MSiSCSI_NICConfig_MacAddress_ID 5

} MSiSCSI_NICConfig, *PMSiSCSI_NICConfig;

#define MSiSCSI_NICConfig_SIZE (FIELD_OFFSET(MSiSCSI_NICConfig, MacAddress) + MSiSCSI_NICConfig_MacAddress_SIZE)

// MSiSCSI_BootConfiguration - MSiSCSI_BootConfiguration

//
// This class is optional.
//
// This class exposes the boot configuration if the adapter is configured to
// boot from an iSCSI disk.
//
// This class uses PDO instance names with a single instance.
//

#define MSiSCSI_BootConfigurationGuid \
    { 0x53ef8d5f,0x36f3,0x4124, { 0x8b,0x76,0xc6,0xad,0x52,0x1a,0x10,0x21 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_BootConfiguration_GUID, \
            0x53ef8d5f,0x36f3,0x4124,0x8b,0x76,0xc6,0xad,0x52,0x1a,0x10,0x21);
#endif


typedef struct _MSiSCSI_BootConfiguration
{
    // LUN on target to use as boot device.
    ULONGLONG LUN;
    #define MSiSCSI_BootConfiguration_LUN_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_BootConfiguration_LUN_ID 1

    // Security flags
    ULONGLONG SecurityFlags;
    #define MSiSCSI_BootConfiguration_SecurityFlags_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_BootConfiguration_SecurityFlags_ID 2

    // Size in bytes of Target Username.
    ULONG UsernameSize;
    #define MSiSCSI_BootConfiguration_UsernameSize_SIZE sizeof(ULONG)
    #define MSiSCSI_BootConfiguration_UsernameSize_ID 3

    // Size in bytes of Target Password.
    ULONG PasswordSize;
    #define MSiSCSI_BootConfiguration_PasswordSize_SIZE sizeof(ULONG)
    #define MSiSCSI_BootConfiguration_PasswordSize_ID 4

    // If TRUE dynamically discover boot device.
    BOOLEAN DiscoverBootDevice;
    #define MSiSCSI_BootConfiguration_DiscoverBootDevice_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_BootConfiguration_DiscoverBootDevice_ID 5

    // The InitiatorNode specifies the iSCSI name of the initiator node to use for the connection. If empty, then the adapter can choose any initiator node name.
    WCHAR InitiatorNode[223 + 1];
    #define MSiSCSI_BootConfiguration_InitiatorNode_ID 6

    // TargetName specifies the iSCSI target name on which the boot device resides.
    WCHAR TargetName[223 + 1];
    #define MSiSCSI_BootConfiguration_TargetName_ID 7

    // Target portal to use for connection to the target.
    ISCSI_TargetPortal TargetPortal;
    #define MSiSCSI_BootConfiguration_TargetPortal_SIZE sizeof(ISCSI_TargetPortal)
    #define MSiSCSI_BootConfiguration_TargetPortal_ID 8

    // Options that affect how login is performed. See ISCSI_LoginOptions
    ISCSI_LoginOptions LoginOptions;
    #define MSiSCSI_BootConfiguration_LoginOptions_SIZE sizeof(ISCSI_LoginOptions)
    #define MSiSCSI_BootConfiguration_LoginOptions_ID 9

    // **extra fields** Authentication Username, for CHAP this is the CHAP Name (CHAP_N) use when authenticating with the target. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding.
    UCHAR Username[1];
    #define MSiSCSI_BootConfiguration_Username_ID 10

    // Authentication Password, for CHAP this is the shared secret to use when generating the response to the target challange. This field is a variable length array.
//  UCHAR Password[1];
    #define MSiSCSI_BootConfiguration_Password_ID 11

} MSiSCSI_BootConfiguration, *PMSiSCSI_BootConfiguration;

// MSiSCSI_SecurityCapabilities - MSiSCSI_SecurityCapabilities

//
// This class is required if adapter supports IPSEC.
//
// This class exposes the security capabilities if the adapter 
// supports IPSEC.
//
// This class uses PDO instance names with a single instance.
//
typedef enum {
    ISCSI_ENCRYPT_NONE = 0,
    ISCSI_ENCRYPT_3DES_HMAC_SHA1 = 1,
    ISCSI_ENCRYPT_AES_CTR = 2              
} ISCSI_ENCRYPTION_TYPES, *PISCSI_ENCRYPTION_TYPES;


#define MSiSCSI_SecurityCapabilitiesGuid \
    { 0x225b9d64,0x47a9,0x41c8, { 0x81,0xcd,0x69,0xbc,0x02,0x65,0x2d,0x87 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_SecurityCapabilities_GUID, \
            0x225b9d64,0x47a9,0x41c8,0x81,0xcd,0x69,0xbc,0x02,0x65,0x2d,0x87);
#endif


typedef struct _MSiSCSI_SecurityCapabilities
{
    // TRUE if the adapter can use IPSEC to protect iSCSI traffic.
    BOOLEAN ProtectiScsiTraffic;
    #define MSiSCSI_SecurityCapabilities_ProtectiScsiTraffic_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_SecurityCapabilities_ProtectiScsiTraffic_ID 1

    // TRUE if the adapter can use IPSEC to protect iSNS traffic.
    BOOLEAN ProtectiSNSTraffic;
    #define MSiSCSI_SecurityCapabilities_ProtectiSNSTraffic_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_SecurityCapabilities_ProtectiSNSTraffic_ID 2

    // TRUE if adapter supports certificates
    BOOLEAN CertificatesSupported;
    #define MSiSCSI_SecurityCapabilities_CertificatesSupported_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_SecurityCapabilities_CertificatesSupported_ID 3

    // Number of encryption types available.
    ULONG EncryptionAvailableCount;
    #define MSiSCSI_SecurityCapabilities_EncryptionAvailableCount_SIZE sizeof(ULONG)
    #define MSiSCSI_SecurityCapabilities_EncryptionAvailableCount_ID 4

    // **typedef** Array of encryption types. This field is a variable length array.
    ULONG EncryptionAvailable[1];
    #define MSiSCSI_SecurityCapabilities_EncryptionAvailable_ID 5

} MSiSCSI_SecurityCapabilities, *PMSiSCSI_SecurityCapabilities;

// MSiSCSI_DiscoveryConfig - MSiSCSI_DiscoveryConfig

//
// This class is required.
//
// This class exposes the configuration capabilities for the adapter to be able to
// perform target discovery. An adapter needs to support target discovery
// if it is ever placed on a separate network from the PC NIC. Although
// the iSCSI Initiator service can use this class with any discovery mechanism
// the best results are obtained by using iSNS.
//
// This class uses PDO instance names with a single instance.
//

#define MSiSCSI_DiscoveryConfigGuid \
    { 0x45755098,0x4291,0x43df, { 0x97,0x20,0xb5,0x86,0x42,0xdd,0x63,0xdf } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_DiscoveryConfig_GUID, \
            0x45755098,0x4291,0x43df,0x97,0x20,0xb5,0x86,0x42,0xdd,0x63,0xdf);
#endif


typedef struct _MSiSCSI_DiscoveryConfig
{
    // TRUE if adapter should perform target discovery via iSNS.
    BOOLEAN PerformiSNSDiscovery;
    #define MSiSCSI_DiscoveryConfig_PerformiSNSDiscovery_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_DiscoveryConfig_PerformiSNSDiscovery_ID 1

    // TRUE if adapter should perform target discovery via SLP.
    BOOLEAN PerformSLPDiscovery;
    #define MSiSCSI_DiscoveryConfig_PerformSLPDiscovery_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_DiscoveryConfig_PerformSLPDiscovery_ID 2

    // TRUE if adapter should perform automatic discovery of iSNS server.
    BOOLEAN AutomaticiSNSDiscovery;
    #define MSiSCSI_DiscoveryConfig_AutomaticiSNSDiscovery_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_DiscoveryConfig_AutomaticiSNSDiscovery_ID 3

    // Default initiator name for registering with iSNS.
    WCHAR InitiatorName[256 + 1];
    #define MSiSCSI_DiscoveryConfig_InitiatorName_ID 4

    // If AutomaticiSNSDiscovery is FALSE then this contains the fixed addresses of iSNS servers
    ISCSI_IP_Address iSNSServer;
    #define MSiSCSI_DiscoveryConfig_iSNSServer_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_DiscoveryConfig_iSNSServer_ID 5

} MSiSCSI_DiscoveryConfig, *PMSiSCSI_DiscoveryConfig;

#define MSiSCSI_DiscoveryConfig_SIZE (FIELD_OFFSET(MSiSCSI_DiscoveryConfig, iSNSServer) + MSiSCSI_DiscoveryConfig_iSNSServer_SIZE)

// MSiSCSI_RADIUSConfig - MSiSCSI_RADIUSConfig

//
// This class is required if adapter supports using RADIUS for CHAP authentication.
//
// This class exposes the configuration capabilities if the adapter able to
// use radius to perform CHAP authentication. Using RADIUS is encouraged
// since it allows centralized management of CHAP credentials.
//
// This class uses PDO instance names with a single instance.
//

#define MSiSCSI_RADIUSConfigGuid \
    { 0x8eaef9d8,0xc053,0x49d3, { 0x92,0x05,0x65,0xc7,0x03,0xc2,0xec,0xc1 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_RADIUSConfig_GUID, \
            0x8eaef9d8,0xc053,0x49d3,0x92,0x05,0x65,0xc7,0x03,0xc2,0xec,0xc1);
#endif


typedef struct _MSiSCSI_RADIUSConfig
{
    // TRUE if adapter should use RADIUS for CHAP authentication
    BOOLEAN UseRADIUSForCHAP;
    #define MSiSCSI_RADIUSConfig_UseRADIUSForCHAP_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_RADIUSConfig_UseRADIUSForCHAP_ID 1

    // Size in bytes of shared secret used to communicate with RADIUS servers
    ULONG SharedSecretSizeInBytes;
    #define MSiSCSI_RADIUSConfig_SharedSecretSizeInBytes_SIZE sizeof(ULONG)
    #define MSiSCSI_RADIUSConfig_SharedSecretSizeInBytes_ID 2

    // Fixed address of primary RADIUS server
    ISCSI_IP_Address RADIUSServer;
    #define MSiSCSI_RADIUSConfig_RADIUSServer_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_RADIUSConfig_RADIUSServer_ID 3

    // Fixed address of backup RADIUS server
    ISCSI_IP_Address BackupRADIUSServer;
    #define MSiSCSI_RADIUSConfig_BackupRADIUSServer_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_RADIUSConfig_BackupRADIUSServer_ID 4

    // Must be zero
    ULONG Reserved;
    #define MSiSCSI_RADIUSConfig_Reserved_SIZE sizeof(ULONG)
    #define MSiSCSI_RADIUSConfig_Reserved_ID 5

    // Shared secret for communicating with primary and backup RADIUS servers. This field is a variable length array.
    UCHAR SharedSecret[1];
    #define MSiSCSI_RADIUSConfig_SharedSecret_ID 6

} MSiSCSI_RADIUSConfig, *PMSiSCSI_RADIUSConfig;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\irclass_ioctl.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Copyright 2005 OSR, Open Systems Resources, Inc. All rights Reserved.
// 
// Module Name:
// 
//     irclass_ioctl.h
// 
// Abstract:
// 
//    This module contains the IOCTL definitions for the 
//    WDF IRCLASS class driver
//
//  
// Author:
//
// Revision History:
//      
//
#ifndef __IRCLASS_IOCTL_H__
#define __IRCLASS_IOCTL_H__

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define FILE_DEVICE_IRCLASS     0x0F60


#define IOCTL_IR_GET_DEV_CAPS           CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 1,                    \
                                                 METHOD_BUFFERED,      \
                                                 FILE_READ_ACCESS)
/*++
    
    IOCTL_IR_GET_DEVCAPS

    Returns device capabilities.  For legacy devices, the Capabilities 
    registry entry can be used to populate this structure.  For new devices, 
    the implementation is left as an exercise for the reader.

    Parameters:

    lpInBuffer      - pointer to caller-allocated IR_DEV_CAPS structure

    nInBufferSize   - sizeof (IR_DEV_CAPS)

--*/

typedef struct _IR_DEV_CAPS {

    //
    // Protocol version.  Currently must be 100 (1.0)
    //
	OUT ULONG_PTR ProtocolVersion;	
    //
    // Number of transmit ports - 0-32
    //
	OUT ULONG_PTR NumTransmitPorts;	

    //
    // Number of receive ports - 0-32 (for snowflake, 
    // this would be one.  For beanbag, this would be 
    // two (one for learning, one for normal)
    //
    OUT ULONG_PTR NumReceivePorts;    

    //
    // Bitmask identifying which receivers are 
    // learning receivers - low bit is the first 
    // receiver, second-low bit is the second receiver, 
    // etc	
    //
    OUT ULONG_PTR LearningReceiverMask; 

    //
    // Flags
    //
	OUT ULONG_PTR DevCapsFlags; 

}IR_DEV_CAPS, *PIR_DEV_CAPS;

#define DEV_CAPS_PROTOCOL_VERSION        0x100

#define DEV_CAPS_SUPPORTS_LEGACY_SIGNING 0x1
#define DEV_CAPS_HAS_UNIQUE_SERIAL       0x2
#define DEV_CAPS_CAN_FLASH_RECEIVER_LED  0x4
#define DEV_CAPS_IS_LEGACY               0x8


#define IOCTL_IR_GET_EMITTERS           CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 2,                    \
                                                 METHOD_BUFFERED,      \
                                                 FILE_READ_ACCESS)
/*++

    IOCTL_IR_GET_EMITTERS

    Gets attached emitters and returns the information in a bitmask.  
    Information returned in lpOutBuffer.

    Parameters:

    lpOutBuffer      - pointer to caller-allocated buffer sizeof(ULONG)

    nOutBufferSize   - sizeof(ULONG)

--*/


#define IOCTL_IR_FLASH_RECEIVER           CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 3,                      \
                                                 METHOD_BUFFERED,        \
                                                 FILE_WRITE_ACCESS)
/*++

    IOCTL_IR_FLASH_RECEIVER

    Flash an LED on the given receiver.  Used to tell the user where to point 
    their remote, so a given "receiver box" with multiple receiver parts only 
    needs one LED to flash.

    Parameters:

    lpInBuffer      - pointer to caller-allocated buffer sizeof(ULONG) with 
                      bitmask of receivers to flash

    nInBufferSize   - sizeof(ULONG)

--*/


#define IOCTL_IR_RESET_DEVICE           CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 4,                    \
                                                 METHOD_BUFFERED,      \
                                                 FILE_WRITE_ACCESS)

/*++

    IOCTL_IR_RESET_DEVICE
    
    Resets the given device.  When a device is reset, all pending transmit and 
    receive IOCTLs are cancelled by the class driver

    Parameters:

--*/



#define IOCTL_IR_TRANSMIT           CTL_CODE(FILE_DEVICE_IRCLASS,    \
                                                 5,                  \
                                                 METHOD_IN_DIRECT,  \
                                                 FILE_WRITE_ACCESS)

/*++

    IOCTL_IR_TRANSMIT


    Transmits the given IR stream on the given port(s) at the given carrier 
    frequency. On legacy devices, this maintains the pre-existing carrier 
    frequency, port masks, and sample period values.  (ie. it gets the old 
    values, changes them, transmits, and then changes them back.)

    This IOCTL is synchronous.  It does not return until the IR has actually 
    been transmitted.

    Parameters:

    lpInBuffer      - pointer to caller-allocated IR_TRANSMIT_PARAMS structure

    nInBufferSize   - sizeof(IR_TRANSMIT_PARAMS)

    lpOutBuffer     - pointer to caller-allocated IR_TRANSMIT_CHUNCK that contains
                      the data to be transmitted

    nOutBufferSize  - size of caller-allocated buffer. 

--*/


typedef struct _IR_TRANSMIT_PARAMS {

    //
    // Bitmask containing ports to transmit on.
    //
	IN ULONG_PTR TransmitPortMask;

    //
    // Carrier period to use.  If zero, Flags 
    // needs to define DC mode or pulse mode.
    //
	IN ULONG_PTR CarrierPeriod;

    //
    // Flags 
    //
	IN ULONG_PTR Flags;			

    //
    // If pulse mode is set, this contains the length of pulse
    // to use.
    //
	IN ULONG_PTR PulseSize;			
						
} IR_TRANSMIT_PARAMS, *PIR_TRANSMIT_PARAMS;

#define TRANSMIT_FLAGS_PULSE_MODE 0x0001
#define TRANSMIT_FLAGS_DC_MODE    0x0002

typedef struct _IR_TRANSMIT_CHUNK {

    //
    // offset, in bytes, from Data member of this buffer to next 
    //   IR_TRANSMIT_CHUNK (or zero if no more chunks in buffer)
    //
    ULONG_PTR    OffsetToNextChunk;

    //
    // number of times to serially repeat "ByteCount" bytes of data
    //
    ULONG_PTR    RepeatCount;   

    //
    // count of data bytes to be sent
    //
    ULONG_PTR    ByteCount;         

    //
    // First byte of "ByteCount" bytes of data. 
    //   Note: Each chunk is filled to integral ULONG_PTR boundary
    //
    LONG        Data[1];

} IR_TRANSMIT_CHUNK, *PIR_TRANSMIT_CHUNK;


#define IOCTL_IR_RECEIVE           CTL_CODE(FILE_DEVICE_IRCLASS,    \
                                                 6,                 \
                                                 METHOD_OUT_DIRECT,  \
                                                 FILE_READ_ACCESS)


/*++

    IOCTL_IR_RECEIVE

    Receives IR.  Does not return until IR is available.  If there is more IR 
    data available than space in the buffer, IrReceiveParms->fMore is set to 
    TRUE.  The provided timeout is used to define the end of a keypress.  So, 
    once the driver starts receiving IR from the hardware, it will continue to 
    add it to the buffer until the specified time passes with no IR.

    Parameters:

    lpOutBuffer      - pointer to caller-allocated IR_RECEIVE_PARAMS structure

    nOutBufferSize   - sizeof(IR_RECEIVE_PARAMS)

--*/
typedef struct _IR_RECEIVE_PARAMS {

    //
    // Does this receive represent a data end event?
    //
    OUT ULONG_PTR DataEnd;

    //
    // Size of the data buffer
    //
    IN  ULONG_PTR ByteCount;

    //
    // The data buffer itself.
    //
    OUT LONG     Data[1];

}IR_RECEIVE_PARAMS, *PIR_RECEIVE_PARAMS;


#define IOCTL_IR_PRIORITY_RECEIVE           CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 8,                   \
                                                 METHOD_OUT_DIRECT,    \
                                                 FILE_READ_ACCESS)

typedef struct _IR_PRIORITY_RECEIVE_PARAMS {

    //
    // Does this receive represent a data end event?
    //
    OUT ULONG_PTR DataEnd;

    //
    // Size of the data buffer
    //
    IN  ULONG_PTR ByteCount;

    //
    // Carrier frequency (only valid if DataEnd != 0)
    //
    OUT ULONG_PTR CarrierFrequency;

    //
    // The data buffer itself.
    //
    IN  LONG     Data[1];

}IR_PRIORITY_RECEIVE_PARAMS, *PIR_PRIORITY_RECEIVE_PARAMS;



#define IOCTL_IR_HANDSHAKE             CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 9,                   \
                                                 METHOD_BUFFERED,     \
                                                 FILE_ANY_ACCESS)

#define IOCTL_IR_ENTER_PRIORITY_RECEIVE        CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 10,                  \
                                                 METHOD_BUFFERED,     \
                                                 FILE_WRITE_ACCESS)

typedef struct _IOCTL_IR_ENTER_PRIORITY_RECEIVE_PARAMS {

    //
    // Index of the receiver to use
    //
    IN ULONG_PTR  Receiver;	
    
    //
    // Timeout value, in micsec.  Used to define 
    // the end of a given sample.
    //
    IN ULONG_PTR  TimeOut;
    
}IOCTL_IR_ENTER_PRIORITY_RECEIVE_PARAMS, *PIOCTL_IR_ENTER_PRIORITY_RECEIVE_PARAMS;


#define IOCTL_IR_EXIT_PRIORITY_RECEIVE         CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 11,                  \
                                                 METHOD_BUFFERED,     \
                                                 FILE_WRITE_ACCESS)

#define IOCTL_IR_USER_OPEN             CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 12,                  \
                                                 METHOD_BUFFERED,     \
                                                 FILE_WRITE_ACCESS)


#define IOCTL_IR_USER_CLOSE            CTL_CODE(FILE_DEVICE_IRCLASS,  \
                                                 13,                  \
                                                 METHOD_BUFFERED,     \
                                                 FILE_WRITE_ACCESS)

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#endif // __IRCLASS_IOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsidef.h ===
#ifndef _iscsidef_h_
#define _iscsidef_h_

// ISCSI_IP_Address - ISCSI_IP_Address


//***************************************************************************
//
//  iscsidef.h
// 
//  Module: iScsi Discovery api
//
//  Purpose: Internal header defining interface between user mode discovery
//           api dll and HBA driver miniport.
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

//
// Definitions for iscsi security flags. These flags provide
// information about the security expectations of a target portal and
// are needed to insure a successful IKE/IPSEC negotiation. Note that
// the flags and values are taken directly from the iSNS spec
//

    // 1 = Tunnel Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    0x00000040

    // 1 = Transport Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED 0x00000020
               
    // 1 = PFS Enabled; 0 = PFS Disabled
#define ISCSI_SECURITY_FLAG_PFS_ENABLED              0x00000010
               
    // 1 = Aggressive Mode Enabled; 0 = Disabled
#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  0x00000008
               
    // 1 = Main Mode Enabled; 0 = MM Disabled
#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        0x00000004
               
    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled
#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        0x00000002

    // If set then all other ISCSI_SECURITY_FLAGS are valid                
#define ISCSI_SECURITY_FLAG_VALID                    0x00000001                


//
// Types of addresses that can be passed by management app to driver
//
typedef enum {
           // Text based host name. This needs to be resolved to binary form
    ISCSI_IP_ADDRESS_TEXT = 0,
           // Binary IPv4 address
    ISCSI_IP_ADDRESS_IPV4 = 1,
           // Binary IPv6 address
    ISCSI_IP_ADDRESS_IPV6 = 2,
           // Empty address
    ISCSI_IP_ADDRESS_EMPTY = 3
} ISCSIIPADDRESSTYPE, *PISCSIIPADDRESSTYPE;

#define ISCSI_IP_AddressGuid \
    { 0x9ac5d4a1,0x1a1a,0x48ec, { 0x8e,0x79,0x73,0x58,0x06,0xe9,0xa1,0xfa } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_IP_Address_GUID, \
            0x9ac5d4a1,0x1a1a,0x48ec,0x8e,0x79,0x73,0x58,0x06,0xe9,0xa1,0xfa);
#endif


typedef struct _ISCSI_IP_Address
{
    // Type of address specified. It can be text: a DNS or dotted address or it can be a binary ipv4 or ipv6 address
    ULONG Type;
    #define ISCSI_IP_Address_Type_SIZE sizeof(ULONG)
    #define ISCSI_IP_Address_Type_ID 1

    // If IPV4 Address is specified as the Address Format then this conains the binary IPv4 ip address
    ULONG IpV4Address;
    #define ISCSI_IP_Address_IpV4Address_SIZE sizeof(ULONG)
    #define ISCSI_IP_Address_IpV4Address_ID 2

    // If IPV6 Address is specified as the Address Format then this conains the binary IPv6 ip address
    UCHAR IpV6Address[16];
    #define ISCSI_IP_Address_IpV6Address_SIZE sizeof(UCHAR[16])
    #define ISCSI_IP_Address_IpV6Address_ID 3

    // IPV6 flow information
    ULONG IpV6FlowInfo;
    #define ISCSI_IP_Address_IpV6FlowInfo_SIZE sizeof(ULONG)
    #define ISCSI_IP_Address_IpV6FlowInfo_ID 4

    // IPV6 scope id
    ULONG IpV6ScopeId;
    #define ISCSI_IP_Address_IpV6ScopeId_SIZE sizeof(ULONG)
    #define ISCSI_IP_Address_IpV6ScopeId_ID 5

    // Text address, either a DNS address or dotted address
    WCHAR TextAddress[256 + 1];
    #define ISCSI_IP_Address_TextAddress_ID 6

} ISCSI_IP_Address, *PISCSI_IP_Address;

// ISCSI_TargetPortal - ISCSI_TargetPortal
// ISCSI target portal
#define ISCSI_TargetPortalGuid \
    { 0xde5051a7,0xbf27,0x48f1, { 0xbd,0x12,0x07,0xca,0xde,0x92,0xae,0xfd } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_TargetPortal_GUID, \
            0xde5051a7,0xbf27,0x48f1,0xbd,0x12,0x07,0xca,0xde,0x92,0xae,0xfd);
#endif


typedef struct _ISCSI_TargetPortal
{
    // Network Address
    ISCSI_IP_Address Address;
    #define ISCSI_TargetPortal_Address_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_TargetPortal_Address_ID 1

    // Reserved
    ULONG Reserved;
    #define ISCSI_TargetPortal_Reserved_SIZE sizeof(ULONG)
    #define ISCSI_TargetPortal_Reserved_ID 2

    // Socket number
    USHORT Socket;
    #define ISCSI_TargetPortal_Socket_SIZE sizeof(USHORT)
    #define ISCSI_TargetPortal_Socket_ID 3

} ISCSI_TargetPortal, *PISCSI_TargetPortal;

#define ISCSI_TargetPortal_SIZE (FIELD_OFFSET(ISCSI_TargetPortal, Socket) + ISCSI_TargetPortal_Socket_SIZE)

// ISCSI_TargetPortalGroup - ISCSI_TargetPortalGroup
// iSCSI target portal group
#define ISCSI_TargetPortalGroupGuid \
    { 0x3081f2a5,0x95f5,0x4d2a, { 0x81,0x3d,0xee,0x59,0x86,0x4c,0x6f,0xc5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_TargetPortalGroup_GUID, \
            0x3081f2a5,0x95f5,0x4d2a,0x81,0x3d,0xee,0x59,0x86,0x4c,0x6f,0xc5);
#endif


typedef struct _ISCSI_TargetPortalGroup
{
    // Number of portals in group
    ULONG PortalCount;
    #define ISCSI_TargetPortalGroup_PortalCount_SIZE sizeof(ULONG)
    #define ISCSI_TargetPortalGroup_PortalCount_ID 1

    // Target portals in group
    ISCSI_TargetPortal Portals[1];
    #define ISCSI_TargetPortalGroup_Portals_ID 2

} ISCSI_TargetPortalGroup, *PISCSI_TargetPortalGroup;

// ISCSI_LoginOptions - ISCSI_LoginOptions
// These are options that can be used for logging into a target

#ifndef _ISCSI_ISCSIDSC_
typedef enum
{
   ISCSI_DIGEST_TYPE_NONE = 0,
   ISCSI_DIGEST_TYPE_CRC32C = 1
} ISCSI_DIGEST_TYPES, *PISCSI_DIGEST_TYPES;

typedef enum
{
   ISCSI_NO_AUTH_TYPE = 0,
   ISCSI_CHAP_AUTH_TYPE = 1,
   ISCSI_MUTUAL_CHAP_AUTH_TYPE = 2 
} ISCSI_AUTH_TYPES, *PISCSI_AUTH_TYPES;
#endif

#define ISCSI_LoginOptionsGuid \
    { 0x3011a7bd,0x0491,0x478e, { 0x8c,0x79,0x3c,0x76,0x42,0x4d,0x05,0xe2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_LoginOptions_GUID, \
            0x3011a7bd,0x0491,0x478e,0x8c,0x79,0x3c,0x76,0x42,0x4d,0x05,0xe2);
#endif


typedef struct _ISCSI_LoginOptions
{

//
// Bit flags for InformationSpecifies
//
#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               0x00000001
#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 0x00000002
#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         0x00000004
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         0x00000008
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       0x00000010
#define ISCSI_LOGIN_OPTIONS_USERNAME                    0x00000020
#define ISCSI_LOGIN_OPTIONS_PASSWORD                    0x00000040
#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   0x00000080


    // Bit flags that specify which login option values are specified
    ULONG InformationSpecified;
    #define ISCSI_LoginOptions_InformationSpecified_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_InformationSpecified_ID 1

    // cyclic integrity checksums that can be negotiated for the header digests
    ULONG HeaderDigest;
    #define ISCSI_LoginOptions_HeaderDigest_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_HeaderDigest_ID 2

    // cyclic integrity checksums that can be negotiated for the header digests
    ULONG DataDigest;
    #define ISCSI_LoginOptions_DataDigest_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_DataDigest_ID 3

    // Maximum number of connections, 0 implies no limit
    ULONG MaximumConnections;
    #define ISCSI_LoginOptions_MaximumConnections_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_MaximumConnections_ID 4

    // The initiator and target negotiate the minimum time, in seconds, to wait before attempting an explicit/implicit logout or active task reassignment after an unexpected connection termination or a connection reset.
    ULONG DefaultTime2Wait;
    #define ISCSI_LoginOptions_DefaultTime2Wait_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_DefaultTime2Wait_ID 5

    //  The initiator and target negotiate the maximum time, in seconds after an initial wait (Time2Wait), before which an explicit/implicit connection Logout or active task reassignment is still possible after an unexpected connection termination or a connection reset.
    ULONG DefaultTime2Retain;
    #define ISCSI_LoginOptions_DefaultTime2Retain_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_DefaultTime2Retain_ID 6


//
// bit flags for ISCSI_LOGIN_FLAGS
//
#ifndef _ISCSI_ISCSIDSC_
#define ISCSI_LOGIN_FLAGS ULONG

#define ISCSI_LOGIN_FLAG_REQUIRE_IPSEC                0x00000001
#define ISCSI_LOGIN_FLAG_MULTIPATH_ENABLED            0x00000002
#define ISCSI_LOGIN_FLAG_RESERVED1                    0x00000004
#define ISCSI_LOGIN_FLAG_ALLOW_PORTAL_HOPPING         0x00000008
#define ISCSI_LOGIN_FLAG_USE_RADIUS_RESPONSE          0x00000010
#define ISCSI_LOGIN_FLAG_USE_RADIUS_VERIFICATION          0x00000020

#endif

    // Flags that affect how login occurs
    ULONG LoginFlags;
    #define ISCSI_LoginOptions_LoginFlags_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_LoginFlags_ID 7

    // Authentication method specified for login
    ULONG AuthType;
    #define ISCSI_LoginOptions_AuthType_SIZE sizeof(ULONG)
    #define ISCSI_LoginOptions_AuthType_ID 8

} ISCSI_LoginOptions, *PISCSI_LoginOptions;

#define ISCSI_LoginOptions_SIZE (FIELD_OFFSET(ISCSI_LoginOptions, AuthType) + ISCSI_LoginOptions_AuthType_SIZE)

// ISCSI_LUNList - ISCSI_LUNList
// This class describes a mapping from a an OS LUN to target device LUN
#define ISCSI_LUNListGuid \
    { 0x994ff278,0x3512,0x4d9b, { 0xa2,0x41,0x54,0xce,0xf4,0x5f,0x5a,0x25 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_LUNList_GUID, \
            0x994ff278,0x3512,0x4d9b,0xa2,0x41,0x54,0xce,0xf4,0x5f,0x5a,0x25);
#endif


typedef struct _ISCSI_LUNList
{
    // Target LUN
    ULONGLONG TargetLUN;
    #define ISCSI_LUNList_TargetLUN_SIZE sizeof(ULONGLONG)
    #define ISCSI_LUNList_TargetLUN_ID 1

    // OS Scsi bus number target is mapped to
    ULONG OSLUN;
    #define ISCSI_LUNList_OSLUN_SIZE sizeof(ULONG)
    #define ISCSI_LUNList_OSLUN_ID 2

    // Reserved
    ULONG Reserved;
    #define ISCSI_LUNList_Reserved_SIZE sizeof(ULONG)
    #define ISCSI_LUNList_Reserved_ID 3

} ISCSI_LUNList, *PISCSI_LUNList;

#define ISCSI_LUNList_SIZE (FIELD_OFFSET(ISCSI_LUNList, Reserved) + ISCSI_LUNList_Reserved_SIZE)

// ISCSI_TargetMapping - ISCSI_TargetMapping
// This class describes a mapping from a target LUN to a Windows port driver LUN
#define ISCSI_TargetMappingGuid \
    { 0x21a28820,0x3c4c,0x4944, { 0xac,0x4f,0xda,0x7f,0xeb,0xa2,0x11,0x68 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_TargetMapping_GUID, \
            0x21a28820,0x3c4c,0x4944,0xac,0x4f,0xda,0x7f,0xeb,0xa2,0x11,0x68);
#endif


typedef struct _ISCSI_TargetMapping
{
    // OS Scsi bus number target is mapped to. If 0xffffffff then any value can be picked by the miniport.
    ULONG OSBus;
    #define ISCSI_TargetMapping_OSBus_SIZE sizeof(ULONG)
    #define ISCSI_TargetMapping_OSBus_ID 1

    // OS Scsi Target number target is mapped to. If 0xffffffff then any value can be picked by the miniport.
    ULONG OSTarget;
    #define ISCSI_TargetMapping_OSTarget_SIZE sizeof(ULONG)
    #define ISCSI_TargetMapping_OSTarget_ID 2

    // Unique Session ID for the target mapping
    ULONGLONG UniqueSessionId;
    #define ISCSI_TargetMapping_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_TargetMapping_UniqueSessionId_ID 3

    // Count of LUNs mapped for this target
    ULONG LUNCount;
    #define ISCSI_TargetMapping_LUNCount_SIZE sizeof(ULONG)
    #define ISCSI_TargetMapping_LUNCount_ID 4

    // Target Name
    WCHAR TargetName[223 + 1];
    #define ISCSI_TargetMapping_TargetName_ID 5

    // TRUE if session created from a persistent login
    BOOLEAN FromPersistentLogin;
    #define ISCSI_TargetMapping_FromPersistentLogin_SIZE sizeof(BOOLEAN)
    #define ISCSI_TargetMapping_FromPersistentLogin_ID 6

    // Reserved
    ULONGLONG Reserved;
    #define ISCSI_TargetMapping_Reserved_SIZE sizeof(ULONGLONG)
    #define ISCSI_TargetMapping_Reserved_ID 7

    // List of LUNs mapped for this target
    ISCSI_LUNList LUNList[1];
    #define ISCSI_TargetMapping_LUNList_ID 8

} ISCSI_TargetMapping, *PISCSI_TargetMapping;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\irb.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    irb.h

Abstract:

    Defines the interface between the Ataport and the ATA miniport drivers.

Authors:

Revision History:

--*/

#if (NTDDI_VERSION >= NTDDI_VISTA)

#ifndef _NTIRB_
#define _NTIRB_

#ifdef __cplusplus
extern "C"
{
#endif

//
// pre-defined channel numbers for P-ATA
//
#define PRIMARY_CHANNEL_NUMBER      0
#define SECONDARY_CHANNEL_NUMBER    1

//
// max number of devices per channel for P-ATA
//
#define MAX_IDE_DEVICE  2

#define MAX_IDE_LUN     8

#define IDE_UNTAGGED  0xFF
#define IDE_UNINITIALIZED_VALUE (-1)

#define IDE_REG_SZ          (1)
#define IDE_REG_BINARY      (3)
#define IDE_REG_DWORD       (4)

typedef PHYSICAL_ADDRESS IDE_PHYSICAL_ADDRESS, *PIDE_PHYSICAL_ADDRESS;

#undef TraceNotification
#define TraceNotification 0

#ifndef _NTDDSCSIH_

//
// Miniport ioctl header
//
typedef struct _IDE_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnStatus;
        ULONG DataLength;
} IDE_IO_CONTROL, *PIDE_IO_CONTROL;
#endif

//
// Notification Event Types
//
typedef enum _IDE_NOTIFICATION_TYPE {
    IdeDeviceArrival,
    IdeDeviceRemoval,
    IdePowerStateChange
} IDE_NOTIFICATION_TYPE, *PIDE_NOTIFICATION_TYPE;

//
// Callback types supported by the port driver
//
typedef enum _IDE_CALLBACK_TYPE {
    IdeTimerRoutine,
    IdeWorkerRoutine,
    IdeSynchronizedRoutine,
    IdeControllerSyncRoutine,
    IdeMaxCallbackType
} IDE_CALLBACK_TYPE, *PIDE_CALLBACK_TYPE;

//
// Device type
//
typedef enum  {
    DeviceUnknown = 0,
    DeviceIsAta,
    DeviceIsAtapi,
    DeviceNotExist
} IDE_DEVICE_TYPE;

//
// addressing mode
//
typedef enum {
    UnknownMode = 0,
    ChsMode,
    LbaMode,
    Lba48BitMode
}ATA_ADDRESS_TRANSLATION;

//
// control action for ChannelControl
//
typedef enum {
    IdeStart = 0,
    IdeStop,
    IdePowerUp,
    IdePowerDown
} IDE_CONTROL_ACTION;

//
// device power states
//
typedef enum {
    IdePowerUnSpecified = 0,
    IdePowerD0, 
    IdePowerD3
} IDE_POWER_STATE;

//
// SenseInfoBuffer return types
//
#define    SENSE_INFO_BUFFER_RETURN_TYPE_CDB             0
#define    SENSE_INFO_BUFFER_RETURN_TYPE_28BIT_TASKFILE  1
#define    SENSE_INFO_BUFFER_RETURN_TYPE_48BIT_TASKFILE  2
#define    SENSE_INFO_BUFFER_RETURN_TYPE_D2H_FIS         3

//
// power transition information
// defines a transition from 
// currentPowerState -> DesiredPowerState
//
typedef struct _IDE_POWER_INFO {
    IDE_POWER_STATE CurrentPowerState;
    IDE_POWER_STATE DesiredPowerState;
} IDE_POWER_INFO, *PIDE_POWER_INFO;

//
// task file register contents
//
typedef struct _IDEREGISTERS {

    //
    // ATA features/error register
    //
    UCHAR bFeaturesReg;

    //
    // sector count
    //
    UCHAR bSectorCountReg;

    //
    // block number (7:0)
    //
    UCHAR bSectorNumberReg;

    //
    // cylinder number (7:0) or LBA (15:8) 
    //
    UCHAR bCylLowReg;

    //
    // cylinder number (15:8) or LBA (23:16) 
    //
    UCHAR bCylHighReg;

    //
    // device/Head and LBA (27:24)
    //
    UCHAR bDriveHeadReg;

    //
    // command/status register
    //
    UCHAR bCommandReg;

    //
    // Reserved for future use. Shall be 0
    //
    UCHAR bReserved;

} IDEREGISTERS, *PIDEREGISTERS;

//
// task file (to hold 48 bit)
//
typedef struct _IDE_TASK_FILE {
    IDEREGISTERS Current;
    IDEREGISTERS Previous;
} IDE_TASK_FILE, *PIDE_TASK_FILE;

typedef UCHAR IRB_STATUS;

//
// irb
//
typedef struct _IDE_REQUEST_BLOCK {

    //
    // IRB_FUNCTION_XXX
    //
    USHORT Function;

    //
    // IRB_STATUS_XXX
    //
    UCHAR IrbStatus;

    //
    // contents of the status and error registers
    // at the completion of the command
    //
    UCHAR AtaStatus;
    UCHAR AtaError;

    //
    // channel, target and lun ids uniquely identify the target device
    //
    UCHAR Channel;
    UCHAR TargetId;
    UCHAR Lun;
    //
    // Length of the actual CDB in the Cdb[16] array
    //
    UCHAR CdbLength;   
    
    //
    // sense info buffer length
    //
    UCHAR SenseInfoBufferLength;    

    //
    // Type of data structure returned in the SenseInfoBuffer
    //
    UCHAR SenseInfoBufferType;       

    //
    // holds the queue tag
    //
    UCHAR QueueTag;

    ULONG ReservedAsUlong;
    
    //
    // Irb Flags
    //
    ULONG IrbFlags;                 

    //
    // timeout
    //
    ULONG TimeOutValue;             

    //
    // data transfer length
    //
    ULONG DataTransferLength;       

    //
    // irb extension
    //
    PVOID IrbExtension;

    //
    // data buffer
    //
    PVOID DataBuffer;               

    //
    // sense buffer
    //
    PVOID SenseInfoBuffer;          

    //
    // Used for queueing irbs
    //
    PVOID NextIrb;

    //
    // For future use (shall be set to NULL)
    //
    PVOID Reserved;

    //
    // task file for ATA devices    or 
    // CDB for ATAPI devices        or
    // power transition information or
    // an array of chars
    // (determined by IrbFunction)
    //
    union {

        //
        // ATA Task file register contents
        //
        IDE_TASK_FILE IdeTaskFile;

        //
        // CDB for ATAPI devices
        //
        UCHAR Cdb[16];

        //
        // power transitition information
        //
        IDE_POWER_INFO PowerChange;

        //
        // array of 16 uchars
        //
        UCHAR AsUChar[16];
    };

} IDE_REQUEST_BLOCK, *PIDE_REQUEST_BLOCK;

//
// irb status
//
#define IRB_STATUS_PENDING              0x0
#define IRB_STATUS_SUCCESS              0x1
#define IRB_STATUS_DATALENGTH_MISMATCH  0x2
#define IRB_STATUS_DEVICE_ERROR         0x3
#define IRB_STATUS_INVALID_REQUEST      0x4
#define IRB_STATUS_BUS_RESET            0x5
#define IRB_STATUS_SELECTION_TIMEOUT    0x6
#define IRB_STATUS_BUSY                 0x7

//
// bit to indicate the SenseInfoBuffer holds a valid Task File
//
#define IRB_STATUS_RETURN_TASKFILE_VALID      0x10

//
// bit mask to indicate valid sense info
//
#define IRB_STATUS_AUTOSENSE_VALID      0x20

//
// 0x40 and above are reserved for the port driver
//
#define IRB_STATUS_INTERNAL_ERROR       0x40

//
// irb function
//

//
// 0x100 - 0x1FF indicate ATA commands
//
#define IRB_FUNCTION_ATA_COMMAND        0x100
#define IRB_FUNCTION_ATA_IDENTIFY       0x101
#define IRB_FUNCTION_ATA_READ           0x102
#define IRB_FUNCTION_ATA_WRITE          0x103
#define IRB_FUNCTION_ATA_FLUSH          0x104
#define IRB_FUNCTION_ATA_SMART          0x105

//
// 0x200 - 0x2FF indicate ATAPI commands
//
#define IRB_FUNCTION_ATAPI_COMMAND      0x200
#define IRB_FUNCTION_REQUEST_SENSE      0x201 

//
// 0x400-0x4FF indicate miniport commands
//
#define IRB_FUNCTION_MINIPORT_COMMAND   0x400
#define IRB_FUNCTION_ADAPTER_FLUSH      0x401
#define IRB_FUNCTION_SHUTDOWN           0x402
#define IRB_FUNCTION_POWER_CHANGE       0x403
#define IRB_FUNCTION_LUN_RESET          0x404
#define IRB_FUNCTION_MINIPORT_IOCTL     0x405

//
// irb flags
//
#define IRB_FLAGS_DRDY_REQUIRED         0x1
#define IRB_FLAGS_USE_DMA               0x2
#define IRB_FLAGS_MAP_BUFFERS           0x4
#define IRB_FLAGS_48BIT                 0x8
#define IRB_FLAGS_PIO_MULTIPLE			0x10
#define IRB_FLAGS_RETURN_RESULTS        0x20
#define IRB_FLAGS_DATA_IN               0x40
#define IRB_FLAGS_DATA_OUT              0x80
#define IRB_FLAGS_DISCARDABLE           0x100
#define IRB_FLAGS_HIGH_PRIORITY         0x200

//
// helper macros
//
#define IsAtapiCommand(irb)     (irb->Function & IRB_FUNCTION_ATAPI_COMMAND)
#define IsAtaCommand(irb)       (irb->Function & IRB_FUNCTION_ATA_COMMAND)
#define IsMiniportCommand(irb)  (irb->Function & IRB_FUNCTION_MINIPORT_COMMAND)
#define IsRequestSenseIrb(irb)  (irb->Function == IRB_FUNCTION_REQUEST_SENSE)
#define IsReturnResults(irb)    (irb->IrbFlags & IRB_FLAGS_RETURN_RESULTS)

#define NeedRequestSense(irb) \
    (IsAtapiCommand(irb) && \
     !IsRequestSenseIrb(irb) && \
     (irb->IrbStatus == IRB_STATUS_DEVICE_ERROR) && \
     (irb->SenseInfoBuffer != NULL) && \
     (irb->SenseInfoBufferLength > 0))

#define Is48BitIrb(irb)         (irb->IrbFlags & IRB_FLAGS_48BIT)
#define IsPioMultipleIrb(irb)	(irb->IrbFlags & IRB_FLAGS_PIO_MULTIPLE)
#define IsHighPriorityIrb(irb)  (irb->IrbFlags & IRB_FLAGS_HIGH_PRIORITY)

#define IRB_USES_DMA(irb)       (irb->IrbFlags & IRB_FLAGS_USE_DMA)

#define MARK_IRB_FOR_DMA(irb)   (irb->IrbFlags |= IRB_FLAGS_USE_DMA)
#define MARK_IRB_FOR_PIO(irb)   (irb->IrbFlags &= ~IRB_FLAGS_USE_DMA)

#define IRB_FOR_DATA_TRANSFER(irb) \
    (irb->IrbFlags & (IRB_FLAGS_DATA_IN | IRB_FLAGS_DATA_OUT))
    

#define GET_IRB_CURRENT_REG(irb)        (&((irb->IdeTaskFile).Current))
#define GET_IRB_PREVIOUS_REG(irb)       (&((irb->IdeTaskFile).Previous))

#define GET_CURRENT_REG(taskFile)       (&(taskFile)->Current)
#define GET_PREVIOUS_REG(taskFile)      (&(taskFile)->Previous)

#define GetIrbErrorReg(irb) (irb->AtaError)
#define GetIrbStatusReg(irb) (irb->AtaStatus)
#define SetIrbCommandReg(irb, cmd) (irb->IdeTaskFile.Current.bCommandReg=cmd)

//
// TargetId >= 1 implies slave device
//
#define SetIrbDeviceReg(irb, val) \
    (irb->IdeTaskFile.Current.bDriveHeadReg = ((irb->TargetId == 0x0) ? (0xA0 | val) : (0xB0 | val)))

//
// algorithm used by the port driver to set the irbFunction
// for an ATA command
//
#define IdeMapAtaCommandToIrbFunction(AtaCommand, irbFunc) \
{ \
    switch (AtaCommand) { \
    case IDE_COMMAND_IDENTIFY: \
    case IDE_COMMAND_ATAPI_IDENTIFY: \
        irbFunc = IRB_FUNCTION_ATA_IDENTIFY; \
        break; \
    case IDE_COMMAND_READ: \
    case IDE_COMMAND_READ_MULTIPLE: \
    case IDE_COMMAND_READ_DMA: \
    case IDE_COMMAND_READ_EXT: \
    case IDE_COMMAND_READ_DMA_EXT: \
    case IDE_COMMAND_READ_MULTIPLE_EXT: \
        irbFunc = IRB_FUNCTION_ATA_READ; \
        break; \
    case IDE_COMMAND_WRITE: \
    case IDE_COMMAND_WRITE_MULTIPLE: \
    case IDE_COMMAND_WRITE_DMA: \
    case IDE_COMMAND_WRITE_EXT: \
    case IDE_COMMAND_WRITE_DMA_EXT: \
    case IDE_COMMAND_WRITE_DMA_FUA_EXT: \
    case IDE_COMMAND_WRITE_MULTIPLE_EXT: \
    case IDE_COMMAND_WRITE_MULTIPLE_FUA_EXT: \
        irbFunc = IRB_FUNCTION_ATA_WRITE; \
        break; \
    case IDE_COMMAND_CHECK_POWER: \
    case IDE_COMMAND_FLUSH_CACHE: \
    case IDE_COMMAND_FLUSH_CACHE_EXT: \
        irbFunc = IRB_FUNCTION_ATA_FLUSH;\
        break; \
    case IDE_COMMAND_SMART: \
        irbFunc = IRB_FUNCTION_ATA_SMART; \
        break;\
    default:\
        irbFunc = IRB_FUNCTION_ATA_COMMAND;\
        break;\
    } \
}

//
// scatter-gather list
//
typedef struct _IDE_SCATTER_GATHER_ELEMENT {
    IDE_PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} IDE_SCATTER_GATHER_ELEMENT, *PIDE_SCATTER_GATHER_ELEMENT;

#if defined(_MSC_VER) && (_MSC_VER >= 800)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union */
#endif

typedef struct _IDE_SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    IDE_SCATTER_GATHER_ELEMENT Elements[];
} IDE_SCATTER_GATHER_LIST, *PIDE_SCATTER_GATHER_LIST;

#if defined(_MSC_VER) && (_MSC_VER >= 800)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#else
#pragma warning(default:4200) /* nonstandard extension used : zero-sized array in struct/union */
#endif
#endif

//
// task file register addresses
//
typedef struct _IDE_REGISTERS_1 {
    PUCHAR RegistersBaseAddress;

    PUSHORT Data;

    union {
        PUCHAR Error;
        PUCHAR Features;
    };

    union {
        PUCHAR BlockCount;
        PUCHAR InterruptReason;
    };

    PUCHAR BlockNumber;

    union {
        PUCHAR CylinderLow;
        PUCHAR ByteCountLow;
    };

    union {
        PUCHAR CylinderHigh;
        PUCHAR ByteCountHigh;
    };

    PUCHAR DriveSelect;
    PUCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

//
// device control register addresses
//
typedef struct _IDE_REGISTERS_2 {
    PUCHAR RegistersBaseAddress;

    PUCHAR DeviceControl;
    PUCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

//
// access range that indicates the resources
//
typedef struct _IDE_ACCESS_RANGE {
    IDE_PHYSICAL_ADDRESS RangeStart;
    IDE_PHYSICAL_ADDRESS PhysicalRangeStart;
    ULONG            RangeLength;
    BOOLEAN          InMemory;
    UCHAR            Bar;
} IDE_ACCESS_RANGE, *PIDE_ACCESS_RANGE;

//
// the miniport's error log entry
//
typedef struct _IDE_ERROR_LOG_ENTRY {
    UCHAR IrbStatus;
    UCHAR Channel;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR UniqueId;
    UCHAR DumpDataSize;
    UCHAR DumpData[1];
} IDE_ERROR_LOG_ENTRY, *PIDE_ERROR_LOG_ENTRY;

//
// device characterstics flags
//

//
// Indicates that the drive has the 'removable' bit set in
// identify data (offset 128)
//
#define DFLAGS_REMOVABLE_MEDIA       (1 << 0)    
                                              
//
// Indicates whether device interrupts as DRQ is set after   
// receiving Atapi Packet Command
//
#define DFLAGS_INT_DRQ               (1 << 1)    
                                                 
//
// Device supports media status notification
//
#define DFLAGS_MSN_SUPPORT           (1 << 2)    


typedef struct _IDE_DEVICE_PARAMETERS {

    //
    // size of this structure
    //
    USHORT Version;

    //
    // device type (ata, atapi etc)
    //
    IDE_DEVICE_TYPE IdeDeviceType;

    //
    // target id
    //
    UCHAR TargetId;

    //
    // Number of Luns
    //
    UCHAR MaximumLun;

    //
    // number of requests the miniport can handle 
    // at a time for this device
    //
    UCHAR NumberOfOverlappedRequests;

    //
    // max number of blocks that can be transferred
    // using read/write multiple command
    //
    UCHAR MaxBlockXfer;

    //
    // device characteristics (removable etc)
    //
    USHORT DeviceCharacteristics;

    //
    // Geometry
    //
    ATA_ADDRESS_TRANSLATION AddressTranslation;

    union {
        LARGE_INTEGER MaxLba;
        struct {
            USHORT NumCylinders;
            USHORT NumHeads;
            USHORT NumSectorsPerTrack;
            USHORT Reserved;
        } Chs;
    };

    //
    // number of bytes per sector
    //
    ULONG BytesPerLogicalSector;

    //
    // number of bytes per sector
    //
    ULONG BytesPerPhysicalSector;
    
    //
    // number of bytes per sector
    //
    ULONG BytesOffsetForSectorAlignment;

    //
    // The transfer modes supported by this device
    //
    ULONG TransferModeSupported;

    //
    // The selected transfer mode for this device
    //
    ULONG TransferModeSelected;

} IDE_DEVICE_PARAMETERS, *PIDE_DEVICE_PARAMETERS;

typedef
BOOLEAN
(*IDE_HW_INITIALIZE) (
    __in PVOID ChannelExtension,
    IN OUT PIDE_DEVICE_PARAMETERS DeviceParameters,
    __in PIDENTIFY_DEVICE_DATA IdentifyData
    );

typedef
BOOLEAN
(*IDE_HW_STARTIO) (
    __in PVOID ChannelExtension,
    __in PIDE_REQUEST_BLOCK Irb
    );

typedef
BOOLEAN
(*IDE_HW_BUILDIO) (
    __in PVOID ChannelExtension,
    __in PIDE_REQUEST_BLOCK Irb
    );

typedef
BOOLEAN
(*IDE_HW_INTERRUPT) (
    __in PVOID ChannelExtension
    );

typedef
VOID
(*IDE_HW_DPC) (
    __in PVOID ChannelExtension
    );

typedef
BOOLEAN
(*IDE_HW_RESET) (
    __in PVOID ChannelExtension
    );

typedef
BOOLEAN
(*IDE_HW_CONTROL) (
    __in PVOID ChannelExtension,
    __in IDE_CONTROL_ACTION ControlAction,
    __inout_opt PVOID Parameters
    );

//
// Indicates the operation constraints
//
typedef enum _IDE_OPERATION_MODE {
    IdeModeNormal = 0,
    IdeModeDump,
    IdeModeRemovableBay
} IDE_OPERATION_MODE, *PIDE_OPERATION_MODE;

//
// miniport hardware resources
//
typedef struct _IDE_MINIPORT_RESOURCES{

    //
    // Number of access ranges
    //
    ULONG NumberOfAccessRanges;

    //
    // array of access range elements.
    //
    __inout_ecount(NumberOfAccessRanges)
    PIDE_ACCESS_RANGE IdeAccessRange;

} IDE_MINIPORT_RESOURCES, *PIDE_MINIPORT_RESOURCES;

typedef struct _IDE_CHANNEL_CONFIGURATION {

    //
    // Input parameters
    //

    //
    // IN only. version
    //
    USHORT Version;

    //
    // IN only. The channel number
    //
    UCHAR ChannelNumber;

    //
    // Reserved
    //
    USHORT Reserved;

    //
    // Operating mode
    //
    IDE_OPERATION_MODE ChannelMode;

    //
    // IN only field. Pointer to hardware resources
    //
    PIDE_MINIPORT_RESOURCES ChannelResources;

    //
    // Output parameters
    //

    //
    // Number of overlapped requests the channel can handle
    //
    UCHAR NumberOfOverlappedRequests;

    //
    // The maximum targetId. 
    // Typically (MaxNumDevices - 1)
    //
    UCHAR MaxTargetId;

    //
    // Always TRUE
    //
    BOOLEAN SyncWithIsr;

    //
    // Always TRUE
    //
    BOOLEAN SupportsWmi;

    //
    // Reserved
    //
    PVOID Reserved1;

} IDE_CHANNEL_CONFIGURATION, *PIDE_CHANNEL_CONFIGURATION;

typedef struct _IDE_CHANNEL_INTERFACE {

    //
    // Input parameters
    //
    
    //
    //  Size of this structure
    //
    USHORT Version;

    //
    // The channel number
    //
    UCHAR ChannelNumber;

    //
    //  Reserved for future use
    //
    UCHAR Reserved;

    //
    // Reserved
    //
    ULONG ReservedUlong;

    //
    // Output parameters
    //
    IDE_HW_INITIALIZE    IdeHwInitialize;
    IDE_HW_BUILDIO       IdeHwBuildIo;
    IDE_HW_STARTIO       IdeHwStartIo;
    IDE_HW_INTERRUPT     IdeHwInterrupt;
    IDE_HW_RESET         IdeHwReset;
    IDE_HW_CONTROL       IdeHwControl;

} IDE_CHANNEL_INTERFACE, *PIDE_CHANNEL_INTERFACE;

typedef BOOLEAN
    (* IDE_CHANNEL_INIT) (
        __in PVOID ChannelExtension,
        __inout PIDE_CHANNEL_INTERFACE ChannelInterface,
        __inout_opt PVOID InitContext
        );

typedef struct _IDE_TRANSFER_MODE_PARAMETERS {

    //
    // Input Parameters
    //          
          
    //
    // IDE Channel Number. 
    //                                       
    UCHAR ChannelNumber;

    //
    // Indicate whether devices are present
    //                                  
    IDE_DEVICE_TYPE DeviceType[MAX_IDE_DEVICE];
    
    //
    // Indicate whether devices support IO Ready Line
    //                                                
    BOOLEAN IoReadySupported[MAX_IDE_DEVICE];

    //
    // Indicate the data transfer modes devices support
    //               
    ULONG DeviceTransferModeSupported[MAX_IDE_DEVICE];

    //
    // Indicate devices' current data transfer modes
    //
    ULONG DeviceTransferModeCurrent[MAX_IDE_DEVICE];

    //
    // Output Parameters
    //          
                      
    //
    // Indicate devices' data transfer modes chosen by
    // the miniport 
    //
    ULONG DeviceTransferModeSelected[MAX_IDE_DEVICE];

} IDE_TRANSFER_MODE_PARAMETERS, *PIDE_TRANSFER_MODE_PARAMETERS;

typedef BOOLEAN
    (*IDE_TRANSFER_MODE_SELECT) (
        __in    PVOID ControllerExtension,
        __inout PIDE_TRANSFER_MODE_PARAMETERS TransferModeSelect
        );

//
// possible channel state
//         
typedef enum {
    ChannelStateDisabled = 0,
    ChannelStateEnabled,
    ChannelStateUnKnown
} ATA_CHANNEL_STATE;

typedef ATA_CHANNEL_STATE
    (*IDE_CHANNEL_ENABLED) (
        __in PVOID ControllerExtension,
        __in ULONG Channel
        );

typedef enum {
    IdeBusPata = 0,
    IdeBusSata,
    IdeBusUnknown
} IDE_BUS_TYPE, *PIDE_BUS_TYPE;

typedef struct _IDE_CONTROLLER_CONFIGURATION {

    //
    // size of this structure
    //
    USHORT Version;

    //
    // number of IDE channels
    //
    UCHAR NumberOfChannels;

    //
    // Operating mode
    //
    IDE_OPERATION_MODE ControllerMode;
    
    //
    // number of elements in the scatter gather list
    //
    UCHAR NumberOfPhysicalBreaks;

    //
    // maximum transfer bytes supported by the controller
    //
    ULONG MaximumTransferLength;

    //
    // Reserved for future use
    //
    BOOLEAN Reserved;

    //
    // TRUE if the controller is in native mode
    //
    BOOLEAN NativeModeEnabled;

    //
    // TRUE if the controller supports 64 bit DMA
    //
    BOOLEAN Dma64BitAddress;

    //
    // TRUE if the controller is a bus master
    //
    BOOLEAN BusMaster;

    //
    // SATA or PATA
    //
    IDE_BUS_TYPE AtaBusType;

    //
    // IN only field. Pointer to hardware resources
    //
    PIDE_MINIPORT_RESOURCES ControllerResources;

} IDE_CONTROLLER_CONFIGURATION, *PIDE_CONTROLLER_CONFIGURATION;

typedef
BOOLEAN
(*IDE_ADAPTER_CONTROL) (
    __in PVOID ControllerExtension,
    __in IDE_CONTROL_ACTION ControlAction,
    __inout_opt PVOID Parameters
    );

typedef struct _IDE_CONTROLLER_INTERFACE {

    //
    //  Size of this structure
    //
    USHORT Version;

    //
    //  Reserved for future use
    //
    USHORT Reserved;
    
    // Size of the controller device extension
    //
    ULONG ControllerExtensionSize;

    //
    // Size of the channel extension
    //
    ULONG ChannelExtensionSize;

    //
    // Alignment requirement
    //
    ULONG AlignmentMask;

    //
    // mini driver entry point
    //

    //
    // init routine for each channel
    //
    IDE_CHANNEL_INIT AtaChannelInitRoutine;

    //
    // channelEnabled routine
    //
    IDE_CHANNEL_ENABLED AtaControllerChannelEnabled;

    //
    // Transfer mode select routine
    //
    IDE_TRANSFER_MODE_SELECT AtaControllerTransferModeSelect;

    //
    // Adapter control routine
    //
    IDE_ADAPTER_CONTROL AtaAdapterControl;
    
} IDE_CONTROLLER_INTERFACE, *PIDE_CONTROLLER_INTERFACE;

//
// Transfer mode support bit masks
//
#define PIO_MODE0           (1 << 0)
#define PIO_MODE1           (1 << 1)
#define PIO_MODE2           (1 << 2)
#define PIO_MODE3           (1 << 3)
#define PIO_MODE4           (1 << 4)

#define SWDMA_MODE0         (1 << 5)
#define SWDMA_MODE1         (1 << 6)
#define SWDMA_MODE2         (1 << 7)

#define MWDMA_MODE0         (1 << 8)
#define MWDMA_MODE1         (1 << 9)
#define MWDMA_MODE2         (1 << 10)

#define UDMA_MODE0          (1 << 11)
#define UDMA_MODE1          (1 << 12)
#define UDMA_MODE2          (1 << 13)
#define UDMA_MODE3          (1 << 14)
#define UDMA_MODE4          (1 << 15)
#define UDMA_MODE5          (1 << 16)

#define PIO_SUPPORT         (PIO_MODE0      | PIO_MODE1     | PIO_MODE2    | PIO_MODE3     | PIO_MODE4)
#define SWDMA_SUPPORT       (SWDMA_MODE0    | SWDMA_MODE1   | SWDMA_MODE2)
#define MWDMA_SUPPORT       (MWDMA_MODE0    | MWDMA_MODE1   | MWDMA_MODE2)
#define UDMA_SUPPORT        (UNINITIALIZED_TRANSFER_MODE & (~(PIO_SUPPORT | SWDMA_SUPPORT | MWDMA_SUPPORT)))

#define DMA_SUPPORT         (SWDMA_SUPPORT  | MWDMA_SUPPORT | UDMA_SUPPORT)
#define ALL_MODE_SUPPORT    (PIO_SUPPORT | DMA_SUPPORT)

#define PIO0                        0
#define PIO1                        1
#define PIO2                        2
#define PIO3                        3
#define PIO4                        4
#define SWDMA0                      5
#define SWDMA1                      6
#define SWDMA2                      7
#define MWDMA0                      8
#define MWDMA1                      9
#define MWDMA2                      10
#define UDMA0                       11

#ifdef MAX_XFER_MODE
#undef MAX_XFER_MODE
#endif

#define MAX_XFER_MODE               18
#define UNINITIALIZED_CYCLE_TIME    0xffffffff
#define UNINITIALIZED_TRANSFER_MODE 0x7fffffff
#define IS_DEFAULT(mode)    (!(mode & 0x80000000))

#ifdef GenTransferModeMask
#undef GenTransferModeMask
#endif

#define GenTransferModeMask(i, mode) {\
    ULONG temp=0xffffffff; \
    mode = (temp >> (31-(i)));\
}

#define GetHighestBitSet(mode, i) {\
    ULONG temp = (mode); \
    i=0; \
    while (temp) { \
        temp >>= 1; \
        i++; \
    } \
    i--; \
}

ULONG
AtaPortInitializeEx(
    __in_opt PVOID                     DriverObject,
    __in_opt PVOID                     RegistryPath,
    __in PIDE_CONTROLLER_INTERFACE ControllerInterface
    );

//
// To query PCI IDE config space data
//                                    
ULONG
AtaPortGetBusData(
    __in PVOID ControllerExtension,
    __in PVOID Buffer,
    __in ULONG ConfigDataOffset,
    __in ULONG BufferLength
    );

//
// To save PCI IDE config space data
//                                    
ULONG
AtaPortSetBusData(
    __in PVOID ControllerExtension,
    __in PVOID Buffer,
    __in ULONG ConfigDataOffset,
    __in ULONG BufferLength
    );

PIDE_SCATTER_GATHER_LIST
AtaPortGetScatterGatherList (
    __in PVOID ChannelExtension,
    __in PIDE_REQUEST_BLOCK   Irb
    );

IDE_PHYSICAL_ADDRESS
AtaPortGetPhysicalAddress (
    __in       PVOID ChannelExtension,
    __in_opt   PIDE_REQUEST_BLOCK Irb,
    __in_opt   PVOID VirtualAddress,
    __out_opt  ULONG * Length
    );

PVOID
AtaPortGetDeviceBase (
    __in PVOID ChannelExtension,
    __in IDE_PHYSICAL_ADDRESS IoAddress,
    __in ULONG NumberOfBytes
    );

VOID
AtaPortCompleteRequest(
    __in PVOID ChannelExtension,
    __in PIDE_REQUEST_BLOCK Irb
    );

VOID
AtaPortCompleteAllActiveRequests(
    __in PVOID ChannelExtension,
    __in UCHAR Target,
    __in UCHAR Lun,
    __in UCHAR IrbStatus
    );

VOID
AtaPortNotification(
    __in IDE_NOTIFICATION_TYPE NotificationType,
    __in PVOID ChannelExtension,
    ...
    );

VOID
AtaPortMoveMemory(
    __out_bcount(Length) PVOID WriteBuffer,
    __in_bcount(Length) PVOID ReadBuffer,
    __in ULONG Length
    );

IDE_PHYSICAL_ADDRESS
AtaPortConvertUlongToPhysicalAddress(
    __in ULONG_PTR UlongAddress
    );

ULONG
AtaPortConvertPhysicalAddressToUlong(
    __in IDE_PHYSICAL_ADDRESS Address
    );

VOID
AtaPortStallExecution(
    __in ULONG Delay
    );

PVOID
AtaPortGetUnCachedExtension (
    __in PVOID ChannelExtension,
    __in ULONG UncachedExtensionSize,
    __in ULONG IrbExtensionSize
    );

VOID
AtaPortDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

VOID
AtaPortLogError(
    __in PVOID ChannelExtension,
    __in PIDE_ERROR_LOG_ENTRY ErrorLogEntry
    );

PIDE_REQUEST_BLOCK
AtaPortBuildRequestSenseIrb(
    __in PVOID ChannelExtension,
    __in PIDE_REQUEST_BLOCK Irb
    );

VOID
AtaPortReleaseRequestSenseIrb(
    __in PVOID ChannelExtension,
    __in PIDE_REQUEST_BLOCK Irb
    );

VOID
AtaPortDeviceStateChange (
    __in PVOID ChannelExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun,
    __in ULONG BusyTimeout
    );

BOOLEAN
AtaPortRequestCallback (
    __in IDE_CALLBACK_TYPE CallbackType,
    __in PVOID ChannelExtension,
    __in IDE_HW_DPC CallBackRoutine,
    __in ULONG TimerValue
    );

PVOID
AtaPortRegistryAllocateBuffer (
    __in PVOID ChannelExtension,
    __in ULONG BufferSize
    );

VOID
AtaPortRegistryFreeBuffer (
    __in PVOID ChannelExtension,
    __in PVOID Buffer
    );

BOOLEAN
AtaPortInitializeQueueTag (
    __in PVOID DeviceExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun,
    __in UCHAR MaxQueueTag
    );

UCHAR
AtaPortAllocateQueueTag (
    __in PVOID DeviceExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun
    );

VOID
AtaPortReleaseQueueTag (
    __in PVOID DeviceExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun,
    __in UCHAR QueueTag
    );

BOOLEAN
AtaPortRegistryRead (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in BOOLEAN ChannelSubKey,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __out_opt PUCHAR Buffer,
    __inout   PULONG BufferLength
    );

BOOLEAN
AtaPortRegistryWrite (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in BOOLEAN ChannelSubKey,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __in PUCHAR Buffer,
    __in PULONG BufferLength
    );

BOOLEAN
AtaPortRegistryWriteDeferred (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in BOOLEAN ChannelSubKey,
    __in IN PCHAR ValueName,
    __in UCHAR ValueType,
    __in PUCHAR Buffer,
    __in PULONG BufferLength
    );

VOID
__inline
AtaPortDeviceBusy (
    __in PVOID ChannelExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun,
    __in ULONG BusyTimeout
    )
{
    AtaPortDeviceStateChange(ChannelExtension,
                             TargetId,
                             Lun,
                             BusyTimeout
                             );
}

VOID
__inline
AtaPortDeviceReady (
    __in PVOID ChannelExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun
    )
{
    AtaPortDeviceStateChange(ChannelExtension,
                             TargetId,
                             Lun,
                             0
                             );
}

BOOLEAN
__inline
AtaPortRegistryControllerKeyRead (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __out_opt PUCHAR Buffer,
    __inout   PULONG BufferLength
    )
{
    return AtaPortRegistryRead (ChannelExtension,
                                ControllerNumber,
                                FALSE,
                                ValueName,
                                ValueType,
                                Buffer,
                                BufferLength
                                );
}

BOOLEAN
__inline
AtaPortRegistryControllerKeyWrite (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __in PUCHAR Buffer,
    __in PULONG BufferLength
    )
{
    return AtaPortRegistryWrite (ChannelExtension,
                                 ControllerNumber,
                                 FALSE,
                                 ValueName,
                                 ValueType,
                                 Buffer,
                                 BufferLength
                                 );
}

BOOLEAN
__inline
AtaPortRegistryControllerKeyWriteDeferred (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __in PUCHAR Buffer,
    __in PULONG BufferLength
    )
{
    return AtaPortRegistryWriteDeferred (ChannelExtension,
                                         ControllerNumber,
                                         FALSE,
                                         ValueName,
                                         ValueType,
                                         Buffer,
                                         BufferLength
                                         );
}

BOOLEAN
__inline
AtaPortRegistryChannelSubkeyRead (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __out_opt PUCHAR Buffer,
    __inout   PULONG BufferLength
    )
{
    return AtaPortRegistryRead (ChannelExtension,
                                ControllerNumber,
                                TRUE,
                                ValueName,
                                ValueType,
                                Buffer,
                                BufferLength
                                );
}

BOOLEAN
__inline
AtaPortRegistryChannelSubkeyWrite (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __in PUCHAR Buffer,
    __in PULONG BufferLength
    )
{
    return AtaPortRegistryWrite (ChannelExtension,
                                 ControllerNumber,
                                 TRUE,
                                 ValueName,
                                 ValueType,
                                 Buffer,
                                 BufferLength
                                 );
}

BOOLEAN
__inline
AtaPortRegistryChannelSubkeyWriteDeferred (
    __in PVOID ChannelExtension,
    __in UCHAR ControllerNumber,
    __in PCHAR ValueName,
    __in UCHAR ValueType,
    __in PUCHAR Buffer,
    __in PULONG BufferLength
    )
{
    return AtaPortRegistryWriteDeferred (ChannelExtension,
                                         ControllerNumber,
                                         TRUE,
                                         ValueName,
                                         ValueType,
                                         Buffer,
                                         BufferLength
                                         );

}

BOOLEAN
__inline
AtaPortRequestWorkerRoutine (
    __in PVOID ChannelExtension,
    __in IDE_HW_DPC CallBackRoutine
    )
{
    return AtaPortRequestCallback (IdeWorkerRoutine, 
                                   ChannelExtension, 
                                   CallBackRoutine, 
                                   0 
                                   );
}

BOOLEAN
__inline
AtaPortRequestSynchronizedRoutine (
    __in PVOID ChannelExtension,
    __in IDE_HW_DPC CallBackRoutine
    )
{
    return AtaPortRequestCallback (IdeSynchronizedRoutine, 
                                   ChannelExtension, 
                                   CallBackRoutine, 
                                   0 
                                   );
}

BOOLEAN
__inline
AtaPortControllerSyncRoutine (
    __in PVOID ChannelExtension,
    __in IDE_HW_DPC CallBackRoutine
    )
{
    return AtaPortRequestCallback (IdeControllerSyncRoutine, 
                                   ChannelExtension, 
                                   CallBackRoutine, 
                                   0 
                                   );
}

BOOLEAN
__inline
AtaPortRequestTimer (
    __in PVOID ChannelExtension,
    __in IDE_HW_DPC CallBackRoutine,
    __in ULONG TimerValue
    )
{
    return AtaPortRequestCallback(IdeTimerRoutine, 
                                  ChannelExtension, 
                                  CallBackRoutine, 
                                  TimerValue 
                                  );
}

VOID
__inline
AtaPortBusChangeDetected (
    __in PVOID ChannelExtension
    )
{
    AtaPortNotification(IdeDeviceArrival,
                        ChannelExtension,
                        IDE_UNTAGGED,
                        0
                        );
}


VOID
__inline
AtaPortDeviceArrived (
    __in PVOID ChannelExtension,
    __in UCHAR TargetId
    )
{
    AtaPortNotification(IdeDeviceArrival,
                        ChannelExtension,
                        TargetId,
                        0
                        );
}

VOID
__inline
AtaPortDeviceRemoved (
    __in PVOID ChannelExtension,
    __in UCHAR TargetId
    )
{
    AtaPortNotification(IdeDeviceRemoval,
                        ChannelExtension,
                        TargetId,
                        0
                        );
}

VOID
__inline
AtaPortRequestPowerStateChange (
    __in PVOID ChannelExtension,
    __in UCHAR TargetId,
    __in UCHAR Lun,
    __in IDE_POWER_STATE DesiredPowerState
    )
{
    AtaPortNotification(IdePowerStateChange,
                        ChannelExtension,
                        TargetId,
                        Lun,
                        DesiredPowerState
                        );
}

VOID
AtaPortQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );
    
VOID
AtaPortDebugBreak (
    IN PVOID ChannelExtension
    );

VOID
AtaPortTraceNotification(
    __in ULONG NotificationType,
    __in_opt PVOID HwDeviceExtension,
    ...
    );

//
// The below I/O access routines should be forwarded to the HAL or NTOSKRNL on
// Intel platforms.
//
UCHAR
AtaPortReadPortUchar(
    IN PUCHAR Port
    );

USHORT
AtaPortReadPortUshort(
    IN PUSHORT Port
    );

ULONG
AtaPortReadPortUlong(
    IN PULONG Port
    );

VOID
AtaPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

VOID
AtaPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
AtaPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

UCHAR
AtaPortReadRegisterUchar(
    IN PUCHAR Register
    );

USHORT
AtaPortReadRegisterUshort(
    IN PUSHORT Register
    );

ULONG
AtaPortReadRegisterUlong(
    IN PULONG Register
    );

VOID
AtaPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

VOID
AtaPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
AtaPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
AtaPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    );

VOID
AtaPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    );

VOID
AtaPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    );

VOID
AtaPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

VOID
AtaPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
AtaPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );


VOID
AtaPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    );

VOID
AtaPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    );

VOID
AtaPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

VOID
AtaPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
AtaPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
AtaPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    );

#ifdef __cplusplus
}
#endif

#endif

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsierr.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iscsierr.h

Abstract:

    Constant definitions for the IScsi discover error codes

Revision History:

--*/

#ifndef _ISCSIERR_
#define _ISCSIERR_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Error status code for ISCSI discovery apis. Error codes can be a 
// standard Windows error code as defined in Winerror.h or one of the
// iscsi discovery specific error codes defined below.
//
#ifndef MOFCOMP_PASS
typedef ULONG ISDSC_STATUS;
#endif

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ISDSC_NON_SPECIFIC_ERROR
//
// MessageText:
//
// A non specific error occurred.
//
#define ISDSC_NON_SPECIFIC_ERROR         ((ISDSC_STATUS)0xEFFF0001L)

//
// MessageId: ISDSC_LOGIN_FAILED
//
// MessageText:
//
// Login Failed.
//
#define ISDSC_LOGIN_FAILED               ((ISDSC_STATUS)0xEFFF0002L)

//
// MessageId: ISDSC_CONNECTION_FAILED
//
// MessageText:
//
// Connection Failed.
//
#define ISDSC_CONNECTION_FAILED          ((ISDSC_STATUS)0xEFFF0003L)

//
// MessageId: ISDSC_INITIATOR_NODE_ALREADY_EXISTS
//
// MessageText:
//
// Initiator Node Already Exists.
//
#define ISDSC_INITIATOR_NODE_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0004L)

//
// MessageId: ISDSC_INITIATOR_NODE_NOT_FOUND
//
// MessageText:
//
// Initiator Node Does Not Exist.
//
#define ISDSC_INITIATOR_NODE_NOT_FOUND   ((ISDSC_STATUS)0xEFFF0005L)

//
// MessageId: ISDSC_TARGET_MOVED_TEMPORARILY
//
// MessageText:
//
// Target Moved Temporarily.
//
#define ISDSC_TARGET_MOVED_TEMPORARILY   ((ISDSC_STATUS)0xEFFF0006L)

//
// MessageId: ISDSC_TARGET_MOVED_PERMANENTLY
//
// MessageText:
//
// Target Moved Permanently.
//
#define ISDSC_TARGET_MOVED_PERMANENTLY   ((ISDSC_STATUS)0xEFFF0007L)

//
// MessageId: ISDSC_INITIATOR_ERROR
//
// MessageText:
//
// Initiator Error.
//
#define ISDSC_INITIATOR_ERROR            ((ISDSC_STATUS)0xEFFF0008L)

//
// MessageId: ISDSC_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Authentication Failure.
//
#define ISDSC_AUTHENTICATION_FAILURE     ((ISDSC_STATUS)0xEFFF0009L)

//
// MessageId: ISDSC_AUTHORIZATION_FAILURE
//
// MessageText:
//
// Authorization Failure.
//
#define ISDSC_AUTHORIZATION_FAILURE      ((ISDSC_STATUS)0xEFFF000AL)

//
// MessageId: ISDSC_NOT_FOUND
//
// MessageText:
//
// Not Found.
//
#define ISDSC_NOT_FOUND                  ((ISDSC_STATUS)0xEFFF000BL)

//
// MessageId: ISDSC_TARGET_REMOVED
//
// MessageText:
//
// Target Removed.
//
#define ISDSC_TARGET_REMOVED             ((ISDSC_STATUS)0xEFFF000CL)

//
// MessageId: ISDSC_UNSUPPORTED_VERSION
//
// MessageText:
//
// Unsupported Version.
//
#define ISDSC_UNSUPPORTED_VERSION        ((ISDSC_STATUS)0xEFFF000DL)

//
// MessageId: ISDSC_TOO_MANY_CONNECTIONS
//
// MessageText:
//
// Too many Connections.
//
#define ISDSC_TOO_MANY_CONNECTIONS       ((ISDSC_STATUS)0xEFFF000EL)

//
// MessageId: ISDSC_MISSING_PARAMETER
//
// MessageText:
//
// Missing Parameter.
//
#define ISDSC_MISSING_PARAMETER          ((ISDSC_STATUS)0xEFFF000FL)

//
// MessageId: ISDSC_CANT_INCLUDE_IN_SESSION
//
// MessageText:
//
// Can not include in session.
//
#define ISDSC_CANT_INCLUDE_IN_SESSION    ((ISDSC_STATUS)0xEFFF0010L)

//
// MessageId: ISDSC_SESSION_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// Session type not supported.
//
#define ISDSC_SESSION_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0011L)

//
// MessageId: ISDSC_TARGET_ERROR
//
// MessageText:
//
// Target Error.
//
#define ISDSC_TARGET_ERROR               ((ISDSC_STATUS)0xEFFF0012L)

//
// MessageId: ISDSC_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Service Unavailable.
//
#define ISDSC_SERVICE_UNAVAILABLE        ((ISDSC_STATUS)0xEFFF0013L)

//
// MessageId: ISDSC_OUT_OF_RESOURCES
//
// MessageText:
//
// Out of Resources.
//
#define ISDSC_OUT_OF_RESOURCES           ((ISDSC_STATUS)0xEFFF0014L)

//
// MessageId: ISDSC_CONNECTION_ALREADY_EXISTS
//
// MessageText:
//
// Connections already exist on initiator node.
//
#define ISDSC_CONNECTION_ALREADY_EXISTS  ((ISDSC_STATUS)0xEFFF0015L)

//
// MessageId: ISDSC_SESSION_ALREADY_EXISTS
//
// MessageText:
//
// Session Already Exists.
//
#define ISDSC_SESSION_ALREADY_EXISTS     ((ISDSC_STATUS)0xEFFF0016L)

//
// MessageId: ISDSC_INITIATOR_INSTANCE_NOT_FOUND
//
// MessageText:
//
// Initiator Instance Does Not Exist.
//
#define ISDSC_INITIATOR_INSTANCE_NOT_FOUND ((ISDSC_STATUS)0xEFFF0017L)

//
// MessageId: ISDSC_TARGET_ALREADY_EXISTS
//
// MessageText:
//
// Target Already Exists.
//
#define ISDSC_TARGET_ALREADY_EXISTS      ((ISDSC_STATUS)0xEFFF0018L)

//
// MessageId: ISDSC_DRIVER_BUG
//
// MessageText:
//
// The iscsi driver implementation did not complete an operation correctly.
//
#define ISDSC_DRIVER_BUG                 ((ISDSC_STATUS)0xEFFF0019L)

//
// MessageId: ISDSC_INVALID_TEXT_KEY
//
// MessageText:
//
// An invalid key text was encountered.
//
#define ISDSC_INVALID_TEXT_KEY           ((ISDSC_STATUS)0xEFFF001AL)

//
// MessageId: ISDSC_INVALID_SENDTARGETS_TEXT
//
// MessageText:
//
// Invalid SendTargets response text was encountered.
//
#define ISDSC_INVALID_SENDTARGETS_TEXT   ((ISDSC_STATUS)0xEFFF001BL)

//
// MessageId: ISDSC_INVALID_SESSION_ID
//
// MessageText:
//
// Invalid Session Id.
//
#define ISDSC_INVALID_SESSION_ID         ((ISDSC_STATUS)0xEFFF001CL)

//
// MessageId: ISDSC_SCSI_REQUEST_FAILED
//
// MessageText:
//
// The scsi request failed.
//
#define ISDSC_SCSI_REQUEST_FAILED        ((ISDSC_STATUS)0xEFFF001DL)

//
// MessageId: ISDSC_TOO_MANY_SESSIONS
//
// MessageText:
//
// Exceeded max sessions for this initiator.
//
#define ISDSC_TOO_MANY_SESSIONS          ((ISDSC_STATUS)0xEFFF001EL)

//
// MessageId: ISDSC_SESSION_BUSY
//
// MessageText:
//
// Session is busy since a request is already in progress.
//
#define ISDSC_SESSION_BUSY               ((ISDSC_STATUS)0xEFFF001FL)

//
// MessageId: ISDSC_TARGET_MAPPING_UNAVAILABLE
//
// MessageText:
//
// The target mapping requested is not available.
//
#define ISDSC_TARGET_MAPPING_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0020L)

//
// MessageId: ISDSC_ADDRESS_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The Target Address type given is not supported.
//
#define ISDSC_ADDRESS_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0021L)

//
// MessageId: ISDSC_LOGON_FAILED
//
// MessageText:
//
// Logon Failed.
//
#define ISDSC_LOGON_FAILED               ((ISDSC_STATUS)0xEFFF0022L)

//
// MessageId: ISDSC_SEND_FAILED
//
// MessageText:
//
// TCP Send Failed.
//
#define ISDSC_SEND_FAILED                ((ISDSC_STATUS)0xEFFF0023L)

//
// MessageId: ISDSC_TRANSPORT_ERROR
//
// MessageText:
//
// TCP Transport Error
//
#define ISDSC_TRANSPORT_ERROR            ((ISDSC_STATUS)0xEFFF0024L)

//
// MessageId: ISDSC_VERSION_MISMATCH
//
// MessageText:
//
// iSCSI Version Mismatch
//
#define ISDSC_VERSION_MISMATCH           ((ISDSC_STATUS)0xEFFF0025L)

//
// MessageId: ISDSC_TARGET_MAPPING_OUT_OF_RANGE
//
// MessageText:
//
// The Target Mapping Address passed is out of range for the adapter configuration.
//
#define ISDSC_TARGET_MAPPING_OUT_OF_RANGE ((ISDSC_STATUS)0xEFFF0026L)

//
// MessageId: ISDSC_TARGET_PRESHAREDKEY_UNAVAILABLE
//
// MessageText:
//
// The preshared key for the target or IKE identification payload is not available.
//
#define ISDSC_TARGET_PRESHAREDKEY_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0027L)

//
// MessageId: ISDSC_TARGET_AUTHINFO_UNAVAILABLE
//
// MessageText:
//
// The authentication information for the target is not available.
//
#define ISDSC_TARGET_AUTHINFO_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0028L)

//
// MessageId: ISDSC_TARGET_NOT_FOUND
//
// MessageText:
//
// The target name is not found or is marked as hidden from login.
//
#define ISDSC_TARGET_NOT_FOUND           ((ISDSC_STATUS)0xEFFF0029L)

//
// MessageId: ISDSC_LOGIN_USER_INFO_BAD
//
// MessageText:
//
// One or more parameters specified in LoginTargetIN structure is invalid.
//
#define ISDSC_LOGIN_USER_INFO_BAD        ((ISDSC_STATUS)0xEFFF002AL)

//
// MessageId: ISDSC_TARGET_MAPPING_EXISTS
//
// MessageText:
//
// Given target mapping already exists.
//
#define ISDSC_TARGET_MAPPING_EXISTS      ((ISDSC_STATUS)0xEFFF002BL)

//
// MessageId: ISDSC_HBA_SECURITY_CACHE_FULL
//
// MessageText:
//
// The HBA security information cache is full.
//
#define ISDSC_HBA_SECURITY_CACHE_FULL    ((ISDSC_STATUS)0xEFFF002CL)

//
// MessageId: ISDSC_INVALID_PORT_NUMBER
//
// MessageText:
//
// The port number passed is not valid for the initiator.
//
#define ISDSC_INVALID_PORT_NUMBER        ((ISDSC_STATUS)0xEFFF002DL)

//
// MessageId: ISDSC_OPERATION_NOT_ALL_SUCCESS
//
// MessageText:
//
// The operation was not successful for all initiators or discovery methods.
//
#define ISDSC_OPERATION_NOT_ALL_SUCCESS  ((ISDSC_STATUS)0xAFFF002EL)

//
// MessageId: ISDSC_HBA_SECURITY_CACHE_NOT_SUPPORTED
//
// MessageText:
//
// The HBA security information cache is not supported by this adapter.
//
#define ISDSC_HBA_SECURITY_CACHE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF002FL)

//
// MessageId: ISDSC_IKE_ID_PAYLOAD_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The IKE id payload type specified is not supported.
//
#define ISDSC_IKE_ID_PAYLOAD_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0030L)

//
// MessageId: ISDSC_IKE_ID_PAYLOAD_INCORRECT_SIZE
//
// MessageText:
//
// The IKE id payload size specified is not correct.
//
#define ISDSC_IKE_ID_PAYLOAD_INCORRECT_SIZE ((ISDSC_STATUS)0xEFFF0031L)

//
// MessageId: ISDSC_TARGET_PORTAL_ALREADY_EXISTS
//
// MessageText:
//
// Target Portal Structure Already Exists.
//
#define ISDSC_TARGET_PORTAL_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0032L)

//
// MessageId: ISDSC_TARGET_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
// Target Address Structure Already Exists.
//
#define ISDSC_TARGET_ADDRESS_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0033L)

//
// MessageId: ISDSC_NO_AUTH_INFO_AVAILABLE
//
// MessageText:
//
// There is no IKE authentication information available.
//
#define ISDSC_NO_AUTH_INFO_AVAILABLE     ((ISDSC_STATUS)0xEFFF0034L)

//
// MessageId: ISDSC_NO_TUNNEL_OUTER_MODE_ADDRESS
//
// MessageText:
//
// There is no tunnel mode outer address specified.
//
#define ISDSC_NO_TUNNEL_OUTER_MODE_ADDRESS ((ISDSC_STATUS)0xEFFF0035L)

//
// MessageId: ISDSC_CACHE_CORRUPTED
//
// MessageText:
//
// Authentication or tunnel address cache is corrupted.
//
#define ISDSC_CACHE_CORRUPTED            ((ISDSC_STATUS)0xEFFF0036L)

//
// MessageId: ISDSC_REQUEST_NOT_SUPPORTED
//
// MessageText:
//
// The request or operation is not supported.
//
#define ISDSC_REQUEST_NOT_SUPPORTED      ((ISDSC_STATUS)0xEFFF0037L)

//
// MessageId: ISDSC_TARGET_OUT_OF_RESORCES
//
// MessageText:
//
// The target does not have enough resources to process the given request.
//
#define ISDSC_TARGET_OUT_OF_RESORCES     ((ISDSC_STATUS)0xEFFF0038L)

//
// MessageId: ISDSC_SERVICE_DID_NOT_RESPOND
//
// MessageText:
//
// The initiator service did not respond to the request sent by the driver.
//
#define ISDSC_SERVICE_DID_NOT_RESPOND    ((ISDSC_STATUS)0xEFFF0039L)

//
// MessageId: ISDSC_ISNS_SERVER_NOT_FOUND
//
// MessageText:
//
// The Internet Storage Name Server (iSNS) server was not found or is unavailable.
//
#define ISDSC_ISNS_SERVER_NOT_FOUND      ((ISDSC_STATUS)0xEFFF003AL)

//
// MessageId: ISDSC_OPERATION_REQUIRES_REBOOT
//
// MessageText:
//
// The operation was successful but requires a driver reload or reboot to become effective.
//
#define ISDSC_OPERATION_REQUIRES_REBOOT  ((ISDSC_STATUS)0xAFFF003BL)

//
// MessageId: ISDSC_NO_PORTAL_SPECIFIED
//
// MessageText:
//
// There is no target portal available to complete the login.
//
#define ISDSC_NO_PORTAL_SPECIFIED        ((ISDSC_STATUS)0xEFFF003CL)

//
// MessageId: ISDSC_CANT_REMOVE_LAST_CONNECTION
//
// MessageText:
//
// Cannot remove the last connection for a session.
//
#define ISDSC_CANT_REMOVE_LAST_CONNECTION ((ISDSC_STATUS)0xEFFF003DL)

//
// MessageId: ISDSC_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Microsoft iSCSI initiator service has not been started.
//
#define ISDSC_SERVICE_NOT_RUNNING        ((ISDSC_STATUS)0xEFFF003EL)

//
// MessageId: ISDSC_TARGET_ALREADY_LOGGED_IN
//
// MessageText:
//
// The target has already been logged in via an iSCSI session.
//
#define ISDSC_TARGET_ALREADY_LOGGED_IN   ((ISDSC_STATUS)0xEFFF003FL)

//
// MessageId: ISDSC_DEVICE_BUSY_ON_SESSION
//
// MessageText:
//
// The session cannot be logged out since a device on that session is currently being used.
//
#define ISDSC_DEVICE_BUSY_ON_SESSION     ((ISDSC_STATUS)0xEFFF0040L)

//
// MessageId: ISDSC_COULD_NOT_SAVE_PERSISTENT_LOGIN_DATA
//
// MessageText:
//
// Failed to save persistent login information.
//
#define ISDSC_COULD_NOT_SAVE_PERSISTENT_LOGIN_DATA ((ISDSC_STATUS)0xEFFF0041L)

//
// MessageId: ISDSC_COULD_NOT_REMOVE_PERSISTENT_LOGIN_DATA
//
// MessageText:
//
// Failed to remove persistent login information.
//
#define ISDSC_COULD_NOT_REMOVE_PERSISTENT_LOGIN_DATA ((ISDSC_STATUS)0xEFFF0042L)

//
// MessageId: ISDSC_PORTAL_NOT_FOUND
//
// MessageText:
//
// The specified portal was not found.
//
#define ISDSC_PORTAL_NOT_FOUND           ((ISDSC_STATUS)0xEFFF0043L)

//
// MessageId: ISDSC_INITIATOR_NOT_FOUND
//
// MessageText:
//
// The specified initiator name was not found.
//
#define ISDSC_INITIATOR_NOT_FOUND        ((ISDSC_STATUS)0xEFFF0044L)

//
// MessageId: ISDSC_DISCOVERY_MECHANISM_NOT_FOUND
//
// MessageText:
//
// The specified discovery mechanism was not found.
//
#define ISDSC_DISCOVERY_MECHANISM_NOT_FOUND ((ISDSC_STATUS)0xEFFF0045L)

//
// MessageId: ISDSC_IPSEC_NOT_SUPPORTED_ON_OS
//
// MessageText:
//
// iSCSI does not support IPSEC for this version of the OS.
//
#define ISDSC_IPSEC_NOT_SUPPORTED_ON_OS  ((ISDSC_STATUS)0xEFFF0046L)

//
// MessageId: ISDSC_PERSISTENT_LOGIN_TIMEOUT
//
// MessageText:
//
// The iSCSI service timed out waiting for all persistent logins to complete.
//
#define ISDSC_PERSISTENT_LOGIN_TIMEOUT   ((ISDSC_STATUS)0xEFFF0047L)

//
// MessageId: ISDSC_SHORT_CHAP_SECRET
//
// MessageText:
//
// The specified CHAP secret is less than 96 bits and will not be usable for authenticating over non ipsec connections.
//
#define ISDSC_SHORT_CHAP_SECRET          ((ISDSC_STATUS)0xAFFF0048L)

//
// MessageId: ISDSC_EVALUATION_PEROID_EXPIRED
//
// MessageText:
//
// The evaluation period for the iSCSI initiator service has expired.
//
#define ISDSC_EVALUATION_PEROID_EXPIRED  ((ISDSC_STATUS)0xEFFF0049L)

//
// MessageId: ISDSC_INVALID_CHAP_SECRET
//
// MessageText:
//
// CHAP secret given does not conform to the standard. Please see system event log for more information.
//
#define ISDSC_INVALID_CHAP_SECRET        ((ISDSC_STATUS)0xEFFF004AL)

//
// MessageId: ISDSC_INVALID_TARGET_CHAP_SECRET
//
// MessageText:
//
// Target CHAP secret given is invalid. Maximum size of CHAP secret is 16 bytes. Minimum size is 12 bytes if IPSec is not used.
//
#define ISDSC_INVALID_TARGET_CHAP_SECRET ((ISDSC_STATUS)0xEFFF004BL)

//
// MessageId: ISDSC_INVALID_INITIATOR_CHAP_SECRET
//
// MessageText:
//
// Initiator CHAP secret given is invalid. Maximum size of CHAP secret is 16 bytes. Minimum size is 12 bytes if IPSec is not used.
//
#define ISDSC_INVALID_INITIATOR_CHAP_SECRET ((ISDSC_STATUS)0xEFFF004CL)

//
// MessageId: ISDSC_INVALID_CHAP_USER_NAME
//
// MessageText:
//
// CHAP Username given is invalid.
//
#define ISDSC_INVALID_CHAP_USER_NAME     ((ISDSC_STATUS)0xEFFF004DL)

//
// MessageId: ISDSC_INVALID_LOGON_AUTH_TYPE
//
// MessageText:
//
// Logon Authentication type given is invalid.
//
#define ISDSC_INVALID_LOGON_AUTH_TYPE    ((ISDSC_STATUS)0xEFFF004EL)

//
// MessageId: ISDSC_INVALID_TARGET_MAPPING
//
// MessageText:
//
// Target Mapping information given is invalid.
//
#define ISDSC_INVALID_TARGET_MAPPING     ((ISDSC_STATUS)0xEFFF004FL)

//
// MessageId: ISDSC_INVALID_TARGET_ID
//
// MessageText:
//
// Target Id given in Target Mapping is invalid.
//
#define ISDSC_INVALID_TARGET_ID          ((ISDSC_STATUS)0xEFFF0050L)

//
// MessageId: ISDSC_INVALID_ISCSI_NAME
//
// MessageText:
//
// The iSCSI name specified contains invalid characters or is too long.
//
#define ISDSC_INVALID_ISCSI_NAME         ((ISDSC_STATUS)0xEFFF0051L)

//
// MessageId: ISDSC_INCOMPATIBLE_ISNS_VERSION
//
// MessageText:
//
// The version number returned from the Internet Storage Name Server (iSNS) server is not compatible with this version of the iSNS client.
//
#define ISDSC_INCOMPATIBLE_ISNS_VERSION  ((ISDSC_STATUS)0xEFFF0052L)

//
// MessageId: ISDSC_FAILED_TO_CONFIGURE_IPSEC
//
// MessageText:
//
// Initiator failed to configure IPSec for the given connection. This could be because of low resources.
//
#define ISDSC_FAILED_TO_CONFIGURE_IPSEC  ((ISDSC_STATUS)0xEFFF0053L)

//
// MessageId: ISDSC_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer given for processing the request is too small.
//
#define ISDSC_BUFFER_TOO_SMALL           ((ISDSC_STATUS)0xEFFF0054L)

//
// MessageId: ISDSC_INVALID_LOAD_BALANCE_POLICY
//
// MessageText:
//
// The given Load Balance policy is not recognized by iScsi initiator.
//
#define ISDSC_INVALID_LOAD_BALANCE_POLICY ((ISDSC_STATUS)0xEFFF0055L)

//
// MessageId: ISDSC_INVALID_PARAMETER
//
// MessageText:
//
// One or more paramaters specified is not valid.
//
#define ISDSC_INVALID_PARAMETER          ((ISDSC_STATUS)0xEFFF0056L)

//
// MessageId: ISDSC_DUPLICATE_PATH_SPECIFIED
//
// MessageText:
//
// Duplicate PathIds were specified in the call to set Load Balance Policy.
//
#define ISDSC_DUPLICATE_PATH_SPECIFIED   ((ISDSC_STATUS)0xEFFF0057L)

//
// MessageId: ISDSC_PATH_COUNT_MISMATCH
//
// MessageText:
//
// Number of paths specified in Set Load Balance Policy does not match the number of paths to the target.
//
#define ISDSC_PATH_COUNT_MISMATCH        ((ISDSC_STATUS)0xEFFF0058L)

//
// MessageId: ISDSC_INVALID_PATH_ID
//
// MessageText:
//
// Path Id specified in the call to set Load Balance Policy is not valid
//
#define ISDSC_INVALID_PATH_ID            ((ISDSC_STATUS)0xEFFF0059L)

//
// MessageId: ISDSC_MULTIPLE_PRIMARY_PATHS_SPECIFIED
//
// MessageText:
//
// Multiple primary paths specified when only one primary path is expected.
//
#define ISDSC_MULTIPLE_PRIMARY_PATHS_SPECIFIED ((ISDSC_STATUS)0xEFFF005AL)

//
// MessageId: ISDSC_NO_PRIMARY_PATH_SPECIFIED
//
// MessageText:
//
// No primary path specified when at least one is expected.
//
#define ISDSC_NO_PRIMARY_PATH_SPECIFIED  ((ISDSC_STATUS)0xEFFF005BL)

//
// MessageId: ISDSC_DEVICE_ALREADY_PERSISTENTLY_BOUND
//
// MessageText:
//
// Device is already a persistently bound device.
//
#define ISDSC_DEVICE_ALREADY_PERSISTENTLY_BOUND ((ISDSC_STATUS)0xEFFF005CL)

//
// MessageId: ISDSC_DEVICE_NOT_FOUND
//
// MessageText:
//
// Device was not found.
//
#define ISDSC_DEVICE_NOT_FOUND           ((ISDSC_STATUS)0xEFFF005DL)

//
// MessageId: ISDSC_DEVICE_NOT_ISCSI_OR_PERSISTENT
//
// MessageText:
//
// The device specified does not originate from an iSCSI disk or a persistent iSCSI login.
//
#define ISDSC_DEVICE_NOT_ISCSI_OR_PERSISTENT ((ISDSC_STATUS)0xEFFF005EL)

//
// MessageId: ISDSC_DNS_NAME_UNRESOLVED
//
// MessageText:
//
// The DNS name specified was not resolved.
//
#define ISDSC_DNS_NAME_UNRESOLVED        ((ISDSC_STATUS)0xEFFF005FL)

//
// MessageId: ISDSC_NO_CONNECTION_AVAILABLE
//
// MessageText:
//
// There is no connection available in the iSCSI session to process the request.
//
#define ISDSC_NO_CONNECTION_AVAILABLE    ((ISDSC_STATUS)0xEFFF0060L)

//
// MessageId: ISDSC_LB_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// The given Load Balance policy is not supported.
//
#define ISDSC_LB_POLICY_NOT_SUPPORTED    ((ISDSC_STATUS)0xEFFF0061L)

//
// MessageId: ISDSC_REMOVE_CONNECTION_IN_PROGRESS
//
// MessageText:
//
// A remove connection request is already in progress for this session.
//
#define ISDSC_REMOVE_CONNECTION_IN_PROGRESS ((ISDSC_STATUS)0xEFFF0062L)

//
// MessageId: ISDSC_INVALID_CONNECTION_ID
//
// MessageText:
//
// Given connection was not found in the session.
//
#define ISDSC_INVALID_CONNECTION_ID      ((ISDSC_STATUS)0xEFFF0063L)

//
// MessageId: ISDSC_CANNOT_REMOVE_LEADING_CONNECTION
//
// MessageText:
//
// The leading connection in the session cannot be removed.
//
#define ISDSC_CANNOT_REMOVE_LEADING_CONNECTION ((ISDSC_STATUS)0xEFFF0064L)

//
// MessageId: ISDSC_RESTRICTED_BY_GROUP_POLICY
//
// MessageText:
//
// The operation cannot be performed since it does not conform with the group policy assigned to this computer.
//
#define ISDSC_RESTRICTED_BY_GROUP_POLICY ((ISDSC_STATUS)0xEFFF0065L)

//
// MessageId: ISDSC_ISNS_FIREWALL_BLOCKED
//
// MessageText:
//
// The operation cannot be performed since the Internet Storage Name Server (iSNS) firewall exception has not been enabled.
//
#define ISDSC_ISNS_FIREWALL_BLOCKED      ((ISDSC_STATUS)0xEFFF0066L)

#endif /* _ISCSIERR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsifnd.h ===
#ifndef _iscsifnd_h_
#define _iscsifnd_h_

// ISCSI_DiscoveredTargetPortal - ISCSI_DiscoveredTargetPortal
// iSCSI target portal


//***************************************************************************
//
//  iscsifnd.h
// 
//  Module: iScsi Discovery api
//
//  Purpose: Header defining interface between user mode discovery 
//           engine and HBA driver miniport.
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#include <iscsidef.h>


#define ISCSI_DiscoveredTargetPortalGuid \
    { 0xfa218c5d,0xb306,0x4d5d, { 0xb2,0xdb,0x6b,0xba,0x05,0x0f,0xd8,0xfa } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_DiscoveredTargetPortal_GUID, \
            0xfa218c5d,0xb306,0x4d5d,0xb2,0xdb,0x6b,0xba,0x05,0x0f,0xd8,0xfa);
#endif


typedef struct _ISCSI_DiscoveredTargetPortal
{
    // Socket number
    USHORT Socket;
    #define ISCSI_DiscoveredTargetPortal_Socket_SIZE sizeof(USHORT)
    #define ISCSI_DiscoveredTargetPortal_Socket_ID 1

    // Network Address
    ISCSI_IP_Address Address;
    #define ISCSI_DiscoveredTargetPortal_Address_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_DiscoveredTargetPortal_Address_ID 2

    // Portal Symbolic Name
    WCHAR SymbolicName[256 + 1];
    #define ISCSI_DiscoveredTargetPortal_SymbolicName_ID 3

} ISCSI_DiscoveredTargetPortal, *PISCSI_DiscoveredTargetPortal;

// ISCSI_DiscoveredTargetPortalGroup - ISCSI_DiscoveredTargetPortalGroup
// iSCSI target portal group
#define ISCSI_DiscoveredTargetPortalGroupGuid \
    { 0x28c3af2c,0xa453,0x4a3d, { 0x8e,0x10,0x9e,0x09,0xd8,0x9e,0xf3,0x33 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_DiscoveredTargetPortalGroup_GUID, \
            0x28c3af2c,0xa453,0x4a3d,0x8e,0x10,0x9e,0x09,0xd8,0x9e,0xf3,0x33);
#endif


typedef struct _ISCSI_DiscoveredTargetPortalGroup
{
    // Number of portals in group
    ULONG PortalCount;
    #define ISCSI_DiscoveredTargetPortalGroup_PortalCount_SIZE sizeof(ULONG)
    #define ISCSI_DiscoveredTargetPortalGroup_PortalCount_ID 1

    // Target portals in group. NOTE: this field is a variable length array.
    ISCSI_DiscoveredTargetPortal Portals[1];
    #define ISCSI_DiscoveredTargetPortalGroup_Portals_ID 2

} ISCSI_DiscoveredTargetPortalGroup, *PISCSI_DiscoveredTargetPortalGroup;

// ISCSI_DiscoveredTarget - ISCSI_DiscoveredTarget
// ISCSI discovered target information
#define ISCSI_DiscoveredTargetGuid \
    { 0x08cdf465,0xe18d,0x42fe, { 0x8e,0xb2,0x56,0x8c,0xa9,0x6a,0x98,0x56 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_DiscoveredTarget_GUID, \
            0x08cdf465,0xe18d,0x42fe,0x8e,0xb2,0x56,0x8c,0xa9,0x6a,0x98,0x56);
#endif


typedef struct _ISCSI_DiscoveredTarget
{
    // Number of portal groups for target
    ULONG TargetPortalGroupCount;
    #define ISCSI_DiscoveredTarget_TargetPortalGroupCount_SIZE sizeof(ULONG)
    #define ISCSI_DiscoveredTarget_TargetPortalGroupCount_ID 1

    // Target Name
    WCHAR TargetName[223 + 1];
    #define ISCSI_DiscoveredTarget_TargetName_ID 2

    // Target Alias
    WCHAR TargetAlias[255 + 1];
    #define ISCSI_DiscoveredTarget_TargetAlias_ID 3

    // Portal Groups available for connection to target. NOTE: this field is a variable length array
    ISCSI_DiscoveredTargetPortalGroup TargetDiscoveredPortalGroups[1];
    #define ISCSI_DiscoveredTarget_TargetDiscoveredPortalGroups_ID 4

} ISCSI_DiscoveredTarget, *PISCSI_DiscoveredTarget;

// ISCSI_DiscoveredTargetPortal2 - ISCSI_DiscoveredTargetPortal2
// iSCSI target portal
#define ISCSI_DiscoveredTargetPortal2Guid \
    { 0xe95162a2,0x8ee5,0x40f1, { 0xb0,0x5d,0xa5,0x32,0x1a,0x30,0xd0,0x3d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_DiscoveredTargetPortal2_GUID, \
            0xe95162a2,0x8ee5,0x40f1,0xb0,0x5d,0xa5,0x32,0x1a,0x30,0xd0,0x3d);
#endif


typedef struct _ISCSI_DiscoveredTargetPortal2
{
    // Socket number
    USHORT Socket;
    #define ISCSI_DiscoveredTargetPortal2_Socket_SIZE sizeof(USHORT)
    #define ISCSI_DiscoveredTargetPortal2_Socket_ID 1

    // Network Address
    ISCSI_IP_Address Address;
    #define ISCSI_DiscoveredTargetPortal2_Address_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_DiscoveredTargetPortal2_Address_ID 2

    // Security capabilities bitmap as specified in iSNS spec
    ULONG SecurityBitmap;
    #define ISCSI_DiscoveredTargetPortal2_SecurityBitmap_SIZE sizeof(ULONG)
    #define ISCSI_DiscoveredTargetPortal2_SecurityBitmap_ID 3

    // Number of bytes contained in key associated with portal address
    ULONG KeySize;
    #define ISCSI_DiscoveredTargetPortal2_KeySize_SIZE sizeof(ULONG)
    #define ISCSI_DiscoveredTargetPortal2_KeySize_ID 4

    // Key associated with portal address. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding. All fields after this are commented out in the header.
    UCHAR Key[1];
    #define ISCSI_DiscoveredTargetPortal2_Key_ID 5

    // Portal Symbolic Name
//  WCHAR SymbolicName[256 + 1];
    #define ISCSI_DiscoveredTargetPortal2_SymbolicName_ID 6

} ISCSI_DiscoveredTargetPortal2, *PISCSI_DiscoveredTargetPortal2;

// ISCSI_DiscoveredTargetPortalGroup2 - ISCSI_DiscoveredTargetPortalGroup2
// iSCSI target portal group
#define ISCSI_DiscoveredTargetPortalGroup2Guid \
    { 0x1732b30d,0xee08,0x4de7, { 0xbe,0xd1,0xde,0x16,0x5f,0x1d,0x7b,0x45 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_DiscoveredTargetPortalGroup2_GUID, \
            0x1732b30d,0xee08,0x4de7,0xbe,0xd1,0xde,0x16,0x5f,0x1d,0x7b,0x45);
#endif


typedef struct _ISCSI_DiscoveredTargetPortalGroup2
{
    // Number of portals in group
    ULONG PortalCount;
    #define ISCSI_DiscoveredTargetPortalGroup2_PortalCount_SIZE sizeof(ULONG)
    #define ISCSI_DiscoveredTargetPortalGroup2_PortalCount_ID 1

    // portal group tag
    USHORT Tag;
    #define ISCSI_DiscoveredTargetPortalGroup2_Tag_SIZE sizeof(USHORT)
    #define ISCSI_DiscoveredTargetPortalGroup2_Tag_ID 2

    // Target portals in group. NOTE: This field is a variable length array.
    ISCSI_DiscoveredTargetPortal2 Portals[1];
    #define ISCSI_DiscoveredTargetPortalGroup2_Portals_ID 3

} ISCSI_DiscoveredTargetPortalGroup2, *PISCSI_DiscoveredTargetPortalGroup2;

// ISCSI_DiscoveredTarget2 - ISCSI_DiscoveredTarget2
// ISCSI discovered target information
#define ISCSI_DiscoveredTarget2Guid \
    { 0xa71bcde9,0x5433,0x4b36, { 0xb9,0xc1,0x07,0x86,0x8e,0x18,0xb4,0x8a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_DiscoveredTarget2_GUID, \
            0xa71bcde9,0x5433,0x4b36,0xb9,0xc1,0x07,0x86,0x8e,0x18,0xb4,0x8a);
#endif


typedef struct _ISCSI_DiscoveredTarget2
{
    // Number of portal groups for target
    ULONG TargetPortalGroupCount;
    #define ISCSI_DiscoveredTarget2_TargetPortalGroupCount_SIZE sizeof(ULONG)
    #define ISCSI_DiscoveredTarget2_TargetPortalGroupCount_ID 1

    // Target Name
    WCHAR TargetName[223 + 1];
    #define ISCSI_DiscoveredTarget2_TargetName_ID 2

    // Target Alias
    WCHAR TargetAlias[255 + 1];
    #define ISCSI_DiscoveredTarget2_TargetAlias_ID 3

    // Portal Groups available for connection to target. NOTE: This field is a variable length array.
    ISCSI_DiscoveredTargetPortalGroup2 TargetDiscoveredPortalGroups[1];
    #define ISCSI_DiscoveredTarget2_TargetDiscoveredPortalGroups_ID 4

} ISCSI_DiscoveredTarget2, *PISCSI_DiscoveredTarget2;

// MSiSCSI_DiscoveryOperations - MSiSCSI_DiscoveryOperations
// Discovery operations

//
// This class is required
//
// This class exposes the configuration capabilities if the adapter is able to
// perform target discovery. An adapter would need to support target discovery
// if it is ever placed on a separate network from the PC NIC.
//
// This classes uses PDO instance names with a single instance
//

#define MSiSCSI_DiscoveryOperationsGuid \
    { 0x556bc0b0,0x0fb5,0x40f2, { 0x92,0x55,0xb7,0xd9,0xa6,0x69,0xda,0xec } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_DiscoveryOperations_GUID, \
            0x556bc0b0,0x0fb5,0x40f2,0x92,0x55,0xb7,0xd9,0xa6,0x69,0xda,0xec);
#endif

//
// Method id definitions for MSiSCSI_DiscoveryOperations
#define ReportDiscoveredTargets     10
typedef struct _ReportDiscoveredTargets_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define ReportDiscoveredTargets_OUT_Status_SIZE sizeof(ULONG)
    #define ReportDiscoveredTargets_OUT_Status_ID 1

    // Number of targets discovered
    ULONG TargetCount;
    #define ReportDiscoveredTargets_OUT_TargetCount_SIZE sizeof(ULONG)
    #define ReportDiscoveredTargets_OUT_TargetCount_ID 2

    // Targets that have been discovered. NOTE: This field is a variabale length array.
    ISCSI_DiscoveredTarget Targets[1];
    #define ReportDiscoveredTargets_OUT_Targets_ID 3

} ReportDiscoveredTargets_OUT, *PReportDiscoveredTargets_OUT;

#define ReportDiscoveredTargets2     11
typedef struct _ReportDiscoveredTargets2_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define ReportDiscoveredTargets2_OUT_Status_SIZE sizeof(ULONG)
    #define ReportDiscoveredTargets2_OUT_Status_ID 1

    // Number of targets discovered
    ULONG TargetCount;
    #define ReportDiscoveredTargets2_OUT_TargetCount_SIZE sizeof(ULONG)
    #define ReportDiscoveredTargets2_OUT_TargetCount_ID 2

    // Targets that have been discovered. NOTE: This field is a variabale length array.
    ISCSI_DiscoveredTarget2 Targets[1];
    #define ReportDiscoveredTargets2_OUT_Targets_ID 3

} ReportDiscoveredTargets2_OUT, *PReportDiscoveredTargets2_OUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\isvbop.inc ===
; This is the inc file for isvbop.h.
; Please refer to isvbop.h for comments and notes on these interfaces
;
BOP_3RDPARTY	EQU	58H
BOP_UNSIMULATE	EQU	0FEH

RegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 1
        endm

DispatchCall macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 2
        endm
 
VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\isvbop.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    ISVBOP.H

Abstract:

    This is the header file supporting third party bops.
    isvbop.inc is the inc file for this h file.

Note:
    Following include file uses 'DB' to define assembly macros. Some
    assemblers use 'emit' instead. If you are using such a compiler,
    you will have to change db's to emit's.

--*/


#if _MSC_VER > 1000
#pragma once
#endif

#define BOP_3RDPARTY 0x58
#define BOP_UNSIMULATE 0xFE

/* XLATOFF */

/** RegisterModule - This Bop call is made from the 16 bit module
 *		     to register a third party DLL with the bop
 *		     manager. This call returns a handle to the
 *		     16bit caller which is to be used later to
 *		     dispatch a call to the DLL.
 *
 *  INPUT:
 *	Client DS:SI - asciiz string of DLL name.
 *      Client ES:DI - asciiz string of Init Routine in the DLL. (Optional)
 *	Client DS:BX - asciiz string to Dispatch routine in the DLL.
 *
 *  OUTPUT:
 *	SUCCESS:
 *	    Client Carry Clear
 *	    Client AX = Handle (non Zero)
 *	FAILURE:
 *	    Client Carry Set
 *	    Client AX = Error Code
 *		    AX = 1 - DLL not found
 *		    AX = 2 - Dispacth routine not found.
 *		    AX = 3 - Init Routine Not Found
 *		    AX = 4 - Insufficient Memory
 *
 *  NOTES:
 *	RegisterModule results in loading the DLL (specified in DS:SI).
 *      Its Init routine (specified in ES:DI) is called. Its Dispatch
 *	routine (specified in DS:BX) is stored away and all the calls
 *      made from DispatchCall are dispacthed to this routine.
 *      If ES and DI both are null than the caller did'nt supply the init
 *      routine.
 */

#define RegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x0

/** UnRegisterModule - This Bop call is made from the 16 bit module
 *		       to unregister a third party DLL with the bop
 *		       manager.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it if initialization of 16bit app fails after registering the
 *	Bop.
 */

#define UnRegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x1

/** DispacthCall - This Bop call is made from the 16 bit module
 *		   to pass a request to its DLL.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (DLL should set the proper output registers etc.)
 *	(VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it to pass a request to 32bit DLL. The request index and the
 *	parameters are passed in different registers. These register settings
 *	are private to the 16bit module and its associated VDD. Bop manager
 *	does'nt know anything about these registers.
 */
#define DispatchCall()	 _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x2

/*** VDDUnSimulate16
 *
 *   This service causes the simulation of intel instructions to stop and
 *   control to return to VDD.
 *
 *   INPUT
 *      None
 *
 *   OUTPUT
 *      None
 *
 *   NOTES
 *      This service is a macro intended for 16bit stub-drivers. At the
 *      end of worker routine stub-driver should use it.
 */

#define VDDUnSimulate16() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_UNSIMULATE

/* XLATON */


/* ASM
RegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 1
	endm

DispatchCall macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 2
	endm

VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm

 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsilog.h ===
/*++ 

Copyright (c) 1991  Microsoft Corporation

Module Name:

    iscsilog.h

Abstract:

    Constant definitions for the iSCSI error code log values.

--*/

#ifndef _ISCSILOG_
#define _ISCSILOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ISCSI_ERR_TDI_CONNECT_FAILED
//
// MessageText:
//
// Initiator failed to connect to the target. Target IP address and TCP Port number are given in dump data.
//
#define ISCSI_ERR_TDI_CONNECT_FAILED     ((NTSTATUS)0xC0000001L)

//
// MessageId: ISCSI_ERR_INSUFFICIENT_SESSION_RESOURCES
//
// MessageText:
//
// The initiator could not allocate resources for an iSCSI session.
//
#define ISCSI_ERR_INSUFFICIENT_SESSION_RESOURCES ((NTSTATUS)0xC0000002L)

//
// MessageId: ISCSI_ERR_INVALID_COMMAND_SEQUENCE_NUMBER
//
// MessageText:
//
// Maximum command sequence number is not serially greater than expected command sequence number in login response.
// Dump data contains Expected Command Sequence number followed by Maximum Command Sequence number.
//
#define ISCSI_ERR_INVALID_COMMAND_SEQUENCE_NUMBER ((NTSTATUS)0xC0000003L)

//
// MessageId: ISCSI_ERR_INVALID_BURST_LENGTH
//
// MessageText:
//
// MaxBurstLength is not serially greater than FirstBurstLength.
// Dump data contains FirstBurstLength followed by MaxBurstLength.
//
#define ISCSI_ERR_INVALID_BURST_LENGTH   ((NTSTATUS)0xC0000004L)

//
// MessageId: ISCSI_ERR_SETUP_NETWORK_NODE
//
// MessageText:
//
// Failed to setup initiator portal. Error status is given in the dump data.
//
#define ISCSI_ERR_SETUP_NETWORK_NODE     ((NTSTATUS)0xC0000005L)

//
// MessageId: ISCSI_ERR_INSUFFICIENT_CONNECTION_RESOURCES
//
// MessageText:
//
// The initiator could not allocate resources for an iSCSI connection
//
#define ISCSI_ERR_INSUFFICIENT_CONNECTION_RESOURCES ((NTSTATUS)0xC0000006L)

//
// MessageId: ISCSI_ERR_SEND_FAILED
//
// MessageText:
//
// The initiator could not send an iSCSI PDU. Error status is given in the dump data.
//
#define ISCSI_ERR_SEND_FAILED            ((NTSTATUS)0xC0000007L)

//
// MessageId: ISCSI_ERR_ISCSI_REQUEST_TIMEOUT
//
// MessageText:
//
// Target or discovery service did not respond in time for an iSCSI request sent by the initiator. 
// iSCSI Function code is given in the dump data. For details about iSCSI Function code please refer 
// to iSCSI User's Guide.
//
#define ISCSI_ERR_ISCSI_REQUEST_TIMEOUT  ((NTSTATUS)0xC0000008L)

//
// MessageId: ISCSI_ERR_SCSI_REQUEST_TIMEOUT
//
// MessageText:
//
// Target did not respond in time for a SCSI request. The CDB is given in the dump data.
//
#define ISCSI_ERR_SCSI_REQUEST_TIMEOUT   ((NTSTATUS)0xC0000009L)

//
// MessageId: ISCSI_ERR_LOGIN_FAILED
//
// MessageText:
//
// Login request failed. The login response packet is given in the dump data.
//
#define ISCSI_ERR_LOGIN_FAILED           ((NTSTATUS)0xC000000AL)

//
// MessageId: ISCSI_ERR_LOGIN_PDU_ERROR
//
// MessageText:
//
// Target returned an invalid login response packet. The login response packet is given in the dump data.
//
#define ISCSI_ERR_LOGIN_PDU_ERROR        ((NTSTATUS)0xC000000BL)

//
// MessageId: ISCSI_ERR_INVALID_LOGIN_REDIRECT_DATA
//
// MessageText:
//
// Target provided invalid data for login redirect. Dump data contains the data returned by the target.
//
#define ISCSI_ERR_INVALID_LOGIN_REDIRECT_DATA ((NTSTATUS)0xC000000CL)

//
// MessageId: ISCSI_ERR_INVALID_AUTHMETHOD
//
// MessageText:
//
// Target offered an unknown AuthMethod. Dump data contains the data returned by the target.
//
#define ISCSI_ERR_INVALID_AUTHMETHOD     ((NTSTATUS)0xC000000DL)

//
// MessageId: ISCSI_ERR_INVALID_CHAP_ALGORITHM
//
// MessageText:
//
// Target offered an unknown digest algorithm for CHAP. Dump data contains the data returned by the target.
//
#define ISCSI_ERR_INVALID_CHAP_ALGORITHM ((NTSTATUS)0xC000000EL)

//
// MessageId: ISCSI_ERR_INVALID_CHAP_CHALLENGE
//
// MessageText:
//
// CHAP challenge given by the target contains invalid characters. Dump data contains the challenge given.
//
#define ISCSI_ERR_INVALID_CHAP_CHALLENGE ((NTSTATUS)0xC000000FL)

//
// MessageId: ISCSI_ERR_INVALID_KEY_DURING_CHAP
//
// MessageText:
//
// An invalid key was received during CHAP negotiation. The key=value pair is given in the dump data.
//
#define ISCSI_ERR_INVALID_KEY_DURING_CHAP ((NTSTATUS)0xC0000010L)

//
// MessageId: ISCSI_ERR_INVALID_CHAP_RESPONSE
//
// MessageText:
//
// CHAP Response given by the target did not match the expected one. Dump data contains the CHAP response.
//
#define ISCSI_ERR_INVALID_CHAP_RESPONSE  ((NTSTATUS)0xC0000011L)

//
// MessageId: ISCSI_ERR_HEADER_DIGEST_NEEDED
//
// MessageText:
//
// Header Digest is required by the initiator, but target did not offer it.
//
#define ISCSI_ERR_HEADER_DIGEST_NEEDED   ((NTSTATUS)0xC0000012L)

//
// MessageId: ISCSI_ERR_HEADER_DATA_NEEDED
//
// MessageText:
//
// Data Digest is required by the initiator, but target did not offer it.
//
#define ISCSI_ERR_HEADER_DATA_NEEDED     ((NTSTATUS)0xC0000013L)

//
// MessageId: ISCSI_ERR_CONNECTION_LOST
//
// MessageText:
//
// Connection to the target was lost. The initiator will attempt to retry the connection.
//
#define ISCSI_ERR_CONNECTION_LOST        ((NTSTATUS)0xC0000014L)

//
// MessageId: ISCSI_ERR_INVALID_DATA_SEGMENT_LENGTH
//
// MessageText:
//
// Data Segment Length given in the header exceeds MaxRecvDataSegmentLength declared by the target.
//
#define ISCSI_ERR_INVALID_DATA_SEGMENT_LENGTH ((NTSTATUS)0xC0000015L)

//
// MessageId: ISCSI_ERR_HEADER_DIGEST_ERROR
//
// MessageText:
//
// Header digest error was detected for the given PDU. Dump data contains the header and digest.
//
#define ISCSI_ERR_HEADER_DIGEST_ERROR    ((NTSTATUS)0xC0000016L)

//
// MessageId: ISCSI_ERR_ISCSI_PDU_ERROR
//
// MessageText:
//
// Target sent an invalid iSCSI PDU. Dump data contains the entire iSCSI header.
//
#define ISCSI_ERR_ISCSI_PDU_ERROR        ((NTSTATUS)0xC0000017L)

//
// MessageId: ISCSI_ERR_UNKNOWN_ISCSI_OPCODE
//
// MessageText:
//
// Target sent an iSCSI PDU with an invalid opcode. Dump data contains the entire iSCSI header.
//
#define ISCSI_ERR_UNKNOWN_ISCSI_OPCODE   ((NTSTATUS)0xC0000018L)

//
// MessageId: ISCSI_ERR_DATA_DIGEST_ERROR
//
// MessageText:
//
// Data digest error was detected. Dump data contains the calculated checksum followed by the given checksum.
//
#define ISCSI_ERR_DATA_DIGEST_ERROR      ((NTSTATUS)0xC0000019L)

//
// MessageId: ISCSI_ERR_EXCESS_DATA_SENT
//
// MessageText:
//
// Target trying to send more data than requested by the initiator.
//
#define ISCSI_ERR_EXCESS_DATA_SENT       ((NTSTATUS)0xC000001AL)

//
// MessageId: ISCSI_ERR_UNEXPECTED_PDU
//
// MessageText:
//
// Initiator could not find a match for the initiator task tag in the received PDU. Dump data contains the entire iSCSI header.
//
#define ISCSI_ERR_UNEXPECTED_PDU         ((NTSTATUS)0xC000001BL)

//
// MessageId: ISCSI_ERR_INVALID_RTT_PDU
//
// MessageText:
//
// Initiator received an invalid R2T packet. Dump data contains the entire iSCSI header.
//
#define ISCSI_ERR_INVALID_RTT_PDU        ((NTSTATUS)0xC000001CL)

//
// MessageId: ISCSI_ERR_ISCSI_PDU_REJECTED
//
// MessageText:
//
// Target rejected an iSCSI PDU sent by the initiator. Dump data contains the rejected PDU.
//
#define ISCSI_ERR_ISCSI_PDU_REJECTED     ((NTSTATUS)0xC000001DL)

//
// MessageId: ISCSI_ERR_INSUFFICIENT_WORKITEM_RESOURCES
//
// MessageText:
//
// Initiator could not allocate a workitem for processing a request.
//
#define ISCSI_ERR_INSUFFICIENT_WORKITEM_RESOURCES ((NTSTATUS)0xC000001EL)

//
// MessageId: ISCSI_ERR_INSUFFICIENT_REQ_PACKET_RESOURCES
//
// MessageText:
//
// Initiator could not allocate resource for processing a request.
//
#define ISCSI_ERR_INSUFFICIENT_REQ_PACKET_RESOURCES ((NTSTATUS)0xC000001FL)

//
// MessageId: ISCSI_INFO_RECEIVED_ASYNC_LOGOUT
//
// MessageText:
//
// Initiator received an asynchronous logout message. The Target name is given in the dump data.
//
#define ISCSI_INFO_RECEIVED_ASYNC_LOGOUT ((NTSTATUS)0x40000020L)

//
// MessageId: ISCSI_ERR_INVALID_CHAP_CHALLENGE_SIZE
//
// MessageText:
//
// Challenge size given by the target exceeds the maximum specified in iSCSI specification.
//
#define ISCSI_ERR_INVALID_CHAP_CHALLENGE_SIZE ((NTSTATUS)0xC0000021L)

//
// MessageId: ISCSI_INFO_RECONNECTED_TO_TARGET
//
// MessageText:
//
// A connection to the target was lost, but Initiator successfully reconnected to the target. Dump data contains the target name.
//
#define ISCSI_INFO_RECONNECTED_TO_TARGET ((NTSTATUS)0x40000022L)

//
// MessageId: ISCSI_ERR_INVALID_TARGET_CHAP_SECRET
//
// MessageText:
//
// Target CHAP secret is smaller than the minimum size (12 bytes) required by the spec. 
//
#define ISCSI_ERR_INVALID_TARGET_CHAP_SECRET ((NTSTATUS)0xC0000023L)

//
// MessageId: ISCSI_ERR_INVALID_INITIATOR_CHAP_SECRET
//
// MessageText:
//
// Initiator CHAP secret is smaller than the minimum size (12 bytes) required by the spec. Dump data contains the given CHAP secret.
//
#define ISCSI_ERR_INVALID_INITIATOR_CHAP_SECRET ((NTSTATUS)0xC0000024L)

//
// MessageId: ISCSI_ERR_FIPS_NOT_AVAILABLE
//
// MessageText:
//
// FIPS service could not be initialized. Persistent logons will not be processed.
//
#define ISCSI_ERR_FIPS_NOT_AVAILABLE     ((NTSTATUS)0xC0000025L)

//
// MessageId: ISCSI_ERR_CHAP_NOT_OFFERED
//
// MessageText:
//
// Initiator requires CHAP for logon authentication, but target did not offer CHAP.
//
#define ISCSI_ERR_CHAP_NOT_OFFERED       ((NTSTATUS)0xC0000026L)

//
// MessageId: ISCSI_ERR_DEVICE_RESET
//
// MessageText:
//
// Initiator sent a task management command to reset the target. The target name is given in the dump data.
//
#define ISCSI_ERR_DEVICE_RESET           ((NTSTATUS)0xC0000027L)

//
// MessageId: ISCSI_ERR_CHAP_OFFERED
//
// MessageText:
//
// Target requires logon authentication via CHAP, but Initiator is not configured to perform CHAP.
//
#define ISCSI_ERR_CHAP_OFFERED           ((NTSTATUS)0xC0000028L)

//
// MessageId: ISCSI_ERR_AUTH_METHOD_NOT_OFFERED
//
// MessageText:
//
// Target did not send AuthMethod key during security negotiation phase.
//
#define ISCSI_ERR_AUTH_METHOD_NOT_OFFERED ((NTSTATUS)0xC0000029L)

//
// MessageId: ISCSI_ERR_INVALID_STATUS_SEQ_NUM
//
// MessageText:
//
// Target sent an invalid status sequence number for a connection. Dump data contains 
// Expected Status Sequence number followed by the given status sequence number.
//
#define ISCSI_ERR_INVALID_STATUS_SEQ_NUM ((NTSTATUS)0xC000002AL)

//
// MessageId: ISCSI_ERR_LOGIN_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time for a login request.
//
#define ISCSI_ERR_LOGIN_TIMED_OUT        ((NTSTATUS)0xC000002BL)

//
// MessageId: ISCSI_ERR_LOGOUT_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time for a logout request.
//
#define ISCSI_ERR_LOGOUT_TIMED_OUT       ((NTSTATUS)0xC000002CL)

//
// MessageId: ISCSI_ERR_ADDCONNECTION_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time for a login request. This login request was for adding a new connection to a session.
//
#define ISCSI_ERR_ADDCONNECTION_TIMED_OUT ((NTSTATUS)0xC000002DL)

//
// MessageId: ISCSI_ERR_SENDTARGETS_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time for a SendTargets command.
//
#define ISCSI_ERR_SENDTARGETS_TIMED_OUT  ((NTSTATUS)0xC000002EL)

//
// MessageId: ISCSI_ERR_SCSICOMMAND_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time for a SCSI command sent through a WMI request.
//
#define ISCSI_ERR_SCSICOMMAND_TIMED_OUT  ((NTSTATUS)0xC000002FL)

//
// MessageId: ISCSI_ERR_NOP_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time to a NOP request.
//
#define ISCSI_ERR_NOP_TIMED_OUT          ((NTSTATUS)0xC0000030L)

//
// MessageId: ISCSI_ERR_TASKMGMT_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time to a Task Management request.
//
#define ISCSI_ERR_TASKMGMT_TIMED_OUT     ((NTSTATUS)0xC0000031L)

//
// MessageId: ISCSI_ERR_ASYNC_TEXT_CMD_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time to a Text Command sent to renegotiate iSCSI parameters.
//
#define ISCSI_ERR_ASYNC_TEXT_CMD_TIMED_OUT ((NTSTATUS)0xC0000032L)

//
// MessageId: ISCSI_ERR_ASYNC_LOGOUT_TIMED_OUT
//
// MessageText:
//
// Target failed to respond in time to a logout request sent in response to an asynchronous message from the target.
//
#define ISCSI_ERR_ASYNC_LOGOUT_TIMED_OUT ((NTSTATUS)0xC0000033L)

//
// MessageId: ISCSI_ERR_CONFIG_IPSEC_TIMED_OUT
//
// MessageText:
//
// Initiator Service failed to respond in time to a request to configure IPSec resources for an iSCSI connection.
//
#define ISCSI_ERR_CONFIG_IPSEC_TIMED_OUT ((NTSTATUS)0xC0000034L)

//
// MessageId: ISCSI_ERR_RELEASE_IPSEC_TIMED_OUT
//
// MessageText:
//
// Initiator Service failed to respond in time to a request to release IPSec resources allocated for an iSCSI connection.
//
#define ISCSI_ERR_RELEASE_IPSEC_TIMED_OUT ((NTSTATUS)0xC0000035L)

//
// MessageId: ISCSI_ERR_ENCRYPT_DECRYPT_TIMED_OUT
//
// MessageText:
//
// Initiator Service failed to respond in time to a request to encrypt or decrypt data.
//
#define ISCSI_ERR_ENCRYPT_DECRYPT_TIMED_OUT ((NTSTATUS)0xC0000036L)

//
// MessageId: ISCSI_ERR_INSUFFICIENT_RESOURCES_FOR_SEND
//
// MessageText:
//
// Initiator failed to allocate resources to send data to target.
//
#define ISCSI_ERR_INSUFFICIENT_RESOURCES_FOR_SEND ((NTSTATUS)0xC0000037L)

//
// MessageId: ISCSI_ERR_FAILED_TO_GET_SYSTEM_ADDRESS
//
// MessageText:
//
// Initiator could not map an user virtual address to kernel virtual address resulting in I/O failure. 
//
#define ISCSI_ERR_FAILED_TO_GET_SYSTEM_ADDRESS ((NTSTATUS)0xC0000038L)

//
// MessageId: ISCSI_ERR_FAILED_TO_ALLOCATE_RESOURCES_FOR_IO
//
// MessageText:
//
// Initiator could not allocate required resources for processing a request resulting in I/O failure. 
//
#define ISCSI_ERR_FAILED_TO_ALLOCATE_RESOURCES_FOR_IO ((NTSTATUS)0xC0000039L)

//
// MessageId: ISCSI_ERR_FAILED_TO_ALLOCATE_REQUEST_TAG
//
// MessageText:
//
// Initiator could not allocate a tag for processing a request resulting in I/O failure. 
//
#define ISCSI_ERR_FAILED_TO_ALLOCATE_REQUEST_TAG ((NTSTATUS)0xC000003AL)

//
// MessageId: ISCSI_ERR_CONNECTION_DROPPED_BEFORE_FFP
//
// MessageText:
//
// Target dropped the connection before the initiator could transition to Full Feature Phase.
//
#define ISCSI_ERR_CONNECTION_DROPPED_BEFORE_FFP ((NTSTATUS)0xC000003BL)

//
// MessageId: ISCSI_ERR_DATA_SENT_IN_SCSI_RESPONSE
//
// MessageText:
//
// Target sent data in SCSI Response PDU instead of Data_IN PDU. Only Sense Data can be sent in SCSI Response.
//
#define ISCSI_ERR_DATA_SENT_IN_SCSI_RESPONSE ((NTSTATUS)0xC000003CL)

//
// MessageId: ISCSI_ERR_DATA_PDU_IN_ORDER_FALSE
//
// MessageText:
//
// Target set DataPduInOrder to NO when initiator requested YES. Login will be failed.
//
#define ISCSI_ERR_DATA_PDU_IN_ORDER_FALSE ((NTSTATUS)0xC000003DL)

//
// MessageId: ISCSI_ERR_DATA_SEQ_IN_ORDER_FALSE
//
// MessageText:
//
// Target set DataSequenceInOrder to NO when initiator requested YES. Login will be failed.
//
#define ISCSI_ERR_DATA_SEQ_IN_ORDER_FALSE ((NTSTATUS)0xC000003EL)

//
// MessageId: ISCSI_ERR_TOO_MANY_RESET_FAILURE
//
// MessageText:
//
// Can not Reset the Target or LUN. Will attempt session recovery.
//
#define ISCSI_ERR_TOO_MANY_RESET_FAILURE ((NTSTATUS)0xC000003FL)

//
// MessageId: ISCSI_INFO_NIC_BOOT
//
// MessageText:
//
// Attempt to bootstrap Windows using iSCSI NIC Boot (iBF)
//
#define ISCSI_INFO_NIC_BOOT              ((NTSTATUS)0x40000040L)

//
// MessageId: ISCSI_PAGING_IRP_ERROR
//
// MessageText:
//
// Booting from iSCSI, but Could not set any NIC in Paging Path.
//
#define ISCSI_PAGING_IRP_ERROR           ((NTSTATUS)0xC0000041L)

#endif /* _ISCSILOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsimgt.h ===
#ifndef _iscsimgt_h_
#define _iscsimgt_h_

// MSiSCSI_HBAInformation - MSiSCSI_HBAInformation


//***************************************************************************
//
//  iscsimgt.h
// 
//  Module: iScsi Discovery api
//
//  Purpose: Internal header defining interface between user mode discovery
//           api dll and HBA driver miniport.
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#include <iscsidef.h>

//
//
// This class is required.
//
// Adapter Information class. The iSCSI initiator service relies upon this
// class in order to interface with your adapter. Implement one instance
// per adapter instance.
//
// This class must be registered using PDO instance names with a single instance
//

#define MSiSCSI_HBAInformationGuid \
    { 0x58515bf3,0x2f59,0x4f37, { 0xb7,0x4f,0x85,0xae,0xec,0x65,0x2a,0xd6 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_HBAInformation_GUID, \
            0x58515bf3,0x2f59,0x4f37,0xb7,0x4f,0x85,0xae,0xec,0x65,0x2a,0xd6);
#endif


typedef struct _MSiSCSI_HBAInformation
{
    // Id that is globally unique for all instances of iSCSI initiators. Use the address of the Adapter Extension or another address owned by the device driver.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_HBAInformation_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_HBAInformation_UniqueAdapterId_ID 1

    // TRUE if TCP/IP traffic is integrated with the Windows networking TCP/IP stack via a software only initiator. An adapter with its own TCP/IP stack would set this to FALSE.
    BOOLEAN IntegratedTCPIP;
    #define MSiSCSI_HBAInformation_IntegratedTCPIP_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBAInformation_IntegratedTCPIP_ID 2

    // If TRUE the iSCSI Initiator service will perform any DNS lookup and pass binary IP addresses to the adapter; the adapter must be on the same network as the Windows TCP/IP stack. If FALSE then DNS must be available on adapter.
    BOOLEAN RequiresBinaryIpAddresses;
    #define MSiSCSI_HBAInformation_RequiresBinaryIpAddresses_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBAInformation_RequiresBinaryIpAddresses_ID 3

    // Minimum version number of the iScsi spec supported by adapter
    UCHAR VersionMin;
    #define MSiSCSI_HBAInformation_VersionMin_SIZE sizeof(UCHAR)
    #define MSiSCSI_HBAInformation_VersionMin_ID 4

    // Maximum version number of the iSCSI spec supported by adapter
    UCHAR VersionMax;
    #define MSiSCSI_HBAInformation_VersionMax_SIZE sizeof(UCHAR)
    #define MSiSCSI_HBAInformation_VersionMax_ID 5

    // TRUE if this adapter is a multifunction device, that is it also exposes a netcard interface
    BOOLEAN MultifunctionDevice;
    #define MSiSCSI_HBAInformation_MultifunctionDevice_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBAInformation_MultifunctionDevice_ID 6

    // TRUE if the adapter caches are valid
    BOOLEAN CacheValid;
    #define MSiSCSI_HBAInformation_CacheValid_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBAInformation_CacheValid_ID 7

    // Number of ports (or TCP/IP addresses) on the adapter
    ULONG NumberOfPorts;
    #define MSiSCSI_HBAInformation_NumberOfPorts_SIZE sizeof(ULONG)
    #define MSiSCSI_HBAInformation_NumberOfPorts_ID 8


#define ISCSI_HBA_STATUS_WORKING           0
#define ISCSI_HBA_STATUS_DEGRADED          1
#define ISCSI_HBA_STATUS_CRITICAL          2
#define ISCSI_HBA_STATUS_FAILED            3

    // **typedef** Current status of adapter
    ULONG Status;
    #define MSiSCSI_HBAInformation_Status_SIZE sizeof(ULONG)
    #define MSiSCSI_HBAInformation_Status_ID 9



//
// Flags that define the functionality supported by the HBA
//
#define ISCSI_HBA_PRESHARED_KEY_CACHE              0x00000001
#define ISCSI_HBA_ISCSI_AUTHENTICATION_CACHE       0x00000002
#define ISCSI_HBA_IPSEC_TUNNEL_MODE                0x00000004
#define ISCSI_HBA_CHAP_VIA_RADIUS                  0x00000008
#define ISCSI_HBA_ISNS_DISCOVERY                   0x00000010
#define ISCSI_HBA_SLP_DISCOVERY                    0x00000020


    // **typedef** Bit flags that indicate various functionality supported
    ULONG FunctionalitySupported;
    #define MSiSCSI_HBAInformation_FunctionalitySupported_SIZE sizeof(ULONG)
    #define MSiSCSI_HBAInformation_FunctionalitySupported_ID 10

    // This is the GUID value last set by the SetGenerationalGuid method in the MSiSCSI_Operations class.
    UCHAR GenerationalGuid[16];
    #define MSiSCSI_HBAInformation_GenerationalGuid_SIZE sizeof(UCHAR[16])
    #define MSiSCSI_HBAInformation_GenerationalGuid_ID 11

    // Maxumum CDB length supported by the adapter
    ULONG MaxCDBLength;
    #define MSiSCSI_HBAInformation_MaxCDBLength_SIZE sizeof(ULONG)
    #define MSiSCSI_HBAInformation_MaxCDBLength_ID 12

    // TRUE if Bi-directionsal SCSI comamnd supported
    BOOLEAN BiDiScsiCommands;
    #define MSiSCSI_HBAInformation_BiDiScsiCommands_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBAInformation_BiDiScsiCommands_ID 13

    // A text string describing the manufacturer of adapter
    WCHAR VendorID[255 + 1];
    #define MSiSCSI_HBAInformation_VendorID_ID 14

    // A text string set by the manufacturer describing the model of adapter
    WCHAR VendorModel[255 + 1];
    #define MSiSCSI_HBAInformation_VendorModel_ID 15

    // A text string set by the manufacturer describing the version of adapter
    WCHAR VendorVersion[255 + 1];
    #define MSiSCSI_HBAInformation_VendorVersion_ID 16

    // A text string set by the manufacturer describing the firmware version of adapter
    WCHAR FirmwareVersion[255 + 1];
    #define MSiSCSI_HBAInformation_FirmwareVersion_ID 17

    // A text string set by the manufacturer describing the Asic version
    WCHAR AsicVersion[255 + 1];
    #define MSiSCSI_HBAInformation_AsicVersion_ID 18

    // A text string set by the manufacturer describing the option rom version of adapter
    WCHAR OptionRomVersion[255 + 1];
    #define MSiSCSI_HBAInformation_OptionRomVersion_ID 19

    // A text string set by the manufacturer describing the serial number of adapter
    WCHAR SerialNumber[255 + 1];
    #define MSiSCSI_HBAInformation_SerialNumber_ID 20

    // A text string specifying the name of the driver for the adapter
    WCHAR DriverName[255 + 1];
    #define MSiSCSI_HBAInformation_DriverName_ID 21

} MSiSCSI_HBAInformation, *PMSiSCSI_HBAInformation;

// MSiSCSI_HBASessionConfig - MSiSCSI_HBASessionConfig

//
//
// This class is optional.
//
// This class allows the default session configuration to be managed. It 
// contains the default values to use when establishing a session.
//
// This class must be registered using PDO instance names with a single instance
//

#define MSiSCSI_HBASessionConfigGuid \
    { 0xb35694de,0xd323,0x49d2, { 0xab,0xb2,0x81,0x39,0x20,0x9a,0xd1,0x50 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_HBASessionConfig_GUID, \
            0xb35694de,0xd323,0x49d2,0xab,0xb2,0x81,0x39,0x20,0x9a,0xd1,0x50);
#endif


typedef struct _MSiSCSI_HBASessionConfig
{
    // The InitialR2T key is used to turn off the default use of R2T, thus allowing an initiator to start sending data to a target as if it has received an initial R2T with Buffer Offset=0 and Desired Data Transfer Length=min (FirstBurstSize, Expected Data Transfer Length).
    BOOLEAN InitialR2T;
    #define MSiSCSI_HBASessionConfig_InitialR2T_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBASessionConfig_InitialR2T_ID 1

    // The initiator and target negotiate support for immediate data. To turn immediate data off, the initiator or target must state its desire to do so.  ImmediateData can be turned on if both the initiator and target have ImmediateData=Yes.
    BOOLEAN ImmediateData;
    #define MSiSCSI_HBASessionConfig_ImmediateData_SIZE sizeof(BOOLEAN)
    #define MSiSCSI_HBASessionConfig_ImmediateData_ID 2

    // Maximum data segment length in bytes they can receive in an iSCSI PDU.
    ULONG MaxRecvDataSegmentLength;
    #define MSiSCSI_HBASessionConfig_MaxRecvDataSegmentLength_SIZE sizeof(ULONG)
    #define MSiSCSI_HBASessionConfig_MaxRecvDataSegmentLength_ID 3

    // Maximum SCSI data payload in bytes in an Data-In or a solicited Data-Out iSCSI sequence.
    ULONG MaxBurstLength;
    #define MSiSCSI_HBASessionConfig_MaxBurstLength_SIZE sizeof(ULONG)
    #define MSiSCSI_HBASessionConfig_MaxBurstLength_ID 4

    // maximum amount in bytes of unsolicited data an iSCSI initiator may send to the target, during the execution of a single SCSI command. This covers the immediate data (if any) and the sequence of unsolicited Data-Out PDUs (if any) that follow the command.
    ULONG FirstBurstLength;
    #define MSiSCSI_HBASessionConfig_FirstBurstLength_SIZE sizeof(ULONG)
    #define MSiSCSI_HBASessionConfig_FirstBurstLength_ID 5

    // Initiator and target negotiate the maximum number of outstanding R2Ts per task, excluding any implied initial R2T that might be part of that task.  An R2T is considered outstanding until the last data PDU (with the F bit set to 1) is transferred, or a sequence reception timeout (section 6.12.1) is encountered for that data sequence.
    ULONG MaxOutstandingR2T;
    #define MSiSCSI_HBASessionConfig_MaxOutstandingR2T_SIZE sizeof(ULONG)
    #define MSiSCSI_HBASessionConfig_MaxOutstandingR2T_ID 6

} MSiSCSI_HBASessionConfig, *PMSiSCSI_HBASessionConfig;

#define MSiSCSI_HBASessionConfig_SIZE (FIELD_OFFSET(MSiSCSI_HBASessionConfig, MaxOutstandingR2T) + MSiSCSI_HBASessionConfig_MaxOutstandingR2T_SIZE)

// ISCSI_ConnectionStaticInfo - ISCSI_ConnectionStaticInfo
// iSCSI Static Connection Statistics Information
#define ISCSI_ConnectionStaticInfoGuid \
    { 0x3ce2d6a0,0x7346,0x4826, { 0x97,0x2f,0xf2,0xc1,0x97,0x79,0xd1,0xd1 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_ConnectionStaticInfo_GUID, \
            0x3ce2d6a0,0x7346,0x4826,0x97,0x2f,0xf2,0xc1,0x97,0x79,0xd1,0xd1);
#endif


typedef struct _ISCSI_ConnectionStaticInfo
{
    // A uniquely generated connection ID. Do not confuse this with CID.
    ULONGLONG UniqueConnectionId;
    #define ISCSI_ConnectionStaticInfo_UniqueConnectionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_ConnectionStaticInfo_UniqueConnectionId_ID 1

    // The iSCSI connection ID for this connection instance.
    USHORT CID;
    #define ISCSI_ConnectionStaticInfo_CID_SIZE sizeof(USHORT)
    #define ISCSI_ConnectionStaticInfo_CID_ID 2



    //login          - The TCP connection has been established, but a valid iSCSI
    //                    login response with the final bit set has not been sent or received.
    //full            - A valid iSCSI login response with the final bit set 
    //                   has been sent or received.
    //logout       - A valid iSCSI logout command has been sent or received, but
    //                  the TCP connection has not yet been closed.



// login
#define login 0
// full
#define full 1
// logout
#define logout 2

    // **typedef** Indicates the current state of this connection
    UCHAR State;
    #define ISCSI_ConnectionStaticInfo_State_SIZE sizeof(UCHAR)
    #define ISCSI_ConnectionStaticInfo_State_ID 3


// TCP
#define TCP 6

    // **typedef** The transport protocol over which this connection instance is running.
    UCHAR Protocol;
    #define ISCSI_ConnectionStaticInfo_Protocol_SIZE sizeof(UCHAR)
    #define ISCSI_ConnectionStaticInfo_Protocol_ID 4


// None
#define None 0
// crc32c
#define crc32c 1

    // **typedef** The name of the iSCSI header digest scheme in use within this session.
    UCHAR HeaderIntegrity;
    #define ISCSI_ConnectionStaticInfo_HeaderIntegrity_SIZE sizeof(UCHAR)
    #define ISCSI_ConnectionStaticInfo_HeaderIntegrity_ID 5


// None
#define None 0
// crc32c
#define crc32c 1

    // **typedef** The name of the iSCSI data digest scheme in use within this session.
    UCHAR DataIntegrity;
    #define ISCSI_ConnectionStaticInfo_DataIntegrity_SIZE sizeof(UCHAR)
    #define ISCSI_ConnectionStaticInfo_DataIntegrity_ID 6

    // Must be zero
    USHORT Reserved;
    #define ISCSI_ConnectionStaticInfo_Reserved_SIZE sizeof(USHORT)
    #define ISCSI_ConnectionStaticInfo_Reserved_ID 7

    // The maximum data payload size supported for command or data PDUs within this session.
    ULONG MaxRecvDataSegmentLength;
    #define ISCSI_ConnectionStaticInfo_MaxRecvDataSegmentLength_SIZE sizeof(ULONG)
    #define ISCSI_ConnectionStaticInfo_MaxRecvDataSegmentLength_ID 8

    // **typedef** Authentication type used when establishing the connection.
    ULONG AuthType;
    #define ISCSI_ConnectionStaticInfo_AuthType_SIZE sizeof(ULONG)
    #define ISCSI_ConnectionStaticInfo_AuthType_ID 9

    // The local network address used for the connection
    ISCSI_IP_Address LocalAddr;
    #define ISCSI_ConnectionStaticInfo_LocalAddr_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_ConnectionStaticInfo_LocalAddr_ID 10

    // The local port used for the connection
    ULONG LocalPort;
    #define ISCSI_ConnectionStaticInfo_LocalPort_SIZE sizeof(ULONG)
    #define ISCSI_ConnectionStaticInfo_LocalPort_ID 11

    // The remote network address used for the connection
    ISCSI_IP_Address RemoteAddr;
    #define ISCSI_ConnectionStaticInfo_RemoteAddr_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_ConnectionStaticInfo_RemoteAddr_ID 12

    // The remote port used for the connection
    ULONG RemotePort;
    #define ISCSI_ConnectionStaticInfo_RemotePort_SIZE sizeof(ULONG)
    #define ISCSI_ConnectionStaticInfo_RemotePort_ID 13

    // Estimated throughput of the link in bytes per second
    ULONGLONG EstimatedThroughput;
    #define ISCSI_ConnectionStaticInfo_EstimatedThroughput_SIZE sizeof(ULONGLONG)
    #define ISCSI_ConnectionStaticInfo_EstimatedThroughput_ID 14

    // Maximum Datagram size supported by the transport in bytes
    ULONG MaxDatagramSize;
    #define ISCSI_ConnectionStaticInfo_MaxDatagramSize_SIZE sizeof(ULONG)
    #define ISCSI_ConnectionStaticInfo_MaxDatagramSize_ID 15

} ISCSI_ConnectionStaticInfo, *PISCSI_ConnectionStaticInfo;

#define ISCSI_ConnectionStaticInfo_SIZE (FIELD_OFFSET(ISCSI_ConnectionStaticInfo, MaxDatagramSize) + ISCSI_ConnectionStaticInfo_MaxDatagramSize_SIZE)

// ISCSI_SessionStaticInfo - ISCSI_SessionStaticInfo
// iSCSI Static Sessions Statistics Information
#define ISCSI_SessionStaticInfoGuid \
    { 0xb71d2538,0x57e2,0x4228, { 0x88,0x8b,0x1a,0xf9,0xb3,0xbd,0x01,0xcd } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_SessionStaticInfo_GUID, \
            0xb71d2538,0x57e2,0x4228,0x88,0x8b,0x1a,0xf9,0xb3,0xbd,0x01,0xcd);
#endif


typedef struct _ISCSI_SessionStaticInfo
{
    // A uniquely generated session ID, it is the same id returned by the LoginToTarget method.  Do not confuse this with ISID or SSID.
    ULONGLONG UniqueSessionId;
    #define ISCSI_SessionStaticInfo_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_SessionStaticInfo_UniqueSessionId_ID 1

    // Initiator node name used to establish the session
    WCHAR InitiatoriSCSIName[223 + 1];
    #define ISCSI_SessionStaticInfo_InitiatoriSCSIName_ID 2

    // iSCSI node name of the target
    WCHAR TargetiSCSIName[223 + 1];
    #define ISCSI_SessionStaticInfo_TargetiSCSIName_ID 3

    // Target-defined portion of the iSCSI Session ID
    USHORT TSID;
    #define ISCSI_SessionStaticInfo_TSID_SIZE sizeof(USHORT)
    #define ISCSI_SessionStaticInfo_TSID_ID 4

    // Initiator-defined portion of the iSCSI Session ID
    UCHAR ISID[6];
    #define ISCSI_SessionStaticInfo_ISID_SIZE sizeof(UCHAR[6])
    #define ISCSI_SessionStaticInfo_ISID_ID 5

    // If TRUE, the initiator must wait for an R2T before sending data to the target.  If FALSE, the initiator may send data immediately, within limits set by FirstBurstSize and the expected data transfer length of the request.
    BOOLEAN InitialR2t;
    #define ISCSI_SessionStaticInfo_InitialR2t_SIZE sizeof(BOOLEAN)
    #define ISCSI_SessionStaticInfo_InitialR2t_ID 6

    // If TRUE indicates whether the initiator and target have agreed to support immediate commands on this session.
    BOOLEAN ImmediateData;
    #define ISCSI_SessionStaticInfo_ImmediateData_SIZE sizeof(BOOLEAN)
    #define ISCSI_SessionStaticInfo_ImmediateData_ID 7



    // Type of iSCSI session
    // discoverySession      - session is being used only for discovery
    // informationalSession  - session is used for a limited number of scsi commands
    // dataSession           - session is being used as a full feature session
    // bootSession           - session is being used to boot an initiator



// discoverySession
#define discoverySession 0
// informationalSession
#define informationalSession 1
// dataSession
#define dataSession 2
// bootSession
#define bootSession 3

    // **typedef** Type of iSCSI session
    UCHAR Type;
    #define ISCSI_SessionStaticInfo_Type_SIZE sizeof(UCHAR)
    #define ISCSI_SessionStaticInfo_Type_ID 8

    // If FALSE indicates that data PDU Sequences may be transferred in any order.  If TRUE indicates that data PDU sequences must be transferred using continuously increasing offsets, except during error recovery.
    BOOLEAN DataSequenceInOrder;
    #define ISCSI_SessionStaticInfo_DataSequenceInOrder_SIZE sizeof(BOOLEAN)
    #define ISCSI_SessionStaticInfo_DataSequenceInOrder_ID 9

    // If FALSE indicates that data PDUs within sequences may be in any order. If TRUE indicates that data PDUs within sequences must be at continuously increasing addresses, with no gaps or overlay between PDUs.
    BOOLEAN DataPduInOrder;
    #define ISCSI_SessionStaticInfo_DataPduInOrder_SIZE sizeof(BOOLEAN)
    #define ISCSI_SessionStaticInfo_DataPduInOrder_ID 10

    // The level of error recovery negotiated between the initiator and the target.
    UCHAR ErrorRecoveryLevel;
    #define ISCSI_SessionStaticInfo_ErrorRecoveryLevel_SIZE sizeof(UCHAR)
    #define ISCSI_SessionStaticInfo_ErrorRecoveryLevel_ID 11

    // The maximum number of outstanding request-to-transmit (R2T) per task within this session
    ULONG MaxOutstandingR2t;
    #define ISCSI_SessionStaticInfo_MaxOutstandingR2t_SIZE sizeof(ULONG)
    #define ISCSI_SessionStaticInfo_MaxOutstandingR2t_ID 12

    // The maximum length supported for unsolicited data sent within this session
    ULONG FirstBurstLength;
    #define ISCSI_SessionStaticInfo_FirstBurstLength_SIZE sizeof(ULONG)
    #define ISCSI_SessionStaticInfo_FirstBurstLength_ID 13

    // The maximum number of bytes which can be sent within a single sequence of Data-In or Data-Out PDUs
    ULONG MaxBurstLength;
    #define ISCSI_SessionStaticInfo_MaxBurstLength_SIZE sizeof(ULONG)
    #define ISCSI_SessionStaticInfo_MaxBurstLength_ID 14

    // The maximum number of connections that will be allowed within this session
    ULONG MaxConnections;
    #define ISCSI_SessionStaticInfo_MaxConnections_SIZE sizeof(ULONG)
    #define ISCSI_SessionStaticInfo_MaxConnections_ID 15

    // The number of connections that currently belong to this session
    USHORT ConnectionCount;
    #define ISCSI_SessionStaticInfo_ConnectionCount_SIZE sizeof(USHORT)
    #define ISCSI_SessionStaticInfo_ConnectionCount_ID 16

    // List of ISCSI_ConnectionStaticInfo.  ConnectionCount specifies the number of elements in the array. NOTE: This is a variable length array.
    ISCSI_ConnectionStaticInfo ConnectionsList[1];
    #define ISCSI_SessionStaticInfo_ConnectionsList_ID 17

} ISCSI_SessionStaticInfo, *PISCSI_SessionStaticInfo;

// ISCSI_PortalInfo - ISCSI_PortalInfo
// iSCSI Portal Info
#define ISCSI_PortalInfoGuid \
    { 0x4fb9130e,0x1fef,0x4ae6, { 0x9e,0x48,0x77,0x83,0x92,0x04,0xd4,0x13 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_PortalInfo_GUID, \
            0x4fb9130e,0x1fef,0x4ae6,0x9e,0x48,0x77,0x83,0x92,0x04,0xd4,0x13);
#endif


typedef struct _ISCSI_PortalInfo
{
    // An integer used to uniquely identify a paticular port
    ULONG Index;
    #define ISCSI_PortalInfo_Index_SIZE sizeof(ULONG)
    #define ISCSI_PortalInfo_Index_ID 1


// Initiator
#define InitiatorPortals 0
// Target
#define TargetPortals 1

    // **typedef** The type of portal (Initiator or Target) 

    UCHAR PortalType;
    #define ISCSI_PortalInfo_PortalType_SIZE sizeof(UCHAR)
    #define ISCSI_PortalInfo_PortalType_ID 2


// TCP
#define TCP 6

    // The portal's transport protocol
    UCHAR Protocol;
    #define ISCSI_PortalInfo_Protocol_SIZE sizeof(UCHAR)
    #define ISCSI_PortalInfo_Protocol_ID 3

    // 
    UCHAR Reserved1;
    #define ISCSI_PortalInfo_Reserved1_SIZE sizeof(UCHAR)
    #define ISCSI_PortalInfo_Reserved1_ID 4

    // 
    UCHAR Reserved2;
    #define ISCSI_PortalInfo_Reserved2_SIZE sizeof(UCHAR)
    #define ISCSI_PortalInfo_Reserved2_ID 5

    // The portal's network address
    ISCSI_IP_Address IPAddr;
    #define ISCSI_PortalInfo_IPAddr_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_PortalInfo_IPAddr_ID 6

    // The portal's socket number
    ULONG Port;
    #define ISCSI_PortalInfo_Port_SIZE sizeof(ULONG)
    #define ISCSI_PortalInfo_Port_ID 7

    // The portal's aggregation tag
    USHORT PortalTag;
    #define ISCSI_PortalInfo_PortalTag_SIZE sizeof(USHORT)
    #define ISCSI_PortalInfo_PortalTag_ID 8

} ISCSI_PortalInfo, *PISCSI_PortalInfo;

#define ISCSI_PortalInfo_SIZE (FIELD_OFFSET(ISCSI_PortalInfo, PortalTag) + ISCSI_PortalInfo_PortalTag_SIZE)

// MSiSCSI_PortalInfoClass - MSiSCSI_PortalInfoClass
// iScsi Portal Information Class

//
//
// This class is recommended. 
//
// This class exposes portal information.
//
// This class must be registered using PDO instance names with a single instance
//

#define MSiSCSI_PortalInfoClassGuid \
    { 0x84ca6fd6,0xb152,0x4e6a, { 0x88,0x69,0xfd,0xe5,0xe3,0x7b,0x61,0x57 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_PortalInfoClass_GUID, \
            0x84ca6fd6,0xb152,0x4e6a,0x88,0x69,0xfd,0xe5,0xe3,0x7b,0x61,0x57);
#endif


typedef struct _MSiSCSI_PortalInfoClass
{
    // Number of elements in iScsiPortalInfo array
    ULONG PortalInfoCount;
    #define MSiSCSI_PortalInfoClass_PortalInfoCount_SIZE sizeof(ULONG)
    #define MSiSCSI_PortalInfoClass_PortalInfoCount_ID 1

    // Variable length array of iScsiPortalInfo.  PortalInfoCount specifies the number of elements in the array. NOTE: this is a variable length array.
    ISCSI_PortalInfo PortalInformation[1];
    #define MSiSCSI_PortalInfoClass_PortalInformation_ID 2

} MSiSCSI_PortalInfoClass, *PMSiSCSI_PortalInfoClass;

// MSiSCSI_InitiatorSessionInfo - MSiSCSI_InitiatorSessionInfo
// iSCSI Static Initiator Session Information

//
//
// This class is required. 
//
// This class exposes session and connection information on the initiator.
//
// This class should use PDO instance names with a single instance.
//

#define MSiSCSI_InitiatorSessionInfoGuid \
    { 0xd7931411,0x0376,0x4869, { 0xa4,0x91,0x8d,0x67,0x9b,0xfc,0x00,0x4a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_InitiatorSessionInfo_GUID, \
            0xd7931411,0x0376,0x4869,0xa4,0x91,0x8d,0x67,0x9b,0xfc,0x00,0x4a);
#endif


typedef struct _MSiSCSI_InitiatorSessionInfo
{
    // Id that is globally unique to each instance of each adapter. Using the address of the Adapter Extension is a good idea.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_InitiatorSessionInfo_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_InitiatorSessionInfo_UniqueAdapterId_ID 1

    // Number of elements in SessionList array
    ULONG SessionCount;
    #define MSiSCSI_InitiatorSessionInfo_SessionCount_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorSessionInfo_SessionCount_ID 2

    // Variable length array of sessions.  SessionCount specifies the number of elements in the array. NOTE: this is a variable length array.
    ISCSI_SessionStaticInfo SessionsList[1];
    #define MSiSCSI_InitiatorSessionInfo_SessionsList_ID 3

} MSiSCSI_InitiatorSessionInfo, *PMSiSCSI_InitiatorSessionInfo;

// MSiSCSI_InitiatorNodeFailureEvent - MSiSCSI_InitiatorNodeFailureEvent
// iSCSI Initiator Node Failure Event

//
//
// This class is recommended. 
//
// This class fires an event when a node failure occurs.
//
// This class should use PDO instance names with a single instance.
//

#define MSiSCSI_InitiatorNodeFailureEventGuid \
    { 0x1221948a,0x6332,0x4ac2, { 0xaa,0x04,0x26,0x8a,0xab,0xce,0xce,0x4f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_InitiatorNodeFailureEvent_GUID, \
            0x1221948a,0x6332,0x4ac2,0xaa,0x04,0x26,0x8a,0xab,0xce,0xce,0x4f);
#endif


typedef struct _MSiSCSI_InitiatorNodeFailureEvent
{
    // Timestamp denoting time failure occured
    ULONGLONG FailureTime;
    #define MSiSCSI_InitiatorNodeFailureEvent_FailureTime_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_InitiatorNodeFailureEvent_FailureTime_ID 1


// LoginOtherFail
#define LoginOtherFail 0
// LoginAuthFail
#define LoginAuthFail 1
// LoginAuthenticateFail
#define LoginAuthenticateFail 2
// LoginNegotiateFail
#define LoginNegotiateFail 3
// LogoutOthers
#define LogoutOthers 4

    // **typedef** Types of initiator node failure
    UCHAR FailureType;
    #define MSiSCSI_InitiatorNodeFailureEvent_FailureType_SIZE sizeof(UCHAR)
    #define MSiSCSI_InitiatorNodeFailureEvent_FailureType_ID 2

    // Name of target involved in failure
    WCHAR TargetFailureName[223 + 1];
    #define MSiSCSI_InitiatorNodeFailureEvent_TargetFailureName_ID 3

    // Network address of target involved in failure
    ISCSI_IP_Address TargetFailureAddr;
    #define MSiSCSI_InitiatorNodeFailureEvent_TargetFailureAddr_SIZE sizeof(ISCSI_IP_Address)
    #define MSiSCSI_InitiatorNodeFailureEvent_TargetFailureAddr_ID 4

} MSiSCSI_InitiatorNodeFailureEvent, *PMSiSCSI_InitiatorNodeFailureEvent;

#define MSiSCSI_InitiatorNodeFailureEvent_SIZE (FIELD_OFFSET(MSiSCSI_InitiatorNodeFailureEvent, TargetFailureAddr) + MSiSCSI_InitiatorNodeFailureEvent_TargetFailureAddr_SIZE)

// MSiSCSI_InitiatorInstanceFailureEvent - MSiSCSI_InitiatorInstanceFailureEvent
// iSCSI Initiator Instance Failure Event

//
//
// This class is recommended. 
//
// This class fires an event when an initiator failure occurs.
//
// This class should use PDO instance names with a single instance.
//

#define MSiSCSI_InitiatorInstanceFailureEventGuid \
    { 0xe67e1bdb,0xd130,0x4143, { 0x9e,0xb2,0x8b,0xee,0x18,0x99,0xfd,0x52 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_InitiatorInstanceFailureEvent_GUID, \
            0xe67e1bdb,0xd130,0x4143,0x9e,0xb2,0x8b,0xee,0x18,0x99,0xfd,0x52);
#endif


typedef struct _MSiSCSI_InitiatorInstanceFailureEvent
{

// SessionDigestError
#define SessionDigestError 0
// SessionCxnTimeoutError
#define SessionCxnTimeoutError 1
// SessionFormatError
#define SessionFormatError 2

    // **typedef** Type of failure
    UCHAR FailureType;
    #define MSiSCSI_InitiatorInstanceFailureEvent_FailureType_SIZE sizeof(UCHAR)
    #define MSiSCSI_InitiatorInstanceFailureEvent_FailureType_ID 1

    // Name of target involved in failure
    WCHAR RemoteNodeName[223 + 1];
    #define MSiSCSI_InitiatorInstanceFailureEvent_RemoteNodeName_ID 2

} MSiSCSI_InitiatorInstanceFailureEvent, *PMSiSCSI_InitiatorInstanceFailureEvent;

// ISCSI_Path - ISCSI_Path
// This class describes an iSCSI Path (A TCP Connection to the target)
#define ISCSI_PathGuid \
    { 0xc8775641,0x5430,0x4220, { 0xba,0x25,0x7d,0xa5,0x61,0xcb,0x64,0xce } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_Path_GUID, \
            0xc8775641,0x5430,0x4220,0xba,0x25,0x7d,0xa5,0x61,0xcb,0x64,0xce);
#endif


typedef struct _ISCSI_Path
{
    // iSCSI Unique connection id
    ULONGLONG UniqueConnectionId;
    #define ISCSI_Path_UniqueConnectionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_Path_UniqueConnectionId_ID 1

    // Estimated speed of the connection in MegaBits Per Second
    ULONGLONG EstimatedLinkSpeed;
    #define ISCSI_Path_EstimatedLinkSpeed_SIZE sizeof(ULONGLONG)
    #define ISCSI_Path_EstimatedLinkSpeed_ID 2

    // Weight assigned to the path
    ULONG PathWeight;
    #define ISCSI_Path_PathWeight_SIZE sizeof(ULONG)
    #define ISCSI_Path_PathWeight_ID 3

    // Flag set to 1 if the path is a primary path, 0 otherwise.
    ULONG PrimaryPath;
    #define ISCSI_Path_PrimaryPath_SIZE sizeof(ULONG)
    #define ISCSI_Path_PrimaryPath_ID 4


// Connected
#define CONNECTION_STATE_CONNECTED 1
// Disconnected
#define CONNECTION_STATE_DISCONNECTED 2
// Reconnecting
#define CONNECTION_STATE_RECONNECTING 3

    // Status of the path - connected, disconnected, reconnecting
    ULONG ConnectionStatus;
    #define ISCSI_Path_ConnectionStatus_SIZE sizeof(ULONG)
    #define ISCSI_Path_ConnectionStatus_ID 5

    // Flag set to 1 if TCP offload is supported for this connection, 0 otherwise.
    ULONG TCPOffLoadAvailable;
    #define ISCSI_Path_TCPOffLoadAvailable_SIZE sizeof(ULONG)
    #define ISCSI_Path_TCPOffLoadAvailable_ID 6

} ISCSI_Path, *PISCSI_Path;

#define ISCSI_Path_SIZE (FIELD_OFFSET(ISCSI_Path, TCPOffLoadAvailable) + ISCSI_Path_TCPOffLoadAvailable_SIZE)

// ISCSI_Supported_LB_Policies - ISCSI_Supported_LB_Policies
// iSCSI Initiator Load Balance Policies supported
#define ISCSI_Supported_LB_PoliciesGuid \
    { 0x749afe4d,0x804d,0x4662, { 0xa6,0x8b,0xdc,0x69,0x66,0x55,0xc7,0x9a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_Supported_LB_Policies_GUID, \
            0x749afe4d,0x804d,0x4662,0xa6,0x8b,0xdc,0x69,0x66,0x55,0xc7,0x9a);
#endif


typedef struct _ISCSI_Supported_LB_Policies
{
    // Id that is unique to this session within this adapter. 
    ULONGLONG UniqueSessionId;
    #define ISCSI_Supported_LB_Policies_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_Supported_LB_Policies_UniqueSessionId_ID 1


// Fail Over Only
#define MSiSCSI_LB_FAILOVER 1
// Round Robin
#define MSiSCSI_LB_ROUND_ROBIN 2
// Round Robin with Subset
#define MSiSCSI_LB_ROUND_ROBIN_WITH_SUBSET 3
// Dynamic Least Queue Depth
#define MSiSCSI_LB_DYN_LEAST_QUEUE_DEPTH 4
// Weighted Paths
#define MSiSCSI_LB_WEIGHTED_PATHS 5
// Vendor Specific
#define MSiSCSI_LB_VENDOR_SPECIFIC 6

    // Load Balance policy supported by the iSCSI Initiator
    ULONG LoadBalancePolicy;
    #define ISCSI_Supported_LB_Policies_LoadBalancePolicy_SIZE sizeof(ULONG)
    #define ISCSI_Supported_LB_Policies_LoadBalancePolicy_ID 2

    // Number of entries in MSiSCSI_Paths array
    ULONG iSCSI_PathCount;
    #define ISCSI_Supported_LB_Policies_iSCSI_PathCount_SIZE sizeof(ULONG)
    #define ISCSI_Supported_LB_Policies_iSCSI_PathCount_ID 3

    // Describes iSCSI Initiator Paths
    ISCSI_Path iSCSI_Paths[1];
    #define ISCSI_Supported_LB_Policies_iSCSI_Paths_ID 4

} ISCSI_Supported_LB_Policies, *PISCSI_Supported_LB_Policies;

// MSiSCSI_LB_Operations - MSiSCSI_LB_Operations
// Set iSCSI Initiator Load Balance Policies
#define MSiSCSI_LB_OperationsGuid \
    { 0xa7dfe761,0xb6bc,0x4490, { 0x91,0xb0,0xd9,0xcf,0x4a,0x24,0xd3,0x7c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_LB_Operations_GUID, \
            0xa7dfe761,0xb6bc,0x4490,0x91,0xb0,0xd9,0xcf,0x4a,0x24,0xd3,0x7c);
#endif

//
// Method id definitions for MSiSCSI_LB_Operations

//
// SetLoadBalancePolicy instructs the iSCSI Initiator what Load Balance
// policy to use.
//

#define SetLoadBalancePolicy     10
typedef struct _SetLoadBalancePolicy_IN
{
    // New Load Balance policy to be set
    ISCSI_Supported_LB_Policies LoadBalancePolicies;
    #define SetLoadBalancePolicy_IN_LoadBalancePolicies_SIZE sizeof(ISCSI_Supported_LB_Policies)
    #define SetLoadBalancePolicy_IN_LoadBalancePolicies_ID 1

} SetLoadBalancePolicy_IN, *PSetLoadBalancePolicy_IN;

#define SetLoadBalancePolicy_IN_SIZE (FIELD_OFFSET(SetLoadBalancePolicy_IN, LoadBalancePolicies) + SetLoadBalancePolicy_IN_LoadBalancePolicies_SIZE)

typedef struct _SetLoadBalancePolicy_OUT
{
    // Status of the operation
    ULONG Status;
    #define SetLoadBalancePolicy_OUT_Status_SIZE sizeof(ULONG)
    #define SetLoadBalancePolicy_OUT_Status_ID 2

} SetLoadBalancePolicy_OUT, *PSetLoadBalancePolicy_OUT;

#define SetLoadBalancePolicy_OUT_SIZE (FIELD_OFFSET(SetLoadBalancePolicy_OUT, Status) + SetLoadBalancePolicy_OUT_Status_SIZE)


// MSiSCSI_QueryLBPolicy - MSiSCSI_QueryLBPolicy
// Query Load Balance policy used by iSCSI Initiator

//
// MSiSCSI_QueryLBPolicy class is used to query the Initiator about
// the load balance policy that is currently used.
//

#define MSiSCSI_QueryLBPolicyGuid \
    { 0xe0aecaee,0xb311,0x426f, { 0xb6,0x7a,0x18,0xd5,0xe5,0x5d,0x09,0x96 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_QueryLBPolicy_GUID, \
            0xe0aecaee,0xb311,0x426f,0xb6,0x7a,0x18,0xd5,0xe5,0x5d,0x09,0x96);
#endif


typedef struct _MSiSCSI_QueryLBPolicy
{
    // Id that is globally unique to each instance of each adapter. Using the address of the Adapter Extension is a good idea.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_QueryLBPolicy_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QueryLBPolicy_UniqueAdapterId_ID 1

    // 
    ULONG Reserved;
    #define MSiSCSI_QueryLBPolicy_Reserved_SIZE sizeof(ULONG)
    #define MSiSCSI_QueryLBPolicy_Reserved_ID 2



    // Number of elements in LoadBalancePolicies array

    // Number of elements in LoadBalancePolicies array
    ULONG SessionCount;
    #define MSiSCSI_QueryLBPolicy_SessionCount_SIZE sizeof(ULONG)
    #define MSiSCSI_QueryLBPolicy_SessionCount_ID 3

    // Load Balance Policy that is currently being used by iSCSI Initiator - one element for each session on the adapter
    ISCSI_Supported_LB_Policies LoadBalancePolicies[1];
    #define MSiSCSI_QueryLBPolicy_LoadBalancePolicies_ID 4

} MSiSCSI_QueryLBPolicy, *PMSiSCSI_QueryLBPolicy;

// MSiSCSI_Eventlog - MSiSCSI_Eventlog
// iSCSI Eventlog generation event

//
// Miniports can fire this event to cause eventlog entries to be
// included in the system eventlog. This is useful as the iscsilog.h
// header has many iSCSI specific eventlog messages that are useful for
// troubleshooting, but can't be fired directly by a miniport. By
// firing this WMI event appropriately a miniport can cause a useful
// eventlog entry to be included in the system eventlog
//

#define MSiSCSI_EventlogGuid \
    { 0xe6b8552b,0x7c62,0x4c6e, { 0x99,0xeb,0x67,0xce,0x60,0x87,0x89,0x4c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_Eventlog_GUID, \
            0xe6b8552b,0x7c62,0x4c6e,0x99,0xeb,0x67,0xce,0x60,0x87,0x89,0x4c);
#endif


typedef struct _MSiSCSI_Eventlog
{
    // Type of eventlog message
    ULONG Type;
    #define MSiSCSI_Eventlog_Type_SIZE sizeof(ULONG)
    #define MSiSCSI_Eventlog_Type_ID 1

    // If zero then this event is not logged to system eventlog
    ULONG LogToEventlog;
    #define MSiSCSI_Eventlog_LogToEventlog_SIZE sizeof(ULONG)
    #define MSiSCSI_Eventlog_LogToEventlog_ID 2

    // Size of Additional Data
    ULONG Size;
    #define MSiSCSI_Eventlog_Size_SIZE sizeof(ULONG)
    #define MSiSCSI_Eventlog_Size_ID 3

    // Additional data to include in eventlog message, typically iSCSI Header
    UCHAR AdditionalData[1];
    #define MSiSCSI_Eventlog_AdditionalData_ID 4

} MSiSCSI_Eventlog, *PMSiSCSI_Eventlog;

// ISCSI_RedirectPortalInfo - ISCSI_RedirectPortalInfo
// iSCSI Redirect Portal Info
#define ISCSI_RedirectPortalInfoGuid \
    { 0xf6004ce6,0x9507,0x4d86, { 0xae,0x1e,0xe9,0xd6,0x4f,0x16,0x6f,0x2f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_RedirectPortalInfo_GUID, \
            0xf6004ce6,0x9507,0x4d86,0xae,0x1e,0xe9,0xd6,0x4f,0x16,0x6f,0x2f);
#endif


typedef struct _ISCSI_RedirectPortalInfo
{
    // A uniquely generated connection ID. Do not confuse this with CID.
    ULONGLONG UniqueConnectionId;
    #define ISCSI_RedirectPortalInfo_UniqueConnectionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_RedirectPortalInfo_UniqueConnectionId_ID 1

    // Original Target IP Address given in the login
    ISCSI_IP_Address OriginalIPAddr;
    #define ISCSI_RedirectPortalInfo_OriginalIPAddr_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_RedirectPortalInfo_OriginalIPAddr_ID 2

    // Original Target portal's socket number given in the login
    ULONG OriginalPort;
    #define ISCSI_RedirectPortalInfo_OriginalPort_SIZE sizeof(ULONG)
    #define ISCSI_RedirectPortalInfo_OriginalPort_ID 3

    // Redirected Target IP Address
    ISCSI_IP_Address RedirectedIPAddr;
    #define ISCSI_RedirectPortalInfo_RedirectedIPAddr_SIZE sizeof(ISCSI_IP_Address)
    #define ISCSI_RedirectPortalInfo_RedirectedIPAddr_ID 4

    // Redirected Target portal's socket number
    ULONG RedirectedPort;
    #define ISCSI_RedirectPortalInfo_RedirectedPort_SIZE sizeof(ULONG)
    #define ISCSI_RedirectPortalInfo_RedirectedPort_ID 5

    // TRUE if login was redirected. RedirectedIPAddr and RedirectedPort are valid then.
    UCHAR Redirected;
    #define ISCSI_RedirectPortalInfo_Redirected_SIZE sizeof(UCHAR)
    #define ISCSI_RedirectPortalInfo_Redirected_ID 6

    // TRUE if the redirection is temporary. FALSE otherwise
    UCHAR TemporaryRedirect;
    #define ISCSI_RedirectPortalInfo_TemporaryRedirect_SIZE sizeof(UCHAR)
    #define ISCSI_RedirectPortalInfo_TemporaryRedirect_ID 7

} ISCSI_RedirectPortalInfo, *PISCSI_RedirectPortalInfo;

#define ISCSI_RedirectPortalInfo_SIZE (FIELD_OFFSET(ISCSI_RedirectPortalInfo, TemporaryRedirect) + ISCSI_RedirectPortalInfo_TemporaryRedirect_SIZE)

// ISCSI_RedirectSessionInfo - ISCSI_RedirectSessionInfo
// iSCSI Redirect Session Info
#define ISCSI_RedirectSessionInfoGuid \
    { 0xed60bc3f,0x3d56,0x42f0, { 0xb4,0xd0,0x81,0xdd,0x16,0xe2,0x85,0x15 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_RedirectSessionInfo_GUID, \
            0xed60bc3f,0x3d56,0x42f0,0xb4,0xd0,0x81,0xdd,0x16,0xe2,0x85,0x15);
#endif


typedef struct _ISCSI_RedirectSessionInfo
{
    // A uniquely generated session ID, it is the same id returned by the LoginToTarget method.  Do not confuse this with ISID or SSID.
    ULONGLONG UniqueSessionId;
    #define ISCSI_RedirectSessionInfo_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ISCSI_RedirectSessionInfo_UniqueSessionId_ID 1

    // Target portal group tag for this Session 
    ULONG TargetPortalGroupTag;
    #define ISCSI_RedirectSessionInfo_TargetPortalGroupTag_SIZE sizeof(ULONG)
    #define ISCSI_RedirectSessionInfo_TargetPortalGroupTag_ID 2



    // Number of elements in RedirectPortalList array

    // Number of elements in RedirectPortalList array
    ULONG ConnectionCount;
    #define ISCSI_RedirectSessionInfo_ConnectionCount_SIZE sizeof(ULONG)
    #define ISCSI_RedirectSessionInfo_ConnectionCount_ID 3

    // Redirect portal info - one element for each connection in the session
    ISCSI_RedirectPortalInfo RedirectPortalList[1];
    #define ISCSI_RedirectSessionInfo_RedirectPortalList_ID 4

} ISCSI_RedirectSessionInfo, *PISCSI_RedirectSessionInfo;

// MSiSCSI_RedirectPortalInfoClass - MSiSCSI_RedirectPortalInfoClass
// iScsi Redirect Portal Information Class

//
//
// This class is recommended. 
//
// This class exposes portal information. It provides the original and 
// redirected target portal information for an iSCSI Connection.
//
// This class must be registered using PDO instance names with a single instance
//

#define MSiSCSI_RedirectPortalInfoClassGuid \
    { 0xdaf7f63a,0xf9ea,0x4869, { 0x87,0xe1,0xae,0x8a,0x7c,0x22,0x61,0xe2 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_RedirectPortalInfoClass_GUID, \
            0xdaf7f63a,0xf9ea,0x4869,0x87,0xe1,0xae,0x8a,0x7c,0x22,0x61,0xe2);
#endif


typedef struct _MSiSCSI_RedirectPortalInfoClass
{
    // Id that is globally unique for all instances of iSCSI initiators.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_RedirectPortalInfoClass_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_RedirectPortalInfoClass_UniqueAdapterId_ID 1

    // Number of elements in RedirectSessionInfo array
    ULONG SessionCount;
    #define MSiSCSI_RedirectPortalInfoClass_SessionCount_SIZE sizeof(ULONG)
    #define MSiSCSI_RedirectPortalInfoClass_SessionCount_ID 2

    // Variable length array of ISCSI_RedirectSessionInfo. SessionCount specifies the number of elements in the array. NOTE: this is a variable length array.
    ISCSI_RedirectSessionInfo RedirectSessionList[1];
    #define MSiSCSI_RedirectPortalInfoClass_RedirectSessionList_ID 3

} MSiSCSI_RedirectPortalInfoClass, *PMSiSCSI_RedirectPortalInfoClass;

// MSiSCSI_ManagementOperations - MSiSCSI_ManagementOperations


//
//
// This class is recommended.
//
// iSCSI management applications rely upon this
// class in order to interface with the adapter. Implement one instance
// per miniport instance (adapter). 
//
// This class must be registered using PDO instance names with a single instance.
//

#define MSiSCSI_ManagementOperationsGuid \
    { 0xb8d765f0,0x2d93,0x4da2, { 0x81,0x86,0xa1,0x87,0x62,0x2b,0x43,0x02 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_ManagementOperations_GUID, \
            0xb8d765f0,0x2d93,0x4da2,0x81,0x86,0xa1,0x87,0x62,0x2b,0x43,0x02);
#endif

//
// Method id definitions for MSiSCSI_ManagementOperations

//
// This method is recommended.
//
// Ping will perform ICMP ping requests to the destination address 
// and return the number of ping responses received. This is only supported
// by some HBA, use the ping command for the software initiator.
//

#define PingIPAddress     10
typedef struct _PingIPAddress_IN
{
    // Number of requests to send
    ULONG RequestCount;
    #define PingIPAddress_IN_RequestCount_SIZE sizeof(ULONG)
    #define PingIPAddress_IN_RequestCount_ID 1

    // Number of bytes in each request
    ULONG RequestSize;
    #define PingIPAddress_IN_RequestSize_SIZE sizeof(ULONG)
    #define PingIPAddress_IN_RequestSize_ID 2

    // Number of ms to wait for response
    ULONG Timeout;
    #define PingIPAddress_IN_Timeout_SIZE sizeof(ULONG)
    #define PingIPAddress_IN_Timeout_ID 3

    // IP address to ping
    ISCSI_IP_Address Address;
    #define PingIPAddress_IN_Address_SIZE sizeof(ISCSI_IP_Address)
    #define PingIPAddress_IN_Address_ID 4

} PingIPAddress_IN, *PPingIPAddress_IN;

#define PingIPAddress_IN_SIZE (FIELD_OFFSET(PingIPAddress_IN, Address) + PingIPAddress_IN_Address_SIZE)

typedef struct _PingIPAddress_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define PingIPAddress_OUT_Status_SIZE sizeof(ULONG)
    #define PingIPAddress_OUT_Status_ID 5

    // Number of responses received
    ULONG ResponsesReceived;
    #define PingIPAddress_OUT_ResponsesReceived_SIZE sizeof(ULONG)
    #define PingIPAddress_OUT_ResponsesReceived_ID 6

} PingIPAddress_OUT, *PPingIPAddress_OUT;

#define PingIPAddress_OUT_SIZE (FIELD_OFFSET(PingIPAddress_OUT, ResponsesReceived) + PingIPAddress_OUT_ResponsesReceived_SIZE)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\lmstats.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmstats.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetStatistics

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSTATS_
#define _LMSTATS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - Statistics
//

NET_API_STATUS NET_API_FUNCTION
NetStatisticsGet (
    __in        LPTSTR  ServerName,
    __in        LPTSTR  Service,
    __in        DWORD   Level,
    __in        DWORD   Options,
    __deref_out LPBYTE *Buffer
    );

//
// Data Structures - Statistics
//

#ifdef LM20_WORKSTATION_STATISTICS
typedef struct _STAT_WORKSTATION_0 {
     DWORD          stw0_start;
     DWORD          stw0_numNCB_r;
     DWORD          stw0_numNCB_s;
     DWORD          stw0_numNCB_a;
     DWORD          stw0_fiNCB_r;
     DWORD          stw0_fiNCB_s;
     DWORD          stw0_fiNCB_a;
     DWORD          stw0_fcNCB_r;
     DWORD          stw0_fcNCB_s;
     DWORD          stw0_fcNCB_a;
     DWORD          stw0_sesstart;
     DWORD          stw0_sessfailcon;
     DWORD          stw0_sessbroke;
     DWORD          stw0_uses;
     DWORD          stw0_usefail;
     DWORD          stw0_autorec;
     DWORD          stw0_bytessent_r_lo;
     DWORD          stw0_bytessent_r_hi;
     DWORD          stw0_bytesrcvd_r_lo;
     DWORD          stw0_bytesrcvd_r_hi;
     DWORD          stw0_bytessent_s_lo;
     DWORD          stw0_bytessent_s_hi;
     DWORD          stw0_bytesrcvd_s_lo;
     DWORD          stw0_bytesrcvd_s_hi;
     DWORD          stw0_bytessent_a_lo;
     DWORD          stw0_bytessent_a_hi;
     DWORD          stw0_bytesrcvd_a_lo;
     DWORD          stw0_bytesrcvd_a_hi;
     DWORD          stw0_reqbufneed;
     DWORD          stw0_bigbufneed;
} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#else

//
// NB: The following structure is REDIR_STATISTICS in sdk\inc\ntddnfs.h. If you
//     change the structure, change it in both places
//

typedef struct _STAT_WORKSTATION_0 {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    DWORD           InitiallyFailedOperations;
    DWORD           FailedCompletionOperations;

    DWORD           ReadOperations;
    DWORD           RandomReadOperations;
    DWORD           ReadSmbs;
    DWORD           LargeReadSmbs;
    DWORD           SmallReadSmbs;

    DWORD           WriteOperations;
    DWORD           RandomWriteOperations;
    DWORD           WriteSmbs;
    DWORD           LargeWriteSmbs;
    DWORD           SmallWriteSmbs;

    DWORD           RawReadsDenied;
    DWORD           RawWritesDenied;

    DWORD           NetworkErrors;

    //  Connection/Session counts
    DWORD           Sessions;
    DWORD           FailedSessions;
    DWORD           Reconnects;
    DWORD           CoreConnects;
    DWORD           Lanman20Connects;
    DWORD           Lanman21Connects;
    DWORD           LanmanNtConnects;
    DWORD           ServerDisconnects;
    DWORD           HungSessions;
    DWORD           UseCount;
    DWORD           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    DWORD           CurrentCommands;

} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#endif

typedef struct _STAT_SERVER_0 {
     DWORD          sts0_start;
     DWORD          sts0_fopens;
     DWORD          sts0_devopens;
     DWORD          sts0_jobsqueued;
     DWORD          sts0_sopens;
     DWORD          sts0_stimedout;
     DWORD          sts0_serrorout;
     DWORD          sts0_pwerrors;
     DWORD          sts0_permerrors;
     DWORD          sts0_syserrors;
     DWORD          sts0_bytessent_low;
     DWORD          sts0_bytessent_high;
     DWORD          sts0_bytesrcvd_low;
     DWORD          sts0_bytesrcvd_high;
     DWORD          sts0_avresponse;
     DWORD          sts0_reqbufneed;
     DWORD          sts0_bigbufneed;
} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;


//
// Special Values and Constants
//

#define STATSOPT_CLR    1
#define STATS_NO_VALUE  ((unsigned long) -1L)
#define STATS_OVERFLOW  ((unsigned long) -2L)


#ifdef __cplusplus
}
#endif

#endif // _LMSTATS.H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\lmuseflg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuseflg.h

Abstract:

    This file contains deletion force levels for deleting a connection.

Environment:

    User Mode - Win32

Notes:

    This file has no dependencies.  It is included by lmwksta.h and
    lmuse.h.

Revision History:

--*/

#ifndef _LMUSEFLG_
#define _LMUSEFLG_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Definition for NetWkstaTransportDel and NetUseDel deletion force levels
//

#define USE_NOFORCE             0
#define USE_FORCE               1
#define USE_LOTS_OF_FORCE       2


#endif // _LMUSEFLG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\kbdmou.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kbdmou.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver, mouse class driver, and keyboard/mouse port
    driver.

Author:

    lees

Revision History:

--*/

#ifndef _KBDMOU_
#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

//
// Define the keyboard/mouse port device name strings.
//

#define DD_KEYBOARD_PORT_DEVICE_NAME    "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U   L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME     "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U  L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U    L"PointerPort"

//
// Define the keyboard/mouse class device name strings.
//

#define DD_KEYBOARD_CLASS_BASE_NAME_U   L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U    L"PointerClass"

//
// Define the keyboard/mouse resource class names.
//

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

//
// Define the maximum number of pointer/keyboard port names the port driver
// will use in an attempt to IoCreateDevice.
//

#define POINTER_PORTS_MAXIMUM  8
#define KEYBOARD_PORTS_MAXIMUM 8

//
// Define the port connection data structure.
//

typedef struct _CONNECT_DATA {
    IN PDEVICE_OBJECT ClassDeviceObject;
    IN PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

//
// Define the service callback routine's structure.
//

typedef
VOID
(*PSERVICE_CALLBACK_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN OUT PVOID SystemArgument3
    );

//
// WMI structures returned by port drivers
//
#include <wmidata.h>

//
// NtDeviceIoControlFile internal IoControlCode values for keyboard device.
//

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_ENABLE  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISABLE CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile internal IoControlCode values for mouse device.
//


#define IOCTL_INTERNAL_MOUSE_CONNECT    CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISCONNECT CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_ENABLE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISABLE    CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Error log definitions (specific to the keyboard/mouse) for DumpData[0]
// in the IO_ERROR_LOG_PACKET.
//
//     DumpData[1] <= hardware port/register
//     DumpData[2] <= {command byte || expected response byte}
//     DumpData[3] <= {command's parameter byte || actual response byte}
//
//

#define KBDMOU_COULD_NOT_SEND_COMMAND  0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM    0x0001
#define KBDMOU_NO_RESPONSE             0x0002
#define KBDMOU_INCORRECT_RESPONSE      0x0004

//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define I8042_ERROR_VALUE_BASE        1000
#define INPORT_ERROR_VALUE_BASE       2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE 3000

#endif // _KBDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ksi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksi.h

Abstract:

    Windows Driver Model/Connection and Streaming Architecture (WDM-CSA)
    core internal definitions.

--*/

#if !defined(_KSI_)
#define _KSI_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#if defined(_NTDDK_)

typedef struct {
    LONGLONG Frequency;
    LONGLONG LastDueTime;
    LONGLONG RunningTimeDelta;
    LONGLONG LastRunningTime;
    KSPIN_LOCK TimeAccessLock;
    LIST_ENTRY EventQueue;
    KSPIN_LOCK EventQueueLock;
    KTIMER QueueTimer;
    KDPC QueueDpc;
    LONG ReferenceCount;
    KSSTATE State;
    LONGLONG SuspendDelta;
    LONGLONG SuspendTime;
    PFNKSSETTIMER SetTimer;
    PFNKSCANCELTIMER CancelTimer;
    PFNKSCLOCK_CORRELATEDTIME CorrelatedTime;
    PVOID Context;
    KSRESOLUTION Resolution;
    KEVENT FreeEvent;
    LONG ExternalTimeReferenceCount;
    BOOLEAN ExternalTimeValid;
    LONGLONG LastStreamTime;
} KSIDEFAULTCLOCK, *PKSIDEFAULTCLOCK;

typedef struct {
    KSOBJECT_HEADER Header;
    PKSIDEFAULTCLOCK DefaultClock;
    ULONG Reserved;
} KSCLOCKINSTANCE, *PKSCLOCKINSTANCE;

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiDefaultClockAddMarkEvent(
    IN PIRP Irp,
    IN PKSEVENT_TIME_INTERVAL EventTime,
    IN PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
BOOLEAN
NTAPI
KsiQueryObjectCreateItemsPresent(
    IN KSDEVICE_HEADER Header
    );

#endif // !defined(_NTDDK_)

#define STATIC_KSNAME_Server\
    0x3C0D501AL, 0x140B, 0x11D1, 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3C0D501A-140B-11D1-B40F-00A0C9223196", KSNAME_Server);
#define KSNAME_Server DEFINE_GUIDNAMED(KSNAME_Server)

#define KSSTRING_Server L"{3C0D501A-140B-11D1-B40F-00A0C9223196}"

#define STATIC_KSPROPSETID_Service \
    0x3C0D501BL, 0x140B, 0x11D1, 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3C0D501B-140B-11D1-B40F-00A0C9223196", KSPROPSETID_Service);
#define KSPROPSETID_Service DEFINE_GUIDNAMED(KSPROPSETID_Service)

typedef enum {
    KSPROPERTY_SERVICE_BUILDCACHE,
    KSPROPERTY_SERVICE_MERIT
} KSPROPERTY_SERVICE;

#define DEFINE_KSPROPERTY_ITEM_SERVICE_BUILDCACHE(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_SERVICE_BUILDCACHE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(L"\\\\?\\"),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_SERVICE_MERIT(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_SERVICE_MERIT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(ULONG) + sizeof(L"\\\\?\\"),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !_KSI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsiop.h ===
#ifndef _iscsiop_h_
#define _iscsiop_h_

// MSiSCSI_Operations - MSiSCSI_Operations


//***************************************************************************
//
//  iscsiop.h
// 
//  Module: iSCSI Discovery api
//
//  Purpose: Internal header defining interface between user mode discovery
//           api dll and HBA driver miniport.
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#include <iscsidef.h>


//
//
// This class is required.
//
// The iSCSI initiator service relies upon this
// class in order to interface with the adapter. Implement one instance
// per miniport instance (adapter). 
//
// This class must be registered using PDO instance names with a single instance.
//

#define MSiSCSI_OperationsGuid \
    { 0xea4d82bf,0x29da,0x4e12, { 0x80,0x0a,0xe5,0x43,0x79,0x64,0x46,0x2c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_Operations_GUID, \
            0xea4d82bf,0x29da,0x4e12,0x80,0x0a,0xe5,0x43,0x79,0x64,0x46,0x2c);
#endif

//
// Method id definitions for MSiSCSI_Operations

//
// This method is required.
//
// SendTargets instructs the adapter to use an existing discovery session
// with the target portal and issue the SendTargets command to it.
// SendTargetsText specifies the value for the SendTargets key in
// the PDU sent to the target.
//

#define SendTargets     10
typedef struct _SendTargets_IN
{
    // Unique Session ID on which to do send targets. This is the session ID returned from the LoginToTarget method.
    ULONGLONG UniqueSessionId;
    #define SendTargets_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define SendTargets_IN_UniqueSessionId_ID 1

    // SendTargets key text
    WCHAR SendTargetsText[223 + 1];
    #define SendTargets_IN_SendTargetsText_ID 2

} SendTargets_IN, *PSendTargets_IN;

typedef struct _SendTargets_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SendTargets_OUT_Status_SIZE sizeof(ULONG)
    #define SendTargets_OUT_Status_ID 3

    // Number of bytes in SendTargets response
    ULONG ResponseSize;
    #define SendTargets_OUT_ResponseSize_SIZE sizeof(ULONG)
    #define SendTargets_OUT_ResponseSize_ID 4

    // Response to SendTargets in UTF8 characters. NOTE: This field is a variable length array
    UCHAR Response[1];
    #define SendTargets_OUT_Response_ID 5

} SendTargets_OUT, *PSendTargets_OUT;



//
// This method is required.
//
// LoginTarget instructs the adapter to perform a login to the target
// portal and esatablish a session with the target.
//
// Types of login sessions.
//     Discovery - a discovery session is used exclusively for SendTargets
//                 operations.
//
//     Informational - an informational session is a full featured session
//                     but the miniport should not report the devices on
//                     the target to the port driver since the devices 
//                     should not be exposed as local devices to Windows.
//                     Instead a subset of SCSI commands can be executed
//                     on the devices via other WMI methods. This allows
//                     applications to gather information about the devices
//                     without causing the corresponding Windows device
//                     driver stack to be loaded.
//
//     Data - a data session is a full featured session and the miniport
//            should report the devices on the target to the port driver.
//            In this way the corresponding driver stack will be loaded and
//            the device will be available to all applications.
//
//         The session id assigned to a session must remain constant for
//     the lifetime of a session. Reconnections due to async logout or
//     network event should not affect the value of the session id. Also
//     the session must be reported to the MSiSCSI_InitiatorSessionInfo
//     class.
//
//         Data and informational sessions have specific rules related to
//     how reconnections should be handled. If a session is disconnected due
//     to async logout or a network event then the initiator must periodically
//     retry logging back into the session until the session is either 
//     successfully reconnected or the initiator is called to
//     logout of the session. The period between retries is not mandated
//     though it is recommended that 5 seconds be a default value. Another
//     rule is that the miniport should not immediately call the port
//     driver to remove the devices on the target when a session is
//     disconnected due to a network event or async logout. If this were to
//     happen then the devices would disappear and no longer be available to
//     applications. Instead the miniport should maintain the availability
//     of the device by queueing requests and faking success for
//     INQUIRY and REPORT LUNS commands. It would need to do this for a 
//     period of time (60 seconds is recommended). If the session is 
//     reconnected before the end of that period then an application will
//     suffer no interruption in its work. If times runs out the miniport
//     should report the removal of the devices on the target to the port
//     driver. Note that a longer time might mean more requests being queued
//     and more system resources used. It is recommended that these value
//     be configurable.
//
typedef enum {
           // Discovery session is used for SendTargets.
    ISCSI_LOGINTARGET_DISCOVERY = 0,

           // Informational session is used for sending Scsi
           // Commands and should not cause LUNs to be reported
           // to the port driver
    ISCSI_LOGINTARGET_INFORMATIONAL = 1,

           // Data session is used for full operations
           // to a device and should cause LUNs to be reported
           // to the port driver
    ISCSI_LOGINTARGET_DATA = 2

} LOGINSESSIONTYPE, *PLOGINSESSIONTYPE;

#define LoginToTarget     30
typedef struct _LoginToTarget_IN
{
    // Port number corresponding to port in which to initiate the session
    ULONG PortNumber;
    #define LoginToTarget_IN_PortNumber_SIZE sizeof(ULONG)
    #define LoginToTarget_IN_PortNumber_ID 1


//
// Options that affect how login is performed. See ISCSI_LoginOptions
//

    // 
    ISCSI_LoginOptions LoginOptions;
    #define LoginToTarget_IN_LoginOptions_SIZE sizeof(ISCSI_LoginOptions)
    #define LoginToTarget_IN_LoginOptions_ID 2

    // **typedef**Specifies the session type - either discovery, informational or data
    ULONG SessionType;
    #define LoginToTarget_IN_SessionType_SIZE sizeof(ULONG)
    #define LoginToTarget_IN_SessionType_ID 3

    // Security flags
    ULONGLONG SecurityFlags;
    #define LoginToTarget_IN_SecurityFlags_SIZE sizeof(ULONGLONG)
    #define LoginToTarget_IN_SecurityFlags_ID 4

    // On target portal to use for initial connection. 
    ISCSI_TargetPortal TargetPortal;
    #define LoginToTarget_IN_TargetPortal_SIZE sizeof(ISCSI_TargetPortal)
    #define LoginToTarget_IN_TargetPortal_ID 5

    // Size in bytes of authentication Username
    ULONG UsernameSize;
    #define LoginToTarget_IN_UsernameSize_SIZE sizeof(ULONG)
    #define LoginToTarget_IN_UsernameSize_ID 6

    // Size in bytes of authentication Password
    ULONG PasswordSize;
    #define LoginToTarget_IN_PasswordSize_SIZE sizeof(ULONG)
    #define LoginToTarget_IN_PasswordSize_ID 7

    // Size in bytes of preshared key associated with target ip address
    ULONG KeySize;
    #define LoginToTarget_IN_KeySize_SIZE sizeof(ULONG)
    #define LoginToTarget_IN_KeySize_ID 8

    // The service will pass an id that is guaranteed to be gloally unique over all initiators for use when connecting to this target. It may be useful as part of the the ISID
    USHORT UniqueIdForISID;
    #define LoginToTarget_IN_UniqueIdForISID_SIZE sizeof(USHORT)
    #define LoginToTarget_IN_UniqueIdForISID_ID 9

    // If TRUE then this login should be persisted in non-volatile memory.  The adapter will then automatically login to the target using the information passed each time the device driver loads. The driver should not attempt to login, just save the information for login later.
    BOOLEAN PersistentLogin;
    #define LoginToTarget_IN_PersistentLogin_SIZE sizeof(BOOLEAN)
    #define LoginToTarget_IN_PersistentLogin_ID 10

    // The InitiatorNode specifies the iSCSI name of the initiator node to use for the connection. If empty, then the HBA can choose any initiator node
    WCHAR InitiatorNode[223 + 1];
    #define LoginToTarget_IN_InitiatorNode_ID 11

    // The InitiatorAlias specifies the iSCSI alias of the initiator node to use for the connection.
    WCHAR InitiatorAlias[255 + 1];
    #define LoginToTarget_IN_InitiatorAlias_ID 12

    // TargetName specifies the iSCSI target name to which a session should be established.
    WCHAR TargetName[223 + 1];
    #define LoginToTarget_IN_TargetName_ID 13

    // Target mappings. If no mappings are specified then the initiator can use any mappings for the LUNs. If mappings are specified then any LUN on the target that is not specified in the mappings should not be exposed to the port driver.
    ISCSI_TargetMapping Mappings;
    #define LoginToTarget_IN_Mappings_SIZE sizeof(ISCSI_TargetMapping)
    #define LoginToTarget_IN_Mappings_ID 14

    // **field**Preshared key associated with target ip address. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding. All fields after this are commented out in the header.
    UCHAR Key[1];
    #define LoginToTarget_IN_Key_ID 15

    // Authentication Username, for CHAP this is the CHAP Name (CHAP_N) to use when authenticating the target. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding.
//  UCHAR Username[1];
    #define LoginToTarget_IN_Username_ID 16

    // Authentication Password, for CHAP this is the shared secret to use when generating the respose to the target challange. NOTE: This field is a variable length array.
//  UCHAR Password[1];
    #define LoginToTarget_IN_Password_ID 17

} LoginToTarget_IN, *PLoginToTarget_IN;

typedef struct _LoginToTarget_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define LoginToTarget_OUT_Status_SIZE sizeof(ULONG)
    #define LoginToTarget_OUT_Status_ID 18

    // Unique Session ID. This ID is used to identify this session in subsqeuent method calls. The unique session ID can never change until the session is logged out.
    ULONGLONG UniqueSessionId;
    #define LoginToTarget_OUT_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define LoginToTarget_OUT_UniqueSessionId_ID 19

    // Unique Connection ID
    ULONGLONG UniqueConnectionId;
    #define LoginToTarget_OUT_UniqueConnectionId_SIZE sizeof(ULONGLONG)
    #define LoginToTarget_OUT_UniqueConnectionId_ID 20

} LoginToTarget_OUT, *PLoginToTarget_OUT;

#define LoginToTarget_OUT_SIZE (FIELD_OFFSET(LoginToTarget_OUT, UniqueConnectionId) + LoginToTarget_OUT_UniqueConnectionId_SIZE)


//
// This method is required.
//
// This method causes a logout from the target and removal of all LUNs
// exposed on that target. If the session is not connected to the target
// then the driver should stop trying to reconnect.
//


#define LogoutFromTarget     31
typedef struct _LogoutFromTarget_IN
{
    // Unique Session ID. This is the session ID that was returned by the driver when the target was logged in.
    ULONGLONG UniqueSessionId;
    #define LogoutFromTarget_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define LogoutFromTarget_IN_UniqueSessionId_ID 1

} LogoutFromTarget_IN, *PLogoutFromTarget_IN;

#define LogoutFromTarget_IN_SIZE (FIELD_OFFSET(LogoutFromTarget_IN, UniqueSessionId) + LogoutFromTarget_IN_UniqueSessionId_SIZE)

typedef struct _LogoutFromTarget_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define LogoutFromTarget_OUT_Status_SIZE sizeof(ULONG)
    #define LogoutFromTarget_OUT_Status_ID 2

} LogoutFromTarget_OUT, *PLogoutFromTarget_OUT;

#define LogoutFromTarget_OUT_SIZE (FIELD_OFFSET(LogoutFromTarget_OUT, Status) + LogoutFromTarget_OUT_Status_SIZE)


//
// This method is required to exist, but the functionality may not be implemented.
// If the functionality is not implemented the driver should return an error
//
// This method causes an additional connection to be established to a target
// over a session
//


#define AddConnectionToSession     32
typedef struct _AddConnectionToSession_IN
{
    // Unique Adapter specific ID. This is the UniqueAdapterId returned by the MSiSCSI_HBAInfo class.
    ULONGLONG UniqueAdapterId;
    #define AddConnectionToSession_IN_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define AddConnectionToSession_IN_UniqueAdapterId_ID 1

    // Unique Session ID. This is the unique session id returned when the target was logged in.
    ULONGLONG UniqueSessionId;
    #define AddConnectionToSession_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define AddConnectionToSession_IN_UniqueSessionId_ID 2

    // Security flags
    ULONGLONG SecurityFlags;
    #define AddConnectionToSession_IN_SecurityFlags_SIZE sizeof(ULONGLONG)
    #define AddConnectionToSession_IN_SecurityFlags_ID 3

    // Port number corresponding to port from which to initiate the connection
    ULONG PortNumber;
    #define AddConnectionToSession_IN_PortNumber_SIZE sizeof(ULONG)
    #define AddConnectionToSession_IN_PortNumber_ID 4


//
// Options that affect how login is performed. See ISCSI_LoginOptions
//

    // 
    ISCSI_LoginOptions LoginOptions;
    #define AddConnectionToSession_IN_LoginOptions_SIZE sizeof(ISCSI_LoginOptions)
    #define AddConnectionToSession_IN_LoginOptions_ID 5

    // Target portal to use for additional connection. 
    ISCSI_TargetPortal TargetPortal;
    #define AddConnectionToSession_IN_TargetPortal_SIZE sizeof(ISCSI_TargetPortal)
    #define AddConnectionToSession_IN_TargetPortal_ID 6

    // Size in bytes of authentication Username.
    ULONG UsernameSize;
    #define AddConnectionToSession_IN_UsernameSize_SIZE sizeof(ULONG)
    #define AddConnectionToSession_IN_UsernameSize_ID 7

    // Size in bytes of authentication Password.
    ULONG PasswordSize;
    #define AddConnectionToSession_IN_PasswordSize_SIZE sizeof(ULONG)
    #define AddConnectionToSession_IN_PasswordSize_ID 8

    // Size in bytes of preshared key associated with target ip address.
    ULONG KeySize;
    #define AddConnectionToSession_IN_KeySize_SIZE sizeof(ULONG)
    #define AddConnectionToSession_IN_KeySize_ID 9

    // **fields** Preshared key associated with target ip address. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding. All fields after this are commented out in the header.
    UCHAR Key[1];
    #define AddConnectionToSession_IN_Key_ID 10

    // Authentication Username, for CHAP this is the CHAP_N value to use when authenticating the target. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding.
//  UCHAR Username[1];
    #define AddConnectionToSession_IN_Username_ID 11

    // Authentication Password, for CHAP this is the shared secret to use when generating the respose to the target challange. NOTE: This field is a variable length array.
//  UCHAR Password[1];
    #define AddConnectionToSession_IN_Password_ID 12

} AddConnectionToSession_IN, *PAddConnectionToSession_IN;

typedef struct _AddConnectionToSession_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define AddConnectionToSession_OUT_Status_SIZE sizeof(ULONG)
    #define AddConnectionToSession_OUT_Status_ID 13

    // Unique Connection ID
    ULONGLONG UniqueConnectionId;
    #define AddConnectionToSession_OUT_UniqueConnectionId_SIZE sizeof(ULONGLONG)
    #define AddConnectionToSession_OUT_UniqueConnectionId_ID 14

} AddConnectionToSession_OUT, *PAddConnectionToSession_OUT;

#define AddConnectionToSession_OUT_SIZE (FIELD_OFFSET(AddConnectionToSession_OUT, UniqueConnectionId) + AddConnectionToSession_OUT_UniqueConnectionId_SIZE)


//
// This method is required.
//
// This method will remove a target from the list of persistent logins
// maintained by the adapter.
//


#define RemovePersistentLogin     33
typedef struct _RemovePersistentLogin_IN
{
    // Port number corresponding to port from which to initiate the session
    ULONG PortNumber;
    #define RemovePersistentLogin_IN_PortNumber_SIZE sizeof(ULONG)
    #define RemovePersistentLogin_IN_PortNumber_ID 1

    // TargetName specifies the iSCSI target name which should be removed.
    WCHAR TargetName[223 + 1];
    #define RemovePersistentLogin_IN_TargetName_ID 2

    // Target portal. If an empty target portal is specified then all persistent logins to this target name for all portals are removed. 
    ISCSI_TargetPortal TargetPortal;
    #define RemovePersistentLogin_IN_TargetPortal_SIZE sizeof(ISCSI_TargetPortal)
    #define RemovePersistentLogin_IN_TargetPortal_ID 3

} RemovePersistentLogin_IN, *PRemovePersistentLogin_IN;

#define RemovePersistentLogin_IN_SIZE (FIELD_OFFSET(RemovePersistentLogin_IN, TargetPortal) + RemovePersistentLogin_IN_TargetPortal_SIZE)

typedef struct _RemovePersistentLogin_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define RemovePersistentLogin_OUT_Status_SIZE sizeof(ULONG)
    #define RemovePersistentLogin_OUT_Status_ID 4

} RemovePersistentLogin_OUT, *PRemovePersistentLogin_OUT;

#define RemovePersistentLogin_OUT_SIZE (FIELD_OFFSET(RemovePersistentLogin_OUT, Status) + RemovePersistentLogin_OUT_Status_SIZE)


//
// This method is required.
//
// This method will remove a connection from a session. 
//    Note that it is specifically disallowed to remove the last
//    connection from a session, use LogoutIScsiTarget instead
//


#define RemoveConnectionFromSession     34
typedef struct _RemoveConnectionFromSession_IN
{
    // Unique Session ID
    ULONGLONG UniqueSessionId;
    #define RemoveConnectionFromSession_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define RemoveConnectionFromSession_IN_UniqueSessionId_ID 1

    // Unique Connection ID
    ULONGLONG UniqueConnectionId;
    #define RemoveConnectionFromSession_IN_UniqueConnectionId_SIZE sizeof(ULONGLONG)
    #define RemoveConnectionFromSession_IN_UniqueConnectionId_ID 2

} RemoveConnectionFromSession_IN, *PRemoveConnectionFromSession_IN;

#define RemoveConnectionFromSession_IN_SIZE (FIELD_OFFSET(RemoveConnectionFromSession_IN, UniqueConnectionId) + RemoveConnectionFromSession_IN_UniqueConnectionId_SIZE)

typedef struct _RemoveConnectionFromSession_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define RemoveConnectionFromSession_OUT_Status_SIZE sizeof(ULONG)
    #define RemoveConnectionFromSession_OUT_Status_ID 3

} RemoveConnectionFromSession_OUT, *PRemoveConnectionFromSession_OUT;

#define RemoveConnectionFromSession_OUT_SIZE (FIELD_OFFSET(RemoveConnectionFromSession_OUT, Status) + RemoveConnectionFromSession_OUT_Status_SIZE)


//
// This method is required.
//
// This method causes a SCSI INQUIRY CDB to be sent to a target. The method
// should return success if the SCSI request succeeded. If the SCSI request
// failed the Status returned should be ISDSC_SCSI_REQUEST_FAILED and the
// ScsiStatus and SenseBuffer fields returned.
//


#define ScsiInquiry     50
typedef struct _ScsiInquiry_IN
{
    // Unique Session ID
    ULONGLONG UniqueSessionId;
    #define ScsiInquiry_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ScsiInquiry_IN_UniqueSessionId_ID 1

    // Logical unit to which to send INQUIRY
    ULONGLONG Lun;
    #define ScsiInquiry_IN_Lun_SIZE sizeof(ULONGLONG)
    #define ScsiInquiry_IN_Lun_ID 2

    // Flags to use for inquiry
    UCHAR InquiryFlags;
    #define ScsiInquiry_IN_InquiryFlags_SIZE sizeof(UCHAR)
    #define ScsiInquiry_IN_InquiryFlags_ID 3

    // Page code
    UCHAR PageCode;
    #define ScsiInquiry_IN_PageCode_SIZE sizeof(UCHAR)
    #define ScsiInquiry_IN_PageCode_ID 4

} ScsiInquiry_IN, *PScsiInquiry_IN;

#define ScsiInquiry_IN_SIZE (FIELD_OFFSET(ScsiInquiry_IN, PageCode) + ScsiInquiry_IN_PageCode_SIZE)

typedef struct _ScsiInquiry_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define ScsiInquiry_OUT_Status_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_Status_ID 5

    // Size of the response buffer in bytes
    ULONG ResponseBufferSize;
    #define ScsiInquiry_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_ResponseBufferSize_ID 6

    // SCSI Status result
    UCHAR ScsiStatus;
    #define ScsiInquiry_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiInquiry_OUT_ScsiStatus_ID 7

    // Sense buffer returned if SCSI error occured
    UCHAR SenseBuffer[18];
    #define ScsiInquiry_OUT_SenseBuffer_SIZE sizeof(UCHAR[18])
    #define ScsiInquiry_OUT_SenseBuffer_ID 8

    // Response to the SCSI CDB. NOTE: This field is a variable length array.
    UCHAR ResponseBuffer[1];
    #define ScsiInquiry_OUT_ResponseBuffer_ID 9

} ScsiInquiry_OUT, *PScsiInquiry_OUT;


//
// This method is required.
//
// This method causes a READ CAPACITY CDB to be sent to a target. The method
// should return success if the SCSI request succeeded. If the SCSI request
// failed the Status returned should be ISDSC_SCSI_REQUEST_FAILED and the
// ScsiStatus and SenseBuffer fields returned.
//


#define ScsiReadCapacity     51
typedef struct _ScsiReadCapacity_IN
{
    // Unique Session ID
    ULONGLONG UniqueSessionId;
    #define ScsiReadCapacity_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ScsiReadCapacity_IN_UniqueSessionId_ID 1

    // Logical unit to which to send READ CAPACITY
    ULONGLONG Lun;
    #define ScsiReadCapacity_IN_Lun_SIZE sizeof(ULONGLONG)
    #define ScsiReadCapacity_IN_Lun_ID 2

} ScsiReadCapacity_IN, *PScsiReadCapacity_IN;

#define ScsiReadCapacity_IN_SIZE (FIELD_OFFSET(ScsiReadCapacity_IN, Lun) + ScsiReadCapacity_IN_Lun_SIZE)

typedef struct _ScsiReadCapacity_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define ScsiReadCapacity_OUT_Status_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_Status_ID 3

    // Size of the response buffer in bytes
    ULONG ResponseBufferSize;
    #define ScsiReadCapacity_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_ResponseBufferSize_ID 4

    // SCSI Status result
    UCHAR ScsiStatus;
    #define ScsiReadCapacity_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiReadCapacity_OUT_ScsiStatus_ID 5

    // Sense buffer returned on SCSI error
    UCHAR SenseBuffer[18];
    #define ScsiReadCapacity_OUT_SenseBuffer_SIZE sizeof(UCHAR[18])
    #define ScsiReadCapacity_OUT_SenseBuffer_ID 6

    // Response to the SCSI CDB. NOTE: This field is a variable length array.
    UCHAR ResponseBuffer[1];
    #define ScsiReadCapacity_OUT_ResponseBuffer_ID 7

} ScsiReadCapacity_OUT, *PScsiReadCapacity_OUT;


//
// This method is required.
//
// This method causes a REPORT LUNS CDB to be sent to a target. The method
// should return success if the SCSI request succeeded. If the SCSI request
// failed the Status returned should be ISDSC_SCSI_REQUEST_FAILED and the
// ScsiStatus and SenseBuffer fields returned.
//


#define ScsiReportLuns     52
typedef struct _ScsiReportLuns_IN
{
    // Unique Session ID
    ULONGLONG UniqueSessionId;
    #define ScsiReportLuns_IN_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define ScsiReportLuns_IN_UniqueSessionId_ID 1

} ScsiReportLuns_IN, *PScsiReportLuns_IN;

#define ScsiReportLuns_IN_SIZE (FIELD_OFFSET(ScsiReportLuns_IN, UniqueSessionId) + ScsiReportLuns_IN_UniqueSessionId_SIZE)

typedef struct _ScsiReportLuns_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define ScsiReportLuns_OUT_Status_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_Status_ID 2

    // Size of the response buffer in bytes
    ULONG ResponseBufferSize;
    #define ScsiReportLuns_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_ResponseBufferSize_ID 3

    // SCSI Status result
    UCHAR ScsiStatus;
    #define ScsiReportLuns_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiReportLuns_OUT_ScsiStatus_ID 4

    // Sense buffer returned on SCSI error
    UCHAR SenseBuffer[18];
    #define ScsiReportLuns_OUT_SenseBuffer_SIZE sizeof(UCHAR[18])
    #define ScsiReportLuns_OUT_SenseBuffer_ID 5

    // Response to the SCSI CDB. NOTE: This field is a variable length array.
    UCHAR ResponseBuffer[1];
    #define ScsiReportLuns_OUT_ResponseBuffer_ID 6

} ScsiReportLuns_OUT, *PScsiReportLuns_OUT;


//
// This method is required.
//
// This method establishes a CHAP shared secret that is assigned to 
// this initiator and should be used when verifying the CHAP response
// to a challange sent by the initiator. Note that the shared secret
// that is used to generate the CHAP response to a target's challange
// is passed in the LoginToTarget method
//


#define SetCHAPSharedSecret     71
typedef struct _SetCHAPSharedSecret_IN
{
    // Size of Chap shared secret in bytes
    ULONG SharedSecretSize;
    #define SetCHAPSharedSecret_IN_SharedSecretSize_SIZE sizeof(ULONG)
    #define SetCHAPSharedSecret_IN_SharedSecretSize_ID 1

    // CHAP shared secret. NOTE: This field is a variable length array.
    UCHAR SharedSecret[1];
    #define SetCHAPSharedSecret_IN_SharedSecret_ID 2

} SetCHAPSharedSecret_IN, *PSetCHAPSharedSecret_IN;

typedef struct _SetCHAPSharedSecret_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetCHAPSharedSecret_OUT_Status_SIZE sizeof(ULONG)
    #define SetCHAPSharedSecret_OUT_Status_ID 3

} SetCHAPSharedSecret_OUT, *PSetCHAPSharedSecret_OUT;

#define SetCHAPSharedSecret_OUT_SIZE (FIELD_OFFSET(SetCHAPSharedSecret_OUT, Status) + SetCHAPSharedSecret_OUT_Status_SIZE)


//
// This method is required.
//
// This method establishes a RADIUS shared secret that is assigned to 
// this initiator and should be used when authenticating oneself
// to the RADIUS server. 
//


#define SetRADIUSSharedSecret     72
typedef struct _SetRADIUSSharedSecret_IN
{
    // Size of RADIUS shared secret in bytes
    ULONG SharedSecretSize;
    #define SetRADIUSSharedSecret_IN_SharedSecretSize_SIZE sizeof(ULONG)
    #define SetRADIUSSharedSecret_IN_SharedSecretSize_ID 1

    // RADIUS shared secret. NOTE: This field is a variable length array.
    UCHAR SharedSecret[1];
    #define SetRADIUSSharedSecret_IN_SharedSecret_ID 2

} SetRADIUSSharedSecret_IN, *PSetRADIUSSharedSecret_IN;

typedef struct _SetRADIUSSharedSecret_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetRADIUSSharedSecret_OUT_Status_SIZE sizeof(ULONG)
    #define SetRADIUSSharedSecret_OUT_Status_ID 3

} SetRADIUSSharedSecret_OUT, *PSetRADIUSSharedSecret_OUT;

#define SetRADIUSSharedSecret_OUT_SIZE (FIELD_OFFSET(SetRADIUSSharedSecret_OUT, Status) + SetRADIUSSharedSecret_OUT_Status_SIZE)


//
// This method is optional and does not need to be implemented.
//
// This method informs the initiator that an initiator node name is no
// longer in use.
//


#define DeleteInitiatorNodeName     91
typedef struct _DeleteInitiatorNodeName_IN
{
    // Initiator name that is deleted.
    WCHAR DeletedInitiatorName[223 + 1];
    #define DeleteInitiatorNodeName_IN_DeletedInitiatorName_ID 1

} DeleteInitiatorNodeName_IN, *PDeleteInitiatorNodeName_IN;

typedef struct _DeleteInitiatorNodeName_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define DeleteInitiatorNodeName_OUT_Status_SIZE sizeof(ULONG)
    #define DeleteInitiatorNodeName_OUT_Status_ID 2

} DeleteInitiatorNodeName_OUT, *PDeleteInitiatorNodeName_OUT;

#define DeleteInitiatorNodeName_OUT_SIZE (FIELD_OFFSET(DeleteInitiatorNodeName_OUT, Status) + DeleteInitiatorNodeName_OUT_Status_SIZE)


//
// This method is optional and does not need to be implemented.
//
// This method informs the initiator that a new initiator node name is 
// begin to be in use//


#define SetInitiatorNodeName     92
typedef struct _SetInitiatorNodeName_IN
{
    // New initiator name.
    WCHAR CreatedInitiatorName[223 + 1];
    #define SetInitiatorNodeName_IN_CreatedInitiatorName_ID 1

} SetInitiatorNodeName_IN, *PSetInitiatorNodeName_IN;

typedef struct _SetInitiatorNodeName_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetInitiatorNodeName_OUT_Status_SIZE sizeof(ULONG)
    #define SetInitiatorNodeName_OUT_Status_ID 2

} SetInitiatorNodeName_OUT, *PSetInitiatorNodeName_OUT;

#define SetInitiatorNodeName_OUT_SIZE (FIELD_OFFSET(SetInitiatorNodeName_OUT, Status) + SetInitiatorNodeName_OUT_Status_SIZE)


//
// This method is optional and does not need to be implemented.
//
// This method adds an iSNS server to the list of iSNS servers the HBA
// should manage
//


#define AddiSNSServer     101
typedef struct _AddiSNSServer_IN
{
    // iSNS Server Name
    WCHAR iSNSServerName[223 + 1];
    #define AddiSNSServer_IN_iSNSServerName_ID 1

} AddiSNSServer_IN, *PAddiSNSServer_IN;

typedef struct _AddiSNSServer_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define AddiSNSServer_OUT_Status_SIZE sizeof(ULONG)
    #define AddiSNSServer_OUT_Status_ID 2

} AddiSNSServer_OUT, *PAddiSNSServer_OUT;

#define AddiSNSServer_OUT_SIZE (FIELD_OFFSET(AddiSNSServer_OUT, Status) + AddiSNSServer_OUT_Status_SIZE)


//
// This method is optional and does not need to be implemented.
//
// This method removes an iSNS server from the list of iSNS servers the HBA
// should manage
//


#define RemoveiSNSServer     102
typedef struct _RemoveiSNSServer_IN
{
    // iSNS Server Name
    WCHAR iSNSServerName[223 + 1];
    #define RemoveiSNSServer_IN_iSNSServerName_ID 1

} RemoveiSNSServer_IN, *PRemoveiSNSServer_IN;

typedef struct _RemoveiSNSServer_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define RemoveiSNSServer_OUT_Status_SIZE sizeof(ULONG)
    #define RemoveiSNSServer_OUT_Status_ID 2

} RemoveiSNSServer_OUT, *PRemoveiSNSServer_OUT;

#define RemoveiSNSServer_OUT_SIZE (FIELD_OFFSET(RemoveiSNSServer_OUT, Status) + RemoveiSNSServer_OUT_Status_SIZE)


//
// This method is optional and does not need to be implemented.
//
// This method adds a RADIUS server to the list of RADIUS servers the initiator/HBA
// should manage
//


#define AddRADIUSServer     103
typedef struct _AddRADIUSServer_IN
{
    // RADIUS Server Address
    ISCSI_IP_Address RADIUSIPAddress;
    #define AddRADIUSServer_IN_RADIUSIPAddress_SIZE sizeof(ISCSI_IP_Address)
    #define AddRADIUSServer_IN_RADIUSIPAddress_ID 1

} AddRADIUSServer_IN, *PAddRADIUSServer_IN;

#define AddRADIUSServer_IN_SIZE (FIELD_OFFSET(AddRADIUSServer_IN, RADIUSIPAddress) + AddRADIUSServer_IN_RADIUSIPAddress_SIZE)

typedef struct _AddRADIUSServer_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define AddRADIUSServer_OUT_Status_SIZE sizeof(ULONG)
    #define AddRADIUSServer_OUT_Status_ID 2

} AddRADIUSServer_OUT, *PAddRADIUSServer_OUT;

#define AddRADIUSServer_OUT_SIZE (FIELD_OFFSET(AddRADIUSServer_OUT, Status) + AddRADIUSServer_OUT_Status_SIZE)


//
// This method is optional and does not need to be implemented.
//
// This method removes a RADIUS server from the list of RADIUS servers the initiator/HBA
// should manage
//


#define RemoveRADIUSServer     104
typedef struct _RemoveRADIUSServer_IN
{
    // RADIUS Server Address
    ISCSI_IP_Address RADIUSIPAddress;
    #define RemoveRADIUSServer_IN_RADIUSIPAddress_SIZE sizeof(ISCSI_IP_Address)
    #define RemoveRADIUSServer_IN_RADIUSIPAddress_ID 1

} RemoveRADIUSServer_IN, *PRemoveRADIUSServer_IN;

#define RemoveRADIUSServer_IN_SIZE (FIELD_OFFSET(RemoveRADIUSServer_IN, RADIUSIPAddress) + RemoveRADIUSServer_IN_RADIUSIPAddress_SIZE)

typedef struct _RemoveRADIUSServer_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define RemoveRADIUSServer_OUT_Status_SIZE sizeof(ULONG)
    #define RemoveRADIUSServer_OUT_Status_ID 2

} RemoveRADIUSServer_OUT, *PRemoveRADIUSServer_OUT;

#define RemoveRADIUSServer_OUT_SIZE (FIELD_OFFSET(RemoveRADIUSServer_OUT, Status) + RemoveRADIUSServer_OUT_Status_SIZE)


// ISCSI_Persistent_Login - ISCSI_Persistent_Login
// Persistent Target login
#define ISCSI_Persistent_LoginGuid \
    { 0x1ac62a5d,0xa418,0x4c15, { 0x96,0xbd,0x2c,0x3a,0x9d,0xb8,0xc8,0xca } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(ISCSI_Persistent_Login_GUID, \
            0x1ac62a5d,0xa418,0x4c15,0x96,0xbd,0x2c,0x3a,0x9d,0xb8,0xc8,0xca);
#endif


typedef struct _ISCSI_Persistent_Login
{
    // Name of the target for persistent login
    WCHAR TargetName[223 + 1];
    #define ISCSI_Persistent_Login_TargetName_ID 1

    // Security flags
    ULONGLONG SecurityFlags;
    #define ISCSI_Persistent_Login_SecurityFlags_SIZE sizeof(ULONGLONG)
    #define ISCSI_Persistent_Login_SecurityFlags_ID 2

    // Port number on which to perform the login
    ULONG InitiatorPortNumber;
    #define ISCSI_Persistent_Login_InitiatorPortNumber_SIZE sizeof(ULONG)
    #define ISCSI_Persistent_Login_InitiatorPortNumber_ID 3

    // Number of bytes in username
    ULONG UsernameSize;
    #define ISCSI_Persistent_Login_UsernameSize_SIZE sizeof(ULONG)
    #define ISCSI_Persistent_Login_UsernameSize_ID 4

    // TRUE if informational session
    BOOLEAN IsInformationalSession;
    #define ISCSI_Persistent_Login_IsInformationalSession_SIZE sizeof(BOOLEAN)
    #define ISCSI_Persistent_Login_IsInformationalSession_ID 5

    // ISID that the persistent login will use for login
    USHORT UniqueIdForISID;
    #define ISCSI_Persistent_Login_UniqueIdForISID_SIZE sizeof(USHORT)
    #define ISCSI_Persistent_Login_UniqueIdForISID_ID 6

    // Portal to use for initial connection
    ISCSI_TargetPortal TargetPortal;
    #define ISCSI_Persistent_Login_TargetPortal_SIZE sizeof(ISCSI_TargetPortal)
    #define ISCSI_Persistent_Login_TargetPortal_ID 7

    // Login options
    ISCSI_LoginOptions LoginOptions;
    #define ISCSI_Persistent_Login_LoginOptions_SIZE sizeof(ISCSI_LoginOptions)
    #define ISCSI_Persistent_Login_LoginOptions_ID 8

    // Target mappings
    ISCSI_TargetMapping TargetMapping;
    #define ISCSI_Persistent_Login_TargetMapping_SIZE sizeof(ISCSI_TargetMapping)
    #define ISCSI_Persistent_Login_TargetMapping_ID 9

    // Authentication Username, for CHAP this is the CHAP Name (CHAP_N) when authenticating the target. NOTE: This field is a variable length array.
    UCHAR Username[1];
    #define ISCSI_Persistent_Login_Username_ID 10

} ISCSI_Persistent_Login, *PISCSI_Persistent_Login;

// MSiSCSI_PersistentLogins - MSiSCSI_PersistentLogins

//
// This class is required.
//
// This class returns the list of persistent target logins. A persistent
// target login is one where the initiator must login to the 
// target immediately upon loading so that the device is available 
// early in boot
//

#define MSiSCSI_PersistentLoginsGuid \
    { 0x420512d9,0x0537,0x4c67, { 0xa7,0x79,0x84,0xba,0x7b,0x29,0xce,0x9f } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_PersistentLogins_GUID, \
            0x420512d9,0x0537,0x4c67,0xa7,0x79,0x84,0xba,0x7b,0x29,0xce,0x9f);
#endif


typedef struct _MSiSCSI_PersistentLogins
{
    // Number of persistent logins
    ULONG PersistentLoginCount;
    #define MSiSCSI_PersistentLogins_PersistentLoginCount_SIZE sizeof(ULONG)
    #define MSiSCSI_PersistentLogins_PersistentLoginCount_ID 1

    // Reserved
    ULONG Reserved;
    #define MSiSCSI_PersistentLogins_Reserved_SIZE sizeof(ULONG)
    #define MSiSCSI_PersistentLogins_Reserved_ID 2

    // Array of PersistentLoginCount ISCSI_Persistent_Login structures. NOTE: This field is a variable length array.
    ISCSI_Persistent_Login PersistentLogins[1];
    #define MSiSCSI_PersistentLogins_PersistentLogins_ID 3

} MSiSCSI_PersistentLogins, *PMSiSCSI_PersistentLogins;

// MSiSCSI_TargetMappings - MSiSCSI_TargetMappings
// Target mappings for iSCSI LUNs

//
// This class is required.
//
// This class returns the list of current OS mappings for iSCSI LUNs
// The iSCSI initiator service relies upon this
// class in order to interface with your HBA. Implement one instance
// per adapter. This class must be registered using PDO
// instance names.
//

#define MSiSCSI_TargetMappingsGuid \
    { 0x41646815,0x7524,0x4bc0, { 0x90,0x4a,0xcd,0x7d,0x51,0x0e,0xac,0x02 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_TargetMappings_GUID, \
            0x41646815,0x7524,0x4bc0,0x90,0x4a,0xcd,0x7d,0x51,0x0e,0xac,0x02);
#endif


typedef struct _MSiSCSI_TargetMappings
{
    // Id that is globally unique to each instance of each adapter. This should be the value returned by the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_TargetMappings_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_TargetMappings_UniqueAdapterId_ID 1

    // Number of target mappings
    ULONG TargetMappingCount;
    #define MSiSCSI_TargetMappings_TargetMappingCount_SIZE sizeof(ULONG)
    #define MSiSCSI_TargetMappings_TargetMappingCount_ID 2

    // Reserved
    ULONG Reserved;
    #define MSiSCSI_TargetMappings_Reserved_SIZE sizeof(ULONG)
    #define MSiSCSI_TargetMappings_Reserved_ID 3

    // Array of TargetMappingCount ISCSI_TargetMapping structures. NOTE: This field is a variable length array.
    ISCSI_TargetMapping TargetMappings[1];
    #define MSiSCSI_TargetMappings_TargetMappings_ID 4

} MSiSCSI_TargetMappings, *PMSiSCSI_TargetMappings;

// MSiSCSI_LUNMappingInformation - MSiSCSI_LUNMappingInformation
// LUN Mapping Information

//
// This class is required.
//
// It must be implemented using PDO instance names by the PDO device object
//
// This class exposes the OS SCSI address information for a particular LUN.
// The SCSI address information must be consistent with the information returned
// by the MSIScsi_TargetMappings class and the information reported to the port
// driver. The class must be implemented on the PDO device object so that there
// will be one instance for each device created by the adapter and named by the
// PDO name for the created device and not the adapter
//

#define MSiSCSI_LUNMappingInformationGuid \
    { 0x7bb02370,0xb8ae,0x4d29, { 0x88,0xde,0x76,0x95,0x1d,0x32,0x45,0xba } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_LUNMappingInformation_GUID, \
            0x7bb02370,0xb8ae,0x4d29,0x88,0xde,0x76,0x95,0x1d,0x32,0x45,0xba);
#endif


typedef struct _MSiSCSI_LUNMappingInformation
{
    // Id that is globally unique to each instance of each adapter. Using the address of the Adapter Extension is a good idea.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_LUNMappingInformation_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_LUNMappingInformation_UniqueAdapterId_ID 1

    // Id that is unique to this session within this adapter. This should be the same session id as the one assigned when the session was logged in.
    ULONGLONG UniqueSessionId;
    #define MSiSCSI_LUNMappingInformation_UniqueSessionId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_LUNMappingInformation_UniqueSessionId_ID 2

    // OS Bus Number
    ULONG OSBus;
    #define MSiSCSI_LUNMappingInformation_OSBus_SIZE sizeof(ULONG)
    #define MSiSCSI_LUNMappingInformation_OSBus_ID 3

    // OS Target Number
    ULONG OSTarget;
    #define MSiSCSI_LUNMappingInformation_OSTarget_SIZE sizeof(ULONG)
    #define MSiSCSI_LUNMappingInformation_OSTarget_ID 4

    // OS LUN Number
    ULONG OSLUN;
    #define MSiSCSI_LUNMappingInformation_OSLUN_SIZE sizeof(ULONG)
    #define MSiSCSI_LUNMappingInformation_OSLUN_ID 5

} MSiSCSI_LUNMappingInformation, *PMSiSCSI_LUNMappingInformation;

#define MSiSCSI_LUNMappingInformation_SIZE (FIELD_OFFSET(MSiSCSI_LUNMappingInformation, OSLUN) + MSiSCSI_LUNMappingInformation_OSLUN_SIZE)

// MSiSCSI_SecurityConfigOperations - MSiSCSI_SecurityConfigOperations

//
// This class is required if your adapter supports IPSEC or CHAP.
//
// An adapter must support the appropriate methods if it implements
// security including IKE (using preshared keys) and/or a non volatile 
// cache for IPSEC preshared keys and iSCSI authentication credentials
// (ie, username and passwords). The adapter should also indicate that
// that the cache is implemented by setting the appropriate flags in the
// MSiSCSI_HBAInformation class
//
// This class must be registered using PDO instance names with a single instance
//

#define MSiSCSI_SecurityConfigOperationsGuid \
    { 0x391f3325,0x0ba3,0x4083, { 0xa8,0x61,0xcf,0x4f,0x6f,0x97,0xa5,0x27 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_SecurityConfigOperations_GUID, \
            0x391f3325,0x0ba3,0x4083,0xa8,0x61,0xcf,0x4f,0x6f,0x97,0xa5,0x27);
#endif

//
// Method id definitions for MSiSCSI_SecurityConfigOperations

//
// This method is required if the initiator supports IKE.
//
// SetPresharedKeyForId allows a management application to configure an
// adapter with a preshared key that is associated with an id. The
// id corresponds to the contents of the identification payload in the
// IKE phase 1 aggressive or main mode exchange. The
// key can be associated with an ip address for use in the IKE phase 1
// main mode exchange. The adapter should maintain the key in its non
// volatile storage if it is available. The adapter should also maintain
// the key in its working memory so that it is available for IKE phase 1
// negotiation. If NVRAM is not available then the initiator service will
// maintain the key on behalf of the adapter.
// 
//
//
// IKE Identification payload types (from RFC 2407)
//
#define       ID_IPV4_ADDR                        1
#define       ID_FQDN                             2
#define       ID_USER_FQDN                        3
#define       ID_IPV6_ADDR                        5


#define SetPresharedKeyForId     1
typedef struct _SetPresharedKeyForId_IN
{
    // Specific port number or 0xffffffff for all ports
    ULONG PortNumber;
    #define SetPresharedKeyForId_IN_PortNumber_SIZE sizeof(ULONG)
    #define SetPresharedKeyForId_IN_PortNumber_ID 1

    // 
    ULONGLONG SecurityFlags;
    #define SetPresharedKeyForId_IN_SecurityFlags_SIZE sizeof(ULONGLONG)
    #define SetPresharedKeyForId_IN_SecurityFlags_ID 2

    // Type of Id to associate with the preshared key
    UCHAR IdType;
    #define SetPresharedKeyForId_IN_IdType_SIZE sizeof(UCHAR)
    #define SetPresharedKeyForId_IN_IdType_ID 3

    // Size in bytes of the Id
    ULONG IdSize;
    #define SetPresharedKeyForId_IN_IdSize_SIZE sizeof(ULONG)
    #define SetPresharedKeyForId_IN_IdSize_ID 4

    // Size in bytes of the Key
    ULONG KeySize;
    #define SetPresharedKeyForId_IN_KeySize_SIZE sizeof(ULONG)
    #define SetPresharedKeyForId_IN_KeySize_ID 5

    // **fields** Id to associate with the key. NOTE: This field is a variable length array, the field that follows this field starts immediately after the end of this field subject to appropriate padding. All fields after this are commented out in the header.
    UCHAR Id[1];
    #define SetPresharedKeyForId_IN_Id_ID 6

    // Key to associate with the id. NOTE: This field is a variable length array.
//  UCHAR Key[1];
    #define SetPresharedKeyForId_IN_Key_ID 7

} SetPresharedKeyForId_IN, *PSetPresharedKeyForId_IN;

typedef struct _SetPresharedKeyForId_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetPresharedKeyForId_OUT_Status_SIZE sizeof(ULONG)
    #define SetPresharedKeyForId_OUT_Status_ID 8

} SetPresharedKeyForId_OUT, *PSetPresharedKeyForId_OUT;

#define SetPresharedKeyForId_OUT_SIZE (FIELD_OFFSET(SetPresharedKeyForId_OUT, Status) + SetPresharedKeyForId_OUT_Status_SIZE)


//
// This method is required if the initiator supports IKE.
//
// GetPresharedKeyForId allows a management application to determine if
// a particular IKE identification payload is configured with a preshared
// key
//

#define GetPresharedKeyForId     2
typedef struct _GetPresharedKeyForId_IN
{
    // 
    ULONG PortNumber;
    #define GetPresharedKeyForId_IN_PortNumber_SIZE sizeof(ULONG)
    #define GetPresharedKeyForId_IN_PortNumber_ID 1

    // Type of Id to associate with the preshared key
    UCHAR IdType;
    #define GetPresharedKeyForId_IN_IdType_SIZE sizeof(UCHAR)
    #define GetPresharedKeyForId_IN_IdType_ID 2

    // Size in bytes of the Id
    ULONG IdSize;
    #define GetPresharedKeyForId_IN_IdSize_SIZE sizeof(ULONG)
    #define GetPresharedKeyForId_IN_IdSize_ID 3

    // Id to associate with the key. NOTE: This field is a variable length array.
    UCHAR Id[1];
    #define GetPresharedKeyForId_IN_Id_ID 4

} GetPresharedKeyForId_IN, *PGetPresharedKeyForId_IN;

typedef struct _GetPresharedKeyForId_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define GetPresharedKeyForId_OUT_Status_SIZE sizeof(ULONG)
    #define GetPresharedKeyForId_OUT_Status_ID 5

    // 
    ULONGLONG SecurityFlags;
    #define GetPresharedKeyForId_OUT_SecurityFlags_SIZE sizeof(ULONGLONG)
    #define GetPresharedKeyForId_OUT_SecurityFlags_ID 6

} GetPresharedKeyForId_OUT, *PGetPresharedKeyForId_OUT;

#define GetPresharedKeyForId_OUT_SIZE (FIELD_OFFSET(GetPresharedKeyForId_OUT, SecurityFlags) + GetPresharedKeyForId_OUT_SecurityFlags_SIZE)


//
// This method is required if the initiator supports IKE
//
// SetGroupPresharedKey allows a management application to configure an
// adapter with a group preshared key that is used in an IKE phase 1 exchange
// when there is no specific key available for that exchange. The adapter 
// should maintain the key in its non volatile storage if available and
// maintain the key in its working memory so that it is available for IKE
// phase 1 negotiation
//
//

#define SetGroupPresharedKey     3
typedef struct _SetGroupPresharedKey_IN
{
    // Number of bytes passed in Key for the preshared key
    ULONG KeySize;
    #define SetGroupPresharedKey_IN_KeySize_SIZE sizeof(ULONG)
    #define SetGroupPresharedKey_IN_KeySize_ID 1

    // Preshared key used as group key. NOTE: This field is a variable length array.
    UCHAR Key[1];
    #define SetGroupPresharedKey_IN_Key_ID 2

} SetGroupPresharedKey_IN, *PSetGroupPresharedKey_IN;

typedef struct _SetGroupPresharedKey_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetGroupPresharedKey_OUT_Status_SIZE sizeof(ULONG)
    #define SetGroupPresharedKey_OUT_Status_ID 3

} SetGroupPresharedKey_OUT, *PSetGroupPresharedKey_OUT;

#define SetGroupPresharedKey_OUT_SIZE (FIELD_OFFSET(SetGroupPresharedKey_OUT, Status) + SetGroupPresharedKey_OUT_Status_SIZE)


//
// This method is required if the initiator supports IPSEC tunnel mode
//
// SetTunnelModeOuterAddress allows a management application to configure the
// tunnel mode outer address that is used by a port on an adapter
// The adapter should maintain the address in its non volatile
// storage if available 
// 

#define SetTunnelModeOuterAddress     4
typedef struct _SetTunnelModeOuterAddress_IN
{
    // Port number to which to associate tunnel mode address. Use 0xffffffff to associate with all ports.
    ULONG PortNumber;
    #define SetTunnelModeOuterAddress_IN_PortNumber_SIZE sizeof(ULONG)
    #define SetTunnelModeOuterAddress_IN_PortNumber_ID 1

    // Destination address
    ISCSI_IP_Address DestinationAddress;
    #define SetTunnelModeOuterAddress_IN_DestinationAddress_SIZE sizeof(ISCSI_IP_Address)
    #define SetTunnelModeOuterAddress_IN_DestinationAddress_ID 2

    // Tunnel mode outer address
    ISCSI_IP_Address TunnelModeOuterAddress;
    #define SetTunnelModeOuterAddress_IN_TunnelModeOuterAddress_SIZE sizeof(ISCSI_IP_Address)
    #define SetTunnelModeOuterAddress_IN_TunnelModeOuterAddress_ID 3

} SetTunnelModeOuterAddress_IN, *PSetTunnelModeOuterAddress_IN;

#define SetTunnelModeOuterAddress_IN_SIZE (FIELD_OFFSET(SetTunnelModeOuterAddress_IN, TunnelModeOuterAddress) + SetTunnelModeOuterAddress_IN_TunnelModeOuterAddress_SIZE)

typedef struct _SetTunnelModeOuterAddress_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetTunnelModeOuterAddress_OUT_Status_SIZE sizeof(ULONG)
    #define SetTunnelModeOuterAddress_OUT_Status_ID 4

} SetTunnelModeOuterAddress_OUT, *PSetTunnelModeOuterAddress_OUT;

#define SetTunnelModeOuterAddress_OUT_SIZE (FIELD_OFFSET(SetTunnelModeOuterAddress_OUT, Status) + SetTunnelModeOuterAddress_OUT_Status_SIZE)


//
// This method is required if the initiator caches information
//
// ClearCache instructs the HBA to clear the iSCSI authentication and
// preshared key caches
// 

#define ClearCache     5
typedef struct _ClearCache_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define ClearCache_OUT_Status_SIZE sizeof(ULONG)
    #define ClearCache_OUT_Status_ID 1

} ClearCache_OUT, *PClearCache_OUT;

#define ClearCache_OUT_SIZE (FIELD_OFFSET(ClearCache_OUT, Status) + ClearCache_OUT_Status_SIZE)


//
// This method is required if the initiator caches information
//
// This method establishes a marker that the service can subsequently
// validate to ensure that the initiator cache is valid
// 

#define SetGenerationalGuid     6
typedef struct _SetGenerationalGuid_IN
{
    // Generational Guid
    UCHAR GenerationalGuid[16];
    #define SetGenerationalGuid_IN_GenerationalGuid_SIZE sizeof(UCHAR[16])
    #define SetGenerationalGuid_IN_GenerationalGuid_ID 1

} SetGenerationalGuid_IN, *PSetGenerationalGuid_IN;

#define SetGenerationalGuid_IN_SIZE (FIELD_OFFSET(SetGenerationalGuid_IN, GenerationalGuid) + SetGenerationalGuid_IN_GenerationalGuid_SIZE)

typedef struct _SetGenerationalGuid_OUT
{
    // Status code resulting from operation
    ULONG Status;
    #define SetGenerationalGuid_OUT_Status_SIZE sizeof(ULONG)
    #define SetGenerationalGuid_OUT_Status_ID 2

} SetGenerationalGuid_OUT, *PSetGenerationalGuid_OUT;

#define SetGenerationalGuid_OUT_SIZE (FIELD_OFFSET(SetGenerationalGuid_OUT, Status) + SetGenerationalGuid_OUT_Status_SIZE)


// MSiSCSI_BootInformation - MSiSCSI_BootInformation
#define MSiSCSI_BootInformationGuid \
    { 0xee5a2356,0xc703,0x489b, { 0xb1,0x36,0x69,0xc9,0x94,0xae,0x3a,0x20 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_BootInformation_GUID, \
            0xee5a2356,0xc703,0x489b,0xb1,0x36,0x69,0xc9,0x94,0xae,0x3a,0x20);
#endif


typedef struct _MSiSCSI_BootInformation
{
    // Initiator Node Name used for boot
    UCHAR NodeName[223];
    #define MSiSCSI_BootInformation_NodeName_SIZE sizeof(UCHAR[223])
    #define MSiSCSI_BootInformation_NodeName_ID 1

    // Length of Initiator Shared Secret
    ULONG SharedSecretLength;
    #define MSiSCSI_BootInformation_SharedSecretLength_SIZE sizeof(ULONG)
    #define MSiSCSI_BootInformation_SharedSecretLength_ID 2

    // Initiator Shared Secret
    UCHAR SharedSecret[255];
    #define MSiSCSI_BootInformation_SharedSecret_SIZE sizeof(UCHAR[255])
    #define MSiSCSI_BootInformation_SharedSecret_ID 3

} MSiSCSI_BootInformation, *PMSiSCSI_BootInformation;

#define MSiSCSI_BootInformation_SIZE (FIELD_OFFSET(MSiSCSI_BootInformation, SharedSecret) + MSiSCSI_BootInformation_SharedSecret_SIZE)

// MSiSCSI_AdapterEvent - MSiSCSI_AdapterEvent

typedef enum {
    ISCSI_ADAPTER_TARGETS_CHANGED = 3
} ISCSI_ADAPTER_EVENT_CODE, *PISCSI_ADAPTER_EVENT_CODE; 

//
// This class is required if the HBA supports discovery
//
// This class must be registered using PDO instance names with a single instance
//

#define MSiSCSI_AdapterEventGuid \
    { 0x46b122c0,0x3767,0x4069, { 0x91,0x6e,0x3a,0x43,0x70,0x2f,0x05,0xce } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_AdapterEvent_GUID, \
            0x46b122c0,0x3767,0x4069,0x91,0x6e,0x3a,0x43,0x70,0x2f,0x05,0xce);
#endif


typedef struct _MSiSCSI_AdapterEvent
{
    // Id that is unique to each instance of each adapter. This is the ID returned in the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_AdapterEvent_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_AdapterEvent_UniqueAdapterId_ID 1

    // **typedef**Adapter Event Code
    ULONG EventCode;
    #define MSiSCSI_AdapterEvent_EventCode_SIZE sizeof(ULONG)
    #define MSiSCSI_AdapterEvent_EventCode_ID 2

} MSiSCSI_AdapterEvent, *PMSiSCSI_AdapterEvent;

#define MSiSCSI_AdapterEvent_SIZE (FIELD_OFFSET(MSiSCSI_AdapterEvent, EventCode) + MSiSCSI_AdapterEvent_EventCode_SIZE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\iscsiprf.h ===
#ifndef _iscsiprf_h_
#define _iscsiprf_h_

// MSiSCSI_MMIPSECStats - MSiSCSI_MMIPSECStats
// iSCSI HBA main mode IPSEC Statistics


//***************************************************************************
//
//  iscsiprf.h
// 
//  Module: iSCSI Discovery api
//
//  Purpose: Internal header defining interface between user mode discovery
//           api dll and HBA driver miniport.
//
//  Note: These classes are recommended as by implementing them the data 
//        exposed will be available in sysmon (perfmon) when running on 
//        Windows XP and Windows .Net server
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

//
// This class exposes the main mode IPSEC statistics
//
// This class must be registered with PDO instance names using a single instance
//

#define MSiSCSI_MMIPSECStatsGuid \
    { 0x36b58ea2,0xc461,0x4bb0, { 0xac,0x8e,0x95,0x2f,0x59,0xd2,0x51,0xed } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_MMIPSECStats_GUID, \
            0x36b58ea2,0xc461,0x4bb0,0xac,0x8e,0x95,0x2f,0x59,0xd2,0x51,0xed);
#endif


typedef struct _MSiSCSI_MMIPSECStats
{

// An acquire is a request by the IPSEC driver to have IKE perform a task. The active acquire statistic includes the outstanding request and the number of any queued requests. Typically, the number of active acquires is 1. Under a heavy load, the number of active acquires is 1 and the number of requests that are queued by IKE for processing.
    // An acquire is a request by the IPSEC driver to have IKE perform a task. The active acquire statistic includes the outstanding request and the number of any queued requests. Typically, the number of active acquires is 1. Under a heavy load, the number of active acquires is 1 and the number of requests that are queued by IKE for processing.
    ULONGLONG ActiveAcquire;
    #define MSiSCSI_MMIPSECStats_ActiveAcquire_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_ActiveAcquire_ID 1


// The number of IKE messages received that are queued for processing.
    // The number of IKE messages received that are queued for processing.
    ULONGLONG ActiveReceive;
    #define MSiSCSI_MMIPSECStats_ActiveReceive_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_ActiveReceive_ID 2


// The number of times that an acquire has failed.
    // The number of times that an acquire has failed.
    ULONGLONG AcquireFailures;
    #define MSiSCSI_MMIPSECStats_AcquireFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_AcquireFailures_ID 3


// The number of times that the TCP stack has failed when receiving IKE messages.
    // The number of times that the TCP stack has failed when receiving IKE messages.
    ULONGLONG ReceiveFailures;
    #define MSiSCSI_MMIPSECStats_ReceiveFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_ReceiveFailures_ID 4


// The number of times that the TCP/IP stack has failed when sending IKE messages.
    // The number of times that the TCP/IP stack has failed when sending IKE messages.
    ULONGLONG SendFailures;
    #define MSiSCSI_MMIPSECStats_SendFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_SendFailures_ID 5


// The number of entries in the acquire heap, which stores active acquires. This number increases under a heavy load and then gradually decreases over time, as the acquire heap is cleared.
    // The number of entries in the acquire heap, which stores active acquires. This number increases under a heavy load and then gradually decreases over time, as the acquire heap is cleared.
    ULONGLONG AcquireHeapSize;
    #define MSiSCSI_MMIPSECStats_AcquireHeapSize_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_AcquireHeapSize_ID 6


// The number of entries in the IKE receive buffers for incoming IKE messages.
    // The number of entries in the IKE receive buffers for incoming IKE messages.
    ULONGLONG ReceiveHeapSize;
    #define MSiSCSI_MMIPSECStats_ReceiveHeapSize_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_ReceiveHeapSize_ID 7


// The total number of negotiation failures that occurred during main mode (also known as Phase I) or quick mode (also known as Phase II) negotiation.
    // The total number of negotiation failures that occurred during main mode (also known as Phase I) or quick mode (also known as Phase II) negotiation.
    ULONGLONG NegotiationFailures;
    #define MSiSCSI_MMIPSECStats_NegotiationFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_NegotiationFailures_ID 8


// The total number of identity authentication failures (Kerberos, certificate, and preshared key) that occurred during main mode negotiation.
    // The total number of identity authentication failures (Kerberos, certificate, and preshared key) that occurred during main mode negotiation.
    ULONGLONG AuthenticationFailures;
    #define MSiSCSI_MMIPSECStats_AuthenticationFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_AuthenticationFailures_ID 9


// A cookie is a value contained in a received IKE message that is used by IKE to find the state of an active main mode. A cookie in a received IKE message that cannot be matched with an active main mode is invalid.
    // A cookie is a value contained in a received IKE message that is used by IKE to find the state of an active main mode. A cookie in a received IKE message that cannot be matched with an active main mode is invalid.
    ULONGLONG InvalidCookiesReceived;
    #define MSiSCSI_MMIPSECStats_InvalidCookiesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_InvalidCookiesReceived_ID 10


// The total number of requests submitted by IKE to obtain a unique Security Parameters Index (SPI).
    // The total number of requests submitted by IKE to obtain a unique Security Parameters Index (SPI).
    ULONGLONG TotalGetSPI;
    #define MSiSCSI_MMIPSECStats_TotalGetSPI_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_TotalGetSPI_ID 11


// The number of outbound quick mode security associations (SAs) added by IKE 
    // The number of outbound quick mode security associations (SAs) added by IKE 
    ULONGLONG KeyAdditions;
    #define MSiSCSI_MMIPSECStats_KeyAdditions_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_KeyAdditions_ID 12


// The number of inbound quick mode security associations (SAs) added by IKE 
    // The number of inbound quick mode security associations (SAs) added by IKE 
    ULONGLONG KeyUpdates;
    #define MSiSCSI_MMIPSECStats_KeyUpdates_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_KeyUpdates_ID 13


// The total number of requests submitted by IKE to obtain a unique Security Parameters Index (SPI) that failed.
    // The total number of requests submitted by IKE to obtain a unique Security Parameters Index (SPI) that failed.
    ULONGLONG GetSPIFailures;
    #define MSiSCSI_MMIPSECStats_GetSPIFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_GetSPIFailures_ID 14


// The number of outbound quick mode security associations (SAs) submitted by IKE that failed
    // The number of outbound quick mode security associations (SAs) submitted by IKE that failed
    ULONGLONG KeyAdditionFailures;
    #define MSiSCSI_MMIPSECStats_KeyAdditionFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_KeyAdditionFailures_ID 15


// The number of inbound quick mode security associations (SAs) added by IKE 
    // The number of inbound quick mode security associations (SAs) added by IKE 
    ULONGLONG KeyUpdateFailures;
    #define MSiSCSI_MMIPSECStats_KeyUpdateFailures_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_KeyUpdateFailures_ID 16


// The number of quick mode state entries.
    // The number of quick mode state entries.
    ULONGLONG ConnectionListSize;
    #define MSiSCSI_MMIPSECStats_ConnectionListSize_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_ConnectionListSize_ID 17


// The total number of successful SAs created during main mode negotiations.
    // The total number of successful SAs created during main mode negotiations.
    ULONGLONG OakleyMainMode;
    #define MSiSCSI_MMIPSECStats_OakleyMainMode_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_OakleyMainMode_ID 18


// The total number of successful SAs created during quick mode negotiations
    // The total number of successful SAs created during quick mode negotiations
    ULONGLONG OakleyQuickMode;
    #define MSiSCSI_MMIPSECStats_OakleyQuickMode_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_OakleyQuickMode_ID 19


// The number of received IKE messages that are invalid, including IKE messages with invalid header fields, incorrect payload lengths, and incorrect values for the responder cookie (when it should be set to 0).
    // The number of received IKE messages that are invalid, including IKE messages with invalid header fields, incorrect payload lengths, and incorrect values for the responder cookie (when it should be set to 0). 
    ULONGLONG InvalidPackets;
    #define MSiSCSI_MMIPSECStats_InvalidPackets_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_InvalidPackets_ID 20


// The total number of negotiations that resulted in the use of plaintext (also known as soft SAs). This typically reflects the number of associations formed with computers that did not respond to main mode negotiation attempts. This can include both non-IPSEC-aware computers and IPSEC-aware computers that do not have IPSEC policy to negotiate security with this IPSEC peer.
    // The total number of negotiations that resulted in the use of plaintext (also known as soft SAs). This typically reflects the number of associations formed with computers that did not respond to main mode negotiation attempts. This can include both non-IPSEC-aware computers and IPSEC-aware computers that do not have IPSEC policy to negotiate security with this IPSEC peer.
    ULONGLONG SoftAssociations;
    #define MSiSCSI_MMIPSECStats_SoftAssociations_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_MMIPSECStats_SoftAssociations_ID 21

} MSiSCSI_MMIPSECStats, *PMSiSCSI_MMIPSECStats;

#define MSiSCSI_MMIPSECStats_SIZE (FIELD_OFFSET(MSiSCSI_MMIPSECStats, SoftAssociations) + MSiSCSI_MMIPSECStats_SoftAssociations_SIZE)

// MSiSCSI_QMIPSECStats - MSiSCSI_QMIPSECStats
// iSCSI HBA quick mode IPSEC Statistics

//
// This class exposes the quick mode IPSEC statistics
//
// This class must be registered with PDO instance names using a single instance
//

#define MSiSCSI_QMIPSECStatsGuid \
    { 0xb4d1c606,0x8682,0x4b7a, { 0xac,0x6b,0xd8,0x83,0xd9,0x15,0x55,0xfb } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_QMIPSECStats_GUID, \
            0xb4d1c606,0x8682,0x4b7a,0xac,0x6b,0xd8,0x83,0xd9,0x15,0x55,0xfb);
#endif


typedef struct _MSiSCSI_QMIPSECStats
{

// The number of active IPSEC SAs
    // The number of active IPSEC SAs
    ULONGLONG ActiveSA;
    #define MSiSCSI_QMIPSECStats_ActiveSA_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_ActiveSA_ID 1


// The number of IPSEC key operations in progress
    // The number of IPSEC key operations in progress
    ULONGLONG PendingKeyOperations;
    #define MSiSCSI_QMIPSECStats_PendingKeyOperations_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_PendingKeyOperations_ID 2


// The total number of successful IPSEC SA negotiations
    // The total number of successful IPSEC SA negotiations
    ULONGLONG KeyAdditions;
    #define MSiSCSI_QMIPSECStats_KeyAdditions_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_KeyAdditions_ID 3


// The total number of key deletions for IPSEC SA
    // The total number of key deletions for IPSEC SA
    ULONGLONG KeyDeletions;
    #define MSiSCSI_QMIPSECStats_KeyDeletions_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_KeyDeletions_ID 4


// The number of rekey operations for IPSEC SAs.
    // The number of rekey operations for IPSEC SAs.
    ULONGLONG ReKeys;
    #define MSiSCSI_QMIPSECStats_ReKeys_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_ReKeys_ID 5


// The number of active IPSEC tunnels.
    // The number of active IPSEC tunnels.
    ULONGLONG ActiveTunnels;
    #define MSiSCSI_QMIPSECStats_ActiveTunnels_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_ActiveTunnels_ID 6


// The total number of packets for which the Security Parameters Index (SPI) was incorrect.
    // The total number of packets for which the Security Parameters Index (SPI) was incorrect.
    ULONGLONG BadSPIPackets;
    #define MSiSCSI_QMIPSECStats_BadSPIPackets_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_BadSPIPackets_ID 7


// The total number of packets that failed decryption.
    // The total number of packets that failed decryption.
    ULONGLONG PacketsNotDecrypted;
    #define MSiSCSI_QMIPSECStats_PacketsNotDecrypted_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_PacketsNotDecrypted_ID 8


// The total number of packets for which data could not be verified. 
    // The total number of packets for which data could not be verified. 
    ULONGLONG PacketsNotAuthenticated;
    #define MSiSCSI_QMIPSECStats_PacketsNotAuthenticated_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_PacketsNotAuthenticated_ID 9


// The total number of packets that contained a valid Sequence Number field.
    // The total number of packets that contained a valid Sequence Number field.
    ULONGLONG PacketsWithReplayDetection;
    #define MSiSCSI_QMIPSECStats_PacketsWithReplayDetection_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_PacketsWithReplayDetection_ID 10


// The number of bytes sent using the ESP protocol.
    // The number of bytes sent using the ESP protocol.
    ULONGLONG ConfidentialBytesSent;
    #define MSiSCSI_QMIPSECStats_ConfidentialBytesSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_ConfidentialBytesSent_ID 11


// The number of bytes received using the ESP protocol.
    // The number of bytes received using the ESP protocol.
    ULONGLONG ConfidentialBytesReceived;
    #define MSiSCSI_QMIPSECStats_ConfidentialBytesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_ConfidentialBytesReceived_ID 12


// The number of bytes sent using the AH protocol.
    // The number of bytes sent using the AH protocol.
    ULONGLONG AuthenticatedBytesSent;
    #define MSiSCSI_QMIPSECStats_AuthenticatedBytesSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_AuthenticatedBytesSent_ID 13


// The number of bytes received using the AH protocol.
    // The number of bytes received using the AH protocol.
    ULONGLONG AuthenticatedBytesReceived;
    #define MSiSCSI_QMIPSECStats_AuthenticatedBytesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_AuthenticatedBytesReceived_ID 14


// The number of bytes sent using the IPSEC protocol.
    // The number of bytes sent using the IPSEC protocol.
    ULONGLONG TransportBytesSent;
    #define MSiSCSI_QMIPSECStats_TransportBytesSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_TransportBytesSent_ID 15


// The number of bytes received using the IPSEC protocol.
    // The number of bytes received using the IPSEC protocol.
    ULONGLONG TransportBytesReceived;
    #define MSiSCSI_QMIPSECStats_TransportBytesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_TransportBytesReceived_ID 16


// The number of bytes sent using the IPSEC tunnel mode.
    // The number of bytes sent using the IPSEC tunnel mode.
    ULONGLONG TunnelBytesSent;
    #define MSiSCSI_QMIPSECStats_TunnelBytesSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_TunnelBytesSent_ID 17


// The number of bytes received using the IPSEC tunnel mode.
    // The number of bytes received using the IPSEC tunnel mode.
    ULONGLONG TunnelBytesReceived;
    #define MSiSCSI_QMIPSECStats_TunnelBytesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_QMIPSECStats_TunnelBytesReceived_ID 18

} MSiSCSI_QMIPSECStats, *PMSiSCSI_QMIPSECStats;

#define MSiSCSI_QMIPSECStats_SIZE (FIELD_OFFSET(MSiSCSI_QMIPSECStats, TunnelBytesReceived) + MSiSCSI_QMIPSECStats_TunnelBytesReceived_SIZE)

// MSiSCSI_ConnectionStatistics - MSiSCSI_ConnectionStatistics
// iSCSI Connection Statistics

//
// This class exposes connection statistics statistics
//
// This class must be registered with dynamic instance names using
// a specific format: 
//
//       targetname_#:# where the first # is the SID, and the second
//    # is the CID.
//

#define MSiSCSI_ConnectionStatisticsGuid \
    { 0x4ae27cd9,0x8dfa,0x4c37, { 0xa4,0x2c,0xb8,0x8a,0x93,0xe3,0xe5,0x21 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_ConnectionStatistics_GUID, \
            0x4ae27cd9,0x8dfa,0x4c37,0xa4,0x2c,0xb8,0x8a,0x93,0xe3,0xe5,0x21);
#endif


typedef struct _MSiSCSI_ConnectionStatistics
{
    // Name of the iSCSI Target
    WCHAR iSCSIName[223 + 1];
    #define MSiSCSI_ConnectionStatistics_iSCSIName_ID 1

    // The iSCSI connection ID for this connection instance.
    USHORT CID;
    #define MSiSCSI_ConnectionStatistics_CID_SIZE sizeof(USHORT)
    #define MSiSCSI_ConnectionStatistics_CID_ID 2

    // A uniquely generated session ID used only internally.  This is the value returned by the LoginToTarget method.
    ULONGLONG USID;
    #define MSiSCSI_ConnectionStatistics_USID_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_ConnectionStatistics_USID_ID 3

    // Id that is globally unique to each instance of each adapter. This is the value reported by the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_ConnectionStatistics_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_ConnectionStatistics_UniqueAdapterId_ID 4

    // Count of # of bytes sent over this connection
    ULONGLONG BytesSent;
    #define MSiSCSI_ConnectionStatistics_BytesSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_ConnectionStatistics_BytesSent_ID 5

    // Count of # of bytes received over this connection
    ULONGLONG BytesReceived;
    #define MSiSCSI_ConnectionStatistics_BytesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_ConnectionStatistics_BytesReceived_ID 6

    // Count of # of  PDU sent over this connection
    ULONGLONG PDUCommandsSent;
    #define MSiSCSI_ConnectionStatistics_PDUCommandsSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_ConnectionStatistics_PDUCommandsSent_ID 7

    // Count of # of PDU received over this connection
    ULONGLONG PDUResponsesReceived;
    #define MSiSCSI_ConnectionStatistics_PDUResponsesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_ConnectionStatistics_PDUResponsesReceived_ID 8

} MSiSCSI_ConnectionStatistics, *PMSiSCSI_ConnectionStatistics;

#define MSiSCSI_ConnectionStatistics_SIZE (FIELD_OFFSET(MSiSCSI_ConnectionStatistics, PDUResponsesReceived) + MSiSCSI_ConnectionStatistics_PDUResponsesReceived_SIZE)

// MSiSCSI_SessionStatistics - MSiSCSI_SessionStatistics
// iSCSI Session Statistics

//
// This class exposes session statistics
//
// This class must be registered with dynamic instance names using
// a specific format: 
//
//       targetname_#  where the  # is the SID
//

#define MSiSCSI_SessionStatisticsGuid \
    { 0xc827993c,0x6d1f,0x4194, { 0x9b,0x5c,0xd7,0xc0,0xa5,0xf1,0xcf,0xb7 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_SessionStatistics_GUID, \
            0xc827993c,0x6d1f,0x4194,0x9b,0x5c,0xd7,0xc0,0xa5,0xf1,0xcf,0xb7);
#endif


typedef struct _MSiSCSI_SessionStatistics
{
    // Name of the iSCSI Target
    WCHAR iSCSIName[223 + 1];
    #define MSiSCSI_SessionStatistics_iSCSIName_ID 1

    // A uniquely generated session ID used only internally.  This is the value returned by the LoginToTarget method.
    ULONGLONG USID;
    #define MSiSCSI_SessionStatistics_USID_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_USID_ID 2

    // Id that is globally unique to each instance of each adapter. This is the value reported by the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_SessionStatistics_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_UniqueAdapterId_ID 3

    // Number of bytes sent over this session
    ULONGLONG BytesSent;
    #define MSiSCSI_SessionStatistics_BytesSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_BytesSent_ID 4

    // Number of bytes received over this session
    ULONGLONG BytesReceived;
    #define MSiSCSI_SessionStatistics_BytesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_BytesReceived_ID 5

    // Number of PDU sent over this session
    ULONGLONG PDUCommandsSent;
    #define MSiSCSI_SessionStatistics_PDUCommandsSent_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_PDUCommandsSent_ID 6

    // Number of PDU received over this session
    ULONGLONG PDUResponsesReceived;
    #define MSiSCSI_SessionStatistics_PDUResponsesReceived_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_PDUResponsesReceived_ID 7

    // Count of Number of Digest errors occured in this session
    ULONGLONG DigestErrors;
    #define MSiSCSI_SessionStatistics_DigestErrors_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_DigestErrors_ID 8

    // Count of Number of ConnectionTimeout errors occured in this session
    ULONGLONG ConnectionTimeoutErrors;
    #define MSiSCSI_SessionStatistics_ConnectionTimeoutErrors_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_ConnectionTimeoutErrors_ID 9

    // Count of Number of Format errors occured in this session
    ULONGLONG FormatErrors;
    #define MSiSCSI_SessionStatistics_FormatErrors_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_SessionStatistics_FormatErrors_ID 10

} MSiSCSI_SessionStatistics, *PMSiSCSI_SessionStatistics;

#define MSiSCSI_SessionStatistics_SIZE (FIELD_OFFSET(MSiSCSI_SessionStatistics, FormatErrors) + MSiSCSI_SessionStatistics_FormatErrors_SIZE)

// MSiSCSI_InitiatorLoginStatistics - MSiSCSI_InitiatorLoginStatistics
// iSCSI Initiator Login Statistics

//
// This class exposes login statistics
//
// This class must be registered with PDO instance names
//

#define MSiSCSI_InitiatorLoginStatisticsGuid \
    { 0xf022f413,0x3bf5,0x47ec, { 0xa9,0x42,0x33,0xb8,0x1c,0xf8,0xe7,0xff } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_InitiatorLoginStatistics_GUID, \
            0xf022f413,0x3bf5,0x47ec,0xa9,0x42,0x33,0xb8,0x1c,0xf8,0xe7,0xff);
#endif


typedef struct _MSiSCSI_InitiatorLoginStatistics
{
    // Id that is globally unique to each instance of each adapter. This is the value reported by the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_InitiatorLoginStatistics_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_InitiatorLoginStatistics_UniqueAdapterId_ID 1

    // Count of Login Accept Responses
    ULONG LoginAcceptRsps;
    #define MSiSCSI_InitiatorLoginStatistics_LoginAcceptRsps_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginAcceptRsps_ID 2

    // Count of Login other failed Responses
    ULONG LoginOtherFailRsps;
    #define MSiSCSI_InitiatorLoginStatistics_LoginOtherFailRsps_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginOtherFailRsps_ID 3

    // Count of Login Redirect Responses
    ULONG LoginRedirectRsps;
    #define MSiSCSI_InitiatorLoginStatistics_LoginRedirectRsps_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginRedirectRsps_ID 4

    // Count of Login Authentication Failed Responses
    ULONG LoginAuthFailRsps;
    #define MSiSCSI_InitiatorLoginStatistics_LoginAuthFailRsps_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginAuthFailRsps_ID 5

    // Count of the number of times a login is aborted due to a target authentication failure
    ULONG LoginAuthenticateFails;
    #define MSiSCSI_InitiatorLoginStatistics_LoginAuthenticateFails_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginAuthenticateFails_ID 6

    // Count of the number of times login failed due to negotiation failure with target
    ULONG LoginNegotiateFails;
    #define MSiSCSI_InitiatorLoginStatistics_LoginNegotiateFails_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginNegotiateFails_ID 7

    // Count of Logout command PDU with reason code 0
    ULONG LogoutNormals;
    #define MSiSCSI_InitiatorLoginStatistics_LogoutNormals_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LogoutNormals_ID 8

    // Count of Logout command PDUs with status code other than 0
    ULONG LogoutOtherCodes;
    #define MSiSCSI_InitiatorLoginStatistics_LogoutOtherCodes_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LogoutOtherCodes_ID 9

    // The object counts the number of times a login attempt from this local initiator has failed
    ULONG LoginFailures;
    #define MSiSCSI_InitiatorLoginStatistics_LoginFailures_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorLoginStatistics_LoginFailures_ID 10

} MSiSCSI_InitiatorLoginStatistics, *PMSiSCSI_InitiatorLoginStatistics;

#define MSiSCSI_InitiatorLoginStatistics_SIZE (FIELD_OFFSET(MSiSCSI_InitiatorLoginStatistics, LoginFailures) + MSiSCSI_InitiatorLoginStatistics_LoginFailures_SIZE)

// MSiSCSI_InitiatorInstanceStatistics - MSiSCSI_InitiatorInstanceStatistics
// iSCSI Initiator Instance Statistics

//
// This class exposes initiator statistics
//
// This class must be registered with PDO instance names
//

#define MSiSCSI_InitiatorInstanceStatisticsGuid \
    { 0xfa30c290,0x68db,0x430a, { 0xaf,0x76,0x91,0xa2,0xe1,0xc4,0x91,0x54 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_InitiatorInstanceStatistics_GUID, \
            0xfa30c290,0x68db,0x430a,0xaf,0x76,0x91,0xa2,0xe1,0xc4,0x91,0x54);
#endif


typedef struct _MSiSCSI_InitiatorInstanceStatistics
{
    // Id that is globally unique to each instance of each adapter. This is the value reported by the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_InitiatorInstanceStatistics_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_InitiatorInstanceStatistics_UniqueAdapterId_ID 1

    // Count of Session digest errors
    ULONG SessionDigestErrorCount;
    #define MSiSCSI_InitiatorInstanceStatistics_SessionDigestErrorCount_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorInstanceStatistics_SessionDigestErrorCount_ID 2

    // Count of Session connection timeout error
    ULONG SessionConnectionTimeoutErrorCount;
    #define MSiSCSI_InitiatorInstanceStatistics_SessionConnectionTimeoutErrorCount_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorInstanceStatistics_SessionConnectionTimeoutErrorCount_ID 3

    // Count of Session format error
    ULONG SessionFormatErrorCount;
    #define MSiSCSI_InitiatorInstanceStatistics_SessionFormatErrorCount_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorInstanceStatistics_SessionFormatErrorCount_ID 4

    // Number of Sessions failed belonging to this instance
    ULONG SessionFailureCount;
    #define MSiSCSI_InitiatorInstanceStatistics_SessionFailureCount_SIZE sizeof(ULONG)
    #define MSiSCSI_InitiatorInstanceStatistics_SessionFailureCount_ID 5

} MSiSCSI_InitiatorInstanceStatistics, *PMSiSCSI_InitiatorInstanceStatistics;

#define MSiSCSI_InitiatorInstanceStatistics_SIZE (FIELD_OFFSET(MSiSCSI_InitiatorInstanceStatistics, SessionFailureCount) + MSiSCSI_InitiatorInstanceStatistics_SessionFailureCount_SIZE)

// MSiSCSI_NICPerformance - MSiSCSI_NICPerformance

//
// NIC performance information class, implement one instance for each port on
// your adapter. 
//
// This class must be registered with PDO instance names with one instance
// names for each port
//

#define MSiSCSI_NICPerformanceGuid \
    { 0x5c59fd61,0xe919,0x4687, { 0x84,0xe2,0x72,0x00,0xab,0xe2,0x20,0x9b } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_NICPerformance_GUID, \
            0x5c59fd61,0xe919,0x4687,0x84,0xe2,0x72,0x00,0xab,0xe2,0x20,0x9b);
#endif


typedef struct _MSiSCSI_NICPerformance
{
    // Number of bytes transmitted via ethernet port
    ULONG BytesTransmitted;
    #define MSiSCSI_NICPerformance_BytesTransmitted_SIZE sizeof(ULONG)
    #define MSiSCSI_NICPerformance_BytesTransmitted_ID 1

    // Number of bytes received via ethernet port
    ULONG BytesReceived;
    #define MSiSCSI_NICPerformance_BytesReceived_SIZE sizeof(ULONG)
    #define MSiSCSI_NICPerformance_BytesReceived_ID 2

    // Number of PDU transmitted via ethernet port
    ULONG PDUTransmitted;
    #define MSiSCSI_NICPerformance_PDUTransmitted_SIZE sizeof(ULONG)
    #define MSiSCSI_NICPerformance_PDUTransmitted_ID 3

    // Number of PDU received via ethernet port
    ULONG PDUReceived;
    #define MSiSCSI_NICPerformance_PDUReceived_SIZE sizeof(ULONG)
    #define MSiSCSI_NICPerformance_PDUReceived_ID 4

} MSiSCSI_NICPerformance, *PMSiSCSI_NICPerformance;

#define MSiSCSI_NICPerformance_SIZE (FIELD_OFFSET(MSiSCSI_NICPerformance, PDUReceived) + MSiSCSI_NICPerformance_PDUReceived_SIZE)

// MSiSCSI_RequestTimeStatistics - MSiSCSI_RequestTimeStatistics
// iSCSI Request Processing Time

//
// This class exposes request processing time statistics
//
// This class must be registered with dynamic instance names using
// a specific format: 
//
//       targetname_#:# where the first # is the SID, and the second
//    # is the CID.
//

#define MSiSCSI_RequestTimeStatisticsGuid \
    { 0xe0b40aa8,0x544b,0x4d5e, { 0xba,0x60,0xa0,0x3f,0x13,0x6d,0xa8,0x3d } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSiSCSI_RequestTimeStatistics_GUID, \
            0xe0b40aa8,0x544b,0x4d5e,0xba,0x60,0xa0,0x3f,0x13,0x6d,0xa8,0x3d);
#endif


typedef struct _MSiSCSI_RequestTimeStatistics
{
    // Name of the iSCSI Target
    WCHAR iSCSIName[223 + 1];
    #define MSiSCSI_RequestTimeStatistics_iSCSIName_ID 1

    // The iSCSI connection ID for this connection instance.
    USHORT CID;
    #define MSiSCSI_RequestTimeStatistics_CID_SIZE sizeof(USHORT)
    #define MSiSCSI_RequestTimeStatistics_CID_ID 2

    // A uniquely generated session ID used only internally.  This is the value returned by the LoginToTarget method.
    ULONGLONG USID;
    #define MSiSCSI_RequestTimeStatistics_USID_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_RequestTimeStatistics_USID_ID 3

    // Id that is globally unique to each instance of each adapter. This is the value reported by the MSiSCSI_HBAInformation class.
    ULONGLONG UniqueAdapterId;
    #define MSiSCSI_RequestTimeStatistics_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSiSCSI_RequestTimeStatistics_UniqueAdapterId_ID 4

    // Maximum time taken to process a request over this connection
    ULONG MaximumProcessingTime;
    #define MSiSCSI_RequestTimeStatistics_MaximumProcessingTime_SIZE sizeof(ULONG)
    #define MSiSCSI_RequestTimeStatistics_MaximumProcessingTime_ID 5

    // Average time taken to process a request over this connection
    ULONG AverageProcessingTime;
    #define MSiSCSI_RequestTimeStatistics_AverageProcessingTime_SIZE sizeof(ULONG)
    #define MSiSCSI_RequestTimeStatistics_AverageProcessingTime_ID 6

} MSiSCSI_RequestTimeStatistics, *PMSiSCSI_RequestTimeStatistics;

#define MSiSCSI_RequestTimeStatistics_SIZE (FIELD_OFFSET(MSiSCSI_RequestTimeStatistics, AverageProcessingTime) + MSiSCSI_RequestTimeStatistics_AverageProcessingTime_SIZE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\lmwksta.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmwksta.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetWorkstation and NetWkstaTransport API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMWKSTA_
#define _LMWKSTA_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>
#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __deref_opt_out OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaSetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buffer,
    __out_opt OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    __in_opt IN  LMSTR  reserved,
    IN  DWORD   level,
    __out_opt OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserSetInfo (
    __in_opt IN  LMSTR  reserved,
    IN  DWORD   level,
    OUT LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserEnum (
    __in_opt LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out_opt LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out_opt LPDWORD     entriesread,
    __out LPDWORD     totalentries,
    __inout_opt LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportAdd (
    __in_opt LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __in LPBYTE  buf,
    __out_opt LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportDel (
    __in_opt IN  LMSTR   servername OPTIONAL,
    __in_opt IN  LMSTR   transportname,
    IN  DWORD   ucond
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportEnum (
    __in_opt LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out_opt LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out_opt LPDWORD     entriesread,
    __out LPDWORD     totalentries,
    __inout_opt LPDWORD resumehandle OPTIONAL
    );

//
//  Data Structures
//

//
// NetWkstaGetInfo and NetWkstaSetInfo
//

//
// NetWkstaGetInfo only.  System information - guest access
//
typedef struct _WKSTA_INFO_100 {
    DWORD   wki100_platform_id;
    LMSTR   wki100_computername;
    LMSTR   wki100_langroup;
    DWORD   wki100_ver_major;
    DWORD   wki100_ver_minor;
}WKSTA_INFO_100, *PWKSTA_INFO_100, *LPWKSTA_INFO_100;

//
// NetWkstaGetInfo only.  System information - user access
//
typedef struct _WKSTA_INFO_101 {
    DWORD   wki101_platform_id;
    LMSTR   wki101_computername;
    LMSTR   wki101_langroup;
    DWORD   wki101_ver_major;
    DWORD   wki101_ver_minor;
    LMSTR   wki101_lanroot;
}WKSTA_INFO_101, *PWKSTA_INFO_101, *LPWKSTA_INFO_101;

//
// NetWkstaGetInfo only.  System information - admin or operator access
//
typedef struct _WKSTA_INFO_102 {
    DWORD   wki102_platform_id;
    LMSTR   wki102_computername;
    LMSTR   wki102_langroup;
    DWORD   wki102_ver_major;
    DWORD   wki102_ver_minor;
    LMSTR   wki102_lanroot;
    DWORD   wki102_logged_on_users;
}WKSTA_INFO_102, *PWKSTA_INFO_102, *LPWKSTA_INFO_102;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// DOS specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_302{
    DWORD   wki302_char_wait;
    DWORD   wki302_collection_time;
    DWORD   wki302_maximum_collection_count;
    DWORD   wki302_keep_conn;
    DWORD   wki302_keep_search;
    DWORD   wki302_max_cmds;
    DWORD   wki302_num_work_buf;
    DWORD   wki302_siz_work_buf;
    DWORD   wki302_max_wrk_cache;
    DWORD   wki302_sess_timeout;
    DWORD   wki302_siz_error;
    DWORD   wki302_num_alerts;
    DWORD   wki302_num_services;
    DWORD   wki302_errlog_sz;
    DWORD   wki302_print_buf_time;
    DWORD   wki302_num_char_buf;
    DWORD   wki302_siz_char_buf;
    LMSTR   wki302_wrk_heuristics;
    DWORD   wki302_mailslots;
    DWORD   wki302_num_dgram_buf;
}WKSTA_INFO_302, *PWKSTA_INFO_302, *LPWKSTA_INFO_302;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo
//
// OS/2 specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_402{
    DWORD   wki402_char_wait;
    DWORD   wki402_collection_time;
    DWORD   wki402_maximum_collection_count;
    DWORD   wki402_keep_conn;
    DWORD   wki402_keep_search;
    DWORD   wki402_max_cmds;
    DWORD   wki402_num_work_buf;
    DWORD   wki402_siz_work_buf;
    DWORD   wki402_max_wrk_cache;
    DWORD   wki402_sess_timeout;
    DWORD   wki402_siz_error;
    DWORD   wki402_num_alerts;
    DWORD   wki402_num_services;
    DWORD   wki402_errlog_sz;
    DWORD   wki402_print_buf_time;
    DWORD   wki402_num_char_buf;
    DWORD   wki402_siz_char_buf;
    LMSTR   wki402_wrk_heuristics;
    DWORD   wki402_mailslots;
    DWORD   wki402_num_dgram_buf;
    DWORD   wki402_max_threads;
}WKSTA_INFO_402, *PWKSTA_INFO_402, *LPWKSTA_INFO_402;

//
// Same-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// NT specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_502{
    DWORD   wki502_char_wait;
    DWORD   wki502_collection_time;
    DWORD   wki502_maximum_collection_count;
    DWORD   wki502_keep_conn;
    DWORD   wki502_max_cmds;
    DWORD   wki502_sess_timeout;
    DWORD   wki502_siz_char_buf;
    DWORD   wki502_max_threads;

    DWORD   wki502_lock_quota;
    DWORD   wki502_lock_increment;
    DWORD   wki502_lock_maximum;
    DWORD   wki502_pipe_increment;
    DWORD   wki502_pipe_maximum;
    DWORD   wki502_cache_file_timeout;
    DWORD   wki502_dormant_file_limit;
    DWORD   wki502_read_ahead_throughput;

    DWORD   wki502_num_mailslot_buffers;
    DWORD   wki502_num_srv_announce_buffers;
    DWORD   wki502_max_illegal_datagram_events;
    DWORD   wki502_illegal_datagram_event_reset_frequency;
    BOOL    wki502_log_election_packets;

    BOOL    wki502_use_opportunistic_locking;
    BOOL    wki502_use_unlock_behind;
    BOOL    wki502_use_close_behind;
    BOOL    wki502_buf_named_pipes;
    BOOL    wki502_use_lock_read_unlock;
    BOOL    wki502_utilize_nt_caching;
    BOOL    wki502_use_raw_read;
    BOOL    wki502_use_raw_write;
    BOOL    wki502_use_write_raw_data;
    BOOL    wki502_use_encryption;
    BOOL    wki502_buf_files_deny_write;
    BOOL    wki502_buf_read_only_files;
    BOOL    wki502_force_core_create_mode;
    BOOL    wki502_use_512_byte_max_transfer;
}WKSTA_INFO_502, *PWKSTA_INFO_502, *LPWKSTA_INFO_502;


//
// The following info-levels are only valid for NetWkstaSetInfo
//

//
// The following levels are supported on down-level systems (LAN Man 2.x)
// as well as NT systems:
//
typedef struct _WKSTA_INFO_1010 {
     DWORD  wki1010_char_wait;
} WKSTA_INFO_1010, *PWKSTA_INFO_1010, *LPWKSTA_INFO_1010;

typedef struct _WKSTA_INFO_1011 {
     DWORD  wki1011_collection_time;
} WKSTA_INFO_1011, *PWKSTA_INFO_1011, *LPWKSTA_INFO_1011;

typedef struct _WKSTA_INFO_1012 {
     DWORD  wki1012_maximum_collection_count;
} WKSTA_INFO_1012, *PWKSTA_INFO_1012, *LPWKSTA_INFO_1012;

//
// The following level are supported on down-level systems (LAN Man 2.x)
// only:
//
typedef struct _WKSTA_INFO_1027 {
     DWORD  wki1027_errlog_sz;
} WKSTA_INFO_1027, *PWKSTA_INFO_1027, *LPWKSTA_INFO_1027;

typedef struct _WKSTA_INFO_1028 {
     DWORD  wki1028_print_buf_time;
} WKSTA_INFO_1028, *PWKSTA_INFO_1028, *LPWKSTA_INFO_1028;

typedef struct _WKSTA_INFO_1032 {
     DWORD  wki1032_wrk_heuristics;
} WKSTA_INFO_1032, *PWKSTA_INFO_1032, *LPWKSTA_INFO_1032;

//
// The following levels are settable on NT systems, and have no
// effect on down-level systems (i.e. LANMan 2.x) since these
// fields cannot be set on them:
//
typedef struct _WKSTA_INFO_1013 {
     DWORD  wki1013_keep_conn;
} WKSTA_INFO_1013, *PWKSTA_INFO_1013, *LPWKSTA_INFO_1013;

typedef struct _WKSTA_INFO_1018 {
     DWORD  wki1018_sess_timeout;
} WKSTA_INFO_1018, *PWKSTA_INFO_1018, *LPWKSTA_INFO_1018;

typedef struct _WKSTA_INFO_1023 {
     DWORD  wki1023_siz_char_buf;
} WKSTA_INFO_1023, *PWKSTA_INFO_1023, *LPWKSTA_INFO_1023;

typedef struct _WKSTA_INFO_1033 {
     DWORD  wki1033_max_threads;
} WKSTA_INFO_1033, *PWKSTA_INFO_1033, *LPWKSTA_INFO_1033;

//
// The following levels are only supported on NT systems:
//
typedef struct _WKSTA_INFO_1041 {
    DWORD   wki1041_lock_quota;
} WKSTA_INFO_1041, *PWKSTA_INFO_1041, *LPWKSTA_INFO_1041;

typedef struct _WKSTA_INFO_1042 {
    DWORD   wki1042_lock_increment;
} WKSTA_INFO_1042, *PWKSTA_INFO_1042, *LPWKSTA_INFO_1042;

typedef struct _WKSTA_INFO_1043 {
    DWORD   wki1043_lock_maximum;
} WKSTA_INFO_1043, *PWKSTA_INFO_1043, *LPWKSTA_INFO_1043;

typedef struct _WKSTA_INFO_1044 {
    DWORD   wki1044_pipe_increment;
} WKSTA_INFO_1044, *PWKSTA_INFO_1044, *LPWKSTA_INFO_1044;

typedef struct _WKSTA_INFO_1045 {
    DWORD   wki1045_pipe_maximum;
} WKSTA_INFO_1045, *PWKSTA_INFO_1045, *LPWKSTA_INFO_1045;

typedef struct _WKSTA_INFO_1046 {
    DWORD   wki1046_dormant_file_limit;
} WKSTA_INFO_1046, *PWKSTA_INFO_1046, *LPWKSTA_INFO_1046;

typedef struct _WKSTA_INFO_1047 {
    DWORD    wki1047_cache_file_timeout;
} WKSTA_INFO_1047, *PWKSTA_INFO_1047, *LPWKSTA_INFO_1047;

typedef struct _WKSTA_INFO_1048 {
    BOOL     wki1048_use_opportunistic_locking;
} WKSTA_INFO_1048, *PWKSTA_INFO_1048, *LPWKSTA_INFO_1048;

typedef struct _WKSTA_INFO_1049 {
    BOOL     wki1049_use_unlock_behind;
} WKSTA_INFO_1049, *PWKSTA_INFO_1049, *LPWKSTA_INFO_1049;

typedef struct _WKSTA_INFO_1050 {
    BOOL     wki1050_use_close_behind;
} WKSTA_INFO_1050, *PWKSTA_INFO_1050, *LPWKSTA_INFO_1050;

typedef struct _WKSTA_INFO_1051 {
    BOOL     wki1051_buf_named_pipes;
} WKSTA_INFO_1051, *PWKSTA_INFO_1051, *LPWKSTA_INFO_1051;

typedef struct _WKSTA_INFO_1052 {
    BOOL     wki1052_use_lock_read_unlock;
} WKSTA_INFO_1052, *PWKSTA_INFO_1052, *LPWKSTA_INFO_1052;

typedef struct _WKSTA_INFO_1053 {
    BOOL     wki1053_utilize_nt_caching;
} WKSTA_INFO_1053, *PWKSTA_INFO_1053, *LPWKSTA_INFO_1053;

typedef struct _WKSTA_INFO_1054 {
    BOOL     wki1054_use_raw_read;
} WKSTA_INFO_1054, *PWKSTA_INFO_1054, *LPWKSTA_INFO_1054;

typedef struct _WKSTA_INFO_1055 {
    BOOL     wki1055_use_raw_write;
} WKSTA_INFO_1055, *PWKSTA_INFO_1055, *LPWKSTA_INFO_1055;

typedef struct _WKSTA_INFO_1056 {
    BOOL     wki1056_use_write_raw_data;
} WKSTA_INFO_1056, *PWKSTA_INFO_1056, *LPWKSTA_INFO_1056;

typedef struct _WKSTA_INFO_1057 {
    BOOL     wki1057_use_encryption;
} WKSTA_INFO_1057, *PWKSTA_INFO_1057, *LPWKSTA_INFO_1057;

typedef struct _WKSTA_INFO_1058 {
    BOOL     wki1058_buf_files_deny_write;
} WKSTA_INFO_1058, *PWKSTA_INFO_1058, *LPWKSTA_INFO_1058;

typedef struct _WKSTA_INFO_1059 {
    BOOL     wki1059_buf_read_only_files;
} WKSTA_INFO_1059, *PWKSTA_INFO_1059, *LPWKSTA_INFO_1059;

typedef struct _WKSTA_INFO_1060 {
    BOOL     wki1060_force_core_create_mode;
} WKSTA_INFO_1060, *PWKSTA_INFO_1060, *LPWKSTA_INFO_1060;

typedef struct _WKSTA_INFO_1061 {
    BOOL     wki1061_use_512_byte_max_transfer;
} WKSTA_INFO_1061, *PWKSTA_INFO_1061, *LPWKSTA_INFO_1061;

typedef struct _WKSTA_INFO_1062 {
    DWORD   wki1062_read_ahead_throughput;
} WKSTA_INFO_1062, *PWKSTA_INFO_1062, *LPWKSTA_INFO_1062;


//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_0 {
    LMSTR   wkui0_username;
}WKSTA_USER_INFO_0, *PWKSTA_USER_INFO_0, *LPWKSTA_USER_INFO_0;

//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_1 {
    LMSTR   wkui1_username;
    LMSTR   wkui1_logon_domain;
    LMSTR   wkui1_oth_domains;
    LMSTR   wkui1_logon_server;
}WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;

//
// NetWkstaUserSetInfo - local access.
//
typedef struct _WKSTA_USER_INFO_1101 {
     LMSTR   wkui1101_oth_domains;
} WKSTA_USER_INFO_1101, *PWKSTA_USER_INFO_1101,
  *LPWKSTA_USER_INFO_1101;


//
// NetWkstaTransportAdd - admin access
//
typedef struct _WKSTA_TRANSPORT_INFO_0 {
    DWORD   wkti0_quality_of_service;
    DWORD   wkti0_number_of_vcs;
    LMSTR   wkti0_transport_name;
    LMSTR   wkti0_transport_address;
    BOOL    wkti0_wan_ish;
}WKSTA_TRANSPORT_INFO_0, *PWKSTA_TRANSPORT_INFO_0,
 *LPWKSTA_TRANSPORT_INFO_0;


//
// Special Values and Constants
//

//
//  Identifiers for use as NetWkstaSetInfo parmnum parameter
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaSetInfo.
//

#define WKSTA_PLATFORM_ID_PARMNUM               100
#define WKSTA_COMPUTERNAME_PARMNUM              1
#define WKSTA_LANGROUP_PARMNUM                  2
#define WKSTA_VER_MAJOR_PARMNUM                 4
#define WKSTA_VER_MINOR_PARMNUM                 5
#define WKSTA_LOGGED_ON_USERS_PARMNUM           6
#define WKSTA_LANROOT_PARMNUM                   7
#define WKSTA_LOGON_DOMAIN_PARMNUM              8
#define WKSTA_LOGON_SERVER_PARMNUM              9
#define WKSTA_CHARWAIT_PARMNUM                  10  // Supported by down-level.
#define WKSTA_CHARTIME_PARMNUM                  11  // Supported by down-level.
#define WKSTA_CHARCOUNT_PARMNUM                 12  // Supported by down-level.
#define WKSTA_KEEPCONN_PARMNUM                  13
#define WKSTA_KEEPSEARCH_PARMNUM                14
#define WKSTA_MAXCMDS_PARMNUM                   15
#define WKSTA_NUMWORKBUF_PARMNUM                16
#define WKSTA_MAXWRKCACHE_PARMNUM               17
#define WKSTA_SESSTIMEOUT_PARMNUM               18
#define WKSTA_SIZERROR_PARMNUM                  19
#define WKSTA_NUMALERTS_PARMNUM                 20
#define WKSTA_NUMSERVICES_PARMNUM               21
#define WKSTA_NUMCHARBUF_PARMNUM                22
#define WKSTA_SIZCHARBUF_PARMNUM                23
#define WKSTA_ERRLOGSZ_PARMNUM                  27  // Supported by down-level.
#define WKSTA_PRINTBUFTIME_PARMNUM              28  // Supported by down-level.
#define WKSTA_SIZWORKBUF_PARMNUM                29
#define WKSTA_MAILSLOTS_PARMNUM                 30
#define WKSTA_NUMDGRAMBUF_PARMNUM               31
#define WKSTA_WRKHEURISTICS_PARMNUM             32  // Supported by down-level.
#define WKSTA_MAXTHREADS_PARMNUM                33

#define WKSTA_LOCKQUOTA_PARMNUM                 41
#define WKSTA_LOCKINCREMENT_PARMNUM             42
#define WKSTA_LOCKMAXIMUM_PARMNUM               43
#define WKSTA_PIPEINCREMENT_PARMNUM             44
#define WKSTA_PIPEMAXIMUM_PARMNUM               45
#define WKSTA_DORMANTFILELIMIT_PARMNUM          46
#define WKSTA_CACHEFILETIMEOUT_PARMNUM          47
#define WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM   48
#define WKSTA_USEUNLOCKBEHIND_PARMNUM           49
#define WKSTA_USECLOSEBEHIND_PARMNUM            50
#define WKSTA_BUFFERNAMEDPIPES_PARMNUM          51
#define WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM   52
#define WKSTA_UTILIZENTCACHING_PARMNUM          53
#define WKSTA_USERAWREAD_PARMNUM                54
#define WKSTA_USERAWWRITE_PARMNUM               55
#define WKSTA_USEWRITERAWWITHDATA_PARMNUM       56
#define WKSTA_USEENCRYPTION_PARMNUM             57
#define WKSTA_BUFFILESWITHDENYWRITE_PARMNUM     58
#define WKSTA_BUFFERREADONLYFILES_PARMNUM       59
#define WKSTA_FORCECORECREATEMODE_PARMNUM       60
#define WKSTA_USE512BYTESMAXTRANSFER_PARMNUM    61
#define WKSTA_READAHEADTHRUPUT_PARMNUM          62


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaUserSetInfo.
//

#define WKSTA_OTH_DOMAINS_PARMNUM              101


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaTransportAdd.
//

#define TRANSPORT_QUALITYOFSERVICE_PARMNUM     201
#define TRANSPORT_NAME_PARMNUM                 202

#ifdef __cplusplus
}
#endif

#endif // _LMWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\mf.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mf.h

Abstract:

    This header describes the structures and interfaces required to interact
    with the multifunction enumerator.

Author:

Revision History:

--*/


#if !defined(_MF_)
#define _MF_

//
// MfFlags value
//

#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

typedef struct _MF_RESOURCE_MAP {

    ULONG Count;
    UCHAR Resources[ANYSIZE_ARRAY];

} MF_RESOURCE_MAP, *PMF_RESOURCE_MAP;


typedef struct _MF_VARYING_RESOURCE_ENTRY {

    UCHAR ResourceIndex;
    UCHAR Reserved[3];      // Packing
    ULONG Offset;
    ULONG Size;
    ULONG MaxCount;

} MF_VARYING_RESOURCE_ENTRY, *PMF_VARYING_RESOURCE_ENTRY;


typedef struct _MF_VARYING_RESOURCE_MAP {

    ULONG Count;
    MF_VARYING_RESOURCE_ENTRY Resources[ANYSIZE_ARRAY];

} MF_VARYING_RESOURCE_MAP, *PMF_VARYING_RESOURCE_MAP;


typedef struct _MF_DEVICE_INFO *PMF_DEVICE_INFO;

typedef struct _MF_DEVICE_INFO {

    //
    // Name for this child, unique with respect to the other children
    //
    UNICODE_STRING Name;

    //
    // A REG_MULTI_SZ style list of hardware IDs
    //
    UNICODE_STRING HardwareID;

    //
    // A REG_MULTI_SZ style list of compatible IDs
    //
    UNICODE_STRING CompatibleID;

    //
    // Map of resource that we totally consume
    //
    PMF_RESOURCE_MAP ResourceMap;

    //
    // Map of resource that we partially consume
    //
    PMF_VARYING_RESOURCE_MAP VaryingResourceMap;

    //
    // Flags -
    //      MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE - if the parent resource doesn't
    //          contain a descriptor referenced in the ResourceMap use a
    //          null (CmResourceTypeNull) descriptor instead.
    //
    ULONG MfFlags;

} MF_DEVICE_INFO;

typedef
NTSTATUS
(*PMF_ENUMERATE_CHILD)(
    IN PVOID Context,
    IN ULONG Index,
    OUT PMF_DEVICE_INFO ChildInfo
    );

/*++


Routine Description:

    This returns information about children to be enumerated by a multifunction
    driver.

Arguments:

    Context - Context from the MF_ENUMERATION_INTERFACE

    Index - Zero based index of the children

    ChildInfo - Pointer to a caller allocated buffer that should be filled in
        by the callee.  This will involve allocation of extra buffers for each
        piece of information.  These will be freed by calling ExFreePool when
        they are no longer required.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NO_MORE_ENTRIES indicates that the are no more children to enumerate

--*/

typedef struct _MF_ENUMERATION_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Multi-function enumeration data
    //
    PMF_ENUMERATE_CHILD EnumerateChild;

} MF_ENUMERATION_INTERFACE, *PMF_ENUMERATION_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\mcd.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    mcd.h

Abstract:

    These are the structures and defines that are used in the
    changer class drivers. The changer class driver is separated
    into two modules. Mcd.c contains code common to all medium
    changer drivers including the driver's major entry points.


Environment:

    Kernel mode

Revision History :

--*/


#include "scsi.h"
#include "ntddchgr.h"
#include <classpnp.h>

#if (NTDDI_VERSION >= NTDDI_WINXP)
#include <wmidata.h>
#include <wmistr.h>
#endif

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#if (NTDDI_VERSION < NTDDI_WINXP)
#define DebugPrint(x) MCDebugPrint x
#else
#define DebugPrint(x) ChangerClassDebugPrint x
#endif
#else
#define DebugPrint(x)
#endif

#define MAXIMUM_CHANGER_INQUIRY_DATA 252

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef
NTSTATUS
(*CHANGER_COMMAND_ROUTINE)(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );

typedef
ULONG
(*CHANGER_EXTENSION_SIZE)(
    IN VOID
    );

typedef
NTSTATUS
(*CHANGER_INITIALIZE)(
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*CHANGER_PERFORM_DIAGNOSTICS)(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    );

typedef
VOID
(*CHANGER_ERROR_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN NTSTATUS *Status,
    IN BOOLEAN *Retry
    );

typedef struct _MCD_INIT_DATA {

    //
    // Size of this structure.
    //

    ULONG InitDataSize;

    //
    // To return the size of the minidriver extension
    //

    CHANGER_EXTENSION_SIZE ChangerAdditionalExtensionSize;

    //
    // To perform minidriver specific initialization
    //

    CHANGER_INITIALIZE     ChangerInitialize;

    //
    // To perform minidriver specific error processing
    //

    CHANGER_ERROR_ROUTINE  ChangerError;

    //
    // To perform diagnostic tests on the device
    //

    CHANGER_PERFORM_DIAGNOSTICS ChangerPerformDiagnostics;

    //
    // Minidriver dispatch routines
    //

    CHANGER_COMMAND_ROUTINE   ChangerGetParameters;

    CHANGER_COMMAND_ROUTINE   ChangerGetStatus;

    CHANGER_COMMAND_ROUTINE   ChangerGetProductData;

    CHANGER_COMMAND_ROUTINE   ChangerSetAccess;

    CHANGER_COMMAND_ROUTINE   ChangerGetElementStatus;

    CHANGER_COMMAND_ROUTINE   ChangerInitializeElementStatus;

    CHANGER_COMMAND_ROUTINE   ChangerSetPosition;

    CHANGER_COMMAND_ROUTINE   ChangerExchangeMedium;

    CHANGER_COMMAND_ROUTINE   ChangerMoveMedium;

    CHANGER_COMMAND_ROUTINE   ChangerReinitializeUnit;

    CHANGER_COMMAND_ROUTINE   ChangerQueryVolumeTags;

} MCD_INIT_DATA, *PMCD_INIT_DATA;
#endif

typedef struct _MODE_ELEMENT_ADDRESS_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransportElementAddress[2];
    UCHAR NumberTransportElements[2];
    UCHAR FirstStorageElementAddress[2];
    UCHAR NumberStorageElements[2];
    UCHAR FirstIEPortElementAddress[2];
    UCHAR NumberIEPortElements[2];
    UCHAR FirstDataXFerElementAddress[2];
    UCHAR NumberDataXFerElements[2];
    UCHAR Reserved2[2];

} MODE_ELEMENT_ADDRESS_PAGE, *PMODE_ELEMENT_ADDRESS_PAGE;

typedef struct _MODE_TRANSPORT_GEOMETRY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR Flip : 1;
    UCHAR Reserved2: 7;
    UCHAR TransportElementNumber;

} MODE_TRANSPORT_GEOMETRY_PAGE, *PMODE_TRANSPORT_GEOMETRY_PAGE;

//
// Capabilities page decribes the various functions that the device
// supports. Used in GetParameters.
//

typedef struct _MODE_DEVICE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransport : 1;
    UCHAR StorageLocation : 1;
    UCHAR IEPort : 1;
    UCHAR DataXFer : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR MTtoMT : 1;
    UCHAR MTtoST : 1;
    UCHAR MTtoIE : 1;
    UCHAR MTtoDT : 1;
    UCHAR Reserved4 : 4;
    UCHAR STtoMT : 1;
    UCHAR STtoST : 1;
    UCHAR STtoIE : 1;
    UCHAR STtoDT : 1;
    UCHAR Reserved5 : 4;
    UCHAR IEtoMT : 1;
    UCHAR IEtoST : 1;
    UCHAR IEtoIE : 1;
    UCHAR IEtoDT : 1;
    UCHAR Reserved6 : 4;
    UCHAR DTtoMT : 1;
    UCHAR DTtoST : 1;
    UCHAR DTtoIE : 1;
    UCHAR DTtoDT : 1;
    UCHAR Reserved7 : 4;
    UCHAR Reserved8[4];
    UCHAR XMTtoMT : 1;
    UCHAR XMTtoST : 1;
    UCHAR XMTtoIE : 1;
    UCHAR XMTtoDT : 1;
    UCHAR Reserved9 : 4;
    UCHAR XSTtoMT : 1;
    UCHAR XSTtoST : 1;
    UCHAR XSTtoIE : 1;
    UCHAR XSTtoDT : 1;
    UCHAR Reserved10 : 4;
    UCHAR XIEtoMT : 1;
    UCHAR XIEtoST : 1;
    UCHAR XIEtoIE : 1;
    UCHAR XIEtoDT : 1;
    UCHAR Reserved11 : 4;
    UCHAR XDTtoMT : 1;
    UCHAR XDTtoST : 1;
    UCHAR XDTtoIE : 1;
    UCHAR XDTtoDT : 1;
    UCHAR Reserved12 : 4;

} MODE_DEVICE_CAPABILITIES_PAGE, *PMODE_DEVICE_CAPABILITIES_PAGE;

#define MODE_PAGE_DISPLAY 0x22

//
// Structures describing return data from READ_ELEMENT_STATUS
//

typedef struct _ELEMENT_STATUS_HEADER {
    UCHAR FirstElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} ELEMENT_STATUS_HEADER, *PELEMENT_STATUS_HEADER;

typedef struct _ELEMENT_STATUS_PAGE {
    UCHAR ElementType;
    UCHAR Reserved1 : 6;
    UCHAR AVolTag : 1;
    UCHAR PVolTag : 1;
    UCHAR ElementDescriptorLength[2];
    UCHAR Reserved2;
    UCHAR DescriptorByteCount[3];
} ELEMENT_STATUS_PAGE, *PELEMENT_STATUS_PAGE;


typedef struct _ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} ELEMENT_DESCRIPTOR, *PELEMENT_DESCRIPTOR;


//
// The following routines are the exported entry points for
// all changer class drivers.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    );


//
// The following routines are provided by the changer
// device-specific module. Each routine name is
// prefixed with 'Changer.'


ULONG
ChangerAdditionalExtensionSize(
    VOID
    );

NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
NTSTATUS
ChangerClassInitialize(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  PMCD_INIT_DATA ChangerInitData
    );

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    );

NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    );

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );
#endif

#if (NTDDI_VERSION < NTDDI_WINXP)
VOID
MCDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

BOOLEAN
ChangerVerifyInquiry(
    PINQUIRYDATA InquiryData
    );
#endif

#if (NTDDI_VERSION < NTDDI_WS03)
NTSTATUS
ChangerClassCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\miniport.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field other than int
#endif
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

//
// For compilers that don't support nameless unions/structs
//
#ifndef DUMMYUNIONNAME
#if defined(NONAMELESSUNION) || !defined(_MSC_EXTENSIONS)
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#define DUMMYUNIONNAME6  u6
#define DUMMYUNIONNAME7  u7
#define DUMMYUNIONNAME8  u8
#define DUMMYUNIONNAME9  u9
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#define DUMMYUNIONNAME6
#define DUMMYUNIONNAME7
#define DUMMYUNIONNAME8
#define DUMMYUNIONNAME9
#endif
#endif // DUMMYUNIONNAME

#ifndef DUMMYSTRUCTNAME
#if defined(NONAMELESSUNION) || !defined(_MSC_EXTENSIONS)
#define DUMMYSTRUCTNAME  s
#define DUMMYSTRUCTNAME2 s2
#define DUMMYSTRUCTNAME3 s3
#define DUMMYSTRUCTNAME4 s4
#define DUMMYSTRUCTNAME5 s5
#else
#define DUMMYSTRUCTNAME
#define DUMMYSTRUCTNAME2
#define DUMMYSTRUCTNAME3
#define DUMMYSTRUCTNAME4
#define DUMMYSTRUCTNAME5
#endif
#endif // DUMMYSTRUCTNAME

#include <specstrings.h>

#if defined(STRICT_GS_ENABLED)
#pragma strict_gs_check(push, on)
#endif

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define ALIGNMENT_MACHINE
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#undef ALIGNMENT_MACHINE
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#if defined(_AMD64_)
#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )
#elif defined(_IA64_)
#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                              TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))
#else
#error "No Target Architecture"
#endif

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#ifndef SORTPP_PASS
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
#define C_ASSERT(e) /* nothing */
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_NOTHROW
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NOTHROW   __declspec(nothrow)
#else
#define DECLSPEC_NOTHROW
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef SYSTEM_CACHE_ALIGNMENT_SIZE
#if defined(_AMD64_) || defined(_X86_)
#define SYSTEM_CACHE_ALIGNMENT_SIZE 64
#else
#define SYSTEM_CACHE_ALIGNMENT_SIZE 128
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef DECLSPEC_NOINLINE
#if (_MSC_VER >= 1300)
#define DECLSPEC_NOINLINE  __declspec(noinline)
#else
#define DECLSPEC_NOINLINE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#ifndef _MANAGED
#if defined(_M_IX86)
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#else
#define FASTCALL NTAPI
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#if !defined(MIDL_PASS)
typedef int INT;
#endif
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef __nullterminated WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef __nullterminated PWSTR *PZPWSTR;
typedef __nullterminated CONST PWSTR *PCZPWSTR;
typedef __nullterminated WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef __nullterminated CONST WCHAR *LPCWSTR, *PCWSTR;
typedef __nullterminated PCWSTR *PZPCWSTR;
typedef __nullterminated CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;


#if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;
typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;

//
//  UCS (Universal Character Set) types
//

typedef unsigned long UCSCHAR;

//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR UNALIGNED *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR UNALIGNED *PCUUCSSTR;

typedef UCSCHAR UNALIGNED *PUUCSCHAR;
typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;

#endif // _WIN32_WINNT >= 0x0600


//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef __nullterminated CHAR *NPSTR, *LPSTR, *PSTR;
typedef __nullterminated PSTR *PZPSTR;
typedef __nullterminated CONST PSTR *PCZPSTR;
typedef __nullterminated CONST CHAR *LPCSTR, *PCSTR;
typedef __nullterminated PCSTR *PZPCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWCH LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPCH LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

//
// The type QUAD and UQUAD are intended to use when a 8 byte aligned structure
// is required, but it is not a floating point number.
//

typedef double DOUBLE;

typedef struct _QUAD {
    union {
        __int64 UseThisFieldToCopy;
        double  DoNotUseThisField;
    } DUMMYUNIONNAME;

} QUAD;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

#if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

//
// Pointer to Const Unsigned Basics
//

typedef CONST UCHAR *PCUCHAR;
typedef CONST USHORT *PCUSHORT;
typedef CONST ULONG *PCULONG;
typedef CONST UQUAD *PCUQUAD;

#endif // _WIN32_WINNT >= 0x0600

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST SCHAR *PCSCHAR;

#endif // _WIN32_WINNT >= 0x0600

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#if 0 && (_MSC_VER > 1000)
#define DECLARE_HANDLE(name) struct name##__; typedef struct name##__ *name
#else
#define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
#endif
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
#ifdef __midl
typedef LONG HRESULT;
#else
typedef __success(return >= 0) long HRESULT;
#endif // __midl
#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

#define STDOVERRIDEMETHODIMP        __override STDMETHODIMP
#define STDOVERRIDEMETHODIMP_(type) __override STDMETHODIMP_(type)

#define IFACEMETHODIMP          __override STDMETHODIMP
#define IFACEMETHODIMP_(type)   __override STDMETHODIMP_(type)

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

#define STDOVERRIDEMETHODIMPV        __override STDMETHODIMPV
#define STDOVERRIDEMETHODIMPV_(type) __override STDMETHODIMPV_(type)

#define IFACEMETHODIMPV          __override STDMETHODIMPV
#define IFACEMETHODIMPV_(type)   __override STDMETHODIMPV_(type)

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                         (0x7fffffffffffffff)


#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)


#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    } DUMMYSTRUCTNAME;
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } DUMMYSTRUCTNAME;
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field) \
    ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   ULONG Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF_V1(A) (sizeof(A)/sizeof((A)[0]))

#if defined(__cplusplus) && \
    !defined(MIDL_PASS) && \
    !defined(RC_INVOKED) && \
    !defined(_PREFAST_) && \
    (_MSC_FULL_VER >= 13009466) && \
    !defined(SORTPP_PASS)
//
// RtlpNumberOf is a function that takes a reference to an array of N Ts.
//
// typedef T array_of_T[N];
// typedef array_of_T &reference_to_array_of_T;
//
// RtlpNumberOf returns a pointer to an array of N chars.
// We could return a reference instead of a pointer but older compilers do not accept that.
//
// typedef char array_of_char[N];
// typedef array_of_char *pointer_to_array_of_char;
//
// sizeof(array_of_char) == N
// sizeof(*pointer_to_array_of_char) == N
//
// pointer_to_array_of_char RtlpNumberOf(reference_to_array_of_T);
//
// We never even call RtlpNumberOf, we just take the size of dereferencing its return type.
// We do not even implement RtlpNumberOf, we just decare it.
//
// Attempts to pass pointers instead of arrays to this macro result in compile time errors.
// That is the point.
//
extern "C++" // templates cannot be declared to have 'C' linkage
template <typename T, size_t N>
char (*RtlpNumberOf( UNALIGNED T (&)[N] ))[N];

#define RTL_NUMBER_OF_V2(A) (sizeof(*RtlpNumberOf(A)))

//
// This does not work with:
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V2(y); // illegal use of anonymous local type in template instantiation
// }
//
// You must instead do:
//
// struct Foo1 { int x; };
//
// void Foo()
// {
//    Foo1 y[2];
//    RTL_NUMBER_OF_V2(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V1(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    _ARRAYSIZE(y); // ok
// }
//

#else
#define RTL_NUMBER_OF_V2(A) RTL_NUMBER_OF_V1(A)
#endif

#ifdef ENABLE_RTL_NUMBER_OF_V2
#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V2(A)
#else
#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V1(A)
#endif

//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//
#define ARRAYSIZE(A)    RTL_NUMBER_OF_V2(A)
#define _ARRAYSIZE(A)   RTL_NUMBER_OF_V1(A)

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   ULONG Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

// end_winnt
//
// This works "generically" for Unicode and Ansi/Oem strings.
// Usage:
//   const static UNICODE_STRING FooU = RTL_CONSTANT_STRING(L"Foo");
//   const static         STRING Foo  = RTL_CONSTANT_STRING( "Foo");
// instead of the slower:
//   UNICODE_STRING FooU;
//           STRING Foo;
//   RtlInitUnicodeString(&FooU, L"Foo");
//          RtlInitString(&Foo ,  "Foo");
//
// Or:
//   const static char szFoo[] = "Foo";
//   const static STRING sFoo = RTL_CONSTANT_STRING(szFoo);
//
// This will compile without error or warning in C++. C will get a warning.
//
#ifdef __cplusplus
extern "C++"
{
char _RTL_CONSTANT_STRING_type_check(const char *s);
char _RTL_CONSTANT_STRING_type_check(const WCHAR *s);
// __typeof would be desirable here instead of sizeof.
template <size_t N> class _RTL_CONSTANT_STRING_remove_const_template_class;
template <> class _RTL_CONSTANT_STRING_remove_const_template_class<sizeof(char)>  {public: typedef  char T; };
template <> class _RTL_CONSTANT_STRING_remove_const_template_class<sizeof(WCHAR)> {public: typedef WCHAR T; };
#define _RTL_CONSTANT_STRING_remove_const_macro(s) \
    (const_cast<_RTL_CONSTANT_STRING_remove_const_template_class<sizeof((s)[0])>::T*>(s))
}
#else
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#endif
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
// begin_winnt

// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;

#include <sdkddkver.h>

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX


#ifdef _AMD64_


#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define bit test intrinsics.
//

#ifdef __cplusplus
extern "C" {
#endif

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64
#define InterlockedBitTestAndSet64 _interlockedbittestandset64
#define InterlockedBitTestAndReset64 _interlockedbittestandreset64

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

BOOLEAN
_bittest64 (
    IN LONG64 const *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_interlockedbittestandset64 (
    IN LONG64 volatile *Base,
    IN LONG64 Offset
    );

BOOLEAN
_interlockedbittestandreset64 (
    IN LONG64 volatile *Base,
    IN LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

BOOLEAN
_BitScanForward (
    __out ULONG *Index,
    __in ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    __out ULONG *Index,
    __in ULONG Mask
    );

BOOLEAN
_BitScanForward64 (
    __out ULONG *Index,
    __in ULONG64 Mask
    );

BOOLEAN
_BitScanReverse64 (
    __out ULONG *Index,
    __in ULONG64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

//
// Interlocked intrinsic functions.
//

#define InterlockedIncrement16 _InterlockedIncrement16
#define InterlockedDecrement16 _InterlockedDecrement16
#define InterlockedCompareExchange16 _InterlockedCompareExchange16

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedAndAffinity InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedOrAffinity InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer

#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

SHORT
InterlockedIncrement16 (
    __inout SHORT volatile *Addend
    );

SHORT
InterlockedDecrement16 (
    __inout SHORT volatile *Addend
    );

SHORT
InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

LONG
InterlockedAnd (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedOr (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedXor (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG64
InterlockedAnd64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedOr64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedXor64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG
InterlockedIncrement(
    __inout LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    __inout LONG volatile *Addend
    );

LONG
InterlockedExchange(
    __inout LONG volatile *Target,
    __in LONG Value
    );

LONG
InterlockedExchangeAdd(
    __inout LONG volatile *Addend,
    __in LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    __inout LONG volatile *Addend,
    __in LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    __inout LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );

LONG64
InterlockedIncrement64(
    __inout LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    __inout LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    __inout LONG64 volatile *Target,
    __in LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    __inout LONG64 volatile *Addend,
    __in LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    __inout LONG64 volatile *Addend,
    __in LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 ExChange,
    __in LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    __inout PVOID volatile *Destination,
    __in_opt PVOID Exchange,
    __in_opt PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    __inout PVOID volatile *Target,
    __in_opt PVOID Value
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#if _MSC_FULL_VER >= 140041204

#define InterlockedAnd8 _InterlockedAnd8
#define InterlockedOr8 _InterlockedOr8
#define InterlockedXor8 _InterlockedXor8
#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedOr16 _InterlockedOr16
#define InterlockedXor16 _InterlockedXor16

char
InterlockedAnd8 (
    __inout char volatile *Destination,
    __in char Value
    );

char
InterlockedOr8 (
    __inout char volatile *Destination,
    __in char Value
    );

char
InterlockedXor8 (
    __inout char volatile *Destination,
    __in char Value
    );

SHORT
InterlockedAnd16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );
    
SHORT
InterlockedOr16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
InterlockedXor16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)

#endif

//
// Define function to flush a cache line.
//

#define CacheLineFlush(Address) _mm_clflush(Address)

VOID
_mm_clflush (
    __in VOID const *Address
    );

#pragma intrinsic(_mm_clflush)

VOID
_ReadWriteBarrier (
    VOID
    );

#pragma intrinsic(_ReadWriteBarrier)

//
// Define memory fence intrinsics
//

#define FastFence __faststorefence
#define LoadFence _mm_lfence
#define MemoryFence _mm_mfence
#define StoreFence _mm_sfence

VOID
__faststorefence (
    VOID
    );

VOID
_mm_lfence (
    VOID
    );

VOID
_mm_mfence (
    VOID
    );

VOID
_mm_sfence (
    VOID
    );

VOID
_mm_pause (
    VOID
    );

VOID 
_mm_prefetch (
    __in CHAR CONST *a, 
    __in int sel
    );

VOID
_m_prefetchw (
    __in volatile CONST VOID *Source
    );

//
// Define constants for use with _mm_prefetch.
//

#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

#pragma intrinsic(__faststorefence)
#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)

#define YieldProcessor _mm_pause
#define MemoryBarrier __faststorefence
#define PreFetchCacheLine(l, a)  _mm_prefetch((CHAR CONST *) a, l)
#define PrefetchForWrite(p) _m_prefetchw(p)
#define ReadForWriteAccess(p) (_m_prefetchw(p), *(p))

//
// PreFetchCacheLine level defines.
//

#define PF_TEMPORAL_LEVEL_1 _MM_HINT_T0
#define PF_TEMPORAL_LEVEL_2 _MM_HINT_T1
#define PF_TEMPORAL_LEVEL_3 _MM_HINT_T2
#define PF_NON_TEMPORAL_LEVEL_ALL _MM_HINT_NTA

//
// Define get/set MXCSR intrinsics.
//

#define ReadMxCsr _mm_getcsr
#define WriteMxCsr _mm_setcsr

unsigned int
_mm_getcsr (
    VOID
    );

VOID
_mm_setcsr (
    __in unsigned int MxCsr
    );

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)

//
// Assert exception.
//

VOID
__int2c (
    VOID
    );

#pragma intrinsic(__int2c)

#define DbgRaiseAssertionFailure() __int2c()

//
// Define function to get the caller's EFLAGs value.
//

#define GetCallersEflags() __getcallerseflags()

unsigned __int32
__getcallerseflags (
    VOID
    );

#pragma intrinsic(__getcallerseflags)

//
// Define function to get segment limit.
//

#define GetSegmentLimit __segmentlimit

ULONG
__segmentlimit (
    __in ULONG Selector
    );

#pragma intrinsic(__segmentlimit)

//
// Define function to read the value of a performance counter.
//

#define ReadPMC __readpmc

ULONG64
__readpmc (
    __in ULONG Counter
    );

#pragma intrinsic(__readpmc)

//
// Define function to read the value of the time stamp counter
//

#define ReadTimeStampCounter() __rdtsc()

ULONG64
__rdtsc (
    VOID
    );

#pragma intrinsic(__rdtsc)

//
// Define functions to move strings as bytes, words, dwords, and qwords.
//

VOID
__movsb (
    IN PUCHAR Destination,
    IN UCHAR const *Source,
    IN SIZE_T Count
    );

VOID
__movsw (
    IN PUSHORT Destination,
    IN USHORT const *Source,
    IN SIZE_T Count
    );

VOID
__movsd (
    IN PULONG Destination,
    IN ULONG const *Source,
    IN SIZE_T Count
    );

VOID
__movsq (
    IN PULONG64 Destination,
    IN ULONG64 const *Source,
    IN SIZE_T Count
    );

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)

//
// Define functions to store strings as bytes, words, dwords, and qwords.
//

VOID
__stosb (
    IN PUCHAR Destination,
    IN UCHAR Value,
    IN SIZE_T Count
    );

VOID
__stosw (
    IN PUSHORT Destination,
    IN USHORT Value,
    IN SIZE_T Count
    );

VOID
__stosd (
    IN PULONG Destination,
    IN ULONG Value,
    IN SIZE_T Count
    );

VOID
__stosq (
    IN PULONG64 Destination,
    IN ULONG64 Value,
    IN SIZE_T Count
    );

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//

#define MultiplyHigh __mulh
#define UnsignedMultiplyHigh __umulh

LONGLONG
MultiplyHigh (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand
    );

ULONGLONG
UnsignedMultiplyHigh (
    __in ULONG64 Multiplier,
    __in ULONG64 Multiplicand
    );

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)

//
// Define functions to perform 128-bit shifts
//

#define ShiftLeft128 __shiftleft128
#define ShiftRight128 __shiftright128

ULONG64
ShiftLeft128 (
    __in ULONG64 LowPart,
    __in ULONG64 HighPart,
    __in UCHAR Shift
    );

ULONG64
ShiftRight128 (
    __in ULONG64 LowPart,
    __in ULONG64 HighPart,
    __in UCHAR Shift
    );

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)

//
// Define functions to perform 128-bit multiplies.
//

#define Multiply128 _mul128

LONG64
Multiply128 (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand,
    __out LONG64 *HighProduct
    );

#pragma intrinsic(_mul128)

#ifndef UnsignedMultiply128

#define UnsignedMultiply128 _umul128

ULONG64
UnsignedMultiply128 (
    __in ULONG64 Multiplier,
    __in ULONG64 Multiplicand,
    __out ULONG64 *HighProduct
    );

#pragma intrinsic(_umul128)

#endif

__forceinline
LONG64
MultiplyExtract128 (
    __in LONG64 Multiplier,
    __in LONG64 Multiplicand,
    __in UCHAR Shift
    )

{

    LONG64 extractedProduct;
    LONG64 highProduct;
    LONG64 lowProduct;
    BOOLEAN negate;
    ULONG64 uhighProduct;
    ULONG64 ulowProduct;

    lowProduct = Multiply128(Multiplier, Multiplicand, &highProduct);
    negate = FALSE;
    uhighProduct = (ULONG64)highProduct;
    ulowProduct = (ULONG64)lowProduct;
    if (highProduct < 0) {
        negate = TRUE;
        uhighProduct = (ULONG64)(-highProduct);
        ulowProduct = (ULONG64)(-lowProduct);
        if (ulowProduct != 0) {
            uhighProduct -= 1;
        }
    }

    extractedProduct = (LONG64)ShiftRight128(ulowProduct, uhighProduct, Shift);
    if (negate != FALSE) {
        extractedProduct = -extractedProduct;
    }

    return extractedProduct;
}

__forceinline
ULONG64
UnsignedMultiplyExtract128 (
    __in ULONG64 Multiplier,
    __in ULONG64 Multiplicand,
    __in UCHAR Shift
    )

{

    ULONG64 extractedProduct;
    ULONG64 highProduct;
    ULONG64 lowProduct;

    lowProduct = UnsignedMultiply128(Multiplier, Multiplicand, &highProduct);
    extractedProduct = ShiftRight128(lowProduct, highProduct, Shift);
    return extractedProduct;
}

//
// Define functions to read and write the uer TEB and the system PCR/PRCB.
//

UCHAR
__readgsbyte (
    __in ULONG Offset
    );

USHORT
__readgsword (
    __in ULONG Offset
    );

ULONG
__readgsdword (
    __in ULONG Offset
    );

ULONG64
__readgsqword (
    __in ULONG Offset
    );

VOID
__writegsbyte (
    __in ULONG Offset,
    __in UCHAR Data
    );

VOID
__writegsword (
    __in ULONG Offset,
    __in USHORT Data
    );

VOID
__writegsdword (
    __in ULONG Offset,
    __in ULONG Data
    );

VOID
__writegsqword (
    __in ULONG Offset,
    __in ULONG64 Data
    );

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)

#if !defined(_MANAGED)

VOID
__incgsbyte (
    __in ULONG Offset
    );
 
VOID
__addgsbyte (
    __in ULONG Offset,
    __in UCHAR Value
    );
 
VOID
__incgsword (
    __in ULONG Offset
    );
 
VOID
__addgsword (
    __in ULONG Offset,
    __in USHORT Value
    );
 
VOID
__incgsdword (
    __in ULONG Offset
    );
 
VOID
__addgsdword (
    __in ULONG Offset,
    __in ULONG Value
    );
 
VOID
__incgsqword (
    __in ULONG Offset
    );
 
VOID
__addgsqword (
    __in ULONG Offset,
    __in ULONG64 Value
    );

#if 0
#pragma intrinsic(__incgsbyte)
#pragma intrinsic(__addgsbyte)
#pragma intrinsic(__incgsword)
#pragma intrinsic(__addgsword)
#pragma intrinsic(__incgsdword)
#pragma intrinsic(__addgsdword)
#pragma intrinsic(__incgsqword)
#pragma intrinsic(__addgsqword)
#endif

#endif

#ifdef __cplusplus
}
#endif 

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)


#endif // _AMD64_


#ifdef _X86_

//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif

// end_ntddk end_nthal
#if defined(_M_IX86) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif


//
// [pfx_parse] - guard against PREfix intrinsic error
//
#if (_MSC_FULL_VER >= 14000101) && (!defined(_PREFIX_))


//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset
#define InterlockedBitTestAndSet _interlockedbittestandset
#define InterlockedBitTestAndReset _interlockedbittestandreset

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
    IN LONG volatile *Base,
    IN LONG Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse

BOOLEAN
_BitScanForward (
    __out ULONG *Index,
    __in ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    __out ULONG *Index,
    __in ULONG Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)

#else

#pragma warning(push)
#pragma warning(disable:4035 4793)

FORCEINLINE
BOOLEAN
InterlockedBitTestAndSet (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock bts [ecx], eax
           setc al
    };
}

FORCEINLINE
BOOLEAN
InterlockedBitTestAndReset (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btr [ecx], eax
           setc al
    };
}
#pragma warning(pop)

#endif	/* _MSC_FULL_VER >= 14000101 */

//
// [pfx_parse] - guard against PREfix intrinsic error
//
#if (_MSC_FULL_VER >= 140040816) || (defined(_PREFAST_) && (_MSC_VER >= 1400))


#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange16)

#endif  /* _MSC_FULL_VER >= 140040816 */

#if !defined(_M_CEE_PURE)
#pragma warning(push)
#pragma warning(disable:4035 4793)

FORCEINLINE
BOOLEAN
InterlockedBitTestAndComplement (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    __asm {
           mov eax, Bit
           mov ecx, Base
           lock btc [ecx], eax
           setc al
    };
}
#pragma warning(pop)
#endif	/* _M_CEE_PURE */

//
// [pfx_parse]
// guard against __readfsbyte parsing error
//
#if (_MSC_FULL_VER >= 13012035) || defined(_PREFIX_) || defined(_PREFAST_)

//
// Define FS referencing intrinsics
//

UCHAR
__readfsbyte (
    IN ULONG Offset
    );
 
USHORT
__readfsword (
    IN ULONG Offset
    );
 
ULONG
__readfsdword (
    IN ULONG Offset
    );
 
VOID
__writefsbyte (
    IN ULONG Offset,
    IN UCHAR Data
    );
 
VOID
__writefsword (
    IN ULONG Offset,
    IN USHORT Data
    );
 
VOID
__writefsdword (
    IN ULONG Offset,
    IN ULONG Data
    );

#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)

#endif	/* _MSC_FULL_VER >= 13012035 */

#if (_MSC_FULL_VER >= 140050727) || defined(_PREFIX_) || defined(_PREFAST_)

#if !defined(_MANAGED)

VOID
__incfsbyte (
    ULONG Offset
    );
 
VOID
__addfsbyte (
    ULONG Offset,
    UCHAR Value
    );
 
VOID
__incfsword (
    ULONG Offset
    );
 
VOID
__addfsword (
    ULONG Offset,
    USHORT Value
    );
 
VOID
__incfsdword (
    ULONG Offset
    );
 
VOID
__addfsdword (
    ULONG Offset,
    ULONG Value
    );
 
#if 0
#pragma intrinsic(__incfsbyte)
#pragma intrinsic(__addfsbyte)
#pragma intrinsic(__incfsword)
#pragma intrinsic(__addfsword)
#pragma intrinsic(__incfsdword)
#pragma intrinsic(__addfsdword)
#endif

#endif

#endif	/* _MSC_FULL_VER >= 140050727 */

#if (_MSC_FULL_VER >= 140041204) || defined(_PREFIX_) || defined(_PREFAST_)

VOID
_mm_pause (
    VOID
    );

#pragma intrinsic(_mm_pause)

#define YieldProcessor _mm_pause

#else

#if !defined(_M_CEE_PURE)
#define YieldProcessor() __asm { rep nop }
#endif  // !defined(_M_CEE_PURE)

#endif  // (_MSC_FULL_VER >= 140041204)

#ifdef __cplusplus
}
#endif

#endif  /* !defined(MIDL_PASS) || defined(_M_IX86) */

#endif //_X86_


#if defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#ifdef __cplusplus
extern "C" {
#endif

//
// Define bit test intrinsics.
//

#define BitTest _bittest
#define BitTestAndComplement _bittestandcomplement
#define BitTestAndSet _bittestandset
#define BitTestAndReset _bittestandreset

#define BitTest64 _bittest64
#define BitTestAndComplement64 _bittestandcomplement64
#define BitTestAndSet64 _bittestandset64
#define BitTestAndReset64 _bittestandreset64

BOOLEAN
_bittest (
    IN LONG const *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandcomplement (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittestandreset (
    IN LONG *Base,
    IN LONG Offset
    );

BOOLEAN
_bittest64 (
    IN LONG64 const *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandcomplement64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

BOOLEAN
_bittestandreset64 (
    IN LONG64 *Base,
    IN LONG64 Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)

//
// Define bit scan intrinsics.
//

#define BitScanForward _BitScanForward
#define BitScanReverse _BitScanReverse
#define BitScanForward64 _BitScanForward64
#define BitScanReverse64 _BitScanReverse64

BOOLEAN
_BitScanForward (
    OUT ULONG *Index,
    IN ULONG Mask
    );

BOOLEAN
_BitScanReverse (
    OUT ULONG *Index,
    IN ULONG Mask
    );

BOOLEAN
_BitScanForward64 (
    OUT ULONG *Index,
    IN ULONG64 Mask
    );

BOOLEAN
_BitScanReverse64 (
    OUT ULONG *Index,
    IN ULONG64 Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

#define InterlockedCompareExchange16 _InterlockedCompareExchange16

SHORT
_InterlockedCompareExchange16 (
    __inout SHORT volatile *Destination,
    __in SHORT ExChange,
    __in SHORT Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange16)

#ifdef __cplusplus
}
#endif

#define InterlockedAdd 				_InterlockedAdd
#define InterlockedAddAcquire 			_InterlockedAdd_acq
#define InterlockedAddRelease 			_InterlockedAdd_rel

#define InterlockedIncrement 			_InterlockedIncrement
#define InterlockedIncrementAcquire 		_InterlockedIncrement_acq
#define InterlockedIncrementRelease 		_InterlockedIncrement_rel

#define InterlockedDecrement 			_InterlockedDecrement
#define InterlockedDecrementAcquire 		_InterlockedDecrement_acq
#define InterlockedDecrementRelease 		_InterlockedDecrement_rel

#define InterlockedExchange 			_InterlockedExchange
#define InterlockedExchangeAcquire 		_InterlockedExchange_acq

#define InterlockedExchangeAdd 			_InterlockedExchangeAdd
#define InterlockedExchangeAddAcquire 		_InterlockedExchangeAdd_acq
#define InterlockedExchangeAddRelease 		_InterlockedExchangeAdd_rel

#define InterlockedAdd64 			_InterlockedAdd64
#define InterlockedAddAcquire64 		_InterlockedAdd64_acq
#define InterlockedAddRelease64 		_InterlockedAdd64_rel

#define InterlockedIncrement64 			_InterlockedIncrement64
#define InterlockedIncrementAcquire64 		_InterlockedIncrement64_acq
#define InterlockedIncrementRelease64 		_InterlockedIncrement64_rel

#define InterlockedDecrement64 			_InterlockedDecrement64
#define InterlockedDecrementAcquire64 		_InterlockedDecrement64_acq
#define InterlockedDecrementRelease64 		_InterlockedDecrement64_rel

#define InterlockedExchange64 			_InterlockedExchange64
#define InterlockedExchangeAcquire64 		_InterlockedExchange64_acq

#define InterlockedExchangeAdd64 		_InterlockedExchangeAdd64
#define InterlockedExchangeAddAcquire64 	_InterlockedExchangeAdd64_acq
#define InterlockedExchangeAddRelease64 	_InterlockedExchangeAdd64_rel

#define InterlockedCompareExchange64 		_InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 	_InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 	_InterlockedCompareExchange64_rel

#define InterlockedCompare64Exchange128     _InterlockedCompare64Exchange128
#define InterlockedCompare64ExchangeAcquire128  _InterlockedCompare64Exchange128_acq
#define InterlockedCompare64ExchangeRelease128  _InterlockedCompare64Exchange128_rel

#define InterlockedCompareExchange 		_InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire 	_InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease 	_InterlockedCompareExchange_rel

#define InterlockedExchangePointer 		_InterlockedExchangePointer
#define InterlockedExchangePointerAcquire       _InterlockedExchangePointer_acq

#define InterlockedCompareExchangePointer 	 _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer_rel
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer_acq


#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
#define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
#define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)

#define InterlockedOr       _InterlockedOr
#define InterlockedOrAcquire   _InterlockedOr_acq
#define InterlockedOrRelease   _InterlockedOr_rel
#define InterlockedOr8      _InterlockedOr8
#define InterlockedOr8Acquire  _InterlockedOr8_acq
#define InterlockedOr8Release  _InterlockedOr8_rel
#define InterlockedOr16     _InterlockedOr16
#define InterlockedOr16Acquire _InterlockedOr16_acq
#define InterlockedOr16Release _InterlockedOr16_rel
#define InterlockedOr64     _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64_acq
#define InterlockedOr64Release _InterlockedOr64_rel
#define InterlockedXor      _InterlockedXor
#define InterlockedXorAcquire  _InterlockedXor_acq
#define InterlockedXorRelease  _InterlockedXor_rel
#define InterlockedXor8     _InterlockedXor8
#define InterlockedXor8Acquire _InterlockedXor8_acq
#define InterlockedXor8Release _InterlockedXor8_rel
#define InterlockedXor16    _InterlockedXor16
#define InterlockedXor16Acquire _InterlockedXor16_acq
#define InterlockedXor16Release _InterlockedXor16_rel
#define InterlockedXor64     _InterlockedXor64
#define InterlockedXor64Acquire _InterlockedXor64_acq
#define InterlockedXor64Release _InterlockedXor64_rel
#define InterlockedAnd       _InterlockedAnd
#define InterlockedAndAcquire   _InterlockedAnd_acq
#define InterlockedAndRelease   _InterlockedAnd_rel
#define InterlockedAnd8      _InterlockedAnd8
#define InterlockedAnd8Acquire  _InterlockedAnd8_acq
#define InterlockedAnd8Release  _InterlockedAnd8_rel
#define InterlockedAnd16     _InterlockedAnd16
#define InterlockedAnd16Acquire _InterlockedAnd16_acq
#define InterlockedAnd16Release _InterlockedAnd16_rel
#define InterlockedAnd64     _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64_acq
#define InterlockedAnd64Release _InterlockedAnd64_rel

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    LONG volatile *Addend,
    LONG Value
    );

LONG
__cdecl
InterlockedAddAcquire (
    LONG volatile *Addend,
    LONG Value
    );

LONG
__cdecl
InterlockedAddRelease (
    LONG volatile *Addend,
    LONG Value
    );
    
LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAddAcquire64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );


LONGLONG
__cdecl
InterlockedAddRelease64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementAcquire(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementRelease(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAcquire(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddAcquire(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAddRelease(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );
LONG
__cdecl
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeRelease (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONG
__cdecl
InterlockedCompareExchangeAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );


LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementAcquire64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedIncrementRelease64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementAcquire64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrementRelease64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAcquire64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddAcquire64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAddRelease64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeAcquire64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeRelease64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

LONG64
__cdecl
InterlockedCompare64Exchange128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeAcquire128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeRelease128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerAcquire (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerRelease (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

PVOID
__cdecl
InterlockedExchangePointerAcquire(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

LONG
__cdecl
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedOrAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedOrRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedOr8 (
    IN OUT CHAR volatile *Destination,
    IN    CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Acquire (
    IN OUT CHAR volatile *Destination,
    IN    CHAR Value
    );

CHAR
__cdecl
InterlockedOr8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedOr16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedOr16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedOr64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedOr64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONG
__cdecl
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedXorAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedXorRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedXor8 (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Acquire (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedXor8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedXor16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedXor16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedXor64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedXor64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONG
__cdecl
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
__cdecl
InterlockedAndAcquire (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );
    
LONG
__cdecl
InterlockedAndRelease (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

CHAR
__cdecl
InterlockedAnd8 (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Acquire (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

CHAR
__cdecl
InterlockedAnd8Release (
    IN OUT CHAR volatile *Destination,
    IN CHAR Value
    );

SHORT
__cdecl
InterlockedAnd16(
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );
    
SHORT
__cdecl
InterlockedAnd16Acquire (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Release (
    IN OUT SHORT volatile *Destination,
    IN SHORT Value
    );

LONGLONG
__cdecl
InterlockedAnd64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Acquire (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );
    
LONGLONG
__cdecl
InterlockedAnd64Release (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedIncrement_acq)
#pragma intrinsic(_InterlockedIncrement_rel)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedDecrement_acq)
#pragma intrinsic(_InterlockedDecrement_rel)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedCompareExchange_acq)
#pragma intrinsic(_InterlockedCompareExchange_rel)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64_rel)
#pragma intrinsic(_InterlockedCompare64Exchange128)
#pragma intrinsic(_InterlockedCompare64Exchange128_acq)
#pragma intrinsic(_InterlockedCompare64Exchange128_rel)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer_acq)
#pragma intrinsic(_InterlockedCompareExchangePointer_rel)
#pragma intrinsic(_InterlockedAdd_acq)
#pragma intrinsic(_InterlockedAdd_rel)
#pragma intrinsic(_InterlockedExchange_acq)
#pragma intrinsic(_InterlockedExchangeAdd_acq)
#pragma intrinsic(_InterlockedExchangeAdd_rel)
#pragma intrinsic(_InterlockedAdd64_acq)
#pragma intrinsic(_InterlockedAdd64_rel)
#pragma intrinsic(_InterlockedIncrement64_acq)
#pragma intrinsic(_InterlockedIncrement64_rel)
#pragma intrinsic(_InterlockedDecrement64_acq)
#pragma intrinsic(_InterlockedDecrement64_rel)
#pragma intrinsic(_InterlockedExchangeAdd64_acq)
#pragma intrinsic(_InterlockedExchangeAdd64_rel)
#pragma intrinsic(_InterlockedExchangePointer_acq)
#pragma intrinsic (_InterlockedOr)
#pragma intrinsic (_InterlockedOr_acq)
#pragma intrinsic (_InterlockedOr_rel)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedOr8_acq)
#pragma intrinsic (_InterlockedOr8_rel)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedOr16_acq)
#pragma intrinsic (_InterlockedOr16_rel)
#pragma intrinsic (_InterlockedOr64)
#pragma intrinsic (_InterlockedOr64_acq)
#pragma intrinsic (_InterlockedOr64_rel)
#pragma intrinsic (_InterlockedXor)
#pragma intrinsic (_InterlockedXor_acq)
#pragma intrinsic (_InterlockedXor_rel)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedXor8_acq)
#pragma intrinsic (_InterlockedXor8_rel)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedXor16_acq)
#pragma intrinsic (_InterlockedXor16_rel)
#pragma intrinsic (_InterlockedXor64)
#pragma intrinsic (_InterlockedXor64_acq)
#pragma intrinsic (_InterlockedXor64_rel)
#pragma intrinsic (_InterlockedAnd)
#pragma intrinsic (_InterlockedAnd_acq)
#pragma intrinsic (_InterlockedAnd_rel)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedAnd8_acq)
#pragma intrinsic (_InterlockedAnd8_rel)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedAnd16_acq)
#pragma intrinsic (_InterlockedAnd16_rel)
#pragma intrinsic (_InterlockedAnd64)
#pragma intrinsic (_InterlockedAnd64_acq)
#pragma intrinsic (_InterlockedAnd64_rel)

#if !defined (InterlockedAnd64)

#define InterlockedAnd64 InterlockedAnd64_Inline

LONGLONG
FORCEINLINE
InterlockedAnd64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedAndAffinity InterlockedAnd64

#if !defined (InterlockedOr64)

#define InterlockedOr64 InterlockedOr64_Inline

LONGLONG
FORCEINLINE
InterlockedOr64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#endif

#define InterlockedOrAffinity InterlockedOr64

#if !defined (InterlockedXor64)

#define InterlockedXor64 InterlockedXor64_Inline

LONGLONG
FORCEINLINE
InterlockedXor64_Inline (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedBitTestAndSet)

#define InterlockedBitTestAndSet InterlockedBitTestAndSet_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset)

#define InterlockedBitTestAndReset InterlockedBitTestAndReset_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndSet64)

#define InterlockedBitTestAndSet64 InterlockedBitTestAndSet64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndSet64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedOr64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset64)

#define InterlockedBitTestAndReset64 InterlockedBitTestAndReset64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndReset64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedAnd64 (&Base[Bit/(sizeof (*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement)

#define InterlockedBitTestAndComplement InterlockedBitTestAndComplement_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement_Inline (
    IN LONG volatile *Base,
    IN LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement64)

#define InterlockedBitTestAndComplement64 InterlockedBitTestAndComplement64_Inline

BOOLEAN
FORCEINLINE
InterlockedBitTestAndComplement64_Inline (
    IN LONG64 volatile *Base,
    IN LONG64 Bit
    )
{
    LONG64 tBit;

    tBit = 1i64<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN) ((InterlockedXor64 (&Base[Bit/(sizeof (*Base)*8)], tBit)&tBit) != 0);
}

#endif

#ifdef __cplusplus
}
#endif

#endif /* defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS) */

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    Vmcs,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm
// begin_ntddk

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

VOID
__inbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__inwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__indwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
__outbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__outwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__outdwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if defined(_AMD64_) && !defined(DSF_DRIVER)

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//

#ifdef __cplusplus
extern "C" {
#endif

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    volatile UCHAR *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    volatile USHORT *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    volatile ULONG *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
ULONG64
READ_REGISTER_ULONG64 (
    volatile ULONG64 *Register
    )
{
    _ReadWriteBarrier();
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsb(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsw(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsd(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG64 (
    PULONG64 Register,
    PULONG64 Buffer,
    ULONG Count
    )
{
    _ReadWriteBarrier();
    __movsq(Buffer, Register, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    volatile UCHAR *Register,
    UCHAR Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    volatile USHORT *Register,
    USHORT Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    volatile ULONG *Register,
    ULONG Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG64 (
    volatile ULONG64 *Register,
    ULONG64 Value
    )
{

    *Register = Value;
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{

    __movsb(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{

    __movsw(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{

    __movsd(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG64 (
    PULONG64 Register,
    PULONG64 Buffer,
    ULONG Count
    )
{

    __movsq(Register, Buffer, Count);
    FastFence();
    return;
}

__forceinline
UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )

{
    UCHAR Result;

    _ReadWriteBarrier();
    Result = __inbyte((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}

__forceinline
USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )

{
    USHORT Result;

    _ReadWriteBarrier();
    Result = __inword((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}

__forceinline
ULONG
READ_PORT_ULONG (
    PULONG Port
    )

{
    ULONG Result;

    _ReadWriteBarrier();
    Result = __indword((USHORT)((ULONG_PTR)Port));
    _ReadWriteBarrier();
    return Result;
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __inbytestring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __inwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __indwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR Value
    )

{
    _ReadWriteBarrier();
    __outbyte((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT Value
    )

{
    _ReadWriteBarrier();
    __outword((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG Value
    )

{
    _ReadWriteBarrier();
    __outdword((USHORT)((ULONG_PTR)Port), Value);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __outbytestring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __outwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    _ReadWriteBarrier();
    __outdwordstring((USHORT)((ULONG_PTR)Port), Buffer, Count);
    _ReadWriteBarrier();
    return;
}

#ifdef __cplusplus
}
#endif

#elif defined(_AMD64_) && defined(DSF_DRIVER)
#include <DsfHrmPorts.h>
#endif


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
} KINTERRUPT_MODE;

t