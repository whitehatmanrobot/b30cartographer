man/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\dxvalid.h ===
//--------------------------------------------------------------------------;
//
//  File: dxvalid.h
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//      This header contains common parameter validate macros for DirectX.
//
//  History:
//      02/14/96    angusm    Initial version
//      03/05/96    angusm    added VALIDEX_GUID_PTR
//
//--------------------------------------------------------------------------;


// _________________________________________________________________________
// VALIDEX_xxx 
//     macros are the same for debug and retail


#define VALIDEX_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#define VALIDEX_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
	(!IsBadCodePtr( (LPVOID) ptr ) )


// _________________________________________________________________________
// VALID_xxx 
//     macros that check memory allocated and sent as API parameters


#ifndef DEBUG
#define FAST_CHECKING
#endif

#ifndef FAST_CHECKING

#define VALID_BOOL_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_DDCOLORKEY_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RGNDATA ) ) )
#define VALID_RECT_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#else
#define VALID_PTR( ptr, size ) 		1
#define VALID_DIRECTDRAW_PTR( ptr )	1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )	1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )	1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )	1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_BOOL_PTR( ptr )	1
#define VALID_HDC_PTR( ptr )	1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )	1
#define VALID_RGNDATA_PTR( ptr )	1
#define VALID_RECT_PTR( ptr )	1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )	1
#define VALID_DDMASK_PTR( ptr )	1
#define VALID_DDSCAPS_PTR( ptr )	1
#define VALID_PTR_PTR( ptr )	1
#define VALID_IID_PTR( ptr )	1
#define VALID_HWND_PTR( ptr )	1
#define VALID_VMEM_PTR( ptr )	1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )	1
#define VALID_HANDLE_PTR( ptr )	1
#define VALID_DDCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCAPS ))
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )	1
#define VALID_DWORD_ARRAY( ptr, cnt )	1
#define VALID_GUID_PTR( ptr )	1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\dpfa.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *	 20-may-96	andyco	forced ansi entry points on all functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include <stdarg.h>

//#ifdef WINNT
//int abs(int x)
//{
//    return x>=0?x:-x;
//}
//#endif

#ifdef DEBUG

#define USE_DDASSERT

#ifndef START_STR
    #define START_STR	"DDRAW: "
#endif
#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif

#define END_STR		"\r\n"

HWND		hWndListBox;
LONG		lDebugLevel = 0;

/*
 * dumpStr
 */
static void dumpStr( LPSTR str )
{
    OutputDebugStringA( str );

    #ifdef DPF_HWND
	if( hWndListBox != NULL )
	{
	    if( !IsWindow( hWndListBox ) )
	    {
		hWndListBox = NULL;
	    }
	}
	if( hWndListBox != NULL )
	{
	    UINT	sel;
	    int	len;
	    len = strlen( str );
	    if( len > 0 )
	    {
		if( str[len-1] == '\r' || str[len-1] == '\n' )
		{
		    str[len-1] = 0;
		}
		if( len > 1 )
		{
		    if( str[len-2] == '\r' || str[len-2] == '\n' )
		    {
			str[len-2] = 0;
		    }
		}
	    }
	    SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	    sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	    if( sel != LB_ERR )
	    {
		SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	    }
	}
    #endif

} /* dumpStr */

/*
 * dprintf
 */
void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
{
    char 	str[256];
    BOOL	allow = FALSE;
    va_list ap;
    va_start(ap,szFormat);


    if( lDebugLevel < 0 )
    {
#ifdef WINNT
	if( (UINT) abs( lDebugLevel ) == lvl )
#else
	if( (UINT) labs( lDebugLevel ) == lvl )
#endif
	{
	    allow = TRUE;
	}
    }
    else if( (UINT) lDebugLevel >= lvl )
    {
	allow = TRUE;
    }

    if( allow )
    {
	wsprintfA( (LPSTR) str, START_STR );
	wvsprintfA( str+lstrlenA( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	lstrcatA( (LPSTR) str, END_STR );
	dumpStr( str );
    }

    va_end(ap);
} /* dprintf */

/*
 * DPFInit
 */
void DPFInit( void )
{
    lDebugLevel = GetProfileIntA( PROF_SECT, "debug", 0 );

} /* DPFInit */

#ifdef USE_DDASSERT

/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    wsprintfA( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

#endif /* USE_DDASSERT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
            #define DEBUG
        #endif
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR(a)    DXdprintf(0, "(ERROR) :"  DPF_MODNAME ": " a);
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\logger.h ===
/*
	logger.h

	Use to write log info to a file.

	Multiple-instance aware. If one instance already owns the output
        file, another will sleep (up to 20s) until the first is done.
	Nicely outputs a header containing user, computer, and driver names,
	date/time and starting display resolution.


        You use it like this:

                CLogfile Log("test.log","your comment here");

                // or CLogfile Log("test.log");
                // for no comment, and overwriting the file.

                // or CLogfile Log("test.log","your comment here",TRUE);
                // to make it append to the file. Default is overwrite.
                
                Log << "\n\n42 decimal is " << 42ul <<" in hex\n";
                Log << "Hi"<<'!'<<'\n' ;
                Log << "The value of 0x2a is " << 0x2al << " in decimal\n";

				CLogfile Faults("faults.log","my test's faults",TRUE);	//append new faults
				Faults << "Encountered a booboo, here's what i did:\n";
				Faults << Log;		//copies contents of test.log to Fault
				Faults << "so now you can diagnose\n";

        The class will then write stuff like this to test.log:


                ----------------------------------------------------------
                EnumSurface test
                Beginning test at 10:38 on 1995/8/14
                User Name:jeffno
                Computer Name:JEFFNO2
                Display driver:S3 Vision864 PCI
                Starting resolution: 640x480x8
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                42 decimal is 0000002a in hex
                Hi!
                The value of 0x2a is 42 in decimal
                ----------- Test ends at 10:38 on 1995/8/14 -------------
                
		And faults.log will get:
				< a header like above>
				Encountered a booboo, here's what i did:
				< a copy of the test.log contents surrounded by
					notes that say this is a snapshot of test.log >
				so now you can diagnose
				< a trailer like above (test ends at etc...)>



        The class can output DWORDS, which it does as an 8-digit hex number,
        LONGs which are output as decimal, chars and strings. As shown
		above you can output one log object to another, which copies 
		everything in the source file from the pos at which the source
		file was opened (if appending to a pre-existing file) up to
		the end.


        But wait! you also get...
                A routine called char * ErrorName(HRESULT) which takes
                a ddraw return value and returns a string describing it.
                Very handy.
                BTW: this header file includes a statically declared array
                full of names, at file level scope. This means you get a 2k
                array in your source wether you want ErrorName or not.
                Go ahead and edit this file if you don't want this array.

        NOTE: this uses WNetGetUser API, so you'll need to add mpr.lib
        to you LIBS line in your makefile.
*/

//#include <stdio.h>
#include <windows.h>
#include <windowsx.h> 


struct {
	char name[100];
	HRESULT errcode;
} ErrorLookup[] = {
				{"DD_OK",DD_OK},
				{"DDERR_ALREADYINITIALIZED",DDERR_ALREADYINITIALIZED},
				{"DDERR_CANNOTATTACHSURFACE",DDERR_CANNOTATTACHSURFACE},
				{"DDERR_CANNOTDETACHSURFACE",DDERR_CANNOTDETACHSURFACE},
				{"DDERR_CURRENTLYNOTAVAIL",DDERR_CURRENTLYNOTAVAIL},
				{"DDERR_EXCEPTION",DDERR_EXCEPTION},
				{"DDERR_GENERIC",DDERR_GENERIC},
				{"DDERR_HEIGHTALIGN",DDERR_HEIGHTALIGN},
				{"DDERR_INCOMPATIBLEPRIMARY",DDERR_INCOMPATIBLEPRIMARY},
				{"DDERR_INVALIDCAPS",DDERR_INVALIDCAPS},
				{"DDERR_INVALIDCLIPLIST",DDERR_INVALIDCLIPLIST},
				{"DDERR_INVALIDMODE",DDERR_INVALIDMODE},
				{"DDERR_INVALIDOBJECT",DDERR_INVALIDOBJECT},
				{"DDERR_INVALIDPARAMS",DDERR_INVALIDPARAMS},
				{"DDERR_INVALIDPIXELFORMAT",DDERR_INVALIDPIXELFORMAT},
				{"DDERR_INVALIDRECT",DDERR_INVALIDRECT},
				{"DDERR_LOCKEDSURFACES",DDERR_LOCKEDSURFACES},
				{"DDERR_NO3D",DDERR_NO3D},
				{"DDERR_NOALPHAHW",DDERR_NOALPHAHW},
				{"DDERR_NOANTITEARHW",DDERR_NOANTITEARHW},
				{"DDERR_NOBLTQUEUEHW",DDERR_NOBLTQUEUEHW},
				{"DDERR_NOCLIPLIST",DDERR_NOCLIPLIST},
				{"DDERR_NOCOLORCONVHW",DDERR_NOCOLORCONVHW},
				{"DDERR_NOCOOPERATIVELEVELSET",DDERR_NOCOOPERATIVELEVELSET},
				{"DDERR_NOCOLORKEY",DDERR_NOCOLORKEY},
				{"DDERR_NOCOLORKEYHW",DDERR_NOCOLORKEYHW},
				{"DDERR_NOEXCLUSIVEMODE",DDERR_NOEXCLUSIVEMODE},
				{"DDERR_NOFLIPHW",DDERR_NOFLIPHW},
				{"DDERR_NOGDI",DDERR_NOGDI},
				{"DDERR_NOMIRRORHW",DDERR_NOMIRRORHW},
				{"DDERR_NOTFOUND",DDERR_NOTFOUND},
				{"DDERR_NOOVERLAYHW",DDERR_NOOVERLAYHW},
				{"DDERR_NORASTEROPHW",DDERR_NORASTEROPHW},
				{"DDERR_NOROTATIONHW",DDERR_NOROTATIONHW},
				{"DDERR_NOSTRETCHHW",DDERR_NOSTRETCHHW},
				{"DDERR_NOT4BITCOLOR",DDERR_NOT4BITCOLOR},
				{"DDERR_NOT4BITCOLORINDEX",DDERR_NOT4BITCOLORINDEX},
				{"DDERR_NOT8BITCOLOR",DDERR_NOT8BITCOLOR},
				{"DDERR_NOTEXTUREHW",DDERR_NOTEXTUREHW},
				{"DDERR_NOVSYNCHW",DDERR_NOVSYNCHW},
				{"DDERR_NOZBUFFERHW",DDERR_NOZBUFFERHW},
				{"DDERR_NOZOVERLAYHW",DDERR_NOZOVERLAYHW},
				{"DDERR_OUTOFCAPS",DDERR_OUTOFCAPS},
				{"DDERR_OUTOFMEMORY",DDERR_OUTOFMEMORY},
				{"DDERR_OUTOFVIDEOMEMORY",DDERR_OUTOFVIDEOMEMORY},
				{"DDERR_OVERLAYCANTCLIP",DDERR_OVERLAYCANTCLIP},
				{"DDERR_OVERLAYCOLORKEYONLYONEACTIVE",DDERR_OVERLAYCOLORKEYONLYONEACTIVE},
				{"DDERR_PALETTEBUSY",DDERR_PALETTEBUSY},
				{"DDERR_COLORKEYNOTSET",DDERR_COLORKEYNOTSET},
				{"DDERR_SURFACEALREADYATTACHED",DDERR_SURFACEALREADYATTACHED},
				{"DDERR_SURFACEALREADYDEPENDENT",DDERR_SURFACEALREADYDEPENDENT},
				{"DDERR_SURFACEBUSY",DDERR_SURFACEBUSY},
				{"DDERR_SURFACEISOBSCURED",DDERR_SURFACEISOBSCURED},
				{"DDERR_SURFACELOST",DDERR_SURFACELOST},
				{"DDERR_SURFACENOTATTACHED",DDERR_SURFACENOTATTACHED},
				{"DDERR_TOOBIGHEIGHT",DDERR_TOOBIGHEIGHT},
				{"DDERR_TOOBIGSIZE",DDERR_TOOBIGSIZE},
				{"DDERR_TOOBIGWIDTH",DDERR_TOOBIGWIDTH},
				{"DDERR_UNSUPPORTED",DDERR_UNSUPPORTED},
				{"DDERR_UNSUPPORTEDFORMAT",DDERR_UNSUPPORTEDFORMAT},
				{"DDERR_UNSUPPORTEDMASK",DDERR_UNSUPPORTEDMASK},
				{"DDERR_VERTICALBLANKINPROGRESS",DDERR_VERTICALBLANKINPROGRESS},
				{"DDERR_WASSTILLDRAWING",DDERR_WASSTILLDRAWING},
				{"DDERR_XALIGN",DDERR_XALIGN},
				{"DDERR_INVALIDDIRECTDRAWGUID",DDERR_INVALIDDIRECTDRAWGUID},
				{"DDERR_DIRECTDRAWALREADYCREATED",DDERR_DIRECTDRAWALREADYCREATED},
				{"DDERR_NODIRECTDRAWHW",DDERR_NODIRECTDRAWHW},
				{"DDERR_PRIMARYSURFACEALREADYEXISTS",DDERR_PRIMARYSURFACEALREADYEXISTS},
				{"DDERR_NOEMULATION",DDERR_NOEMULATION},
				{"DDERR_REGIONTOOSMALL",DDERR_REGIONTOOSMALL},
				{"DDERR_CLIPPERISUSINGHWND",DDERR_CLIPPERISUSINGHWND},
				{"DDERR_NOCLIPPERATTACHED",DDERR_NOCLIPPERATTACHED},
				{"DDERR_NOHWND",DDERR_NOHWND},
				{"DDERR_HWNDSUBCLASSED",DDERR_HWNDSUBCLASSED},
				{"DDERR_HWNDALREADYSET",DDERR_HWNDALREADYSET},
				{"DDERR_NOPALETTEATTACHED",DDERR_NOPALETTEATTACHED},
				{"DDERR_NOPALETTEHW",DDERR_NOPALETTEHW},
				{"DDERR_BLTFASTCANTCLIP",DDERR_BLTFASTCANTCLIP},
				{"DDERR_NOBLTHW",DDERR_NOBLTHW},
				{"DDERR_NODDROPSHW",DDERR_NODDROPSHW},
				{"DDERR_OVERLAYNOTVISIBLE",DDERR_OVERLAYNOTVISIBLE},
				{"DDERR_NOOVERLAYDEST",DDERR_NOOVERLAYDEST},
				{"DDERR_INVALIDPOSITION",DDERR_INVALIDPOSITION},
				{"DDERR_NOTAOVERLAYSURFACE",DDERR_NOTAOVERLAYSURFACE},
				{"DDERR_EXCLUSIVEMODEALREADYSET",DDERR_EXCLUSIVEMODEALREADYSET},
				{"DDERR_NOTFLIPPABLE",DDERR_NOTFLIPPABLE},
				{"DDERR_CANTDUPLICATE",DDERR_CANTDUPLICATE},
				{"DDERR_NOTLOCKED",DDERR_NOTLOCKED},
				{"DDERR_CANTCREATEDC",DDERR_CANTCREATEDC},
				{"DDERR_NODC",DDERR_NODC},
				{"DDERR_WRONGMODE",DDERR_WRONGMODE},
				{"DDERR_IMPLICITLYCREATED",DDERR_IMPLICITLYCREATED},
				{"DDERR_NOTPALETTIZED",DDERR_NOTPALETTIZED},
				{"DDERR_UNSUPPORTEDMODE",DDERR_UNSUPPORTEDMODE},
				{"END",0}
};

inline char * ErrorName(HRESULT err)
{
	int e=0;
	while (strcmp(ErrorLookup[e].name,"END"))
	{
		if (err == ErrorLookup[e].errcode)
			return ErrorLookup[e].name;
		e++;
	};
	return "Unknown Error code";
}	


class CLogfile
{	
	private:
		char smalltemp[10];
		HFILE 	fh;
		OFSTRUCT of;
		BOOL bHeaderWritten;
		char *cComment;
		char line[1000];
		LONG lStartPos;
		char Path[200];
	public:
		CLogfile(char * path, char * comment = 0,BOOL bAppend=FALSE)
		{
			if (path)
				strncpy(Path,path,199);

			fh = HFILE_ERROR;
			bHeaderWritten = FALSE;
			lStartPos = 0;

			//if the file does not exist, create it:
			if (GetFileAttributes(path) == 0xffffffff)
				fh = OpenFile(path,&of,OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
			else
				//first attempt to get a lock on the file...
				for (int i=0;i<20 && fh==HFILE_ERROR;i++)
				{
					if (bAppend)
						fh = OpenFile(path,&of, OF_READWRITE|OF_SHARE_DENY_WRITE);
					else
						fh = OpenFile(path,&of, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
					if (fh==HFILE_ERROR)
						Sleep(1000);
				}

			if (fh==HFILE_ERROR)
				return;

			lStartPos = _llseek(fh,0,SEEK_END);

			cComment = comment;
		}

		void OutputHeader(void)
		{
			//now we have the file, write user/computer info:

			//write separator, comment if necessary and date and time:
			SYSTEMTIME st;
			GetLocalTime(&st);
			wsprintf(line,"----------------------------------------------------------\r\n");
			_lwrite(fh,line,strlen(line));
			if (cComment && strlen(cComment))
			{
				wsprintf(line,"%s\r\n",cComment);
				_lwrite(fh,line,strlen(line));
			}
			wsprintf(line,"Beginning test at %d:%02d on %d/%d/%d\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
			_lwrite(fh,line,strlen(line));


			//write user's name:
			DWORD length = 100;
			wsprintf(line,"User Name:");

			WNetGetUser(NULL,line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write computer's name:
			wsprintf(line,"\r\nComputer Name:");
			GetComputerName(line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write display driver's name:
			wsprintf(line,"\r\nDisplay driver:");
			GetPrivateProfileString("boot.description","display.drv","(Unknown)",line+strlen(line),100,"system.ini");
			_lwrite(fh,line,strlen(line));

			_lwrite(fh,"\r\n",2);

			HDC hdc = GetDC(NULL);
			if (hdc)
			{
				wsprintf(line,"Starting resolution: %dx%dx%d\r\n",
							GetDeviceCaps(hdc,HORZRES)
							,GetDeviceCaps(hdc,VERTRES)
							,GetDeviceCaps(hdc,BITSPIXEL) );
				_lwrite(fh,line,strlen(line));
				ReleaseDC(NULL,hdc);
			}
			wsprintf(line,"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n");
			_lwrite(fh,line,strlen(line));

			bHeaderWritten = TRUE;
		}
		~CLogfile()
		{
			SYSTEMTIME st;
			if(fh != HFILE_ERROR)
			{
				if (bHeaderWritten)
				{
					GetLocalTime(&st);
					wsprintf(line,"----------- Test ends at %d:%02d on %d/%d/%d -------------\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
					_lwrite(fh,line,strlen(line));
				}
				_lclose(fh);
			}
		}
		CLogfile & operator << (DWORD dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%08x",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (LONG dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%d",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
                CLogfile & operator << (void * p)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
            wsprintf(smalltemp,"%08x",p);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (char * cp)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			while( *cp)
				*this << *cp++;
			return *this;
		}
		CLogfile & operator << (char  c)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			if (c=='\n')
			{
				wsprintf(smalltemp,"\r");
				_lwrite(fh,smalltemp,strlen(smalltemp));
			}
			wsprintf(smalltemp,"%c",c);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (CLogfile & log)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();

			LONG pos = _llseek(log.fh,0,FILE_CURRENT);
			LONG from = _llseek(log.fh,log.lStartPos,FILE_BEGIN);

			char ch;
			*this << "= = = = = = = Snapshot of ";
			if (log.Path)
				*this << log.Path;
			else
				*this << "Unknown file";
			*this << " = = = = = = =\n";

			for (LONG j=0;j<pos-from;j++)
			{
				_lread(log.fh,&ch,1);
				*this << ch;
			}

			*this << "= = = = = = = = = Snapshot ends = = = = = = = = = = =\n";
			return *this;
		}
			
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#if defined(_X86_)
	#define MyGetReturnAddress(first) (LPVOID) *(DWORD *)(((LPBYTE)&first)-4)
#else
	#define MyGetReturnAddress(first) _ReturnAddress()
#endif

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = MyGetReturnAddress(first); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return (UINT)HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 6, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 6, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 6, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 6, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 6, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\filter.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/27/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       filter.h
 *  Content:    Filter classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/27/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __FILTER_H__
#define __FILTER_H__

//
// Public filter types
//

#define WBFILTER_ADPCM  0x00000001
#define WBFILTER_8BIT   0x00000002
#define WBFILTER_MASK   0x00000003

#ifdef __cplusplus

//
// Xbox ADPCM filter
//

class CXboxAdpcmFilter
    : protected CImaAdpcmCodec
{
public:
    CXboxAdpcmFilter(void);
    virtual ~CXboxAdpcmFilter(void);

public:
    // Filter name
    static LPCSTR GetName(void);
    
    // Initialization
    virtual BOOL Initialize(LPCWAVEBANKMINIWAVEFORMAT pwfxSource);

    // Format
    static BOOL IsValidFormat(LPCWAVEBANKMINIWAVEFORMAT pwfxFormat);
    static BOOL ConvertFormat(LPWAVEBANKMINIWAVEFORMAT pwfxFormat);

    // Sizes
    static DWORD GetSourceAlignment(DWORD nChannels);
    virtual DWORD GetSourceAlignment(void);
    static DWORD GetDestinationAlignment(DWORD nChannels);
    virtual DWORD GetDestinationAlignment(void);
    static DWORD GetSize(DWORD cbSource, DWORD nChannels, BOOL fRoundUp = FALSE);
    virtual DWORD GetSize(DWORD cbSource, BOOL fRoundUp = FALSE);

    // Data conversion
    virtual BOOL Convert(LPCVOID pvSource, LPDWORD pcbRead, LPVOID pvDest, LPDWORD pcbWritten);
};

__inline LPCSTR CXboxAdpcmFilter::GetName(void)
{
    return "ADPCM";
}

__inline DWORD CXboxAdpcmFilter::GetSourceAlignment(DWORD nChannels)
{
    return nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
}

__inline DWORD CXboxAdpcmFilter::GetSourceAlignment(void)
{
    return m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
}

__inline DWORD CXboxAdpcmFilter::GetDestinationAlignment(DWORD nChannels)
{
    return nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
}

__inline DWORD CXboxAdpcmFilter::GetDestinationAlignment(void)
{
    return m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
}

__inline DWORD CXboxAdpcmFilter::GetSize(DWORD cbSource, DWORD nChannels, BOOL fRoundUp)
{
    const DWORD             cbSrcAlign  = GetSourceAlignment(nChannels);
    const DWORD             cbDstAlign  = GetDestinationAlignment(nChannels);
    
    if(fRoundUp)
    {
        cbSource += cbSrcAlign - 1;
    }

    cbSource /= cbSrcAlign;
    cbSource *= cbDstAlign;
    
    return cbSource;
}

__inline DWORD CXboxAdpcmFilter::GetSize(DWORD cbSource, BOOL fRoundUp)
{
    return GetSize(cbSource, m_wfxEncode.wfx.nChannels, fRoundUp);
}

//
// 16- to 8-bit filter
//

class C8BitFilter
{
protected:
    DWORD                   m_nChannels;    // Channel count

public:
    C8BitFilter(void);
    virtual ~C8BitFilter(void);

public:
    // Filter name
    static LPCSTR GetName(void);
    
    // Initialization
    virtual BOOL Initialize(LPCWAVEBANKMINIWAVEFORMAT pwfxSource);

    // Format
    static BOOL IsValidFormat(LPCWAVEBANKMINIWAVEFORMAT pwfxFormat);
    static BOOL ConvertFormat(LPWAVEBANKMINIWAVEFORMAT pwfxFormat);

    // Sizes
    static DWORD GetSourceAlignment(DWORD nChannels);
    virtual DWORD GetSourceAlignment(void);
    static DWORD GetDestinationAlignment(DWORD nChannels);
    virtual DWORD GetDestinationAlignment(void);
    static DWORD GetSize(DWORD cbSource, DWORD nChannels);
    virtual DWORD GetSize(DWORD cbSource);

    // Data conversion
    virtual BOOL Convert(LPCVOID pvSource, LPDWORD pcbRead, LPVOID pvDest, LPDWORD pcbWritten);
};
    
__inline LPCSTR C8BitFilter::GetName(void)
{
    return "8-bit";
}

__inline DWORD C8BitFilter::GetSourceAlignment(DWORD nChannels)
{
    return nChannels * 2;
}

__inline DWORD C8BitFilter::GetSourceAlignment(void)
{
    return m_nChannels * 2;
}

__inline DWORD C8BitFilter::GetDestinationAlignment(DWORD nChannels)
{
    return nChannels;
}

__inline DWORD C8BitFilter::GetDestinationAlignment(void)
{
    return m_nChannels;
}

__inline DWORD C8BitFilter::GetSize(DWORD cbSource, DWORD nChannels)
{
    return cbSource / (nChannels * 2) * nChannels;
}

__inline DWORD C8BitFilter::GetSize(DWORD cbSource)
{
    return cbSource / (m_nChannels * 2) * m_nChannels;
}

#endif // __cplusplus

#endif // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\format2.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/27/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       format2.cpp
 *  Content:    Format conversion helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/27/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"

using namespace DirectSound::WaveFormat;


/****************************************************************************
 *
 *  WaveBankExpandFormat
 *
 *  Description:
 *      Expands a compressed wave format to a standard format structure.
 *
 *  Arguments:
 *      LPCWAVEBANKMINIWAVEFORMAT [in]: compressed format.
 *      LPWAVEBANKUNIWAVEFORMAT [out]: standard format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveBankExpandFormat"

BOOL 
WaveBankExpandFormat
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxCompressed, 
    LPWAVEBANKUNIWAVEFORMAT    pwfxExpanded
)
{
    DPF_ENTER();

    if(WAVEBANKMINIFORMAT_TAG_ADPCM == pwfxCompressed->wFormatTag)
    {
        XAudioCreateAdpcmFormat((WORD)pwfxCompressed->nChannels, pwfxCompressed->nSamplesPerSec, &pwfxExpanded->AdpcmWaveFormat);
    }
    else
    {
        XAudioCreatePcmFormat((WORD)pwfxCompressed->nChannels, pwfxCompressed->nSamplesPerSec, (WAVEBANKMINIFORMAT_BITDEPTH_16 == pwfxCompressed->wBitsPerSample) ? 16 : 8, &pwfxExpanded->WaveFormatEx);
    }

    DPF_LEAVE(TRUE);

    return TRUE;
}


/****************************************************************************
 *
 *  WaveBankCompressFormat
 *
 *  Description:
 *      Converts a standard format structure to a compressed wave format.
 *
 *  Arguments:
 *      LPCWAVEBANKUNIWAVEFORMAT [in]: standard format.
 *      LPWAVEBANKMINIWAVEFORMAT [out]: compressed format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveBankCompressFormat"

BOOL 
WaveBankCompressFormat
(
    LPCWAVEBANKUNIWAVEFORMAT   pwfxExpanded,
    LPWAVEBANKMINIWAVEFORMAT   pwfxCompressed
)
{
    BOOL                        fValid;

    DPF_ENTER();

    if(WAVE_FORMAT_PCM == pwfxExpanded->WaveFormatEx.wFormatTag)
    {
        if(fValid = IsValidPcmFormat(&pwfxExpanded->WaveFormatEx))
        {
            pwfxCompressed->wFormatTag = WAVEBANKMINIFORMAT_TAG_PCM;
            pwfxCompressed->nChannels = pwfxExpanded->WaveFormatEx.nChannels;
            pwfxCompressed->nSamplesPerSec = pwfxExpanded->WaveFormatEx.nSamplesPerSec;
            pwfxCompressed->wBitsPerSample = (16 == pwfxExpanded->WaveFormatEx.wBitsPerSample) ? WAVEBANKMINIFORMAT_BITDEPTH_16 : WAVEBANKMINIFORMAT_BITDEPTH_8;
        }
    }
    else if(WAVE_FORMAT_XBOX_ADPCM == pwfxExpanded->WaveFormatEx.wFormatTag)
    {
        if(fValid = IsValidAdpcmFormat(&pwfxExpanded->AdpcmWaveFormat))
        {
            pwfxCompressed->wFormatTag = WAVEBANKMINIFORMAT_TAG_ADPCM;
            pwfxCompressed->nChannels = pwfxExpanded->WaveFormatEx.nChannels;
            pwfxCompressed->nSamplesPerSec = pwfxExpanded->WaveFormatEx.nSamplesPerSec;
            pwfxCompressed->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_4;
        }
    }
    else
    {
        DPF_ERROR("Unsupported format tag");
        fValid = FALSE;
    }   

    DPF_LEAVE(fValid);

    return fValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   15-jun-98  linstev added DPF2
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>

#ifdef cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
   extern int  DebugPrintf2(LPSTR cFilter, ...);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}

#else
    #pragma warning(disable:4002)
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()
#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(4, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL	0x80004005L

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HINSTANCE hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( (HANDLE) 0xffffffff, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, 100000 );  // fail if this doesn't work within 100 seconds
    CloseHandle( hevent );
    if( rc == WAIT_TIMEOUT )
    {
        return FALSE;
    }
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = (DWORD)hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */


/*
 * StopWatchProcess
 *
 * Signal DDHELP to stop watching a process.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP to stop watching a process" );
    hd.req = DDHELPREQ_STOPWATCHPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

#ifndef WINNT
/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open DOS box event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

#endif //!winnt

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
		return (DWORD)hd.dwReturn;
	else
		return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */

    /*
     * Get DDHELP to load the DirectDraw VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDDVxd( void )
    {
	DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDDVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDDVxd */

#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD_PTR)pfn;
    sendRequest( &hd );
    return;
}

HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_LOADLIBRARY;
    hd.dwData1 = (DWORD_PTR)pszLibraryName;
    sendRequest(&hd);
    return (HINSTANCE)hd.dwReturn;
}

BOOL HelperFreeLibrary(HINSTANCE hInst)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_FREELIBRARY;
    hd.dwData1 = (DWORD_PTR)hInst;
    sendRequest(&hd);
    return (BOOL)hd.dwReturn;
}

void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_ADDDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}

void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_DELDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\source\common.cpp ===
#include "stdafx.h"

#include "..\..\common\inc\common.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\inc\common.h ===
#ifndef XACT_COMMON_H
#define XACT_COMMON_H

//
// common data/code
//


EXTERN_C DWORD XACTpCreateHashFromName(const PCHAR pszName,DWORD dwSeed);

//
// common functions for host and xbox side code
//

DWORD XACTpCreateHashFromName(const PCHAR pszName,DWORD dwSeed)
{
    DWORD dwTemp;
    DWORD dwResult = 0;

	srand(dwSeed);
    int r = rand();
    int r1 = rand();

    PCHAR pBuffer = pszName;

    for (DWORD i=0;i<sizeof(dwResult);i++){

        dwTemp = (DWORD) pBuffer;
        dwTemp ^= dwTemp*r*r*r1 | (*(pBuffer+3) << 16);

        dwResult = (dwResult ^ dwTemp) * dwTemp;
        pBuffer ++;   

    }

    return dwResult;

}

#endif // XACT_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\misc\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "dpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;
static bAdvancedDPFs=FALSE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;

int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
    OUTPUTDEBUGSTRING( str );
    OUTPUTDEBUGSTRING("\n");
}

void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }
    }
    else
    {
        bAdvancedDPFs=TRUE;
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
#ifndef DWORD_PTR
#define DWORD_PTR DWORD
#endif

int DebugPrintf(DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD_PTR arg;
    LPSTR szFormat;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;
    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    //Pull out which topics this DPF refers to
    while ( (arg = va_arg(ap,DWORD_PTR)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }

    //if this message has no topics, then it's a misc message.
    //we turn them on only if allowed (i.e. "-" is not in the enable string).
    //And level zero messages are always allowed
    if (bMiscMessage)
    {
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;
    }
    else
    {
        //topic-ed message is only allowed if the advanced DPF line is set in [DirectX]
        if (!bAdvancedDPFs)
            bAllowed=FALSE;
    }

    //Advanced DPFs have the option ("+") to print every topic
    if (bAdvancedDPFs)
    {
        if ( bPrintAllTopics )
            bAllowed=TRUE;
    }

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;

    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (dwDetail==0)
    {
        WSPRINTF( cMsg+strlen(cMsg),"ERROR:" );
    }
    if (dwDetail==1)
    {
        WSPRINTF( cMsg+strlen(cMsg),"WARN:" );
    }
    if (dwDetail==2)
    {
        WSPRINTF( cMsg+strlen(cMsg),"INFO:" );
    }


    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;

}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\filter.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/27/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       filter.cpp
 *  Content:    Filter classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/27/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"


/****************************************************************************
 *
 *  CXboxAdpcmFilter
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::CXboxAdpcmFilter"

CXboxAdpcmFilter::CXboxAdpcmFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CXboxAdpcmFilter
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::~CXboxAdpcmFilter"

CXboxAdpcmFilter::~CXboxAdpcmFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCWAVEBANKMINIWAVEFORMAT [in]: source format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::Initialize"

BOOL
CXboxAdpcmFilter::Initialize
(
    LPCWAVEBANKMINIWAVEFORMAT   pwfxSource
)
{
    WAVEBANKMINIWAVEFORMAT      wfxDest     = *pwfxSource;
    WAVEBANKUNIWAVEFORMAT       wfxExpanded;

    if(!ConvertFormat(&wfxDest))
    {
        return FALSE;
    }

    if(!WaveBankExpandFormat(&wfxDest, &wfxExpanded))
    {
        return FALSE;
    }

    return CImaAdpcmCodec::Initialize(&wfxExpanded.AdpcmWaveFormat, TRUE);
}


/****************************************************************************
 *
 *  IsValidFormat
 *
 *  Description:
 *      Checks a source format for validity.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::IsValidFormat"

BOOL 
CXboxAdpcmFilter::IsValidFormat
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxFormat
)
{
    if(WAVEBANKMINIFORMAT_TAG_PCM != pwfxFormat->wFormatTag)
    {
        return FALSE;
    }

    if((pwfxFormat->nChannels < 1) || (pwfxFormat->nChannels > 2))
    {
        return FALSE;
    }

    if(WAVEBANKMINIFORMAT_BITDEPTH_16 != pwfxFormat->wBitsPerSample)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  ConvertFormat
 *
 *  Description:
 *      Converts a source format to a destination.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::ConvertFormat"

BOOL 
CXboxAdpcmFilter::ConvertFormat
(
    LPWAVEBANKMINIWAVEFORMAT   pwfxFormat
)
{
    if(!IsValidFormat(pwfxFormat))
    {
        return FALSE;
    }

    pwfxFormat->wFormatTag = WAVEBANKMINIFORMAT_TAG_ADPCM;
    pwfxFormat->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_4;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      DWORD [in/out]: source buffer size, in bytes.
 *      LPVOID [out]: destination buffer.
 *      DWORD [in/out]: destination buffer size, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::Convert"

BOOL
CXboxAdpcmFilter::Convert
(
    LPCVOID                 pvSource,
    LPDWORD                 pcbSource,
    LPVOID                  pvDest,
    LPDWORD                 pcbDest
)
{
    DWORD                   cBlocks;

    //
    // Convert byte sizes to blocks
    //

    *pcbSource /= m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
    *pcbDest /= m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
    
    cBlocks = min(*pcbSource, *pcbDest);

    *pcbSource = cBlocks * m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
    *pcbDest = cBlocks * m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

    //
    // Convert data
    //

    return CImaAdpcmCodec::Convert(pvSource, pvDest, cBlocks);
}


/****************************************************************************
 *
 *  C8BitFilter
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::C8BitFilter"

C8BitFilter::C8BitFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  ~C8BitFilter
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::~C8BitFilter"

C8BitFilter::~C8BitFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCWAVEBANKMINIWAVEFORMAT [in]: source format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::Initialize"

BOOL
C8BitFilter::Initialize
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxSource
)
{
    if(!IsValidFormat(pwfxSource))
    {
        return FALSE;
    }
    
    m_nChannels = pwfxSource->nChannels;
    
    return TRUE;
}


/****************************************************************************
 *
 *  IsValidFormat
 *
 *  Description:
 *      Checks a source format for validity.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::IsValidFormat"

BOOL 
C8BitFilter::IsValidFormat
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxFormat
)
{
    if(WAVEBANKMINIFORMAT_TAG_PCM != pwfxFormat->wFormatTag)
    {
        return FALSE;
    }

    if(WAVEBANKMINIFORMAT_BITDEPTH_16 != pwfxFormat->wBitsPerSample)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  ConvertFormat
 *
 *  Description:
 *      Converts a source format to a destination.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::ConvertFormat"

BOOL 
C8BitFilter::ConvertFormat
(
    LPWAVEBANKMINIWAVEFORMAT   pwfxFormat
)
{
    if(!IsValidFormat(pwfxFormat))
    {
        return FALSE;
    }

    pwfxFormat->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_8;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      DWORD [in/out]: source buffer size, in bytes.
 *      LPVOID [out]: destination buffer.
 *      DWORD [in/out]: destination buffer size, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::Convert"

BOOL
C8BitFilter::Convert
(
    LPCVOID                 pvSource,
    LPDWORD                 pcbSource,
    LPVOID                  pvDest,
    LPDWORD                 pcbDest
)
{
    const short *           psSource    = (const short *)pvSource;
    unsigned char *         pbDest      = (unsigned char *)pvDest;
    DWORD                   cSamples;
    DWORD                   dwSample;

    //
    // Convert byte sizes to samples
    //

    *pcbSource /= m_nChannels * 2;
    *pcbDest /= m_nChannels;
    
    cSamples = min(*pcbSource, *pcbDest);

    *pcbSource = cSamples * m_nChannels * 2;
    *pcbDest = cSamples * m_nChannels;

    //
    // Convert data
    //

    cSamples *= m_nChannels;
    
    while(cSamples--)
    {
        dwSample = *psSource + 32768;
        *pbDest = (BYTE)(dwSample >> 8);

        pbDest++;
        psSource++;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\loader.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 02/13/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       loader.cpp
 *  Content:    Wave bank project loader.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/13/2002  dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"


/****************************************************************************
 *
 *  ExtractDirectory
 *
 *  Description:
 *      Extracts the first directory from a path.
 *
 *  Arguments:
 *      LPTSTR [in]: path.
 *      LPTSTR [out]: directory name.
 *
 *  Returns:  
 *      LPTSTR: path.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ExtractDirectory"

static LPTSTR
ExtractDirectory
(
    LPTSTR                   pszSrc,
    LPTSTR                   pszDst
)
{
    if(TEXT('\\') == *pszSrc)
    {
        pszSrc++;
    }

    while(TRUE)
    {
        if(TEXT('\\') == *pszSrc)
        {
            *pszDst = 0;
            pszSrc++;
            break;
        }
        
        *pszDst = *pszSrc;

        if(!*pszDst)
        {
            break;
        }

        pszDst++;
        pszSrc++;
    }

    return pszSrc;
}


/****************************************************************************
 *
 *  GetRelativePath
 *
 *  Description:
 *      Converts an absolute path to a relative one.
 *
 *  Arguments:
 *      LPCTSTR [in]: parent path.
 *      LPCTSTR [in]: child path.
 *      LPTSTR [out]: relative path.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetRelativePath"

static void
GetRelativePath
(
    LPCTSTR                 pszInputParentPath,
    LPCTSTR                 pszInputChildPath,
    LPTSTR                  pszRelativePath
)
{
    BOOL                    fSuccess                = TRUE;
    TCHAR                   szParentPath[MAX_PATH];
    TCHAR                   szChildPath[MAX_PATH];
    TCHAR                   szParentPart[MAX_PATH];
    TCHAR                   szChildPart[MAX_PATH];
    LPTSTR                  pszParentPath;
    LPTSTR                  pszChildPath;
    LPTSTR                  pszParentTemp;
    LPTSTR                  pszChildTemp;

    *pszRelativePath = 0;

    GetFullPathName(pszInputParentPath, NUMELMS(szParentPath), szParentPath, NULL);
    GetFullPathName(pszInputChildPath, NUMELMS(szChildPath), szChildPath, NULL);

    if((szParentPath[0] >= TEXT('a')) && (szParentPath[0] <= TEXT('z')))
    {
        szParentPath[0] = TEXT('A') + (szParentPath[0] - TEXT('a'));
    }

    if((szChildPath[0] >= TEXT('a')) && (szChildPath[0] <= TEXT('z')))
    {
        szChildPath[0] = TEXT('A') + (szChildPath[0] - TEXT('a'));
    }

    pszParentPath = szParentPath;
    pszChildPath = szChildPath;

    //
    // If the paths aren't on the same drive, bail
    //

    if((szParentPath[0] >= TEXT('A')) && (szParentPath[0] <= TEXT('Z')) && (TEXT(':') == szParentPath[1]))
    {
        fSuccess = ((szParentPath[0] == szChildPath[0]) && (szParentPath[1] == szChildPath[1]));

        if(fSuccess)
        {
            pszParentPath = &szParentPath[2];
            pszChildPath = &szChildPath[2];
        }
    }

    //
    // Skip over any matching directories
    //

    if(fSuccess)
    {
        while(TRUE)
        {
            pszParentTemp = ExtractDirectory(pszParentPath, szParentPart);

            if(!*pszParentTemp)
            {
                break;
            }

            pszChildTemp = ExtractDirectory(pszChildPath, szChildPart);

            if(!*pszChildTemp)
            {
                break;
            }

            if(_tcsicmp(szParentPart, szChildPart))
            {
                break;
            }

            pszParentPath = pszParentTemp;
            pszChildPath = pszChildTemp;
        }
    }

    //
    // For every directory that appears in the parent but not the child, add
    // a "..\"
    //

    if(fSuccess)
    {
        while(TRUE)
        {
            pszParentTemp = ExtractDirectory(pszParentPath, szParentPart);

            if(!*pszParentTemp)
            {
                break;
            }

            pszChildTemp = ExtractDirectory(pszChildPath, szChildPart);

            if(*pszChildTemp)
            {
                if(!_tcsicmp(szParentPart, szChildPart))
                {
                    break;
                }
            }

            _tcscat(pszRelativePath, TEXT("..\\"));

            pszParentPath = pszParentTemp;
        }
    }

    //
    // If anything went wrong, just copy the full child path.  If all is good,
    // build the relative path.
    //
    
    if(fSuccess)
    {
        _tcscat(pszRelativePath, pszChildPath);
    }
    else
    {
        _tcscpy(pszRelativePath, szChildPath);
    }
}


/****************************************************************************
 *
 *  Load
 *
 *  Description:
 *      Loads project data.
 *
 *  Arguments:
 *      LPCTSTR [in]: project file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProjectFile::Load"

HRESULT
CWaveBankProjectFile::Load
(
    CWaveBankProject *      pProject,
    LPCTSTR                 pszProjectFile
)
{
    HRESULT                 hr          = S_OK;
    LPTSTR                  pszFilePart;
    DWORD                   dwBankCount;
    TCHAR                   c;
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Save a pointer to the project
    //

    m_pProject = pProject;

    //
    // Convert the project file name to a full path.  The INI APIs prefer it
    //

    GetFullPathName(pszProjectFile, NUMELMS(m_szProjectFile), m_szProjectFile, &pszFilePart);

    //
    // Set the current directory to the project file's to make sure any 
    // relative paths are expanded properly
    //

    c = *pszFilePart;
    *pszFilePart = 0;
    
    if(!SetCurrentDirectory(m_szProjectFile))
    {
        DPF_ERROR("Unable to change to project file directory");
        hr = E_FAIL;
    }

    *pszFilePart = c;

    //
    // Start loading banks
    //

    if(SUCCEEDED(hr))
    {
        dwBankCount = GetPrivateProfileInt(WBPROJECT_PROJECT_MAIN_SECTION, WBPROJECT_PROJECT_BANKCOUNT_KEY, 0, m_szProjectFile);

        for(i = 0; (i < dwBankCount) && SUCCEEDED(hr); i++)
        {
            hr = LoadBank(i);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Save
 *
 *  Description:
 *      Stores project data.
 *
 *  Arguments:
 *      LPCTSTR [in]: project file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProjectFile::Save"

HRESULT
CWaveBankProjectFile::Save
(
    CWaveBankProject *      pProject,
    LPCTSTR                 pszProjectFile
)
{
    HRESULT                 hr                      = S_OK;
    CStdFileStream          ProjectFile;
    TCHAR                   szBankCount[MAX_PATH];
    LPTSTR                  pszFilePart;
    PLIST_ENTRY             pleEntry;
    CWaveBank *             pBank;
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Save a pointer to the project
    //

    m_pProject = pProject;

    //
    // Convert the project file name to a full path.  The INI APIs prefer it
    //

    GetFullPathName(pszProjectFile, NUMELMS(m_szProjectFile), m_szProjectFile, &pszFilePart);

    //
    // Truncate the existing file
    //

    DeleteFile(m_szProjectFile);

    //
    // Write project data
    //

    if(SUCCEEDED(hr))
    {
        sprintf(szBankCount, TEXT("%lu"), m_pProject->m_dwBankCount);
        
        if(!WritePrivateProfileString(WBPROJECT_PROJECT_MAIN_SECTION, WBPROJECT_PROJECT_BANKCOUNT_KEY, szBankCount, m_szProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }
    }

    //
    // Write all bank data
    //

    for(pleEntry = m_pProject->m_lstBanks.Flink, i = 0; (pleEntry != &m_pProject->m_lstBanks) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, i++)
    {
        ASSERT(i < m_pProject->m_dwBankCount);
        
        pBank = CONTAINING_RECORD(pleEntry, CWaveBank, m_leBank);

        hr = SaveBank(pBank, i);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(i == m_pProject->m_dwBankCount);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  LoadBank
 *
 *  Description:
 *      Loads a bank from the project file.
 *
 *  Arguments:
 *      DWORD [in]: bank index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProjectFile::LoadBank"

HRESULT
CWaveBankProjectFile::LoadBank
(
    DWORD                   dwBankIndex
)
{
    CWaveBank *             pBank                   = NULL;
    HRESULT                 hr                      = S_OK;
    TCHAR                   szSectionName[MAX_PATH];
    TCHAR                   szBankName[MAX_PATH];
    TCHAR                   szBankFile[MAX_PATH];
    TCHAR                   szHeaderFile[MAX_PATH];
    DWORD                   dwEntryCount;
    CWaveBankEntry *        pEntry;
    HRESULT                 hrEntry;
    DWORD                   i;
    
    DPF_ENTER();

    sprintf(szSectionName, WBPROJECT_BANK_KEY, dwBankIndex);

    GetPrivateProfileString(szSectionName, WBPROJECT_BANK_NAME_KEY, TEXT(""), szBankName, NUMELMS(szBankName), m_szProjectFile);
    GetPrivateProfileString(szSectionName, WBPROJECT_BANK_FILE_KEY, TEXT(""), szBankFile, NUMELMS(szBankFile), m_szProjectFile);
    GetPrivateProfileString(szSectionName, WBPROJECT_BANK_HEADER_KEY, TEXT(""), szHeaderFile, NUMELMS(szHeaderFile), m_szProjectFile);

    hr = m_pProject->AddBank(szBankName, szBankFile, szHeaderFile, &pBank);

    if(SUCCEEDED(hr))
    {
        dwEntryCount = GetPrivateProfileInt(szSectionName, WBPROJECT_BANK_ENTRYCOUNT_KEY, 0, m_szProjectFile);

        for(i = 0; (i < dwEntryCount) && SUCCEEDED(hr); i++)
        {
            hr = LoadEntry(szSectionName, pBank, i);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SaveBank
 *
 *  Description:
 *      Saves project data for the bank.
 *
 *  Arguments:
 *      CWaveBank * [in]: bank object.
 *      DWORD [in]: bank index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProjectFile::SaveBank"

HRESULT
CWaveBankProjectFile::SaveBank
(
    CWaveBank *             pBank,
    DWORD                   dwBankIndex
)
{
    HRESULT                 hr                      = S_OK;
    TCHAR                   szSectionName[MAX_PATH];
    TCHAR                   szText[MAX_PATH];
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   i;
    
    DPF_ENTER();

    sprintf(szSectionName, WBPROJECT_BANK_KEY, dwBankIndex);
    
    if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_NAME_KEY, pBank->m_szBankName, m_szProjectFile))
    {
        DPF_ERROR("An error occurred while attempting to write to the project file");
        hr = E_FAIL;
    }        

    if(SUCCEEDED(hr))
    {
        GetRelativePath(m_szProjectFile, pBank->m_szBankFile, szText);
        
        if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_FILE_KEY, szText, m_szProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
        GetRelativePath(m_szProjectFile, pBank->m_szHeaderFile, szText);
        
        if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_HEADER_KEY, szText, m_szProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }        
    }

    if(SUCCEEDED(hr))
    {
        sprintf(szText, TEXT("%lu"), pBank->m_dwEntryCount);

        if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_ENTRYCOUNT_KEY, szText, m_szProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }        
    }

    if(SUCCEEDED(hr))
    {
        for(pleEntry = pBank->m_lstEntries.Flink, i = 0; (pleEntry != &pBank->m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, i++)
        {
            ASSERT(i < pBank->m_dwEntryCount);
        
            pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

            hr = SaveEntry(szSectionName, pEntry, i);
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(i == pBank->m_dwEntryCount);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  LoadEntry
 *
 *  Description:
 *      Loads an entry from the project file.
 *
 *  Arguments:
 *      LPCTSTR [in]: section name.
 *      CWaveBank * [in]: parent bank.
 *      DWORD [in]: entry index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProjectFile::LoadEntry"

HRESULT
CWaveBankProjectFile::LoadEntry
(
    LPCTSTR                 pszSectionName,
    CWaveBank *             pBank,
    DWORD                   dwEntryIndex
)
{
    TCHAR                   szKeyName[0x100];
    TCHAR                   szEntryData[MAX_PATH + 0x200];
    TCHAR                   szEntryName[0x100];
    TCHAR                   szFileName[MAX_PATH];
    DWORD                   dwFlags;
    LPCTSTR                 pszSrc;
    LPTSTR                  pszDst;
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Load the whole entry string
    //

    sprintf(szKeyName, WBPROJECT_ENTRY_KEY, dwEntryIndex);

    GetPrivateProfileString(pszSectionName, szKeyName, "", szEntryData, NUMELMS(szEntryData), m_szProjectFile);

    pszSrc = szEntryData;
    
    //
    // Extract the entry name
    //
    
    pszDst = szEntryName;

    while(TRUE)
    {
        switch(tolower(*pszSrc))
        {
            case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
                pszSrc++;
                *pszDst = 0;
                break;

            default:
                *pszDst = *pszSrc;
                break;
        }

        if(!*pszDst)
        {
            break;
        }

        pszDst++;
        pszSrc++;
    }

    //
    // Extract the file name
    //
    
    pszDst = szFileName;

    while(TRUE)
    {
        switch(tolower(*pszSrc))
        {
            case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
                pszSrc++;
                *pszDst = 0;
                break;

            default:
                *pszDst = *pszSrc;
                break;
        }

        if(!*pszDst)
        {
            break;
        }

        pszDst++;
        pszSrc++;
    }

    //
    // Extract the flags
    //

    dwFlags = 0;

    while(*pszSrc)
    {
        switch(tolower(*pszSrc))
        {
            case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
                break;

            case WBPROJECT_ENTRYEXT_ADPCMFILTER_LCHAR:
                dwFlags |= WBFILTER_ADPCM;
                break;

            case WBPROJECT_ENTRYEXT_8BITFILTER_LCHAR:
                dwFlags |= WBFILTER_8BIT;
                break;

            default:
                DPF_WARNING("Unrecognized flag character in project file");
                break;
        }

        pszSrc++;
    }

    //
    // Create the entry
    //

    hr = pBank->AddEntry(szEntryName, szFileName, dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SaveEntry
 *
 *  Description:
 *      Stores project data for the entry.
 *
 *  Arguments:
 *      LPCTSTR [in]: section name.
 *      CWaveBankEntry * [in]: entry.
 *      DWORD [in]: entry index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProjectFile::SaveEntry"

HRESULT
CWaveBankProjectFile::SaveEntry
(
    LPCTSTR                 pszSectionName,
    CWaveBankEntry *        pEntry,
    DWORD                   dwEntryIndex
)
{
    HRESULT                 hr                              = S_OK;
    TCHAR                   szKeyName[0x100];
    TCHAR                   szEntryData[MAX_PATH + 0x200];
    
    DPF_ENTER();

    sprintf(szKeyName, WBPROJECT_ENTRY_KEY, dwEntryIndex);

    _tcscpy(szEntryData, pEntry->m_szEntryName);
    _tcscat(szEntryData, WBPROJECT_ENTRYEXT_SEPARATOR_STR);

    GetRelativePath(m_szProjectFile, pEntry->m_szFileName, &szEntryData[_tcslen(szEntryData)]);

    if(pEntry->m_dwFlags & WBFILTER_MASK)
    {
        _tcscat(szEntryData, WBPROJECT_ENTRYEXT_SEPARATOR_STR);

        if(pEntry->m_dwFlags & WBFILTER_ADPCM)
        {
            _tcscat(szEntryData, WBPROJECT_ENTRYEXT_ADPCMFILTER_STR);
        }

        if(pEntry->m_dwFlags & WBFILTER_8BIT)
        {
            _tcscat(szEntryData, WBPROJECT_ENTRYEXT_8BITFILTER_STR);
        }
    }

    if(!WritePrivateProfileString(pszSectionName, szKeyName, szEntryData, m_szProjectFile))
    {
        DPF_ERROR("Error %lu occurred writing to the project file", GetLastError());
        hr = E_FAIL;
    }        

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\xacthost.inc ===
#
# Common sources file for all XACT Win32 components
#

DXBASEDIR = $(BASEDIR)\private\windows\directx
DSBASEDIR = $(DXBASEDIR)\dsound
XACTBASEDIR = $(DXBASEDIR)\xact
XACTHOSTBASEDIR = $(XACTBASEDIR)\host
XACTHOSTOBJDIR = $(XACTHOSTBASEDIR)\obj

TARGETTYPE = LIBRARY
TARGETPATH = $(XACTHOSTOBJDIR)
UMTYPE = windows

NTDBGFILES = 1
USE_MAPSYM = 1

USER_C_FLAGS = $(USER_C_FLAGS) /FAcs

!if !$(FREEBUILD)
MSC_OPTIMIZATION = $(MSC_OPTIMIZATION) /Od
!endif

INCLUDES =\
    $(BASEDIR)\public\wsdk\inc;\
    $(BASEDIR)\public\wsdk\inc\mfc42;\
    $(BASEDIR)\public\sdk\inc;\
    $(DSBASEDIR)\common;\
    $(XACTBASEDIR)\common\wavbndlr;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\reader.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/7/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reader.cpp
 *  Content:    Wave Bundler file reader.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/7/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"


/****************************************************************************
 *
 *  CWaveBankReader
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankReader::CWaveBankReader"

CWaveBankReader::CWaveBankReader
(
    void
)
{
    DPF_ENTER();

    m_pvBaseAddress = NULL;
    m_dwBankSize = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBankReader
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankReader::~CWaveBankReader"

CWaveBankReader::~CWaveBankReader
(
    void
)
{
    DPF_ENTER();

    Flush();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Opens a wave bank.
 *
 *  Arguments:
 *      LPCSTR [in]: wave bank file path.
 *      LPWAVEBANKSECTIONDATA [out]: wave bank data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankReader::Open"

HRESULT
CWaveBankReader::Open
(
    LPCSTR                  pszBankFile
)
{
    CStdFileStream          BankFile;
    LPCWAVEBANKHEADER       pHeader;
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Open the file
    //

    hr = BankFile.Open(pszBankFile, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN);

    //
    // Read the whole damn thing
    //

    if(SUCCEEDED(hr))
    {
        hr = BankFile.GetLength(&m_dwBankSize);
    }

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pvBaseAddress = MEMALLOC(BYTE, m_dwBankSize));
    }

    if(SUCCEEDED(hr))
    {
        hr = BankFile.Read(m_pvBaseAddress, m_dwBankSize);
    }

    //
    // Validate the header
    //

    if(SUCCEEDED(hr))
    {
        pHeader = (LPCWAVEBANKHEADER)m_pvBaseAddress;

        if(WAVEBANKHEADER_SIGNATURE != pHeader->dwSignature)
        {
            DPF_ERROR("Invalid signature");
            hr = E_FAIL;
        }

        if(WAVEBANKHEADER_VERSION != pHeader->dwVersion)
        {
            DPF_ERROR("Invalid version");
            hr = E_FAIL;
        }
    }

    //
    // If anything went wrong, free everything
    //

    if(FAILED(hr))
    {
        Flush();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Frees wave bank data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankReader::Flush"

void
CWaveBankReader::Flush
(
    void
)
{
    DPF_ENTER();

    MEMFREE(m_pvBaseAddress);

    m_dwBankSize = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetSectionData
 *
 *  Description:
 *      Gets wave bank section data.
 *
 *  Arguments:
 *      LPWAVEBANKSECTIONDATA [out]: wave bank data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankReader::GetSectionData"

void
CWaveBankReader::GetSectionData
(
    LPWAVEBANKSECTIONDATA   pSectionData
)
{
    DPF_ENTER();

    ASSERT(m_pvBaseAddress);
    ASSERT(m_dwBankSize);

    pSectionData->pHeader = (LPWAVEBANKHEADER)m_pvBaseAddress;
    pSectionData->paMetaData = (LPWAVEBANKENTRY)(pSectionData->pHeader + 1);
    pSectionData->pvData = &pSectionData->paMetaData[pSectionData->pHeader->dwEntryCount];
    pSectionData->dwDataSize = m_dwBankSize - sizeof(*pSectionData->pHeader) - (sizeof(pSectionData->paMetaData[0]) * pSectionData->pHeader->dwEntryCount);

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\loader.h ===
/***************************************************************************
 *
 *  Copyright (C) 02/13/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       loader.h
 *  Content:    Wave bank project loader.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/13/2002  dereks  Created.
 *
 ****************************************************************************/

#ifndef __LOADER_H__
#define __LOADER_H__

//
// File extensions
//

#define WBWRITER_FILEEXTENSION_PROJECT          TEXT("xwp")
#define WBWRITER_FILEEXTENSION_BANK             TEXT("xwb")
#define WBWRITER_FILEEXTENSION_HEADER           TEXT("h")
                                                
//                                              
// Project file format                          
//                                              
                                                
#define WBPROJECT_PROJECT_MAIN_SECTION          TEXT("PROJECT")
#define WBPROJECT_PROJECT_BANKCOUNT_KEY         TEXT("BANKCOUNT")
                                                
#define WBPROJECT_BANK_KEY                      TEXT("BANK%lu")
#define WBPROJECT_BANK_NAME_KEY                 TEXT("BANKNAME")
#define WBPROJECT_BANK_FILE_KEY                 TEXT("BANKFILE")
#define WBPROJECT_BANK_HEADER_KEY               TEXT("HEADERFILE")
#define WBPROJECT_BANK_ENTRYCOUNT_KEY           TEXT("ENTRYCOUNT")
                                                
#define WBPROJECT_ENTRY_KEY                     TEXT("ENTRY%lu")
                                                
#define WBPROJECT_ENTRYEXT_SEPARATOR_STR        TEXT(",")
#define WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR      TEXT(',')

#define WBPROJECT_ENTRYEXT_ADPCMFILTER_STR      TEXT("c")
#define WBPROJECT_ENTRYEXT_ADPCMFILTER_LCHAR    TEXT('c')
                                                
#define WBPROJECT_ENTRYEXT_8BITFILTER_STR       TEXT("8")
#define WBPROJECT_ENTRYEXT_8BITFILTER_LCHAR     TEXT('8')

#ifdef __cplusplus

//
// Forward declarations
//

class CWaveBankProject;
class CWaveBank;
class CWaveBankEntry;

//
// Project loader
//

class CWaveBankProjectFile
{
protected:
    CWaveBankProject *      m_pProject;                 // Wave bank project object
    TCHAR                   m_szProjectFile[MAX_PATH];  // Project file path

public:
    // IO
    virtual HRESULT Load(CWaveBankProject *pProject, LPCTSTR pszProjectFile);
    virtual HRESULT Save(CWaveBankProject *pProject, LPCTSTR pszProjectFile);

protected:
    virtual HRESULT LoadBank(DWORD dwBankIndex);
    virtual HRESULT SaveBank(CWaveBank *pBank, DWORD dwBankIndex);

    virtual HRESULT LoadEntry(LPCTSTR pszSectionName, CWaveBank *pBank, DWORD dwEntryIndex);
    virtual HRESULT SaveEntry(LPCTSTR pszSectionName, CWaveBankEntry *pEntry, DWORD dwEntryIndex);
};

#endif // __cplusplus

#endif // __LOADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\wavbndli.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wavbndli.h
 *  Content:    Wave Bundler common library definitions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/2/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WAVBNDLI_H__
#define __WAVBNDLI_H__

#include "..\..\..\..\dsound\common\dscommon.h"
#include "wavbndlr.h"
#include "filter.h"
#include "writer.h"
#include "loader.h"

#endif // __WAVBNDLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\writer.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       writer.h
 *  Content:    Wave bank writer.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/2/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WRITER_H__
#define __WRITER_H__

//
// C header file format
//

#define WBCHEADER_ENUMNAME                      TEXT("WAVEBANK_%s")
#define WBCHEADER_ENUMENTRYNAME                 WBCHEADER_ENUMNAME TEXT("_%s")
#define WBCHEADER_ENTRYCOUNTSHORTNAME           TEXT("ENTRY_COUNT")
#define WBCHEADER_ENTRYCOUNTNAME                WBCHEADER_ENUMNAME TEXT("_") WBCHEADER_ENTRYCOUNTSHORTNAME

#ifdef __cplusplus

//
// Forward declarations
//

class CWaveBank;
class CWaveBankProject;
class CWaveBankCallback;

//
// Wave bank entry
//

class CWaveBankEntry
{
public:
    static BOOL             m_fAutoLoad;            // Automatically load wave file at init?

public:
    CWaveBank *             m_pParent;              // Parent object
    LIST_ENTRY              m_leEntry;              // Parent list entry
    TCHAR                   m_szEntryName[0x100];   // Entry name
    TCHAR                   m_szHeaderName[0x100];  // Entry name (header version)
    TCHAR                   m_szFileName[MAX_PATH]; // Source file path
    WAVEBANKMINIWAVEFORMAT  m_Format;               // Format
    WAVEBANKENTRYREGION     m_PlayRegion;           // Wave data file offset/length
    WAVEBANKENTRYREGION     m_LoopRegion;           // Loop region
    DWORD                   m_dwFlags;              // Flags
    DWORD                   m_dwFileType;           // File type
    BOOL                    m_fLoaded;              // Has the wave file been parsed?
    DWORD                   m_dwDestLength;         // File size when stored in the wave bank

public:
    CWaveBankEntry(CWaveBank *pParent);
    virtual ~CWaveBankEntry(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCTSTR pszEntryName, LPCTSTR pszFileName, DWORD dwFlags);
    virtual HRESULT Load(BOOL fForce = FALSE);

    // Entry properties
    virtual HRESULT SetName(LPCTSTR pszName);
    virtual DWORD GetValidFlags(void);
    virtual DWORD SetFlags(DWORD dwMask, DWORD dwFlags);

    // Entry data
    virtual HRESULT GetMetaData(LPWAVEBANKENTRY pMetaData, DWORD dwBaseOffset, DWORD dwAlignment, LPDWORD pdwOffset);
    virtual HRESULT CommitWaveData(CWaveBankCallback *pCallback, CStdFileStream *pBankFile, DWORD dwBaseOffset, LPCWAVEBANKENTRY pMetaData, LPVOID pvCopyBuffer, DWORD dwCopyBufferSize);

protected:
    // Validation
    virtual HRESULT FindDuplicateEntry(LPCTSTR pszName, UINT *pnNameCount, LPCTSTR pszPath, UINT *pnPathCount);
};

//
// Wave bank
//

class CWaveBank
{
public:
    static const DWORD      m_dwMinAlignment;                               // Minimum entry alignment

public:
    CWaveBankProject *      m_pParent;                                      // Parent object
    LIST_ENTRY              m_leBank;                                       // Wave bank list entry
    TCHAR                   m_szBankName[WAVEBANKHEADER_BANKNAME_LENGTH];   // Wave bank name
    TCHAR                   m_szHeaderName[WAVEBANKHEADER_BANKNAME_LENGTH]; // Wave bank name (header version)
    TCHAR                   m_szBankFile[MAX_PATH];                         // Wave bank file name
    TCHAR                   m_szHeaderFile[MAX_PATH];                       // Wave bank header file name
    LIST_ENTRY              m_lstEntries;                                   // Bank entry list
    DWORD                   m_dwEntryCount;                                 // Wave bank entry count
    DWORD                   m_dwFlags;                                      // Wave bank flags
    DWORD                   m_dwAlignment;                                  // Entry alignment

public:
    CWaveBank(CWaveBankProject *pParent = NULL);
    virtual ~CWaveBank(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCTSTR pszBankName, LPCTSTR pszBankFile, LPCTSTR pszHeaderFile);

    // Bank properties
    virtual HRESULT SetName(LPCTSTR pszName);
    virtual HRESULT SetAlignment(DWORD dwAlignment);
    virtual DWORD GetBankDataSize(void);

    // Entries
    virtual HRESULT AddEntry(LPCTSTR pszEntryName, LPCTSTR pszFileName, DWORD dwFlags, CWaveBankEntry **ppEntry = NULL);
    virtual void RemoveEntry(CWaveBankEntry *pEntry);
    virtual HRESULT LoadEntries(BOOL fForce = FALSE);

    // File creation
    virtual HRESULT GenerateBank(CWaveBankCallback *pCallback, BOOL fAllowOverwrite);
    virtual HRESULT GenerateHeader(CWaveBankCallback *pCallback, BOOL fAllowOverwrite);

protected:
    // Entry creation
    virtual CWaveBankEntry *CreateEntry(void);

    // File creation
    virtual DWORD GetBankHeaderSize(void);
    static DWORD GetBankHeaderSize(DWORD dwEntryCount);

    // Validation
    virtual HRESULT FindDuplicateBank(LPCTSTR pszName, UINT *pnNameCount, LPCTSTR pszBankFile, UINT *pnBankFile, LPCTSTR pszHeaderFile, UINT *pnHeaderFile);
};

__inline void CWaveBank::RemoveEntry(CWaveBankEntry *pEntry)
{
    DELETE(pEntry);
}

__inline DWORD CWaveBank::GetBankHeaderSize(DWORD dwEntryCount)
{
    return sizeof(WAVEBANKHEADER) + (sizeof(WAVEBANKENTRY) * dwEntryCount);
}

__inline DWORD CWaveBank::GetBankHeaderSize(void)
{
    return GetBankHeaderSize(m_dwEntryCount);
}

__inline CWaveBankEntry *CWaveBank::CreateEntry(void)
{
    return NEW(CWaveBankEntry(this));
}

//
// Wave bank project
//

class CWaveBankProject
{
public:
    LIST_ENTRY              m_lstBanks;                 // Wave bank list
    DWORD                   m_dwBankCount;              // Bank count
    DWORD                   m_dwEntryCount;             // Total entry count

public:
    CWaveBankProject(void);
    virtual ~CWaveBankProject(void);

public:
    // Banks
    virtual HRESULT AddBank(LPCTSTR pszBankName, LPCTSTR pszBankFile, LPCTSTR pszHeaderFile, CWaveBank **ppBank);
    virtual void RemoveBank(CWaveBank *pBank);
    
    // File creation
    virtual HRESULT Generate(CWaveBankCallback *pCallback, BOOL fAllowOverwrite);

protected:    
    // Bank creation
    virtual CWaveBank *CreateBank(void);
};

__inline void CWaveBankProject::RemoveBank(CWaveBank *pBank)
{
    DELETE(pBank);
}

__inline CWaveBank *CWaveBankProject::CreateBank(void)
{
    return NEW(CWaveBank(this));
}

//
// Wave bank status callback
//

class CWaveBankCallback
{
public:
    virtual BOOL BeginProject(CWaveBankProject *pProject);
    virtual void EndProject(CWaveBankProject *pProject, HRESULT hr);
    virtual BOOL OpenBank(CWaveBank *pBank);
    virtual void CloseBank(CWaveBank *pBank);
    virtual BOOL OpenHeader(CWaveBank *pBank);
    virtual void CloseHeader(CWaveBank *pBank);
    virtual BOOL BeginEntry(CWaveBankEntry *pEntry);
    virtual BOOL ProcessEntry(CWaveBankEntry *pEntry, DWORD dwProcessed);
    virtual void EndEntry(CWaveBankEntry *pEntry);
};

__inline BOOL CWaveBankCallback::BeginProject(CWaveBankProject *pProject)
{
    return TRUE;
}

__inline void CWaveBankCallback::EndProject(CWaveBankProject *pProject, HRESULT hr)
{
}

__inline BOOL CWaveBankCallback::OpenBank(CWaveBank *pBank)
{
    return TRUE;
}

__inline void CWaveBankCallback::CloseBank(CWaveBank *pBank)
{
}

__inline BOOL CWaveBankCallback::OpenHeader(CWaveBank *pBank)
{
    return TRUE;
}

__inline void CWaveBankCallback::CloseHeader(CWaveBank *pBank)
{
}

__inline BOOL CWaveBankCallback::BeginEntry(CWaveBankEntry *pEntry)
{
    return TRUE;
}

__inline BOOL CWaveBankCallback::ProcessEntry(CWaveBankEntry *pEntry, DWORD dwProcessed)
{
    return TRUE;
}

__inline void CWaveBankCallback::EndEntry(CWaveBankEntry *pEntry)
{
}

#endif // __cplusplus

#endif // __WRITER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\filegen\filegen.cpp ===
// filegen.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

int __cdecl main(int argc, char* argv[])
{
    CXACTFileGenerator *pFileGen = new CXACTFileGenerator("XACT BINARY FILE GENERATOR");
    int err;

    if (pFileGen == NULL) {
        return -1;
    }

    err = pFileGen->ParseCommandLine(argc,argv);
    if (err != ERROR_SUCCESS) {
		pFileGen->DebugPrint(DBGLVL_ERROR,"Failed parsing input file");
        goto mainExit;
    }

    err = pFileGen->ParseIniFile();
    if (err != ERROR_SUCCESS) {
		pFileGen->DebugPrint(DBGLVL_ERROR,"Failed parsing input file");
        goto mainExit;
    }

    err = pFileGen->CreateBinaryImage();
    if (err != ERROR_SUCCESS) {
		pFileGen->DebugPrint(DBGLVL_ERROR,"Failed parsing input file");
        goto mainExit;
    }

mainExit:
    delete pFileGen;

	return 0;
}


CXACTFileGenerator::CXACTFileGenerator(char* AppName)
{
    memcpy(m_szAppName,AppName,sizeof(m_szAppName));

    m_hInputFile = NULL;
    m_hOutputFile = NULL;
    m_dwDebugLevel = DBGLVL_WARN;

    memset(m_szIniFileName,0,sizeof(m_szIniFileName));
    memset(m_szOutputFileName,0,sizeof(m_szOutputFileName));

    m_hInputFile = INVALID_HANDLE_VALUE;
    m_hOutputFile = INVALID_HANDLE_VALUE;

    m_pFileHeader = NULL;
    m_pSoundTable  = NULL;
    m_pCueTable = NULL;
	m_pXACTSoundTable = NULL;

}

CXACTFileGenerator::~CXACTFileGenerator()
{
    if (m_hInputFile != INVALID_HANDLE_VALUE) {
        CloseHandle(m_hInputFile);
    }

    if (m_hOutputFile != INVALID_HANDLE_VALUE) {
        CloseHandle(m_hOutputFile);
    }

    if (m_pCueTable) {
        delete [] m_pCueTable;
        m_pCueTable = NULL;
    }

    if (m_pSoundTable) {
        delete [] m_pSoundTable;
        m_pSoundTable = NULL;
    }

    if (m_pXACTSoundTable) {
        delete [] m_pXACTSoundTable;
        m_pXACTSoundTable = NULL;
    }


}

// ****************************************************************************
// binary file generation
// ****************************************************************************

int CXACTFileGenerator::CreateBinaryImage()
{
	int err = ERROR_SUCCESS;
	DWORD dwSize, dwBytesWritten, i,j;
	BOOL bResult;

	DWORD dw3dParamOffset = 0, dwTotalTracks = 0, dwTotalWaveBankEntries = 0;
	DWORD dwTrackTableOffset = 0;
	DWORD dwEventDataBaseOffset = 0;
	DWORD dwEventDataOffset = 0;
	DWORD dwTrackTableBaseOffset = 0;
	DWORD dwWaveBankTableBaseOffset = 0;
	DWORD dwOffset = 0;

    m_hOutputFile = CreateFile(
        (const char *)m_szOutputFileName,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS,
        0,
        NULL);

    if (m_hOutputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        Print("\n Failed to open the output file.Error 0x%x\n", err);
        return err;

    }

	dwOffset = 0;

	dwSize = SetFilePointer(m_hOutputFile,
		dwOffset,
		NULL,
		FILE_BEGIN);

	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	//
	// setup file header
	//

	m_pFileHeader->dwSignature = (DWORD) XACT_SOUNDBANK_HEADER_SIGNATURE;
	m_pFileHeader->dwVersion = XACT_SOUNDBANK_HEADER_VERSION;
	m_pFileHeader->dwFlags = 0;

    //
	// first write out the header for the soundbank file
	//

	bResult = WriteFile(m_hOutputFile,
		m_pFileHeader,
		sizeof(*m_pFileHeader),
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
		goto errExit;
		
	}

	//
	// advance offset
	//

	dwOffset += dwBytesWritten;

	//
	// now write the cue entry table
	//

	bResult = WriteFile(m_hOutputFile,
		m_pCueTable,
		sizeof(XACT_SOUNDBANK_CUE_ENTRY)*m_pFileHeader->dwCueEntryCount,
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
		goto errExit;
		
	}

    //
	// advance offset
	//

	dwOffset += dwBytesWritten;

	//
	// calculate the file offset for the variable length data (tracks, wavebank table, 3d params)
	// 3d param data follows the sound entry table. 
	//

	dw3dParamOffset = dwOffset + sizeof(XACT_SOUNDBANK_SOUND_ENTRY)*m_pFileHeader->dwSoundEntryCount;

	//
	// set file pointer to 3d param data offset
	//

	dwSize = SetFilePointer(m_hOutputFile,
		dw3dParamOffset,
		NULL,
		FILE_BEGIN);

	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	//
	// collect total object information
	//

	dwTotalTracks = 0;
	dwTotalWaveBankEntries = 0;

	for (i=0;i<m_pFileHeader->dwSoundEntryCount;i++)
	{
		//
		// every sound has 3d param data in this implementation
		//
	
		dwTotalTracks += m_pSoundTable[i].m_pSoundEntry->wTrackCount;
		dwTotalWaveBankEntries += m_pSoundTable[i].m_pSoundEntry->wWaveBankCount;

		//
		// we have enough information to write out the 3d param data for each sound
		//

		if (m_pSoundTable[i].m_pSoundEntry->dwFlags & XACT_FLAG_SOUND_3D) {

			m_pSoundTable[i].m_pSoundEntry->dw3DParametersOffset = dw3dParamOffset;
     		dw3dParamOffset += sizeof(XACT_SOUNDBANK_SOUND_3D_PARAMETERS);

			bResult = WriteFile(m_hOutputFile,
				m_pSoundTable[i].m_pSound3dData,
				sizeof(XACT_SOUNDBANK_SOUND_3D_PARAMETERS),
				&dwBytesWritten,
				0);
			
			if (!bResult) {
				
				err = GetLastError();
				DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
				goto errExit;
				
			}

		}

	}

	//
	// now calculate offsets for wavebank tables
	//

	dwWaveBankTableBaseOffset = dw3dParamOffset;

	//
	// calc base offset for track table
	//

	dwTrackTableBaseOffset = dwWaveBankTableBaseOffset + sizeof(XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY)*dwTotalWaveBankEntries;

	//
	// calc base offset for track event data
	//

	dwEventDataBaseOffset = dwTrackTableBaseOffset + sizeof(XACT_SOUNDBANK_TRACK_ENTRY)*dwTotalTracks;
	dwEventDataOffset = dwEventDataBaseOffset;

	dwSize = SetFilePointer(m_hOutputFile,
		dwEventDataOffset,
		NULL,
		FILE_BEGIN);
	
	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	//
	// now fill in the offsets for each sound entry
	//

	for (i=0;i<m_pFileHeader->dwSoundEntryCount;i++)
	{
		//
		// every sound has 3d param data in this implementation
		//

		m_pSoundTable[i].m_pSoundEntry->dwTrackTableOffset = dwTrackTableBaseOffset + i*sizeof(XACT_SOUNDBANK_TRACK_ENTRY);
		m_pSoundTable[i].m_pSoundEntry->dwWaveBankTableOffset = dwWaveBankTableBaseOffset + i*sizeof(XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY);

		//
		// calculate the event data offset for each track in the sound
		//
		
		for (j=0;j<m_pSoundTable[i].m_pSoundEntry->wTrackCount;j++)
		{
			CXACTTrackData *pTrackData = &m_pSoundTable[i].m_pTrackTable[j];
			pTrackData->m_pTrackEntry->dwEventDataOffset = dwEventDataOffset;
			dwEventDataOffset += pTrackData->m_dwEventDataSize;

			//
			// write out all the event data to file now that we know their offset
			//

			bResult = WriteFile(m_hOutputFile,
				pTrackData->m_pEventBuffer,
				pTrackData->m_dwEventDataSize,
				&dwBytesWritten,
				0);
			
			if (!bResult) {
				
				err = GetLastError();
				DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
				goto errExit;
				
			}

		}

	}


	//
	// we are now ready to write everything out.
	// start with the sound table
	// reset file pointer to sound entry table base
	//

    dwSize = SetFilePointer(m_hOutputFile,
		dwOffset,
		NULL,
		FILE_BEGIN);
	
	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	bResult = WriteFile(m_hOutputFile,
		m_pXACTSoundTable,
		sizeof(XACT_SOUNDBANK_SOUND_ENTRY)*m_pFileHeader->dwSoundEntryCount,
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
		goto errExit;
		
	}

    //
	// advance offset to wave bank table. 3d params have already been written
	//

	dwOffset = dwWaveBankTableBaseOffset;

    dwSize = SetFilePointer(m_hOutputFile,
		dwOffset,
		NULL,
		FILE_BEGIN);
	
	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	for (i=0;i<m_pFileHeader->dwSoundEntryCount;i++)
	{
		
		
		bResult = WriteFile(m_hOutputFile,
			m_pSoundTable[i].m_pWaveBankTable,
			sizeof(XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY)*m_pSoundTable[i].m_pSoundEntry->wWaveBankCount,
			&dwBytesWritten,
			0);
		
		if (!bResult) {
			
			err = GetLastError();
			DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
			goto errExit;
			
		}
		
	}

	//
	// the offset should now be at the track table base
	//

	dwOffset = dwTrackTableBaseOffset;

    dwSize = SetFilePointer(m_hOutputFile,
		dwOffset,
		NULL,
		FILE_BEGIN);
	
	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	for (i=0;i<m_pFileHeader->dwSoundEntryCount;i++)
	{
		
		bResult = WriteFile(m_hOutputFile,
			m_pSoundTable[i].m_pXACTTrackTable,
			sizeof(XACT_SOUNDBANK_TRACK_ENTRY)*m_pSoundTable[i].m_pSoundEntry->wTrackCount,
			&dwBytesWritten,
			0);
		
		if (!bResult) {
			
			err = GetLastError();
			DebugPrint(DBGLVL_ERROR,"Failed to write data to file %s",m_szOutputFileName);
			goto errExit;
			
		}
		
	}
	





errExit:

    //
    // we dont need the output file anymore
    //

    CloseHandle(m_hOutputFile);
    m_hOutputFile = INVALID_HANDLE_VALUE;

    return err;


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\common\wavbndlr\writer.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       writer.cpp
 *  Content:    Wave bank writer.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/2/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"

const DWORD CWaveBank::m_dwMinAlignment = 4;

BOOL CWaveBankEntry::m_fAutoLoad = TRUE;


/****************************************************************************
 *
 *  MakeHeaderString
 *
 *  Description:
 *      Removes all spaces from a string and replaces them with underscores.
 *
 *  Arguments:
 *      LPTSTR [in/out]: string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MakeHeaderString"

static void
MakeHeaderString
(
    LPTSTR                  pszString
)
{
    while(*pszString)
    {
        if((*pszString >= TEXT('a')) && (*pszString <= TEXT('z')))
        {
            *pszString = TEXT('A') + *pszString - TEXT('a');
        }
        else if((*pszString >= TEXT('A')) && (*pszString <= TEXT('Z')))
        {
        }
        else if((*pszString >= TEXT('0')) && (*pszString <= TEXT('9')))
        {
        }
        else
        {
            *pszString = TEXT('_');
        }

        pszString++;
    }
}


/****************************************************************************
 *
 *  CWaveBankEntry
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CWaveBank * [in]: parent object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::CWaveBankEntry"

CWaveBankEntry::CWaveBankEntry
(
    CWaveBank *             pParent
)
{
    DPF_ENTER();

    m_pParent = pParent;

    InsertTailListUninit(&m_pParent->m_lstEntries, &m_leEntry);

    m_pParent->m_dwEntryCount++;
    m_pParent->m_pParent->m_dwEntryCount++;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBankEntry
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::~CWaveBankEntry"

CWaveBankEntry::~CWaveBankEntry
(
    void
)
{
    DPF_ENTER();

    RemoveEntryList(&m_leEntry);

    ASSERT(m_pParent->m_dwEntryCount);
    m_pParent->m_dwEntryCount--;

    ASSERT(m_pParent->m_pParent->m_dwEntryCount);
    m_pParent->m_pParent->m_dwEntryCount--;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object from a source file.
 *
 *  Arguments:
 *      LPCTSTR [in]: entry name.
 *      LPCTSTR [in]: wave file name.
 *      DWORD [in]: processing flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::Initialize"

HRESULT
CWaveBankEntry::Initialize
(
    LPCTSTR                 pszEntryName,
    LPCTSTR                 pszFileName,
    DWORD                   dwFlags
)
{
    HRESULT                 hr          = S_OK;
    UINT                    nNameCount;
    UINT                    nFileCount;
    
    DPF_ENTER();

    ASSERT(pszFileName);

    //
    // Save the file path
    //

    GetFullPathName(pszFileName, NUMELMS(m_szFileName), m_szFileName, NULL);

    //
    // Save the flags
    //

    m_dwFlags = dwFlags;

    //
    // If no entry name was specified, generate one from the file name
    //

    if(pszEntryName)
    {
        _tcsncpy(m_szEntryName, pszEntryName, NUMELMS(m_szEntryName));
    }
    else
    {
        _splitpath(m_szFileName, NULL, NULL, m_szEntryName, NULL);
    }

    _tcsncpy(m_szHeaderName, m_szEntryName, NUMELMS(m_szHeaderName));
    MakeHeaderString(m_szHeaderName);

    FindDuplicateEntry(m_szHeaderName, &nNameCount, m_szFileName, &nFileCount);

    if(nNameCount)
    {
        DPF_ERROR("An entry with that name already exists in the bank, or that name has been reserved");
        hr = E_FAIL;
    }
    else if(nFileCount)
    {
        DPF_WARNING("An entry using that filename already exists in the bank");
    }

    //
    // Open the file
    //

    if(SUCCEEDED(hr) && m_fAutoLoad)
    {
        hr = Load();
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  FindDuplicateEntry
 *
 *  Description:
 *      Checks the wave bank for a duplicate entry.
 *
 *  Arguments:
 *      LPCTSTR [in]: entry name.
 *      UINT * [out]: count of duplicate named entries found.
 *      LPCTSTR [in]: entry file path.
 *      UINT * [out]: count of duplicate pathed entries found.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::FindDuplicateEntry"

HRESULT
CWaveBankEntry::FindDuplicateEntry
(
    LPCTSTR                 pszName,
    UINT *                  pnNameCount,
    LPCTSTR                 pszPath,
    UINT *                  pnPathCount
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    
    DPF_ENTER();

    ASSERT(pszName || pszPath);

    if(pnNameCount)
    {
        *pnNameCount = 0;
    }

    if(pnPathCount)
    {
        *pnPathCount = 0;
    }

    if(pszName)
    {
        if(!_tcsicmp(pszName, WBCHEADER_ENTRYCOUNTSHORTNAME))
        {
            hr = E_FAIL;
            
            if(pnNameCount)
            {
                *pnNameCount += 1;
            }
        }
    }

    for(pleEntry = m_pParent->m_lstEntries.Flink; pleEntry != &m_pParent->m_lstEntries; pleEntry = pleEntry->Flink)
    {
        if(FAILED(hr) && !pnNameCount && !pnPathCount)
        {
            break;
        }
        
        if(this == (pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry)))
        {
            continue;
        }

        if(pszName)
        {
            if(!_tcsicmp(pszName, pEntry->m_szHeaderName))
            {
                hr = E_FAIL;
                
                if(pnNameCount)
                {
                    *pnNameCount += 1;
                }
            }
        }

        if(pszPath)
        {
            if(!_tcsicmp(pszPath, pEntry->m_szFileName))
            {
                hr = E_FAIL;
                
                if(pnPathCount)
                {
                    *pnPathCount += 1;
                }
            }
        }
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the entry.
 *
 *  Arguments:
 *      LPCTSTR [in]: entry name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::SetName"

HRESULT 
CWaveBankEntry::SetName
(
    LPCTSTR                 pszName
)
{
    HRESULT                 hr                                      = S_OK;
    TCHAR                   szHeaderName[NUMELMS(m_szHeaderName)];

    if(_tcslen(pszName) >= NUMELMS(m_szEntryName))
    {
        DPF_ERROR("That name is too long");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        _tcsncpy(szHeaderName, pszName, NUMELMS(szHeaderName));
        MakeHeaderString(szHeaderName);

        hr = FindDuplicateEntry(szHeaderName, NULL, NULL, NULL);

        if(SUCCEEDED(hr))
        {
            _tcsncpy(m_szEntryName, pszName, NUMELMS(m_szEntryName));
            _tcsncpy(m_szHeaderName, szHeaderName, NUMELMS(m_szHeaderName));
        }
        else
        {
            DPF_ERROR("An entry with that name already exists in the bank, or that name has been reserved");
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  Load
 *
 *  Description:
 *      Initializes the object from a wave file.
 *
 *  Arguments:
 *      BOOL: TRUE to force a reload.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::Load"

HRESULT
CWaveBankEntry::Load
(
    BOOL                    fForce
)
{
    HRESULT                 hr          = S_OK;
    CWaveFile               WaveFile;
    WAVEBANKUNIWAVEFORMAT   Format;
    
    DPF_ENTER();

    if(fForce || !m_fLoaded)
    {
        //
        // Open the file
        //

        if(FAILED(hr = WaveFile.Open(m_szFileName)))
        {
            DPF_ERROR("An error occurred while attempting to open %s", m_szFileName);
        }

        //
        // Load the file format
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = WaveFile.GetFileType(&m_dwFileType)))
            {
                DPF_ERROR("An error occurred while attempting to retrieve the file type");
            }
        }

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = WaveFile.GetFormat(&Format.WaveFormatEx, sizeof(Format))))
            {
                DPF_ERROR("An error occurred while attempting to retrieve the file format");
            }
        }

        if(SUCCEEDED(hr))
        {
            if(!WaveBankCompressFormat(&Format, &m_Format))
            {
                hr = E_NOTIMPL;
            }
        }

        //
        // Save the data chunk offset and length
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = WaveFile.GetDataOffset(&m_PlayRegion.dwStart)))
            {
                DPF_ERROR("An error occurred while attempting to retrieve the wave data offset");
            }
        }
    
        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = WaveFile.GetDuration(&m_PlayRegion.dwLength)))
            {
                DPF_ERROR("An error occurred while attempting to retrieve the wave data length");
            }
        }

        //
        // Save the loop region
        //

        if(SUCCEEDED(hr))
        {
            hr = WaveFile.GetLoopRegion(&m_LoopRegion.dwStart, &m_LoopRegion.dwLength);

            if(FAILED(hr))
            {
                m_LoopRegion.dwStart = 0;
                m_LoopRegion.dwLength = 0;
            
                hr = S_OK;
            }
        }
    
        //
        // Update the flags to account for having valid data
        //
    
        if(SUCCEEDED(hr))
        {
            SetFlags(~0UL, m_dwFlags);
        }

        //
        // Success
        //

        if(SUCCEEDED(hr))
        {
            m_fLoaded = TRUE;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetValidFlags
 *
 *  Description:
 *      Gets the mask of flags available for the entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: valid flags mask.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::GetValidFlags"

DWORD
CWaveBankEntry::GetValidFlags
(
    void
)
{
    DWORD                   dwFlags = 0;
    
    DPF_ENTER();

    if(CXboxAdpcmFilter::IsValidFormat(&m_Format))
    {
        dwFlags |= WBFILTER_ADPCM;
    }

    if(C8BitFilter::IsValidFormat(&m_Format))
    {
        dwFlags |= WBFILTER_8BIT;
    }

    DPF_LEAVE(dwFlags);

    return dwFlags;
}


/****************************************************************************
 *
 *  SetFlags
 *
 *  Description:
 *      Sets entry flags.  Because of error-checking, the flags actually set
 *      by this method may not match those passed in.
 *
 *  Arguments:
 *      DWORD [in]: mask of flags to change.
 *      DWORD [in]: new flags.
 *
 *  Returns:  
 *      DWORD: new flags.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::SetFlags"

DWORD
CWaveBankEntry::SetFlags
(
    DWORD                   dwMask,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

    //
    // Check the mask against what the filters can actually deal with
    //

    dwMask &= GetValidFlags();

    //
    // Mask off any unused bits
    //
    
    dwFlags &= dwMask;
    
    //
    // ADPCM and 8BIT are mutually exclusive
    //

    if((dwFlags & WBFILTER_ADPCM) && (dwFlags & WBFILTER_8BIT))
    {
        DPF_WARNING("ADPCM and 8BIT filtering are mutually exclusive");
        dwFlags &= ~WBFILTER_8BIT;
    }

    //
    // Set the flags
    //

    m_dwFlags &= ~dwMask;
    m_dwFlags |= dwFlags;

    //
    // Recalculate the size the entry will take in the wave bank, including
    // alignment
    //

    m_dwDestLength = m_PlayRegion.dwLength;

    if(m_dwFlags & WBFILTER_ADPCM)
    {
        m_dwDestLength = CXboxAdpcmFilter::GetSize(m_dwDestLength, m_Format.nChannels, TRUE);
    }
    else if(m_dwFlags & WBFILTER_8BIT)
    {
        m_dwDestLength = C8BitFilter::GetSize(m_dwDestLength, m_Format.nChannels);
    }

    DPF_LEAVE(dwFlags);

    return dwFlags;
}


/****************************************************************************
 *
 *  GetMetaData
 *
 *  Description:
 *      Generates entry meta-data.
 *
 *  Arguments:
 *      LPWAVEBANKENTRY [out]: entry meta-data.
 *      DWORD [in]: base file offset of the data segment.
 *      DWORD [in]: entry alignment.
 *      LPDWORD [in/out]: current offset into the data segment.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::GetMetaData"

HRESULT
CWaveBankEntry::GetMetaData
(
    LPWAVEBANKENTRY         pMetaData,
    DWORD                   dwBaseOffset,
    DWORD                   dwAlignment,
    LPDWORD                 pdwOffset
)
{
    BOOL                    fSuccess;
    
    DPF_ENTER();

    ASSERT(!((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT)));
    ASSERT(m_fLoaded);

    //
    // Align the starting offset
    //

    *pdwOffset = BLOCKALIGNPAD(dwBaseOffset + *pdwOffset, dwAlignment) - dwBaseOffset;

    //
    // If we're compressing, write the compressed format, not the source
    //

    pMetaData->Format = m_Format;

    if(m_dwFlags & WBFILTER_ADPCM)
    {
        fSuccess = CXboxAdpcmFilter::ConvertFormat(&pMetaData->Format);
        ASSERT(fSuccess);
    }
    else if(m_dwFlags & WBFILTER_8BIT)
    {
        fSuccess = C8BitFilter::ConvertFormat(&pMetaData->Format);
        ASSERT(fSuccess);
    }

    //
    // Set the entry starting offset and length
    //

    pMetaData->PlayRegion.dwStart = *pdwOffset;
    pMetaData->PlayRegion.dwLength = m_dwDestLength;

    //
    // Convert the loop offsets
    //

    pMetaData->LoopRegion = m_LoopRegion;

    if(m_dwFlags & WBFILTER_ADPCM)
    {
        pMetaData->LoopRegion.dwStart = CXboxAdpcmFilter::GetSize(pMetaData->LoopRegion.dwStart, m_Format.nChannels);
        pMetaData->LoopRegion.dwLength = CXboxAdpcmFilter::GetSize(pMetaData->LoopRegion.dwLength, m_Format.nChannels);
    }
    else if(m_dwFlags & WBFILTER_8BIT)
    {
        pMetaData->LoopRegion.dwStart = C8BitFilter::GetSize(pMetaData->LoopRegion.dwStart, m_Format.nChannels);
        pMetaData->LoopRegion.dwLength = C8BitFilter::GetSize(pMetaData->LoopRegion.dwLength, m_Format.nChannels);
    }

    //
    // Update the file offset
    //

    *pdwOffset = pMetaData->PlayRegion.dwStart + pMetaData->PlayRegion.dwLength;

    DPF_LEAVE_HRESULT(S_OK);

    return S_OK;
}


/****************************************************************************
 *
 *  CommitWaveData
 *
 *  Description:
 *      Writes entry wave data to the bank file.
 *
 *  Arguments:
 *      CWaveBankCallback * [in]: callback object.
 *      CStdFileStream * [in]: bank file stream.
 *      DWORD [in]: base file offset of the data segment.
 *      LPCWAVEBANKENTRY [in]: entry meta-data generated by GetMetaData.
 *      LPVOID [in]: scratch memory.
 *      DWORD [in]: size of scratch buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::CommitWaveData"

HRESULT
CWaveBankEntry::CommitWaveData
(
    CWaveBankCallback *     pCallback,
    CStdFileStream *        pBankFile,
    DWORD                   dwBaseOffset,
    LPCWAVEBANKENTRY        pMetaData,
    LPVOID                  pvCopyBuffer,
    DWORD                   dwCopyBufferSize
)
{
    DWORD                   dwTotalRead     = 0;
    DWORD                   dwTotalWritten  = 0;
    HRESULT                 hr              = S_OK;
    CXboxAdpcmFilter        AdpcmFilter;
    C8BitFilter             BitFilter;
    CStdFileStream          WaveFile;
    DWORD                   dwAlignment;
    DWORD                   dwRead;
    DWORD                   dwWritten;
    DWORD                   dwAlignedRead;
    DWORD                   dwFilterRead;
    DWORD                   dwFileType;
    
    DPF_ENTER();

    ASSERT(!((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT)));
    ASSERT(m_fLoaded);
    
    if(!pBankFile)
    {
        ASSERT(dwCopyBufferSize >= pMetaData->PlayRegion.dwLength);
    }
    
    //
    // Call the callback
    //

    if(pCallback)
    {
        if(!pCallback->BeginEntry(this))
        {
            hr = E_ABORT;
        }
    }

    //
    // Open the source file and seek to the start of the data chunk
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.Open(m_szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN)))
        {
            DPF_ERROR("An error occurred while attempting to open %s", m_szFileName);
        }
    }

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.Seek(m_PlayRegion.dwStart, FILE_BEGIN)))
        {
            DPF_ERROR("An error occurred while attempting to read from the wave file");
        }
    }

    //
    // Seek to the proper location in the destination file
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = pBankFile->Seek(dwBaseOffset + pMetaData->PlayRegion.dwStart, FILE_BEGIN)))
        {
            DPF_ERROR("An error occurred while attempting to read from the bank file");
        }
    }

    //
    // Initialize the ADPCM filter
    //

    if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_ADPCM))
    {
        if(!AdpcmFilter.Initialize(&m_Format))
        {
            DPF_ERROR("Failed to initialize the ADPCM filter");
            hr = E_FAIL;
        }
    }

    //
    // Initialize the 8BIT filter
    //

    if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_8BIT))
    {
        if(!BitFilter.Initialize(&m_Format))
        {
            DPF_ERROR("Failed to initialize the 8BIT filter");
            hr = E_FAIL;
        }
    }

    //
    // Get the filter alignment so we never have to seek backwards in the
    // file due to converting less data than we read.
    //

    if(SUCCEEDED(hr))
    {
        if(m_dwFlags & WBFILTER_ADPCM)
        {
            dwAlignment = AdpcmFilter.GetSourceAlignment();
        }
        else if(m_dwFlags & WBFILTER_8BIT)
        {
            dwAlignment = BitFilter.GetSourceAlignment();
        }
        else
        {
            dwAlignment = m_Format.nChannels;
            
            if(WAVEBANKMINIFORMAT_BITDEPTH_16 == m_Format.wBitsPerSample)
            {
                dwAlignment *= 2;
            }
        }

        ASSERT(dwCopyBufferSize >= dwAlignment);
    }

    //
    // Start copying data
    //

    while(SUCCEEDED(hr) && (dwTotalRead < m_PlayRegion.dwLength))
    {
        //
        // Don't read past the end of the file
        //

        dwRead = min(dwCopyBufferSize, m_PlayRegion.dwLength - dwTotalRead);

        //
        // Align the read amount so we never have to seek backwards in the
        // file due to converting less data than we read.  If there isn't
        // enough data left in the file to satisfy the alignment, pad with
        // silence.
        //

        if(dwRead >= dwAlignment)
        {
            dwRead = dwAlignedRead = BLOCKALIGN(dwRead, dwAlignment);
        }
        else
        {
            dwAlignedRead = BLOCKALIGNPAD(dwRead, dwAlignment);
        }

        dwWritten = dwAlignedRead;

        //
        // Read source data
        //
        
        hr = WaveFile.Read(pvCopyBuffer, dwRead);

        //
        // Convert if AIFF PCM
        //

        if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))
        {
            CWaveFile::ConvertAiffPcm(pvCopyBuffer, dwRead, (WAVEBANKMINIFORMAT_BITDEPTH_16 == m_Format.wBitsPerSample) ? 16 : 8);
        }

        //
        // Pad with silence if necessary
        //

        if(SUCCEEDED(hr) && (dwAlignedRead > dwRead))
        {
            ZeroMemory((LPBYTE)pvCopyBuffer + dwRead, dwAlignedRead - dwRead);
        }
        
        //
        // Convert (or not)
        //

        if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_ADPCM))
        {
            dwFilterRead = dwAlignedRead;
            
            if(AdpcmFilter.Convert(pvCopyBuffer, &dwFilterRead, pvCopyBuffer, &dwWritten))
            {
                ASSERT(dwFilterRead == dwAlignedRead);
            }
            else
            {
                DPF_ERROR("An error occurred while compressing PCM data");
                hr = E_FAIL;
            }
        }
            
        if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_8BIT))
        {
            dwFilterRead = dwAlignedRead;
            
            if(BitFilter.Convert(pvCopyBuffer, &dwFilterRead, pvCopyBuffer, &dwWritten))
            {
                ASSERT(dwFilterRead == dwAlignedRead);
            }
            else
            {
                DPF_ERROR("An error occurred while compressing PCM data");
                hr = E_FAIL;
            }
        }

        //
        // Write to the bank file
        //
        
        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = pBankFile->Write(pvCopyBuffer, dwWritten)))
            {
                DPF_ERROR("An error occurred while attempting to write to the bank file");
            }
        }

        //
        // Increment counters
        //

        if(SUCCEEDED(hr))
        {
            dwTotalRead += dwRead;
            dwTotalWritten += dwWritten;
        }

        //
        // If no file was specified, bail out now
        //

        if(!pBankFile)
        {
            break;
        }

        //
        // Call the callback
        //

        if(pCallback)
        {
            if(!pCallback->ProcessEntry(this, dwTotalRead))
            {
                hr = E_ABORT;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(dwTotalRead == m_PlayRegion.dwLength);
        ASSERT(dwTotalWritten == pMetaData->PlayRegion.dwLength);
    }

    //
    // Call the callback
    //

    if(pCallback)
    {
        pCallback->EndEntry(this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CWaveBank
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::CWaveBank"

CWaveBank::CWaveBank
(
    CWaveBankProject *      pParent
)
{
    DPF_ENTER();

    m_pParent = pParent;
    m_dwEntryCount = 0;
    m_dwAlignment = m_dwMinAlignment;

    InitializeListHead(&m_lstEntries);

    if(m_pParent)
    {
        InsertTailListUninit(&m_pParent->m_lstBanks, &m_leBank);

        m_pParent->m_dwBankCount++;
    }
    else
    {
        InitializeListHead(&m_leBank);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBank
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::~CWaveBank"

CWaveBank::~CWaveBank
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    
    DPF_ENTER();

    //
    // Free all the entries
    //
    
    while((pleEntry = m_lstEntries.Flink) != &m_lstEntries)
    {
        pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);
        
        DELETE(pEntry);
    }

    //
    // Free ourselves from the parent list
    //

    RemoveEntryList(&m_leBank);

    if(m_pParent)
    {
        ASSERT(m_pParent->m_dwBankCount);
        m_pParent->m_dwBankCount--;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCTSTR [in]: wave bank name.
 *      LPCTSTR [in]: bank file path.
 *      LPCTSTR [in]: header file path.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::Initialize"

HRESULT
CWaveBank::Initialize
(
    LPCTSTR                 pszBankName,
    LPCTSTR                 pszBankFile,
    LPCTSTR                 pszHeaderFile
)
{
    HRESULT                 hr                  = S_OK;
    UINT                    nNameCount;
    UINT                    nBankFileCount;
    UINT                    nHeaderFileCount;

    DPF_ENTER();

    _tcsncpy(m_szBankName, pszBankName, NUMELMS(m_szBankName));
    _tcsncpy(m_szHeaderName, pszBankName, NUMELMS(m_szHeaderName));
    MakeHeaderString(m_szHeaderName);

    GetFullPathName(pszBankFile, NUMELMS(m_szBankFile), m_szBankFile, NULL);
    GetFullPathName(pszHeaderFile, NUMELMS(m_szHeaderFile), m_szHeaderFile, NULL);

    FindDuplicateBank(m_szHeaderName, &nNameCount, m_szBankFile, &nBankFileCount, m_szHeaderFile, &nHeaderFileCount);

    if(nNameCount)
    {
        DPF_ERROR("A bank with that name (or a similar one) already exists in the project");
        hr = E_FAIL;
    }
    else if(nBankFileCount)
    {
        DPF_ERROR("A bank using that filename already exists in the project");
        hr = E_FAIL;
    }
    else if(nHeaderFileCount)
    {
        DPF_ERROR("A bank using that header filename already exists in the project");
        hr = E_FAIL;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  FindDuplicateBank
 *
 *  Description:
 *      Checks the wave bank for a duplicate Bank.
 *
 *  Arguments:
 *      LPCTSTR [in]: Bank name.
 *      UINT * [out]: count of duplicate named entries found.
 *      LPCTSTR [in]: Bank file path.
 *      UINT * [out]: count of duplicate pathed entries found.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::FindDuplicateBank"

HRESULT
CWaveBank::FindDuplicateBank
(
    LPCTSTR                 pszName,
    UINT *                  pnNameCount,
    LPCTSTR                 pszBankFile,
    UINT *                  pnBankFileCount,
    LPCTSTR                 pszHeaderFile,
    UINT *                  pnHeaderFileCount
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleBank;
    CWaveBank *             pBank;
    
    DPF_ENTER();

    ASSERT(pszName || pszBankFile);

    if(pnNameCount)
    {
        *pnNameCount = 0;
    }

    if(pnBankFileCount)
    {
        *pnBankFileCount = 0;
    }

    if(pnHeaderFileCount)
    {
        *pnHeaderFileCount = 0;
    }

    for(pleBank = m_pParent->m_lstBanks.Flink; pleBank != &m_pParent->m_lstBanks; pleBank = pleBank->Flink)
    {
        if(this == (pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank)))
        {
            continue;
        }

        if(pszName)
        {
            if(!_tcsicmp(pszName, pBank->m_szHeaderName))
            {
                hr = E_FAIL;
                
                if(pnNameCount)
                {
                    *pnNameCount = *pnNameCount + 1;
                }
                else if(!pnBankFileCount)
                {
                    break;
                }
            }
        }

        if(pszBankFile)
        {
            if(!_tcsicmp(pszBankFile, pBank->m_szBankFile))
            {
                hr = E_FAIL;
                
                if(pnBankFileCount)
                {
                    *pnBankFileCount = *pnBankFileCount + 1;
                }
                else if(!pnNameCount)
                {
                    break;
                }
            }
        }

        if(pszHeaderFile)
        {
            if(!_tcsicmp(pszHeaderFile, pBank->m_szHeaderFile))
            {
                hr = E_FAIL;
                
                if(pnHeaderFileCount)
                {
                    *pnHeaderFileCount = *pnHeaderFileCount + 1;
                }
                else if(!pnNameCount)
                {
                    break;
                }
            }
        }
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the Bank.
 *
 *  Arguments:
 *      LPCTSTR [in]: Bank name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "SetName"

HRESULT 
CWaveBank::SetName
(
    LPCTSTR                  pszName
)
{
    HRESULT                 hr                                      = S_OK;
    TCHAR                   szHeaderName[NUMELMS(m_szHeaderName)];

    if(_tcslen(pszName) >= NUMELMS(m_szBankName))
    {
        DPF_ERROR("That name is too long");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        _tcsncpy(szHeaderName, pszName, NUMELMS(szHeaderName));
        MakeHeaderString(szHeaderName);

        hr = FindDuplicateBank(szHeaderName, NULL, NULL, NULL, NULL, NULL);

        if(SUCCEEDED(hr))
        {
            _tcsncpy(m_szBankName, pszName, NUMELMS(m_szBankName));
            _tcsncpy(m_szHeaderName, szHeaderName, NUMELMS(m_szHeaderName));
        }
        else
        {
            DPF_ERROR("A bank with that name (or a similar one) already exists in the project");
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  SetAlignment
 *
 *  Description:
 *      Sets entry data alignment.
 *
 *  Arguments:
 *      DWORD [in]: alignment.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "SetAlignment"

HRESULT 
CWaveBank::SetAlignment
(
    DWORD                   dwAlignment
)
{
    HRESULT                 hr  = S_OK;
    
    if(dwAlignment % m_dwMinAlignment)
    {
        DPF_ERROR("Alignment must be a multiple of %lu", m_dwMinAlignment);
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr))
    {
        m_dwAlignment = dwAlignment;
    }

    return hr;
}


/****************************************************************************
 *
 *  AddEntry
 *
 *  Description:
 *      Adds an entry to the wave bank.
 *
 *  Arguments:
 *      LPCTSTR [in]: entry name.
 *      LPCTSTR [in]: wave file name.
 *      DWORD [in]: entry flags.
 *      CWaveBankEntry ** [out]: entry object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::AddEntry"

HRESULT
CWaveBank::AddEntry
(
    LPCTSTR                 pszEntryName,
    LPCTSTR                 pszFileName,
    DWORD                   dwFlags,
    CWaveBankEntry **       ppEntry
)
{
    CWaveBankEntry *        pEntry;
    HRESULT                 hr;
    
    DPF_ENTER();

    hr = HRFROMP(pEntry = CreateEntry());

    if(SUCCEEDED(hr))
    {
        hr = pEntry->Initialize(pszEntryName, pszFileName, dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        if(ppEntry)
        {
            *ppEntry = pEntry;
        }
    }
    else
    {
        DELETE(pEntry);
    }

    return hr;
}


/****************************************************************************
 *
 *  GenerateBank
 *
 *  Description:
 *      Saves files to the wave bank.
 *
 *  Arguments:
 *      CWaveBankCallback * [in]: callback object.
 *      BOOL [in]: TRUE to allow overwriting the wave bank file.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::GenerateBank"

HRESULT
CWaveBank::GenerateBank
(
    CWaveBankCallback *     pCallback,
    BOOL                    fAllowOverwrite
)                                   
{                                   
    static const DWORD      dwCopyBufferSize    = 256 * 1024;
    LPVOID                  pvCopyBuffer        = NULL;
    LPVOID                  pvHeader            = NULL;
    HRESULT                 hr                  = S_OK;
    CStdFileStream          BankFile;
    LPWAVEBANKHEADER        pHeader;
    LPWAVEBANKENTRY         paMetaData;
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   dwEntryIndex;
    DWORD                   dwHeaderSize;
    DWORD                   dwOffset;
    
    DPF_ENTER();

    if(m_dwEntryCount)
    {
        //
        // Call the callback
        //

        if(pCallback)
        {
            if(!pCallback->OpenBank(this))
            {
                hr = E_ABORT;
            }
        }

        //
        // Open the bank file
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = BankFile.Open(m_szBankFile, GENERIC_READ | GENERIC_WRITE, 0, fAllowOverwrite ? CREATE_ALWAYS : CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN)))
            {
                DPF_ERROR("An error occurred while attempting to open %s", m_szBankFile);
            }
        }
        
        //
        // Allocate temporary storage
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HRFROMP(pvCopyBuffer = MEMALLOC_NOINIT(BYTE, dwCopyBufferSize))))
            {
                DPF_ERROR("Out of memory");
            }
        }

        if(SUCCEEDED(hr))
        {
            dwHeaderSize = GetBankHeaderSize();
            
            if(FAILED(hr = HRFROMP(pvHeader = MEMALLOC(BYTE, dwHeaderSize))))
            {
                DPF_ERROR("Out of memory");
            }
        }

        if(SUCCEEDED(hr))
        {
            pHeader = (LPWAVEBANKHEADER)pvHeader;
            paMetaData = (LPWAVEBANKENTRY)(pHeader + 1);
        }

        //
        // Create the file header
        //

        if(SUCCEEDED(hr))
        {
            pHeader->dwSignature = WAVEBANKHEADER_SIGNATURE;
            pHeader->dwVersion = WAVEBANKHEADER_VERSION;
            pHeader->dwFlags = m_dwFlags;
            pHeader->dwEntryCount = m_dwEntryCount;
            pHeader->dwAlignment = m_dwAlignment;
            
            _tcsncpy(pHeader->szBankName, m_szBankName, NUMELMS(pHeader->szBankName));
        }

        //
        // Generate metadata
        //

        if(SUCCEEDED(hr))
        {
            for(pleEntry = m_lstEntries.Flink, dwEntryIndex = 0, dwOffset = 0; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink, dwEntryIndex++)
            {
                ASSERT(dwEntryIndex < m_dwEntryCount);
                
                pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

                hr = pEntry->Load(TRUE);

                if(SUCCEEDED(hr))
                {
                    hr = pEntry->GetMetaData(&paMetaData[dwEntryIndex], dwHeaderSize, m_dwAlignment, &dwOffset);
                }
            }
        }

        //
        // Write the file header
        //
        
        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = BankFile.Write(pvHeader, dwHeaderSize)))
            {
                DPF_ERROR("An error occurred while attempting to write to the bank file");
            }
        }

        //
        // Write the data section
        //

        if(SUCCEEDED(hr))
        {
            for(pleEntry = m_lstEntries.Flink, dwEntryIndex = 0; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink, dwEntryIndex++)
            {
                ASSERT(dwEntryIndex < m_dwEntryCount);
                
                pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

                if(SUCCEEDED(hr))
                {
                    hr = pEntry->CommitWaveData(pCallback, &BankFile, dwHeaderSize, &paMetaData[dwEntryIndex], pvCopyBuffer, dwCopyBufferSize);
                }
            }
        }

        //
        // Call the callback
        //

        if(pCallback)
        {
            pCallback->CloseBank(this);
        }
    }
    else
    {
        DPF_ERROR("No entries added yet");
        hr = E_FAIL;
    }

    //
    // Clean up
    //

    MEMFREE(pvCopyBuffer);
    MEMFREE(pvHeader);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GenerateHeader
 *
 *  Description:
 *      Generates the C header to use with the wave bank.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::GenerateHeader"

HRESULT
CWaveBank::GenerateHeader
(
    CWaveBankCallback *     pCallback,
    BOOL                    fAllowOverwrite
)                                   
{                                   
    static const LPCTSTR    pszFileBegin            = TEXT("#pragma once\r\n\r\n");
    static const LPCTSTR    pszEnumBegin            = TEXT("typedef enum\r\n{\r\n");
    static const LPCTSTR    pszEnumEnd              = TEXT("} " WBCHEADER_ENUMNAME ";\r\n\r\n");
    static const LPCTSTR    pszEnumEntry            = TEXT("    ") WBCHEADER_ENUMENTRYNAME TEXT(" = %lu,\r\n");
    static const LPCTSTR    pszEnumCount            = TEXT("#define ") WBCHEADER_ENTRYCOUNTNAME TEXT(" %lu\r\n");
    HRESULT                 hr                      = S_OK;
    CStdFileStream          HeaderFile;
    TCHAR                   szText[MAX_PATH];
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   dwEntry;
    
    DPF_ENTER();

    if(m_dwEntryCount)
    {
        //
        // Call the callback
        //

        if(pCallback)
        {
            if(!pCallback->OpenHeader(this))
            {
                hr = E_ABORT;
            }
        }

        //
        // Open the bank file
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HeaderFile.Open(m_szHeaderFile, GENERIC_READ | GENERIC_WRITE, 0, fAllowOverwrite ? CREATE_ALWAYS : CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN)))
            {
                DPF_ERROR("An error occurred while attempting to open %s", m_szHeaderFile);
            }
        }

        //
        // Write the file header
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HeaderFile.Write(pszFileBegin, _tcslen(pszFileBegin))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Write the enumeration header
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HeaderFile.Write(pszEnumBegin, _tcslen(pszEnumBegin))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Begin the entry loop
        //

        if(SUCCEEDED(hr))
        {
            for(pleEntry = m_lstEntries.Flink, dwEntry = 0; (pleEntry != &m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, dwEntry++)
            {
                pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

                //
                // Add the entry to the enumeration
                //

                sprintf(szText, pszEnumEntry, m_szHeaderName, pEntry->m_szHeaderName, dwEntry);

                if(FAILED(hr = HeaderFile.Write(szText, _tcslen(szText))))
                {
                    DPF_ERROR("An error occurred while attempting to write to the header file");
                }
            }
        }

        //
        // End the enumeration
        //

        if(SUCCEEDED(hr))
        {
            sprintf(szText, pszEnumEnd, m_szHeaderName);

            if(FAILED(hr = HeaderFile.Write(szText, _tcslen(szText))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Add a count
        //

        if(SUCCEEDED(hr))
        {
            ASSERT(dwEntry == m_dwEntryCount);
            
            sprintf(szText, pszEnumCount, m_szHeaderName, dwEntry);

            if(FAILED(hr = HeaderFile.Write(szText, _tcslen(szText))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Call the callback
        //

        if(pCallback)
        {
            pCallback->CloseHeader(this);
        }
    }
    else
    {
        DPF_ERROR("No entries added yet");
        hr = E_FAIL;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetBankDataSize
 *
 *  Description:
 *      Calculates the size of the wave bank's data segment, in bytes.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: bank data size.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::GetBankDataSize"

DWORD
CWaveBank::GetBankDataSize
(
    void
)                                   
{                                   
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   dwHeaderSize;
    DWORD                   dwSize;
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Calculate the total size of the bank's data segment based on the
    // total size of all the entries in the bank.  We're aligning the size
    // so that it matches the aligned offsets that will appear in the bank
    // file.
    //

    dwHeaderSize = GetBankHeaderSize();

    for(pleEntry = m_lstEntries.Flink, dwSize = 0, hr = S_OK; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink)
    {
        dwSize = BLOCKALIGNPAD(dwHeaderSize + dwSize, m_dwAlignment) - dwHeaderSize;

        pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

        if(!pEntry->m_fLoaded)
        {
            hr = E_ABORT;
            break;
        }
    }

    if(FAILED(hr))
    {
        dwSize = 0;
    }

    DPF_LEAVE(dwSize);

    return dwSize;
}


/****************************************************************************
 *
 *  LoadEntries
 *
 *  Description:
 *      Loads (or reloads) entry data.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to force a reload.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::LoadEntries"

HRESULT
CWaveBank::LoadEntries
(
    BOOL                    fForce
)                                   
{                                   
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    
    DPF_ENTER();

    for(pleEntry = m_lstEntries.Flink; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink)
    {
        pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

        hr = pEntry->Load(fForce);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CWaveBankProject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::CWaveBankProject"

CWaveBankProject::CWaveBankProject
(
    void
)
{
    DPF_ENTER();

    m_dwBankCount = 0;
    m_dwEntryCount = 0;

    InitializeListHead(&m_lstBanks);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBankProject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::~CWaveBankProject"

CWaveBankProject::~CWaveBankProject
(
    void
)
{
    PLIST_ENTRY             pleBank;
    CWaveBank *             pBank;
    
    DPF_ENTER();

    //
    // Free all the entries
    //
    
    while((pleBank = m_lstBanks.Flink) != &m_lstBanks)
    {
        pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);
        
        DELETE(pBank);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AddBank
 *
 *  Description:
 *      Adds a wave bank to the project.
 *
 *  Arguments:
 *      LPCTSTR [in]: wave bank name.
 *      LPCTSTR [in]: bank file path.
 *      LPCTSTR [in]: header file path.
 *      CWaveBank ** [out]: bank object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::AddBank"

HRESULT
CWaveBankProject::AddBank
(
    LPCTSTR                 pszBankName, 
    LPCTSTR                 pszBankFile, 
    LPCTSTR                 pszHeaderFile,
    CWaveBank **            ppBank
)
{
    CWaveBank *             pBank;
    HRESULT                 hr;
    
    DPF_ENTER();

    hr = HRFROMP(pBank = CreateBank());

    if(SUCCEEDED(hr))
    {
        hr = pBank->Initialize(pszBankName, pszBankFile, pszHeaderFile);
    }

    if(SUCCEEDED(hr))
    {
        if(ppBank)
        {
            *ppBank = pBank;
        }
    }
    else
    {
        DELETE(pBank);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Generate
 *
 *  Description:
 *      Generates wave bank files.
 *
 *  Arguments:
 *      CWaveBankCallback * [in]: callback object.
 *      BOOL [in]: TRUE to allow overwriting of files.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::Generate"

HRESULT
CWaveBankProject::Generate
(
    CWaveBankCallback *     pCallback,
    BOOL                    fAllowOverwrite
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleBank;
    PLIST_ENTRY             pleEntry;
    CWaveBank *             pBank;

    DPF_ENTER();

    if(pCallback)
    {
        if(!pCallback->BeginProject(this))
        {
            hr = E_ABORT;
        }
    }

    for(pleBank = m_lstBanks.Flink; (pleBank != &m_lstBanks) && SUCCEEDED(hr); pleBank = pleBank->Flink)
    {
        pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);

        hr = pBank->GenerateBank(pCallback, fAllowOverwrite);

        if(SUCCEEDED(hr))
        {
            hr = pBank->GenerateHeader(pCallback, fAllowOverwrite);
        }
    }

    if(pCallback)
    {
        pCallback->EndProject(this, hr);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\filegen\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	filegen.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\filegen\filegen.h ===
#define DBGLVL_INFO 2
#define DBGLVL_WARN 1
#define DBGLVL_ERROR 0

//
// context for a single XACT_SOUNDBANK_TRACK_ENTRY
class CXACTTrackData {
public:
    CXACTTrackData::CXACTTrackData()
    {
        m_pEventBuffer = NULL;
		m_dwEventDataSize = 0;
		m_pTrackEntry = NULL;
		
    }

	void SetTrackEntry(PXACT_SOUNDBANK_TRACK_ENTRY pTrackEntry)
	{

		m_pTrackEntry = pTrackEntry;

	}

	CXACTTrackData::~CXACTTrackData()
	{

		if (m_pEventBuffer) {
			delete [] m_pEventBuffer;
			m_pEventBuffer = NULL;
		}

	}

	PXACT_SOUNDBANK_TRACK_ENTRY m_pTrackEntry;
	XACT_TRACK_EVENT *m_pEventBuffer;

	DWORD		m_dwEventDataSize;
	

};

class CXACTSoundData {
public:
    CXACTSoundData::CXACTSoundData()
    {
        m_pWaveBankTable = NULL;
        m_pTrackTable = NULL; 
		m_pXACTTrackTable = NULL;
        m_pSoundEntry = NULL;
        m_pSound3dData = NULL;
    }

    BOOL IsValid()
    {
        return ((m_pSoundEntry!=NULL) && (m_pSoundEntry->wWaveBankCount != 0));
    }

    int Initialize(PXACT_SOUNDBANK_SOUND_ENTRY pSoundEntry)
    {

        int err = ERROR_SUCCESS;

		//
		// the caller passes us the memory allocation for a single
		// sound entry that comes from a big contigious buffer
		//
                
        m_pSoundEntry = pSoundEntry;

        //
        // allocate cue data structures
        //

        m_pSound3dData = (PXACT_SOUNDBANK_SOUND_3D_PARAMETERS) new XACT_SOUNDBANK_SOUND_3D_PARAMETERS[1];
        if (m_pSound3dData == NULL) {
            err = ERROR_OUTOFMEMORY;
            return -1;
        }

        memset(m_pSound3dData,0,sizeof(XACT_SOUNDBANK_SOUND_3D_PARAMETERS));

        //
        // set proper initial parameters
        //

        m_pSound3dData->flMinDistance = 0.5f;
        m_pSound3dData->flMaxDistance = 1.0f;
        m_pSound3dData->flDistanceFactor = DS3D_MINDISTANCEFACTOR;
        m_pSound3dData->flDopplerFactor = DS3D_MINDOPPLERFACTOR;
        m_pSound3dData->flRolloffFactor = DS3D_MINROLLOFFFACTOR;

        return err;
    }


    CXACTSoundData::~CXACTSoundData()
    {
        if (m_pWaveBankTable) {
            delete [] m_pWaveBankTable;
            m_pWaveBankTable = NULL;
        }

        if (m_pTrackTable) {

            delete [] m_pTrackTable;
            m_pTrackTable = NULL;
        }

		if (m_pXACTTrackTable ) {
            delete [] m_pXACTTrackTable;
            m_pXACTTrackTable = NULL;
		}

        if (m_pSound3dData) {
            delete [] m_pSound3dData;
            m_pSound3dData = NULL;
        }

    }

    int GetWaveBankTableIndex(const PCHAR pszName)
    {
        for (DWORD i=0;i<m_pSoundEntry->wWaveBankCount;i++){

            if (!strcmp(m_pWaveBankTable[i].szFriendlyName,pszName)){
                return i;
            }
        }

        return -1;
    }

    PXACT_SOUNDBANK_SOUND_ENTRY m_pSoundEntry;
    PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY m_pWaveBankTable;

    CXACTTrackData *m_pTrackTable;
	PXACT_SOUNDBANK_TRACK_ENTRY m_pXACTTrackTable;

    PXACT_SOUNDBANK_SOUND_3D_PARAMETERS m_pSound3dData;

};

class CXACTFileGenerator {

protected:

    TCHAR m_szAppName[64];

    TCHAR m_szIniFileName[MAX_PATH];
    TCHAR m_szOutputFileName[MAX_PATH];

    HANDLE m_hInputFile;
    HANDLE m_hOutputFile;

	DWORD m_dwDebugLevel;	

    //
    // soundbank data
    //

    PXACT_SOUNDBANK_FILE_HEADER m_pFileHeader;
    CXACTSoundData  *m_pSoundTable;
	PXACT_SOUNDBANK_SOUND_ENTRY m_pXACTSoundTable;

    PXACT_SOUNDBANK_CUE_ENTRY m_pCueTable;
   
public:

    CXACTFileGenerator::CXACTFileGenerator(char* AppName);
    virtual CXACTFileGenerator::~CXACTFileGenerator();

	//
	// utility functions
	//
    
    int ParseCommandLine(int argc, char * argv[]);
    void UsageFailure(int err);
	int ErrorCheckOnParser(PCHAR pResult, PCHAR pDefault,DWORD dwBytesRead, DWORD dwSize);

    void PrintParsingError(PCHAR pSection, PCHAR pKey,PCHAR szFormat, ...);
	void DebugPrint(DWORD dwLevel, PCHAR pszFormat, ...);

	virtual void Print(PCHAR pFormat, ...);

	//
	// core functions
	//

	int CreateBinaryImage();

	//
	// parsing functions
	//

    int ParseIniFile();
    int ParseSoundData(DWORD dwSoundIndex);
    int ParseTrackEvents(DWORD dwSoundIndex, DWORD dwTrackIndex);

    int ParseEvent(LPSTR lpSectionName,
        DWORD dwSoundIndex,
        PXACT_TRACK_EVENT pEvent);


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\filegen\iniparser.h ===
#define SECTION_MAX_SIZE    256

//
// names for INI sections
//

//
// main section keys
//
#define SECTIONNAME_MAIN   "MAIN"
#define KEYNAME_CUE_ENTRY_COUNT   "CUE_ENTRY_COUNT"
#define KEYNAME_SOUND_ENTRY_COUNT   "SOUND_ENTRY_COUNT"

//
// cue section keys
//
#define SECTIONNAME_CUE   "CUE"
#define KEYNAME_SOUND_INDEX     "SOUND_INDEX"
#define KEYNAME_CUE_NAME        "NAME"

//
// sound section
//

#define SECTIONNAME_SOUND       "SOUND"

#define KEYNAME_SOUND_FLAG_3D   "FLAG_3D"

#define KEYNAME_SOUND_VOLUME    "VOLUME"
#define KEYNAME_SOUND_GROUP     "GROUP"
#define KEYNAME_SOUND_PRIORITY  "PRIORITY"
#define KEYNAME_SOUND_LAYER     "LAYER"
#define KEYNAME_SOUND_WAVEBANK_COUNT    "WAVEBANK_COUNT"
#define KEYNAME_SOUND_TRACK_COUNT   "TRACK_COUNT"
//
// WAVEBANK TABLE SECTION
//

#define SECTIONNAME_WAVEBANK_TABLE "WAVEBANK_TABLE"
#define KEYNAME_WAVEBANK_TABLE_WAVEBANK_NAME "WAVEBANK"

//
// TRACK SECTION
//

#define SECTIONNAME_TRACK   "TRACK"
#define KEYNAME_TRACK_EVENT_COUNT   "EVENT_COUNT"

//
// EVENT SECTION
//

//
// EVENT NAMES
//

#define NUM_EVENT_TYPES    15  

#define EVENTNAME_PLAY                      "PLAY"
#define EVENTNAME_STOP                      "STOP"
#define EVENTNAME_SETFREQUENCY              "SETFREQUENCY"
#define EVENTNAME_SETVOLUME                 "SETVOLUME"
#define EVENTNAME_SETHEADROOM               "SETHEADROOM"
#define EVENTNAME_SETLFO                    "SETLFO"
#define EVENTNAME_SETEG                     "SETEG"
#define EVENTNAME_SETEFFECTDATA             "SETEFFECTDATA"
#define EVENTNAME_SETFILTER                 "SETFILTER"
#define EVENTNAME_LOOPSTART                 "LOOPSTART"
#define EVENTNAME_LOOPEND                   "LOOPEND"
#define EVENTNAME_SETMIXBINVOLUMES          "SETVOLUME"
#define EVENTNAME_MARKER                    "MARKER"
#define EVENTNAME_PLAYWITHPITCHANDVOLUME    "PLAYWITHPITCHANDVOLUME"
#define EVENTNAME_PITCHANDVOLUMEVARIATION   "PITCHANDVOLUMEVARIATION"



#define SECTIONNAME_TRACK_EVENT     "EVENT"
#define KEYNAME_EVENT_TYPE          "TYPE"
#define KEYNAME_EVENT_TIMESTAMP     "TIMESTAMP"
#define KEYNAME_EVENT_WAVEBANK_NAME "WAVEBANK"
#define KEYNAME_EVENT_WAVE_INDEX    "WAVE_INDEX"
#define KEYNAME_EVENT_VALUE         "VALUE"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\filegen\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__493D38A4_A792_4EBB_AFF2_A2195BB64EEC__INCLUDED_)
#define AFX_STDAFX_H__493D38A4_A792_4EBB_AFF2_A2195BB64EEC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

#include <xtl.h>
#include <xactp.h>
#include <xboxverp.h>
#include <xboxdbg.h>
#include <dsfxparm.h>

#include "filegen.h"
#include "iniparser.h"
#include <stdlib.h>

EXTERN_C
WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    );

EXTERN_C 
WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileInt  GetPrivateProfileIntW
#else
#define GetPrivateProfileInt  GetPrivateProfileIntA
#endif // !UNICODE

EXTERN_C 
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );

EXTERN_C 
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSection  GetPrivateProfileSectionW
#else
#define GetPrivateProfileSection  GetPrivateProfileSectionA
#endif // !UNICODE

EXTERN_C 
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );

EXTERN_C 
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileString  GetPrivateProfileStringW
#else
#define GetPrivateProfileString  GetPrivateProfileStringA
#endif // !UNICODE

EXTERN_C
WINBASEAPI
DWORD
WINAPI
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

EXTERN_C
WINBASEAPI
DWORD
WINAPI
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
#ifdef UNICODE
#define GetFullPathName  GetFullPathNameW
#else
#define GetFullPathName  GetFullPathNameA
#endif // !UNICODE


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__493D38A4_A792_4EBB_AFF2_A2195BB64EEC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\sources.inc ===
#
# Common sources file for all XACT GUI components
#
# Be sure to include xacthost.inc before this file
#

XACTGUIBASEDIR = $(XACTHOSTBASEDIR)\gui

C_DEFINES = -DDPF_LIBRARY=\"XACTGUI\"

INCLUDES =\
    $(INCLUDES);\
    $(XACTGUIBASEDIR)\base;\
    $(XACTGUIBASEDIR)\controls;\
    $(XACTHOSTBASEDIR)\wavbndlr\common
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\filegen\parse.cpp ===
// parse.cpp : parsing functions
//

#include "stdafx.h"


//
// NOTE: the order of the names below MUST match the
// XACT_TRACK_EVENT_TYPES enum in xactp.h
//

char *g_aszEventNames[NUM_EVENT_TYPES] = {

        "PLAY",
        "PLAYWITHPITCHANDAVOLUME",
        "STOP",
        "PITCHANDAVOLUMEVARIATION",
        "SETFREQUENCY",
        "SETVOLUME",
        "SETHEADROOM",
        "SETLFO",
        "SETEG",
        "SETFILTER",
        "MARKER",
        "LOOPSTART",
        "LOOPEND",
        "SETMIXBINVOLUMES",
        "SETEFFECTDATA"        

};

void
CXACTFileGenerator::Print(
                        IN PCHAR    pFormat,
                        IN ...
                        )
/*++

Routine Description:

    Virtual print method. Defaults to stderr

Arguments:

    IN pFormat -    Format string
    IN ... -        Additional arguments

Return Value:

    None

--*/
{
    CHAR    szString[0x400];
    va_list va;

    va_start(va, pFormat);
    vsprintf(szString, pFormat, va);
    va_end(va);

    fprintf(stderr, szString);
}

void CXACTFileGenerator::UsageFailure(int err)
{
    if (err != ERROR_SUCCESS) {
        Print("\n Error: 0x%x\n", err);
    }

    Print("\n Usage: %s [Soundbank description INI filename] [output soundbank filename]\n",
          m_szAppName);

}

void CXACTFileGenerator::DebugPrint(DWORD dwLevel, PCHAR pszFormat, ...)
{
    CHAR                    szString[0x400];
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szString, pszFormat, va);
    va_end(va);
    
    if (m_dwDebugLevel >= dwLevel) {
        
        Print("*** %s ***\n", szString);
    }

}

int CXACTFileGenerator::ErrorCheckOnParser(PCHAR pResult, PCHAR pDefault,DWORD dwBytesRead, DWORD dwSize)
{

    if (dwBytesRead == dwSize-1) {
        
        
        DebugPrint(DBGLVL_INFO,"Parsing error, GetProfile function thought our buffer is too small!!");
        return -1;
        
    }
    
    if (dwBytesRead == dwSize-2) {        
        
        DebugPrint(DBGLVL_INFO,"Parsing error, GetProfile function thought our buffer is too small!!");
        return -1;
        
    }

    if (dwBytesRead == 0) {

        DebugPrint(DBGLVL_INFO,"Parsing error, GetProfile function returned 0 bytes");
        return -1;

    }

    if (!strcmp(pResult,pDefault)) {


        return -1;

    }


    return ERROR_SUCCESS;

}

void CXACTFileGenerator::PrintParsingError(PCHAR pSection, PCHAR pKey, PCHAR pszFormat, ...)
{
    CHAR                    szString[0x400];
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szString, pszFormat, va);
    va_end(va);
    
    Print("*** ParsingInputFile : SectionName %s, KeyName %s.\n"\
                   "    %s\n",
                   pSection,pKey,szString);

}

int CXACTFileGenerator::ParseCommandLine(int argc, char **argv)
{

    int err = ERROR_SUCCESS;

    if (argc < 2) {

        err = -1;
        UsageFailure(err);
        return err;
    }

    if (strstr("?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
        err = -1;
        return err;
    }

    if (strstr("/?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
        err = -1;
        return err;
    }

    if (strstr("-?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
        err = -1;
        return err;
    }

    //
    // create full path name for main INI
    //

    LPTSTR pBuffer;

    if (GetFullPathName(argv[1],
        sizeof(m_szIniFileName),
        m_szIniFileName,        
        &pBuffer)== 0){


        err = GetLastError();
        Print("\n Failed to find the description INI file.Error 0x%x\n", err);
        return err;

    }

    printf("\nInput File to parse: %s\n", m_szIniFileName);
    
    memcpy(m_szOutputFileName,argv[2],sizeof(m_szOutputFileName));
    printf("Output File: %s\n\n", m_szOutputFileName);
    
    m_hInputFile = CreateFile(
        (const char *)m_szIniFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_ALWAYS,
        0,
        NULL);

    if (m_hInputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        Print("\n Failed to open the Ini description file.Error 0x%x\n", err);
        return err;

    }

    //
    // we dont need the input file anymore
    //

    CloseHandle(m_hInputFile);
    m_hInputFile = INVALID_HANDLE_VALUE;

    return ERROR_SUCCESS;

}


// ****************************************************************************
// parsing
// ****************************************************************************

int CXACTFileGenerator::ParseIniFile()
{

    int err = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwValue = 0;
    DWORD i=0;

    LPCTSTR lpDefault = "DefaultString";
    LPSTR lpSectionName = NULL;
    LPSTR lpKeyName = NULL;
    PCHAR lpResult  = NULL;    

    lpResult = new CHAR[SECTION_MAX_SIZE];
    if (lpResult == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpSectionName = new CHAR[SECTION_MAX_SIZE];
    if (lpSectionName == NULL) {
        
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpKeyName = new CHAR[SECTION_MAX_SIZE];
    if (lpKeyName == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    sprintf(lpSectionName,"%s",SECTIONNAME_MAIN);       

    //
    // see if the main section exists
    //
    
    dwBytesRead = GetPrivateProfileSection(lpSectionName,
        lpResult,
        SECTION_MAX_SIZE,
        (const char*)m_szIniFileName);
    
    if (!dwBytesRead) {
        
        PrintParsingError(lpSectionName,
            NULL,
            "FATAL: main section not found!");              
        
        goto errorExit;
        
    }

    //
    // allocate file header
    //

    m_pFileHeader = (PXACT_SOUNDBANK_FILE_HEADER) new XACT_SOUNDBANK_FILE_HEADER[1];
    if (m_pFileHeader == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    memset(m_pFileHeader,0,sizeof(XACT_SOUNDBANK_FILE_HEADER));

    // **************************************************
    // read number of CUEs
    // **************************************************

    sprintf(lpSectionName,"%s",SECTIONNAME_MAIN);       
    sprintf(lpKeyName,"%s",KEYNAME_CUE_ENTRY_COUNT);

    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;

    }
    
    m_pFileHeader->dwCueEntryCount = dwValue;

    //
    // now that we know how many CUEs we have, allocate an array
    // of cue context data
    //

    m_pCueTable = new XACT_SOUNDBANK_CUE_ENTRY[m_pFileHeader->dwCueEntryCount];
    if (m_pCueTable == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    memset(m_pCueTable,0,sizeof(XACT_SOUNDBANK_CUE_ENTRY)*m_pFileHeader->dwCueEntryCount);

    // **************************************************
    // read number of sounds
    // **************************************************

    sprintf(lpSectionName,"%s",SECTIONNAME_MAIN);       
    sprintf(lpKeyName,"%s",KEYNAME_SOUND_ENTRY_COUNT);

    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;

    }
    
    m_pFileHeader->dwSoundEntryCount = dwValue;

    m_pSoundTable = new CXACTSoundData[m_pFileHeader->dwSoundEntryCount];
    if (m_pSoundTable == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }   

	//
	// allocate contigious buffer for XACT sound entries. we do this
	// to optimize the binary file generation
	//

    m_pXACTSoundTable = new XACT_SOUNDBANK_SOUND_ENTRY[m_pFileHeader->dwSoundEntryCount];
    if (m_pXACTSoundTable == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }   

	memset(m_pXACTSoundTable,0,sizeof(XACT_SOUNDBANK_SOUND_ENTRY)*m_pFileHeader->dwSoundEntryCount);

    //
    // parse data associated with each cue
    //

    for (i=0;i<m_pFileHeader->dwCueEntryCount;i++) {

        // **************************************************
        // get sound index associated with cue
        // **************************************************

        sprintf(lpSectionName,"%s%d",SECTIONNAME_CUE,i);       
        sprintf(lpKeyName,"%s",KEYNAME_SOUND_INDEX);
        
        dwValue = GetPrivateProfileInt(lpSectionName,
            lpKeyName,
            -1,
            (const char*)m_szIniFileName);  
        
        if (dwValue == -1) {
            
            PrintParsingError(lpSectionName,
                lpKeyName,
                "ERROR: Key not found.");             
            err = -1;
            goto errorExit;
            
        }

        m_pCueTable[i].dwSoundIndex = dwValue;

        // **************************************************
        // read a friendlyname for the cue
        // **************************************************
        
        sprintf(lpSectionName,"%s%d",SECTIONNAME_CUE,i);       
        sprintf(lpKeyName,"%s",KEYNAME_CUE_NAME);
        dwBytesRead = GetPrivateProfileString(lpSectionName,
            lpKeyName,
            lpDefault,
            m_pCueTable[i].szFriendlyName,
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH,
            (const char*)m_szIniFileName);
        
        if (ErrorCheckOnParser(m_pCueTable[i].szFriendlyName,
            (char*)lpDefault,
            dwBytesRead,
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH)) {
            
            PrintParsingError(lpSectionName,
                lpKeyName,
                "WARNING: Key not found.");             
            
            sprintf(m_pCueTable[i].szFriendlyName,"DEFAULT");
            
        }

        //
        // parse information associated with sound entry used by this cue
        // only parse sounds not already referenced and parsed by other cues
        //

        if (!m_pSoundTable[m_pCueTable[i].dwSoundIndex].IsValid()) {

            err = ParseSoundData(m_pCueTable[i].dwSoundIndex);
            if (err != ERROR_SUCCESS) {

                goto errorExit;
            }

        }


    }

errorExit:
    if (lpSectionName)
        delete [] lpSectionName;

    if (lpKeyName)
        delete [] lpKeyName;

    if (lpResult)
        delete [] lpResult;


    return err;

}


int CXACTFileGenerator::ParseSoundData(DWORD dwSoundIndex)
{

    int err = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwValue = 0;
    DWORD i=0;

    CHAR szName[64];
    LPCTSTR lpDefault = "DefaultString";
    LPSTR lpSectionName = NULL;
    LPSTR lpKeyName = NULL;
    PCHAR lpResult = NULL;    

    lpResult = new CHAR[SECTION_MAX_SIZE];
    if (lpResult == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpSectionName = new CHAR[SECTION_MAX_SIZE];
    if (lpSectionName == NULL) {
        
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpKeyName = new CHAR[SECTION_MAX_SIZE];
    if (lpKeyName == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    sprintf(lpSectionName,"%s%d",SECTIONNAME_SOUND, dwSoundIndex);       

    //
    // see if sound section exists
    //
    
    dwBytesRead = GetPrivateProfileSection(lpSectionName,
        lpResult,
        SECTION_MAX_SIZE,
        (const char*)m_szIniFileName);
    
    if (!dwBytesRead) {
        
        PrintParsingError(lpSectionName,
            NULL,
            "FATAL: sound section not found!");              
        
        return -1;
        
    }

    if (m_pSoundTable[dwSoundIndex].Initialize(&m_pXACTSoundTable[dwSoundIndex]) != ERROR_SUCCESS){
        goto errorExit;
    }

    // **************************************************
    // get sound slot 
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_SOUND_LAYER);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;
        
    }
    
    m_pSoundTable[dwSoundIndex].m_pSoundEntry->wLayer = (WORD)dwValue;

    // **************************************************
    // get sound group
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_SOUND_GROUP);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;
        
    }
    
    m_pSoundTable[dwSoundIndex].m_pSoundEntry->wGroupNumber = (WORD)dwValue;

    // **************************************************
    // get wavebank count
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_SOUND_WAVEBANK_COUNT);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;
        
    }
    
    m_pSoundTable[dwSoundIndex].m_pSoundEntry->wWaveBankCount = (WORD)dwValue;

    // **************************************************
    // get track count
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_SOUND_TRACK_COUNT);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;
        
    }
        
    m_pSoundTable[dwSoundIndex].m_pSoundEntry->wTrackCount = (WORD)dwValue;
            
    // **************************************************
    // parse sound flags (keys are optional)
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_SOUND_FLAG_3D);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue != -1) {
        
        m_pSoundTable[dwSoundIndex].m_pSoundEntry->dwFlags |= XACT_FLAG_SOUND_3D;

        //
        // this sounds uses 3d properties.
        // a zero initialized 3d property object will be associated for now
        //


        
    }

    //
    // allocate wavebank table
    //

    m_pSoundTable[dwSoundIndex].m_pWaveBankTable = (PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY) new XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY[m_pSoundTable[dwSoundIndex].m_pSoundEntry->wWaveBankCount];
    if (!m_pSoundTable[dwSoundIndex].m_pWaveBankTable) {

        err = ERROR_OUTOFMEMORY;
        goto errorExit;

    }

    memset(m_pSoundTable[dwSoundIndex].m_pWaveBankTable,0,sizeof(XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY)*m_pSoundTable[dwSoundIndex].m_pSoundEntry->wWaveBankCount);

    //
    // retrieve wavebank table information for the sound
    //

    for (i=0;i<m_pSoundTable[dwSoundIndex].m_pSoundEntry->wWaveBankCount;i++) {
        
        sprintf(lpSectionName,"%s%d_%s",SECTIONNAME_SOUND,dwSoundIndex,SECTIONNAME_WAVEBANK_TABLE);       
        sprintf(lpKeyName,"%s%d",KEYNAME_WAVEBANK_TABLE_WAVEBANK_NAME,i);

        dwBytesRead = GetPrivateProfileString(lpSectionName,
            lpKeyName,
            lpDefault,
            szName,
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH,
            (const char*)m_szIniFileName);
        
        if (ErrorCheckOnParser(szName,
            (char*)lpDefault,
            dwBytesRead,
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH)) {
            
            PrintParsingError(lpSectionName,
                lpKeyName,
                "ERROR: Key not found.");             
            
            err = -1;
            goto errorExit;
            
        }

        strcpy(m_pSoundTable[dwSoundIndex].m_pWaveBankTable[i].szFriendlyName,szName);        
        
    }

    //
    // retrieve track information
    //

    //
    // allocate track table
    //

    m_pSoundTable[dwSoundIndex].m_pTrackTable = new CXACTTrackData[m_pSoundTable[dwSoundIndex].m_pSoundEntry->wTrackCount];
    if (!m_pSoundTable[dwSoundIndex].m_pTrackTable) {

        err = ERROR_OUTOFMEMORY;
        goto errorExit;

    }

    m_pSoundTable[dwSoundIndex].m_pXACTTrackTable = new XACT_SOUNDBANK_TRACK_ENTRY[m_pSoundTable[dwSoundIndex].m_pSoundEntry->wTrackCount];
    if (!m_pSoundTable[dwSoundIndex].m_pXACTTrackTable) {

        err = ERROR_OUTOFMEMORY;
        goto errorExit;

    }

    memset(m_pSoundTable[dwSoundIndex].m_pXACTTrackTable,0,sizeof(XACT_SOUNDBANK_TRACK_ENTRY)*m_pSoundTable[dwSoundIndex].m_pSoundEntry->wTrackCount);


    //
    // retrieve track entry information for the sound
    //

    for (i=0;i<m_pSoundTable[dwSoundIndex].m_pSoundEntry->wTrackCount;i++) {
        
        sprintf(lpSectionName,"%s%d_%s%d",SECTIONNAME_SOUND,dwSoundIndex,SECTIONNAME_TRACK,i);       
        sprintf(lpKeyName,"%s",KEYNAME_TRACK_EVENT_COUNT);

        dwValue = GetPrivateProfileInt(lpSectionName,
            lpKeyName,
            -1,
            (const char*)m_szIniFileName);  
        
        if (dwValue == -1) {

            PrintParsingError(lpSectionName,
                lpKeyName,
                "ERROR: Key not found.");             
            err = -1;
            goto errorExit;

        }

		m_pSoundTable[dwSoundIndex].m_pTrackTable[i].SetTrackEntry(&m_pSoundTable[dwSoundIndex].m_pXACTTrackTable[i]);

        m_pSoundTable[dwSoundIndex].m_pTrackTable[i].m_pTrackEntry->wEventEntryCount = (WORD)dwValue;        

        err = ParseTrackEvents(dwSoundIndex, i);
        if (err != ERROR_SUCCESS) {

            goto errorExit;

        }
        
    }




errorExit:
    if (lpSectionName)
        delete [] lpSectionName;

    if (lpKeyName)
        delete [] lpKeyName;

    if (lpResult)
        delete [] lpResult;


    return err;

}

int CXACTFileGenerator::ParseTrackEvents(DWORD dwSoundIndex, DWORD dwTrackIndex)
{

    int err = ERROR_SUCCESS;
    DWORD dwValue = 0;
    DWORD i=0;

    LPCTSTR lpDefault = "DefaultString";
    LPSTR lpSectionName;


    CXACTTrackData *pTrackEntry = &m_pSoundTable[dwSoundIndex].m_pTrackTable[dwTrackIndex]; 
    PXACT_TRACK_EVENT pEventTable, pEvent;

    lpSectionName = new CHAR[SECTION_MAX_SIZE];
    if (lpSectionName == NULL) {
        
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    //
    // allocate a worst case array large enough to hold all track events
    //

    dwValue = sizeof(XACT_TRACK_EVENT)*pTrackEntry->m_pTrackEntry->wEventEntryCount;
    pEventTable = (PXACT_TRACK_EVENT) new BYTE[dwValue];

    if (pEventTable == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    memset(pEventTable,0,dwValue);

	//
	// store event table pointer in track entry
	//

	pTrackEntry->m_pEventBuffer = pEventTable;

    //
    // read all events, one at a time
    //

	pEvent = &pEventTable[0];
    for (i=0;i<pTrackEntry->m_pTrackEntry->wEventEntryCount;i++)
    {

        sprintf(lpSectionName,"%s%d_%s%d_%s%d",SECTIONNAME_SOUND,dwSoundIndex,
            SECTIONNAME_TRACK, dwTrackIndex,
            SECTIONNAME_TRACK_EVENT,i);

        //
        // parse indivdual event entries        
        //

        err = ParseEvent(lpSectionName, dwSoundIndex, pEvent);
        if (err != ERROR_SUCCESS) {
            goto errorExit;
        }

        //
        // add event size to total data size
        //

		pTrackEntry->m_dwEventDataSize += (pEvent->Header.wSize+sizeof(XACT_TRACK_EVENT_HEADER));

		pEvent = (PXACT_TRACK_EVENT) ((PUCHAR)&pEventTable[0] + pTrackEntry->m_dwEventDataSize);

    }
   
errorExit:
    if (lpSectionName)
        delete [] lpSectionName;

    return err;
}
    

int CXACTFileGenerator::ParseEvent(LPSTR lpSectionName,
                                   DWORD dwSoundIndex,
                                   PXACT_TRACK_EVENT pEvent)
{

    DWORD dwValue = 0;
    DWORD dwBytesRead;

    BOOL bGetWaveData = FALSE;
    int err = ERROR_SUCCESS;

    PCHAR lpResult = NULL;    
    LPCTSTR lpDefault = "DefaultString";
    LPSTR lpKeyName = NULL;
    CHAR szName[64];

    lpResult = new CHAR[SECTION_MAX_SIZE];
    if (lpResult == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpKeyName = new CHAR[SECTION_MAX_SIZE];
    if (lpKeyName == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    //
    // some effects just have a single generic value associated
    // with them. read this here
    //

    // **************************************************
    // event type 
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_EVENT_TYPE);

    dwValue = -1;
    dwBytesRead = GetPrivateProfileString(lpSectionName,
        lpKeyName,
        lpDefault,
        szName,
        XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH,
        (const char*)m_szIniFileName);
    
    if (ERROR_SUCCESS == ErrorCheckOnParser(szName,
        (char*)lpDefault,
        dwBytesRead,
        XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH)) {

        for (DWORD i=0;i<NUM_EVENT_TYPES;i++)
        {

            if (!strcmp(g_aszEventNames[i],szName)){

                //
                // found a supported event type
                //

                dwValue = i;
                break;
            }

        }


    } 
    
    if (dwValue == -1){

        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found or event type not supported.");             
        err = -1;
        goto errorExit;
        
    }
    
    pEvent->Header.wType = (WORD)dwValue;

    // **************************************************
    // event timestamp
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_EVENT_TIMESTAMP);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Key not found.");             
        err = -1;
        goto errorExit;
        
    }
    
    pEvent->Header.lSampleTime = dwValue;

    // **************************************************
    // Data Value
    // **************************************************
    
    sprintf(lpKeyName,"%s",KEYNAME_EVENT_VALUE);
    
    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szIniFileName);  

    if(NUM_EVENT_TYPES != eXACTEvent_Max) {
        Print("Executable and xact.h header do not match");
        err = -1;
        goto errorExit;
    }
    
    if (dwValue == -1)
        dwValue = 0;

    sprintf(lpKeyName,"%s",KEYNAME_EVENT_TYPE);

    switch (pEvent->Header.wType) {
    case eXACTEvent_PlayWithPitchAndVolumeVariation:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR);
        bGetWaveData = TRUE;
        break;
    case eXACTEvent_Play:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_PLAY);
        bGetWaveData = TRUE;
        break;
    case eXACTEvent_Stop:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_STOP);
        break;
    case eXACTEvent_SetFrequency:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETFREQUENCY);
        pEvent->EventData.SetFrequency.wFrequency = (WORD)dwValue;
        break;
    case eXACTEvent_SetVolume:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETVOLUME);
        pEvent->EventData.SetVolume.sVolume = (SHORT)dwValue;
        break;
    case eXACTEvent_SetHeadroom:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETHEADROOM);
        pEvent->EventData.SetHeadroom.wHeadroom = (WORD)dwValue;
        break;
    case eXACTEvent_SetLFO:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETLFO);
        pEvent->EventData.SetLFO.Desc.dwLFO = DSLFO_PITCH;
        pEvent->EventData.SetLFO.Desc.dwDelay = 10;
        pEvent->EventData.SetLFO.Desc.dwDelta = dwValue;
        pEvent->EventData.SetLFO.Desc.lPitchModulation = 0x1f;
        break;
    case eXACTEvent_SetEG:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETEG);
        pEvent->EventData.SetEG.Desc.dwEG = DSEG_AMPLITUDE;
        pEvent->EventData.SetEG.Desc.dwMode = DSEG_MODE_DELAY;
        pEvent->EventData.SetEG.Desc.dwDelay = 1;
        pEvent->EventData.SetEG.Desc.dwAttack = 100;
        pEvent->EventData.SetEG.Desc.dwHold = 0xa00;
        pEvent->EventData.SetEG.Desc.dwDecay = 100;
        pEvent->EventData.SetEG.Desc.dwSustain = 200;
        pEvent->EventData.SetEG.Desc.dwRelease = 1;
        break;
    case eXACTEvent_SetFilter:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETFILTER);
        pEvent->EventData.SetFilter.Desc.dwMode = DSFILTER_MODE_PARAMEQ;
        pEvent->EventData.SetFilter.Desc.dwQCoefficient = DSFILTER_MODE_PARAMEQ;

        //
        // set the filter for Fc=701Hz, Gain = 20dB, Q = 1
        //

        pEvent->EventData.SetFilter.Desc.adwCoefficients[0] = 0xbe1d;
        pEvent->EventData.SetFilter.Desc.adwCoefficients[1] = 0x8000;
        pEvent->EventData.SetFilter.Desc.adwCoefficients[2] = 0xc8dc;
        pEvent->EventData.SetFilter.Desc.adwCoefficients[3] = 0x1fff;
        break;
    case eXACTEvent_LoopStart:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_LOOPSTART);
        pEvent->EventData.LoopStart.wLoopCount = (WORD)dwValue;
        break;

    case eXACTEvent_LoopEnd:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_LOOPEND);
        break;

    case eXACTEvent_SetMixBinVolumes:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETMIXBINVOLUMES);
        break;

    case eXACTEvent_SetEffectData:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETEFFECTDATA);
        
        //
        // assume one dword of data
        //
        
        pEvent->Header.wSize += sizeof(DWORD);

        //
        // safest thing to do is assume a mono effect then setting its
        // delay line to a small value
        //

        pEvent->EventData.SetEffectData.wEffectIndex = 3;
        pEvent->EventData.SetEffectData.wOffset = sizeof(DWORD); //dwScratchSize
        pEvent->EventData.SetEffectData.wDataSize = sizeof(DWORD);
        pEvent->EventData.SetEffectData.dwData[1] = dwValue;

        break;        
        
    default:
        PrintParsingError(lpSectionName,
            lpKeyName,
            "ERROR: Invalid event type specified");             
        err = -1;
        goto errorExit;
        break;
    }

    if (bGetWaveData) {
        
        // **************************************************
        // wavebank index
        // **************************************************
        
        sprintf(lpKeyName,"%s",KEYNAME_WAVEBANK_TABLE_WAVEBANK_NAME);
        
        dwBytesRead = GetPrivateProfileString(lpSectionName,
            lpKeyName,
            lpDefault,
            szName,
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH,
            (const char*)m_szIniFileName);
        
        if (!ErrorCheckOnParser(szName,
            (char*)lpDefault,
            dwBytesRead,
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH)) {
            
            //
            // get wavebank index
            //
            
            dwValue = m_pSoundTable[dwSoundIndex].GetWaveBankTableIndex(szName);
            if (dwValue != -1){
                pEvent->EventData.Play.PlayDesc.WaveSource.wWaveIndex = (USHORT)dwValue;
            } else {
                PrintParsingError(lpSectionName,
                    lpKeyName,
                    "ERROR: Wavebank (%s) referenced not found in sound wavebank table",
                    szName);
                
                err = -1;
                goto errorExit;
            }
            
        }
        
        // **************************************************
        // wave index
        // **************************************************
        
        sprintf(lpKeyName,"%s",KEYNAME_EVENT_WAVE_INDEX);
        
        dwValue = GetPrivateProfileInt(lpSectionName,
            lpKeyName,
            -1,
            (const char*)m_szIniFileName);  
        
        if (dwValue != -1) {
            
            pEvent->EventData.Play.PlayDesc.WaveSource.wWaveIndex = (USHORT) dwValue;
            
        }
        
    }

errorExit:

    if (lpResult)
        delete [] lpResult;

    if (lpKeyName)
        delete [] lpKeyName;

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\dlgwrap.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/20/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dlgwrap.h
 *  Content:    Dialog wrapper classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/20/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __DLGWRAP_H__
#define __DLGWRAP_H__

#ifdef __cplusplus

//
// Dialog base class
//

class CDialog
    : public CWindow
{
public:
    enum
    {
        WNDTYPE = WNDTYPE_DIALOG
    };

    const UINT              m_nDialogResourceId;

public:
    CDialog(UINT nDialogResourceId);
    virtual ~CDialog(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(CWindow *pParent, LPVOID pvParam = NULL);
    virtual BOOL DoModal(CWindow *pParent, LPVOID pvParam = NULL);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult);
    virtual BOOL OnClose(LRESULT *plResult);

    // Command handlers
    virtual void OnCmdOK(void);
    virtual void OnCmdCancel(void);

    // Default handler
    virtual LRESULT DefWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    // Main window procedure
    static int CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // The first and final message handlers
    static CWindow *OnInitialCreate(HWND hWnd, LPARAM *plParam);
};

__inline ULONG CDialog::AddRef(void)
{
    return 1;
}

__inline ULONG CDialog::Release(void)
{
    return 1;
}

__inline LRESULT CDialog::DefWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

#endif // __cplusplus

#endif // __DLGWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\mdiwrap.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mdiwrap.h
 *  Content:    Windows wrapper classes (aka My Mini MFC)
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __MDIWRAP_H__
#define __MDIWRAP_H__

#ifdef __cplusplus

//
// Forward declarations
//

class CMDIFrameWindow;
class CMDIClientWindow;
class CMDIChildWindow;

//
// MDI frame window wrapper class
//

class CMDIFrameWindow
    : public CWindow
{
    friend class CMDIClientWindow;

public:
    enum
    {
        WNDTYPE = WNDTYPE_MDIFRAME
    };

protected:
    CMDIClientWindow *      m_pMDIClient;       // MDI client window

public:
    CMDIFrameWindow(UINT nMenuId = 0, UINT nAccelId = 0);
    virtual ~CMDIFrameWindow(void);

protected:
    // Creation (protected to force subclassing of the CWindow type)
    virtual BOOL Create(LPCTSTR pszClassName, LPCTSTR pszWindowName, DWORD dwExStyle, DWORD dwStyle, int x, int y, int nWidth, int nHeight, LPVOID pvParam = NULL);

    // Default handler
    virtual LRESULT DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

//
// MDI client window wrapper class
//

class CMDIClientWindow
    : public CWindow
{
    friend class CMDIFrameWindow;
    friend class CMDIChildWindow;

public:
    enum
    {
        WNDTYPE = WNDTYPE_MDICLIENT
    };

public:
    CMDIClientWindow(void);
    virtual ~CMDIClientWindow(void);

public:
    // Child windows
    virtual BOOL GetActiveChild(CMDIChildWindow **ppWindow = NULL, LPBOOL pfMaximized = NULL);
    virtual BOOL IsActiveChild(CMDIChildWindow *pWindow);

protected:
    // Creation (protected to force subclassing of the CWindow type)
    virtual BOOL Create(CMDIFrameWindow *pParent, DWORD dwExStyle, DWORD dwStyle, int x, int y, int nWidth, int nHeight, UINT nControlId, const CLIENTCREATESTRUCT *pccs);

    // Message dispatching
    virtual BOOL DispatchMessage(LPMSG pMsg);
};

//
// MDI child window wrapper class
//

class CMDIChildWindow
    : public CWindow
{
public:
    enum
    {
        WNDTYPE = WNDTYPE_MDICHILD
    };

public:
    CMDIChildWindow(void);
    virtual ~CMDIChildWindow(void);

protected:
    // Creation (protected to force subclassing of the CWindow type)
    virtual BOOL Create(CMDIClientWindow *pParent, LPCTSTR pszClassName, LPCTSTR pszWindowName, DWORD dwExStyle, DWORD dwStyle, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT, int nWidth = CW_USEDEFAULT, int nHeight = CW_USEDEFAULT, LPVOID pvParam = NULL);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnStyleChanged(UINT nType, LPSTYLESTRUCT pStyle, LRESULT *plResult);
    virtual BOOL OnForceResize(LRESULT *plResult);
    virtual BOOL OnMdiActivate(HWND hWndInactive, HWND hWndActive, LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);

    // Event handlers
    virtual void OnActivate(void);
    virtual void OnDeactivate(void);

    // Default handler
    virtual LRESULT DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

__inline void CMDIChildWindow::OnActivate(void)
{
}

__inline void CMDIChildWindow::OnDeactivate(void)
{
}

#endif // __cplusplus

#endif // __MDIWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\mdiwrap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mdiwrap.cpp
 *  Content:    Windows wrapper classes (aka My Mini MFC)
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#include "xactgui.h"


/****************************************************************************
 *
 *  CMDIFrameWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      UINT [in]: menu resource identifier, or 0.
 *      UINT [in]: accelerator resource identifier, or 0.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIFrameWindow::CMDIFrameWindow"

CMDIFrameWindow::CMDIFrameWindow
(
    UINT                    nMenuId,
    UINT                    nAccelId
)
:   CWindow(nMenuId, nAccelId, WNDTYPE)
{
}


/****************************************************************************
 *
 *  ~CMDIFrameWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIFrameWindow::~CMDIFrameWindow"

CMDIFrameWindow::~CMDIFrameWindow
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      LPCTSTR [in]: window class name.
 *      LPCTSTR [in]: window title.
 *      DWORD [in]: window extended style.
 *      DWORD [in]: window basic style.
 *      int [in]: window x-coordinate.
 *      int [in]: window y-coordinate.
 *      int [in]: window width.
 *      int [in]: window height.
 *      LPVOID [in]: creation context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIFrameWindow::Create"

BOOL
CMDIFrameWindow::Create
(
    LPCTSTR                 pszClassName, 
    LPCTSTR                 pszWindowName, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight, 
    LPVOID                  pvParam
)
{
    return CWindow::Create(NULL, pszClassName, pszWindowName, dwExStyle, dwStyle, x, y, nWidth, nHeight, 0, pvParam);
}


/****************************************************************************
 *
 *  DefWindowProc
 *
 *  Description:
 *      Default message handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter.
 *      LPARAM [in]: message parameter.
 *
 *  Returns:  
 *      LRESULT: message result.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMDIFrameWindow::DefWindowProc"

LRESULT
CMDIFrameWindow::DefWindowProc
(
    HWND                    hWnd, 
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam
)
{
    switch(uMsg)
    {
        case WM_SIZE:
            return ::DefWindowProc(hWnd, uMsg, wParam, lParam);

        default:
            return ::DefFrameProc(hWnd, GetHWND(m_pMDIClient), uMsg, wParam, lParam);
    }
}


/****************************************************************************
 *
 *  CMDIClientWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIClientWindow::CMDIClientWindow"

CMDIClientWindow::CMDIClientWindow
(
    void
)
:   CWindow(-1, -1, WNDTYPE)
{
}


/****************************************************************************
 *
 *  ~CMDIClientWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIClientWindow::~CMDIClientWindow"

CMDIClientWindow::~CMDIClientWindow
(
    void
)
{
    CMDIFrameWindow *           pParent = CWindowCast<CMDIFrameWindow>::Cast(m_pParent);

    if(pParent)
    {
        pParent->m_pMDIClient = NULL;
    }
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      LPCTSTR [in]: window class name.
 *      LPCTSTR [in]: window title.
 *      DWORD [in]: window extended style.
 *      DWORD [in]: window basic style.
 *      int [in]: window x-coordinate.
 *      int [in]: window y-coordinate.
 *      int [in]: window width.
 *      int [in]: window height.
 *      UINT [in]: child control identifier.
 *      UINT [in]: identifier of the first MDI child window.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIClientWindow::Create"

BOOL
CMDIClientWindow::Create
(
    CMDIFrameWindow *           pParent, 
    DWORD                       dwExStyle, 
    DWORD                       dwStyle, 
    int                         x,
    int                         y,
    int                         nWidth,
    int                         nHeight,
    UINT                        nControlId,
    const CLIENTCREATESTRUCT *  pccs
)
{
    ASSERT(pParent);
    
    dwExStyle |= WS_EX_CLIENTEDGE;
    dwStyle |= WS_CHILD;

    //
    // Create the window.  The 
    //

    if(!CWindow::Create(pParent, TEXT("MDICLIENT"), NULL, dwExStyle, dwStyle, x, y, nWidth, nHeight, nControlId, (LPVOID)pccs))
    {
        return FALSE;
    }

    //
    // Give the parent frame a pointer to us
    //

    pParent->m_pMDIClient = this;

    return TRUE;
}


/****************************************************************************
 *
 *  DispatchMessage
 *
 *  Description:
 *      Dispatches a message to the appropriate handler.
 *
 *  Arguments:
 *      LPMSG [in]: message.
 *
 *  Returns:  
 *      BOOL: TRUE if the message was dispatched.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIClientWindow::DispatchMessage"

BOOL
CMDIClientWindow::DispatchMessage
(
    LPMSG                   pMsg
)
{
    BOOL                    fDispatched;

    //
    // If none of our children handle the message, it might be an MDI system
    // accelerator
    //

    if(!(fDispatched = CWindow::DispatchMessage(pMsg)))
    {
        fDispatched = TranslateMDISysAccel(m_hWnd, pMsg);
    }

    return fDispatched;
}


/****************************************************************************
 *
 *  GetActiveChild
 *
 *  Description:
 *      Gets the active workspace child.
 *
 *  Arguments:
 *      CMDIChildWindow ** [out]: child window.
 *      LPBOOL [out]: TRUE if the window is maximized.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIClientWindow::GetActiveChild"

BOOL
CMDIClientWindow::GetActiveChild
(
    CMDIChildWindow **      ppWindow,
    LPBOOL                  pfMaximized
)
{
    CMDIChildWindow *       pWindow;
    HWND                    hWnd;

    if(!(hWnd = (HWND)SendMessage(WM_MDIGETACTIVE, 0, (LPARAM)pfMaximized)))
    {
        return FALSE;
    }

    if(!(pWindow = CWindowCast<CMDIChildWindow>::Cast(GetWindowContext(hWnd))))
    {
        return FALSE;
    }

    if(ppWindow)
    {
        *ppWindow = pWindow;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  IsActiveChild
 *
 *  Description:
 *      Determines if a child window is currently the active one.
 *
 *  Arguments:
 *      CMDIChildWindow * [in]: child window.
 *
 *  Returns:  
 *      BOOL: TRUE if the window is active.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIClientWindow::IsActiveChild"

BOOL
CMDIClientWindow::IsActiveChild
(
    CMDIChildWindow *       pWindow
)
{
    HWND                    hWnd;

    if(!(hWnd = (HWND)SendMessage(WM_MDIGETACTIVE)))
    {
        return FALSE;
    }

    return hWnd == pWindow->m_hWnd;
}


/****************************************************************************
 *
 *  CMDIChildWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::CMDIChildWindow"

CMDIChildWindow::CMDIChildWindow
(
    void
)
:   CWindow(-1, -1, WNDTYPE)
{
}


/****************************************************************************
 *
 *  ~CMDIChildWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::~CMDIChildWindow"

CMDIChildWindow::~CMDIChildWindow
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      LPCTSTR [in]: window class name.
 *      LPCTSTR [in]: window title.
 *      DWORD [in]: window extended style.
 *      DWORD [in]: window basic style.
 *      int [in]: window x-coordinate.
 *      int [in]: window y-coordinate.
 *      int [in]: window width.
 *      int [in]: window height.
 *      LPVOID [in]: creation context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::Create"

BOOL 
CMDIChildWindow::Create
(
    CMDIClientWindow *      pParent, 
    LPCTSTR                 pszClassName, 
    LPCTSTR                 pszWindowName, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight, 
    LPVOID                  pvParam
)
{
    BOOL                    fMaximized;
    
    ASSERT(pParent);

    dwExStyle |= WS_EX_MDICHILD;
    dwStyle |= WS_CHILD;

    //
    // Get the window state of the currently active MDI child (if any)
    // and use it to override the state passed in.
    //
    
    if(pParent->GetActiveChild(NULL, &fMaximized))
    {
        dwStyle &= ~(WS_MAXIMIZE | WS_MINIMIZE);
        
        if(fMaximized)
        {
            dwStyle |= WS_MAXIMIZE;
        }
    }

    //
    // Create the window
    //

    return CWindow::Create(pParent, pszClassName, pszWindowName, dwExStyle, dwStyle, x, y, nWidth, nHeight, 0, pvParam);
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::HandleMessage"

BOOL 
CMDIChildWindow::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_STYLECHANGED:
            fHandled = OnStyleChanged(wParam, (LPSTYLESTRUCT)lParam, plResult);
            break;

        case WM_USER_FORCERESIZE:
            fHandled = OnForceResize(plResult);
            break;

        case WM_MDIACTIVATE:
            fHandled = OnMdiActivate((HWND)wParam, (HWND)lParam, plResult);
            break;

        default:
            fHandled = CWindow::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles WM_SIZE messages.
 *
 *  Arguments:
 *      UINT [in]: resize type.
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::OnSize"

BOOL
CMDIChildWindow::OnSize
(
    UINT                    nType, 
    UINT                    nWidth, 
    UINT                    nHeight, 
    LRESULT *               plResult
)
{
    static const DWORD      dwFlags     = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED;
    DWORD                   dwExStyle;
    RECT                    rc;
    
    if(CWindow::OnSize(nType, nWidth, nHeight, plResult))
    {
        return TRUE;
    }

    //
    // Toggle the WS_EX_CLIENTEDGE style so we don't look goofy when maximized
    // inside the MDI client window.  Because of this trick, make sure child
    // windows don't have the WS_EX_CLIENTEDGE style.
    //
    // This is all a massive hack.  See OnStyleChanged and OnForceResize for
    // more information.
    //

    if(SIZE_MAXIMIZED == nType)
    {
        if((dwExStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE)) & WS_EX_CLIENTEDGE)
        {
            SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle & ~WS_EX_CLIENTEDGE);
        }
    }
    else
    {
        if(!((dwExStyle = GetWindowLong(m_hWnd, GWL_EXSTYLE)) & WS_EX_CLIENTEDGE))
        {
            SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle | WS_EX_CLIENTEDGE);
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnStyleChanged
 *
 *  Description:
 *      Handles WM_STYLECHANGED messages.
 *
 *  Arguments:
 *      UINT [in]: style that changed.
 *      LPSTYLESTRUCT [in]: style data.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::OnStyleChanged"

BOOL
CMDIChildWindow::OnStyleChanged
(
    UINT                    nStyle, 
    LPSTYLESTRUCT           pStyleData,
    LRESULT *               plResult
)
{
    static const DWORD      dwFlags             = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_NOSENDCHANGING | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED;
    static const DWORD      dwFrameChangeMask   = WS_EX_CLIENTEDGE;

    //
    // Whenever the frame style changes, Windows won't automatically redraw
    // the window, so we'll do it from here
    //
    
    if(GWL_EXSTYLE == nStyle)
    {
        if((pStyleData->styleNew ^ pStyleData->styleOld) & dwFrameChangeMask)
        {
            ::SetWindowPos(m_hWnd, 0, 0, 0, 0, 0, dwFlags);
            ::PostMessage(m_hWnd, WM_USER_FORCERESIZE, 0, 0);
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnForceResize
 *
 *  Description:
 *      Handles WM_USER_FORCERESIZE messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::OnForceResize"

BOOL
CMDIChildWindow::OnForceResize
(
    LRESULT *               plResult
)
{
    RECT                    rc;

    // 
    // This sucks, but I'm anal enough to want a recessed MDI client window
    // and a recessed MDI child window without having a doubly-recessed
    // window when the child is maximized.
    //
    // Force a resize of the MDI client window so it in turn resizes the
    // MDI child properly.
    //
    // Sometimes that's not enough, so we'll force a resize of the child
    // as well.  If there isn't a better way to do this, someone should
    // lose their job.  Regardless, I can't figure it out.
    //

    ASSERT(m_pParent);
    ASSERT(m_pParent->m_pParent);
    
    m_pParent->GetWindowRect(&rc);
    m_pParent->m_pParent->ScreenToClient(&rc);

    m_pParent->MoveWindow(0, 0, 0, 0, FALSE);
    m_pParent->MoveWindow(&rc, FALSE);

    GetWindowRect(&rc);
    m_pParent->ScreenToClient(&rc);

    InvalidateRect(m_pParent->m_hWnd, NULL, TRUE);
    InvalidateRect(m_hWnd, NULL, TRUE);

    MoveWindow(0, 0, 0, 0, FALSE);
    MoveWindow(&rc, TRUE);

    *plResult = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  OnMdiActivate
 *
 *  Description:
 *      Handles WM_MDIACTIVATE messages.
 *
 *  Arguments:
 *      HWND [in]: inactive window.
 *      HWND [in]: active window.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::OnMdiActivate"

BOOL
CMDIChildWindow::OnMdiActivate
(
    HWND                    hWndInactive,
    HWND                    hWndActive,
    LRESULT *               plResult
)
{
    if(hWndInactive == m_hWnd)
    {
        OnDeactivate();
    }
    else if(hWndActive == m_hWnd)
    {
        OnActivate();
    }
    else
    {
        DPF_ERROR("Received WM_MDIACTIVATE with unexpected handles");
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles WM_DESTROY messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::OnDestroy"

BOOL
CMDIChildWindow::OnDestroy
(
    LRESULT *               plResult
)
{
    if(CWindow::OnDestroy(plResult))
    {
        return TRUE;
    }

    //
    // If we're the last child to go, make sure the OnDeactivate method gets
    // called.  The MDIACTIVATE message isn't sent unless there's a new window
    // waiting to take focus.
    //

    if(!((CMDIClientWindow *)m_pParent)->GetActiveChild())
    {
        OnDeactivate();
    }

    return FALSE;
}


/****************************************************************************
 *
 *  DefWindowProc
 *
 *  Description:
 *      Default message handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter.
 *      LPARAM [in]: message parameter.
 *
 *  Returns:  
 *      LRESULT: message result.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMDIChildWindow::DefWindowProc"

LRESULT
CMDIChildWindow::DefWindowProc
(
    HWND                    hWnd, 
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam
)
{
    return ::DefMDIChildProc(hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\dlgwrap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/20/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dlgwrap.cpp
 *  Content:    Dialog wrapper classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/20/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactgui.h"


/****************************************************************************
 *
 *  CDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      UINT [in]: dialog resource identifier.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::CDialog"

CDialog::CDialog
(
    UINT                    nDialogResourceId
)
:   CWindow(-1, -1, WNDTYPE),
    m_nDialogResourceId(nDialogResourceId)
{
}


/****************************************************************************
 *
 *  ~CDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::~CDialog"

CDialog::~CDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the dialog.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      LPVOID [in]: creation parameter.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::Create"

BOOL
CDialog::Create
(
    CWindow *               pParent,
    LPVOID                  pvContext
)
{
    WINDOWCREATECTX         ctx;

    m_pParent = pParent;

    ctx.dwSignature = m_dwValidSignature;
    ctx.pWindow = this;
    ctx.pvContext = pvContext;

    return MAKEBOOL(CreateDialogParam(g_hInstance, MAKEINTRESOURCE(m_nDialogResourceId), GetHWND(pParent), DialogProc, (LPARAM)&ctx));
}


/****************************************************************************
 *
 *  DoModal
 *
 *  Description:
 *      Creates the dialog.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      LPVOID [in]: creation parameter.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::DoModal"

BOOL
CDialog::DoModal
(
    CWindow *               pParent,
    LPVOID                  pvContext
)
{
    HWND                    hWndFocus;
    WINDOWCREATECTX         ctx;
    BOOL                    fSuccess;

    m_pParent = pParent;

    //
    // Save the window with the keyboard focus so we can restore it later
    //

    hWndFocus = GetFocus();

    //
    // Show the dialog
    //

    ctx.dwSignature = m_dwValidSignature;
    ctx.pWindow = this;
    ctx.pvContext = pvContext;

    fSuccess = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(m_nDialogResourceId), GetHWND(pParent), DialogProc, (LPARAM)&ctx);

    //
    // Restore focus
    //

    SetFocus(hWndFocus);

    return fSuccess;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles WM_COMMAND messages.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::OnCommand"

BOOL
CDialog::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hwndControl,
    LRESULT *               plResult
)
{
    LPCTSTR                 pszPath;
    
    if(CWindow::OnCommand(nCommandId, nControlId, hwndControl, plResult))
    {
        return TRUE;
    }

    switch(nControlId)
    {
        case IDOK:
            OnCmdOK();
            break;
        
        case IDCANCEL:
            OnCmdCancel();
            break;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnClose
 *
 *  Description:
 *      Handles WM_CLOSE messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::OnClose"

BOOL
CDialog::OnClose
(
    LRESULT *               plResult
)
{
    OnCmdCancel();

    *plResult = 0;
    return TRUE;
}


/****************************************************************************
 *
 *  OnCmdOK
 *
 *  Description:
 *      Handles the OK command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::OnCmdOK"

void
CDialog::OnCmdOK
(
    void
)
{
    EndDialog(m_hWnd, TRUE);
}


/****************************************************************************
 *
 *  OnCmdCancel
 *
 *  Description:
 *      Handles the Cancel command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::OnCmdCancel"

void
CDialog::OnCmdCancel
(
    void
)
{
    EndDialog(m_hWnd, FALSE);
}


/****************************************************************************
 *
 *  DialogProc
 *
 *  Description:
 *      Main window message handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *
 *  Returns:  
 *      LRESULT: message result.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::DialogProc"

int CALLBACK
CDialog::DialogProc
(
    HWND                    hWnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    LRESULT                 lResult     = 0;
    CWindow *               pWindow;

    //
    // Get the "this" pointer from the window object
    // 
    // We're special-casing WM_CREATE because it actually contains the window
    // handle we use to add ourselves to the global window list.
    //
    
    if(WM_INITDIALOG == uMsg)
    {
        pWindow = OnInitialCreate(hWnd, &lParam);
    }
    else
    {
        pWindow = GetWindowContext(hWnd);
    }

    if(!pWindow)
    {
        return FALSE;
    }

    //
    // Hand off to the message dispatcher
    //

    if(pWindow->HandleMessage(uMsg, wParam, lParam, &lResult))
    {
        SetWindowLong(hWnd, DWL_MSGRESULT, lResult);
        lResult = TRUE;
    }
    else
    {
        lResult = FALSE;
    }

    //
    // Special-case WM_DESTROY to delete the window object
    //

    if(WM_DESTROY == uMsg)
    {
        pWindow->Destroy();
        pWindow->Release();
    }

    return lResult;
}


/****************************************************************************
 *
 *  OnInitialCreate
 *
 *  Description:
 *      Peforms internal handling of the WM_CREATE message.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      LPARAM * [in/out]: message parameter 2.
 *
 *  Returns:  
 *      CWindow *: window object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::OnInitialCreate"

CWindow *
CDialog::OnInitialCreate
(
    HWND                    hWnd,
    LPARAM *                plParam
)
{
    CWindow *               pWindow     = NULL;
    LRESULT                 lResult     = 0;
    LPCWINDOWCREATECTX      pCtx;
    BOOL                    fHandled;

    ASSERT(hWnd);
    ASSERT(plParam);

    //
    // Get the CWindow object from the message parameters
    //

    pCtx = (LPCWINDOWCREATECTX)*plParam;
    ASSERT(pCtx);

    ASSERT(m_dwValidSignature == pCtx->dwSignature);

    pWindow = pCtx->pWindow;
    ASSERT(pWindow);

    *plParam = (LPARAM)pCtx->pvContext;

    ASSERT(!pWindow->m_hWnd);
    pWindow->m_hWnd = hWnd;

    //
    // Store the HWND => CWindow lookup data
    //

    SetWindowContext(hWnd, pWindow);

    //
    // Increment the window object's reference count
    //

    pWindow->AddRef();

    return pWindow;
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::HandleMessage"

BOOL 
CDialog::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_CREATE:
            break;

        case WM_INITDIALOG:
            fHandled = OnCreate((LPVOID)lParam, plResult);
            break;
        
        default:
            fHandled = CWindow::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\registry.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/12/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       registry.cpp
 *  Content:    Registry wrapper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/12/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactgui.h"


/****************************************************************************
 *
 *  CRegistryKey
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::CRegistryKey"

CRegistryKey::CRegistryKey
(
    void
)
{
    m_hKey = NULL;
}


/****************************************************************************
 *
 *  ~CRegistryKey
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::~CRegistryKey"

CRegistryKey::~CRegistryKey(void)
{
    Close();
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a new key.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPCTSTR [in]: key name.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::Create"

BOOL 
CRegistryKey::Create
(   
    HKEY                    hParentKey, 
    LPCTSTR                 pszKeyName
)
{
    Close();
    
    return !RegCreateKey(hParentKey, pszKeyName, &m_hKey);
}


/****************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Opens an existing key.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPCTSTR [in]: key name.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::Open"

BOOL 
CRegistryKey::Open
(
    HKEY                    hParentKey, 
    LPCTSTR                 pszKeyName
)
{
    Close();
    
    return !RegOpenKey(hParentKey, pszKeyName, &m_hKey);
}


/****************************************************************************
 *
 *  Close
 *
 *  Description:
 *      Closes an open key.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::Close"

void 
CRegistryKey::Close
(
    void
)
{
    if(m_hKey)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}


/****************************************************************************
 *
 *  GetNumericValue
 *
 *  Description:
 *      Reads a value from the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: value name.
 *      int * [out]: value data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::GetNumericValue"

BOOL 
CRegistryKey::GetNumericValue
(
    LPCTSTR                 pszValueName, 
    int *                   pnValue
)
{
    DWORD                   dwType  = REG_DWORD;
    DWORD                   dwSize  = sizeof(*pnValue);
    
    if(RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)pnValue, &dwSize))
    {
        return FALSE;
    }

    ASSERT(REG_DWORD == dwType);
    ASSERT(sizeof(*pnValue) == dwSize);

    return TRUE;
}


/****************************************************************************
 *
 *  SetNumericValue
 *
 *  Description:
 *      Stores a value in the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: value name.
 *      int [in]: value data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::SetNumericValue"

BOOL 
CRegistryKey::SetNumericValue
(
    LPCTSTR                 pszValueName, 
    int                     nValue
)
{
    return !RegSetValueEx(m_hKey, pszValueName, NULL, REG_DWORD, (const BYTE *)&nValue, sizeof(nValue));
}


/****************************************************************************
 *
 *  GetStringValue
 *
 *  Description:
 *      Reads a value from the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: value name.
 *      LPTSTR [out]: value data.
 *      UINT [in]: value data buffer length, in characters.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::GetStringValue"

BOOL 
CRegistryKey::GetStringValue
(
    LPCTSTR                 pszValueName, 
    LPTSTR                  pszValue, 
    UINT                    nLength
)
{
    DWORD                   dwType  = REG_SZ;
    DWORD                   dwSize  = nLength * sizeof(TCHAR);
    
    if(RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (LPBYTE)pszValue, &dwSize))
    {
        return FALSE;
    }

    ASSERT(REG_SZ == dwType);
    ASSERT(nLength >= dwSize);

    pszValue[nLength - 1] = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  SetStringValue
 *
 *  Description:
 *      Stores a value in the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: value name.
 *      LPCTSTR [in]: value data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::SetStringValue"

BOOL 
CRegistryKey::SetStringValue
(
    LPCTSTR                 pszValueName, 
    LPCTSTR                 pszValue
)
{
    const int               nLength = _tcslen(pszValue) + 1;
    
    return !RegSetValueEx(m_hKey, pszValueName, NULL, REG_SZ, (const BYTE *)pszValue, nLength * sizeof(TCHAR));
}


/****************************************************************************
 *
 *  GetBinaryValue
 *
 *  Description:
 *      Reads a value from the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: value name.
 *      LPVOID [out]: value data.
 *      UINT [in]: value data buffer length, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::GetBinaryValue"

BOOL 
CRegistryKey::GetBinaryValue
(
    LPCTSTR                 pszValueName, 
    LPVOID                  pvValue, 
    UINT                    nSize
)
{
    DWORD                   dwType  = REG_BINARY;
    DWORD                   dwSize  = nSize;
    
    if(RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, (BYTE *)pvValue, &dwSize))
    {
        return FALSE;
    }

    ASSERT(REG_BINARY == dwType);
    ASSERT(nSize == dwSize);

    return TRUE;
}


/****************************************************************************
 *
 *  SetBinaryValue
 *
 *  Description:
 *      Stores a value in the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: value name.
 *      LPCVOID [in]: value data.
 *      UINT [in]: value data buffer length, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistryKey::SetBinaryValue"

BOOL 
CRegistryKey::SetBinaryValue
(
    LPCTSTR                 pszValueName, 
    LPCVOID                 pvValue, 
    UINT                    nSize
)
{
    return !RegSetValueEx(m_hKey, pszValueName, NULL, REG_BINARY, (const BYTE *)pvValue, nSize);
}


/****************************************************************************
 *
 *  CRegistry
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      HKEY [in]: parent key.
 *      LPCTSTR [in]: application key path.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRegistry::CRegistry"

CRegistry::CRegistry
(
    HKEY                    hRootKey, 
    LPCTSTR                 pszAppPath
)
{
    m_AppKey.Create(hRootKey, pszAppPath);
}    


/****************************************************************************
 *
 *  ~CRegistry
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRegistry::~CRegistry"

CRegistry::~CRegistry
(
    void
)
{
}


/****************************************************************************
 *
 *  GetNumericValue
 *
 *  Description:
 *      Reads a value from the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: subkey name.
 *      LPCTSTR [in]: value name.
 *      int * [out]: value data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistry::GetNumericValue"

BOOL 
CRegistry::GetNumericValue
(
    LPCTSTR                 pszKeyName, 
    LPCTSTR                 pszValueName, 
    int *                   pnValue
)
{
    if(pszKeyName)
    {
        CRegistryKey Key;

        if(!Key.Open(m_AppKey, pszKeyName))
        {
            return FALSE;
        }

        return Key.GetNumericValue(pszValueName, pnValue);
    }
    else
    {
        return m_AppKey.GetNumericValue(pszValueName, pnValue);
    }
}


/****************************************************************************
 *
 *  SetNumericValue
 *
 *  Description:
 *      Stores a value in the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: subkey name.
 *      LPCTSTR [in]: value name.
 *      int [in]: value data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistry::SetNumericValue"

BOOL 
CRegistry::SetNumericValue
(
    LPCTSTR                 pszKeyName, 
    LPCTSTR                 pszValueName, 
    int                     nValue
)
{
    if(pszKeyName)
    {
        CRegistryKey Key;

        if(!Key.Create(m_AppKey, pszKeyName))
        {
            return FALSE;
        }

        return Key.SetNumericValue(pszValueName, nValue);
    }
    else
    {
        return m_AppKey.SetNumericValue(pszValueName, nValue);
    }
}


/****************************************************************************
 *
 *  GetStringValue
 *
 *  Description:
 *      Reads a value from the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: subkey name.
 *      LPCTSTR [in]: value name.
 *      LPTSTR [out]: value data.
 *      UINT [in]: value data buffer length, in characters.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistry::GetStringValue"

BOOL 
CRegistry::GetStringValue
(
    LPCTSTR                 pszKeyName, 
    LPCTSTR                 pszValueName, 
    LPTSTR                  pszValue, 
    UINT                    nLength
)
{
    if(pszKeyName)
    {
        CRegistryKey Key;

        if(!Key.Open(m_AppKey, pszKeyName))
        {
            return FALSE;
        }

        return Key.GetStringValue(pszValueName, pszValue, nLength);
    }
    else
    {
        return m_AppKey.GetStringValue(pszValueName, pszValue, nLength);
    }
}


/****************************************************************************
 *
 *  SetStringValue
 *
 *  Description:
 *      Stores a value in the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: subkey name.
 *      LPCTSTR [in]: value name.
 *      LPCTSTR [in]: value data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistry::SetStringValue"

BOOL 
CRegistry::SetStringValue
(
    LPCTSTR                 pszKeyName, 
    LPCTSTR                 pszValueName, 
    LPCTSTR                 pszValue
)
{
    if(pszKeyName)
    {
        CRegistryKey Key;

        if(!Key.Create(m_AppKey, pszKeyName))
        {
            return FALSE;
        }

        return Key.SetStringValue(pszValueName, pszValue);
    }
    else
    {
        return m_AppKey.SetStringValue(pszValueName, pszValue);
    }
}


/****************************************************************************
 *
 *  GetBinaryValue
 *
 *  Description:
 *      Reads a value from the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: subkey name.
 *      LPCTSTR [in]: value name.
 *      LPVOID [out]: value data.
 *      UINT [in]: value data buffer length, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistry::GetBinaryValue"

BOOL 
CRegistry::GetBinaryValue
(
    LPCTSTR                 pszKeyName, 
    LPCTSTR                 pszValueName, 
    LPVOID                  pvValue, 
    UINT                    nSize
)
{
    if(pszKeyName)
    {
        CRegistryKey Key;

        if(!Key.Open(m_AppKey, pszKeyName))
        {
            return FALSE;
        }

        return Key.GetBinaryValue(pszValueName, pvValue, nSize);
    }
    else
    {
        return m_AppKey.GetBinaryValue(pszValueName, pvValue, nSize);
    }
}


/****************************************************************************
 *
 *  SetBinaryValue
 *
 *  Description:
 *      Stores a value in the registry.
 *
 *  Arguments:
 *      LPCTSTR [in]: subkey name.
 *      LPCTSTR [in]: value name.
 *      LPCVOID [in]: value data.
 *      UINT [in]: value data buffer length, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRegistry::SetBinaryValue"

BOOL 
CRegistry::SetBinaryValue
(
    LPCTSTR                 pszKeyName, 
    LPCTSTR                 pszValueName, 
    LPCVOID                 pvValue, 
    UINT                    nSize
)
{
    if(pszKeyName)
    {
        CRegistryKey Key;

        if(!Key.Create(m_AppKey, pszKeyName))
        {
            return FALSE;
        }

        return Key.SetBinaryValue(pszValueName, pvValue, nSize);
    }
    else
    {
        return m_AppKey.SetBinaryValue(pszValueName, pvValue, nSize);
    }
}


/****************************************************************************
 *
 *  CMRU
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::CMRU"

CMRU::CMRU
(
    HKEY                    hParentKey, 
    LPCTSTR                 pszKeyName
)
{
    m_Key.Create(hParentKey, pszKeyName);

    Load();
}


/****************************************************************************
 *
 *  ~CMRU
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::~CMRU"

CMRU::~CMRU
(
    void
)
{
    Save();
}


/****************************************************************************
 *
 *  Load
 *
 *  Description:
 *      Loads MRU data from the registry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::Load"

void
CMRU::Load
(
    void
)
{
    TCHAR                   szValueName[0x100];
    UINT                    i;
    
    //
    // Reinitialize list data
    //

    InitializeListHead(&m_lstItems);
    InitializeListHead(&m_lstFree);

    //
    // Read each item from the registry
    //

    for(i = 0; i < NUMELMS(m_aItems); i++)
    {
        _stprintf(szValueName, TEXT("%u"), i);
        
        if(!m_Key.GetStringValue(szValueName, m_aItems[i].szPath, NUMELMS(m_aItems[i].szPath)))
        {
            break;
        }

        InsertTailListUninit(&m_lstItems, &m_aItems[i].leItems);
    }

    //
    // Move the remaining items into the free list
    //

    for(; i < NUMELMS(m_aItems); i++)
    {
        InsertTailListUninit(&m_lstFree, &m_aItems[i].leItems);
    }

    //
    // Update the menu
    //

    UpdateMenu();
}


/****************************************************************************
 *
 *  Save
 *
 *  Description:
 *      Saves MRU data to the registry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::Save"

void
CMRU::Save
(
    void
)
{
    TCHAR                   szValueName[0x100];
    DWORD                   dwLength;
    PLIST_ENTRY             pleEntry;
    LPMRUITEM               pItem;
    UINT                    i;
    
    //
    // Delete all values from the registry key
    //

    while(TRUE)
    {
        dwLength = NUMELMS(szValueName);
        
        if(RegEnumValue(m_Key, 0, szValueName, &dwLength, NULL, NULL, NULL, NULL))
        {
            break;
        }

        if(!RegDeleteValue(m_Key, szValueName))
        {
            break;
        }
    }

    //
    // Write all entries from the list
    //

    for(pleEntry = m_lstItems.Flink, i = 0; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink, i++)
    {
        pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);
        
        _stprintf(szValueName, TEXT("%u"), i);

        m_Key.SetStringValue(szValueName, pItem->szPath);
    }
}


/****************************************************************************
 *
 *  AddItem
 *
 *  Description:
 *      Adds an item to the list.
 *
 *  Arguments:
 *      LPCTSTR [in]: item path.
 *      BOOL [in]: TRUE to update the MRU menu.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::AddItem"

void
CMRU::AddItem
(
    LPCTSTR                 pszPath,
    BOOL                    fUpdateMenu
)
{
    PLIST_ENTRY             pleEntry;
    LPMRUITEM               pItem;

    //
    // Look for the item in the current list
    //

    for(pleEntry = m_lstItems.Flink; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink)
    {
        pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

        if(!_tcsicmp(pszPath, pItem->szPath))
        {
            break;
        }
    }

    //
    // If the item's already in the list, just move it to the head.  If not,
    // add it to the tail.  If we're out of free items, use the last one in
    // the current list.
    //

    if(pleEntry != &m_lstItems)
    {
        RemoveEntryList(pleEntry);
    }
    else if(!IsListEmpty(&m_lstFree))
    {
        pleEntry = RemoveHeadList(&m_lstFree);
    }
    else
    {
        pleEntry = RemoveTailList(&m_lstItems);
    }

    pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

    _tcscpy(pItem->szPath, pszPath);
    
    InsertHeadList(&m_lstItems, pleEntry);

    //
    // Update the menu
    //

    if(fUpdateMenu)
    {
        UpdateMenu();
    }
}


/****************************************************************************
 *
 *  UpdateMenu
 *
 *  Description:
 *      Applies MRU data to the menu.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::UpdateMenu"

void
CMRU::UpdateMenu
(
    void
)
{
    TCHAR                   szString[MAX_PATH + 0x100];
    PLIST_ENTRY             pleEntry;
    LPMRUITEM               pItem;
    UINT                    i;
    
    if(!m_hMenu)
    {
        return;
    }

    //
    // Save the first item that already exists in the menu.  If there's
    // nothing in the MRU, we'll use this as a placeholder.
    //

    if(!m_szPlaceholder[0])
    {
        GetMenuString(m_hMenu, 0, m_szPlaceholder, NUMELMS(m_szPlaceholder), MF_BYPOSITION);
    }

    //
    // Remove existing menu items
    //
    
    while(DeleteMenu(m_hMenu, 0, MF_BYPOSITION));

    //
    // Add MRU data
    //

    for(pleEntry = m_lstItems.Flink, i = 0; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink, i++)
    {
        pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

        _stprintf(szString, TEXT("&%lu\t%s"), i + 1, pItem->szPath);

        AppendMenu(m_hMenu, MF_STRING, m_nCommandId + i, szString);
    }

    //
    // If we didn't add anything, add a placeholder
    //

    if(!i && m_szPlaceholder[0])
    {
        AppendMenu(m_hMenu, MF_STRING, m_nCommandId, m_szPlaceholder);
        EnableMenuItem(m_hMenu, 0, MF_BYPOSITION | MF_GRAYED);
    }
}


/****************************************************************************
 *
 *  TranslateCommand
 *
 *  Description:
 *      Converts a command identifier to a file path.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *
 *  Returns:  
 *      LPCTSTR: file path or NULL.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::TranslateCommand"

LPCTSTR
CMRU::TranslateCommand
(
    UINT                    nCommandId
)
{
    PLIST_ENTRY             pleEntry;
    LPMRUITEM               pItem;
    UINT                    i;

    if((nCommandId < m_nCommandId) || (nCommandId >= m_nCommandId + NUMELMS(m_aItems)))
    {
        return NULL;
    }

    pleEntry = m_lstItems.Flink;
    i = m_nCommandId;

    while((pleEntry != &m_lstItems) && (i != nCommandId))
    {
        pleEntry = pleEntry->Flink;
        i++;
    }

    if(i != nCommandId)
    {
        return NULL;
    }

    pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

    return pItem->szPath;
}


/****************************************************************************
 *
 *  AttachMenu
 *
 *  Description:
 *      Attaches the MRU to a menu.
 *
 *  Arguments:
 *      HMENU [in]: menu handle.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::AttachMenu"

void
CMRU::AttachMenu
(
    HMENU                   hMenu
)
{
    m_hMenu = hMenu;

    //
    // Get the identifier of the first item in the menu.  All MRU items will
    // increment from this base command identifier.
    //

    m_nCommandId = GetMenuItemID(m_hMenu, 0);
    ASSERT(-1 != m_nCommandId);

    //
    // Reset the menu
    //

    UpdateMenu();
}


/****************************************************************************
 *
 *  GetItems
 *
 *  Description:
 *      Retrieves the items in the MRU list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      LPTSTR: double-NULL-terminated string containing all the MRU items.
 *              the caller is responsible for freeing this buffer.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::GetItems"

LPTSTR
CMRU::GetItems
(
    void
)
{
    LPTSTR                  pszBuffer;
    PLIST_ENTRY             pleEntry;
    LPMRUITEM               pItem;
    LPTSTR                  psz;

    //
    // Allocate a buffer large enough to hold the maximum number of items
    // possible
    //

    if(!(pszBuffer = MEMALLOC(TCHAR, MAX_PATH * MAX_ITEMS + 1)))
    {
        return NULL;
    }

    //
    // Start copying the items
    //

    psz = pszBuffer;
    
    for(pleEntry = m_lstItems.Flink; pleEntry != &m_lstItems; pleEntry = pleEntry->Flink)
    {
        pItem = CONTAINING_RECORD(pleEntry, MRUITEM, leItems);

        _tcscpy(psz, pItem->szPath);

        psz += _tcslen(psz) + 1;
    }

    return pszBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\strhlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/4/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strhlp.h
 *  Content:    String helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/4/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __STRHLP_H__
#define __STRHLP_H__

EXTERN_C void FormatStringResource(LPTSTR pszText, UINT nLength, UINT nResourceId, ...);
EXTERN_C LPCTSTR FormatStringResourceStatic(UINT nResourceId, ...);
EXTERN_C BOOL ParseCommandLine(LPCTSTR pszCmdLine, LPTSTR *ppszParsed, LPUINT pnArgCount);
EXTERN_C void GetXDKVersion(LPTSTR pszString);
EXTERN_C void FormatNumber(int nValue, BOOL fSigned, BOOL fThousands, LPTSTR pszString);
EXTERN_C UINT MsgBoxV(HWND hWnd, DWORD dwFlags, LPCTSTR pszText, va_list va);
EXTERN_C UINT MsgBox(HWND hWnd, DWORD dwFlags, LPCTSTR pszText, ...);
EXTERN_C UINT MsgBoxResource(HWND hWnd, DWORD dwFlags, UINT nStringResourceId, ...);

#endif // __STRHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\registry.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/12/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       registry.h
 *  Content:    Registry wrapper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/12/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __REGISTRY_H__
#define __REGISTRY_H__

#ifdef __cplusplus

//
// Generic key object
//

class CRegistryKey
{
protected:
    HKEY                    m_hKey;         // Registry key handle

public:
    CRegistryKey(void);
    virtual ~CRegistryKey(void);

public:
    // Initialization
    virtual BOOL Create(HKEY hParentKey, LPCTSTR pszKeyName);
    virtual BOOL Open(HKEY hParentKey, LPCTSTR pszKeyName);

    virtual void Close(void);

    // Value data
    virtual BOOL GetNumericValue(LPCTSTR pszValueName, int *pnValue);
    virtual BOOL SetNumericValue(LPCTSTR pszValueName, int nValue);
    
    virtual BOOL GetStringValue(LPCTSTR pszValueName, LPTSTR pszValue, UINT nLength);
    virtual BOOL SetStringValue(LPCTSTR pszValueName, LPCTSTR pszValue);
    
    virtual BOOL GetBinaryValue(LPCTSTR pszValueName, LPVOID pvValue, UINT nSize);
    virtual BOOL SetBinaryValue(LPCTSTR pszValueName, LPCVOID pvValue, UINT nSize);

    // Operators
    virtual operator HKEY(void);
};

__inline CRegistryKey::operator HKEY(void)
{
    return m_hKey;
}

//
// Registry wrapper object
//

class CRegistry
{
protected:
    CRegistryKey            m_AppKey;       // Application root key

public:
    CRegistry(HKEY hRootKey, LPCTSTR pszAppPath);
    virtual ~CRegistry(void);

public:
    // Value data
    virtual BOOL GetNumericValue(LPCTSTR pszKeyName, LPCTSTR pszValueName, int *pnValue);
    virtual BOOL SetNumericValue(LPCTSTR pszKeyName, LPCTSTR pszValueName, int nValue);
    
    virtual BOOL GetStringValue(LPCTSTR pszKeyName, LPCTSTR pszValueName, LPTSTR pszValue, UINT nLength);
    virtual BOOL SetStringValue(LPCTSTR pszKeyName, LPCTSTR pszValueName, LPCTSTR pszValue);
    
    virtual BOOL GetBinaryValue(LPCTSTR pszKeyName, LPCTSTR pszValueName, LPVOID pvValue, UINT nSize);
    virtual BOOL SetBinaryValue(LPCTSTR pszKeyName, LPCTSTR pszValueName, LPCVOID pvValue, UINT nSize);

    // Operators
    virtual operator HKEY(void);
};

__inline CRegistry::operator HKEY(void)
{
    return m_AppKey;
}

//
// Most-recently-used list
//

class CMRU
{
public:
    enum
    {
        MAX_ITEMS = 4
    };

    typedef struct
    {
        LIST_ENTRY          leItems;                // Item list entry
        TCHAR               szPath[MAX_PATH];       // File path
    } MRUITEM, *LPMRUITEM;

protected:
    CRegistryKey            m_Key;                  // Registry key
    MRUITEM                 m_aItems[MAX_ITEMS];    // Item data
    LIST_ENTRY              m_lstItems;             // Item list
    LIST_ENTRY              m_lstFree;              // Free list
    HMENU                   m_hMenu;                // Menu handle
    UINT                    m_nCommandId;           // Menu item identifier
    TCHAR                   m_szPlaceholder[0x100]; // Placeholder item string

public:
    CMRU(HKEY hParentKey, LPCTSTR pszKeyName);
    virtual ~CMRU(void);

public:
    // Initialization
    virtual void AttachMenu(HMENU hMenu);
    virtual void UpdateMenu(void);

    // MRU data
    virtual void AddItem(LPCSTR pszPath, BOOL fUpdateMenu = TRUE);
    virtual LPTSTR GetItems(void);

    // Command handler
    virtual LPCTSTR TranslateCommand(UINT nCommandId);

protected:
    // MRU data
    virtual void Load(void);
    virtual void Save(void);
};

#endif // __cplusplus

#endif // __REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\strhlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/4/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strhlp.cpp
 *  Content:    String helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/4/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactgui.h"


/****************************************************************************
 *
 *  FormatStringResource
 *
 *  Description:
 *      Loads and formats a string.
 *
 *  Arguments:
 *      HINSTANCE [in]: resource instance.
 *      UINT [in]: resource identifier.
 *
 *  Returns:  
 *      LPCTSTR: formatted string.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FormatStringResource"

void
FormatStringResource
(
    LPTSTR                  pszText,
    UINT                    nLength,
    UINT                    nResourceId,
    ...
)
{
    TCHAR                   szFormat[0x100];
    va_list                 va;

    if(LoadString(g_hInstance, nResourceId, szFormat, NUMELMS(szFormat)))
    {
        va_start(va, nResourceId);
        _vsntprintf(pszText, nLength, szFormat, va);
        va_end(va);
    }
    else
    {
        DPF_ERROR("String %lu not found", nResourceId);
        *pszText = 0;
    }
}


/****************************************************************************
 *
 *  FormatStringResourceStatic
 *
 *  Description:
 *      Loads and formats a string.
 *
 *  Arguments:
 *      HINSTANCE [in]: resource instance.
 *      UINT [in]: resource identifier.
 *
 *  Returns:  
 *      LPCTSTR: formatted string.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FormatStringResourceStatic"

LPCTSTR
FormatStringResourceStatic
(
    UINT                    nResourceId,
    ...
)
{
    static TCHAR            szFinal[0x400];
    TCHAR                   szFormat[0x100];
    va_list                 va;

    if(LoadString(g_hInstance, nResourceId, szFormat, NUMELMS(szFormat)))
    {
        va_start(va, nResourceId);
        _vsntprintf(szFinal, NUMELMS(szFinal), szFormat, va);
        va_end(va);
    }
    else
    {
        DPF_ERROR("String %lu not found", nResourceId);
        szFormat[0] = 0;
    }
    
    return szFinal;
}


/****************************************************************************
 *
 *  ParseCommandLine
 *
 *  Description:
 *      Parses a command line into a set of double-null-terminated string.
 *
 *  Arguments:
 *      LPCTSTR [in]: command line.
 *      LPCTSTR * [out]: parsed command line.  The caller is responsible for
 *                       freeing this buffer with MEMFREE.
 *      LPUINT [out]: number of arguments in the command line.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ParseCommandLine"

BOOL
ParseCommandLine
(
    LPCTSTR                 pszCmdLine,
    LPTSTR *                ppszParsed,
    LPUINT                  pnArgCount
)
{
    BOOL                    fOpenQuote  = FALSE;
    UINT                    nArgCount   = 1;
    LPTSTR                  pszParsed;
    LPTSTR                  pszDest;

    //
    // Allocate a string large enough to hold the double-NULL terminated
    // version of the arguments
    //

    if(!(pszDest = pszParsed = MEMALLOC(TCHAR, _tcslen(pszCmdLine) + 2)))
    {
        return FALSE;
    }

    //
    // Start coopying parameters
    //

    while(*pszCmdLine)
    {
        //
        // Skip leading whitespace
        //

        while(TEXT(' ') == *pszCmdLine)
        {
            pszCmdLine++;
        }

        //
        // Copy characters up to the next unquoted space
        //

        while(TRUE)
        {
            if(!*pszCmdLine)
            {
                *pszDest++ = 0;
                break;
            }
            else if(TEXT('\"') == *pszCmdLine)
            {
                fOpenQuote = !fOpenQuote;
            }
            else if((TEXT(' ') == *pszCmdLine) && !fOpenQuote)
            {
                nArgCount++;
                *pszDest++ = 0;
                break;
            }
            else
            {
                *pszDest++ = *pszCmdLine;
            }

            pszCmdLine++;
        }
    }

    *pszDest = 0;

    //
    // Fill out parameters
    //

    if(ppszParsed)
    {
        *ppszParsed = pszParsed;
    }
    else
    {
        MEMFREE(pszParsed);
    }

    if(pnArgCount)
    {
        *pnArgCount = nArgCount;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  GetXDKVersion
 *
 *  Description:
 *      Gets the current XDK version.
 *
 *  Arguments:
 *      LPTSTR [out]: version string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GetXDKVersion"

void 
GetXDKVersion
(
    LPTSTR                  pszString
)
{
    static const DWORD      dwMajor = (VER_PRODUCTVERSION_DW >> 24) & 0xFF;
    static const DWORD      dwMinor = (VER_PRODUCTVERSION_DW >> 16) & 0xFF;
    static const DWORD      dwBuild = VER_PRODUCTVERSION_DW & 0xFFFF;
    
    _stprintf(pszString, TEXT("%lu.%lu.%lu"), dwMajor, dwMinor, dwBuild);
}


/****************************************************************************
 *
 *  FormatNumber
 *
 *  Description:
 *      Converts a number to a string, adding comma-separators.
 *
 *  Arguments:
 *      int [in]: number.
 *      BOOL [in]: signed or unsigned.
 *      BOOL [in]: add commas.
 *      LPTSTR [out]: string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FormatNumber"

void
FormatNumber
(
    int                     nValue,
    BOOL                    fSigned,
    BOOL                    fThousands,
    LPTSTR                  pszString
)
{
    LPSTR                   psz     = pszString;
    UINT                    nDigits = 0;
    UINT                    uValue;
    
    if(nValue)
    {
        if(!fSigned || (nValue > 0))
        {
            uValue = (UINT)nValue;
            
            while(uValue)
            {
                *psz++ = TEXT('0') + (uValue % 10);

                uValue /= 10;

                if(uValue && fThousands)
                {
                    if(2 == (nDigits % 3))
                    {
                        *psz++ = TEXT(',');
                    }
                }

                nDigits++;
            }
        }
        else
        {
            uValue = abs(nValue);
            
            while(uValue)
            {
                *psz++ = TEXT('0') + (uValue % 10);

                uValue /= 10;

                if(uValue && fThousands)
                {
                    if(2 == (nDigits % 3))
                    {
                        *psz++ = TEXT(',');
                    }
                }

                nDigits++;
            }

            *psz++ = TEXT('-');
        }
    }
    else
    {
        *psz++ = TEXT('0');
    }

    *psz = 0;

    _tcsrev(pszString);
}


/****************************************************************************
 *
 *  MsgBoxV
 *
 *  Description:
 *      Displays a message box.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      DWORD [in]: flags.
 *      LPCTSTR [in]: message text.
 *      ... [in]: formatting options.
 *
 *  Returns:  
 *      UINT: button clicked.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MsgBoxV"

UINT
MsgBoxV
(
    HWND                    hWnd,
    DWORD                   dwFlags,
    LPCTSTR                 pszText,
    va_list                 va
)
{
    TCHAR                   szText[0x400];
    UINT                    nResult;
    HWND                    hWndFocus;

    //
    // Save the current keyboard focus
    //

    hWndFocus = GetFocus();

    //
    // Create the text string
    //

    _vsntprintf(szText, NUMELMS(szText), pszText, va);

    //
    // Display the message
    //

    nResult = MessageBox(hWnd, szText, g_szAppTitle, dwFlags);

    //
    // Restore focus
    //

    SetFocus(hWndFocus);

    return nResult;
}


/****************************************************************************
 *
 *  MsgBox
 *
 *  Description:
 *      Displays a message box.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      DWORD [in]: flags.
 *      LPCTSTR [in]: message text.
 *      ... [in]: formatting options.
 *
 *  Returns:  
 *      UINT: button clicked.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MsgBox"

UINT
MsgBox
(
    HWND                    hWnd,
    DWORD                   dwFlags,
    LPCTSTR                 pszText,
    ...
)
{
    va_list                 va;
    UINT                    nResult;

    va_start(va, pszText);

    nResult = MsgBoxV(hWnd, dwFlags, pszText, va);

    va_end(va);

    return nResult;
}


/****************************************************************************
 *
 *  MsgBox
 *
 *  Description:
 *      Displays a message box.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      DWORD [in]: flags.
 *      UINT [in]: string resource identifier.
 *      ... [in]: formatting options.
 *
 *  Returns:  
 *      UINT: button clicked.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MsgBoxResource"

UINT
MsgBoxResource
(
    HWND                    hWnd,
    DWORD                   dwFlags,
    UINT                    nStringResourceId,
    ...
)
{
    TCHAR                   szFormat[0x100];
    va_list                 va;
    UINT                    nResult;

    LoadString(g_hInstance, nStringResourceId, szFormat, NUMELMS(szFormat));
    
    va_start(va, nStringResourceId);
    
    nResult = MsgBoxV(hWnd, dwFlags, szFormat, va);
    
    va_end(va);

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\xactgui.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/31/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xactgui.h
 *  Content:    Common header file for all XACT GUI components.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/31/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __XACTGUI_H__
#define __XACTGUI_H__

#include "dscommon.h"
#include <shellapi.h>
#include "strhlp.h"
#include "wndwrap.h"
#include "mdiwrap.h"
#include "dlgwrap.h"
#include "registry.h"

#endif // __XACTGUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\wndwrap.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wndwrap.h
 *  Content:    Windows wrapper classes (aka My Mini MFC)
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WNDWRAP_H__
#define __WNDWRAP_H__

#define WNDWRAP_USE_SET_WINDOW_LONG

//
// Window class names
//

#define XACTGUI_MAKE_WNDCLASS_NAME(name) \
    TEXT("XACT:GUI:" name)

//
// Common dialog helpers
//

#define MAKE_COMMDLG_FILTER(desc, ext) \
    desc TEXT(" Files (") ext TEXT(")\0") ext TEXT("\0")


//
// Private window messages
//

enum
{
    //
    // WM_USER_FORCERESIZE
    //
    // Private message used by MDI children.
    //  wParam == (void)
    //  lParam == (void)
    //  lResult == (void)
    //
    
    WM_USER_FORCERESIZE = WM_USER + 0xBFFF,

    //
    // WM_PROJECT_BUILDDONE
    //
    // Private message used by the project object to notify itself that
    // the build has completed.
    //  wParam == (void)
    //  lParam == build result code.
    //  lResult == (void)
    //

    WM_PROJECT_BUILDDONE,

    //
    // LVM_FIXITEMINDICES
    //
    // Private message used by ListView controls to notify themselves that
    // the item indices have changed and need to be updated.
    //  wParam == (void)
    //  lParam == (void)
    //  lResult == (void)
    //

    LVM_FIXITEMINDICES,
};

//
// Window types
//

enum
{
    WNDTYPE_WINDOW = 0,
    WNDTYPE_MDIFRAME,
    WNDTYPE_MDICLIENT,
    WNDTYPE_MDICHILD,
    WNDTYPE_DIALOG,
};

//
// Globals
//

EXTERN_C const HINSTANCE g_hInstance;
EXTERN_C TCHAR g_szAppTitle[0x100];

#ifdef __cplusplus

//
// Forward declarations
//

class CWindow;

//
// OnCreate context
//

BEGIN_DEFINE_STRUCT()
    DWORD       dwSignature;
    CWindow *   pWindow;
    LPVOID      pvContext;
END_DEFINE_STRUCT(WINDOWCREATECTX);

//
// Window wrapper class
//

class CWindow
{
public:
    const DWORD             m_dwSignature;          // Window signature
    const UINT              m_nWindowType;          // Window type
    CWindow *               m_pParent;              // Parent window
    LIST_ENTRY              m_lstChildren;          // Child window list
    HWND                    m_hWnd;                 // Window handle
    HMENU                   m_hMenu;                // Window menu
    HACCEL                  m_hAccel;               // Window accelerator table

protected:
    static const DWORD      m_dwValidSignature;     // Window signature
    BOOL                    m_fRedraw;              // Allowing redraws?

private:

#ifndef WNDWRAP_USE_SET_WINDOW_LONG

    static LIST_ENTRY       m_lstWindows;           // List of all windows
    LIST_ENTRY              m_leWindows;            // Window list entry

#endif // WNDWRAP_USE_SET_WINDOW_LONG

    LIST_ENTRY              m_leChildren;           // Child window list entry

public:
    CWindow(UINT nMenuId = -1, UINT nAccelId = -1, UINT nWindowType = WNDTYPE_WINDOW);
    virtual ~CWindow(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
    virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

    // Validity
    virtual BOOL IsWindow(void);

    // Window destruction
    virtual void Destroy(void);

    // Redraw
    virtual BOOL SetRedraw(BOOL fRedraw);

    // Messaging
    virtual LRESULT SendMessage(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    virtual LRESULT PostMessage(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    virtual LRESULT SendDlgItemMessage(int nItemId, UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    virtual HWND GetDlgItem(int nItemId);

    // Window text
    virtual BOOL SetWindowText(LPCTSTR pszText);
    virtual BOOL SetDlgItemText(int nItemId, LPCTSTR pszString);
    virtual BOOL SetDlgItemInt(int nItemId, UINT nValue, BOOL fSigned);
    virtual BOOL GetDlgItemText(int nItemId, LPTSTR pszString, int nLength);
    virtual UINT GetDlgItemInt(int nItemId, LPBOOL pfTranslated, BOOL fSigned);
    
    // Window size
    virtual BOOL MoveWindow(int x, int y, int nWidth, int nHeight, BOOL fRepaint = TRUE);
    virtual BOOL MoveWindow(LPCRECT prcWindow, BOOL fRepaint = TRUE);
    virtual BOOL GetWindowRect(LPRECT prcWindow);
    virtual BOOL GetClientRect(LPRECT prcClient);

    // Screen coordinates
    virtual BOOL ScreenToClient(LPPOINT ppt);
    virtual BOOL ScreenToClient(LPRECT prc);

    // Drag-and-drop
    virtual void DragAcceptFiles(BOOL fAccept = TRUE);
    
    // Operators
    virtual operator HWND(void);
    static HWND GetHWND(CWindow *pWindow);

    // Message dispatching
    virtual BOOL DispatchMessage(LPMSG pMsg);

    // Basic message handlers (no modification of data)
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnClose(LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult);
    virtual BOOL OnSysCommand(UINT nCommandId, LRESULT *plResult);
    virtual BOOL OnNotify(LPNMHDR pHdr, LRESULT *plResult);
    virtual BOOL OnEraseBackground(HDC hdc, LRESULT *plResult);
    virtual BOOL OnPaint(LRESULT *plResult);
    virtual BOOL OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult);
    virtual BOOL OnDropFiles(HDROP hDrop, LRESULT *plResult);

    // Advanced message handlers (handle stupid Windows stuff before handler)
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnScroll(UINT nScrollBarType, HWND hWndScrollBar, INT nPosition, LRESULT *plResult);
    virtual BOOL OnScroll(UINT nScrollBarType, UINT nRequest, HWND hWndScrollBar, LRESULT *plResult);

    // Default handler
    virtual LRESULT DefWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Main window procedure
    static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    // Creation (protected to force subclassing of the CWindow type)
    virtual BOOL Create(CWindow *pParent, LPCTSTR pszClassName, LPCTSTR pszWindowName, DWORD dwExStyle, DWORD dwStyle, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT, int nWidth = CW_USEDEFAULT, int nHeight = CW_USEDEFAULT, UINT nControlId = 0, LPVOID pvParam = NULL);

    // Window context
    static CWindow *GetWindowContext(HWND hWnd);

    // The first and final message handlers
    static CWindow *OnInitialCreate(HWND hWnd, LPARAM *plParam);
    
    // Window context
    static void SetWindowContext(HWND hWnd, CWindow *pWindow);
    void FreeWindowContext(void);
};

__inline HWND CWindow::GetHWND(CWindow *pWindow)
{
    return pWindow ? pWindow->m_hWnd : NULL;
}

__inline BOOL CWindow::OnCreate(LPVOID pvContext, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnClose(LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnDestroy(LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnSysCommand(UINT nCommandId, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnNotify(LPNMHDR pHdr, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnEraseBackground(HDC hdc, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnPaint(LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnScroll(UINT nScrollBarType, HWND hWndScrollBar, INT nPosition, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult)
{
    return FALSE;
}

__inline LRESULT CWindow::DefWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

__inline CWindow::operator HWND(void)
{
    ASSERT(this);
    return m_hWnd;
}

__inline BOOL CWindow::IsWindow(void)
{
    if(!m_hWnd)
    {
        return FALSE;
    }

    ASSERT(::IsWindow(m_hWnd));

    return TRUE;
}

__inline LRESULT CWindow::SendMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return ::SendMessage(m_hWnd, uMsg, wParam, lParam);
}

__inline LRESULT CWindow::PostMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return ::PostMessage(m_hWnd, uMsg, wParam, lParam);
}

__inline BOOL CWindow::SetWindowText(LPCTSTR pszText)
{
    return ::SetWindowText(m_hWnd, pszText);
}

__inline BOOL CWindow::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL fRepaint)
{
    return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, fRepaint);
}

__inline BOOL CWindow::MoveWindow(LPCRECT prcWindow, BOOL fRepaint)
{
    return ::MoveWindow(m_hWnd, prcWindow->left, prcWindow->top, prcWindow->right - prcWindow->left, prcWindow->bottom - prcWindow->top, fRepaint);
}

__inline BOOL CWindow::GetWindowRect(LPRECT prcWindow)
{
    return ::GetWindowRect(m_hWnd, prcWindow);
}

__inline BOOL CWindow::GetClientRect(LPRECT prcClient)
{
    return ::GetClientRect(m_hWnd, prcClient);
}

__inline BOOL CWindow::ScreenToClient(LPPOINT ppt)
{
    return ::ScreenToClient(m_hWnd, ppt);
}

__inline BOOL CWindow::ScreenToClient(LPRECT prc)
{
    if(!::ScreenToClient(m_hWnd, (LPPOINT)&prc->left))
    {
        return FALSE;
    }

    return ::ScreenToClient(m_hWnd, (LPPOINT)&prc->right);
}

__inline LRESULT CWindow::SendDlgItemMessage(int nItemId, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return ::SendDlgItemMessage(m_hWnd, nItemId, uMsg, wParam, lParam);
}

__inline HWND CWindow::GetDlgItem(int nItemId)
{
    return ::GetDlgItem(m_hWnd, nItemId);
}

__inline BOOL CWindow::SetDlgItemText(int nItemId, LPCTSTR pszString)
{
    return ::SetDlgItemText(m_hWnd, nItemId, pszString);
}

__inline BOOL CWindow::SetDlgItemInt(int nItemId, UINT nValue, BOOL fSigned)
{
    return ::SetDlgItemInt(m_hWnd, nItemId, nValue, fSigned);
}

__inline BOOL CWindow::GetDlgItemText(int nItemId, LPTSTR pszString, int nLength)
{
    return ::GetDlgItemText(m_hWnd, nItemId, pszString, nLength);
}

__inline UINT CWindow::GetDlgItemInt(int nItemId, LPBOOL pfTranslated, BOOL fSigned)
{
    return ::GetDlgItemInt(m_hWnd, nItemId, pfTranslated, fSigned);
}

__inline void CWindow::DragAcceptFiles(BOOL fAccept)
{
    ::DragAcceptFiles(m_hWnd, fAccept);
}

__inline BOOL CWindow::OnDropFiles(HDROP hDrop, LRESULT *plResult)
{
    return FALSE;
}

//
// Function templates don't work
//

template <class type> class CWindowCast
{
public:
    static type *Cast(CWindow *pWindow);
};

template <class type> type *CWindowCast<type>::Cast(CWindow *pWindow)
{
    if(!pWindow)
    {
        return NULL;
    }

    ASSERT(type::WNDTYPE == pWindow->m_nWindowType);

    return (type *)pWindow;
}

#endif // __cplusplus

//
// Generic window helpers
//

__inline void BeginWaitCursor(void)
{
    SetCursor(LoadCursor(NULL, IDC_WAIT));
}

__inline void EndWaitCursor(void)
{
    SetCursor(LoadCursor(NULL, IDC_ARROW));
}

__inline HICON LoadResourceIconLarge(UINT nResourceId)
{
    return (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(nResourceId), IMAGE_ICON, 32, 32, LR_SHARED);
}

__inline HICON LoadResourceIconSmall(UINT nResourceId)
{
    return (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(nResourceId), IMAGE_ICON, 16, 16, LR_SHARED);
}

__inline HMENU LoadPopupMenu(UINT nResourceId)
{
    HMENU                   hMenu;

    hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(nResourceId));

    return GetSubMenu(hMenu, 0);
}

#endif // __WNDWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\base\wndwrap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wndwrap.cpp
 *  Content:    Windows wrapper classes (aka My Mini MFC)
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#include "xactgui.h"

const HINSTANCE g_hInstance = GetModuleHandle(NULL);

TCHAR g_szAppTitle[0x100] = { 0 };

const DWORD CWindow::m_dwValidSignature = ' dnw';

#ifndef WNDWRAP_USE_SET_WINDOW_LONG

LIST_ENTRY CWindow::m_lstWindows = { 0 };

#endif // WNDWRAP_USE_SET_WINDOW_LONG


/****************************************************************************
 *
 *  CWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      UINT [in]: menu resource identifier, or 0.
 *      UINT [in]: accelerator resource identifier, or 0.
 *      UINT [in]: window type.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::CWindow"

CWindow::CWindow
(
    UINT                    nMenuId,
    UINT                    nAccelId,
    UINT                    nWindowType
)
:   m_dwSignature(m_dwValidSignature),
    m_nWindowType(nWindowType)
{

#ifndef WNDWRAP_USE_SET_WINDOW_LONG

    if(!m_lstWindows.Flink || !m_lstWindows.Blink)
    {
        ASSERT(!m_lstWindows.Flink && !m_lstWindows.Blink);
        InitializeListHead(&m_lstWindows);
    }
    
    InitializeListHead(&m_leWindows);

#endif // WNDWRAP_USE_SET_WINDOW_LONG

    InitializeListHead(&m_lstChildren);
    InitializeListHead(&m_leChildren);

    m_pParent = NULL;
    m_hWnd = NULL;
    m_hMenu = NULL;
    m_hAccel = NULL;
    m_fRedraw = TRUE;

    if(-1 != nMenuId)
    {
        m_hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(nMenuId));
    }

    if(-1 != nAccelId)
    {
        m_hAccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(nAccelId));
    }
}


/****************************************************************************
 *
 *  ~CWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::~CWindow"

CWindow::~CWindow
(
    void
)
{
    //
    // Destroy the window
    //
    
    Destroy();
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      LPCTSTR [in]: window class name.
 *      LPCTSTR [in]: window title.
 *      DWORD [in]: window extended style.
 *      DWORD [in]: window basic style.
 *      int [in]: window x-coordinate.
 *      int [in]: window y-coordinate.
 *      int [in]: window width.
 *      int [in]: window height.
 *      UINT [in]: child control identifier.
 *      LPVOID [in]: creation context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::Create"

BOOL
CWindow::Create
(
    CWindow *               pParent, 
    LPCTSTR                 pszClassName, 
    LPCTSTR                 pszWindowName, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight, 
    UINT                    nControlId,
    LPVOID                  pvParam
)
{
    WNDCLASSEX              wc  = { 0 };
    WINDOWCREATECTX         ctx;

    ASSERT(!m_pParent);
    m_pParent = pParent;

    //
    // Check to see if the window class uses our WindowProc to process
    // messages.  If it doesn't, pass the creation context directly to
    // CreateWindowEx instead of munging it.  We'll never get a WM_CREATE
    // message, so there's no point in changing the parameter. Also, some 
    // windows require specific data be passed to their WM_CREATE handler
    // (MDICLIENT for example).
    //

    wc.cbSize = sizeof(wc);
    
    if(GetClassInfoEx(g_hInstance, pszClassName, &wc))
    {
        if(WindowProc == wc.lpfnWndProc)
        {
            ctx.dwSignature = m_dwValidSignature;
            ctx.pWindow = this;
            ctx.pvContext = pvParam;

            pvParam = &ctx;
        }
    }
    
    if(!(m_hWnd = CreateWindowEx(dwExStyle, pszClassName, pszWindowName, dwStyle, x, y, nWidth, nHeight, GetHWND(pParent), m_hMenu ? m_hMenu : (HMENU)nControlId, g_hInstance, pvParam)))
    {
        return FALSE;
    }

    if(m_pParent)
    {
        InsertTailList(&m_pParent->m_lstChildren, &m_leChildren);
    }

    return TRUE;
}


/****************************************************************************
 *
 *  DispatchMessage
 *
 *  Description:
 *      Dispatches a message to the appropriate handler.
 *
 *  Arguments:
 *      LPMSG [in]: message.
 *
 *  Returns:  
 *      BOOL: TRUE if the message was dispatched.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::DispatchMessage"

BOOL
CWindow::DispatchMessage
(
    LPMSG                   pMsg
)
{
    BOOL                    fDispatched = FALSE;
    PLIST_ENTRY             pleEntry;
    CWindow *               pChild;

    //
    // See if any of our children can do anything with this message.  If they
    // cant, we don't have anything special to do.
    //

    for(pleEntry = m_lstChildren.Flink; pleEntry != &m_lstChildren; pleEntry = pleEntry->Flink)
    {
        pChild = CONTAINING_RECORD(pleEntry, CWindow, m_leChildren);

        if(fDispatched = pChild->DispatchMessage(pMsg))
        {
            break;
        }
    }

    if(!fDispatched && m_hAccel)
    {
        fDispatched = TranslateAccelerator(m_hWnd, m_hAccel, pMsg);
    }

    return fDispatched;
}


/****************************************************************************
 *
 *  WindowProc
 *
 *  Description:
 *      Main window message handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *
 *  Returns:  
 *      LRESULT: message result.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::WindowProc"

LPARAM CALLBACK
CWindow::WindowProc
(
    HWND                    hWnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    LRESULT                 lResult     = 0;
    CWindow *               pWindow;

    //
    // Get the "this" pointer from the window object
    // 
    // We're special-casing WM_CREATE because it actually contains the window
    // handle we use to add ourselves to the global window list.
    //
    
    if(WM_CREATE == uMsg)
    {
        pWindow = OnInitialCreate(hWnd, &lParam);
    }
    else
    {
        pWindow = GetWindowContext(hWnd);
    }

    if(!pWindow)
    {
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    //
    // Hand off to the message dispatcher
    //

    if(!pWindow->HandleMessage(uMsg, wParam, lParam, &lResult))
    {
        lResult = pWindow->DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    //
    // Special-case WM_DESTROY to delete the window object
    //

    if(WM_DESTROY == uMsg)
    {
        pWindow->Destroy();
        pWindow->Release();
    }

    return lResult;
}


/****************************************************************************
 *
 *  SetWindowContext
 *
 *  Description:
 *      Sets up HWND => CWindow mapping data.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      CWindow * [in]: window object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::SetWindowContext"

void
CWindow::SetWindowContext
(
    HWND                    hWnd,
    CWindow *               pWindow
)
{
    ASSERT(hWnd);
    ASSERT(pWindow);

#ifdef WNDWRAP_USE_SET_WINDOW_LONG

    SetWindowLong(hWnd, GWL_USERDATA, (LONG)pWindow);

#else // WNDWRAP_USE_SET_WINDOW_LONG

    InsertTailList(&m_lstWindows, &pWindow->m_leWindows);

#endif // WNDWRAP_USE_SET_WINDOW_LONG

}


/****************************************************************************
 *
 *  FreeWindowContext
 *
 *  Description:
 *      Frees HWND => CWindow mapping data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::FreeWindowContext"

void
CWindow::FreeWindowContext
(
    void
)
{

#ifdef WNDWRAP_USE_SET_WINDOW_LONG

    SetWindowLong(m_hWnd, GWL_USERDATA, 0);

#else // WNDWRAP_USE_SET_WINDOW_LONG

    RemoveEntryList(&m_leWindows);

#endif // WNDWRAP_USE_SET_WINDOW_LONG

}


/****************************************************************************
 *
 *  GetWindowContext
 *
 *  Description:
 *      Retrieves HWND => CWindow mapping data.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *
 *  Returns:  
 *      CWindow *: window object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::GetWindowContext"

CWindow *
CWindow::GetWindowContext
(
    HWND                    hWnd
)
{
    CWindow *               pWindow;
    PLIST_ENTRY             pleEntry;

#ifdef WNDWRAP_USE_SET_WINDOW_LONG

    pWindow = (CWindow *)GetWindowLong(hWnd, GWL_USERDATA);

#else //  WNDWRAP_USE_SET_WINDOW_LONG

    pleEntry = m_lstWindows.Flink;
    pWindow = NULL;
    
    while(pleEntry != &m_lstWindows)
    {
        pWindow = CONTAINING_RECORD(pleEntry, CWindow, m_leWindows);

        if(pWindow->m_hWnd)
        {
            if(hWnd == pWindow->m_hWnd)
            {
                break;
            }
        }

        pleEntry = pleEntry->Flink;
        pWindow = NULL;
    }

#endif //  WNDWRAP_USE_SET_WINDOW_LONG

    if(pWindow)
    {
        ASSERT(m_dwValidSignature == pWindow->m_dwSignature);
    }

    return pWindow;
}


/****************************************************************************
 *
 *  OnInitialCreate
 *
 *  Description:
 *      Peforms internal handling of the WM_CREATE message.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      LPARAM * [in/out]: message parameter 2.
 *
 *  Returns:  
 *      CWindow *: window object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::OnInitialCreate"

CWindow *
CWindow::OnInitialCreate
(
    HWND                    hWnd,
    LPARAM *                plParam
)
{
    CWindow *               pWindow     = NULL;
    LRESULT                 lResult     = 0;
    LPCREATESTRUCT          pCreate;
    LPMDICREATESTRUCT       pMdiCreate;
    LPCWINDOWCREATECTX      pCtx;
    BOOL                    fHandled;

    ASSERT(hWnd);
    ASSERT(plParam);

    //
    // Get the CWindow object from the message parameters
    //

    pCreate = (LPCREATESTRUCT)*plParam;
    ASSERT(pCreate);

    if(pCreate->dwExStyle & WS_EX_MDICHILD)
    {
        pMdiCreate = (LPMDICREATESTRUCT)pCreate->lpCreateParams;
        ASSERT(pMdiCreate);

        pCtx = (LPCWINDOWCREATECTX)pMdiCreate->lParam;
        ASSERT(pCtx);
    }
    else
    {
        pCtx = (LPCWINDOWCREATECTX)pCreate->lpCreateParams;
        ASSERT(pCtx);
    }

    ASSERT(m_dwValidSignature == pCtx->dwSignature);

    pWindow = pCtx->pWindow;
    ASSERT(pWindow);

    *plParam = (LPARAM)pCtx->pvContext;

    ASSERT(!pWindow->m_hWnd);
    pWindow->m_hWnd = hWnd;

    //
    // Store the HWND => CWindow lookup data
    //

    SetWindowContext(hWnd, pWindow);

    //
    // Increment the window object's reference count
    //

    pWindow->AddRef();

    return pWindow;
}


/****************************************************************************
 *
 *  Destroy
 *
 *  Description:
 *      Destroys the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::Destroy"

void
CWindow::Destroy
(
    void
)
{
    LRESULT                 lResult     = 0;
    PLIST_ENTRY             pleEntry;
    CWindow *               pChild;

    //
    // Call the OnDestroy handler
    //

    if(m_hWnd)
    {
        OnDestroy(&lResult);
    }

    //
    // Free the HWND => CWindow lookup data so we don't get any more messages
    //

    if(m_hWnd)
    {
        FreeWindowContext();
    }

    //
    // Detach all child windows
    //

    while((pleEntry = RemoveEntryList(m_lstChildren.Flink)) != &m_lstChildren)
    {
        pChild = CONTAINING_RECORD(pleEntry, CWindow, m_leChildren);

        pChild->Destroy();
    }

    //
    // Destroy the window
    //

    if(m_hWnd)
    {
        if((WNDTYPE_MDICHILD == m_nWindowType) && m_pParent)
        {
            m_pParent->SendMessage(WM_MDIDESTROY, (WPARAM)m_hWnd);
        }
        else
        {
            DestroyWindow(m_hWnd);
        }

        m_hWnd = NULL;
    }

    //
    // Detach from the parent
    //

    RemoveEntryList(&m_leChildren);
    m_pParent = NULL;

    //
    // Free resources
    //

    DestroyMenu(m_hMenu);
    m_hMenu = NULL;

    DestroyAcceleratorTable(m_hAccel);
    m_hMenu = NULL;
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::HandleMessage"

BOOL 
CWindow::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    // DPF_ABSOLUTE("%x %x %x %x", m_hWnd, uMsg, wParam, lParam);
    
    switch(uMsg)
    {
        //
        // Basic handlers
        //
        
        case WM_CREATE:
            fHandled = OnCreate((LPVOID)lParam, plResult);
            break;
        
        case WM_CLOSE:
            fHandled = OnClose(plResult);
            break;
        
        case WM_SIZE:
            fHandled = OnSize(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam), plResult);
            break;

        case WM_COMMAND:
            fHandled = OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, plResult);
            break;
        
        case WM_SYSCOMMAND:
            fHandled = OnSysCommand(wParam, plResult);
            break;
        
        case WM_NOTIFY:
            fHandled = OnNotify((LPNMHDR)lParam, plResult);
            break;

        case WM_ERASEBKGND:
            fHandled = OnEraseBackground((HDC)wParam, plResult);
            break;

        case WM_PAINT:
            fHandled = OnPaint(plResult);
            break;

        case WM_CONTEXTMENU:
            fHandled = OnContextMenu((HWND)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam), plResult);
            break;

        case WM_DROPFILES:
            fHandled = OnDropFiles((HDROP)wParam, plResult);
            break;
        
        //
        // Advanced handlers
        //

        case WM_HSCROLL:
            fHandled = OnScroll(SB_HORZ, LOWORD(wParam), (HWND)lParam, plResult);
            break;
        
        case WM_VSCROLL:
            fHandled = OnScroll(SB_VERT, LOWORD(wParam), (HWND)lParam, plResult);
            break;

        //
        // No handler
        //

        default:
            fHandled = FALSE;
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnScroll
 *
 *  Description:
 *      Handles WM_HSCROLL and WM_VSCROLL messages.  This method does partial
 *      handling of the message before handing off to the default handler.
 *
 *  Arguments:
 *      UINT [in]: scroll bar type (SB_HORZ/SB_VERT).
 *      UINT [in]: scroll request.
 *      HWND [in]: scroll bar window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::OnScroll"

BOOL
CWindow::OnScroll
(
    UINT                    nScrollBarType, 
    UINT                    nRequest, 
    HWND                    hWndScrollBar, 
    LRESULT *               plResult
)
{
    SCROLLINFO              si;

    if(SB_ENDSCROLL == nRequest)
    {
        return FALSE;
    }

    //
    // The WM_H/VSCROLL message sucks ass.  It doesn't actually update the
    // position or tell us anything valuable, so we have to do it manually.
    //

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if(!GetScrollInfo(m_hWnd, nScrollBarType, &si))
    {
        return FALSE;
    }

    switch(nRequest)
    {
        case SB_BOTTOM:
            si.nPos = si.nMin;
            break;

        case SB_TOP:
            si.nPos = si.nMax;
            break;

        case SB_LINEDOWN:
            si.nPos++;
            break;

        case SB_LINEUP:
            si.nPos--;
            break;

        case SB_PAGEDOWN:
            si.nPos += si.nPage;
            break;

        case SB_PAGEUP:
            si.nPos -= si.nPage;
            break;

        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;
    }

    si.nPos = min(si.nPos, si.nMax);
    si.nPos = max(si.nPos, si.nMin);

    SetScrollPos(m_hWnd, nScrollBarType, si.nPos, TRUE);

    //
    // Call the handler
    //

    OnScroll(nScrollBarType, hWndScrollBar, si.nPos, plResult);

    return TRUE;
}


/****************************************************************************
 *
 *  SetRedraw
 *
 *  Description:
 *      Toggles the redraw flag for this window.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to allow redraws.
 *
 *  Returns:  
 *      BOOL: prior value.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "SetRedraw"

BOOL 
CWindow::SetRedraw
(
    BOOL                    fRedraw
)
{
    const BOOL              fPrevious   = m_fRedraw;

    if(fPrevious != fRedraw)
    {
        m_fRedraw = fRedraw;

        SendMessage(WM_SETREDRAW, fRedraw);

        if(fRedraw)
        {
            InvalidateRect(m_hWnd, NULL, FALSE);
            UpdateWindow(m_hWnd);
        }
    }

    return fPrevious;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\ctltools.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/30/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ctltools.h
 *  Content:    Control tools.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/30/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __CTLTOOLS_H__
#define __CTLTOOLS_H__

#ifdef __cplusplus

//
// CTempSelectObject helper -- saves and restores the previous GDI object
//

class CTempSelectObject
{
protected:
    HGDIOBJ                 m_hgdiSave;
    HDC                     m_hdc;

public:
    CTempSelectObject(void);
    ~CTempSelectObject(void);

public:
    BOOL SelectObject(HDC hdc, HGDIOBJ hgdi);
    void RestoreObject(void);
};

__inline CTempSelectObject::CTempSelectObject(void)
{
    m_hgdiSave = NULL;
    m_hdc = NULL;
}

__inline CTempSelectObject::~CTempSelectObject(void)
{
    RestoreObject();
}

__inline BOOL CTempSelectObject::SelectObject(HDC hdc, HGDIOBJ hgdi)
{
    if(hgdi = ::SelectObject(hdc, hgdi))
    {
        if(HGDI_ERROR == hgdi)
        {
            return FALSE;
        }
    }

    if(m_hgdiSave)
    {
        ASSERT(hdc == m_hdc);
    }
    else
    {
        m_hgdiSave = hgdi;
        m_hdc = hdc;
    }

    return TRUE;
}

__inline void CTempSelectObject::RestoreObject(void)
{
    if(m_hdc && m_hgdiSave)
    {
        ::SelectObject(m_hdc, m_hgdiSave);
    }

    m_hgdiSave = NULL;
    m_hdc = NULL;
}

#endif // __cplusplus

#endif // __CTLTOOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\listview.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/7/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       listview.cpp
 *  Content:    List-view control wrapper class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/7/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactctl.h"

const LPCTSTR CListView::m_pszClassName = XACTGUI_MAKE_WNDCLASS_NAME("ListView");

BEGIN_DEFINE_STRUCT()
    HWND            hWnd;
    UINT            nSubItem;
    BOOL            fAscending;
END_DEFINE_STRUCT(LVSORTITEMDATA);


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      CListView * [in]: parent window.
 *      DWORD [in]: extended window style.
 *      DWORD [in]: window style.
 *      int [in]: x-coordinate.
 *      int [in]: y-coordinate.
 *      int [in]: width.
 *      int [in]: height.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewCtrl::Create"

BOOL
CListViewCtrl::Create
(
    CListView *             pParent, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight
)
{
    return CWindow::Create(pParent, WC_LISTVIEW, NULL, dwExStyle, dwStyle, x, y, nWidth, nHeight);
}


/****************************************************************************
 *
 *  CListView
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::CListView"

CListView::CListView
(
    void
)
{
    //
    // Initialize the type list
    //
    
    InitializeListHead(&m_lstTypes);

    //
    // Create the image lists
    //

    m_hLargeImageList = ImageList_Create(32, 32, ILC_COLOR16 | ILC_MASK, 0, 0x100);
    m_hSmallImageList = ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 0, 0x100);
}


/****************************************************************************
 *
 *  ~CListView
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::~CListView"

CListView::~CListView
(
    void
)
{
    CListViewType *         pType;
    PLIST_ENTRY             pleEntry;
    
    //
    // Free registered types
    //

    while((pleEntry = RemoveEntryList(m_lstTypes.Flink)) != &m_lstTypes)
    {
        pType = CONTAINING_RECORD(pleEntry, CListViewType, m_leTypes);

        RELEASE(pType);
    }

    //
    // Free the image lists
    //

    ImageList_Destroy(m_hLargeImageList);
    ImageList_Destroy(m_hSmallImageList);
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      UINT [in]: control identifier.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::Create"

BOOL
CListView::Create
(
    CWindow *               pParent, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    DWORD                   dwListExStyle,
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight, 
    UINT                    nControlId
)
{
    WNDCLASSEX              wc              = { 0 };
    DWORD                   adwStyles[2];

    //
    // Mask off and save the list-view specific style bits
    //

    adwStyles[0] = LOWORD(dwStyle);
    dwStyle &= ~adwStyles[0];

    adwStyles[1] = dwListExStyle;

    //
    // Register the window class
    //

    wc.cbSize = sizeof(wc);
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = g_hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName = m_pszClassName;

    RegisterClassEx(&wc);

    //
    // Create the window
    //

    return CWindow::Create(pParent, m_pszClassName, NULL, dwExStyle, dwStyle, x, y, nWidth, nHeight, nControlId, (LPVOID)&adwStyles);
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::HandleMessage"

BOOL 
CListView::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case LVM_FIXITEMINDICES:
            FixItemIndices();
            break;
        
        default:
            fHandled = CWindow::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnCreate"

BOOL
CListView::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    static const DWORD      dwExStyle   = 0;
    static const DWORD      dwStyle     = WS_CHILD | WS_VISIBLE | LVS_SHAREIMAGELISTS;
    const DWORD *           adwStyles   = (const DWORD *)pvContext;
    BOOL                    fSuccess;

    if(CWindow::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Create the list-view control
    //

    fSuccess = m_ListCtrl.Create(this, dwExStyle, dwStyle | adwStyles[0]);

    //
    // Set extended list-view style
    //

    if(fSuccess)
    {
        ListView_SetExtendedListViewStyle(m_ListCtrl, adwStyles[1]);
    }
    
    //
    // Set the image lists
    //

    if(fSuccess)
    {
        ASSERT(m_hLargeImageList);
        ASSERT(m_hSmallImageList);
        
        ListView_SetImageList(m_ListCtrl, m_hLargeImageList, LVSIL_NORMAL);
        ListView_SetImageList(m_ListCtrl, m_hSmallImageList, LVSIL_SMALL);

        ImageList_SetBkColor(m_hLargeImageList, ListView_GetBkColor(m_ListCtrl));
        ImageList_SetBkColor(m_hSmallImageList, ListView_GetBkColor(m_ListCtrl));
    }

    //
    // Success
    //

    if(!fSuccess)
    {
        *plResult = 0;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles WM_DESTROY messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnDestroy"

BOOL
CListView::OnDestroy
(
    LRESULT *               plResult
)
{
    if(CWindow::OnDestroy(plResult))
    {
        return TRUE;
    }

    ListView_DeleteAllItems(m_ListCtrl);

    return FALSE;
}


/****************************************************************************
 *
 *  OnDeleteItem
 *
 *  Description:
 *      Handles LVN_DELETEITEM notifications.
 *
 *  Arguments:
 *      LPNMLISTVIEW [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnDeleteItem"

void
CListView::OnDeleteItem
(
    LPNMLISTVIEW            pHdr
)
{
    CListViewItem *         pItem   = CListViewItem::PtrFromListIndex(this, pHdr->iItem);

    //
    // Notify the item
    //

    pItem->OnDelete();

    //
    // Post a message to ourselves to update the item indices *after* the
    // item has been deleted.
    //

    PostMessage(LVM_FIXITEMINDICES);
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles WM_SIZE messages.
 *
 *  Arguments:
 *      UINT [in]: resize type.
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnSize"

BOOL
CListView::OnSize
(
    UINT                    nType,
    UINT                    nWidth,
    UINT                    nHeight,
    LRESULT *               plResult
)
{
    if(CWindow::OnSize(nType, nWidth, nHeight, plResult))
    {
        return TRUE;
    }
    
    m_ListCtrl.MoveWindow(0, 0, nWidth, nHeight);

    return FALSE;
}


/****************************************************************************
 *
 *  OnNotify
 *
 *  Description:
 *      Handles WM_NOTIFY messages.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnNotify"

BOOL
CListView::OnNotify
(
    LPNMHDR                 pHdr,
    LRESULT *               plResult
)
{
    if(CWindow::OnNotify(pHdr, plResult))
    {
        return TRUE;
    }
    
    //
    // We're intercepting certain messages and passing the rest along to
    // the parent to be processed
    //
    
    switch(pHdr->code)
    {
        case LVN_DELETEITEM:
            OnDeleteItem((LPNMLISTVIEW)pHdr);
            break;

        case LVN_COLUMNCLICK:
            OnColumnClick((LPNMLISTVIEW)pHdr);
            break;

        case LVN_ENDLABELEDIT:
            *plResult = OnEndLabelEdit((LPNMLVDISPINFO)pHdr);
            return TRUE;

        case LVN_ITEMCHANGED:
            OnItemChanged((LPNMLISTVIEW)pHdr);
            break;

        case NM_DBLCLK:
        case NM_RETURN:
            OnDoubleClick(pHdr);
            break;
    };

    return FALSE;
}


/****************************************************************************
 *
 *  OnColumnClick
 *
 *  Description:
 *      Handles column-click notifications.
 *
 *  Arguments:
 *      LPNMLISTVIEW [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnColumnClick"

void
CListView::OnColumnClick
(
    LPNMLISTVIEW            pHdr
)
{
    //
    // Resort the list
    //

    Sort(pHdr->iSubItem, LVSORT_TOGGLE_DIRECTION);
}


/****************************************************************************
 *
 *  OnEndLabelEdit
 *
 *  Description:
 *      Handles item text editing.
 *
 *  Arguments:
 *      LPNMLVDISPINFO [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnEndLabelEdit"

BOOL
CListView::OnEndLabelEdit
(
    LPNMLVDISPINFO          pHdr
)
{
    CListViewItem *         pItem   = pItem->PtrFromListCtx(pHdr->item.lParam);

    if(!pHdr->item.pszText)
    {
        return FALSE;
    }

    if(!*pHdr->item.pszText)
    {
        return FALSE;
    }

    return pItem->OnEndLabelEdit(pHdr->item.pszText);
}


/****************************************************************************
 *
 *  OnItemChanged
 *
 *  Description:
 *      Handles notifications that an item has changed in some way.
 *
 *  Arguments:
 *      LPNMLISTVIEW [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnItemChanged"

void
CListView::OnItemChanged
(
    LPNMLISTVIEW            pHdr
)
{
    CListViewItem *         pItem   = pItem->PtrFromListCtx(pHdr->lParam);

    if(pHdr->uChanged & LVIF_STATE)
    {
        pItem->OnStateChanged(pHdr->uOldState, pHdr->uNewState);
    }
}


/****************************************************************************
 *
 *  OnDoubleClick
 *
 *  Description:
 *      Handles NM_DBLCLK notifications.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::OnDoubleClick"

void
CListView::OnDoubleClick
(
    LPNMHDR                 pHdr
)
{
    CListViewItem *         pItem   = NULL;

    //
    // Find the selected item or items and call the activation callback
    //

    while(pItem = GetNextItem(pItem, LVNI_SELECTED))
    {
        pItem->OnDoubleClick();
    }
}


/****************************************************************************
 *
 *  RegisterType
 *
 *  Description:
 *      Registers an item type.
 *
 *  Arguments:
 *      LPCTSTR [in]: type name.
 *      HICON [in]: type icon.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::RegisterType"

BOOL
CListView::RegisterType
(
    LPCTSTR                 pszText,
    HICON                   hLargeIcon,
    HICON                   hSmallIcon
)
{
    CListViewType *         pType;
    int                     nLargeImageIndex;
    int                     nSmallImageIndex;

    ASSERT(pszText);
    ASSERT(hLargeIcon);
    ASSERT(hSmallIcon);

    //
    // Make sure the type isn't already registered
    //

    if(FindRegisteredType(pszText))
    {
        return TRUE;
    }

    //
    // Add the icon to the image list
    //

    if(-1 == (nLargeImageIndex = ImageList_AddIcon(m_hLargeImageList, hLargeIcon)))
    {
        return FALSE;
    }

    if(-1 == (nSmallImageIndex = ImageList_AddIcon(m_hSmallImageList, hSmallIcon)))
    {
        return FALSE;
    }

    ASSERT(nLargeImageIndex == nSmallImageIndex);

    //
    // Add the type to the list
    //
    
    if(!(pType = NEW(CListViewType(this, pszText, nLargeImageIndex))))
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  InsertColumn
 *
 *  Description:
 *      Inserts a column into the list.
 *
 *  Arguments:
 *      LPCTSTR [in]: column header text.
 *      LVCTYPE [in]: column data type.
 *      BOOL [in]: sort flag.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::InsertColumn"

BOOL
CListView::InsertColumn
(
    LPCTSTR                 pszText,
    LVCTYPE                 nDataType,
    BOOL                    fSortAscending
)
{
    LVCOLUMN                lvc;
    
    //
    // Insert the column
    //

    lvc.mask = LVCF_SUBITEM | LVCF_TEXT;
    lvc.pszText = (LPTSTR)pszText;
    lvc.iSubItem = m_nColumnCount;

    if(-1 == ListView_InsertColumn(m_ListCtrl, m_nColumnCount, &lvc))
    {
        return FALSE;
    }

    //
    // Save the column's data
    //

    m_aColumnData[m_nColumnCount].nHeaderStringId = -1;
    m_aColumnData[m_nColumnCount].nDataType = nDataType;
    m_aColumnData[m_nColumnCount].fSortAscending = fSortAscending;

    //
    // Resize the column
    //

    ResizeColumn(m_nColumnCount);

    //
    // Increment the column count
    //

    m_nColumnCount++;

    return TRUE;
}


/****************************************************************************
 *
 *  InsertColumns
 *
 *  Description:
 *      Inserts columns into the list.
 *
 *  Arguments:
 *      LPCLVCOLUMNDATA [in]: column data.
 *      UINT [in]: column count.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::InsertColumns"

BOOL
CListView::InsertColumns
(
    LPCLVCOLUMNDATA         paColumnData,
    UINT                    nColumnCount
)
{
    BOOL                    fSuccess    = TRUE;
    BOOL                    fRedraw;

    fRedraw = SetRedraw(FALSE);

    while(fSuccess && nColumnCount--)
    {
        fSuccess = InsertColumn(FormatStringResourceStatic(paColumnData->nHeaderStringId), paColumnData->nDataType, paColumnData->fSortAscending);

        paColumnData++;
    }

    SetRedraw(fRedraw);

    return fSuccess;
}


/****************************************************************************
 *
 *  Sort
 *
 *  Description:
 *      Sorts item data.
 *
 *  Arguments:
 *      UINT [in]: column index, or -1 to use the most recent sort column.
 *      DWORD [in]: sort flags.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::Sort"

void
CListView::Sort
(
    UINT                    nColumnIndex,
    DWORD                   dwFlags
)
{
    LVSORTITEMDATA          SortData;
    
    //
    // If the column index is -1, use the last column someone sorted by
    //
    
    if(-1 == nColumnIndex)
    {
        nColumnIndex = m_nLastSortColumn;
    }
    
    //
    // Set up sort data
    //
    
    ASSERT(nColumnIndex < m_nColumnCount);

    SortData.hWnd = m_ListCtrl;
    SortData.nSubItem = nColumnIndex;

    if(dwFlags & LVSORT_FORCE_ASCENDING)
    {
        ASSERT(!(dwFlags & (LVSORT_FORCE_DECENDING | LVSORT_TOGGLE_DIRECTION)));
        SortData.fAscending = TRUE;
    }
    else if(dwFlags & LVSORT_FORCE_DECENDING)
    {
        ASSERT(!(dwFlags & (LVSORT_FORCE_ASCENDING | LVSORT_TOGGLE_DIRECTION)));
        SortData.fAscending = FALSE;
    }
    else
    {
        SortData.fAscending = m_aColumnData[nColumnIndex].fSortAscending;

        if(dwFlags & LVSORT_TOGGLE_DIRECTION)
        {
            m_aColumnData[nColumnIndex].fSortAscending = !m_aColumnData[nColumnIndex].fSortAscending;
        }
    }

    //
    // Sort
    //

    if(LVCTYPE_NUMBER == m_aColumnData[nColumnIndex].nDataType)
    {
        ListView_SortItemsEx(m_ListCtrl, NumericSortCallback, &SortData);
    }
    else
    {
        ListView_SortItemsEx(m_ListCtrl, StringSortCallback, &SortData);
    }

    //
    // Save the column index
    //
    
    m_nLastSortColumn = nColumnIndex;

    //
    // Any time we sort, all the child items lose their item indices because
    // the stupid list-view stores everything as an index, not a handle.
    //

    FixItemIndices();
}


/****************************************************************************
 *
 *  StringSortCallback
 *
 *  Description:
 *      Sorting callback function for string columns.
 *
 *  Arguments:
 *      LPARAM [in]: item index 1.
 *      LPARAM [in]: item index 2.
 *      LPARAM [in]: sort context.
 *
 *  Returns:  
 *      int: negative value if the first item should precede the second, a 
 *           positive value if the first item should follow the second, or 
 *           zero if the two items are equivalent.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::StringSortCallback"

int
CListView::StringSortCallback
(
    LPARAM                  nItem0,
    LPARAM                  nItem1,
    LPARAM                  lContext
)
{
    LPCLVSORTITEMDATA       pContext            = (LPCLVSORTITEMDATA)lContext;
    CHAR                    szText[2][0x100];
    int                     nResult;
    
    ListView_GetItemText(pContext->hWnd, nItem0, pContext->nSubItem, szText[0], NUMELMS(szText[0]));
    ListView_GetItemText(pContext->hWnd, nItem1, pContext->nSubItem, szText[1], NUMELMS(szText[1]));

    nResult = strcmp(szText[0], szText[1]);

    if(!pContext->fAscending)
    {
        nResult = -nResult;
    }

    return nResult;
}


/****************************************************************************
 *
 *  NumericSortCallback
 *
 *  Description:
 *      Sorting callback function for numeric columns.
 *
 *  Arguments:
 *      LPARAM [in]: item index 1.
 *      LPARAM [in]: item index 2.
 *      LPARAM [in]: sort context.
 *
 *  Returns:  
 *      int: negative value if the first item should precede the second, a 
 *           positive value if the first item should follow the second, or 
 *           zero if the two items are equivalent.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::NumericSortCallback"

int
CListView::NumericSortCallback
(
    LPARAM                  nItem0,
    LPARAM                  nItem1,
    LPARAM                  lContext
)
{
    LPCLVSORTITEMDATA       pContext            = (LPCLVSORTITEMDATA)lContext;
    CHAR                    szText[2][0x100];
    int                     nValue[2];
    int                     nResult;
    
    ListView_GetItemText(pContext->hWnd, nItem0, pContext->nSubItem, szText[0], NUMELMS(szText[0]));
    ListView_GetItemText(pContext->hWnd, nItem1, pContext->nSubItem, szText[1], NUMELMS(szText[1]));

    nValue[0] = atoi(szText[0]);
    nValue[1] = atoi(szText[1]);

    nResult = nValue[0] - nValue[1];

    if(!pContext->fAscending)
    {
        nResult = -nResult;
    }

    return nResult;
}


/****************************************************************************
 *
 *  ResizeColumn
 *
 *  Description:
 *      Auto-resizes a list-view column.
 *
 *  Arguments:
 *      UINT [in]: column index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::ResizeColumn"

void
CListView::ResizeColumn
(
    UINT                    nColumn
)
{

#if 0

    static const int        nMarginWidth    = 7;
    CHAR                    szText[0x100];
    int                     nLargestWidth;
    int                     nWidth;
    int                     nCount;
    LVCOLUMN                lvc;
    int                     i;
    
    //
    // Get the width of the column header text
    //

    lvc.mask = LVCF_TEXT;
    lvc.pszText = szText;
    lvc.cchTextMax = NUMELMS(szText);
    
    ListView_GetColumn(m_ListCtrl, nColumn, &lvc);

    nLargestWidth = ListView_GetStringWidth(m_ListCtrl, szText);

    //
    // Get the width of each item in the column
    //

    nCount = ListView_GetItemCount(m_ListCtrl);
    
    for(i = 0; i < nCount; i++)
    {
        ListView_GetItemText(m_ListCtrl, i, nColumn, szText, NUMELMS(szText));

        if((nWidth = ListView_GetStringWidth(m_ListCtrl, szText)) > nLargestWidth)
        {
            nLargestWidth = nWidth;
        }
    }

    //
    // Factor in the margins and set the column width
    //

    ListView_SetColumnWidth(m_ListCtrl, nColumn, nLargestWidth + (nMarginWidth * 2));

#else

    int                     nColumnWidth;
    int                     nItemWidth;
    BOOL                    fRedraw;

    fRedraw = SetRedraw(FALSE);

    //
    // Resize based on the column header
    //

    ListView_SetColumnWidth(m_ListCtrl, nColumn, LVSCW_AUTOSIZE_USEHEADER);

    nColumnWidth = ListView_GetColumnWidth(m_ListCtrl, nColumn);

    //
    // Resize based on the item text
    //

    ListView_SetColumnWidth(m_ListCtrl, nColumn, LVSCW_AUTOSIZE);

    nItemWidth = ListView_GetColumnWidth(m_ListCtrl, nColumn);

    //
    // Use the larger of the two
    //

    ListView_SetColumnWidth(m_ListCtrl, nColumn, max(nColumnWidth, nItemWidth));

    SetRedraw(fRedraw);

#endif

}


/****************************************************************************
 *
 *  ResizeColumns
 *
 *  Description:
 *      Resizes all columns in a list view.
 *
 *  Arguments:
 *      HWND [in]: list view window handle.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::ResizeColumns"

void
CListView::ResizeColumns
(
    void
)
{
    BOOL                    fRedraw;
    UINT                    i;
    
    fRedraw = SetRedraw(FALSE);
    
    for(i = 0; i < m_nColumnCount; i++)
    {
        ResizeColumn(i);
    }

    SetRedraw(fRedraw);
}


/****************************************************************************
 *
 *  FindRegisteredType
 *
 *  Description:
 *      Finds a registered item type.
 *
 *  Arguments:
 *      LPCTSTR [in]: type name.
 *
 *  Returns:  
 *      CListViewType *: registered type object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::FindRegisteredType"

CListViewType *
CListView::FindRegisteredType
(
    LPCTSTR                 pszText
)
{
    PLIST_ENTRY             pleEntry;
    CListViewType *         pType;

    ASSERT(pszText);
    
    for(pleEntry = m_lstTypes.Flink; pleEntry != &m_lstTypes; pleEntry = pleEntry->Flink)
    {
        pType = CONTAINING_RECORD(pleEntry, CListViewType, m_leTypes);

        if(!_tcsicmp(pszText, pType->m_szName))
        {
            return pType;
        }
    }

    return NULL;
}


/****************************************************************************
 *
 *  FixItemIndices
 *
 *  Description:
 *      Resets the item indices for all items in the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::FixItemIndices"

void
CListView::FixItemIndices
(
    void
)
{
    int                     nItemCount;
    int                     nItem;
    CListViewItem *         pItem;

    nItemCount = ListView_GetItemCount(m_ListCtrl);

    for(nItem = 0; nItem < nItemCount; nItem++)
    {
        pItem = PtrFromListIndex(nItem);

        pItem->m_nItemIndex = nItem;
    }
}


/****************************************************************************
 *
 *  GetNextItem
 *
 *  Description:
 *      Gets the next related item.
 *
 *  Arguments:
 *      CListViewItem * [in]: current item, or NULL.
 *      DWORD [in]: relationship flags.
 *
 *  Returns:  
 *      CListViewItem *: next item.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::GetNextItem"

CListViewItem *
CListView::GetNextItem
(
    CListViewItem *         pItem,
    DWORD                   dwFlags
)
{
    int                     nItem;

    nItem = ListView_GetNextItem(m_ListCtrl.m_hWnd, pItem ? pItem->m_nItemIndex : -1, dwFlags);

    if(-1 == nItem)
    {
        return NULL;
    }

    return PtrFromListIndex(nItem);
}


/****************************************************************************
 *
 *  SelectAll
 *
 *  Description:
 *      Selects or de-selects all items.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to select; FALSE to de-select.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListView::SelectAll"

void
CListView::SelectAll
(
    BOOL                    fSelected
)
{
    CListViewItem *         pItem   = NULL;

    while(pItem = GetNextItem(pItem, LVNI_ALL))
    {
        pItem->SetSelection(fSelected);
    }
}


/****************************************************************************
 *
 *  CListViewType
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CListView * [in]: parent tree.
 *      LPCTSTR [in]: type name.
 *      int [in]: image list index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewType::CListViewType"

CListViewType::CListViewType
(
    CListView *             pList,
    LPCTSTR                 pszText,
    int                     nImageIndex
)
{
    ASSERT(pList);
    ASSERT(pszText);
    
    InsertTailListUninit(&pList->m_lstTypes, &m_leTypes);

    _tcscpy(m_szName, pszText);

    m_nImageIndex = nImageIndex;
}


/****************************************************************************
 *
 *  ~CListViewType
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewType::~CListViewType"

CListViewType::~CListViewType
(
    void
)
{
    RemoveEntryList(&m_leTypes);
}


/****************************************************************************
 *
 *  CListViewItem
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::CListViewItem"

CListViewItem::CListViewItem
(
    void
)
{
    m_nItemIndex = -1;
}


/****************************************************************************
 *
 *  ~CListViewItem
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::~CListViewItem"

CListViewItem::~CListViewItem
(
    void
)
{
    Remove();
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the list-view item.
 *
 *  Arguments:
 *      CListView * [in]: parent list.
 *      LPCTSTR [in]: item text.
 *      LPCTSTR [in]: item type.
 *      LPVOID [in]: item context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::Create"

BOOL
CListViewItem::Create
(
    CListView *             pList,
    LPCTSTR                 pszText,
    LPCTSTR                 pszType,
    LPVOID                  pvContext
)
{
    LVITEM                  lvi    = { 0 };
    CListViewType *         pType;

    ASSERT(pList);

    m_pList = pList;
    m_pvContext = pvContext;

    //
    // Insert the item
    //

    lvi.mask = LVIF_PARAM;
    lvi.lParam = (LPARAM)this;

    if(pszText)
    {
        lvi.mask |= LVIF_TEXT;
        lvi.pszText = (LPTSTR)pszText;
    }

    if(pszType)
    {
        if(pType = pList->FindRegisteredType(pszType))
        {
            lvi.mask |= LVIF_IMAGE;
            lvi.iImage = pType->m_nImageIndex;
        }
        else
        {
            DPF_ERROR("Type not registered");
        }
    }

    if(-1 == (m_nItemIndex = ListView_InsertItem(pList->m_ListCtrl, &lvi)))
    {
        return -1;
    }

    //
    // Resort the list
    //

    pList->Sort(-1, 0);

    return m_nItemIndex;
}


/****************************************************************************
 *
 *  Remove
 *
 *  Description:
 *      Removes the item from the list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::Remove"

void
CListViewItem::Remove
(
    void
)
{
    CListView *             pList   = m_pList;
    
    if(pList && (-1 != m_nItemIndex))
    {
        ListView_DeleteItem(pList->m_ListCtrl, m_nItemIndex);
        pList->FixItemIndices();
    }
}


/****************************************************************************
 *
 *  SetColumnText
 *
 *  Description:
 *      Sets the item text.
 *
 *  Arguments:
 *      int [in]: column index.
 *      LPCTSTR [in]: text.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::SetColumnText"

void
CListViewItem::SetColumnText
(
    int                     nColumnIndex,
    LPCTSTR                 pszText
)
{
    LVITEM                  lvi;

    if(!m_pList)
    {
        return;
    }

    lvi.mask = TVIF_TEXT;
    lvi.pszText = (LPTSTR)pszText;
    lvi.iItem = m_nItemIndex;
    lvi.iSubItem = nColumnIndex;

    ListView_SetItem(m_pList->m_ListCtrl, &lvi);
}


/****************************************************************************
 *
 *  SetColumnValue
 *
 *  Description:
 *      Sets the item text.
 *
 *  Arguments:
 *      int [in]: column index.
 *      int [in]: value.
 *      BOOL [in]: TRUE for signed, FALSE for unsigned.
 *      BOOL [in]: TRUE to format (comma-separated thousands)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::SetColumnValue"

void
CListViewItem::SetColumnValue
(
    int                     nColumnIndex,
    int                     nValue,
    BOOL                    fSigned,
    BOOL                    fFormat
)
{
    TCHAR                   szText[0x100];

    FormatNumber(nValue, fSigned, fFormat, szText);
    
    SetColumnText(nColumnIndex, szText);
}


/****************************************************************************
 *
 *  PtrFromListIndex
 *
 *  Description:
 *      Converts a list item index to an object pointer.
 *
 *  Arguments:
 *      CListView * [in]: list view object.
 *      int [in]: list item index.
 *
 *  Returns:  
 *      CListViewItem *: object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::PtrFromListIndex"

CListViewItem *
CListViewItem::PtrFromListIndex
(
    CListView *             pList,
    int                     nItem
)
{
    LVITEM                  lvi;

    ASSERT(pList);

    lvi.mask = TVIF_PARAM;
    lvi.iItem = nItem;
    lvi.iSubItem = 0;

    if(!ListView_GetItem(pList->m_ListCtrl, &lvi))
    {
        return NULL;
    }

    return PtrFromListCtx(lvi.lParam);
}


/****************************************************************************
 *
 *  GetListIndex
 *
 *  Description:
 *      Gets the current list index for this object.  Because the list-view
 *      maintains it's own list that is (stupidly) referenced by index, but
 *      those indexes change due to sorting and user interaction, we never
 *      store the item index.  This means that every time we want to 
 *      reference the object in the list, we have to find it.  Suckity suck.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      int: item index.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::GetListIndex"

int
CListViewItem::GetListIndex
(
    void
)
{
    LVFINDINFO              lvfi;

    if(!m_pList)
    {
        return -1;
    }

    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)this;
    
    return m_pList->m_ListCtrl.SendMessage(LVM_FINDITEM, (WPARAM)-1, (LPARAM)&lvfi);
}


/****************************************************************************
 *
 *  OnDelete
 *
 *  Description:
 *      Handles TVN_DELETEITEM notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::OnDelete"

void
CListViewItem::OnDelete
(
    void
)
{
    m_pList = NULL;
    m_nItemIndex = -1;
    m_pvContext = NULL;
}


/****************************************************************************
 *
 *  SetSelection
 *
 *  Description:
 *      Sets the selection state for the item.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to select; FALSE to de-select.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CListViewItem::SetSelection"

void
CListViewItem::SetSelection
(
    BOOL                    fSelected
)
{
    ListView_SetItemState(m_pList->m_ListCtrl, m_nItemIndex, LVIS_SELECTED, LVIS_SELECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\toolbar.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/11/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       toolbar.cpp
 *  Content:    Toolbar and toolbar dock classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/11/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactctl.h"


/****************************************************************************
 *
 *  CToolBar
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::CToolBar"

CToolBar::CToolBar
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CToolBar
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::~CToolBar"

CToolBar::~CToolBar
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      UINT [in]: control identifier.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::Create"

BOOL
CToolBar::Create
(
    CWindow *               pParent, 
    DWORD                   dwExStyle,
    DWORD                   dwStyle,
    UINT                    nControlId
)
{
    dwStyle |= WS_CHILD;

    //
    // Create the window
    //

    if(!CWindow::Create(pParent, TOOLBARCLASSNAME, NULL, dwExStyle, dwStyle, 0, 0, 0, 0, nControlId))
    {
        return FALSE;
    }

    SendMessage(TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(TB_SETBITMAPSIZE, 0, MAKELONG(16, 16));

    //
    // Add the standard image lists
    //

    SendMessage(CCM_SETVERSION, 5, 0);

    LoadImages(IDB_HIST_SMALL_COLOR, 0, HINST_COMMCTRL);
    LoadImages(IDB_STD_SMALL_COLOR, 0, HINST_COMMCTRL);
    LoadImages(IDB_VIEW_SMALL_COLOR, 0, HINST_COMMCTRL);

    return TRUE;
}


/****************************************************************************
 *
 *  LoadImages
 *
 *  Description:
 *      Loads a bitmap into the toolbar's image list.
 *
 *  Arguments:
 *      UINT [in]: bitmap resource identifier.
 *      UINT [in]: bitmap image count.
 *
 *  Returns:  
 *      UINT: index of the image list added.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::LoadImages"

UINT
CToolBar::LoadImages
(
    UINT                    nBitmapId,
    UINT                    nImageCount,
    HINSTANCE               hInstance
)
{
    const UINT              nImageList  = m_nNextImageList;
    TBADDBITMAP             tbab;
    
    if(nImageList >= NUMELMS(m_anFirstImageIndex))
    {
        DPF_ERROR("Too many image lists");
        return 0;
    }

    if(!hInstance)
    {
        hInstance = g_hInstance;
    }

    m_nNextImageList++;

    tbab.hInst = hInstance;
    tbab.nID = nBitmapId;

    m_anFirstImageIndex[nImageList] = SendMessage(TB_ADDBITMAP, nImageCount, (LPARAM)&tbab);
    
    return nImageList;
}


/****************************************************************************
 *
 *  AddButton
 *
 *  Description:
 *      Adds a button to the toolbar.
 *
 *  Arguments:
 *      UINT [in]: bitmap index.
 *      UINT [in]: image index (within the bitmap).
 *      UINT [in]: command identifier.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::AddButton"

BOOL
CToolBar::AddButton
(
    UINT                    nBitmapIndex,
    UINT                    nImageIndex,
    UINT                    nCommandId
)
{
    TBBUTTON                tbb = { 0 };
    
    tbb.iBitmap = m_anFirstImageIndex[nBitmapIndex] + nImageIndex;
    tbb.idCommand = nCommandId;
    tbb.fsState = TBSTATE_ENABLED;
    tbb.fsStyle = BTNS_BUTTON;
    
    return SendMessage(TB_ADDBUTTONS, 1, (LPARAM)&tbb);
}


/****************************************************************************
 *
 *  AddSeparator
 *
 *  Description:
 *      Adds a separator to the toolbar.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::AddSeparator"

BOOL
CToolBar::AddSeparator
(
    void
)
{
    TBBUTTON                tbb = { 0 };
    
    tbb.fsStyle = BTNS_SEP;
    
    return SendMessage(TB_ADDBUTTONS, 1, (LPARAM)&tbb);
}


/****************************************************************************
 *
 *  SetButtonState
 *
 *  Description:
 *      Sets the state-mask for a button.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      DWORD [in]: valid bit mask.
 *      DWORD [in]: button state.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CToolBar::SetButtonState"

BOOL
CToolBar::SetButtonState
(
    UINT                    nCommandId, 
    DWORD                   dwMask,
    DWORD                   dwState
)
{
    TBBUTTONINFO            tbbi    = { 0 };
    
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE;

    if(!SendMessage(TB_GETBUTTONINFO, nCommandId, (LPARAM)&tbbi))
    {
        return FALSE;
    }

    tbbi.fsState &= ~dwMask;
    tbbi.fsState |= dwState;
    
    return SendMessage(TB_SETBUTTONINFO, nCommandId, (LPARAM)&tbbi);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\toolbar.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/11/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       toolbar.h
 *  Content:    Toolbar and toolbar dock classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/11/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __TOOLBAR_H__
#define __TOOLBAR_H__

#ifdef __cplusplus

//
// ToolBar wrapper class
//

class CToolBar
    : public CWindow
{
public:
    
    // 
    // Default image lists
    //

    enum
    {
        IML_HIST,
        IML_STD,
        IML_VIEW,
        IML_COUNT
    };

protected:
    UINT                    m_anFirstImageIndex[64];
    UINT                    m_nNextImageList;

public:
    CToolBar(void);
    virtual ~CToolBar(void);

public:
    // Creation
    virtual BOOL Create(CWindow *pParent, DWORD dwExStyle, DWORD dwStyle, UINT nControlId);

    // Toolbar buttons
    virtual UINT LoadImages(UINT nBitmapId, UINT nImageCount, HINSTANCE hInstance = NULL);
    virtual BOOL AddButton(UINT nBitmapIndex, UINT nImageIndex, UINT nCommandId);
    virtual BOOL AddSeparator(void);
    virtual BOOL EnableButton(UINT nCommandId, BOOL fEnable);
    virtual BOOL SetButtonState(UINT nCommandId, DWORD dwMask, DWORD dwState);
};

__inline BOOL CToolBar::EnableButton(UINT nCommandId, BOOL fEnable)
{
    return SendMessage(TB_ENABLEBUTTON, nCommandId, MAKELONG(fEnable, 0));
}

#endif // __cplusplus

#endif // __TOOLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\treeview.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/7/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       treeview.cpp
 *  Content:    Tree-view control wrapper class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/7/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactctl.h"

const LPCTSTR CTreeView::m_pszClassName = XACTGUI_MAKE_WNDCLASS_NAME("TreeView");


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      CTreeView * [in]: parent window.
 *      DWORD [in]: extended window style.
 *      DWORD [in]: window style.
 *      int [in]: x-coordinate.
 *      int [in]: y-coordinate.
 *      int [in]: width.
 *      int [in]: height.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewCtrl::Create"

BOOL
CTreeViewCtrl::Create
(
    CTreeView *             pParent, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight
)
{
    return CWindow::Create(pParent, WC_TREEVIEW, NULL, dwExStyle, dwStyle, x, y, nWidth, nHeight);
}


/****************************************************************************
 *
 *  CTreeView
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::CTreeView"

CTreeView::CTreeView
(
    void
)
{
    //
    // Initialize the type list
    //
    
    InitializeListHead(&m_lstTypes);

    //
    // Create the image list
    //

    m_hImageList = ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 0, 0x100);
}


/****************************************************************************
 *
 *  ~CTreeView
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::~CTreeView"

CTreeView::~CTreeView
(
    void
)
{
    CTreeViewType *         pType;
    PLIST_ENTRY             pleEntry;
    
    //
    // Free registered types
    //

    while((pleEntry = RemoveEntryList(m_lstTypes.Flink)) != &m_lstTypes)
    {
        pType = CONTAINING_RECORD(pleEntry, CTreeViewType, m_leTypes);

        RELEASE(pType);
    }

    //
    // Free the image list
    //

    ImageList_Destroy(m_hImageList);
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      UINT [in]: control identifier.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::Create"

BOOL
CTreeView::Create
(
    CWindow *               pParent, 
    DWORD                   dwExStyle, 
    DWORD                   dwStyle, 
    int                     x, 
    int                     y, 
    int                     nWidth, 
    int                     nHeight, 
    UINT                    nControlId
)
{
    WNDCLASSEX              wc              = { 0 };
    DWORD                   dwTreeStyle;

    //
    // Mask off and save the tree-view specific style bits
    //

    dwTreeStyle = LOWORD(dwStyle);
    dwStyle &= ~dwTreeStyle;

    //
    // Save the control identifier
    //

    m_nControlId = nControlId;

    //
    // Register the window class
    //

    wc.cbSize = sizeof(wc);
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = g_hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName = m_pszClassName;

    RegisterClassEx(&wc);

    //
    // Create the window
    //

    return CWindow::Create(pParent, m_pszClassName, NULL, dwExStyle, dwStyle, x, y, nWidth, nHeight, nControlId, (LPVOID)dwTreeStyle);
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnCreate"

BOOL
CTreeView::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    static const DWORD      dwExStyle   = 0;
    static const DWORD      dwStyle     = WS_CHILD | WS_VISIBLE | TVS_INFOTIP;
    const DWORD             dwTreeStyle = (DWORD)pvContext;
    BOOL                    fSuccess;

    if(CWindow::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }
    
    //
    // Create the tree-view control
    //

    fSuccess = m_TreeCtrl.Create(this, dwExStyle, dwStyle | dwTreeStyle);
    
    //
    // Set the image list
    //

    if(fSuccess)
    {
        ASSERT(m_hImageList);
        
        TreeView_SetImageList(m_TreeCtrl, m_hImageList, TVSIL_NORMAL);
        
        ImageList_SetBkColor(m_hImageList, TreeView_GetBkColor(m_TreeCtrl));
    }

    //
    // Success
    //

    if(!fSuccess)
    {
        *plResult = 0;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles WM_DESTROY messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnDestroy"

BOOL
CTreeView::OnDestroy
(
    LRESULT *               plResult
)
{
    if(CWindow::OnDestroy(plResult))
    {
        return TRUE;
    }

    TreeView_DeleteAllItems(m_TreeCtrl.m_hWnd);

    return FALSE;
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles WM_SIZE messages.
 *
 *  Arguments:
 *      UINT [in]: resize type.
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnSize"

BOOL
CTreeView::OnSize
(
    UINT                    nType,
    UINT                    nWidth,
    UINT                    nHeight,
    LRESULT *               plResult
)
{
    if(CWindow::OnSize(nType, nWidth, nHeight, plResult))
    {
        return TRUE;
    }
    
    m_TreeCtrl.MoveWindow(0, 0, nWidth, nHeight);

    return FALSE;
}


/****************************************************************************
 *
 *  OnContextMenu
 *
 *  Description:
 *      Handles WM_CONTEXTMENU messages.
 *
 *  Arguments:
 *      HWND [in]: window the user clicked in.
 *      int [in]: mouse x-coordinate.
 *      int [in]: mouse y-coordinate.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnContextMenu"

BOOL
CTreeView::OnContextMenu
(
    HWND                    hWndFocus,
    int                     x,
    int                     y,
    LRESULT *               plResult
)
{
    TVHITTESTINFO           htti    = { 0 };
    CTreeViewItem *         pItem;
    
    if(CWindow::OnContextMenu(hWndFocus, x, y, plResult))
    {
        return TRUE;
    }

    htti.pt.x = x;
    htti.pt.y = y;

    m_TreeCtrl.ScreenToClient(&htti.pt);

    TreeView_HitTest(m_TreeCtrl, &htti);

    if(!htti.hItem)
    {
        return FALSE;
    }

    TreeView_Select(m_TreeCtrl, htti.hItem, TVGN_CARET);
    
    pItem = pItem->PtrFromTreeItem(this, htti.hItem);

    return pItem->OnContextMenu(hWndFocus, x, y, plResult);
}


/****************************************************************************
 *
 *  OnNotify
 *
 *  Description:
 *      Handles WM_NOTIFY messages.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnNotify"

BOOL
CTreeView::OnNotify
(
    LPNMHDR                 pHdr,
    LRESULT *               plResult
)
{
    if(CWindow::OnNotify(pHdr, plResult))
    {
        return TRUE;
    }
    
    //
    // We're intercepting certain messages and passing the rest along to
    // the parent to be processed
    //
    
    switch(pHdr->code)
    {
        case TVN_DELETEITEM:
            OnDeleteItem((LPNMTREEVIEW)pHdr);
            break;

        case NM_DBLCLK:
        case NM_RETURN:
            OnDoubleClick(pHdr);
            break;

        case TVN_GETINFOTIP:
            OnGetInfoTip((LPNMTVGETINFOTIP)pHdr);
            break;

        case TVN_ENDLABELEDIT:
            *plResult = OnEndLabelEdit((LPNMTVDISPINFO)pHdr);
            return TRUE;
    };

    return FALSE;
}


/****************************************************************************
 *
 *  OnDeleteItem
 *
 *  Description:
 *      Handles TVN_DELETEITEM notifications.
 *
 *  Arguments:
 *      LPNMTREEVIEW [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnDeleteItem"

void
CTreeView::OnDeleteItem
(
    LPNMTREEVIEW            pHdr
)
{
    CTreeViewItem *         pItem   = CTreeViewItem::PtrFromTreeCtx(pHdr->itemOld.lParam);

    pItem->OnDelete();
}


/****************************************************************************
 *
 *  OnDoubleClick
 *
 *  Description:
 *      Handles NM_DBLCLK notifications.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnDoubleClick"

void
CTreeView::OnDoubleClick
(
    LPNMHDR                 pHdr
)
{
    CTreeViewItem *         pItem;

    //
    // Find the selected item or items and call the activation callback
    //

    if(!(pItem = GetSelection()))
    {
        return;
    }

    pItem->OnDoubleClick();
}


/****************************************************************************
 *
 *  OnGetInfoTip
 *
 *  Description:
 *      Handles TVN_GETINFOTIP notifications.
 *
 *  Arguments:
 *      LPNMTVGETINFOTIP [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnGetInfoTip"

void
CTreeView::OnGetInfoTip
(
    LPNMTVGETINFOTIP        pHdr
)
{
    CTreeViewItem *         pItem   = CTreeViewItem::PtrFromTreeCtx(pHdr->lParam);

    ASSERT(pItem);
    pItem->OnGetInfoTip(pHdr->pszText, pHdr->cchTextMax);
}


/****************************************************************************
 *
 *  OnEndLabelEdit
 *
 *  Description:
 *      Handles TVN_ENDLABELEDIT notifications.
 *
 *  Arguments:
 *      LPNMTVDISPINFO [in]: notification header.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::OnEndLabelEdit"

BOOL
CTreeView::OnEndLabelEdit
(
    LPNMTVDISPINFO          pHdr
)
{
    CTreeViewItem *         pItem   = CTreeViewItem::PtrFromTreeCtx(pHdr->item.lParam);

    if(!pHdr->item.pszText)
    {
        return FALSE;
    }

    if(!*pHdr->item.pszText)
    {
        return FALSE;
    }

    return pItem->OnEndLabelEdit(pHdr->item.pszText);
}


/****************************************************************************
 *
 *  RegisterType
 *
 *  Description:
 *      Registers an item type.
 *
 *  Arguments:
 *      LPCTSTR [in]: type name.
 *      HICON [in]: type icon.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::RegisterType"

BOOL
CTreeView::RegisterType
(
    LPCTSTR                 pszText,
    HICON                   hIcon
)
{
    CTreeViewType *         pType;
    int                     nImageIndex;

    ASSERT(pszText);
    ASSERT(hIcon);

    //
    // Make sure the type isn't already registered
    //

    if(FindRegisteredType(pszText))
    {
        return TRUE;
    }

    //
    // Add the icon to the image list
    //

    if(-1 == (nImageIndex = ImageList_AddIcon(m_hImageList, hIcon)))
    {
        return FALSE;
    }

    //
    // Add the type to the list
    //
    
    if(!(pType = NEW(CTreeViewType(this, pszText, nImageIndex))))
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  FindRegisteredType
 *
 *  Description:
 *      Finds a registered item type.
 *
 *  Arguments:
 *      LPCTSTR [in]: type name.
 *
 *  Returns:  
 *      CTreeViewType *: registered type object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::FindRegisteredType"

CTreeViewType *
CTreeView::FindRegisteredType
(
    LPCTSTR                 pszText
)
{
    PLIST_ENTRY             pleEntry;
    CTreeViewType *         pType;

    ASSERT(pszText);
    
    for(pleEntry = m_lstTypes.Flink; pleEntry != &m_lstTypes; pleEntry = pleEntry->Flink)
    {
        pType = CONTAINING_RECORD(pleEntry, CTreeViewType, m_leTypes);

        if(!_tcsicmp(pszText, pType->m_szName))
        {
            return pType;
        }
    }

    return NULL;
}


/****************************************************************************
 *
 *  GetSelection
 *
 *  Description:
 *      Gets the currently selected tree item.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      CTreeViewItem *: selected item.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::GetSelection"

CTreeViewItem *
CTreeView::GetSelection
(
    void
)
{
    HTREEITEM               hTreeItem;
    
    if(!(hTreeItem = TreeView_GetSelection(m_TreeCtrl)))
    {
        return NULL;
    }

    return CTreeViewItem::PtrFromTreeItem(this, hTreeItem);
}


/****************************************************************************
 *
 *  GetNextItem
 *
 *  Description:
 *      Gets the next related item.
 *
 *  Arguments:
 *      CTreeViewItem * [in]: current item, or NULL.
 *      DWORD [in]: relationship flags.
 *
 *  Returns:  
 *      CTreeViewItem *: next item.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::GetNextItem"

CTreeViewItem *
CTreeView::GetNextItem
(
    CTreeViewItem *         pItem,
    DWORD                   dwFlags
)
{
    HTREEITEM               hItem;

    hItem = TreeView_GetNextItem(m_TreeCtrl.m_hWnd, pItem ? pItem->m_hTreeItem : NULL, dwFlags);

    if(!hItem)
    {
        return NULL;
    }

    return PtrFromTreeItem(hItem);
}


/****************************************************************************
 *
 *  PtrFromTreeItem
 *
 *  Description:
 *      Converts a tree-view item handle to a CTreeViewItem object pointer.
 *
 *  Arguments:
 *      HTREEITEM [in]: item handle.
 *
 *  Returns:  
 *      CTreeViewItem *: object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeView::PtrFromTreeItem"

CTreeViewItem *
CTreeView::PtrFromTreeItem
(
    HTREEITEM               hItem
)
{
    TVITEM                  tvi;

    tvi.mask = TVIF_PARAM;
    tvi.hItem = hItem;

    if(!TreeView_GetItem(m_TreeCtrl.m_hWnd, &tvi))
    {
        return NULL;
    }

    return CTreeViewItem::PtrFromTreeCtx(tvi.lParam);
}


/****************************************************************************
 *
 *  CTreeViewType
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CTreeView * [in]: parent tree.
 *      LPCTSTR [in]: type name.
 *      int [in]: image list index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewType::CTreeViewType"

CTreeViewType::CTreeViewType
(
    CTreeView *             pTree,
    LPCTSTR                 pszText,
    int                     nImageIndex
)
{
    ASSERT(pTree);
    ASSERT(pszText);
    
    InsertTailListUninit(&pTree->m_lstTypes, &m_leTypes);

    _tcscpy(m_szName, pszText);

    m_nImageIndex = nImageIndex;
}


/****************************************************************************
 *
 *  ~CTreeViewType
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewType::~CTreeViewType"

CTreeViewType::~CTreeViewType
(
    void
)
{
    RemoveEntryList(&m_leTypes);
}


/****************************************************************************
 *
 *  CTreeViewItem
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::CTreeViewItem"

CTreeViewItem::CTreeViewItem
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CTreeViewItem
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::~CTreeViewItem"

CTreeViewItem::~CTreeViewItem
(
    void
)
{
    Remove();
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the item.
 *
 *  Arguments:
 *      CTreeView * [in]: tree control.
 *      CTreeViewItem * [in]: parent item.
 *      LPCTSTR [in]: item name.
 *      LPCTSTR [in]: item type.
 *      LPVOID [in]: item context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::Create"

BOOL
CTreeViewItem::Create
(
    CTreeView *             pTree,
    CTreeViewItem *         pParentItem,
    LPCTSTR                 pszText,
    LPCTSTR                 pszType,
    LPVOID                  pvContext
)
{
    TVINSERTSTRUCT          tvi     = { 0 };
    CTreeViewType *         pType;

    ASSERT(pTree);
    ASSERT(!m_hTreeItem);

    m_pTree = pTree;
    m_pvContext = pvContext;

    tvi.hParent = pParentItem ? pParentItem->m_hTreeItem : NULL;
    tvi.hInsertAfter = TVI_SORT;
    
    tvi.item.mask = TVIF_PARAM;
    tvi.item.lParam = (LPARAM)this;

    if(pszText)
    {
        tvi.item.mask |= TVIF_TEXT;
        tvi.item.pszText = (LPTSTR)pszText;
    }

    if(pszType)
    {
        if(pType = pTree->FindRegisteredType(pszType))
        {
            tvi.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            tvi.item.iImage = pType->m_nImageIndex;
            tvi.item.iSelectedImage = pType->m_nImageIndex;
        }
        else
        {
            DPF_ERROR("Type not registered");
        }
    }

    return MAKEBOOL(m_hTreeItem = TreeView_InsertItem(pTree->m_TreeCtrl, &tvi));
}


/****************************************************************************
 *
 *  Remove
 *
 *  Description:
 *      Removes the item from the tree.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::Remove"

void
CTreeViewItem::Remove
(
    void
)
{
    if(m_hTreeItem && m_pTree)
    {
        TreeView_DeleteItem(m_pTree->m_TreeCtrl, m_hTreeItem);
    }
}


/****************************************************************************
 *
 *  OnDelete
 *
 *  Description:
 *      Handles TVN_DELETEITEM notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::OnDelete"

void
CTreeViewItem::OnDelete
(
    void
)
{
    m_hTreeItem = NULL;
    m_pTree = NULL;
    m_pvContext = NULL;
}


/****************************************************************************
 *
 *  SetText
 *
 *  Description:
 *      Sets the item text.
 *
 *  Arguments:
 *      LPCTSTR [in]: text.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::SetText"

void
CTreeViewItem::SetText
(
    LPCTSTR                 pszText
)
{
    TVITEM                  tvi;

    if(!m_pTree || !m_hTreeItem)
    {
        return;
    }

    tvi.mask = TVIF_TEXT;
    tvi.hItem = m_hTreeItem;
    tvi.pszText = (LPTSTR)pszText;

    TreeView_SetItem(m_pTree->m_TreeCtrl, &tvi);
}


/****************************************************************************
 *
 *  PtrFromTreeItem
 *
 *  Description:
 *      Converts a tree-view item handle to a CTreeViewItem object pointer.
 *
 *  Arguments:
 *      CTreeView * [in]: tree view.
 *      HTREEITEM [in]: item handle.
 *
 *  Returns:  
 *      CTreeViewItem *: object.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTreeViewItem::PtrFromTreeItem"

CTreeViewItem *
CTreeViewItem::PtrFromTreeItem
(
    CTreeView *             pTree,
    HTREEITEM               hItem
)
{
    return pTree->PtrFromTreeItem(hItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\listview.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/7/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       listview.h
 *  Content:    List-view control wrapper class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/7/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __LISTVIEW_H__
#define __LISTVIEW_H__

DEFINELPTYPE(NMLVDISPINFO);

//
// List-view column types
//

BEGIN_DEFINE_ENUM()
    LVCTYPE_STRING = 0,
    LVCTYPE_NUMBER,
END_DEFINE_ENUM(LVCTYPE);

//
// List-view column data
//

BEGIN_DEFINE_STRUCT()
    UINT    nHeaderStringId;
    LVCTYPE nDataType;
    BOOL    fSortAscending;
END_DEFINE_STRUCT(LVCOLUMNDATA);

//
// List-view sorting flags
//

#define LVSORT_TOGGLE_DIRECTION 0x00000001
#define LVSORT_FORCE_ASCENDING  0x00000002
#define LVSORT_FORCE_DECENDING  0x00000004

#ifdef __cplusplus

//
// Forward declarations
//

class CListView;
class CListViewType;
class CListViewItem;

//
// List view child window
//

class CListViewCtrl
    : public CWindow
{
public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(CListView *pParent, DWORD dwExStyle, DWORD dwStyle, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT, int nWidth = CW_USEDEFAULT, int nHeight = CW_USEDEFAULT);
};

__inline ULONG CListViewCtrl::AddRef(void)
{
    return 1;
}

__inline ULONG CListViewCtrl::Release(void)
{
    return 1;
}

//
// List view wrapper
//

class CListView
    : public CWindow
{
    friend class CListViewType;
    friend class CListViewItem;

public:
    static const LPCTSTR    m_pszClassName;         // Window class name
    CListViewCtrl           m_ListCtrl;             // List view control

protected:                                          
    HIMAGELIST              m_hLargeImageList;      // Large icon image list
    HIMAGELIST              m_hSmallImageList;      // Small icon image list
    LIST_ENTRY              m_lstTypes;             // Registered types
    LVCOLUMNDATA            m_aColumnData[32];      // Column data
    UINT                    m_nColumnCount;         // Column count
    UINT                    m_nLastSortColumn;      // Last column the list was sorted by
   
public:
    CListView(void);
    virtual ~CListView(void);

public:
    // Creation
    virtual BOOL Create(CWindow *pParent, DWORD dwExStyle, DWORD dwStyle, DWORD dwListExStyle, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT, int nWidth = CW_USEDEFAULT, int nHeight = CW_USEDEFAULT, UINT nControlId = 0);

    // Columns
    virtual BOOL InsertColumn(LPCTSTR pszHeader, LVCTYPE nType = LVCTYPE_STRING, BOOL fSortAscending = TRUE);
    virtual BOOL InsertColumns(LPCLVCOLUMNDATA paColumnData, UINT nCount);
    virtual void ResizeColumn(UINT nColumnIndex);
    virtual void ResizeColumns(void);

    // Items
    virtual int GetSelectedCount(void);
    virtual CListViewItem *GetNextItem(CListViewItem *pItem, DWORD dwFlags);
    virtual CListViewItem *PtrFromListIndex(int nItemIndex);
    virtual void SelectAll(BOOL fSelected);

    // Sorting
    virtual void Sort(UINT nColumnIndex, DWORD dwFlags);

    // Item types
    virtual BOOL RegisterType(LPCTSTR pszText, HICON hIconLarge, HICON hIconSmall);
    virtual CListViewType *FindRegisteredType(LPCTSTR pszText);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnNotify(LPNMHDR pHdr, LRESULT *plResult);

    // Notification handlers
    virtual void OnColumnClick(LPNMLISTVIEW pHdr);
    virtual void OnDeleteItem(LPNMLISTVIEW pHdr);
    virtual BOOL OnEndLabelEdit(LPNMLVDISPINFO pHdr);
    virtual void OnItemChanged(LPNMLISTVIEW pHdr);
    virtual void OnDoubleClick(LPNMHDR pHdr);

    // List view stupidity
    virtual void FixItemIndices(void);

private:
    // Sort callbacks
    static int CALLBACK StringSortCallback(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    static int CALLBACK NumericSortCallback(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
};

__inline int CListView::GetSelectedCount(void)
{
    return ListView_GetSelectedCount(m_ListCtrl.m_hWnd);
}

//
// List-view item type
//

class CListViewType
    : public CRefCount
{
public:
    LIST_ENTRY              m_leTypes;          // Registered type list entry
    TCHAR                   m_szName[0x100];    // Type name
    int                     m_nImageIndex;      // Image list index

public:
    CListViewType(CListView *pList, LPCTSTR pszText, int nImageIndex);
    virtual ~CListViewType(void);
};

//
// List-view item
//

class CListViewItem
{
    friend class CListView;

public:
    CListView *             m_pList;            // Parent list object
    int                     m_nItemIndex;       // List item index
    LPVOID                  m_pvContext;        // Item context

public:
    CListViewItem(void);
    virtual ~CListViewItem(void);

public:
    // Creation/destruction
    virtual BOOL Create(CListView *pList, LPCTSTR pszText, LPCTSTR pszType, LPVOID pvContext = NULL);
    virtual void Remove(void);

    // Item properties
    virtual void SetText(LPCTSTR pszText);
    virtual void SetColumnText(int nColumnIndex, LPCTSTR pszText);
    virtual void SetColumnValue(int nColumnIndex, int nValue, BOOL fSigned = TRUE, BOOL fFormat = FALSE);
    virtual HWND EditLabel(void);
    virtual void SetSelection(BOOL fSelected);

    // Operators
    static CListViewItem *PtrFromListCtx(LPARAM lParam);
    static CListViewItem *PtrFromListIndex(CListView *pList, int nItemIndex);

    // Event handlers
    virtual void OnDelete(void);
    virtual BOOL OnEndLabelEdit(LPCTSTR pszText);
    virtual void OnStateChanged(DWORD dwOldState, DWORD dwNewState);
    virtual void OnDoubleClick(void);

    // List helpers
    virtual int GetListIndex(void);
};

__inline void CListViewItem::SetText(LPCTSTR pszText)
{
    SetColumnText(0, pszText);
}

__inline HWND CListViewItem::EditLabel(void)
{
    return ListView_EditLabel(m_pList->m_ListCtrl.m_hWnd, m_nItemIndex);
}

__inline CListViewItem *CListViewItem::PtrFromListCtx(LPARAM lParam)
{
    return (CListViewItem *)lParam;
}

__inline CListViewItem *CListView::PtrFromListIndex(int nItemIndex)
{
    return CListViewItem::PtrFromListIndex(this, nItemIndex);
}

__inline BOOL CListViewItem::OnEndLabelEdit(LPCTSTR pszText)
{
    return FALSE;
}

__inline void CListViewItem::OnStateChanged(DWORD dwOldState, DWORD dwNewState)
{
}

__inline void CListViewItem::OnDoubleClick(void)
{
}

#endif // __cplusplus

#endif // __LISTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\treeview.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/7/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       treeview.h
 *  Content:    Tree-view control wrapper class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/7/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __TREEVIEW_H__
#define __TREEVIEW_H__

#ifdef __cplusplus

//
// Forward declarations
//

class CTreeView;
class CTreeViewType;
class CTreeViewItem;

//
// Tree-view child window
//

class CTreeViewCtrl
    : public CWindow
{
public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(CTreeView *pParent, DWORD dwExStyle, DWORD dwStyle, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT, int nWidth = CW_USEDEFAULT, int nHeight = CW_USEDEFAULT);
};

__inline ULONG CTreeViewCtrl::AddRef(void)
{
    return 1;
}

__inline ULONG CTreeViewCtrl::Release(void)
{
    return 1;
}

//
// Tree-view wrapper object
//

class CTreeView
    : public CWindow
{
    friend class CTreeViewType;
    friend class CTreeViewItem;

public:
    static const LPCTSTR    m_pszClassName;     // Window class name
    CTreeViewCtrl           m_TreeCtrl;         // Tree-view child window

protected:
    HIMAGELIST              m_hImageList;       // Image list
    LIST_ENTRY              m_lstTypes;         // Registered types
    UINT                    m_nControlId;       // Control identifier
   
public:
    CTreeView(void);
    virtual ~CTreeView(void);

public:
    // Creation
    virtual BOOL Create(CWindow *pParent, DWORD dwExStyle, DWORD dwStyle, int x = CW_USEDEFAULT, int y = CW_USEDEFAULT, int nWidth = CW_USEDEFAULT, int nHeight = CW_USEDEFAULT, UINT nControlId = 0);

    // Item types
    virtual BOOL RegisterType(LPCTSTR pszText, HICON hIcon);
    virtual CTreeViewType *FindRegisteredType(LPCTSTR pszText);

    // Items
    virtual CTreeViewItem *GetSelection(void);
    virtual CTreeViewItem *GetNextItem(CTreeViewItem *pItem, DWORD dwFlags);
    virtual CTreeViewItem *PtrFromTreeItem(HTREEITEM hItem);

    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult);
    virtual BOOL OnNotify(LPNMHDR pHdr, LRESULT *plResult);

    // Notification handlers
    virtual void OnDeleteItem(LPNMTREEVIEW pHdr);
    virtual void OnDoubleClick(LPNMHDR pHdr);
    virtual void OnGetInfoTip(LPNMTVGETINFOTIP pHdr);
    virtual BOOL OnEndLabelEdit(LPNMTVDISPINFO pHdr);
};

//
// Tree-view item type
//

class CTreeViewType
    : public CRefCount
{
public:
    LIST_ENTRY              m_leTypes;          // Registered type list entry
    TCHAR                   m_szName[0x100];    // Type name
    int                     m_nImageIndex;      // Image list index

public:
    CTreeViewType(CTreeView *pTree, LPCTSTR pszText, int nImageIndex);
    virtual ~CTreeViewType(void);
};

//
// Tree-view item
//

class CTreeViewItem
{
    friend class CTreeView;

public:
    CTreeView *             m_pTree;            // Parent tree object
    HTREEITEM               m_hTreeItem;        // Tree item handle
    LPVOID                  m_pvContext;        // Item context

public:
    CTreeViewItem(void);
    virtual ~CTreeViewItem(void);

public:
    // Creation/destruction
    virtual BOOL Create(CTreeView *pTree, CTreeViewItem *pParentItem, LPCTSTR pszText, LPCTSTR pszType, LPVOID pvContext = NULL);
    virtual void Remove(void);

    // Item properties
    virtual void SetText(LPCTSTR pszText);
    virtual HWND EditLabel(void);

    // Operators
    static CTreeViewItem *PtrFromTreeCtx(LPARAM lParam);
    static CTreeViewItem *PtrFromTreeItem(CTreeView *pTree, HTREEITEM hItem);

    // Message handlers
    virtual BOOL OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult);

    // Notification handlers
    virtual void OnDoubleClick(void);
    virtual void OnDelete(void);    
    virtual void OnGetInfoTip(LPTSTR pszText, int cchTextMax);
    virtual BOOL OnEndLabelEdit(LPCTSTR pszText);
};

__inline HWND CTreeViewItem::EditLabel(void)
{
    return TreeView_EditLabel(m_pTree->m_TreeCtrl.m_hWnd, m_hTreeItem);
}

__inline CTreeViewItem *CTreeViewItem::PtrFromTreeCtx(LPARAM lParam)
{
    return (CTreeViewItem *)lParam;
}

__inline void CTreeViewItem::OnDoubleClick(void)
{
}

__inline BOOL CTreeViewItem::OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult)
{
    return FALSE;
}

__inline void CTreeViewItem::OnGetInfoTip(LPTSTR pszText, int cchTextMax)
{
    *pszText = 0;
}

__inline BOOL CTreeViewItem::OnEndLabelEdit(LPCTSTR pszText)
{
    return FALSE;
}

#endif // __cplusplus

#endif // __PRJTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\waveform.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1/30/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveform.cpp
 *  Content:    Renders a waveform bitmap.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/30/2002   dereks  Created.
 *
 ****************************************************************************/

// #define WAVEFORM_USE_XBOX_COLORS

#include "xactctl.h"

const UINT CWaveformRenderer::m_nDefaultScale = 16;
const UINT CWaveformRenderer::m_nDefaultResolution = 8;

const LPCTSTR CWaveformControl::m_pszClassName = TEXT("WAVEFORM");
const UINT CWaveformControl::m_nSectionDivisor = 4;


/****************************************************************************
 *
 *  CWaveformRenderer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::CWaveformRenderer"

CWaveformRenderer::CWaveformRenderer
(
    void
)
{
    m_nState = WAVEFORM_RENDER_FULL;
    m_hWndDisplay = NULL;
    m_hdcDraw = NULL;
    m_hbrActiveBackground = NULL;
    m_hbrInactiveBackground = NULL;
    m_hpnWaveform = NULL;
    m_pvWaveData = NULL;
    m_cbWaveData = NULL;
    m_cbHorizOffset = 0;
    m_nScale = m_nDefaultScale;
    m_nResolution = m_nDefaultResolution;

    SetColors(NULL);
    SetRect(NULL);
}


/****************************************************************************
 *
 *  ~CWaveformRenderer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::~CWaveformRenderer"

CWaveformRenderer::~CWaveformRenderer
(
    void
)
{
    if(m_hdcDraw)
    {
        DeleteDC(m_hdcDraw);
    }

    if(m_hbrActiveBackground)
    {
        DeleteObject(m_hbrActiveBackground);
    }

    if(m_hbrInactiveBackground)
    {
        DeleteObject(m_hbrInactiveBackground);
    }

    if(m_hpnWaveform)
    {
        DeleteObject(m_hpnWaveform);
    }
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      HWND [in]: window handle to draw on.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::Initialize"

BOOL
CWaveformRenderer::Initialize
(
    HWND                    hWnd
)
{
    BOOL                    fSuccess    = TRUE;
    HDC                     hdc;
    RECT                    rc;

    m_hWndDisplay = hWnd;
    
    // 
    // Create the offscreen device context
    //
    
    hdc = GetDC(hWnd);

    if(!(m_hdcDraw = CreateCompatibleDC(hdc)))
    {
        DPF_ERROR("Failed to create compatible DC");
        fSuccess = FALSE;
    }

    if(hdc)
    {
        ReleaseDC(hWnd, hdc);
    }

    //
    // Default the default bitmap size to the client area of the window
    //

    if(fSuccess)
    {
        GetClientRect(hWnd, &rc);

        fSuccess = SetRect(&rc);
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  SetRect
 *
 *  Description:
 *      Sets the drawing rectangle.
 *
 *  Arguments:
 *      LPCRECT [in]: rectangle.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::SetRect"

BOOL
CWaveformRenderer::SetRect
(
    LPCRECT                 prcDrawing
)
{
    if(prcDrawing)
    {
        m_rcDisplay = *prcDrawing;
    }
    else
    {
        ZeroMemory(&m_rcDisplay, sizeof(m_rcDisplay));
    }

    m_nWidth = m_rcDisplay.right - m_rcDisplay.left;
    m_nHeight = m_rcDisplay.bottom - m_rcDisplay.top;

    SetRenderState(WAVEFORM_RENDER_CREATEBITMAP);

    return TRUE;
}


/****************************************************************************
 *
 *  SetColors
 *
 *  Description:
 *      Sets the colors used by the renderer.
 *
 *  Arguments:
 *      LPCWAVEFORMCOLORS [in]: color data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::SetColors"

BOOL
CWaveformRenderer::SetColors
(
    LPCWAVEFORMCOLORS       pColors
)
{
    if(pColors)
    {
        m_colors = *pColors;
    }
    else
    {

#ifdef WAVEFORM_USE_XBOX_COLORS

        m_colors.rgbBackground = RGB(0, 0, 0);
        m_colors.rgbInactiveBackground = RGB(127, 127, 127);
        m_colors.rgbWaveform = RGB(0, 255, 0);

#else // WAVEFORM_USE_XBOX_COLORS

        m_colors.rgbBackground = GetSysColor(COLOR_WINDOW);
        m_colors.rgbInactiveBackground = GetSysColor(COLOR_GRAYTEXT);
        m_colors.rgbWaveform = GetSysColor(COLOR_WINDOWTEXT);

#endif // WAVEFORM_USE_XBOX_COLORS

    }

    SetRenderState(WAVEFORM_RENDER_DRAWINGTOOLS);

    return TRUE;
}


/****************************************************************************
 *
 *  SetWaveData
 *
 *  Description:
 *      Sets the wave data used by the renderer.
 *
 *  Arguments:
 *      LPCWAVEFORMDATA [in]: wave data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::SetWaveData"

BOOL
CWaveformRenderer::SetWaveData
(
    LPCWAVEFORMDATA         pWaveData
)
{
    BOOL                    fSuccess    = TRUE;
    
    if(pWaveData)
    {
        if(!pWaveData->pwfxFormat)
        {
            DPF_ERROR("No wave data format supplied");
            fSuccess = FALSE;
        }
        else if(!pWaveData->pvWaveData)
        {
            DPF_ERROR("No wave data buffer supplied");
            fSuccess = FALSE;
        }
        else if(!pWaveData->cbWaveData)
        {
            DPF_ERROR("No wave data size supplied");
            fSuccess = FALSE;
        }
        else if(WAVE_FORMAT_PCM != pWaveData->pwfxFormat->wFormatTag)
        {
            DPF_ERROR("Format not PCM");
            fSuccess = FALSE;
        }

        if(fSuccess)
        {
            CopyMemory(&m_wfxFormat, pWaveData->pwfxFormat, sizeof(m_wfxFormat) - sizeof(m_wfxFormat.cbSize));

            m_wfxFormat.cbSize = 0;

            m_pvWaveData = pWaveData->pvWaveData;
            m_cbWaveData = pWaveData->cbWaveData;
            m_cbHorizOffset = 0;
        }
    }
    else
    {
        ZeroMemory(&m_wfxFormat, sizeof(m_wfxFormat));

        m_pvWaveData = NULL;
        m_cbWaveData = NULL;
    }

    SetRenderState(WAVEFORM_RENDER_REDRAW);

    return fSuccess;
}


/****************************************************************************
 *
 *  SetOffset
 *
 *  Description:
 *      Sets the bitmap Offset.
 *
 *  Arguments:
 *      UINT [in]: bitmap width.
 *      UINT [in]: bitmap height.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::SetOffset"

BOOL
CWaveformRenderer::SetOffset
(
    UINT                    cbOffset
)
{
    m_cbHorizOffset = cbOffset;

    SetRenderState(WAVEFORM_RENDER_REDRAW);

    return TRUE;
}


/****************************************************************************
 *
 *  SetScale
 *
 *  Description:
 *      Sets the scaling factor used to render the wave data.
 *
 *  Arguments:
 *      UINT [in]: scale.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::SetScale"

BOOL
CWaveformRenderer::SetScale
(
    UINT                    nScale
)
{
    m_nScale = max(1, nScale);

    SetRenderState(WAVEFORM_RENDER_REDRAW);

    return TRUE;
}


/****************************************************************************
 *
 *  Render
 *
 *  Description:
 *      Draws the waveform.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::Render"

BOOL
CWaveformRenderer::Render
(
    HDC                     hdcDisplay,
    LPCRECT                 prcUpdate
)
{
    BOOL                    fSuccess    = TRUE;
    BOOL                    fReleaseDC  = FALSE;

    if(!hdcDisplay)
    {
        if(!(hdcDisplay = GetDC(m_hWndDisplay)))
        {
            DPF_ERROR("Failed to get display DC");
            fSuccess = FALSE;
        }

        if(fSuccess)
        {
            fReleaseDC = TRUE;
        }
    }

    if(fSuccess && (m_nState >= WAVEFORM_RENDER_CREATEBITMAP))
    {
        fSuccess = CreateBitmap(hdcDisplay);
    }

    if(fSuccess && (m_nState >= WAVEFORM_RENDER_DRAWINGTOOLS))
    {
        fSuccess = CreateDrawingTools();
    }
    
    if(fSuccess && (m_nState >= WAVEFORM_RENDER_REDRAW))
    {
        fSuccess = DrawBackground();
    }

    if(fSuccess && (m_nState >= WAVEFORM_RENDER_REDRAW))
    {
        fSuccess = DrawWaveform();
    }

    if(fSuccess)
    {
        m_nState = WAVEFORM_RENDER_NONE;
    }

    if(fSuccess)
    {
        fSuccess = DisplayBitmap(hdcDisplay, prcUpdate);
    }

    if(fReleaseDC)
    {
        ReleaseDC(m_hWndDisplay, hdcDisplay);
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  CreateBitmap
 *
 *  Description:
 *      (Re)creates the waveform bitmap.
 *
 *  Arguments:
 *      HDC [in]: display DC.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::CreateBitmap"

BOOL
CWaveformRenderer::CreateBitmap
(
    HDC                     hdcDisplay
)
{
    BOOL                    fSuccess    = TRUE;
    HBITMAP                 hbmDraw;

    ASSERT(hdcDisplay);

    if(!(hbmDraw = CreateCompatibleBitmap(hdcDisplay, m_nWidth, m_nHeight)))
    {
        DPF_ERROR("Failed to create compatible bitmap");
        fSuccess = FALSE;
    }

    if(fSuccess)
    {
        if(hbmDraw = (HBITMAP)SelectObject(m_hdcDraw, hbmDraw))
        {
            if(HGDI_ERROR == hbmDraw)
            {
                DPF_ERROR("Failed to select the off-screen bitmap");
                fSuccess = FALSE;
            }
            else
            {
                DeleteObject(hbmDraw);
            }
        }
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  CreateDrawingTools
 *
 *  Description:
 *      Creates the drawing objects.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::CreateDrawingTools"

BOOL
CWaveformRenderer::CreateDrawingTools
(
    void
)
{
    BOOL                    fSuccess        = TRUE;

    if(m_hbrActiveBackground)
    {
        DeleteObject(m_hbrActiveBackground);
        m_hbrActiveBackground = NULL;
    }

    if(m_hbrInactiveBackground)
    {
        DeleteObject(m_hbrActiveBackground);
        m_hbrActiveBackground = NULL;
    }

    if(m_hpnWaveform)
    {
        DeleteObject(m_hpnWaveform);
        m_hpnWaveform = NULL;
    }

    //
    // Create the background brushes
    //

    if(!(m_hbrActiveBackground = CreateSolidBrush(m_colors.rgbBackground)))
    {
        DPF_ERROR("Failed to create active background brush");
        fSuccess = FALSE;
    }

    if(fSuccess)
    {
        if(!(m_hbrInactiveBackground = CreateHatchBrush(HS_DIAGCROSS, m_colors.rgbInactiveBackground)))
        {
            DPF_ERROR("Failed to create inactive background brush");
            fSuccess = FALSE;
        }
    }

    //
    // Create the foreground pen
    //

    if(fSuccess)
    {
        if(!(m_hpnWaveform = CreatePen(PS_SOLID, 1, m_colors.rgbWaveform)))
        {
            DPF_ERROR("Failed to create waveform pen");
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  DrawBackground
 *
 *  Description:
 *      Draws the waveform background.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::DrawBackground"

BOOL
CWaveformRenderer::DrawBackground
(
    void
)
{
    const RECT              rc  = { 0, 0, m_nWidth, m_nHeight };
    
    ASSERT(m_hdcDraw);
    ASSERT(m_hbrActiveBackground);

    //
    // Paint the whole background as active.  The waveform render function
    // will repaint the inactive region for us
    //

    return FillRect(m_hdcDraw, &rc, m_hbrActiveBackground);
}


/****************************************************************************
 *
 *  DrawWaveform
 *
 *  Description:
 *      Draws the waveform.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::DrawWaveform"

BOOL
CWaveformRenderer::DrawWaveform
(
    void
)
{
    CTempSelectObject       SelectPen;
    BOOL                    fSuccess;

    ASSERT(m_hdcDraw);
    ASSERT(m_hpnWaveform);

    if(fSuccess = SelectPen.SelectObject(m_hdcDraw, m_hpnWaveform))
    {
        switch(m_wfxFormat.wBitsPerSample)
        {
            case 8:
                RenderWaveform((const unsigned char *)m_pvWaveData, 0x100, FALSE);
                break;

            case 16:
                RenderWaveform((const short *)m_pvWaveData, 0x10000, TRUE);
                break;

            default:
                DPF_ERROR("Unsupported bit resolution");
                fSuccess = FALSE;
                break;
        }
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  RenderWaveform
 *
 *  Description:
 *      Draws the waveform in a DC.  This function assumes all GDI objects
 *      have already been set up and simply draws the waveform.
 *
 *  Arguments:
 *      const SampleType * [in]: wave data.  This is only here to work around
 *                               a bug in template functions.
 *      UINT [in]: value range of a sample.
 *      BOOL [in]: TRUE if the samples are signed.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::RenderWaveform"

template <class SampleType>
void
CWaveformRenderer::RenderWaveform
(
    const SampleType *      pWaveData,
    UINT                    nWaveRange,
    BOOL                    fSigned
)
{
    static const int        nBaseX              = 0;
    const int               nBaseY              = m_nHeight / 2;
    const int               nHalfWaveRange      = nWaveRange / 2;
    const float             flVerticalScale     = (float)m_nHeight / (float)nWaveRange;
    const int               nSampleIncrement    = (m_nScale / m_nResolution) + 1;
    const int               cbSample            = sizeof(*pWaveData) * m_wfxFormat.nChannels;
    const int               nSampleOffset       = m_cbHorizOffset / cbSample;
    int                     cSamples            = m_cbWaveData / cbSample;
    int                     nPerPixelCount      = 0;
    long                    lSample;
    RECT                    rcUnused;
    int                     x, y;
    int                     i;

    if(!m_nWidth || !m_nHeight || !m_nScale)
    {
        return;
    }

    //
    // Reset the pen position to the 0,0 location
    //

    x = nBaseX;
    y = nBaseY;
    
    MoveToEx(m_hdcDraw, x, y, NULL);

    //
    // Offset the buffer and sample count
    //

    pWaveData += nSampleOffset * m_wfxFormat.nChannels;
    cSamples -= nSampleOffset;

    //
    // Enter the drawing loop
    //

    while((cSamples > 0) && (x < (int)m_nWidth))
    {
        //
        // Merge all channels into one averaged sample
        //

        if(fSigned)
        {
            for(i = 0, lSample = 0; i < m_wfxFormat.nChannels; i++)
            {
                lSample += (LONG)*pWaveData++;
            }
        }
        else
        {
            for(i = 0, lSample = 0; i < m_wfxFormat.nChannels; i++)
            {
                lSample += (long)*pWaveData++;
                lSample -= nHalfWaveRange;
            }
        }

        lSample /= m_wfxFormat.nChannels;
        
        ASSERT(lSample >= -nHalfWaveRange);
        ASSERT(lSample < nHalfWaveRange);

        //
        // Convert the sample's scale to our window height
        //

        lSample = (long)((float)lSample * flVerticalScale);

        //
        // Convert the sample value to a positive
        //

        y = nBaseY + lSample;

        //
        // Draw a line from the current position to the sample's position on
        // the graph
        //

        ASSERT(y >= 0);
        ASSERT(y < (int)m_nHeight);
        
        LineTo(m_hdcDraw, x, y);

        //
        // Skip ahead a few samples based on the resolution.  This is here to
        // prevent us from processing every single sample when the scaling 
        // factor is high.
        //

        cSamples -= nSampleIncrement;
        pWaveData += (nSampleIncrement - 1) * m_wfxFormat.nChannels;

        //
        // Increment the per-pixel sample counter.  When this number exceeds
        // the scaling factor, it's time to move the x-coordinate.
        //

        nPerPixelCount += nSampleIncrement;

        if(nPerPixelCount >= (int)m_nScale)
        {
            x++;

            nPerPixelCount = 0;
        }
    }

    //
    // Paint the remaining unused region
    //

    if(x < (int)m_nWidth)
    {
        rcUnused.left = x;
        rcUnused.top = 0;
        rcUnused.right = m_nWidth;
        rcUnused.bottom = m_nHeight;
    
        FillRect(m_hdcDraw, &rcUnused, m_hbrInactiveBackground);
    }
}


/****************************************************************************
 *
 *  DisplayBitmap
 *
 *  Description:
 *      Displays the bitmap we've drawn on the window.
 *
 *  Arguments:
 *      HDC [in]: display DC.
 *      LPCRECT [in]: update region.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformRenderer::DisplayBitmap"

BOOL
CWaveformRenderer::DisplayBitmap
(
    HDC                     hdcDisplay,
    LPCRECT                 prcUpdate
)
{
    int                     x;
    int                     y;
    int                     nWidth;
    int                     nHeight;

    ASSERT(hdcDisplay);

    if(!prcUpdate)
    {
        prcUpdate = &m_rcDisplay;
    }

    x = prcUpdate->left - m_rcDisplay.left;
    y = prcUpdate->top - m_rcDisplay.top;

    nWidth = prcUpdate->right - x;
    nHeight = prcUpdate->bottom - y;

    return BitBlt(hdcDisplay, prcUpdate->left, prcUpdate->top, nWidth, nHeight, m_hdcDraw, x, y, SRCCOPY);
}


/****************************************************************************
 *
 *  CWaveformControl
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::CWaveformControl"

CWaveformControl::CWaveformControl
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CWaveformControl
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::~CWaveformControl"

CWaveformControl::~CWaveformControl
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *      DWORD [in]: extended window style.
 *      int [in]: x-coordinate.
 *      int [in]: y-coordinate.
 *      UINT [in]: width.
 *      UINT [in]: height.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::Create"

BOOL
CWaveformControl::Create
(
    CWindow *               pParent,
    DWORD                   dwExStyle,
    int                     x, 
    int                     y, 
    UINT                    nWidth, 
    UINT                    nHeight,
    UINT                    nControlId
)
{
    static const DWORD      dwGeneralStyle  = WS_HSCROLL | WS_VSCROLL | WS_TABSTOP;
    static const DWORD      dwChildStyle    = WS_CHILD;
    static const DWORD      dwParentStyle   = WS_OVERLAPPEDWINDOW;
    WNDCLASSEX              wc              = { 0 };
    DWORD                   dwStyle;

    dwStyle = dwGeneralStyle;

    if(pParent)
    {
        dwStyle |= dwChildStyle;
    }
    else
    {
        dwStyle |= dwParentStyle;
        nControlId = 0;
    }

    //
    // Register the window class
    //    

    wc.cbSize = sizeof(wc);
    wc.style = CS_DBLCLKS | CS_OWNDC;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = g_hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszClassName = m_pszClassName;

    RegisterClassEx(&wc);

    //
    // Create the window
    //

    return CWindow::Create(pParent, m_pszClassName, NULL, dwExStyle, dwStyle, x, y, nWidth, nHeight, nControlId);
}


/****************************************************************************
 *
 *  SetScale
 *
 *  Description:
 *      Sets the scaling factor used to render the wave data.
 *
 *  Arguments:
 *      UINT [in]: scale.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::SetScale"

BOOL
CWaveformControl::SetScale
(
    UINT                    nScale
)
{
    //
    // Hand off to the renderer
    //

    if(!CWaveformRenderer::SetScale(nScale))
    {
        return FALSE;
    }

    //
    // Reset the scrollbars
    //

    SetupOffsetScrollbar();

    return TRUE;
}


/****************************************************************************
 *
 *  SetWaveData
 *
 *  Description:
 *      Sets the wave data used by the renderer.
 *
 *  Arguments:
 *      LPCWAVEFORMDATA [in]: wave data.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::SetWaveData"

BOOL
CWaveformControl::SetWaveData
(
    LPCWAVEFORMDATA         pWaveData
)
{
    if(!CWaveformRenderer::SetWaveData(pWaveData))
    {
        return FALSE;
    }

    SetupOffsetScrollbar();

    return TRUE;
}


/****************************************************************************
 *
 *  SetOffset
 *
 *  Description:
 *      Sets the bitmap Offset.
 *
 *  Arguments:
 *      UINT [in]: bitmap width.
 *      UINT [in]: bitmap height.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::SetOffset"

BOOL
CWaveformControl::SetOffset
(
    UINT                    cbOffset
)
{
    if(!CWaveformRenderer::SetOffset(cbOffset))
    {
        return FALSE;
    }

    SetupOffsetScrollbar();

    return TRUE;
}


/****************************************************************************
 *
 *  SetupOffsetScrollbar
 *
 *  Description:
 *      Sets up the offset scrollbar.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::SetupOffsetScrollbar"

void
CWaveformControl::SetupOffsetScrollbar
(
    void
)
{
    const int               cbSample        = m_wfxFormat.nChannels * m_wfxFormat.wBitsPerSample / 8;
    SCROLLINFO              si              = { 0 };
    int                     nSectionCount;
    int                     nSectionOffset;

    //
    // How many "pages" are there currently?  A page is defined as the amount
    // of wave data that can currently be displayed in the window.
    //

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE | SIF_POS | SIF_RANGE;

    m_nPageSize = m_nWidth * cbSample * m_nScale;
    m_nSectionSize = m_nPageSize / m_nSectionDivisor;
    
    if(m_nSectionSize)
    {
        nSectionCount = (m_cbWaveData + m_nSectionSize - 1) / m_nSectionSize;
        nSectionOffset = m_cbHorizOffset / m_nSectionSize;

        //
        // Fix the current offset so that no more than one unused section is
        // visible
        //

        if(nSectionCount <= (int)m_nSectionDivisor)
        {
            nSectionOffset = 0;

            CWaveformRenderer::SetOffset(0);
        }
        else if(nSectionOffset > nSectionCount - (int)m_nSectionDivisor)
        {
            nSectionOffset = m_cbHorizOffset / m_nSectionSize;

            CWaveformRenderer::SetOffset((nSectionCount - (int)m_nSectionDivisor) * m_nSectionSize);
        }

        si.nMin = 0;
        si.nMax = nSectionCount - 1;
        si.nPage = m_nSectionDivisor;
        si.nPos = nSectionOffset;
    }

    SetScrollInfo(m_hWnd, SB_HORZ, &si, TRUE);
}


/****************************************************************************
 *
 *  SetupScaleScrollbar
 *
 *  Description:
 *      Sets up the scaling scrollbar.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::SetupScaleScrollbar"

void
CWaveformControl::SetupScaleScrollbar
(
    void
)
{
    SCROLLINFO              si  = { 0 };

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE | SIF_POS | SIF_RANGE;
    si.nMin = 0;
    si.nMax = 15;
    si.nPage = 4;
    
    for(si.nPos = 0; si.nPos < 31; si.nPos++)
    {
        if(m_nScale & (1UL << si.nPos))
        {
            break;
        }
    }

    SetScrollInfo(m_hWnd, SB_VERT, &si, TRUE);
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: window creation context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::OnCreate"

BOOL
CWaveformControl::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    if(CWindow::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }
    
    //
    // Initialize the renderer
    //

    if(!CWaveformRenderer::Initialize(m_hWnd))
    {
        *plResult = FALSE;
        return TRUE;
    }

    //
    // Setup the scrollbars
    //

    SetupScaleScrollbar();
    SetupOffsetScrollbar();

    return FALSE;
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles WM_SIZE messages.
 *
 *  Arguments:
 *      UINT [in]: resize type.
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::OnSize"

BOOL
CWaveformControl::OnSize
(
    UINT                    nType, 
    UINT                    nWidth, 
    UINT                    nHeight, 
    LRESULT *               plResult
)
{
    const RECT              rcDisplay   = { 0, 0, nWidth, nHeight };
    
    if(CWindow::OnSize(nType, nWidth, nHeight, plResult))
    {
        return TRUE;
    }
    
    //
    // Update the renderer
    //

    CWaveformRenderer::SetRect(&rcDisplay);

    //
    // Update the offset scrollbar
    //

    SetupOffsetScrollbar();

    //
    // Force a repaint
    //

    InvalidateRect(m_hWnd, NULL, FALSE);

    return FALSE;
}


/****************************************************************************
 *
 *  OnEraseBackground
 *
 *  Description:
 *      Handles WM_ERASEBKGND messages.
 *
 *  Arguments:
 *      HDC [in]: device context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::OnEraseBackground"

BOOL
CWaveformControl::OnEraseBackground
(
    HDC                     hdc,
    LRESULT *               plResult
)
{
    if(!m_hdcDraw)
    {
        return FALSE;
    }
    
    *plResult = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  OnPaint
 *
 *  Description:
 *      Handles WM_PAINT messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::OnPaint"

BOOL
CWaveformControl::OnPaint
(
    LRESULT *               plResult
)
{
    PAINTSTRUCT             ps;

    if(!m_hdcDraw)
    {
        return FALSE;
    }
    
    //
    // Repaint the window
    //

    BeginPaint(m_hWnd, &ps);

    CWaveformRenderer::Render(ps.hdc, &ps.rcPaint);

    EndPaint(m_hWnd, &ps);
    
    *plResult = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  OnScroll
 *
 *  Description:
 *      Handles WM_H/VSCROLL messages.
 *
 *  Arguments:
 *      UINT [in]: scrollbar type (SB_HORZ/SB_VERT).
 *      HWND [in]: scrollbar control window handle.
 *      INT [in]: new scrollbar position.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveformControl::OnScroll"

BOOL
CWaveformControl::OnScroll
(
    UINT                    nScrollBarType, 
    HWND                    hWndScrollBar, 
    INT                     nPosition, 
    LRESULT *               plResult
)
{
    if(CWindow::OnScroll(nScrollBarType, hWndScrollBar, nPosition, plResult))
    {
        return TRUE;
    }
    
    //
    // If the vertical scrollbar changed, update the scale.  If it was the
    // horizontal, update the offset.
    //

    if(SB_VERT == nScrollBarType)
    {
        SetScale(1UL << nPosition);
        SetupOffsetScrollbar();
    }
    else if(SB_HORZ == nScrollBarType)
    {
        SetOffset(nPosition * m_nSectionSize);
    }
    
    //
    // Force a repaint
    //

    InvalidateRect(m_hWnd, NULL, FALSE);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\waveform.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/30/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveform.h
 *  Content:    Renders a waveform bitmap.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/30/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WAVEFORM_H__
#define __WAVEFORM_H__

//
// Waveform renderer color data
//

BEGIN_DEFINE_STRUCT()
    COLORREF    rgbBackground;          // Window background color
    COLORREF    rgbInactiveBackground;  // Window background color
    COLORREF    rgbWaveform;            // Waveform color
END_DEFINE_STRUCT(WAVEFORMCOLORS);

//
// Waveform renderer wave data
//

BEGIN_DEFINE_STRUCT()
    LPCWAVEFORMATEX pwfxFormat;     // Data format (PCM only)
    LPCVOID         pvWaveData;     // Wave data
    UINT            cbWaveData;     // Wave data size, in bytes
END_DEFINE_STRUCT(WAVEFORMDATA);

//
// Waveform render state
//

typedef enum
{
    WAVEFORM_RENDER_NONE = 0,       // Nothing needs to be redrawn
    WAVEFORM_RENDER_REDRAW,         // The waveform needs to be redrawn
    WAVEFORM_RENDER_DRAWINGTOOLS,   // The objects used to draw the waveform need to be recreated
    WAVEFORM_RENDER_CREATEBITMAP,   // The off-screen bitmap needs to be recreated
    WAVEFORM_RENDER_FULL,           // All render operations need to be done
} WAVEFORM_RENDER_STATE;

#ifdef __cplusplus

//
// Waveform renderer object
//

class CWaveformRenderer
{
public:
    static const UINT       m_nDefaultScale;            // Default scaling factor
    static const UINT       m_nDefaultResolution;       // Default resolution factor

protected:
    WAVEFORM_RENDER_STATE   m_nState;                   // Render state
    HWND                    m_hWndDisplay;              // Window we're drawing on
    RECT                    m_rcDisplay;                // Drawing rectangle
    int                     m_nWidth;                   // Drawing rectangle width
    int                     m_nHeight;                  // Drawing rectangle height
    HDC                     m_hdcDraw;                  // Offscreen drawing device context
    HBRUSH                  m_hbrActiveBackground;      // Background brush
    HBRUSH                  m_hbrInactiveBackground;    // Background brush
    HPEN                    m_hpnBackground;            // Background pen
    HPEN                    m_hpnWaveform;              // Waveform pen
    WAVEFORMCOLORS          m_colors;                   // Bitmap colors
    WAVEFORMATEX            m_wfxFormat;                // Data format
    LPCVOID                 m_pvWaveData;               // PCM wave data
    UINT                    m_cbWaveData;               // Wave data size
    UINT                    m_cbHorizOffset;            // Offset into the wave data
    UINT                    m_nScale;                   // Scaling factor
    UINT                    m_nResolution;              // Resolution factor

public:
    CWaveformRenderer(void);
    virtual ~CWaveformRenderer(void);

public:
    // Initialization
    virtual BOOL Initialize(HWND hWnd);

    // Renderer properties
    virtual BOOL SetRect(LPCRECT prcDisplay);
    virtual BOOL SetColors(LPCWAVEFORMCOLORS pColors);
    virtual BOOL SetWaveData(LPCWAVEFORMDATA pWaveData);
    virtual BOOL SetOffset(UINT cbOffset);
    virtual BOOL SetScale(UINT nScale);
    virtual BOOL SetResolution(UINT nResolution);

    // Renderer methods
    virtual BOOL Render(HDC hdcDisplay, LPCRECT prcUpdate);

protected:
    // Renderer state
    virtual void SetRenderState(WAVEFORM_RENDER_STATE nState);

    // Renderer methods
    virtual BOOL CreateBitmap(HDC hdcDisplay);
    virtual BOOL CreateDrawingTools(void);
    virtual BOOL DrawBackground(void);
    virtual BOOL DrawWaveform(void);
    virtual BOOL DisplayBitmap(HDC hdcDisplay, LPCRECT prcUpdate);

private:
    // Renderer methods
    template <class SampleType> void RenderWaveform(const SampleType *pWaveData, UINT nWaveRange, BOOL fSigned);
};

__inline void CWaveformRenderer::SetRenderState(WAVEFORM_RENDER_STATE nState)
{
    if(nState > m_nState)
    {
        m_nState = nState;
    }
}

__inline BOOL CWaveformRenderer::SetResolution(UINT nResolution)
{
    m_nResolution = nResolution;
    return TRUE;
}

//
// Waveform window
//

class CWaveformControl
    : public CWindow, public CRefCount, protected CWaveformRenderer
{
public:
    static const LPCTSTR    m_pszClassName;     // Window class name

protected:
    static const UINT       m_nSectionDivisor;  // Number of sections in a page
    UINT                    m_nPageSize;        // Visible page size (in logical window units)
    UINT                    m_nSectionSize;     // Section size (in logical window units)

public:
    CWaveformControl(void);
    virtual ~CWaveformControl(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(CWindow *pParent, DWORD dwExStyle, int x, int y, UINT nWidth, UINT nHeight, UINT nControlId);

    // Renderer properties
    virtual BOOL SetColors(LPCWAVEFORMCOLORS pColors);
    virtual BOOL SetWaveData(LPCWAVEFORMDATA pWaveData);
    virtual BOOL SetOffset(UINT cbOffset);
    virtual BOOL SetScale(UINT nScale);
    virtual BOOL SetResolution(UINT nResolution);

    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnEraseBackground(HDC hdc, LRESULT *plResult);
    virtual BOOL OnPaint(LRESULT *plResult);
    virtual BOOL OnScroll(UINT nScrollBarType, HWND hWndScrollBar, INT nPosition, LRESULT *plResult);

protected:
    // Setup
    virtual void SetupOffsetScrollbar(void);
    virtual void SetupScaleScrollbar(void);
};

__inline ULONG CWaveformControl::AddRef(void)
{
    return CRefCount::AddRef();
}

__inline ULONG CWaveformControl::Release(void)
{
    return CRefCount::Release();
}

__inline BOOL CWaveformControl::SetColors(LPCWAVEFORMCOLORS pColors)
{
    return CWaveformRenderer::SetColors(pColors);
}

__inline BOOL CWaveformControl::SetResolution(UINT nResolution)
{
    return CWaveformRenderer::SetResolution(nResolution);
}

#endif // __cplusplus

#endif // __WAVEFORM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\controls\xactctl.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/30/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xactctl.h
 *  Content:    Main XACT control header.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/30/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __XACTCTL_H__
#define __XACTCTL_H__

#include "xactgui.h"
#include "ctltools.h"
#include "waveform.h"
#include "treeview.h"
#include "toolbar.h"
#include "listview.h"

#endif // __XACTCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\audition.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/22/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       audition.cpp
 *  Content:    Audition objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/22/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactapp.h"


/****************************************************************************
 *
 *  CRemoteAudition
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteAudition::CRemoteAudition"

CRemoteAudition::CRemoteAudition
(
    void
)
{
    m_pxbdm = NULL;
}


/****************************************************************************
 *
 *  ~CRemoteAudition
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteAudition::~CRemoteAudition"

CRemoteAudition::~CRemoteAudition
(
    void
)
{
    Disconnect();
}


/****************************************************************************
 *
 *  Connect
 *
 *  Description:
 *      Connects to a remote instance of Audio Console.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteAudition::Connect"

BOOL
CRemoteAudition::Connect
(
    void
)
{
    CMRU                    MRU(g_pApplication->m_Registry, REGKEY_XBOX_MRU);

    static const LPCTSTR    pszCommandTemplate  = TEXT("XAUD!connect %s");
    CXboxConnectionDialog   Dialog;
    XBOXCONNECTDATA         ConnectData;
    TCHAR                   szDefault[0x100];
    TCHAR                   szCommand[0x100];
    int                     nResult;
    BOOL                    fSuccess;
    DWORD                   dwSize;
    
    if(m_pxbdm)
    {
        return TRUE;
    }

    _stprintf(szCommand, pszCommandTemplate, g_szAppTitle);

    //
    // Get the default Xbox name and make sure it's in the MRU
    //

    dwSize = NUMELMS(szDefault);

    if(XBDM_NOERR == (nResult = DmGetXboxName(szDefault, &dwSize)))
    {
        MRU.AddItem(szDefault);
    }
    else
    {
        DPF_ERROR("DmGetXboxName failed with %x", nResult);
    }

    //
    // Get MRU data
    //

    ConnectData.pszAddressList = MRU.GetItems();

    //
    // Enter the connection loop
    //

    while(TRUE)
    {
        //
        // Show the connection dialog.  The dialog will write directly to
        // our m_szAddress buffer.
        //

        if(!(fSuccess = Dialog.DoModal(&g_pApplication->m_MainFrame, &ConnectData)))
        {
            break;
        }

        //
        // If the address is valid, use it
        //

        if(fSuccess && ConnectData.szAddress[0])
        {
            DmSetXboxNameNoRegister(ConnectData.szAddress);
        }

        //
        // Connect to the Xbox
        //

        if(fSuccess)
        {
            if(XBDM_NOERR != (nResult = DmOpenConnection(&m_pxbdm)))
            {
                DPF_ERROR("DmOpenConnection failed with %x", nResult);
                fSuccess = FALSE;
            }
        }

        //
        // Connect to AudConsole
        //

        if(fSuccess)
        {
            if(XBDM_NOERR != (nResult = DmSendCommand(m_pxbdm, szCommand, NULL, NULL)))
            {
                DPF_ERROR("DmSendCommand(%s) failed with %x", szCommand, nResult);
                fSuccess = FALSE;
            }
        }

        //
        // If anything went wrong, try again
        //

        if(fSuccess)
        {
            break;
        }
        else
        {
            DmCloseConnection(m_pxbdm);
            m_pxbdm = NULL;
        }
    }

    //
    // Add the address to the MRU
    //

    if(fSuccess && ConnectData.szAddress[0])
    {
        MRU.AddItem(ConnectData.szAddress);
    }

    //
    // Update commands
    //

    if(fSuccess)
    {
        g_pApplication->m_MainFrame.EnableCommand(ID_CONNECT, FALSE);
        g_pApplication->m_MainFrame.EnableCommand(ID_DISCONNECT, TRUE);
    }

    //
    // Clean up
    //

    MEMFREE(ConnectData.pszAddressList);

    return fSuccess;
}


/****************************************************************************
 *
 *  Disconnect
 *
 *  Description:
 *      Disconnects from a remote instance of Audio Console.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteAudition::Disconnect"

void
CRemoteAudition::Disconnect
(
    void
)
{
    static const LPCTSTR    pszCommandTemplate  = TEXT("XAUD!disconnect %s");
    TCHAR                   szCommand[0x100];
    int                     nResult;
    
    if(!m_pxbdm)
    {
        return;
    }

    //
    // Disconnect
    //
    
    _stprintf(szCommand, pszCommandTemplate, g_szAppTitle);

    DmSendCommand(m_pxbdm, szCommand, NULL, NULL);
    DmCloseConnection(m_pxbdm);

    m_pxbdm = NULL;

    //
    // Update commands
    //

    g_pApplication->m_MainFrame.EnableCommand(ID_CONNECT, TRUE);
    g_pApplication->m_MainFrame.EnableCommand(ID_DISCONNECT, FALSE);
}


/****************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Auditions an entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteAudition::Play"

BOOL
CRemoteAudition::Play
(
    CWaveBankEntry *        pEntry
)
{
    static const LPCSTR     pszCommandTemplate      = "XAUD!WaveBank.PlayEntry \"%s\"";
    static const LPCSTR     pszDstPathTemplate      = "T:\\%s";
    static const DWORD      dwCopyBufferSize        = 256 * 1024;
    DWORD                   dwOffset                = 0;
    LPVOID                  pvCopyBuffer            = NULL;
    TCHAR                   szCurDir[MAX_PATH];
    TCHAR                   szSrcFile[MAX_PATH];
    TCHAR                   szDstFile[MAX_PATH];
    TCHAR                   szFileTitle[MAX_PATH];
    CHAR                    szCommand[0x400];
    CStdFileStream          DataFile;
    WAVEBANKENTRY           Entry;
    BOOL                    fSuccess;
    int                     nResult;

    //
    // Make sure we're connected
    //

    if(!Connect())
    {
        return FALSE;
    }

    //
    // Open a temporary file
    //

    GetCurrentDirectory(NUMELMS(szCurDir), szCurDir);
    GetTempFileName(szCurDir, TEXT("XAC"), 0, szSrcFile);

    fSuccess = SUCCEEDED(DataFile.Open(szSrcFile, GENERIC_READ | GENERIC_WRITE, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN));

    //
    // Get entry meta-data and write it to the file
    //

    if(fSuccess)
    {
        fSuccess = SUCCEEDED(pEntry->GetMetaData(&Entry, 0, CWaveBank::m_dwMinAlignment, &dwOffset));
    }

    if(fSuccess)
    {
        fSuccess = SUCCEEDED(DataFile.Write(&Entry, sizeof(Entry)));
    }
    
    //
    // Allocate the copy buffer
    //

    if(fSuccess)
    {
        fSuccess = MAKEBOOL(pvCopyBuffer = MEMALLOC(BYTE, dwCopyBufferSize));
    }

    //
    // Get wave data
    //

    if(fSuccess)
    {
        fSuccess = SUCCEEDED(pEntry->CommitWaveData(NULL, &DataFile, sizeof(Entry), &Entry, pvCopyBuffer, dwCopyBufferSize));
    }

    //
    // Close the file so XBDM can read it
    //

    if(fSuccess)
    {
        DataFile.Close();
    }

    //
    // Send the file to the Xbox
    //

    if(fSuccess)
    {
        _stprintf(szDstFile, pszDstPathTemplate, pEntry->m_pParent->m_szBankName);

        DmMkdir(szDstFile);
    }
    
    if(fSuccess)
    {
        _splitpath(pEntry->m_szFileName, NULL, NULL, szFileTitle, NULL);
        
        _tcscat(szDstFile, TEXT("\\"));
        _tcscat(szDstFile, szFileTitle);
        
        if(XBDM_NOERR != (nResult = DmSendFile(szSrcFile, szDstFile)))
        {
            DPF_ERROR("DmSendFile(%s, %s) failed with %x", szSrcFile, szDstFile, nResult);
            fSuccess = FALSE;
        }
    }

    //
    // Tell the Xbox to play the file
    //

    if(fSuccess)
    {
        sprintf(szCommand, pszCommandTemplate, szDstFile);
        
        if(XBDM_NOERR != (nResult = DmSendCommand(m_pxbdm, szCommand, NULL, NULL)))
        {
            DPF_ERROR("DmSendCommand(%s) failed with %x", szCommand, nResult);
            fSuccess = FALSE;
        }
    }

    //
    // Clean up
    //

    DeleteFile(szSrcFile);
    
    MEMFREE(pvCopyBuffer);

    return fSuccess;
}


/****************************************************************************
 *
 *  StopAll
 *
 *  Description:
 *      Cancels any autitioning entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteAudition::StopAll"

void
CRemoteAudition::StopAll
(
    void
)
{
    DmSendCommand(m_pxbdm, "XAUD!WaveBank.StopAll", NULL, NULL);
}


/****************************************************************************
 *
 *  CXboxConnectionDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxConnectionDialog::CXboxConnectionDialog"

CXboxConnectionDialog::CXboxConnectionDialog
(
    void
)
:   CDialog(IDD)
{
}


/****************************************************************************
 *
 *  ~CXboxConnectionDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxConnectionDialog::~CXboxConnectionDialog"

CXboxConnectionDialog::~CXboxConnectionDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxConnectionDialog::OnCreate"

BOOL
CXboxConnectionDialog::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    LPTSTR                  pszAddressList;
    
    if(CDialog::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Save connection data
    //

    ASSERT(pvContext);
    m_pData = (LPXBOXCONNECTDATA)pvContext;

    //
    // Add addresses from the address list
    //

    if(m_pData->pszAddressList)
    {
        pszAddressList = m_pData->pszAddressList;

        while(*pszAddressList)
        {
            SendDlgItemMessage(IDC_ADDRESS_LIST, CB_ADDSTRING, 0, (LPARAM)pszAddressList);

            pszAddressList += _tcslen(pszAddressList) + 1;
        }
    }

    //
    // Set the default list item
    //

    SendDlgItemMessage(IDC_ADDRESS_LIST, CB_SETCURSEL, 0);

    return FALSE;
}


/****************************************************************************
 *
 *  OnCmdOK
 *
 *  Description:
 *      Handles the OK command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxConnectionDialog::OnCmdOK"

void
CXboxConnectionDialog::OnCmdOK
(
    void
)
{
    //
    // Get the address
    //

    GetDlgItemText(IDC_ADDRESS_LIST, m_pData->szAddress, NUMELMS(m_pData->szAddress));

    //
    // Hand off to the base class
    //

    CDialog::OnCmdOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\dscommon.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscommon.cpp
 *  Content:    DirectSound common source file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/01    dereks  Created.
 *
 ***************************************************************************/

#include "xactapp.h"
#include "..\..\..\..\dsound\common\dscommon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\audition.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/22/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       audition.h
 *  Content:    Audition objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/22/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __AUDITION_H__
#define __AUDITION_H__

#ifdef __cplusplus

//
// Connection dialog data
//

BEGIN_DEFINE_STRUCT()
    LPTSTR      pszAddressList;                     // Initial address list
    TCHAR       szAddress[0x100];                   // Address output buffer
END_DEFINE_STRUCT(XBOXCONNECTDATA);

//
// Remote audition object
//

class CRemoteAudition
{
protected:
    PDM_CONNECTION              m_pxbdm;            // Xbox debugger connection

public:
    CRemoteAudition(void);
    virtual ~CRemoteAudition(void);

public:
    // Connection
    virtual BOOL Connect(void);
    virtual void Disconnect(void);

    // Auditioning
    virtual BOOL Play(CWaveBankEntry *pEntry);
    virtual void StopAll(void);
};

//
// Xbox connection dialog
//

class CXboxConnectionDialog
    : public CDialog
{
public:
    enum
    {
        IDD = IDD_CONNECT_XBOX
    };

protected:
    LPXBOXCONNECTDATA       m_pData;            // Connection data

public:
    CXboxConnectionDialog(void);
    virtual ~CXboxConnectionDialog(void);

protected:
    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);

    // Command handlers
    virtual void OnCmdOK(void);
};

#endif // __cplusplus

#endif // __AUDITION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\mainrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDS_APPTITLE                    1
#define IDS_XDKVERSION                  2
#define IDS_OPEN_PROJECT                3
#define IDS_SAVE_PROJECT                4
#define IDS_CREATE_WAVE_BANK            5
#define IDS_CREATE_WAVE_BANK_HEADER     6
#define IDS_SAVE_CHANGES                7
#define IDS_UNNAMED_PROJECT             8
#define IDS_CREATE_WAVE_BANK_ENTRY      9
#define IDS_BUILD_SUCCEEDED             10
#define IDS_BUILD_ABORTED               11
#define IDS_BUILD_FAILED                12
#define IDS_CLOSE                       13
#define IDS_ABORTING                    14
#define IDS_CONFIRM_DELETE_WAVEBANK     15
#define IDS_CONFIRM_DELETE_WAVEBANK_ENTRY 16
#define IDS_NOT_ALL_CONVERTED           17
#define IDS_NONE_CONVERTED              18
#define IDS_BANKSIZE_UNKNOWN            19
#define IDS_CONFIRM_RELOAD              20
#define IDI_XACT                        101
#define IDM_MAIN                        103
#define IDA_MAIN                        104
#define IDB_MAIN_TOOLBAR                105
#define IDI_WAVEBANK                    108
#define IDI_WAVEBANK_ENTRY              109
#define IDI_CATEGORY_WAVEBUNDLER        110
#define IDD_BUILD                       110
#define IDB_DIALOG_PANE                 111
#define IDD_BUILD_CHILD_TEMPLATE        112
#define IDD_BUILD_WAVEBUNDLER           113
#define IDM_WAVEBANK_ENTRY_POPUP        113
#define IDM_WAVEBANK_POPUP              114
#define IDD_CONNECT_XBOX                115
#define IDI_CONSOLE                     124
#define IDI_PLAY                        125
#define IDI_STOP                        126
#define IDD_WAVEBANK_ENTRY_OFN_CHILD    126
#define IDD_WAVEBANK_PROPERTIES         127
#define IDS_CATEGORY_WAVEBUNDLER        256
#define IDS_ENTRY_NAME                  257
#define IDS_ENTRY_FORMAT                258
#define IDS_ENTRY_SAMPLING_RATE         259
#define IDS_ENTRY_BIT_RESOLUTION        260
#define IDS_ENTRY_CHANNEL_COUNT         261
#define IDS_ENTRY_SIZE                  262
#define IDS_ENTRY_CONVERSION            263
#define IDS_ENTRY_SOURCE_FILE           264
#define IDS_BANK_INFOTIP                265
#define IDC_OVERALL_PROGRESS            1000
#define IDC_PLACEHOLDER                 1003
#define IDC_BANK_PROGRESS               1006
#define IDC_CURRENT_BANK                1007
#define IDC_CURRENT_ENTRY               1008
#define IDC_ADDRESS_LIST                1008
#define IDC_ENTRY_PROGRESS              1010
#define IDC_PLAY                        1011
#define IDC_STOP                        1012
#define IDC_WAVEBANK_NAME               1012
#define IDC_WAVEBANK_PATH               1013
#define IDC_WAVEBANK_HEADER_PATH        1014
#define IDC_WAVEBANK_PATH_BROWSE        1015
#define IDC_WAVEBANK_HEADER_PATH_BROWSE 1016
#define IDC_WAVEBANK_TYPE_BUFFER        1019
#define IDC_WAVEBANK_TYPE_STREAMING     1021
#define IDC_WAVEBANK_ALIGNMENT          1023
#define IDC_WAVEBANK_SIZE               1024
#define ID_EXIT                         40001
#define ID_ABOUT                        40002
#define ID_NEW_PROJECT                  40003
#define ID_OPEN_PROJECT                 40004
#define ID_SAVE_PROJECT                 40005
#define ID_SAVE_PROJECT_AS              40006
#define ID_ADD_WAVEBANK                 40007
#define ID_ADD_WAVEBANK_ENTRY           40008
#define ID_WAVEBANK_ENTRY_ADPCM         40009
#define ID_WAVEBANK_ENTRY_8BIT          40010
#define ID_BUILD                        40011
#define ID_PLAY                         40012
#define ID_STOP                         40013
#define ID_DELETE                       40014
#define ID_REFRESH                      40015
#define ID_WINDOW_NEXT                  40016
#define ID_WINDOW_PREV                  40017
#define ID_WINDOW_CLOSE                 40018
#define ID_WINDOW_CLOSE_ALL             40019
#define ID_RELOAD_PROJECT               40020
#define ID_RENAME                       40027
#define ID_SELECT_ALL                   40030
#define ID_CONNECT                      40031
#define ID_DISCONNECT                   40032
#define ID_PROPERTIES                   40033
#define ID_ACTIVATE                     40036
#define ID_WAVEBANK_ENTRY_RENAME        40037
#define ID_WAVEBANK_ENTRY_DELETE        40038
#define ID_WAVEBANK_ENTRY_PROPERTIES    40039
#define ID_WAVEBANK_ACTIVATE            40040
#define ID_WAVEBANK_RENAME              40041
#define ID_WAVEBANK_DELETE              40042
#define ID_WAVEBANK_PROPERTIES          40043
#define ID_WAVEBANK_REFRESH             40046
#define ID_RECENT_FILE_0                60000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        128
#define _APS_NEXT_COMMAND_VALUE         40047
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\project.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/13/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       project.cpp
 *  Content:    Project object (parser, object manager).
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/13/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactapp.h"
#include <commdlg.h>


/****************************************************************************
 *
 *  CProject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProject::CProject"

CProject::CProject
(
    void
)
{
    m_hBuildEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_fUpdateAppTitle = TRUE;
}


/****************************************************************************
 *
 *  ~CProject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProject::~CProject"

CProject::~CProject
(
    void
)
{
    //
    // Free owned objects
    //
    
    Reset();

    //
    // Free resources
    //

    CLOSE_HANDLE(m_hBuildEvent);
}


/****************************************************************************
 *
 *  New
 *
 *  Description:
 *      Creates a new project.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to reset the file path.
 *      BOOL [in]: TRUE to prompt the user to save first.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::New"

BOOL
CProject::New
(
    BOOL                    fResetFilePath,
    BOOL                    fConfirm
)
{
    BOOL                    fSuccess;

    //
    // Prompt to save
    //

    if(fConfirm)
    {
        if(!CheckDirty())
        {
            return FALSE;
        }
    }

    //
    // Free any current project data
    //
    
    Reset();

    //
    // Reset the file path
    //

    if(fResetFilePath)
    {
        m_szProjectFile[0] = 0;
    }

    //
    // Create child objects
    //

    fSuccess = MAKEBOOL(m_pWaveBankProject = NEW(CGuiWaveBankProject()));

    //
    // Clear the dirty flag
    //

    MakeDirty(FALSE);

    //
    // Disable the "reload" command
    //

    g_pApplication->m_MainFrame.EnableCommand(ID_RELOAD_PROJECT, FALSE);

    return fSuccess;
}


/****************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Opens a new project.
 *
 *  Arguments:
 *      LPCTSTR [in]: project file path, or NULL to prompt the user for one.
 *      BOOL [in]: TRUE to prompt the user to save first.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::Open"

BOOL
CProject::Open
(
    LPCTSTR                 pszProjectFile,
    BOOL                    fConfirm
)
{
    static const LPCTSTR    pszFilter       = MAKE_COMMDLG_FILTER(TEXT("Wave Bundler Project"), TEXT("*.") WBWRITER_FILEEXTENSION_PROJECT) \
                                              MAKE_COMMDLG_FILTER(TEXT("All"), TEXT("*.*"));

    static const LPCTSTR    pszDefExt       = WBWRITER_FILEEXTENSION_PROJECT;
    static const DWORD      dwOfnFlags      = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_ALLOWMULTISELECT;
    OPENFILENAME            ofn             = { 0 };

    //
    // Don't reopen the same project.  If you want to reload it, call Reopen.
    //

    if(pszProjectFile)
    {
        if(!_tcsicmp(pszProjectFile, m_szProjectFile))
        {
            return TRUE;
        }
    }

    //
    // Prompt the user to save first
    //

    if(fConfirm)
    {
        if(!CheckDirty())
        {
            return FALSE;
        }
    }

    //
    // Get the new project file path
    //

    if(pszProjectFile)
    {
        _tcscpy(m_szProjectFile, pszProjectFile);
    }
    else
    {
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = g_pApplication->m_MainFrame;
        ofn.lpstrFilter = pszFilter;
        ofn.lpstrFile = m_szProjectFile;
        ofn.nMaxFile = NUMELMS(m_szProjectFile);
        ofn.lpstrTitle = FormatStringResourceStatic(IDS_OPEN_PROJECT);
        ofn.Flags = dwOfnFlags;
        ofn.lpstrDefExt = pszDefExt;

        if(!GetOpenFileName(&ofn))
        {
            return FALSE;
        }
    }

    //
    // Now that the file name's set, just call the Reopen method to
    // do all the work
    //

    return Reopen(FALSE);
}


/****************************************************************************
 *
 *  Reopen
 *
 *  Description:
 *      Reopens the current project.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to prompt the user to save first.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::Reopen"

BOOL
CProject::Reopen
(
    BOOL                    fConfirm
)
{
    CWaveBankProjectFile    WaveBankLoader;
    BOOL                    fAppTitle;
    BOOL                    fSuccess;

    //
    // If we don't have a valid project file, bail
    //

    if(!m_szProjectFile[0])
    {
        return FALSE;
    }

    //
    // Get confirmation that they want to reload
    //

    if(fConfirm)
    {
        if(IsDirty())
        {
            if(IDYES != MsgBoxResource(g_pApplication->m_MainFrame, MB_YESNOCANCEL | MB_ICONQUESTION, IDS_CONFIRM_RELOAD))
            {
                return FALSE;
            }
        }
    }

    //
    // Toggle app title updates
    //

    fAppTitle = EnableAppTitleUpdates(FALSE);

    //
    // Reinitialize the project
    //

    if(fSuccess = New(FALSE, FALSE))
    {
        //
        // Change the cursor to provide user feedback
        //

        BeginWaitCursor();

        //
        // Open Wave Bundler stuff
        //

        fSuccess = SUCCEEDED(WaveBankLoader.Load(m_pWaveBankProject, m_szProjectFile));

        //
        // Update the application's MRU
        //

        if(fSuccess)
        {
            g_pApplication->m_MRU.AddItem(m_szProjectFile);
        }

        //
        // Clear the dirty flag.  It gets reset by New, but loading the
        // project could indirectly set it back to dirty.
        //

        MakeDirty(FALSE);

        //
        // Enable the "reload" command
        //

        g_pApplication->m_MainFrame.EnableCommand(ID_RELOAD_PROJECT, TRUE);

        //
        // Restore the cursor
        //

        EndWaitCursor();
    }

    //
    // Update the app title
    //

    EnableAppTitleUpdates(fAppTitle);

    return fSuccess;
}


/****************************************************************************
 *
 *  Save
 *
 *  Description:
 *      Saves the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::Save"

BOOL
CProject::Save
(
    void
)
{
    BOOL                    fSuccess        = TRUE;
    CWaveBankProjectFile    WaveBankLoader;

    //
    // If we don't have a valid file path, hand off to the SaveAs method
    //

    if(!m_szProjectFile[0])
    {
        return SaveAs();
    }
    
    //
    // Save Wave Bundler stuff
    //

    fSuccess = SUCCEEDED(WaveBankLoader.Save(m_pWaveBankProject, m_szProjectFile));

    //
    // Update the application's MRU
    //

    if(fSuccess)
    {
        g_pApplication->m_MRU.AddItem(m_szProjectFile);
    }

    //
    // Clear the dirty flag
    //

    if(fSuccess)
    {
        MakeDirty(FALSE);
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  SaveAs
 *
 *  Description:
 *      Saves the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "SaveAs::SaveAs"

BOOL
CProject::SaveAs
(
    void
)
{
    static const LPCTSTR    pszFilter   = MAKE_COMMDLG_FILTER(TEXT("Wave Bundler Project"), TEXT("*.") WBWRITER_FILEEXTENSION_PROJECT) \
                                          MAKE_COMMDLG_FILTER(TEXT("All"), TEXT("*.*"));

    static const LPCTSTR    pszDefExt   = WBWRITER_FILEEXTENSION_PROJECT;
    static const DWORD      dwOfnFlags  = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_ALLOWMULTISELECT;
    OPENFILENAME            ofn         = { 0 };

    //
    // Get the new project file path
    //

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = g_pApplication->m_MainFrame;
    ofn.lpstrFilter = pszFilter;
    ofn.lpstrFile = m_szProjectFile;
    ofn.nMaxFile = NUMELMS(m_szProjectFile);
    ofn.lpstrTitle = FormatStringResourceStatic(IDS_SAVE_PROJECT);
    ofn.Flags = dwOfnFlags;
    ofn.lpstrDefExt = pszDefExt;

    if(!GetSaveFileName(&ofn))
    {
        return FALSE;
    }

    //
    // Enable the "reload" command
    //

    g_pApplication->m_MainFrame.EnableCommand(ID_RELOAD_PROJECT, TRUE);

    //
    // Save the project
    //
    
    return Save();
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Frees all project data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProject::Reset"

void
CProject::Reset
(
    void
)
{
    //
    // Free objects
    //

    DELETE(m_pWaveBankProject);
}


/****************************************************************************
 *
 *  AddWaveBank
 *
 *  Description:
 *      Adds a new bank to the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProject::AddWaveBank"

BOOL
CProject::AddWaveBank
(
    void
)
{
    CGuiWaveBank *          pBank                   = NULL;
    TCHAR                   szBankPath[MAX_PATH];
    TCHAR                   szHeaderPath[MAX_PATH];
    TCHAR                   szDrive[MAX_PATH];
    TCHAR                   szDir[MAX_PATH];
    TCHAR                   szFile[MAX_PATH];
    TCHAR                   szExt[MAX_PATH];

    while(TRUE)
    {
        //
        // Get the wave bank file path
        //

        szBankPath[0] = 0;
        
        if(!CGuiWaveBankProject::BrowseBankFile(g_pApplication->m_MainFrame, szBankPath, NUMELMS(szBankPath)))
        {
            return FALSE;
        }
    
        //
        // Get the header file path
        //
    
        _splitpath(szBankPath, szDrive, szDir, szFile, szExt);
        _makepath(szHeaderPath, szDrive, szDir, szFile, TEXT(".") WBWRITER_FILEEXTENSION_HEADER);

        if(!CGuiWaveBankProject::BrowseHeaderFile(g_pApplication->m_MainFrame, szHeaderPath, NUMELMS(szHeaderPath)))
        {
            return FALSE;
        }

        //
        // Create the bank
        //

        if(SUCCEEDED(m_pWaveBankProject->AddBank(szFile, szBankPath, szHeaderPath, (CWaveBank **)&pBank)))
        {
            break;
        }
    }

    //
    // Open the new bank
    //

    pBank->OpenList();

    //
    // Show the bank properties dialog in case the user wants to change 
    // anything else
    //

    pBank->OnCmdProperties();

    //
    // Mark the project as dirty
    //

    MakeDirty();

    return TRUE;
}


/****************************************************************************
 *
 *  CheckDirty
 *
 *  Description:
 *      Prompts the user to save if the project has changed.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing; FALSE to cancel.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::CheckDirty"

BOOL
CProject::CheckDirty
(
    void
)
{
    TCHAR                   szProjectFile[MAX_PATH];
    
    if(!m_fDirty)
    {
        return TRUE;
    }

    if(m_szProjectFile[0])
    {
        _tcsncpy(szProjectFile, m_szProjectFile, NUMELMS(szProjectFile));
    }
    else
    {
        FormatStringResource(szProjectFile, NUMELMS(szProjectFile), IDS_UNNAMED_PROJECT);
    }

    switch(MsgBoxResource(g_pApplication->m_MainFrame, MB_ICONQUESTION | MB_YESNOCANCEL, IDS_SAVE_CHANGES, szProjectFile))
    {
        case IDYES:
            return Save();

        case IDNO:
            return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  UpdateAppTitle
 *
 *  Description:
 *      Updates the main frame's application title.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::UpdateAppTitle"

void
CProject::UpdateAppTitle
(
    void
)
{
    TCHAR                   szTitle[MAX_PATH + 0x100];

    if(!m_fUpdateAppTitle)
    {
        return;
    }

    if(m_szProjectFile[0])
    {
        _tsplitpath(m_szProjectFile, NULL, NULL, szTitle, NULL);
    }
    else
    {
        FormatStringResource(szTitle, NUMELMS(szTitle), IDS_UNNAMED_PROJECT);
    }

    if(m_fDirty)
    {
        _tcscat(szTitle, TEXT(" *"));
    }

    _tcscat(szTitle, TEXT(" - "));
    _tcscat(szTitle, g_szAppTitle);

    g_pApplication->m_MainFrame.SetWindowText(szTitle);
}


/****************************************************************************
 *
 *  EnableAppTitleUpdates
 *
 *  Description:
 *      Toggles whether the project updates the application title.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable.
 *
 *  Returns:  
 *      BOOL: previous value.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::EnableAppTitleUpdates"

BOOL
CProject::EnableAppTitleUpdates
(
    BOOL                    fEnable
)
{
    const BOOL              fPrevious   = m_fUpdateAppTitle;

    m_fUpdateAppTitle = fEnable;

    if(fEnable && !fPrevious)
    {
        UpdateAppTitle();
    }

    return fPrevious;
}


/****************************************************************************
 *
 *  Build
 *
 *  Description:
 *      Builds the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::Build"

BOOL
CProject::Build
(
    void
)
{
    BOOL                    fSuccess    = TRUE;
    DWORD                   dwThreadId;

    ASSERT(!IS_VALID_HANDLE_VALUE(m_hThread));

    //
    // Reset the build event
    //

    ResetEvent(m_hBuildEvent);

    //
    // Create the build thread
    //

    m_hThread = CreateThread(NULL, 0, BuildThreadProc, this, 0, &dwThreadId);
    fSuccess = IS_VALID_HANDLE_VALUE(m_hThread);

    //
    // Pop the build dialog
    //
    
    if(fSuccess)
    {
        fSuccess = m_BuildDialog.DoModal(&g_pApplication->m_MainFrame);
    }

    //
    // Clean up
    //

    CLOSE_HANDLE(m_hThread);

    return fSuccess;
}


/****************************************************************************
 *
 *  BuildThread
 *
 *  Description:
 *      Build worker thread procedure.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: thread exit code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CProject::BuildThread"

DWORD
CProject::BuildThread
(
    void
)
{
    HRESULT                 hr;
    
    //
    // Wait for the go-ahead
    //

    WaitForSingleObject(m_hBuildEvent, INFINITE);

    //
    // Build wave banks
    //

    hr = m_pWaveBankProject->Generate(&m_BuildDialog.m_WaveBundler, TRUE);

    //
    // Post a message to the build dialog to tell it that we're done
    //

    m_BuildDialog.PostMessage(WM_PROJECT_BUILDDONE, 0, hr);

    return hr;
}


/****************************************************************************
 *
 *  CProjectBuildDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProjectBuildDialog::CProjectBuildDialog"

CProjectBuildDialog::CProjectBuildDialog
(
    void
)
:   CDialog(IDD)
{
}


/****************************************************************************
 *
 *  ~CProjectBuildDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProjectBuildDialog::~CProjectBuildDialog"

CProjectBuildDialog::~CProjectBuildDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProjectBuildDialog::HandleMessage"

BOOL 
CProjectBuildDialog::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_PROJECT_BUILDDONE:
            fHandled = OnBuildDone((HRESULT)lParam, plResult);
            break;

        default:
            fHandled = CDialog::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProjectBuildDialog::OnCreate"

BOOL
CProjectBuildDialog::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    HWND                    hWndChildFrame  = GetDlgItem(IDC_PLACEHOLDER);
    UINT                    nProgressSteps;
    RECT                    rcPlaceholder;
    
    if(CDialog::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Determine the total number of steps in building the project
    //

    nProgressSteps = g_pApplication->m_Project.m_pWaveBankProject->m_dwEntryCount;

    //
    // Initialize controls
    //

    SendDlgItemMessage(IDC_OVERALL_PROGRESS, PBM_SETRANGE32, 0, nProgressSteps);

    //
    // Load child dialogs
    //

    ::GetWindowRect(GetDlgItem(IDC_PLACEHOLDER), &rcPlaceholder);
    ScreenToClient(&rcPlaceholder);

    m_WaveBundler.Create(this);
    m_WaveBundler.MoveWindow(&rcPlaceholder);

    //
    // Start building
    //

    SetEvent(g_pApplication->m_Project.m_hBuildEvent);

    //
    // Return TRUE to set the keyboard focus
    //

    return TRUE;
}


/****************************************************************************
 *
 *  OnBuildDone
 *
 *  Description:
 *      Handles WM_PROJECT_BUILDDONE messages.
 *
 *  Arguments:
 *      HRESULT [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProjectBuildDialog::OnBuildDone"

BOOL
CProjectBuildDialog::OnBuildDone
(
    HRESULT                 hr,
    LRESULT *               plResult
)
{
    UINT                    nStringId;
    
    //
    // Update the UI
    //

    ShowWindow(m_WaveBundler, SW_HIDE);

    switch(hr)
    {
        case S_OK:
            nStringId = IDS_BUILD_SUCCEEDED;
            break;

        case E_ABORT:
            nStringId = IDS_BUILD_ABORTED;
            break;

        default:
            nStringId = IDS_BUILD_FAILED;
            break;
    }
    
    SetDlgItemText(IDC_PLACEHOLDER, FormatStringResourceStatic(nStringId));
    SetDlgItemText(IDCANCEL, FormatStringResourceStatic(IDS_CLOSE));

    EnableWindow(GetDlgItem(IDCANCEL), TRUE);

    //
    // Alert the user
    //
    
    MessageBeep(MB_ICONEXCLAMATION);

    *plResult = 0;
    return TRUE;
}


/****************************************************************************
 *
 *  OnCmdCancel
 *
 *  Description:
 *      Handles the Cancel command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CProjectBuildDialog::OnCmdCancel"

void
CProjectBuildDialog::OnCmdCancel
(
    void
)
{
    DWORD                   dwExitCode  = ~STILL_ACTIVE;
    
    //
    // If the thread is still running, we can't just close the dialog
    //

    GetExitCodeThread(g_pApplication->m_Project.m_hThread, &dwExitCode);

    if(STILL_ACTIVE == dwExitCode)
    {
        g_pApplication->m_Project.CancelBuild();
        
        SetDlgItemText(IDCANCEL, FormatStringResourceStatic(IDS_ABORTING));
        EnableWindow(GetDlgItem(IDCANCEL), FALSE);
    }
    else
    {
        CDialog::OnCmdCancel();
    }
}


/****************************************************************************
 *
 *  CWaveBundlerBuildDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::CWaveBundlerBuildDialog"

CWaveBundlerBuildDialog::CWaveBundlerBuildDialog
(
    void
)
:   CDialog(IDD)
{
}


/****************************************************************************
 *
 *  ~CWaveBundlerBuildDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::~CWaveBundlerBuildDialog"

CWaveBundlerBuildDialog::~CWaveBundlerBuildDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  BeginProject
 *
 *  Description:
 *      Status callback.
 *
 *  Arguments:
 *      CWaveBankProject * [in]: project.
 *
 *  Returns:  
 *      BOOL: TRUE to continue.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::BeginProject"

BOOL
CWaveBundlerBuildDialog::BeginProject
(
    CWaveBankProject *      pProject
)
{
    //
    // Make the dialog visible
    //

    ShowWindow(m_hWnd, SW_SHOW);

    //
    // Check for a cancellation
    //

    return !g_pApplication->m_Project.CheckBuildCancellation();
}


/****************************************************************************
 *
 *  EndProject
 *
 *  Description:
 *      Status callback.
 *
 *  Arguments:
 *      CWaveBankProject * [in]: project.
 *      HRESULT [in]: result code.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::EndProject"

void
CWaveBundlerBuildDialog::EndProject
(
    CWaveBankProject *      pProject,
    HRESULT                 hr
)
{
    //
    // Hide the dialog
    //

    ShowWindow(m_hWnd, SW_HIDE);
}


/****************************************************************************
 *
 *  OpenBank
 *
 *  Description:
 *      Status callback.
 *
 *  Arguments:
 *      CWaveBank * [in]: bank.
 *
 *  Returns:  
 *      BOOL: TRUE to continue.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::OpenBank"

BOOL
CWaveBundlerBuildDialog::OpenBank
(
    CWaveBank *             pBank
)
{
    //
    // Update the UI
    //
    
    SetDlgItemText(IDC_CURRENT_BANK, pBank->m_szBankName);

    //
    // Set up progress indicators
    //

    SendDlgItemMessage(IDC_BANK_PROGRESS, PBM_SETPOS, 0, 0);
    SendDlgItemMessage(IDC_BANK_PROGRESS, PBM_SETRANGE32, 0, pBank->m_dwEntryCount);

    //
    // Check for a cancellation
    //

    return !g_pApplication->m_Project.CheckBuildCancellation();
}


/****************************************************************************
 *
 *  BeginEntry
 *
 *  Description:
 *      Status callback.
 *
 *  Arguments:
 *      CWaveBankEntry * [in]: entry.
 *
 *  Returns:  
 *      BOOL: TRUE to continue.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::BeginEntry"

BOOL
CWaveBundlerBuildDialog::BeginEntry
(
    CWaveBankEntry *        pEntry
)
{
    //
    // Update the UI
    //

    SetDlgItemText(IDC_CURRENT_ENTRY, pEntry->m_szEntryName);

#ifdef IDC_ENTRY_PROGRESS

    //
    // Set up progress indicators
    //

    SendDlgItemMessage(IDC_ENTRY_PROGRESS, PBM_SETPOS, 0, 0);
    SendDlgItemMessage(IDC_ENTRY_PROGRESS, PBM_SETRANGE32, 0, pEntry->m_PlayRegion.dwLength);

#endif // IDC_ENTRY_PROGRESS

    //
    // Check for a cancellation
    //

    return !g_pApplication->m_Project.CheckBuildCancellation();
}


/****************************************************************************
 *
 *  ProcessEntry
 *
 *  Description:
 *      Status callback.
 *
 *  Arguments:
 *      CWaveBankEntry * [in]: entry.
 *      DWORD [in]: number of bytes that have been read up to this point.
 *
 *  Returns:  
 *      BOOL: TRUE to continue.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::ProcessEntry"

BOOL
CWaveBundlerBuildDialog::ProcessEntry
(
    CWaveBankEntry *        pEntry,
    DWORD                   dwProcessed
)
{

#ifdef IDC_ENTRY_PROGRESS

    //
    // Update the UI
    //

    SendDlgItemMessage(IDC_ENTRY_PROGRESS, PBM_SETPOS, dwProcessed, 0);

#endif // IDC_ENTRY_PROGRESS

    //
    // Check for a cancellation
    //

    return !g_pApplication->m_Project.CheckBuildCancellation();
}


/****************************************************************************
 *
 *  EndEntry
 *
 *  Description:
 *      Status callback.
 *
 *  Arguments:
 *      CWaveBankEntry * [in]: entry.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBundlerBuildDialog::EndEntry"

void
CWaveBundlerBuildDialog::EndEntry
(
    CWaveBankEntry *        pEntry
)
{
    //
    // Update the UI
    //

    SendDlgItemMessage(IDC_BANK_PROGRESS, PBM_DELTAPOS, 1, 0);
    m_pParent->SendDlgItemMessage(IDC_OVERALL_PROGRESS, PBM_DELTAPOS, 1, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\project.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/13/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       project.h
 *  Content:    Project object (parser, object manager).
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/13/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __PROJECT_H__
#define __PROJECT_H__

#ifdef __cplusplus

//
// Forward declarations
//

class CGuiWaveBankProject;
class CGuiWaveBank;
class CGuiWaveBankEntry;

//
// Wave Bundler child build dialog
//

class CWaveBundlerBuildDialog
    : public CDialog, public CWaveBankCallback
{
public:
    enum
    {
        IDD = IDD_BUILD_WAVEBUNDLER
    };

public:
    CWaveBundlerBuildDialog(void);
    virtual ~CWaveBundlerBuildDialog(void);

protected:
    // Build callbacks
    virtual BOOL BeginProject(CWaveBankProject *pProject);
    virtual void EndProject(CWaveBankProject *pProject, HRESULT hr);
    virtual BOOL OpenBank(CWaveBank *pBank);
    virtual BOOL BeginEntry(CWaveBankEntry *pEntry);
    virtual BOOL ProcessEntry(CWaveBankEntry *pEntry, DWORD dwProcessed);
    virtual void EndEntry(CWaveBankEntry *pEntry);
};    

//
// Parent build dialog
//

class CProjectBuildDialog
    : public CDialog
{
public:
    enum
    {
        IDD = IDD_BUILD
    };

    CWaveBundlerBuildDialog m_WaveBundler;      // Wave Bundler build dialog

public:
    CProjectBuildDialog(void);
    virtual ~CProjectBuildDialog(void);

public:
    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnBuildDone(HRESULT hr, LRESULT *plResult);

    // Command handlers
    virtual void OnCmdCancel(void);
};

//
// Project object
//

class CProject
{
    friend class CWaveBundlerBuildDialog;
    friend class CProjectBuildDialog;

protected:
    TCHAR                   m_szProjectFile[MAX_PATH];      // Project file path
    CGuiWaveBankProject *   m_pWaveBankProject;             // Wave Bundler sub-project
    BOOL                    m_fDirty;                       // Project status
    HANDLE                  m_hBuildEvent;                  // Build start event
    HANDLE                  m_hThread;                      // Build thread
    CProjectBuildDialog     m_BuildDialog;                  // Build dialog
    BOOL                    m_fUpdateAppTitle;              // Update the app title?

public:
    CProject(void);
    virtual ~CProject(void);

public:
    // Project file
    virtual BOOL New(void);
    virtual BOOL Open(LPCTSTR pszProjectFile = NULL);
    virtual BOOL Reopen(void);
    virtual BOOL Save(void);
    virtual BOOL SaveAs(void);
    
    // Building
    virtual BOOL Build(void);

    // Wave Bundler
    virtual BOOL AddWaveBank(void);

    // Project status
    virtual BOOL IsDirty(void);
    virtual void MakeDirty(void);
    virtual BOOL CheckDirty(void);

    // Build status
    virtual void CancelBuild(void);
    virtual BOOL CheckBuildCancellation(void);

    // UI helpers
    virtual BOOL EnableAppTitleUpdates(BOOL fEnable);
    virtual void UpdateAppTitle(void);

protected:
    // Project file
    virtual BOOL New(BOOL fResetFilePath, BOOL fConfirm);
    virtual BOOL Open(LPCTSTR pszProjectFile, BOOL fConfirm);
    virtual BOOL Reopen(BOOL fConfirm);

    // Project status
    virtual void MakeDirty(BOOL fDirty);
    virtual void Reset(void);

private:
    // Worker thread
    virtual DWORD BuildThread(void);
    static DWORD WINAPI BuildThreadProc(LPVOID pvContext);
};

__inline BOOL CProject::New(void)
{
    return New(TRUE, TRUE);
}

__inline BOOL CProject::Open(LPCTSTR pszProjectFile)
{
    return Open(pszProjectFile, TRUE);
}

__inline BOOL CProject::Reopen(void)
{
    return Reopen(TRUE);
}

__inline BOOL CProject::IsDirty(void)
{
    return m_fDirty;
}

__inline void CProject::MakeDirty(void)
{
    MakeDirty(TRUE);
}

__inline void CProject::MakeDirty(BOOL fDirty)
{
    m_fDirty = fDirty;
    UpdateAppTitle();
}

__inline void CProject::CancelBuild(void)
{
    ResetEvent(m_hBuildEvent);
}

__inline BOOL CProject::CheckBuildCancellation(void)
{
    return WAIT_TIMEOUT == WaitForSingleObject(m_hBuildEvent, 0);
}

__inline DWORD CProject::BuildThreadProc(LPVOID pvContext)
{
    return ((CProject *)pvContext)->BuildThread();
}

#endif // __cplusplus

#endif // __PROJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\mainfrm.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/4/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mainfrm.h
 *  Content:    Main window frame.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/4/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __MAINFRM_H__
#define __MAINFRM_H__

#ifdef __cplusplus

//
// Forward declarations
//

class CMainFrame;
class CWorkspaceChild;
class CGuiWaveBankListWindow;
class CMainProjectTree;

//
// Main status bar
//

class CMainStatusBar
    : public CWindow
{
public:
    CMainStatusBar(void);
    virtual ~CMainStatusBar(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(void);
};

__inline ULONG CMainStatusBar::AddRef(void)
{
    return 1;
}

__inline ULONG CMainStatusBar::Release(void)
{
    return 1;
}

//
// Main toolbar
//

class CMainToolBar
    : public CToolBar
{
public:
    
    //
    // Toolbar bitmap images
    //

    enum
    {
        BTN_WAVEBANK = 0,
        BTN_WAVEBANK_ENTRY,
        BTN_BUILD,
        BTN_ADPCM,
        BTN_8BIT,
        BTN_PLAY,
        BTN_STOP,
        BTN_CONNECT,
        BTN_DISCONNECT,
        BTN_COUNT
    };

public:
    CMainToolBar(void);
    virtual ~CMainToolBar(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(void);
};

__inline ULONG CMainToolBar::AddRef(void)
{
    return 1;
}

__inline ULONG CMainToolBar::Release(void)
{
    return 1;
}

//
// Project tree item
//

class CMainProjectTreeItem
    : public CTreeViewItem
{
public:
    CMainProjectTreeItem(void);
    virtual ~CMainProjectTreeItem(void);

public:
    // Creation
    virtual BOOL Create(CMainProjectTree *pTree, CMainProjectTreeItem *pParentItem, LPCTSTR pszText, LPCTSTR pszType, LPVOID pvContext = NULL);

    // Message handlers
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult);
};

__inline BOOL CMainProjectTreeItem::OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult)
{
    return FALSE;
}

//
// Project tree category item
//

class CMainProjectTreeCategory
    : public CMainProjectTreeItem
{
public:
    CMainProjectTreeCategory(void);
    virtual ~CMainProjectTreeCategory(void);

public:
    // Creation
    virtual BOOL Create(CMainProjectTree *pTree, UINT nStringId, UINT nIconId);
};

//
// Project tree object
//

class CMainProjectTree
    : public CTreeView
{
public:
    static const LPCTSTR        m_pszWaveBankType;      // Tree control registered type name
    CMainProjectTreeCategory    m_WaveBundlerCategory;  // Wave Bundler category item

public:
    CMainProjectTree(void);
    virtual ~CMainProjectTree(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(void);

    // Message handlers
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult);
};

__inline ULONG CMainProjectTree::AddRef(void)
{
    return 1;
}

__inline ULONG CMainProjectTree::Release(void)
{
    return 1;
}

//
// Main window vertical splitter
//

class CMainSplitter
    : public CWindow
{
    friend class CMainFrame;

public:
    static const LPCTSTR    m_pszClassName;         // Class name
    static const UINT       m_nWidth;               // Splitter width

protected:
    int                     m_nPosition;            // X-coordinate
    BOOL                    m_fDragging;            // Drag operation in progress?

public:
    CMainSplitter(void);
    virtual ~CMainSplitter(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(void);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnMouseButtonDown(DWORD dwKeys, int x, int y, LRESULT *plResult);
    virtual BOOL OnMouseButtonUp(DWORD dwKeys, int x, int y, LRESULT *plResult);
    virtual BOOL OnMouseMove(DWORD dwKeys, int x, int y, LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
};

__inline ULONG CMainSplitter::AddRef(void)
{
    return 1;
}

__inline ULONG CMainSplitter::Release(void)
{
    return 1;
}

//
// Main window workspace
//

class CMainWorkspace
    : public CMDIClientWindow
{
public:
    CMainWorkspace(void);
    virtual ~CMainWorkspace(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Creation
    virtual BOOL Create(void);
};

__inline ULONG CMainWorkspace::AddRef(void)
{
    return 1;
}

__inline ULONG CMainWorkspace::Release(void)
{
    return 1;
}

//
// Workspace child window
//

class CWorkspaceChild
    : public CMDIChildWindow
{
public:
    enum
    {
        WKSPCTYPE_WAVEBANK = 0,
    };

    static const LPCTSTR    m_pszClassName;     // Class name
    const UINT              m_nWorkspaceType;   // Window type

public:
    CWorkspaceChild(UINT nWorkspaceType);
    virtual ~CWorkspaceChild(void);

public:
    // Creation
    virtual BOOL Create(LPCTSTR pszWindowTitle, UINT nIconId, LPBOOL pfOpened = NULL);

    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
};

//
// Main window frame
//

class CMainFrame
    : public CMDIFrameWindow
{
    friend class CMainSplitter;

public:
    
    //
    // Control identifiers
    //
    
    enum
    {
        IDC_MAIN_TOOLBAR = 1,
        IDC_MAIN_PROJECTTREE,
        IDC_MAIN_SPLITTER,
        IDC_MAIN_WORKSPACE,
        IDC_MAIN_STATUSBAR,
        IDC_MAIN_FIRSTMDICHILD,
    };

    //
    // Menu item indices
    //

    enum
    {
        MENUPOS_FILE = 0,
        MENUPOS_FILE_MRU = 7,
        MENUPOS_WINDOW = 4,
    };

    //
    // Secondary menu indices
    //

    enum
    {
        MENUIDX_WAVEBANK_POPUP = 0,
        MENUIDX_WAVEBANK_ENTRY_POPUP,
        MENUIDX_COUNT
    };

    //
    // Command forwarding flags
    //

    enum
    {
        FORWARD_FOCUS = 0,
        FORWARD_ACTIVE_WORKSPACE_CHILD,
    };

public:
    static const LPCTSTR    m_pszClassName;             // Window class
                                                        
public:                                                 
    CMainToolBar            m_ToolBar;                  // Toolbar
    CMainStatusBar          m_StatusBar;                // Status bar
    CMainProjectTree        m_ProjectTree;              // Project tree
    CMainSplitter           m_Splitter;                 // Vertical splitter
    CMainWorkspace          m_Workspace;                // Workspace
    HMENU                   m_ahMenus[MENUIDX_COUNT];   // Secondary menus

public:
    CMainFrame(void);
    virtual ~CMainFrame(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Initialization
    virtual int Create(int nShowCmd);

    // Control layout
    virtual void LayoutControls(BOOL fRepaint = TRUE);
    virtual void LayoutControls(UINT nWidth, UINT nHeight, BOOL fRepaint = TRUE);

    // Command helpers
    virtual void EnableCommand(UINT nCommandId, BOOL fEnable);
    virtual void CheckCommand(UINT nCommandId, BOOL fChecked);
    virtual void SetDefaultCommandState(void);

    // Message pump
    virtual int PumpMessages(void);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnClose(LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
    virtual BOOL OnMenuSelect(UINT nMenuItem, UINT nFlags, HMENU hMenu, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult);
    virtual BOOL OnNotify(LPNMHDR pHdr, LRESULT *plResult);

    // Command handlers
    virtual BOOL ForwardCommand(UINT nForward, UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult);
    virtual void OnCmdNewProject(void);
    virtual void OnCmdOpenProject(void);
    virtual void OnCmdReloadProject(void);
    virtual void OnCmdSaveProject(void);
    virtual void OnCmdSaveProjectAs(void);
    virtual void OnCmdExit(void);
    virtual void OnCmdAbout(void);
    virtual void OnCmdWindowNext(void);
    virtual void OnCmdWindowPrev(void);
    virtual void OnCmdWindowCascade(void);
    virtual void OnCmdWindowTileHorz(void);
    virtual void OnCmdWindowTileVert(void);
    virtual void OnCmdWindowClose(void);
    virtual void OnCmdWindowCloseAll(void);
    virtual void OnCmdAddWaveBank(void);
    virtual void OnCmdBuild(void);
    virtual void OnCmdConnect(void);
    virtual void OnCmdDisconnect(void);

    // Notification handlers
    virtual void OnToolTipDisplayInfo(LPNMTTDISPINFO pHdr);
};

__inline ULONG CMainFrame::AddRef(void)
{
    return 1;
}

__inline ULONG CMainFrame::Release(void)
{
    return 1;
}

//
// The main application object
//

class CApplication
{
public:
    CRegistry               m_Registry;         // Application registry
    CMainFrame              m_MainFrame;        // Main window frame
    CProject                m_Project;          // Project object
    CMRU                    m_MRU;              // Most-recently-used file list
    CRemoteAudition         m_RemoteAudition;   // Remote audition object

public:
    CApplication(void);
    virtual ~CApplication(void);
};

extern CApplication *g_pApplication;

#endif // __cplusplus

#endif // __MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\mainfrm.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/4/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mainfrm.cpp
 *  Content:    Main window frame.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/4/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactapp.h"

const LPCTSTR CMainFrame::m_pszClassName = XACTGUI_MAKE_WNDCLASS_NAME("MainFrame");

const LPCTSTR CMainSplitter::m_pszClassName = XACTGUI_MAKE_WNDCLASS_NAME("MainSplitter");
const UINT CMainSplitter::m_nWidth = 4;

const LPCTSTR CMainProjectTree::m_pszWaveBankType = TEXT("Wave Bank");

const LPCTSTR CWorkspaceChild::m_pszClassName = XACTGUI_MAKE_WNDCLASS_NAME("WorkspaceChild");

CApplication *g_pApplication = NULL;


/****************************************************************************
 *
 *  WinMain
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      HINSTANCE [in]: application instance handle.
 *      HINSTANCE [in]: unused.
 *      LPSTR [in]: application command-line.
 *      int [in]: application show command.
 *
 *  Returns:  
 *      int: application return code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WinMain"

int WINAPI
WinMain
(
    HINSTANCE               hInstance,
    HINSTANCE               hPrevInstance,
    LPSTR                   pszCmdLine,
    int                     nShowCmd
)
{
    INITCOMMONCONTROLSEX    icc;
    int                     nResult;

    //
    // Initialize globals
    //

    CWaveBankEntry::m_fAutoLoad = FALSE;

    //
    // Initialize the common controls library
    //

    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_BAR_CLASSES | ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_TREEVIEW_CLASSES | ICC_UPDOWN_CLASS;
    
    if(!InitCommonControlsEx(&icc))
    {
        DPF_ERROR("InitCommonControlsEx failed");
        return -1;
    }

    //
    // Load the application title
    //
    
    if(!LoadString(hInstance, IDS_APPTITLE, g_szAppTitle, NUMELMS(g_szAppTitle)))
    {
        DPF_ERROR("Failed to load application title");
        return -1;
    }

#ifdef _DEBUG

    strcat(g_szAppTitle, " (debug)");

#endif // _DEBUG

    //
    // Create the application object
    //
    
    if(!(g_pApplication = NEW(CApplication)))
    {
        return -1;
    }
    
    nResult = g_pApplication->m_MainFrame.Create(nShowCmd);

    DELETE(g_pApplication);

    //
    // Check for leaks
    //

    CMemoryManager::DumpMemoryUsage(TRUE);

    return nResult;
}


/****************************************************************************
 *
 *  CApplication
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CApplication::CApplication"

CApplication::CApplication
(
    void
)
:   m_Registry(HKEY_XACT_APPLICATION_ROOT, REGKEY_XACT_APPLICATION_ROOT),
    m_MRU(m_Registry, REGKEY_PROJECT_MRU)
{
}


/****************************************************************************
 *
 *  ~CApplication
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CApplication::~CApplication"

CApplication::~CApplication
(
    void
)
{
}


/****************************************************************************
 *
 *  CMainFrame
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::CMainFrame"

CMainFrame::CMainFrame
(
    void
)
:   CMDIFrameWindow(IDM_MAIN, IDA_MAIN)
{
}


/****************************************************************************
 *
 *  ~CMainFrame
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::~CMainFrame"

CMainFrame::~CMainFrame
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      int [in]: window show command.
 *
 *  Returns:  
 *      int: application exit code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::Create"

int
CMainFrame::Create
(
    int                     nShowCmd
)
{
    static const DWORD      dwExStyle   = 0;
    DWORD                   dwStyle     = WS_OVERLAPPEDWINDOW;
    WNDCLASSEX              wc          = { 0 };
    LPTSTR                  pszCmdLine  = NULL;
    LPTSTR                  pszProject  = NULL;
    WINDOWPLACEMENT         wp;
    HRESULT                 hr;

    //
    // Register the window class
    //

    wc.cbSize = sizeof(wc);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpfnWndProc = WindowProc;
    wc.hIcon = LoadResourceIconLarge(IDI_XACT);
    wc.hIconSm = LoadResourceIconSmall(IDI_XACT);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hInstance = g_hInstance;
    wc.lpszClassName = m_pszClassName;

    RegisterClassEx(&wc);

    //
    // Load window placement data
    //
    
    if(g_pApplication->m_Registry.GetBinaryValue(REGKEY_MAINFRAME_PLACEMENT, &wp, sizeof(wp)))
    {
        wp.rcNormalPosition.right -= wp.rcNormalPosition.left;
        wp.rcNormalPosition.bottom -= wp.rcNormalPosition.top;

        if((SW_SHOWNORMAL == nShowCmd) && (SW_MAXIMIZE == wp.showCmd))
        {
            nShowCmd = SW_SHOWMAXIMIZED;
        }
    }
    else
    {
        wp.rcNormalPosition.left = CW_USEDEFAULT;
        wp.rcNormalPosition.top = CW_USEDEFAULT;
        wp.rcNormalPosition.right = CW_USEDEFAULT;
        wp.rcNormalPosition.bottom = CW_USEDEFAULT;
    }

    //
    // Create the window
    //

    if(!CMDIFrameWindow::Create(m_pszClassName, g_szAppTitle, dwExStyle, dwStyle, wp.rcNormalPosition.left, wp.rcNormalPosition.top, wp.rcNormalPosition.right, wp.rcNormalPosition.bottom))
    {
        return -1;
    }

    ShowWindow(m_hWnd, nShowCmd);

    //
    // Load project data
    //

    if(ParseCommandLine(GetCommandLine(), &pszCmdLine, NULL))
    {
        pszProject = pszCmdLine + _tcslen(pszCmdLine) + 1;

        if(!*pszProject)
        {
            pszProject = NULL;
        }
    }

    if(pszProject)
    {
        g_pApplication->m_Project.Open(pszProject);
    }
    else
    {
        g_pApplication->m_Project.New();
    }
        
    MEMFREE(pszCmdLine);

    //
    // Enter the message pump
    //

    return PumpMessages();
}


/****************************************************************************
 *
 *  PumpMessages
 *
 *  Description:
 *      Window message pump.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      int: application exit code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::PumpMessages"

int
CMainFrame::PumpMessages
(
    void
)
{
    MSG                     msg;

    while(GetMessage(&msg, NULL, 0, 0) > 0)
    {
        if(!DispatchMessage(&msg))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }

    ASSERT(WM_QUIT == msg.message);

    return msg.wParam;
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::HandleMessage"

BOOL 
CMainFrame::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_MENUSELECT:
            fHandled = OnMenuSelect(LOWORD(wParam), HIWORD(wParam), (HMENU)lParam, plResult);
            break;

        default:
            fHandled = CMDIFrameWindow::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCreate"

BOOL
CMainFrame::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    HMENU                   hFileMenu;
    HMENU                   hMRUMenu;
    BOOL                    fSuccess;

    if(CMDIFrameWindow::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Create main window controls
    //
    
    fSuccess = m_ToolBar.Create();
    
    if(fSuccess)
    {
        fSuccess = m_StatusBar.Create();
    }
    
    if(fSuccess)
    {
        fSuccess = m_ProjectTree.Create();
    }
    
    if(fSuccess)
    {
        fSuccess = m_Splitter.Create();
    }
    
    if(fSuccess)
    {
        fSuccess = m_Workspace.Create();
    }

    //
    // Attach the MRU object
    //

    if(fSuccess)
    {
        hFileMenu = GetSubMenu(m_hMenu, MENUPOS_FILE);
        hMRUMenu = GetSubMenu(hFileMenu, MENUPOS_FILE_MRU);
        
        g_pApplication->m_MRU.AttachMenu(hMRUMenu);
    }

    //
    // Load secondary menus
    //

    if(fSuccess)
    {
        m_ahMenus[MENUIDX_WAVEBANK_POPUP] = LoadPopupMenu(IDM_WAVEBANK_POPUP);
        SetMenuDefaultItem(m_ahMenus[MENUIDX_WAVEBANK_POPUP], 0, MF_BYPOSITION);

        m_ahMenus[MENUIDX_WAVEBANK_ENTRY_POPUP] = LoadPopupMenu(IDM_WAVEBANK_ENTRY_POPUP);
        SetMenuDefaultItem(m_ahMenus[MENUIDX_WAVEBANK_ENTRY_POPUP], 0, MF_BYPOSITION);
    }

    //
    // Set default command states
    //
    
    if(fSuccess)
    {
        SetDefaultCommandState();
    }

    if(!fSuccess)
    {
        *plResult = -1;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles WM_SIZE messages.
 *
 *  Arguments:
 *      UINT [in]: resize type.
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnSize"

BOOL
CMainFrame::OnSize
(
    UINT                    nType,
    UINT                    nWidth,
    UINT                    nHeight,
    LRESULT *               plResult
)
{
    if(CMDIFrameWindow::OnSize(nType, nWidth, nHeight, plResult))
    {
        return TRUE;
    }

    if(SIZE_MINIMIZED == nType)
    {
        return FALSE;
    }
    
    LayoutControls(nWidth, nHeight);

    return FALSE;
}


/****************************************************************************
 *
 *  OnClose
 *
 *  Description:
 *      Handles WM_CLOSE messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnClose"

BOOL
CMainFrame::OnClose
(
    LRESULT *               plResult
)
{
    if(!g_pApplication->m_Project.CheckDirty())
    {
        *plResult = 0;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles WM_DESTROY messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnDestroy"

BOOL
CMainFrame::OnDestroy
(
    LRESULT *               plResult
)
{
    WINDOWPLACEMENT         wp;
    
    if(CMDIFrameWindow::OnDestroy(plResult))
    {
        return TRUE;
    }

    //
    // Close all MDI child windows
    //

    OnCmdWindowCloseAll();

    //
    // Save the window placement data
    //

    wp.length = sizeof(wp);
    
    GetWindowPlacement(m_hWnd, &wp);

    g_pApplication->m_Registry.SetBinaryValue(REGKEY_MAINFRAME_PLACEMENT, &wp, sizeof(wp));

    //
    // Terminate the main thread
    //
    
    PostQuitMessage(0);

    return FALSE;
}


/****************************************************************************
 *
 *  OnMenuSelect
 *
 *  Description:
 *      Handles selection of a menu item.
 *
 *  Arguments:
 *      UINT [in]: menu item identifier.
 *      UINT [in]: flags.
 *      HMENU [in]: menu handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnMenuSelect"

BOOL
CMainFrame::OnMenuSelect
(
    UINT                    nMenuItem, 
    UINT                    nFlags, 
    HMENU                   hMenu, 
    LRESULT *               plResult
)
{
    TCHAR                   szText[0x100];

    szText[0] = 0;

    if(g_pApplication->m_MRU.TranslateCommand(nMenuItem))
    {
        nMenuItem = ID_RECENT_FILE_0;
    }
    
    if(!(nFlags & (MF_SYSMENU | MF_POPUP)))
    {
        LoadString(g_hInstance, nMenuItem, szText, NUMELMS(szText));
    }

    m_StatusBar.SetWindowText(szText);

    return FALSE;
}


/****************************************************************************
 *
 *  OnNotify
 *
 *  Description:
 *      Handles WM_NOTIFY messages.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnNotify"

BOOL
CMainFrame::OnNotify
(
    LPNMHDR                 pHdr,
    LRESULT *               plResult
)
{
    if(CMDIFrameWindow::OnNotify(pHdr, plResult))
    {
        return TRUE;
    }
    
    switch(pHdr->code)
    {
        case TTN_GETDISPINFO:
            OnToolTipDisplayInfo((LPNMTTDISPINFO)pHdr);
            break;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnToolTipDisplayInfo
 *
 *  Description:
 *      Gets display information for a tool-tip.
 *
 *  Arguments:
 *      LPTOOLTIPTEXT [in/out]: tool tip data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnToolTipDisplayInfo"

void
CMainFrame::OnToolTipDisplayInfo
(
    LPNMTTDISPINFO          pInfo
)
{
    pInfo->hinst = g_hInstance;
    pInfo->lpszText = MAKEINTRESOURCE(pInfo->hdr.idFrom);
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles WM_COMMAND messages.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCommand"

BOOL
CMainFrame::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hWndControl,
    LRESULT *               plResult
)
{
    LPCTSTR                 pszPath;
    
    if(CMDIFrameWindow::OnCommand(nCommandId, nControlId, hWndControl, plResult))
    {
        return TRUE;
    }

    if(pszPath = g_pApplication->m_MRU.TranslateCommand(nControlId))
    {
        g_pApplication->m_Project.Open(pszPath);
        return FALSE;
    }
    
    switch(nControlId)
    {
        case ID_NEW_PROJECT:
            OnCmdNewProject();
            break;
        
        case ID_OPEN_PROJECT:
            OnCmdOpenProject();
            break;

        case ID_RELOAD_PROJECT:
            OnCmdReloadProject();
            break;

        case ID_SAVE_PROJECT:
            OnCmdSaveProject();
            break;

        case ID_SAVE_PROJECT_AS:
            OnCmdSaveProjectAs();
            break;
        
        case ID_EXIT:
            OnCmdExit();
            break;

        case ID_ABOUT:
            OnCmdAbout();
            break;

        case ID_WINDOW_NEXT:
            OnCmdWindowNext();
            break;

        case ID_WINDOW_PREV:
            OnCmdWindowPrev();
            break;

        case ID_WINDOW_CASCADE:
            OnCmdWindowCascade();
            break;

        case ID_WINDOW_TILE_HORZ:
            OnCmdWindowTileHorz();
            break;
        
        case ID_WINDOW_TILE_VERT:
            OnCmdWindowTileVert();
            break;
        
        case ID_WINDOW_CLOSE:
            OnCmdWindowClose();
            break;

        case ID_WINDOW_CLOSE_ALL:
            OnCmdWindowCloseAll();
            break;

        case ID_ADD_WAVEBANK:
            OnCmdAddWaveBank();
            break;

        case ID_BUILD:
            OnCmdBuild();
            break;

        case ID_CONNECT:
            OnCmdConnect();
            break;

        case ID_DISCONNECT:
            OnCmdDisconnect();
            break;

        case ID_ADD_WAVEBANK_ENTRY:
            return ForwardCommand(FORWARD_ACTIVE_WORKSPACE_CHILD, nCommandId, nControlId, hWndControl, plResult);

        default:
            return ForwardCommand(FORWARD_FOCUS, nCommandId, nControlId, hWndControl, plResult);
    }

    return FALSE;
}


/****************************************************************************
 *
 *  ForwardCommand
 *
 *  Description:
 *      Forwards a command on to the window with the keyboard focus.
 *
 *  Arguments:
 *      UINT [in]: forward type.
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::ForwardCommand"

BOOL
CMainFrame::ForwardCommand
(
    UINT                    nForward,
    UINT                    nCommandId, 
    UINT                    nControlId, 
    HWND                    hWndControl,
    LRESULT *               plResult
)
{
    CWindow *               pWindow;
    CMDIChildWindow *       pMDIChild;
    HWND                    hWnd;

    if(FORWARD_FOCUS == nForward)
    {
        //
        // We really want to send this to the first window in the chain that has
        // a registered handler we recognize (i.e. derived from CWindow)
        //
        // WARNING: if we forward this to a window who turns around and forwards
        // it back to us, we're screwed.
        //

        hWnd = GetFocus();
        
        while(TRUE)
        {
            if(pWindow = GetWindowContext(hWnd))
            {
                break;
            }

            hWnd = GetParent(hWnd);
        }

        if(this == pWindow)
        {
            return FALSE;
        }
    }
    else if(FORWARD_ACTIVE_WORKSPACE_CHILD == nForward)
    {
        if(m_Workspace.GetActiveChild(&pMDIChild))
        {
            pWindow = pMDIChild;
        }
    }
    else
    {
        ASSERTMSG("Invalid forward type");
        return FALSE;
    }

    return pWindow->OnCommand(nCommandId, nControlId, hWndControl, plResult);
}


/****************************************************************************
 *
 *  OnCmdNewProject
 *
 *  Description:
 *      Creates a new project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdNewProject"

void
CMainFrame::OnCmdNewProject
(
    void
)
{
    g_pApplication->m_Project.New();
}


/****************************************************************************
 *
 *  OnCmdOpenProject
 *
 *  Description:
 *      Opens a new project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdOpenProject"

void
CMainFrame::OnCmdOpenProject
(
    void
)
{
    g_pApplication->m_Project.Open();
}


/****************************************************************************
 *
 *  OnCmdReloadProject
 *
 *  Description:
 *      Reopens the current project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdReloadProject"

void
CMainFrame::OnCmdReloadProject
(
    void
)
{
    g_pApplication->m_Project.Reopen();
}


/****************************************************************************
 *
 *  OnCmdSaveProject
 *
 *  Description:
 *      Saves the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdSaveProject"

void
CMainFrame::OnCmdSaveProject
(
    void
)
{
    g_pApplication->m_Project.Save();
}


/****************************************************************************
 *
 *  OnCmdSaveProjectAs
 *
 *  Description:
 *      Saves the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdSaveProjectAs"

void
CMainFrame::OnCmdSaveProjectAs
(
    void
)
{
    g_pApplication->m_Project.SaveAs();
}


/****************************************************************************
 *
 *  OnCmdAddWaveBank
 *
 *  Description:
 *      Adds a wave bank to the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdAddWaveBank"

void
CMainFrame::OnCmdAddWaveBank
(
    void
)
{
    g_pApplication->m_Project.AddWaveBank();
}


/****************************************************************************
 *
 *  OnCmdBuild
 *
 *  Description:
 *      Builds the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdBuild"

void
CMainFrame::OnCmdBuild
(
    void
)
{
    g_pApplication->m_Project.Build();
}


/****************************************************************************
 *
 *  OnCmdConnect
 *
 *  Description:
 *      Connects to a remote instance of Audio Console.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdConnect"

void
CMainFrame::OnCmdConnect
(
    void
)
{
    g_pApplication->m_RemoteAudition.Connect();
}


/****************************************************************************
 *
 *  OnCmdDisconnect
 *
 *  Description:
 *      Disconnects from a remote instance of Audio Console.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdDisconnect"

void
CMainFrame::OnCmdDisconnect
(
    void
)
{
    g_pApplication->m_RemoteAudition.Disconnect();
}


/****************************************************************************
 *
 *  OnCmdExit
 *
 *  Description:
 *      Handles the Exit command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdExit"

void
CMainFrame::OnCmdExit
(
    void
)
{
    PostMessage(WM_DESTROY);
}


/****************************************************************************
 *
 *  OnCmdAbout
 *
 *  Description:
 *      Handles the About command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdAbout"

void
CMainFrame::OnCmdAbout
(
    void
)
{
    TCHAR                   szVersion[0x100];
    LPCTSTR                 pszString;
    HICON                   hIcon;
    HWND                    hWndFocus;

    GetXDKVersion(szVersion);

    pszString = FormatStringResourceStatic(IDS_XDKVERSION, szVersion);
    hIcon = LoadResourceIconLarge(IDI_XACT);

    hWndFocus = GetFocus();
    
    ShellAbout(m_hWnd, g_szAppTitle, pszString, hIcon);

    SetFocus(hWndFocus);
}


/****************************************************************************
 *
 *  OnCmdWindowPrev
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowPrev"

void
CMainFrame::OnCmdWindowPrev
(
    void
)
{
    m_Workspace.SendMessage(WM_MDINEXT, NULL, TRUE);
}


/****************************************************************************
 *
 *  OnCmdWindowNext
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowNext"

void
CMainFrame::OnCmdWindowNext
(
    void
)
{
    m_Workspace.SendMessage(WM_MDINEXT, NULL, FALSE);
}


/****************************************************************************
 *
 *  OnCmdWindowCascade
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowCascade"

void
CMainFrame::OnCmdWindowCascade
(
    void
)
{
    m_Workspace.SendMessage(WM_MDICASCADE);
}


/****************************************************************************
 *
 *  OnCmdWindowTileHorz
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowTileHorz"

void
CMainFrame::OnCmdWindowTileHorz
(
    void
)
{
    m_Workspace.SendMessage(WM_MDITILE, MDITILE_HORIZONTAL);
}


/****************************************************************************
 *
 *  OnCmdWindowTileVert
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowTileVert"

void
CMainFrame::OnCmdWindowTileVert
(
    void
)
{
    m_Workspace.SendMessage(WM_MDITILE, MDITILE_VERTICAL);
}


/****************************************************************************
 *
 *  OnCmdWindowClose
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowClose"

void
CMainFrame::OnCmdWindowClose
(
    void
)
{
    HWND                    hWnd;

    hWnd = (HWND)m_Workspace.SendMessage(WM_MDIGETACTIVE);
    
    m_Workspace.SendMessage(WM_MDIDESTROY, (WPARAM)hWnd);
}


/****************************************************************************
 *
 *  OnCmdWindowCloseAll
 *
 *  Description:
 *      Handles window commands.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::OnCmdWindowCloseAll"

void
CMainFrame::OnCmdWindowCloseAll
(
    void
)
{
    HWND                    hWnd;

    while(TRUE)
    {
        if(!(hWnd = (HWND)m_Workspace.SendMessage(WM_MDIGETACTIVE)))
        {
            break;
        }
    
        m_Workspace.SendMessage(WM_MDIDESTROY, (WPARAM)hWnd);
    }
}


/****************************************************************************
 *
 *  LayoutControls
 *
 *  Description:
 *      Moves the controls around.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::LayoutControls"

void
CMainFrame::LayoutControls
(
    BOOL                    fRepaint
)
{
    RECT                    rcClient;

    GetClientRect(&rcClient);

    LayoutControls(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, fRepaint);
}


/****************************************************************************
 *
 *  LayoutControls
 *
 *  Description:
 *      Moves the controls around.
 *
 *  Arguments:
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::LayoutControls"

void
CMainFrame::LayoutControls
(
    UINT                    nWidth,
    UINT                    nHeight,
    BOOL                    fRepaint
)
{
    RECT                    rcClient        = { 0, 0, nWidth, nHeight };
    RECT                    rcToolBar;
    RECT                    rcStatusBar;
    RECT                    rcProjectTree;
    RECT                    rcSplitter;
    RECT                    rcWorkspace;
    
    //
    // The basic window layout is as follows:
    //
    //   +-----------------------------+
    //   | Title bar                   |
    //   +-----------------------------+
    //   | Menu bar                    |
    //   +-----------------------------+
    //   | Tool bar                    |
    //   +-----------------------------+
    //   | T   |S|  MDI Workspace      |
    //   | r   |p|                     |
    //   | e   |l|                     |
    //   | e   |i|                     |
    //   |     |t|                     |
    //   | v   |t|                     |
    //   | i   |e|                     |
    //   | e   |r|                     |
    //   | w   | |                     |
    //   |     | |                     |
    //   +-----------------------------+
    //   | Status bar                  |
    //   +-----------------------------+
    //

    //
    // Trim the width and height down to account for the toolbar and status
    // bar sizes
    //

    m_ToolBar.SendMessage(WM_SIZE, SIZE_RESTORED, MAKELONG(nWidth, nHeight));
    m_StatusBar.SendMessage(WM_SIZE, SIZE_RESTORED, MAKELONG(nWidth, nHeight));
    
    m_ToolBar.GetWindowRect(&rcToolBar);
    m_StatusBar.GetWindowRect(&rcStatusBar);

    rcClient.top += rcToolBar.bottom - rcToolBar.top;
    rcClient.bottom -= rcStatusBar.bottom - rcStatusBar.top;

    //
    // The splitter defines the size of the other two windows
    // 

    if(m_Splitter.m_nPosition < 0)
    {
        m_Splitter.m_nPosition = 0;
    }
    else if(m_Splitter.m_nPosition + m_Splitter.m_nWidth > nWidth)
    {
        m_Splitter.m_nPosition = nWidth - m_Splitter.m_nWidth;
    }
    
    rcSplitter.left = rcClient.left + m_Splitter.m_nPosition;
    rcSplitter.top = rcClient.top;
    rcSplitter.right = rcSplitter.left + m_Splitter.m_nWidth;
    rcSplitter.bottom = rcClient.bottom;
    
    // 
    // Resize the tree-view up to the splitter
    //

    rcProjectTree.left = rcClient.left;
    rcProjectTree.top = rcClient.top;
    rcProjectTree.right = rcSplitter.left;
    rcProjectTree.bottom = rcClient.bottom;

    //
    // Resize the workspace to take the remaining area
    //

    rcWorkspace.left = rcSplitter.right;
    rcWorkspace.top = rcClient.top;
    rcWorkspace.right = rcClient.right;
    rcWorkspace.bottom = rcClient.bottom;

    m_ProjectTree.MoveWindow(&rcProjectTree, fRepaint);
    m_Splitter.MoveWindow(&rcSplitter, fRepaint);
    m_Workspace.MoveWindow(&rcWorkspace, fRepaint);
}


/****************************************************************************
 *
 *  EnableCommand
 *
 *  Description:
 *      Enables or disables a command.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      BOOL [in]: TRUE to enable.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::EnableCommand"

void
CMainFrame::EnableCommand
(
    UINT                    nCommandId,
    BOOL                    fEnable
)
{
    const DWORD             dwMenuFlags = MF_BYCOMMAND | (fEnable ? MF_ENABLED : MF_GRAYED);
    UINT                    i;
    
    //
    // Update the toolbar
    //

    m_ToolBar.EnableButton(nCommandId, fEnable);

    //
    // Update the main menu
    //

    EnableMenuItem(m_hMenu, nCommandId, dwMenuFlags);

    //
    // Update the secondary menus
    //

    for(i = 0; i < NUMELMS(m_ahMenus); i++)
    {
        EnableMenuItem(m_ahMenus[i], nCommandId, dwMenuFlags);
    }

    //
    // Update check state
    //

    if(!fEnable)
    {
        CheckCommand(nCommandId, FALSE);
    }
}


/****************************************************************************
 *
 *  CheckCommand
 *
 *  Description:
 *      Checks or unchecks a command.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      BOOL [in]: TRUE to check.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::CheckCommand"

void
CMainFrame::CheckCommand
(
    UINT                    nCommandId,
    BOOL                    fCheck
)
{
    const DWORD             dwMenuFlags = MF_BYCOMMAND | (fCheck ? MF_CHECKED : MF_UNCHECKED);
    UINT                    i;
    
    //
    // Update the toolbar
    //

    m_ToolBar.SetButtonState(nCommandId, TBSTATE_CHECKED, fCheck ? TBSTATE_CHECKED : 0);

    //
    // Update the main menu
    //

    CheckMenuItem(m_hMenu, nCommandId, dwMenuFlags);

    //
    // Update the secondary menus
    //

    for(i = 0; i < NUMELMS(m_ahMenus); i++)
    {
        CheckMenuItem(m_ahMenus[i], nCommandId, dwMenuFlags);
    }
}


/****************************************************************************
 *
 *  SetDefaultCommandState
 *
 *  Description:
 *      Sets the default state for all commands.  This method is really only
 *      meant to be called during init, so it only disables commands.  None
 *      are enabled, and the check state is never changed.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainFrame::SetDefaultCommandState"

void
CMainFrame::SetDefaultCommandState
(
    void
)
{
    static const UINT       anDisabled[] =
    {
        ID_RELOAD_PROJECT,
        ID_ADD_WAVEBANK_ENTRY,
        ID_WAVEBANK_ENTRY_ADPCM,
        ID_WAVEBANK_ENTRY_8BIT,
        ID_PLAY,
        ID_STOP,
        ID_RECENT_FILE_0,
        ID_DISCONNECT,
    };

    UINT                    i;

    for(i = 0; i < NUMELMS(anDisabled); i++)
    {
        EnableCommand(anDisabled[i], FALSE);
    }
}


/****************************************************************************
 *
 *  CMainStatusBar
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainStatusBar::CMainStatusBar"

CMainStatusBar::CMainStatusBar
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CMainStatusBar
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainStatusBar::~CMainStatusBar"

CMainStatusBar::~CMainStatusBar
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainStatusBar::Create"

BOOL
CMainStatusBar::Create
(
    void
)
{
    static const DWORD      dwExStyle   = 0;
    static const DWORD      dwStyle     = WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP;
    
    //
    // Create the window
    //

    return CWindow::Create(&g_pApplication->m_MainFrame, STATUSCLASSNAME, NULL, dwExStyle, dwStyle, 0, 0, 0, 0, CMainFrame::IDC_MAIN_STATUSBAR);
}


/****************************************************************************
 *
 *  CMainToolBar
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainToolBar::CMainToolBar"

CMainToolBar::CMainToolBar
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CMainToolBar
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainToolBar::~CMainToolBar"

CMainToolBar::~CMainToolBar
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainToolBar::Create"

BOOL
CMainToolBar::Create
(
    void
)
{
    static const DWORD      dwExStyle       = 0;
    static const DWORD      dwStyle         = WS_CHILD | WS_VISIBLE | CCS_TOP | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT | TBSTYLE_TOOLTIPS;
    UINT                    nBitmapIndex;
    
    //
    // Create the window
    //
    
    if(!CToolBar::Create(&g_pApplication->m_MainFrame, dwExStyle, dwStyle, CMainFrame::IDC_MAIN_TOOLBAR))
    {
        return FALSE;
    }

    //
    // Add the main toolbar bitmap
    //

    nBitmapIndex = LoadImages(IDB_MAIN_TOOLBAR, BTN_COUNT);

    //
    // Add buttons
    //

    AddButton(IML_STD, STD_FILENEW, ID_NEW_PROJECT);

    AddSeparator();

    AddButton(IML_STD, STD_FILEOPEN, ID_OPEN_PROJECT);
    AddButton(IML_STD, STD_FILESAVE, ID_SAVE_PROJECT);

    AddSeparator();

    AddButton(nBitmapIndex, BTN_WAVEBANK, ID_ADD_WAVEBANK);
    AddButton(nBitmapIndex, BTN_WAVEBANK_ENTRY, ID_ADD_WAVEBANK_ENTRY);

    AddSeparator();

    AddButton(nBitmapIndex, BTN_ADPCM, ID_WAVEBANK_ENTRY_ADPCM);
    AddButton(nBitmapIndex, BTN_8BIT, ID_WAVEBANK_ENTRY_8BIT);

    AddSeparator();

    AddButton(nBitmapIndex, BTN_CONNECT, ID_CONNECT);
    AddButton(nBitmapIndex, BTN_DISCONNECT, ID_DISCONNECT);

    AddSeparator();

    AddButton(nBitmapIndex, BTN_PLAY, ID_PLAY);
    AddButton(nBitmapIndex, BTN_STOP, ID_STOP);

    AddSeparator();

    AddButton(nBitmapIndex, BTN_BUILD, ID_BUILD);

    return TRUE;
}


/****************************************************************************
 *
 *  CMainProjectTree
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTree::CMainProjectTree"

CMainProjectTree::CMainProjectTree
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CMainProjectTree
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTree::~CMainProjectTree"

CMainProjectTree::~CMainProjectTree
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTree::Create"

BOOL
CMainProjectTree::Create
(
    void
)
{
    static const DWORD      dwExStyle   = WS_EX_CLIENTEDGE;
    static const DWORD      dwStyle     = WS_VISIBLE | WS_CHILD | TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_EDITLABELS | TVS_DISABLEDRAGDROP | TVS_SHOWSELALWAYS;

    //
    // Create the window
    //

    if(!CTreeView::Create(&g_pApplication->m_MainFrame, dwExStyle, dwStyle, 0, 0, 0, 0, CMainFrame::IDC_MAIN_PROJECTTREE))
    {
        return FALSE;
    }

    //
    // Create category items
    //

    m_WaveBundlerCategory.Create(this, IDS_CATEGORY_WAVEBUNDLER, IDI_CATEGORY_WAVEBUNDLER);

    //
    // Register standard types
    //

    RegisterType(m_pszWaveBankType, LoadResourceIconSmall(IDI_WAVEBANK));

    return TRUE;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles WM_COMMAND messages.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTree::OnCommand"

BOOL
CMainProjectTree::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hWndControl,
    LRESULT *               plResult
)
{
    CMainProjectTreeItem *  pItem;
    
    if(CTreeView::OnCommand(nCommandId, nControlId, hWndControl, plResult))
    {
        return TRUE;
    }

    if(!(pItem = (CMainProjectTreeItem *)GetSelection()))
    {
        return FALSE;
    }

    return pItem->OnCommand(nCommandId, nControlId, hWndControl, plResult);
}


/****************************************************************************
 *
 *  CMainProjectTreeItem
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTreeItem::CMainProjectTreeItem"

CMainProjectTreeItem::CMainProjectTreeItem
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CMainProjectTreeItem
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTreeItem::~CMainProjectTreeItem"

CMainProjectTreeItem::~CMainProjectTreeItem
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the item.
 *
 *  Arguments:
 *      CMainProjectTree * [in]: tree control.
 *      CTreeViewItem * [in]: parent item.
 *      LPCTSTR [in]: item name.
 *      LPCTSTR [in]: item type.
 *      LPVOID [in]: item context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTreeItem::Create"

BOOL
CMainProjectTreeItem::Create
(
    CMainProjectTree *      pTree,
    CMainProjectTreeItem *  pParentItem,
    LPCTSTR                 pszText,
    LPCTSTR                 pszType,
    LPVOID                  pvContext
)
{
    return CTreeViewItem::Create(pTree, pParentItem, pszText, pszType, pvContext);
}


/****************************************************************************
 *
 *  CMainProjectTreeCategory
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTreeCategory::CMainProjectTreeCategory"

CMainProjectTreeCategory::CMainProjectTreeCategory
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CMainProjectTreeCategory
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTreeCategory::~CMainProjectTreeCategory"

CMainProjectTreeCategory::~CMainProjectTreeCategory
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the item.
 *
 *  Arguments:
 *      CMainProjectTree * [in]: tree.
 *      UINT [in]: category name string identifier.
 *      UINT [in]: icon identifier.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainProjectTreeCategory::Create"

BOOL
CMainProjectTreeCategory::Create
(
    CMainProjectTree *      pTree,
    UINT                    nStringId,
    UINT                    nIconId
)
{
    TCHAR                   szName[0x100];
    HICON                   hIcon;

    FormatStringResource(szName, NUMELMS(szName), nStringId);

    hIcon = LoadResourceIconSmall(nIconId);

    pTree->RegisterType(szName, hIcon);
    
    return CMainProjectTreeItem::Create(pTree, NULL, szName, szName);
}


/****************************************************************************
 *
 *  CMainSplitter
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainSplitter::CMainSplitter"

CMainSplitter::CMainSplitter
(
    void
)
{
    m_nPosition = 250;
    m_fDragging = FALSE;
}


/****************************************************************************
 *
 *  ~CMainSplitter
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainSplitter::~CMainSplitter"

CMainSplitter::~CMainSplitter
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainSplitter::Create"

BOOL
CMainSplitter::Create
(
    void
)
{
    static const DWORD      dwExStyle   = 0;
    static const DWORD      dwStyle     = WS_CHILD | WS_VISIBLE;
    WNDCLASSEX              wc          = { 0 };

    //
    // Load the splitter position from the registry
    //
    
    g_pApplication->m_Registry.GetNumericValue(REGKEY_SPLITTER_POSITION, &m_nPosition);

    //
    // Register the window class
    //

    wc.cbSize = sizeof(wc);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpfnWndProc = WindowProc;
    wc.hCursor = LoadCursor(NULL, IDC_SIZEWE);
    wc.hInstance = g_hInstance;
    wc.lpszClassName = m_pszClassName;

    RegisterClassEx(&wc);

    //
    // Create the window
    //

    return CWindow::Create(&g_pApplication->m_MainFrame, m_pszClassName, NULL, dwExStyle, dwStyle, 0, 0, 0, 0, CMainFrame::IDC_MAIN_SPLITTER);
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

BOOL 
CMainSplitter::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
            fHandled = OnMouseButtonDown(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam), plResult);
            break;
        
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
            fHandled = OnMouseButtonUp(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam), plResult);
            break;
        
        case WM_MOUSEMOVE:
            fHandled = OnMouseMove(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam), plResult);
            break;
        
        default:
            fHandled = CWindow::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnMouseButtonDown
 *
 *  Description:
 *      Handles mouse button events.
 *
 *  Arguments:
 *      DWORD [in]: pressed keys.
 *      UINT [in]: x-coordinate of the mouse.
 *      UINT [in]: y-coordinate of the mouse.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

BOOL 
CMainSplitter::OnMouseButtonDown
(
    DWORD                   dwKeys,
    int                     x,
    int                     y,
    LRESULT *               plResult
)
{
    //
    // Capture the mouse so the user can drag the splitter around
    //

    SetCapture(m_hWnd);

    m_fDragging = TRUE;

    return FALSE;
}


/****************************************************************************
 *
 *  OnMouseButtonUp
 *
 *  Description:
 *      Handles mouse button events.
 *
 *  Arguments:
 *      DWORD [in]: pressed keys.
 *      UINT [in]: x-coordinate of the mouse.
 *      UINT [in]: y-coordinate of the mouse.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

BOOL 
CMainSplitter::OnMouseButtonUp
(
    DWORD                   dwKeys,
    int                     x,
    int                     y,
    LRESULT *               plResult
)
{
    //
    // Release the mouse
    //

    ReleaseCapture();

    m_fDragging = FALSE;

    return FALSE;
}


/****************************************************************************
 *
 *  OnMouseMove
 *
 *  Description:
 *      Handles mouse events.
 *
 *  Arguments:
 *      DWORD [in]: pressed keys.
 *      UINT [in]: x-coordinate of the mouse.
 *      UINT [in]: y-coordinate of the mouse.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

BOOL 
CMainSplitter::OnMouseMove
(
    DWORD                   dwKeys,
    int                     x,
    int                     y,
    LRESULT *               plResult
)
{
    if(!m_fDragging)
    {
        return FALSE;
    }

    //
    // Update our position
    //

    m_nPosition += x;
    
    //
    // Tell the parent to shuffle controls around
    //

    ((CMainFrame *)m_pParent)->LayoutControls();
    
    return FALSE;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles WM_DESTROY messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainSplitter::OnDestroy"

BOOL
CMainSplitter::OnDestroy
(
    LRESULT *               plResult
)
{
    WINDOWPLACEMENT         wp;
    
    if(CWindow::OnDestroy(plResult))
    {
        return TRUE;
    }

    g_pApplication->m_Registry.SetNumericValue(REGKEY_SPLITTER_POSITION, m_nPosition);

    return FALSE;
}


/****************************************************************************
 *
 *  CMainWorkspace
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWorkspace::CMainWorkspace"

CMainWorkspace::CMainWorkspace
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CMainWorkspace
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWorkspace::~CMainWorkspace"

CMainWorkspace::~CMainWorkspace
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWorkspace::Create"

BOOL
CMainWorkspace::Create
(
    void
)
{
    static const DWORD      dwExStyle   = WS_EX_CLIENTEDGE;
    static const DWORD      dwStyle     = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL;
    CLIENTCREATESTRUCT      ccs;

    //
    // Create the window
    //

    ccs.hWindowMenu = GetSubMenu(g_pApplication->m_MainFrame.m_hMenu, g_pApplication->m_MainFrame.MENUPOS_WINDOW);
    ccs.idFirstChild = g_pApplication->m_MainFrame.IDC_MAIN_FIRSTMDICHILD;

    return CMDIClientWindow::Create(&g_pApplication->m_MainFrame, dwExStyle, dwStyle, 0, 0, 0, 0, g_pApplication->m_MainFrame.IDC_MAIN_WORKSPACE, &ccs);
}


/****************************************************************************
 *
 *  CWorkspaceChild
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      UINT [in]: window type.
 *      UINT [in]: window menu resource identifier.
 *      UINT [in]: window accelerator table resource identifier.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWorkspaceChild::CWorkspaceChild"

CWorkspaceChild::CWorkspaceChild
(
    UINT                    nWorkspaceType
)
:   m_nWorkspaceType(nWorkspaceType)
{
}


/****************************************************************************
 *
 *  ~CWorkspaceChild
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWorkspaceChild::~CWorkspaceChild"

CWorkspaceChild::~CWorkspaceChild
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      LPCTSTR [in]: window title.
 *      UINT [in]: window icon resource identifier.
 *      LPBOOL [out]: TRUE if the window was opened; FALSE if it was just
 *                    activated.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWorkspaceChild::Create"

BOOL
CWorkspaceChild::Create
(
    LPCTSTR                 pszWindowTitle,
    UINT                    nIconId,
    LPBOOL                  pfOpened
)
{
    static const DWORD      dwExStyle   = 0;
    DWORD                   dwStyle     = WS_CHILD | WS_VISIBLE;
    WNDCLASSEX              wc          = { 0 };
    WINDOWPLACEMENT         wp;

    //
    // If the window already exists, just activate it
    //

    if(m_hWnd)
    {
        if(pfOpened)
        {
            *pfOpened = FALSE;
        }
        
        m_pParent->SendMessage(WM_MDIACTIVATE, (WPARAM)m_hWnd);

        return TRUE;
    }

    //
    // Register the window class
    //

    wc.cbSize = sizeof(wc);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpfnWndProc = WindowProc;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hInstance = g_hInstance;
    wc.lpszClassName = m_pszClassName;

    RegisterClassEx(&wc);

    //
    // Load window placement data
    //
    
    if(g_pApplication->m_Registry.GetBinaryValue(REGKEY_WORKSPACE_CHILD_PLACEMENT, &wp, sizeof(wp)))
    {
        if(SW_MAXIMIZE == wp.showCmd)
        {
            dwStyle |= WS_MAXIMIZE;
        }
    }

    //
    // Create the window
    //

    if(!CMDIChildWindow::Create(&g_pApplication->m_MainFrame.m_Workspace, m_pszClassName, pszWindowTitle, dwExStyle, dwStyle, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, (LPVOID)nIconId))
    {
        return FALSE;
    }

    //
    // Return that the window was opened
    //

    if(pfOpened)
    {
        *pfOpened = TRUE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWorkspaceChild::OnCreate"

BOOL
CWorkspaceChild::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    const int               nIconId = (int)pvContext;

    if(CMDIChildWindow::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Set the window's icon
    //

    SendMessage(WM_SETICON, ICON_BIG, (LPARAM)LoadResourceIconLarge(nIconId));
    SendMessage(WM_SETICON, ICON_SMALL, (LPARAM)LoadResourceIconSmall(nIconId));

    return FALSE;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles WM_DESTROY messages.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWorkspaceChild::OnDestroy"

BOOL
CWorkspaceChild::OnDestroy
(
    LRESULT *               plResult
)
{
    WINDOWPLACEMENT         wp;
    
    if(CMDIChildWindow::OnDestroy(plResult))
    {
        return TRUE;
    }

    //
    // Save the window placement data
    //

    wp.length = sizeof(wp);
    
    GetWindowPlacement(m_hWnd, &wp);

    g_pApplication->m_Registry.SetBinaryValue(REGKEY_WORKSPACE_CHILD_PLACEMENT, &wp, sizeof(wp));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\wbndgui.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2/13/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wbndgui.cpp
 *  Content:    Wave Bundler GUI wrapper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/13/2002   dereks  Created.
 *
 ****************************************************************************/

#include "xactapp.h"
#include <commdlg.h>

const LVCOLUMNDATA CGuiWaveBankEntry::m_aColumnData[] =
{
    { IDS_ENTRY_NAME,           LVCTYPE_STRING, TRUE },
    { IDS_ENTRY_FORMAT,         LVCTYPE_NUMBER, TRUE },
    { IDS_ENTRY_SAMPLING_RATE,  LVCTYPE_NUMBER, TRUE },
    { IDS_ENTRY_BIT_RESOLUTION, LVCTYPE_NUMBER, TRUE },
    { IDS_ENTRY_CHANNEL_COUNT,  LVCTYPE_NUMBER, TRUE },
    { IDS_ENTRY_SIZE,           LVCTYPE_NUMBER, TRUE },
    { IDS_ENTRY_CONVERSION,     LVCTYPE_STRING, TRUE },
    { IDS_ENTRY_SOURCE_FILE,    LVCTYPE_STRING, TRUE },
};


/****************************************************************************
 *
 *  CGuiWaveBankProject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::CGuiWaveBankProject"

CGuiWaveBankProject::CGuiWaveBankProject
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CGuiWaveBankProject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::~CGuiWaveBankProject"

CGuiWaveBankProject::~CGuiWaveBankProject
(
    void
)
{
}


/****************************************************************************
 *
 *  BrowseBankFile
 *
 *  Description:
 *      Browses for a wave bank file path.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      LPTSTR [out]: bank file path.
 *      UINT [in]: path buffer size, in characters.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::BrowseBankFile"

BOOL
CGuiWaveBankProject::BrowseBankFile
(
    HWND                    hWnd, 
    LPTSTR                  pszFile, 
    UINT                    nLength
)
{
    static const LPCTSTR    pszFilter       = MAKE_COMMDLG_FILTER(TEXT("Wave Bank"), TEXT("*.") WBWRITER_FILEEXTENSION_BANK) \
                                              MAKE_COMMDLG_FILTER(TEXT("All"), TEXT("*.*"));
                                                        
    static const DWORD      dwOfnFlags      = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    OPENFILENAME            ofn             = { 0 };
    TCHAR                   szTitle[0x100];

    FormatStringResource(szTitle, NUMELMS(szTitle), IDS_CREATE_WAVE_BANK);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.Flags = dwOfnFlags;
    ofn.lpstrFilter = pszFilter;
    ofn.lpstrFile = pszFile;
    ofn.nMaxFile = nLength;
    ofn.lpstrTitle = FormatStringResourceStatic(IDS_CREATE_WAVE_BANK);
    ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_BANK;

    return GetSaveFileName(&ofn);
}


/****************************************************************************
 *
 *  BrowseHeaderFile
 *
 *  Description:
 *      Browses for a wave bank header file path.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      LPTSTR [out]: bank header file path.
 *      UINT [in]: path buffer size, in characters.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::BrowseHeaderFile"

BOOL
CGuiWaveBankProject::BrowseHeaderFile
(
    HWND                    hWnd, 
    LPTSTR                  pszFile, 
    UINT                    nLength
)
{
    static const LPCTSTR    pszFilter       = MAKE_COMMDLG_FILTER(TEXT("C/C++ Headers"), TEXT("*.h;*.hpp")) \
                                              MAKE_COMMDLG_FILTER(TEXT("All"), TEXT("*.*"));
                                                        
    static const DWORD      dwOfnFlags      = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    OPENFILENAME            ofn             = { 0 };
    TCHAR                   szTitle[0x100];

    FormatStringResource(szTitle, NUMELMS(szTitle), IDS_CREATE_WAVE_BANK_HEADER);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.Flags = dwOfnFlags;
    ofn.lpstrFilter = pszFilter;
    ofn.lpstrFile = pszFile;
    ofn.nMaxFile = nLength;
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_HEADER;

    return GetSaveFileName(&ofn);
}


/****************************************************************************
 *
 *  BrowseEntryFile
 *
 *  Description:
 *      Browses for a wave bank file path.
 *
 *  Arguments:
 *      HWND [in]: parent window.
 *      LPTSTR [out]: bank header file path.
 *      UINT [in]: path buffer size, in characters.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::BrowseEntryFile"

BOOL
CGuiWaveBankProject::BrowseEntryFile
(
    HWND                    hWnd, 
    LPTSTR                  pszFile, 
    UINT                    nLength
)
{
    static const LPCTSTR    pszFilter   = MAKE_COMMDLG_FILTER(TEXT("Sound"), TEXT("*.wav;*.aif;*.aiff")) \
                                          MAKE_COMMDLG_FILTER(TEXT("Wave"), TEXT("*.wav")) \
                                          MAKE_COMMDLG_FILTER(TEXT("Macintosh AIFF"), TEXT("*.aif;*.aiff")) \
                                          MAKE_COMMDLG_FILTER(TEXT("All"), TEXT("*.*"));
                                                    
    DWORD                   dwOfnFlags  = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
    OPENFILENAME            ofn         = { 0 };
    TCHAR                   szTitle[0x100];

    //
    // If more than MAX_PATH characters were supplied, allow for multiple
    // file selection
    //

    if(nLength > MAX_PATH)
    {
        dwOfnFlags |= OFN_ALLOWMULTISELECT;
    }

    FormatStringResource(szTitle, NUMELMS(szTitle), IDS_CREATE_WAVE_BANK_ENTRY);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.Flags = dwOfnFlags;
    ofn.lpstrFilter = pszFilter;
    ofn.lpstrFile = pszFile;
    ofn.nMaxFile = nLength;
    ofn.lpstrTitle = szTitle;
    ofn.hInstance = g_hInstance;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_WAVEBANK_ENTRY_OFN_CHILD);
    ofn.lpfnHook = WaveBankEntryOFNHookProc;

    return GetOpenFileName(&ofn);
}


/****************************************************************************
 *
 *  WaveBankEntryOFNHookProc
 *
 *  Description:
 *      Hook procedure for "Add wave bank entry" common dialog.
 *
 *  Arguments:
 *      HWND [in]: child window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter.
 *      LPARAM [in]: message parameter.
 *
 *  Returns:  
 *      UINT: message result, or 0 for default.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::WaveBankEntryOFNHookProc"

UINT
CGuiWaveBankProject::WaveBankEntryOFNHookProc
(
    HWND                    hWnd, 
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam
)
{
    static const UINT       nPaneControlId  = 0x4a0;
    LPOFNOTIFY              pHdr;
    HWND                    hWndParent;
    HWND                    hWndPane;
    RECT                    rcAlign;
    int                     nAlignWidth;
    RECT                    rc;
    int                     nWidth;
    TCHAR                   szPath[MAX_PATH];
    int                     x;
    
    switch(uMsg)
    {
        case WM_NOTIFY:
            pHdr = (LPOFNOTIFY)lParam;

            switch(pHdr->hdr.code)
            {
                case CDN_INITDONE:

                    //
                    // Align the child dialog with the pane on the left
                    //

                    hWndParent = ::GetParent(hWnd);
                    hWndPane = ::GetDlgItem(hWndParent, nPaneControlId);

                    ::GetWindowRect(hWndPane, &rcAlign);
                    ::GetWindowRect(hWnd, &rc);

                    ::ScreenToClient(hWndParent, (LPPOINT)&rcAlign.left);
                    ::ScreenToClient(hWndParent, (LPPOINT)&rc.left);

                    nWidth = rc.right - rc.left;
                    nAlignWidth = rcAlign.right - rcAlign.left;

                    x = rcAlign.left + ((nAlignWidth - nWidth) / 2);

                    ::SetWindowPos(hWnd, NULL, x, rc.top, 0, 0, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER);

                    //
                    // Load button icons
                    //

                    ::SendDlgItemMessage(hWnd, IDC_PLAY, BM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadResourceIconSmall(IDI_PLAY));
                    ::SendDlgItemMessage(hWnd, IDC_STOP, BM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadResourceIconSmall(IDI_STOP));

                    break;
            }

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_PLAY:
                    hWndParent = ::GetParent(hWnd);

                    if((int)::SendMessage(hWndParent, CDM_GETFILEPATH, NUMELMS(szPath), (LPARAM)szPath) > 0)
                    {
                        ::PlaySound(szPath, NULL, SND_FILENAME | SND_ASYNC);
                    }

                    break;

                case IDC_STOP:
                    ::PlaySound(NULL, NULL, 0);

                    break;
            }
    }
    
    return 0;
}


/****************************************************************************
 *
 *  CGuiWaveBank
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::CGuiWaveBank"

CGuiWaveBank::CGuiWaveBank
(
    CGuiWaveBankProject *   pParent
)
:   CWaveBank(pParent)
{
    m_ListWindow.Initialize(this);

    g_pApplication->m_Project.MakeDirty();
}


/****************************************************************************
 *
 *  ~CGuiWaveBank
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::~CGuiWaveBank"

CGuiWaveBank::~CGuiWaveBank
(
    void
)
{
    g_pApplication->m_Project.MakeDirty();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCTSTR [in]: bank name.
 *      LPCTSTR [in]: bank file name.
 *      LPCTSTR [in]: header file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::Initialize"

HRESULT
CGuiWaveBank::Initialize
(
    LPCTSTR                     pszBankName,
    LPCTSTR                     pszBankFile,
    LPCTSTR                     pszHeaderFile
)
{
    CMainProjectTree *          pTree       = &g_pApplication->m_MainFrame.m_ProjectTree;
    CMainProjectTreeCategory *  pParentItem = &pTree->m_WaveBundlerCategory;
    HRESULT                     hr;

    //
    // Initialize the base class
    //

    hr = CWaveBank::Initialize(pszBankName, pszBankFile, pszHeaderFile);

    //
    // Add the bank to the project tree
    //

    if(SUCCEEDED(hr))
    {
        hr = CMainProjectTreeItem::Create(pTree, pParentItem, m_szBankName, pTree->m_pszWaveBankType) ? S_OK : E_FAIL;
    }

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the bank.
 *
 *  Arguments:
 *      LPCTSTR [in]: bank name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SetName"

HRESULT 
CGuiWaveBank::SetName
(
    LPCTSTR                  pszName
)
{
    HRESULT                 hr;

    if(!_tcscmp(pszName, m_szBankName))
    {
        return S_OK;
    }

    hr = CWaveBank::SetName(pszName);

    if(SUCCEEDED(hr))
    {
        MakeDirty();
    }

    return hr;
}


/****************************************************************************
 *
 *  SetBankPath
 *
 *  Description:
 *      Sets the bank path.
 *
 *  Arguments:
 *      LPCTSTR [in]: bank path.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SetBankPath"

HRESULT 
CGuiWaveBank::SetBankPath
(
    LPCTSTR                  pszBankPath
)
{
    if(!_tcsicmp(pszBankPath, m_szBankFile))
    {
        return S_OK;
    }

    _tcsncpy(m_szBankFile, pszBankPath, NUMELMS(m_szBankFile));

    MakeDirty();

    return S_OK;
}


/****************************************************************************
 *
 *  SetHeaderPath
 *
 *  Description:
 *      Sets the header path.
 *
 *  Arguments:
 *      LPCTSTR [in]: header path.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SetHeaderPath"

HRESULT 
CGuiWaveBank::SetHeaderPath
(
    LPCTSTR                  pszHeaderPath
)
{
    if(!_tcsicmp(pszHeaderPath, m_szHeaderFile))
    {
        return S_OK;
    }

    _tcsncpy(m_szHeaderFile, pszHeaderPath, NUMELMS(m_szHeaderFile));

    MakeDirty();

    return S_OK;
}


/****************************************************************************
 *
 *  SetFlags
 *
 *  Description:
 *      Sets the bank flags.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SetFlags"

HRESULT 
CGuiWaveBank::SetFlags
(
    DWORD                   dwFlags
)
{
    if(dwFlags == m_dwFlags)
    {
        return S_OK;
    }

    m_dwFlags = dwFlags;

    MakeDirty();

    return S_OK;
}


/****************************************************************************
 *
 *  SetAlignment
 *
 *  Description:
 *      Sets entry data alignment.
 *
 *  Arguments:
 *      DWORD [in]: alignment.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SetAlignment"

HRESULT 
CGuiWaveBank::SetAlignment
(
    DWORD                   dwAlignment
)
{
    HRESULT                 hr;
    
    if(dwAlignment == m_dwAlignment)
    {
        return S_OK;
    }

    hr = CWaveBank::SetAlignment(dwAlignment);

    if(SUCCEEDED(hr))
    {
        MakeDirty();
    }

    return hr;
}


/****************************************************************************
 *
 *  OpenList
 *
 *  Description:
 *      Opens the list window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OpenList"

BOOL
CGuiWaveBank::OpenList
(
    void
)
{
    return m_ListWindow.Create();
}


/****************************************************************************
 *
 *  CloseList
 *
 *  Description:
 *      Closes the list window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::CloseList"

void
CGuiWaveBank::CloseList
(
    void
)
{
    m_ListWindow.Destroy();
}


/****************************************************************************
 *
 *  UpdateUI
 *
 *  Description:
 *      Updates the UI for this object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::UpdateUI"

void
CGuiWaveBank::UpdateUI
(
    void
)
{
    //
    // Update the tree view
    //
    
    CTreeViewItem::SetText(m_szBankName);

    //
    // Update the list window
    //

    m_ListWindow.SetWindowText(m_szBankName);
}


/****************************************************************************
 *
 *  OnGetInfo
 *
 *  Description:
 *      Updates the UI for this object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnGetInfoTip"

void
CGuiWaveBank::OnGetInfoTip
(
    LPTSTR                  pszText, 
    int                     cchTextMax
)
{
    TCHAR                   szBankSize[0x100];
    DWORD                   dwBankSize;
    
    if(dwBankSize = GetBankDataSize())
    {
        FormatNumber(dwBankSize, FALSE, TRUE, szBankSize);
    }
    else
    {
        FormatStringResource(szBankSize, NUMELMS(szBankSize), IDS_BANKSIZE_UNKNOWN);
    }

    FormatStringResource(pszText, cchTextMax, IDS_BANK_INFOTIP, m_szBankFile, m_szHeaderFile, m_dwEntryCount, szBankSize);
}


/****************************************************************************
 *
 *  OnEndLabelEdit
 *
 *  Description:
 *      Updates the UI for this object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnEndLabelEdit"

BOOL
CGuiWaveBank::OnEndLabelEdit
(
    LPCTSTR                 pszText
)
{
    SetName(pszText);
    
    return FALSE;
}


/****************************************************************************
 *
 *  OnContextMenu
 *
 *  Description:
 *      Handles WM_CONTEXTMENU messages.
 *
 *  Arguments:
 *      HWND [in]: window the user clicked in.
 *      int [in]: mouse x-coordinate.
 *      int [in]: mouse y-coordinate.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnContextMenu"

BOOL
CGuiWaveBank::OnContextMenu
(
    HWND                    hWndFocus,
    int                     x,
    int                     y,
    LRESULT *               plResult
)
{
    if(CMainProjectTreeItem::OnContextMenu(hWndFocus, x, y, plResult))
    {
        return TRUE;
    }

    TrackPopupMenu(g_pApplication->m_MainFrame.m_ahMenus[g_pApplication->m_MainFrame.MENUIDX_WAVEBANK_POPUP], TPM_RIGHTBUTTON, x, y, 0, *m_pTree, NULL);

    return FALSE;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles WM_COMMAND messages.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnCommand"

BOOL
CGuiWaveBank::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hWndControl,
    LRESULT *               plResult
)
{
    if(CMainProjectTreeItem::OnCommand(nCommandId, nControlId, hWndControl, plResult))
    {
        return TRUE;
    }

    switch(nControlId)
    {
        case ID_ACTIVATE:
        case ID_WAVEBANK_ACTIVATE:
            OnDoubleClick();
            break;

        case ID_REFRESH:
        case ID_WAVEBANK_REFRESH:
            OnCmdRefresh();
            break;
        
        case ID_RENAME:
        case ID_WAVEBANK_RENAME:
            OnCmdRename();
            break;

        case ID_DELETE:
        case ID_WAVEBANK_DELETE:
            OnCmdRemove();
            break;

        case ID_PROPERTIES:
        case ID_WAVEBANK_PROPERTIES:
            OnCmdProperties();
            break;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnCmdRefresh
 *
 *  Description:
 *      Reloads the wave bank.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnCmdRefresh"

void
CGuiWaveBank::OnCmdRefresh
(
    void
)
{
    m_ListWindow.Refresh();
}


/****************************************************************************
 *
 *  OnCmdRename
 *
 *  Description:
 *      Renames the currently selected entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnCmdRename"

void
CGuiWaveBank::OnCmdRename
(
    void
)
{
    EditLabel();
}


/****************************************************************************
 *
 *  OnCmdRemove
 *
 *  Description:
 *      Removes the currently selected entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnCmdRemove"

void
CGuiWaveBank::OnCmdRemove
(
    void
)
{
    if(IDYES != MsgBoxResource(g_pApplication->m_MainFrame, MB_ICONQUESTION | MB_YESNO, IDS_CONFIRM_DELETE_WAVEBANK))
    {
        return;
    }

    m_pParent->RemoveBank(this);
}


/****************************************************************************
 *
 *  OnCmdProperties
 *
 *  Description:
 *      Displays properties.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::OnCmdProperties"

void
CGuiWaveBank::OnCmdProperties
(
    void
)
{
    CWaveBankPropertiesDialog    Dialog(this);

    Dialog.DoModal(&g_pApplication->m_MainFrame);
}


/****************************************************************************
 *
 *  CGuiWaveBankEntry
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CGuiWaveBank * [in]: parent bank.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::CGuiWaveBankEntry"

CGuiWaveBankEntry::CGuiWaveBankEntry
(
    CGuiWaveBank *          pWaveBank
)
:   CWaveBankEntry(pWaveBank)
{
    g_pApplication->m_Project.MakeDirty();
}


/****************************************************************************
 *
 *  ~CGuiWaveBankEntry
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::~CGuiWaveBankEntry"

CGuiWaveBankEntry::~CGuiWaveBankEntry
(
    void
)
{
    MakeDirty();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object from a source file.
 *
 *  Arguments:
 *      LPCTSTR [in]: entry name.
 *      LPCTSTR [in]: wave file name.
 *      DWORD [in]: processing flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::Initialize"

HRESULT
CGuiWaveBankEntry::Initialize
(
    LPCTSTR                 pszEntryName,
    LPCTSTR                 pszFileName,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    //
    // Hand off to the base class
    //

    hr = CWaveBankEntry::Initialize(pszEntryName, pszFileName, dwFlags);

    //
    // Save the file extension
    //

    if(SUCCEEDED(hr))
    {
        _splitpath(pszFileName, NULL, NULL, NULL, m_szFileExtension);
    }

    return hr;
}


/****************************************************************************
 *
 *  Load
 *
 *  Description:
 *      Loads wave data.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to force a reload.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::Load"

HRESULT
CGuiWaveBankEntry::Load
(
    BOOL                    fForce
)
{
    CGuiWaveBank *          pBank       = (CGuiWaveBank *)m_pParent;
    HICON                   hLargeIcon  = NULL;
    HICON                   hSmallIcon  = NULL;
    SHFILEINFO              shfi;
    HRESULT                 hr;

    //
    // Register the shell icon with the list view
    //

    if(!m_fLoaded)
    {
        if(!pBank->m_ListWindow.m_ListView.FindRegisteredType(m_szFileExtension))
        {
            if(SHGetFileInfo(m_szFileName, 0, &shfi, sizeof(shfi), SHGFI_ICON | SHGFI_LARGEICON))
            {
                hLargeIcon = shfi.hIcon;
            }
            
            if(SHGetFileInfo(m_szFileName, 0, &shfi, sizeof(shfi), SHGFI_ICON | SHGFI_SMALLICON))
            {
                hSmallIcon = shfi.hIcon;
            }

            if(!hLargeIcon)
            {
                hLargeIcon = LoadIcon(NULL, IDI_QUESTION);
            }

            if(!hSmallIcon)
            {
                hSmallIcon = LoadIcon(NULL, IDI_QUESTION);
            }

            pBank->m_ListWindow.m_ListView.RegisterType(m_szFileExtension, hLargeIcon, hSmallIcon);
        }
    }

    //
    // Hand off to the base class
    //

    hr = CWaveBankEntry::Load(fForce);

    //
    // Update the UI
    //

    if(SUCCEEDED(hr))
    {
        UpdateUI();
    }

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the entry.
 *
 *  Arguments:
 *      LPCTSTR [in]: entry name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::SetName"

HRESULT 
CGuiWaveBankEntry::SetName
(
    LPCTSTR                 pszName
)
{
    HRESULT                 hr;

    if(!_tcscmp(pszName, m_szEntryName))
    {
        return S_OK;
    }
    
    hr = CWaveBankEntry::SetName(pszName);

    if(SUCCEEDED(hr))
    {
        MakeDirty();
    }

    return hr;
}


/****************************************************************************
 *
 *  SetFlags
 *
 *  Description:
 *      Sets entry flags.  Because of error-checking, the flags actually set
 *      by this method may not match those passed in.
 *
 *  Arguments:
 *      DWORD [in]: mask of flags to change.
 *      DWORD [in]: new flags.
 *
 *  Returns:  
 *      DWORD: new flags.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::SetFlags"

DWORD
CGuiWaveBankEntry::SetFlags
(
    DWORD                   dwMask,
    DWORD                   dwFlags
)
{
    DWORD                   dwNewFlags;
    
    dwNewFlags = CWaveBankEntry::SetFlags(dwMask, dwFlags);

    if(dwNewFlags != (dwFlags & dwMask))
    {
        MakeDirty();
    }

    return dwNewFlags;
}


/****************************************************************************
 *
 *  UpdateUI
 *
 *  Description:
 *      Updates the UI for this entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::UpdateUI"

void
CGuiWaveBankEntry::UpdateUI
(
    void
)
{
    CGuiWaveBank *          pBank       = (CGuiWaveBank *)CWaveBankEntry::m_pParent;
    UINT                    nColumn     = 1;
    DWORD                   dwOffset    = 0;

    if(!pBank->m_ListWindow.m_ListView)
    {
        return;
    }
    
    //
    // If we're not already in the list, put us there
    //

    if(-1 == m_nItemIndex)
    {
        CListViewItem::Create(&pBank->m_ListWindow.m_ListView, m_szEntryName, m_szFileExtension);
    }
    else
    {
        SetText(m_szEntryName);
    }

    //
    // Add column data
    //

    if(WAVEBANKMINIFORMAT_TAG_ADPCM == m_Format.wFormatTag)
    {
        SetColumnText(nColumn++, TEXT("ADPCM"));
    }
    else
    {
        SetColumnText(nColumn++, TEXT("PCM"));
    }

    SetColumnValue(nColumn++, m_Format.nSamplesPerSec, FALSE, TRUE);
    
    if(WAVEBANKMINIFORMAT_TAG_ADPCM == m_Format.wFormatTag)
    {
        SetColumnValue(nColumn++, 4, FALSE, FALSE);
    }
    else if(WAVEBANKMINIFORMAT_BITDEPTH_8 == m_Format.wBitsPerSample)
    {
        SetColumnValue(nColumn++, 8, FALSE, FALSE);
    }
    else
    {
        SetColumnValue(nColumn++, 16, FALSE, FALSE);
    }

    SetColumnValue(nColumn++, m_Format.nChannels, FALSE, FALSE);
    SetColumnValue(nColumn++, m_dwDestLength, FALSE, TRUE);

    if(m_dwFlags & WBFILTER_ADPCM)
    {
        SetColumnText(nColumn++, CXboxAdpcmFilter::GetName());
    }
    else if(m_dwFlags & WBFILTER_8BIT)
    {
        SetColumnText(nColumn++, C8BitFilter::GetName());
    }
    else
    {
        SetColumnText(nColumn++, NULL);
    }
    
    SetColumnText(nColumn++, m_szFileName);

    //
    // Resort and resize
    //

    m_pList->Sort(-1, 0);
    m_pList->ResizeColumns();
}


/****************************************************************************
 *
 *  OnEndLabelEdit
 *
 *  Description:
 *      Updates the UI for this object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::OnEndLabelEdit"

BOOL
CGuiWaveBankEntry::OnEndLabelEdit
(
    LPCTSTR                 pszText
)
{
    SetName(pszText);

    return FALSE;
}


/****************************************************************************
 *
 *  OnStateChanged
 *
 *  Description:
 *      Handles state changes.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::OnStateChanged"

void
CGuiWaveBankEntry::OnStateChanged
(
    DWORD                   dwOldState,
    DWORD                   dwNewState
)
{
    //
    // If the selection state has changed, update the UI
    //

    if((dwOldState | dwNewState) & LVIS_SELECTED)
    {
        ((CWaveBankWindow *)m_pList->m_pParent)->UpdateCommandState();
    }
}


/****************************************************************************
 *
 *  OnCmdPlay
 *
 *  Description:
 *      Plays the entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::OnCmdPlay"

void
CGuiWaveBankEntry::OnCmdPlay
(
    void
)
{
    g_pApplication->m_RemoteAudition.Play(this);
}


/****************************************************************************
 *
 *  CWaveBankWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::CWaveBankWindow"

CWaveBankWindow::CWaveBankWindow
(
    void
)
:   CWorkspaceChild(WKSPCTYPE)
{
    m_fUpdateCommands = TRUE;
}


/****************************************************************************
 *
 *  ~CWaveBankWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::~CWaveBankWindow"

CWaveBankWindow::~CWaveBankWindow
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates or activates the window.
 *
 *  Arguments:
 *      LPBOOL [out]: TRUE if the window was created; FALSE if it was just
 *                    activated.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::Create"

BOOL
CWaveBankWindow::Create
(
    LPBOOL                  pfCreated
)
{
    return CWorkspaceChild::Create(m_pBank->m_szBankName, IDI_WAVEBANK, pfCreated);
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCreate"

BOOL
CWaveBankWindow::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    static const DWORD      dwExStyle       = 0;
    static const DWORD      dwStyle         = WS_CHILD | WS_VISIBLE | LVS_ALIGNLEFT | LVS_ALIGNTOP | LVS_AUTOARRANGE | LVS_NOLABELWRAP | LVS_REPORT | LVS_EDITLABELS | LVS_SHOWSELALWAYS;
    static const DWORD      dwListExStyle   = LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP;
    BOOL                    fSuccess;

    if(CWorkspaceChild::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Create the list-view
    //

    fSuccess = m_ListView.Create(this, dwExStyle, dwStyle, dwListExStyle);

    //
    // Add columns
    //

    if(fSuccess)
    {
        fSuccess = m_ListView.InsertColumns(CGuiWaveBankEntry::m_aColumnData, NUMELMS(CGuiWaveBankEntry::m_aColumnData));
    }

    //
    // Populate the list-view
    //

    if(fSuccess)
    {
        fSuccess = Refresh();
    }

    //
    // Enable file drops
    //

    if(fSuccess)
    {
        DragAcceptFiles();
    }

    //
    // Success
    //

    if(!fSuccess)
    {
        *plResult = 0;
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles WM_SIZE messages.
 *
 *  Arguments:
 *      UINT [in]: resize type.
 *      UINT [in]: client width.
 *      UINT [in]: client height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnSize"

BOOL
CWaveBankWindow::OnSize
(
    UINT                    nType,
    UINT                    nWidth,
    UINT                    nHeight,
    LRESULT *               plResult
)
{
    if(CWorkspaceChild::OnSize(nType, nWidth, nHeight, plResult))
    {
        return TRUE;
    }
    
    m_ListView.MoveWindow(0, 0, nWidth, nHeight);

    return FALSE;
}


/****************************************************************************
 *
 *  OnContextMenu
 *
 *  Description:
 *      Handles WM_CONTEXTMENU messages.
 *
 *  Arguments:
 *      HWND [in]: window the user clicked in.
 *      int [in]: mouse x-coordinate.
 *      int [in]: mouse y-coordinate.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnContextMenu"

BOOL
CWaveBankWindow::OnContextMenu
(
    HWND                    hWndFocus,
    int                     x,
    int                     y,
    LRESULT *               plResult
)
{
    HMENU                   hMenu;
    
    if(CWorkspaceChild::OnContextMenu(hWndFocus, x, y, plResult))
    {
        return TRUE;
    }

    TrackPopupMenu(g_pApplication->m_MainFrame.m_ahMenus[g_pApplication->m_MainFrame.MENUIDX_WAVEBANK_ENTRY_POPUP], TPM_RIGHTBUTTON, x, y, 0, m_hWnd, NULL);

    return FALSE;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles WM_COMMAND messages.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCommand"

BOOL
CWaveBankWindow::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hWndControl,
    LRESULT *               plResult
)
{
    if(CWorkspaceChild::OnCommand(nCommandId, nControlId, hWndControl, plResult))
    {
        return TRUE;
    }

    switch(nControlId)
    {
        case ID_REFRESH:
        case ID_WAVEBANK_REFRESH:
            Refresh();
            break;
        
        case ID_ADD_WAVEBANK_ENTRY:
            OnCmdAddEntry();
            break;
        
        case ID_RENAME:
        case ID_WAVEBANK_ENTRY_RENAME:
            OnCmdRename();
            break;

        case ID_DELETE:
        case ID_WAVEBANK_ENTRY_DELETE:
            OnCmdRemove();
            break;

        case ID_WAVEBANK_ENTRY_ADPCM:
            OnCmdSetFlags(WBFILTER_ADPCM);
            break;

        case ID_WAVEBANK_ENTRY_8BIT:
            OnCmdSetFlags(WBFILTER_8BIT);
            break;

        case ID_SELECT_ALL:
            OnCmdSelectAll();
            break;

        case ID_PLAY:
            OnCmdPlay();
            break;

        case ID_STOP:
            OnCmdStop();
            break;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnCmdRename
 *
 *  Description:
 *      Renames the currently selected entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdRename"

void
CWaveBankWindow::OnCmdRename
(
    void
)
{
    int                     nSelectionCount;
    CListViewItem *         pItem;
    
    //
    // We can only rename one item at a time
    //

    if(1 != (nSelectionCount = m_ListView.GetSelectedCount()))
    {
        return;
    }

    if(pItem = m_ListView.GetNextItem(NULL, LVNI_SELECTED))
    {
        pItem->EditLabel();
    }
}


/****************************************************************************
 *
 *  OnCmdRemove
 *
 *  Description:
 *      Removes the currently selected entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdRemove"

void
CWaveBankWindow::OnCmdRemove
(
    void
)
{
    CGuiWaveBankEntry *     pEntry;
    BOOL                    fRedraw;
    BOOL                    fAppTitle;
    int                     nSelectionCount;

    if((nSelectionCount = m_ListView.GetSelectedCount()) < 1)
    {
        return;
    }
    
    if(IDYES != MsgBoxResource(g_pApplication->m_MainFrame, MB_ICONQUESTION | MB_YESNO, IDS_CONFIRM_DELETE_WAVEBANK_ENTRY))
    {
        return;
    }

    fRedraw = m_ListView.SetRedraw(FALSE);
    fAppTitle = g_pApplication->m_Project.EnableAppTitleUpdates(FALSE);
    
    while(TRUE)
    {
        if(!(pEntry = (CGuiWaveBankEntry *)m_ListView.GetNextItem(NULL, LVNI_SELECTED)))
        {
            break;
        }

        m_pBank->RemoveEntry(pEntry);
    }

    m_ListView.SetRedraw(fRedraw);
    g_pApplication->m_Project.EnableAppTitleUpdates(fAppTitle);
}


/****************************************************************************
 *
 *  OnCmdSetFlags
 *
 *  Description:
 *      Sets flags for the selected entry or entries.
 *
 *  Arguments:
 *      DWORD [in]: valid mask.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdSetFlags"

void
CWaveBankWindow::OnCmdSetFlags
(
    DWORD                   dwFilter
)
{
    static const DWORD      dwMask          = WBFILTER_MASK;
    DWORD                   dwFlags         = 0;
    int                     nChanged        = 0;
    int                     nSelectionCount;
    CGuiWaveBankEntry *     pEntry;
    BOOL                    fRedraw;

    //
    // Make sure at least one item is selected
    //

    if((nSelectionCount = m_ListView.GetSelectedCount()) < 1)
    {
        return;
    }

    //
    // Disable redraws
    //
    
    fRedraw = m_ListView.SetRedraw(FALSE);

    //
    // Get the current flags for all selected items.  If any of them have
    // this compression bit set, we'll toggle them all off.  If none of
    // them do, we'll toggle them all on.
    //

    pEntry = NULL;
    
    while(TRUE)
    {
        if(!(pEntry = (CGuiWaveBankEntry *)m_ListView.GetNextItem(pEntry, LVNI_SELECTED)))
        {
            break;
        }

        dwFlags |= pEntry->m_dwFlags;
    }

    dwFlags = ~dwFlags & dwFilter;

    pEntry = NULL;
    
    while(TRUE)
    {
        if(!(pEntry = (CGuiWaveBankEntry *)m_ListView.GetNextItem(pEntry, LVNI_SELECTED)))
        {
            break;
        }

        if(pEntry->SetFlags(dwMask, dwFlags) == dwFlags)
        {
            nChanged++;
        }

        pEntry->UpdateUI();
    }

    //
    // Restore redraws
    //

    m_ListView.SetRedraw(fRedraw);

    //
    // Update command states
    //

    if(nChanged)
    {
        UpdateCommandState();
    }

    //
    // If not every item was able to be changed, warn the user
    //

    if(nChanged < nSelectionCount)
    {
        if(nChanged)
        {
            MsgBoxResource(g_pApplication->m_MainFrame, MB_OK | MB_ICONINFORMATION, IDS_NOT_ALL_CONVERTED);
        }
        else
        {
            MsgBoxResource(g_pApplication->m_MainFrame, MB_OK | MB_ICONINFORMATION, IDS_NONE_CONVERTED);
        }
    }
}


/****************************************************************************
 *
 *  OnCmdSelectAll
 *
 *  Description:
 *      Selects all items in the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdSelectAll"

void
CWaveBankWindow::OnCmdSelectAll
(
    void
)
{
    BOOL                    fEnable;

    fEnable = EnableCommandUpdate(FALSE);

    m_ListView.SelectAll(TRUE);

    EnableCommandUpdate(fEnable);
}


/****************************************************************************
 *
 *  OnCmdPlay
 *
 *  Description:
 *      Auditions the selected entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdPlay"

void
CWaveBankWindow::OnCmdPlay
(
    void
)
{
    CGuiWaveBankEntry *     pEntry  = NULL;
    
    //
    // Turn on the hourglass
    //

    BeginWaitCursor();

    //
    // Enumerate selected entries and audition them
    //

    while(pEntry = (CGuiWaveBankEntry *)m_ListView.GetNextItem(pEntry, LVNI_SELECTED))
    {
        pEntry->OnCmdPlay();
    }

    //
    // Turn off the hourglass
    //

    EndWaitCursor();
}


/****************************************************************************
 *
 *  OnCmdStop
 *
 *  Description:
 *      Stops any playing entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdStop"

void
CWaveBankWindow::OnCmdStop
(
    void
)
{
    g_pApplication->m_RemoteAudition.StopAll();
}


/****************************************************************************
 *
 *  Refresh
 *
 *  Description:
 *      Refreshes list data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::Refresh"

BOOL
CWaveBankWindow::Refresh
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CGuiWaveBankEntry *     pEntry;
    BOOL                    fRedraw;

    //
    // Change the cursor to provide user feedback
    //

    BeginWaitCursor();

    //
    // Disable window redraws
    //

    fRedraw = m_ListView.SetRedraw(FALSE);

    //
    // Reload all entries
    //
    
    m_pBank->LoadEntries(TRUE);

    //
    // Restore redraw state
    //
    
    m_ListView.SetRedraw(fRedraw);

    //
    // Restore the cursor
    //

    EndWaitCursor();

    return TRUE;
}


/****************************************************************************
 *
 *  UpdateCommandState
 *
 *  Description:
 *      Updates the state of all commands used by this object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::UpdateCommandState"

void
CWaveBankWindow::UpdateCommandState
(
    void
)
{
    static const UINT       anCommands[]    =
    {
        ID_ADD_WAVEBANK_ENTRY,
        ID_WAVEBANK_ENTRY_ADPCM,
        ID_WAVEBANK_ENTRY_8BIT,
        ID_PLAY,
        ID_STOP,
        ID_WAVEBANK_ENTRY_RENAME,
        ID_WAVEBANK_ENTRY_DELETE,
    };

    CGuiWaveBankEntry *     pEntry          = NULL;
    int                     nValidAdpcm     = 0;
    int                     nAdpcm          = 0;
    int                     nValid8bit      = 0;
    int                     n8bit           = 0;
    BOOL                    fEnable;
    int                     nSelectionCount;
    DWORD                   dwFlags;
    UINT                    i;

    if(!m_fUpdateCommands)
    {
        return;
    }
    
    //
    // If we're not the active window, disable all commands that relate to
    // us
    //

#pragma TODO("Is there ever a possibility that we'll do this *after* another window has taken focus?")

    if(!((CMDIClientWindow *)m_pParent)->IsActiveChild(this))
    {
        for(i = 0; i < NUMELMS(anCommands); i++)
        {
            g_pApplication->m_MainFrame.EnableCommand(anCommands[i], FALSE);
        }

        return;
    }

    //
    // Update commands that are enabled just because we're in view
    //

    g_pApplication->m_MainFrame.EnableCommand(ID_ADD_WAVEBANK_ENTRY, TRUE);

    //
    // Update commands that depend on the selection state
    //

    nSelectionCount = m_ListView.GetSelectedCount();
    fEnable = (nSelectionCount >= 1);

    g_pApplication->m_MainFrame.EnableCommand(ID_PLAY, fEnable);
    g_pApplication->m_MainFrame.EnableCommand(ID_STOP, fEnable);
    g_pApplication->m_MainFrame.EnableCommand(ID_WAVEBANK_ENTRY_DELETE, fEnable);

    fEnable = (1 == nSelectionCount);

    g_pApplication->m_MainFrame.EnableCommand(ID_WAVEBANK_ENTRY_RENAME, fEnable);

    //
    // Update commands that depend on which entries are selected
    //

    while(TRUE)
    {
        if(!(pEntry = (CGuiWaveBankEntry *)m_ListView.GetNextItem(pEntry, LVNI_SELECTED)))
        {
            break;
        }

        dwFlags = pEntry->GetValidFlags();

        if(dwFlags & WBFILTER_ADPCM)
        {
            nValidAdpcm++;
        }

        if(dwFlags & WBFILTER_8BIT)
        {
            nValid8bit++;
        }

        dwFlags = pEntry->m_dwFlags;

        if(dwFlags & WBFILTER_ADPCM)
        {
            nAdpcm++;
        }

        if(dwFlags & WBFILTER_8BIT)
        {
            n8bit++;
        }

        if(nValidAdpcm && nAdpcm && nValid8bit && n8bit)
        {
            break;
        }
    }

    if(nValidAdpcm)
    {
        g_pApplication->m_MainFrame.EnableCommand(ID_WAVEBANK_ENTRY_ADPCM, TRUE);
        g_pApplication->m_MainFrame.CheckCommand(ID_WAVEBANK_ENTRY_ADPCM, MAKEBOOL(nAdpcm));
    }
    else
    {
        g_pApplication->m_MainFrame.EnableCommand(ID_WAVEBANK_ENTRY_ADPCM, FALSE);
    }
            
    if(nValid8bit)
    {
        g_pApplication->m_MainFrame.EnableCommand(ID_WAVEBANK_ENTRY_8BIT, TRUE);
        g_pApplication->m_MainFrame.CheckCommand(ID_WAVEBANK_ENTRY_8BIT, MAKEBOOL(n8bit));
    }
    else
    {
        g_pApplication->m_MainFrame.EnableCommand(ID_WAVEBANK_ENTRY_8BIT, FALSE);
    }
}


/****************************************************************************
 *
 *  EnableCommandUpdate
 *
 *  Description:
 *      Toggles the whether the command state is updated or not.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to allow updates.
 *
 *  Returns:  
 *      BOOL: prior value.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::EnableCommandUpdate"

BOOL 
CWaveBankWindow::EnableCommandUpdate
(
    BOOL                    fEnable
)
{
    const BOOL              fPrevious   = m_fUpdateCommands;

    if(fPrevious != fEnable)
    {
        if(m_fUpdateCommands = fEnable)
        {
            UpdateCommandState();
        }
    }

    return fPrevious;
}


/****************************************************************************
 *
 *  OnCmdAddEntry
 *
 *  Description:
 *      Adds a new entry to the bank.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnCmdAddEntry"

void
CWaveBankWindow::OnCmdAddEntry
(
    void
)
{
    static const DWORD      dwMaxEntries    = 128;
    LPTSTR                  pszPath         = NULL;
    CWaveBankEntry *        pEntry;
    LPCTSTR                 pszFile;
    TCHAR                   szFile[MAX_PATH];
    BOOL                    fSuccess;
    BOOL                    fAddedAny;
    BOOL                    fAddedAll;
    BOOL                    fRedraw;
    HRESULT                 hr;

    fSuccess = MAKEBOOL(pszPath = MEMALLOC(TCHAR, MAX_PATH * dwMaxEntries));

    //
    // Get the file path(s)
    //

    if(fSuccess)
    {
        fSuccess = CGuiWaveBankProject::BrowseEntryFile(g_pApplication->m_MainFrame, pszPath, MAX_PATH * dwMaxEntries);
    }

    if(fSuccess)
    {
        //
        // Turn off redraws
        //

        fRedraw = m_ListView.SetRedraw(FALSE);

        //
        // If more than one file was specified, the path will be first, followed
        // by each file name in a null-terminated list
        //

        pszFile = pszPath + _tcslen(pszPath) + 1;

        if(*pszFile)
        {
            fAddedAny = FALSE;
            fAddedAll = TRUE;
        
            while(*pszFile)
            {
                _makepath(szFile, NULL, pszPath, pszFile, NULL);

                hr = m_pBank->AddEntry(NULL, szFile, 0, &pEntry);

                if(SUCCEEDED(hr))
                {
                    hr = pEntry->Load();
                }

                if(SUCCEEDED(hr))
                {
                    fAddedAny = TRUE;
                }
                else
                {
                    m_pBank->RemoveEntry(pEntry);
                    fAddedAll = FALSE;
                }

                pszFile += _tcslen(pszFile) + 1;
            }

            if(!fAddedAny)
            {
                DPF_WARNING("None of the entries were added to the wave bank");
                fSuccess = FALSE;
            }
            else if(!fAddedAll)
            {
                DPF_WARNING("Not all entries were added to the wave bank");
            }
        }
        else
        {
            hr = m_pBank->AddEntry(NULL, pszPath, 0, &pEntry);

            if(SUCCEEDED(hr))
            {
                hr = pEntry->Load();
            }

            if(FAILED(hr))
            {
                m_pBank->RemoveEntry(pEntry);
                fSuccess = FALSE;
            }
        }

        //
        // Turn redraws back on
        //

        m_ListView.SetRedraw(fRedraw);
    }

    //
    // Clean up
    //

    MEMFREE(pszPath);
}


/****************************************************************************
 *
 *  OnDropFiles
 *
 *  Description:
 *      Handles WM_DROPFILE messages.
 *
 *  Arguments:
 *      HDROP [in]: drop handle.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankWindow::OnDropFiles"

BOOL
CWaveBankWindow::OnDropFiles
(
    HDROP                   hDrop,
    LRESULT *               plResult
)
{
    BOOL                    fAddedAny           = FALSE;
    BOOL                    fAddedAll           = TRUE;
    CWaveBankEntry *        pEntry;
    UINT                    nCount;
    TCHAR                   szFile[MAX_PATH];
    BOOL                    fSuccess;
    BOOL                    fRedraw;
    HRESULT                 hr;
    UINT                    i;

    if(CWorkspaceChild::OnDropFiles(hDrop, plResult))
    {
        return TRUE;
    }

    //
    // Turn off redraws
    //

    fRedraw = m_ListView.SetRedraw(FALSE);

    //
    // Enumerate files dropped
    //

    nCount = DragQueryFile(hDrop, ~0UL, NULL, 0);

    for(i = 0; i < nCount; i++)
    {
        if(!DragQueryFile(hDrop, i, szFile, NUMELMS(szFile)))
        {
            fAddedAll = FALSE;
            continue;
        }
        
        hr = m_pBank->AddEntry(NULL, szFile, 0, &pEntry);

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = pEntry->Load()))
            {
                m_pBank->RemoveEntry(pEntry);
            }
        }

        if(SUCCEEDED(hr))
        {
            fAddedAny = TRUE;
        }
        else
        {
            fAddedAll = FALSE;
        }
    }

    if(!fAddedAny)
    {
        DPF_WARNING("None of the dropped files were added to the wave bank");
    }
    else if(!fAddedAll)
    {
        DPF_WARNING("Not all of the dropped files were added to the wave bank");
    }

    //
    // Turn redraws back on
    //

    m_ListView.SetRedraw(fRedraw);

    return FALSE;
}


/****************************************************************************
 *
 *  CWaveBankPropertiesDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::CWaveBankPropertiesDialog"

CWaveBankPropertiesDialog::CWaveBankPropertiesDialog
(
    CGuiWaveBank *          pBank
)
:   CDialog(IDD)
{
    m_pBank = pBank;
}


/****************************************************************************
 *
 *  ~CWaveBankPropertiesDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::~CWaveBankPropertiesDialog"

CWaveBankPropertiesDialog::~CWaveBankPropertiesDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles WM_CREATE messages.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::OnCreate"

BOOL
CWaveBankPropertiesDialog::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    static const UINT       nDefaultAlignmentCount  = 15;
    TCHAR                   szAlignment[0x100];
    TCHAR                   szSize[0x100];
    DWORD                   dwAlignment;
    UINT                    i;
    
    if(CDialog::OnCreate(pvContext, plResult))
    {
        return TRUE;
    }

    //
    // Make sure all entries are loaded
    //

    if(FAILED(m_pBank->LoadEntries()))
    {
        OnCmdCancel();
    }

    //
    // Populate controls
    //

    for(i = 0, dwAlignment = m_pBank->m_dwMinAlignment; i < nDefaultAlignmentCount; i++, dwAlignment *= 2)
    {
        FormatNumber(dwAlignment, FALSE, FALSE, szAlignment);
        
        SendDlgItemMessage(IDC_WAVEBANK_ALIGNMENT, CB_INSERTSTRING, -1, (LPARAM)szAlignment);
    }

    FormatNumber(m_pBank->GetBankDataSize(), FALSE, TRUE, szSize);

    SetDlgItemText(IDC_WAVEBANK_NAME, m_pBank->m_szBankName);
    SetDlgItemText(IDC_WAVEBANK_PATH, m_pBank->m_szBankFile);
    SetDlgItemText(IDC_WAVEBANK_HEADER_PATH, m_pBank->m_szHeaderFile);
    SetDlgItemText(IDC_WAVEBANK_SIZE, szSize);
    SetDlgItemInt(IDC_WAVEBANK_ALIGNMENT, m_pBank->m_dwAlignment, FALSE);

    CheckRadioButton(m_hWnd, IDC_WAVEBANK_TYPE_BUFFER, IDC_WAVEBANK_TYPE_STREAMING, (m_pBank->m_dwFlags & WAVEBANK_TYPE_STREAMING) ? IDC_WAVEBANK_TYPE_STREAMING : IDC_WAVEBANK_TYPE_BUFFER);

    return FALSE;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Handles WM_COMMAND messages.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::OnCommand"

BOOL
CWaveBankPropertiesDialog::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hWndControl,
    LRESULT *               plResult
)
{
    switch(nControlId)
    {
        case IDC_WAVEBANK_PATH_BROWSE:
            OnCmdBrowseBankPath();
            break;

        case IDC_WAVEBANK_HEADER_PATH_BROWSE:
            OnCmdBrowseHeaderPath();
            break;

        default:
            return CDialog::OnCommand(nCommandId, nControlId, hWndControl, plResult);
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnCmdOK
 *
 *  Description:
 *      Handles the OK command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::OnCmdOK"

void
CWaveBankPropertiesDialog::OnCmdOK
(
    void
)
{
    TCHAR                   szText[0x100];
    DWORD                   dwFlags;
    DWORD                   dwAlignment;
    HRESULT                 hr;
    
    //
    // Update the bank
    //

    GetDlgItemText(IDC_WAVEBANK_NAME, szText, NUMELMS(szText));

    hr = m_pBank->SetName(szText);

    if(SUCCEEDED(hr))
    {
        GetDlgItemText(IDC_WAVEBANK_PATH, szText, NUMELMS(szText));

        hr = m_pBank->SetBankPath(szText);
    }

    if(SUCCEEDED(hr))
    {
        GetDlgItemText(IDC_WAVEBANK_HEADER_PATH, szText, NUMELMS(szText));

        hr = m_pBank->SetHeaderPath(szText);
    }

    if(SUCCEEDED(hr))
    {
        dwFlags = m_pBank->m_dwFlags & ~WAVEBANK_TYPE_MASK;

        if(IsDlgButtonChecked(m_hWnd, IDC_WAVEBANK_TYPE_STREAMING))
        {
            dwFlags |= WAVEBANK_TYPE_STREAMING;
        }

        hr = m_pBank->SetFlags(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        dwAlignment = GetDlgItemInt(IDC_WAVEBANK_ALIGNMENT, NULL, FALSE);

        hr = m_pBank->SetAlignment(dwAlignment);
    }

    //
    // Close the dialog
    //

    if(SUCCEEDED(hr))
    {
        CDialog::OnCmdOK();
    }
}


/****************************************************************************
 *
 *  OnCmdBrowseBankPath
 *
 *  Description:
 *      Handles the browse command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::OnCmdBrowseBankPath"

void
CWaveBankPropertiesDialog::OnCmdBrowseBankPath
(
    void
)
{
    TCHAR                   szPath[MAX_PATH];

    if(!GetDlgItemText(IDC_WAVEBANK_PATH, szPath, NUMELMS(szPath)))
    {
        szPath[0] = 0;
    }

    if(CGuiWaveBankProject::BrowseBankFile(m_hWnd, szPath, NUMELMS(szPath)))
    {
        SetDlgItemText(IDC_WAVEBANK_PATH, szPath);
    }
}


/****************************************************************************
 *
 *  OnCmdBrowseHeaderPath
 *
 *  Description:
 *      Handles the browse command.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankPropertiesDialog::OnCmdBrowseHeaderPath"

void
CWaveBankPropertiesDialog::OnCmdBrowseHeaderPath
(
    void
)
{
    TCHAR                   szPath[MAX_PATH];

    if(!GetDlgItemText(IDC_WAVEBANK_HEADER_PATH, szPath, NUMELMS(szPath)))
    {
        szPath[0] = 0;
    }

    if(CGuiWaveBankProject::BrowseHeaderFile(m_hWnd, szPath, NUMELMS(szPath)))
    {
        SetDlgItemText(IDC_WAVEBANK_HEADER_PATH, szPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\xactapp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/4/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xactapp.h
 *  Content:    Main header file for XACT GUI application.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/4/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __XACTAPP_H__
#define __XACTAPP_H__

#include "xactgui.h"
#include "xactctl.h"
#include "wavbndli.h"
#include <xboxdbg.h>
#include "afxres.h"
#include "mainrc.h"
#include "xactreg.h"
#include "project.h"
#include "audition.h"
#include "mainfrm.h"
#include "wbndgui.h"

#endif // __XACTAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\wbndgui.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/13/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wbndgui.h
 *  Content:    Wave Bundler GUI wrapper objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/13/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WBNDGUI_H__
#define __WBNDGUI_H__

#ifdef __cplusplus

//
// Forward declarations
//

class CGuiWaveBank;
class CWaveBankWindow;
class CGuiWaveBankProject;

//
// Wave bank entry
//

class CGuiWaveBankEntry
    : public CWaveBankEntry, public CListViewItem
{
public:
    static const LVCOLUMNDATA   m_aColumnData[];                // List-view column data

protected:
    TCHAR                       m_szFileExtension[MAX_PATH];    // File extension (used to type-define the entry in the list)

public:
    CGuiWaveBankEntry(CGuiWaveBank *pWaveBank);
    virtual ~CGuiWaveBankEntry(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCTSTR pszEntryName, LPCTSTR pszFileName, DWORD dwFlags);
    virtual HRESULT Load(BOOL fForce = FALSE);

    // Entry properties
    virtual HRESULT SetName(LPCTSTR pszName);
    virtual DWORD SetFlags(DWORD dwMask, DWORD dwFlags);

    // UI
    virtual void MakeDirty(void);
    virtual void UpdateUI(void);

    // Command handlers
    virtual void OnCmdPlay(void);

    // Notification handlers
    virtual BOOL OnEndLabelEdit(LPCTSTR pszText);
    virtual void OnStateChanged(DWORD dwOldState, DWORD dwNewState);
    virtual void OnDoubleClick(void);
};

__inline void CGuiWaveBankEntry::MakeDirty(void)
{
    g_pApplication->m_Project.MakeDirty();
    UpdateUI();
}

__inline void CGuiWaveBankEntry::OnDoubleClick(void)
{
    OnCmdPlay();
}

//
// Wave bank list-view
//

class CWaveBankListView
    : public CListView
{
public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // Message handlers
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult);
};

__inline ULONG CWaveBankListView::AddRef(void)
{
    return 1;
}

__inline ULONG CWaveBankListView::Release(void)
{
    return 1;
}

__inline BOOL CWaveBankListView::OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult)
{
    if(CListView::OnCommand(nCommandId, nControlId, hWndControl, plResult))
    {
        return TRUE;
    }

    if(m_pParent)
    {
        return m_pParent->OnCommand(nCommandId, nControlId, hWndControl, plResult);
    }

    return FALSE;
}

//
// Wave bank list window
//

class CWaveBankWindow
    : public CWorkspaceChild
{
    friend class CGuiWaveBank;
    friend class CGuiWaveBankEntry;

public:
    enum
    {
        WKSPCTYPE = CWorkspaceChild::WKSPCTYPE_WAVEBANK
    };

    CWaveBankListView    m_ListView;         // List view
    CGuiWaveBank *          m_pBank;            // Bank object

protected:
    BOOL                    m_fUpdateCommands;  // Allow command updates?

public:
    CWaveBankWindow(void);
    virtual ~CWaveBankWindow(void);

public:
    // Reference count
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);
    
    // Initialization
    virtual void Initialize(CGuiWaveBank *pBank);
    virtual BOOL Create(LPBOOL pfCreated = NULL);

    // List contents
    virtual BOOL Refresh(void);

    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnSize(UINT nType, UINT nWidth, UINT nHeight, LRESULT *plResult);
    virtual BOOL OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hWndControl, LRESULT *plResult);
    virtual BOOL OnDropFiles(HDROP hDrop, LRESULT *plResult);

    // Command handlers
    virtual void OnCmdAddEntry(void);
    virtual void OnCmdRename(void);
    virtual void OnCmdRemove(void);
    virtual void OnCmdSetFlags(DWORD dwFilter);
    virtual void OnCmdPlay(void);
    virtual void OnCmdStop(void);
    virtual void OnCmdSelectAll(void);

    // Event handlers
    virtual void OnActivate(void);
    virtual void OnDeactivate(void);

    // Command state
    virtual BOOL EnableCommandUpdate(BOOL fEnable);
    virtual void UpdateCommandState(void);
};

__inline ULONG CWaveBankWindow::AddRef(void)
{
    return 1;
}

__inline ULONG CWaveBankWindow::Release(void)
{
    return 1;
}

__inline void CWaveBankWindow::Initialize(CGuiWaveBank *pBank)
{
    m_pBank = pBank;
}

__inline void CWaveBankWindow::OnActivate(void)
{
    UpdateCommandState();
}

__inline void CWaveBankWindow::OnDeactivate(void)
{
    UpdateCommandState();
}

//
// Wave bank
//

class CGuiWaveBank
    : public CWaveBank, public CMainProjectTreeItem
{
    friend class CWaveBankWindow;
    friend class CGuiWaveBankEntry;

protected:
    CWaveBankWindow  m_ListWindow;           // Bank list window

public:
    CGuiWaveBank(CGuiWaveBankProject *pProject);
    virtual ~CGuiWaveBank(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCTSTR pszBankName, LPCTSTR pszBankFile, LPCTSTR pszHeaderFile);

    // Bank properties
    virtual HRESULT SetName(LPCTSTR pszName);
    virtual HRESULT SetBankPath(LPCTSTR pszBankPath);
    virtual HRESULT SetHeaderPath(LPCTSTR pszHeaderPath);
    virtual HRESULT SetFlags(DWORD dwFlags);
    virtual HRESULT SetAlignment(DWORD dwAlignment);

    // UI
    virtual void MakeDirty(void);
    virtual BOOL OpenList(void);
    virtual void CloseList(void);
    virtual void UpdateUI(void);

    // Message handlers
    virtual BOOL OnContextMenu(HWND hWndFocus, int x, int y, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult);

    // Command handlers
    virtual void OnCmdRefresh(void);
    virtual void OnCmdRename(void);
    virtual void OnCmdRemove(void);
    virtual void OnCmdProperties(void);

    // Notification handlers
    virtual void OnDoubleClick(void);
    virtual void OnGetInfoTip(LPTSTR pszText, int cchTextMax);
    virtual BOOL OnEndLabelEdit(LPCTSTR pszText);

protected:
    // Entry creation
    virtual CWaveBankEntry *CreateEntry(void);
};

__inline CWaveBankEntry *CGuiWaveBank::CreateEntry(void)
{
    return NEW(CGuiWaveBankEntry(this));
}

__inline void CGuiWaveBank::MakeDirty(void)
{
    g_pApplication->m_Project.MakeDirty();
    UpdateUI();
}

__inline void CGuiWaveBank::OnDoubleClick(void)
{
    OpenList();
}

//
// Wave bank properties
//

class CWaveBankPropertiesDialog
    : public CDialog
{
public:
    enum
    {
        IDD = IDD_WAVEBANK_PROPERTIES
    };

protected:
    CGuiWaveBank *          m_pBank;        // Wave bank

public:
    CWaveBankPropertiesDialog(CGuiWaveBank *pBank);
    virtual ~CWaveBankPropertiesDialog(void);

protected:
    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hControlWnd, LRESULT *plResult);

    // Command handlers
    virtual void OnCmdOK(void);
    virtual void OnCmdBrowseBankPath(void);
    virtual void OnCmdBrowseHeaderPath(void);
};

//
// Wave bank project
//

class CGuiWaveBankProject
    : public CWaveBankProject
{
public:
    CGuiWaveBankProject(void);
    virtual ~CGuiWaveBankProject(void);

public:
    // File browsing
    static BOOL BrowseBankFile(HWND hWnd, LPTSTR pszFile, UINT nLength);
    static BOOL BrowseHeaderFile(HWND hWnd, LPTSTR pszFile, UINT nLength);
    static BOOL BrowseEntryFile(HWND hWnd, LPTSTR pszFile, UINT nLength);

protected:    
    // Bank creation
    virtual CWaveBank *CreateBank(void);

private:
    // Wave bank entry OFN hook procedure
    static UINT CALLBACK WaveBankEntryOFNHookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

__inline CWaveBank *CGuiWaveBankProject::CreateBank(void)
{
    return NEW(CGuiWaveBank(this));
}

#endif // __cplusplus

#endif // __WBNDGUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\host\gui\main\xactreg.h ===
/***************************************************************************
 *
 *  Copyright (C) 2/12/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xactreg.h
 *  Content:    XACT GUI global registry definitions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/12/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __XACTREG_H__
#define __XACTREG_H__

//
// The application root registry key
//

#define HKEY_XACT_APPLICATION_ROOT          HKEY_CURRENT_USER
#define REGKEY_XACT_APPLICATION_ROOT        TEXT("Software\\Microsoft\\XACT\\GUI")

//
// Window placement key/value pairs
//

#define REGKEY_MAINFRAME_PLACEMENT          NULL, TEXT("MainFramePlacement")
#define REGKEY_WORKSPACE_CHILD_PLACEMENT    NULL, TEXT("WorkspaceChildPlacement")
#define REGKEY_SPLITTER_POSITION            NULL, TEXT("MainSplitterPosition")

//
// MRU keys
//

#define REGKEY_PROJECT_MRU                  TEXT("Project MRU")
#define REGKEY_XBOX_MRU                     TEXT("Xbox MRU")

#ifdef __cplusplus

#endif // __cplusplus

#endif // __XACTREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\common.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscommon.cpp
 *  Content:    DirectSound common source file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/01    dereks  Created.
 *
 ***************************************************************************/

#include "common.h"

#include "debug.cpp"
#include "drvhlp.cpp"

#include "memmgr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\drvhlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.cpp
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "common.h"

namespace XACT {


}; //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include "macros.h"

#if defined(DEBUG) && !defined(USEDPF)
#define USEDPF
#endif // USEDPF

//
// Preprocessor hacks
//

#define QUOTE0(a) \
    #a

#define QUOTE1(a) \
    QUOTE0(a)

//
// DPF definitions
//
                                
#ifndef DPF_LIBRARY
#error DPF_LIBRARY not defined
#endif // DPF_LIBRARY

BEGIN_DEFINE_STRUCT()
    DWORD   dwFlags;
    DWORD   dwLevel;
    LPCSTR  pszFile;
    UINT    nLine;
    LPCSTR  pszFunction;
    LPCSTR  pszLibrary;
END_DEFINE_STRUCT(DPFCONTEXT);

typedef void (CALLBACK *LPFNDPFCALLBACK)(DWORD dwLevel, LPCSTR pszString);

EXTERN_C DWORD g_dwXactDebugLevel;
EXTERN_C DWORD g_dwXactDebugBreakLevel;

EXTERN_C DPFCONTEXT g_XactDebugContext[HIGH_LEVEL + 1];
EXTERN_C BOOL g_fXactDebugBreak;


#pragma warning(disable:4002)

//
// #pragma Reminders
//

#define MESSAGE(msg) \
    message(__FILE__ "(" QUOTE1(__LINE__) "): " msg)

#define TODO(msg) \
    MESSAGE("TODO: " msg)

#define BUGBUG(msg) \
    MESSAGE("BUGBUG: " msg)

#define HACKHACK(msg) \
    MESSAGE("HACKHACK: " msg)

//
// Debug flags
//

#define DPF_FLAGS_LIBRARY           0x00000001
#define DPF_FLAGS_FILELINE          0x00000002
#define DPF_FLAGS_PROCESSTHREADID   0x00000004
#define DPF_FLAGS_FUNCTIONNAME      0x00000008

#ifndef DPF_FLAGS_DEFAULT
#ifdef _XBOX
#define DPF_FLAGS_DEFAULT           (DPF_FLAGS_LIBRARY | DPF_FLAGS_FUNCTIONNAME)
#else // _XBOX
#define DPF_FLAGS_DEFAULT           (DPF_FLAGS_LIBRARY | DPF_FLAGS_FUNCTIONNAME)
#endif // _XBOX
#endif // DPF_FLAGS_DEFAULT

//
// Debug levels
//

#define DPFLVL_ABSOLUTE         0   // Disregard level
#define DPFLVL_ERROR            1   // Errors
#define DPFLVL_RESOURCE         2   // Resource allocation failures
#define DPFLVL_WARNING          3   // Warnings
#define DPFLVL_INFO             4   // General info
#define DPFLVL_BLAB             5   // Mostly useless info
#define DPFLVL_ENTERLEAVE       9   // Function enter/leave

#define DPFLVL_FIRST            DPFLVL_ABSOLUTE
#define DPFLVL_LAST             DPFLVL_ENTERLEAVE

#ifndef DPFLVL_DEFAULT
#define DPFLVL_DEFAULT          DPFLVL_WARNING
#endif // DPFLVL_DEFAULT

#ifndef DPFLVL_DEFAULT_BREAK
#define DPFLVL_DEFAULT_BREAK    DPFLVL_RESOURCE
#endif // DPFLVL_DEFAULT_BREAK

//
// Debug API
//

#undef ASSERTMSG
#undef ASSERT
#undef BREAK

#ifdef USEDPF

void __cdecl DwDbgSetContext(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary);
void __cdecl DwDbgPrint(LPCSTR pszFormat, ...);
void __cdecl DwDbgPrintStatic(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary, LPCSTR pszFormat, ...);
void __cdecl DwDbgPrintStaticV(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary, LPCSTR pszFormat, va_list va);
void __cdecl DwDbgAssert(BOOL fAssert, LPCSTR pszExpression, LPCSTR pszFile, UINT nLine);
void __cdecl DwDbgBreak(void);

#define DPF_ABSOLUTE \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_ABSOLUTE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_ERROR \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_ERROR, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_RESOURCE \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_RESOURCE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_WARNING \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_WARNING, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_INFO \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_INFO, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_BLAB \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_BLAB, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#ifdef DPF_ENABLE_ENTERLEAVE

#define DPF_ENTERLEAVE \
    DwDbgSetContext(DPF_FLAGS_DEFAULT, DPFLVL_ENTERLEAVE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#else // DPF_ENTERLEAVE
                                
#define DPF_ENTERLEAVE(a)

#endif // DPF_ENTERLEAVE
                                
#define ASSERT(a) \
    DwDbgAssert(!(a), #a, __FILE__, __LINE__)

#define ASSERTMSG(a) \
    DwDbgAssert(TRUE, a, __FILE__, __LINE__)

#define BREAK() \
    DwDbgBreak()

#else // USEDPF

#define DPF_ABSOLUTE(a)
#define DPF_ERROR(a)
#define DPF_RESOURCE(a)
#define DPF_WARNING(a)
#define DPF_INFO(a)
#define DPF_BLAB(a)
#define DPF_ENTERLEAVE(a)

#define ASSERT(a)
#define ASSERTMSG(a)
#define BREAK()

#endif // USEDPF
                                
#define DPF_ENTER()             DPF_ENTERLEAVE("Enter")
#define DPF_LEAVE(a)            DPF_ENTERLEAVE("Leave, returning %#x", (DWORD)(a))
#define DPF_LEAVE_VOID()        DPF_ENTERLEAVE("Leave")

#define DPF_LEAVE_HRESULT(a)    DPF_LEAVE(a)
#define DPF_LEAVE_WINERROR(a)   DPF_LEAVE(a)
#define DPF_LEAVE_NTSTATUS(a)   DPF_LEAVE(a)

#undef DPF_FNAME
#define DPF_FNAME               NULL

//
// Debug log
//

#ifdef USEDEBUGLOG

#define DLOG_ENTRY_LENGTH   64
#define DLOG_ENTRY_COUNT    1024

EXTERN_C CHAR g_aszDirectSoundDebugLog[DLOG_ENTRY_COUNT][DLOG_ENTRY_LENGTH];
EXTERN_C DWORD g_dwDirectSoundDebugLogIndex;

EXTERN_C void __cdecl DwDbgLog(LPCSTR pszFormat, ...);

#define DLOG DwDbgLog

#else // USEDEBUGLOG

#define DLOG(a)

#endif // USEDEBUGLOG

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\drvhlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.h
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DRVHLP_H__
#define __DRVHLP_H__

#if defined(_XBOX) && defined(__cplusplus)

// 
// Raised IRQL object
//

class CIrql
{
private:
    KIRQL                   m_irql;
    BOOL                    m_fRaised;

public:
    CIrql(void);

public:
    void Raise(void);
    void Lower(void);
};

__inline CIrql::CIrql(void)
{
    m_fRaised = FALSE;
}
    
__inline void CIrql::Raise(void)
{
    if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))
    {
        m_irql = KfRaiseIrql(DISPATCH_LEVEL);
    }
}

__inline void CIrql::Lower(void)
{
    if(m_fRaised)
    {
        KfLowerIrql(m_irql);
        m_fRaised = FALSE;
    }
}

//
// Automatic (function-scope) raised IRQL
//

class CAutoIrql
    : public CIrql
{
public:
    CAutoIrql(void);
    ~CAutoIrql(void);
};

__inline CAutoIrql::CAutoIrql(void)
{
    Raise();
}

__inline CAutoIrql::~CAutoIrql(void)
{
    Lower();
}

#define AutoIrql() \
    CAutoIrql __AutoIrql

#endif // defined(_XBOX) && defined(__cplusplus)

//
// Misc. helpers
//

__inline UINT CountBits(DWORD dwBits)
{
    UINT                    nCount;
    UINT                    i;

    for(i = 0, nCount = 0; i < 32; i++)
    {
        if(dwBits & (1UL << i))
        {
            nCount++;
        }
    }

    return nCount;
}

__inline UINT GetBitIndex(DWORD dwBit)
{
    UINT                    i;

    for(i = 0; i < 32; i++)
    {
        if(dwBit & (1UL << i))
        {
            break;
        }
    }

    return i;
}

#ifdef __cplusplus

//
// Interlocked and/or operations
//

static void __fastcall and(volatile unsigned short *dst, unsigned short src)
{
    __asm
    {
        and word ptr [ecx], dx
    }
}

static void __fastcall or(volatile unsigned short *dst, unsigned short src)
{
    __asm
    {
        or word ptr [ecx], dx
    }
}

static void __fastcall and(volatile unsigned long *dst, unsigned long src)
{
    __asm
    {
        and dword ptr [ecx], edx
    }                        
}

static void __fastcall or(volatile unsigned long *dst, unsigned long src)
{
    __asm
    {
        or dword ptr [ecx], edx
    }
}

#endif // __cplusplus

#endif // __DRVHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

//
// Preprocessor definitions
//

#if DBG && !defined(DEBUG)
#define DEBUG
#endif

#if defined(DEBUG) && !defined(VALIDATE_PARAMETERS)
#define VALIDATE_PARAMETERS
#endif

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <pci.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define NODSOUND
#include <xtl.h>
#undef NODSOUND

#include <xboxp.h>
#include <dsoundp.h>

#include <stdio.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>

//
// Private includes
//

namespace XACT {

#include "macros.h"
#include "debug.h"
#include "drvhlp.h"
#include "ntlist.h"
#include "refcount.h"

}//namespace

#include "memmgr.h"

//
// New and delete overrides
//

#ifdef __cplusplus


static void *__cdecl operator new(size_t cbBuffer) 
{ 
    using namespace XACT;
    return XactMemAlloc(cbBuffer, FALSE); 
}

static void *__cdecl operator new[](size_t cbBuffer) 
{ 
    using namespace XACT;
    return XactMemAlloc(cbBuffer, FALSE);
}

#ifdef TRACK_MEMORY_USAGE

static void *__cdecl operator new(size_t cbBuffer, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass)
{
    using namespace XACT;
    return XactTrackMemAlloc(pszFile, nLine, pszClass, cbBuffer, TRUE); 
}

static void *__cdecl operator new[](size_t cbBuffer, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass)
{
    using namespace XACT;
    return XactTrackMemAlloc(pszFile, nLine, pszClass, cbBuffer, TRUE); 
}

#endif // TRACK_MEMORY_USAGE

static void __cdecl operator delete(void *pvBuffer) 
{ 
    using namespace XACT;
    XactMemFree(pvBuffer); 
}

static void __cdecl operator delete[](void *pvBuffer) 
{ 
    using namespace XACT;
    XactMemFree(pvBuffer); 
}

#ifdef TRACK_MEMORY_USAGE

#define NEW(type) \
    new(__FILE__, __LINE__, #type) type

#define NEW_A(type, count) \
    new(__FILE__, __LINE__, #type) type [count]

#else // TRACK_MEMORY_USAGE

#define NEW(type) \
    new type

#define NEW_A(type, count) \
    new type [count]

#endif // TRACK_MEMORY_USAGE

#undef DELETE
#define DELETE(p) \
    { \
        if(p) \
        { \
            delete (p); \
            (p) = NULL; \
        } \
    }

#define DELETE_A(p) \
    { \
        if(p) \
        { \
            delete [] (p); \
            (p) = NULL; \
        } \
    }


#endif // __cplusplus


#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\memmgr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memmgr.cpp
 *  Content:    Memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/21/00    dereks  Created.
 *
 ****************************************************************************/

#include "common.h"


#ifdef TRACK_MEMORY_USAGE

//
// Allocation tracking data
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY              leListEntry;
    LPCSTR                  pszFile;
    ULONG                   nLine;
    LPCSTR                  pszClass;
    ULONG                   cbSize;
    LPVOID                  pvBaseAddress;
END_DEFINE_STRUCT(MEMTRACK);

LIST_ENTRY g_lstMemoryTracking;

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  MemAlloc
 *
 *  Description:
 *      Allocates memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "XactMemAlloc"

LPVOID 
XactMemAlloc
(
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    LPVOID                  pvBuffer;

    using namespace XACT;
    ASSERT(cbBuffer);

    pvBuffer = ExAllocatePoolWithTag(cbBuffer,'tcax');
    memset(pvBuffer,0,cbBuffer);

    return pvBuffer;
}

/****************************************************************************
 *
 *  MemFree
 *
 *  Description:
 *      Frees memory allocated with MemAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "XactMemFree"

void 
XactMemFree
(
    LPVOID                  pvBuffer
)
{
    using namespace XACT;
    ASSERT(pvBuffer);	
	ExFreePool(pvBuffer);
}

/****************************************************************************
 *
 *  TrackMemAlloc
 *
 *  Description:
 *      Completes a memory tracking operation by adding the allocation to
 *      the list and fixing up the base pointer.
 *
 *  Arguments:
 *      LPVOID [in]: allocation base address.
 *      LPCSTR [in]: file the allocation comes from.
 *      ULONG [in]: line number the allocation comes from.
 *      LPCSTR [in]: class being allocated.
 *      DWORD [in]: allocator tag.
 *      ULONG [in]: size of allocation.
 *
 *  Returns:  
 *      LPVOID: allocation base address.
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "TrackMemAlloc"

LPVOID
XactTrackMemAlloc
(
    LPVOID                  pvBaseAddress,
    ULONG                   cbTracking,
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    ULONG                   cbSize
)
{
    LPDSMEMTRACK            pTracking;
    
    ASSERT(pvBaseAddress);
    ASSERT(cbTracking >= sizeof(*pTracking));
    ASSERT(cbSize);
    
    //
    // Because of alignment issues, the base address may be incremented more
    // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
    // directly behind the allocation, but allocate more than cbSize +
    // sizeof(DSMEMTRACK).
    //

    pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

    //
    // Create the tracking info
    //

    pTracking->pszFile = pszFile;
    pTracking->nLine = nLine;
    pTracking->pszClass = pszClass;
    pTracking->cbSize = cbSize;
    pTracking->pvBaseAddress = pvBaseAddress;

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

    //
    // Add the allocation to the list
    //

    if(!g_lstMemoryTracking.Flink && !g_lstMemoryTracking.Blink)
    {
        InitializeListHead(&g_lstMemoryTracking);
    }
    
    InsertTailListUninit(&g_lstMemoryTracking, &pTracking->leListEntry);

    //
    // Fix up the base address
    //

    return pTracking + 1;
}

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  DirectSoundForgetAlloc
 *
 *  Description:
 *      Removes a tracked allocation from the list.
 *
 *  Arguments:
 *      LPVOID [in]: allocation base address.
 *      DSOUND_ALLOCATOR_TAG [in]: allocator tag.
 *
 *  Returns:  
 *      LPVOID: allocation base address.
 *
 ****************************************************************************/

#ifdef TRACK_MEMORY_USAGE

#undef DPF_FNAME
#define DPF_FNAME "ForgetAlloc"

LPVOID
XactForgetAlloc
(
    LPVOID                  pvBaseAddress,
)
{
    LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

    ASSERT(pvBaseAddress);

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

    //
    // Remove the allocation from the list
    //

    RemoveEntryList(&pTracking->leListEntry);

    //
    // Return the proper base address
    //

    return pTracking->pvBaseAddress;
}

#endif // TRACK_MEMORY_USAGE




/****************************************************************************
 *
 *  TrackMemFree
 *
 *  Description:
 *      Frees memory allocated with TrackMemAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#if defined(TRACK_MEMORY_USAGE)

#undef DPF_FNAME
#define DPF_FNAME "TrackMemFree"

void 
XactTrackMemFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = ForgetAlloc(pvBuffer);

    //
    // Free memory
    //

    MemFree(pvBuffer);
}

#endif // defined(TRACK_MEMORY_USAGE)


/****************************************************************************
 *
 *  DirectSoundDumpMemoryUsage
 *
 *  Description:
 *      Dumps current memory usage to the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert that there is no memory allocated.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DumpMemoryUsage"

void
DumpMemoryUsage
(
    BOOL                    fAssertNone
)
{

    using namespace XACT;
#ifdef DEBUG

    static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";

#ifdef TRACK_MEMORY_USAGE

    PLIST_ENTRY             pleEntry;
    LPDSMEMTRACK            pTracking;

#endif // TRACK_MEMORY_USAGE

    DwDbgSetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
    DwDbgPrint(pszBanner);
    DwDbgPrint("Begin memory usage dump");
    DwDbgPrint(pszBanner);
    
#ifdef TRACK_MEMORY_USAGE

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();
  
    //
    // Show specifically what allocations are remaining
    //
    
    if(g_lstMemoryTracking.Flink)
    {
        if(!IsListEmpty(&g_lstMemoryTracking))
        {
            for(pleEntry = g_lstMemoryTracking.Flink; pleEntry != &g_lstMemoryTracking; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
            
                pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

                DwDbgSetContext(DPF_FLAGS_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);
                DwDbgPrint("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);
            }

            DwDbgSetContext(DPF_FLAGS_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
            DwDbgPrint(pszBanner);
        }
    }

#endif // TRACK_MEMORY_USAGE


    DwDbgPrint(pszBanner);
    DwDbgPrint("End memory usage dump");
    DwDbgPrint(pszBanner);

#endif // DEBUG

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\debug.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.cpp
 *  Content:    Debugger helper object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/23/00    dereks  Created.
 *
 ***************************************************************************/

#include "common.h"

namespace XACT {

#ifdef USEDPF

//
// Globals
//

DWORD g_dwXactDebugLevel = DPFLVL_DEFAULT;
DWORD g_dwXactDebugBreakLevel = DPFLVL_DEFAULT_BREAK;

DPFCONTEXT g_XactDebugContext[HIGH_LEVEL + 1];
BOOL g_fXactDebugBreak = FALSE;



/***************************************************************************
 *
 *  dstrcpy
 *
 *  Description:
 *      Copies one string to another.
 *
 *  Arguments:
 *      LPSTR [in/out]: destination string.
 *      LPCSTR [in]: source string.
 *
 *  Returns:  
 *      LPSTR: pointer to the end of the string.
 *
 ***************************************************************************/

__inline LPSTR 
dstrcpy
(
    LPSTR                   dst, 
    LPCSTR                  src
)
{
    while(*dst = *src)
    {
        dst++;
        src++;
    }
    
    return dst;
}


/****************************************************************************
 *
 *  DwDbgPrintStaticV
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *      LPCSTR [in]: format string.
 *      va_list [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgPrintStaticV
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction, 
    LPCSTR                  pszLibrary,
    LPCSTR                  pszFormat,
    va_list                 va
)
{
    CHAR                    szDebug[0x400];
    CHAR                    szText[0x400];
    LPSTR                   pszWorking;
    DWORD                   dwWritten;

    if(dwLevel <= g_dwXactDebugLevel)
    {

#ifdef DEBUG

        pszWorking = szDebug;

        //
        // Add the library name
        //

        if((dwFlags & DPF_FLAGS_LIBRARY) && pszLibrary && *pszLibrary)
        {
            pszWorking += sprintf(pszWorking, "%s: ", pszLibrary);
        }

        //
        // Add the source file and line number
        //

        if((dwFlags & DPF_FLAGS_FILELINE) && pszFile && *pszFile)
        {
            pszWorking += sprintf(pszWorking, "%hs(%lu): ", pszFile, nLine);
        }

        //
        // Add the function name
        //

        if((dwFlags & DPF_FLAGS_FUNCTIONNAME) && pszFunction && *pszFunction)
        {
            pszWorking += sprintf(pszWorking, "%hs: ", pszFunction);
        }

        //
        // Add process and thread id
        //

        if(dwFlags & DPF_FLAGS_PROCESSTHREADID)
        {
            pszWorking += sprintf(pszWorking, "%.8lx: ", GetCurrentThreadId());
        }

        //
        // Add the type of message it is (i.e. error or warning)
        //

        switch(dwLevel)
        {
            case DPFLVL_ERROR:
                pszWorking = dstrcpy(pszWorking, "Error: ");
                break;

            case DPFLVL_RESOURCE:
                pszWorking = dstrcpy(pszWorking, "Resource failure: ");
                break;

            case DPFLVL_WARNING:
                pszWorking = dstrcpy(pszWorking, "Warning: ");
                break;
        }

#endif // DEBUG

        //
        // Add the debug string
        //

        vsprintf(szText, pszFormat, va);

#ifdef DEBUG
        
        pszWorking = dstrcpy(pszWorking, szText);

        //
        // Add a carriage-return since OutputDebugString doesn't
        //

        pszWorking = dstrcpy(pszWorking, "\n");

        //
        // Output to the debugger
        //

        OutputDebugStringA(szDebug);

        //
        // Break into the debugger
        //

        if(dwLevel && (dwLevel <= g_dwXactDebugBreakLevel))
        {
            DwDbgBreak();
        }

#endif // DEBUG

    }
}


/****************************************************************************
 *
 *  DwDbgPrintStatic
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *      LPCSTR [in]: format string.
 *      va_list [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgPrintStatic
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction, 
    LPCSTR                  pszLibrary,
    LPCSTR                  pszFormat,
    ...
)
{
    va_list                 va;

    va_start(va, pszFormat);
    DwDbgPrintStaticV(dwFlags, dwLevel, pszFile, nLine, pszFunction, pszLibrary, pszFormat, va);
    va_end(va);
}


/****************************************************************************
 *
 *  DwDbgSetContext
 *
 *  Description:
 *      Sets context for a DPF.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgSetContext
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction,
    LPCSTR                  pszLibrary
)
{

#ifdef _XBOX

    const KIRQL             irql    = KeGetCurrentIrql();

#else // _XBOX

    static const UINT       irql    = 0;

#endif // _XBOX

    g_XactDebugContext[irql].dwFlags = dwFlags;
    g_XactDebugContext[irql].dwLevel = dwLevel;
    g_XactDebugContext[irql].pszFile = pszFile;
    g_XactDebugContext[irql].nLine = nLine;
    g_XactDebugContext[irql].pszFunction = pszFunction;
    g_XactDebugContext[irql].pszLibrary = pszLibrary;
}


/****************************************************************************
 *
 *  DwDbgPrint
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      LPCSTR [in]: format string.
 *      ... [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgPrint
(
    LPCSTR                  pszFormat,
    ...
)
{

#ifdef _XBOX

    const KIRQL             irql    = KeGetCurrentIrql();

#else // _XBOX

    static const UINT       irql    = 0;

#endif // _XBOX

    va_list                 va;

    va_start(va, pszFormat);
    DwDbgPrintStaticV(g_XactDebugContext[irql].dwFlags, g_XactDebugContext[irql].dwLevel, g_XactDebugContext[irql].pszFile, g_XactDebugContext[irql].nLine, g_XactDebugContext[irql].pszFunction, g_XactDebugContext[irql].pszLibrary, pszFormat, va);
    va_end(va);
}


/****************************************************************************
 *
 *  DwDbgAssert
 *
 *  Description:
 *      Breaks into the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert.
 *      LPCSTR [in]: expression string.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line number called from.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgAssert
(
    BOOL                    fAssert,
    LPCSTR                  pszExpression,
    LPCSTR                  pszFile,
    UINT                    nLine
)
{
    static const LPCSTR     pszBanner           = "******************************************************************************";
    CHAR                    szMessage[0x400];
    LPSTR                   pszMessage;

    if(fAssert)
    {
        pszMessage = szMessage;

        pszMessage = dstrcpy(pszMessage, pszBanner);
        pszMessage = dstrcpy(pszMessage, "\n");
        pszMessage = dstrcpy(pszMessage, "Assertion failed in ");
        pszMessage = dstrcpy(pszMessage, pszFile);
        pszMessage = dstrcpy(pszMessage, ", line ");
    
        _itoa(nLine, pszMessage, 10);
        pszMessage += strlen(pszMessage);

        pszMessage = dstrcpy(pszMessage, ":\n");
        pszMessage = dstrcpy(pszMessage, pszExpression);
        pszMessage = dstrcpy(pszMessage, "\n");
        pszMessage = dstrcpy(pszMessage, pszBanner);
        pszMessage = dstrcpy(pszMessage, "\n");

        OutputDebugStringA(szMessage);
        DwDbgBreak();
    }
}


/****************************************************************************
 *
 *  DwDbgBreak
 *
 *  Description:
 *      Breaks into the debugger.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgBreak
(
    void
)
{
    //
    // Break in the debugger
    //
    
    __asm int 3;

#ifdef _XBOX

    //
    // If we're at DISPATCH_LEVEL or higher, the VC debugger won't catch
    // the break.
    //
    
    if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        g_fXactDebugBreak = TRUE;
    }

#endif // _XBOX

}


#endif // USEDPF


/****************************************************************************
 *
 *  DwDbgLog
 *
 *  Description:
 *      Adds an entry to the debug log.
 *
 *  Arguments:
 *      LPCSTR [in]: format string.
 *      ...
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef USEDEBUGLOG

CHAR g_aszDebugLog[DLOG_ENTRY_COUNT][DLOG_ENTRY_LENGTH] = { 0 };
DWORD g_dwXactDebugLogIndex = 0;

#undef DPF_FNAME
#define DPF_FNAME "DwDbgLog"

void __cdecl 
DwDbgLog
(
    LPCSTR                  pszFormat, 
    ...
)
{
    va_list                 va;
    int                     i;

    va_start(va, pszFormat);
    i = vsprintf(g_aszDebugLog[g_dwXactDebugLogIndex], pszFormat, va);
    va_end(va);
    
    for(i = i + 1; i < NUMELMS(g_aszDebugLog[g_dwXactDebugLogIndex]); i++)
    {
        g_aszDebugLog[g_dwXactDebugLogIndex][i] = 0;
    }

    g_dwXactDebugLogIndex = (g_dwXactDebugLogIndex + 1) % NUMELMS(g_aszDebugLog);
}

#endif // USEDEBUGLOG

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\macros.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       macros.h
 *  Content:    Misc. helper macros.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ***************************************************************************/

#ifndef __MACROS_H__
#define __MACROS_H__

#define DEFINEPTYPE(name) \
    typedef name *P##name

#define DEFINELPTYPE(name) \
    typedef name *LP##name

#define DEFINELPCTYPE(name) \
    typedef const name *LPC##name

#ifdef __cplusplus                  

#define DEFINEREFTYPE(name)  \
    typedef const name &REF##name

#else // __cplusplus                

#define DEFINEREFTYPE(name) \
    typedef const name *REF##name

#endif // __cplusplus               

#define DEFINETYPEFORMS(name) \
    DEFINEPTYPE(name); DEFINELPTYPE(name); DEFINELPCTYPE(name); DEFINEREFTYPE(name)

#define DEFINETYPE(name, type) \
    typedef type name; DEFINETYPEFORMS(name)
                                    
#define BEGIN_DEFINE_STRUCT() \
    typedef struct {

#define BEGIN_DEFINE_STRUCT_(name) \
    typedef struct name {

#define END_DEFINE_STRUCT(name) \
    } name; DEFINETYPEFORMS(name)

#define BEGIN_DEFINE_UNION() \
    typedef union {

#define BEGIN_DEFINE_UNION_(name) \
    typedef union name {

#define END_DEFINE_UNION(name) \
    } name; DEFINETYPEFORMS(name)

#define BEGIN_DEFINE_ENUM()  \
    typedef enum {

#define BEGIN_DEFINE_ENUM_(name) \
    typedef enum name {

#define END_DEFINE_ENUM(name) \
    } name; DEFINETYPEFORMS(name)

#define END_DEFINE_ENUM_() \
    }

#define DIVUP(a, b) \
    (((a) + ((b) - 1)) / (b))

#define BLOCKALIGN(a, b) \
    (((a) / (b)) * (b))

#define BLOCKALIGNPAD(a, b) \
    (DIVUP(a, b) * (b))

#define MAKEBOOL(a) \
    (!!(a))

#define NUMELMS(a) \
    (sizeof(a) / sizeof((a)[0]))

#define HRESULT_FROM_POINTER(p) \
    ((p) ? S_OK : E_OUTOFMEMORY)

#define HRFROMP(p) \
    HRESULT_FROM_POINTER(p)

#ifdef __cplusplus

#define IS_NULL_GUID(guid) \
    (!&(guid) || IsEqualGUID(guid, GUID_NULL))

#else // __cplusplus

#define IS_NULL_GUID(pguid) \
    (!(pguid) || IsEqualGUID(pguid, &GUID_NULL))

#endif // __cplusplus

#define IS_VALID_HANDLE_VALUE(h) \
    ((h) && (INVALID_HANDLE_VALUE != (h)))

#define CLOSE_HANDLE(h) \
    { \
        if(IS_VALID_HANDLE_VALUE(h)) \
        { \
            CloseHandle(h); \
            (h) = NULL; \
        } \
    }

#define INTERLOCKED_EXCHANGE(a, b) \
    InterlockedExchange((LPLONG)&(a), (LONG)(b))

#define INTERLOCKED_INCREMENT(a) \
    InterlockedIncrement((LPLONG)&(a))

#define INTERLOCKED_DECREMENT(a) \
    InterlockedDecrement((LPLONG)&(a))

#define CHECKRANGE(a, min, max) \
    { \
        if((a) < (min)) \
        { \
            (a) = (min); \
        } \
        else if((a) > (max)) \
        { \
            (a) = (max); \
        } \
    }

#ifdef DBG
#define ASSERT_IN_DPC ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL)
#define ASSERT_IN_PASSIVE ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL)
#else
#define ASSERT_IN_DPC ((void) 0)
#define ASSERT_IN_PASSIVE ((void) 0)
#endif

#endif // __MACROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\memmgr.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memmgr.h
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/21/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MEMMGR_H__
#define __MEMMGR_H__

#include "macros.h"

EXTERN_C LPVOID XactTrackMemAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, ULONG cbBuffer, BOOL fZeroInit);
EXTERN_C void XactTrackMemFree(LPVOID pvBuffer);

EXTERN_C LPVOID XactMemAlloc(ULONG cbBuffer, BOOL fZeroInit);
EXTERN_C void XactMemFree(LPVOID pvBuffer);


#endif // __MEMMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\ntlist.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ntlist.h
 *  Content:    Overrides of the standard NT list management macros.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __NTLIST_H__
#define __NTLIST_H__

#include "macros.h"

#ifndef InitializeListHead

#define InitializeListHead(ListHead) \
    ((ListHead)->Blink = (ListHead)->Flink = (ListHead))

#endif // InitializeListHead

#ifndef IsListEmpty

#define IsListEmpty(ListHead) \
    ((ListHead) == (ListHead)->Flink)

#endif // IsListEmpty

#ifndef IsEntryInList

#define IsEntryInList(Entry) \
    (!IsListEmpty(Entry))

#endif // IsEntryInList

//
// Determine if the entry is valid
//

BEGIN_DEFINE_ENUM()
    ASSERT_VALID_ONLY = 0,
    ASSERT_IN_LIST,
    ASSERT_NOT_IN_LIST,
END_DEFINE_ENUM(ASSERT_VALID_ENTRY_LIST);

#ifdef DEBUG

__inline void __AssertValidEntryList(PLIST_ENTRY Entry, ASSERT_VALID_ENTRY_LIST nFlags, LPCSTR pszFile, UINT nLine)
{
    if(!Entry)
    {
        DwDbgAssert(TRUE, "NULL list entry pointer", pszFile, nLine);
    }
    else if(!Entry->Flink || !Entry->Blink)
    {
        DwDbgAssert(TRUE, "List entry contains NULL pointer", pszFile, nLine);
    }
    else if((Entry == Entry->Flink) || (Entry == Entry->Blink))
    {
        if((Entry != Entry->Flink) || (Entry != Entry->Blink))
        {
            DwDbgAssert(TRUE, "List entry partially points to itself", pszFile, nLine);
        }
    }
    else if(ASSERT_IN_LIST == nFlags)
    {
        if(!IsEntryInList(Entry))
        {
            DwDbgAssert(TRUE, "List entry not in list", pszFile, nLine);
        }
    }
    else if(ASSERT_NOT_IN_LIST == nFlags)
    {
        if(IsEntryInList(Entry))
        {
            DwDbgAssert(TRUE, "List entry in list", pszFile, nLine);
        }
    }
}

#define AssertValidEntryList(Entry, nFlags) \
    __AssertValidEntryList(Entry, nFlags, __FILE__, __LINE__)

#else // DEBUG

#define AssertValidEntryList(Entry, nFlags)

#endif // DEBUG

//
// Add an entry to the end of a list or add a node at the position before
// the given node
//

/*
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
*/

#undef InsertTailList
__inline void InsertTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;
    
    Entry->Blink->Flink = Entry;
    Entry->Flink->Blink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}    

//
// Add an entry to the end of a list or add a node at the position before
// the given node (no valid node check)
//

__inline void InsertTailListUninit(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}    

//
// Add an entry to the head of a list or add a node at the position after
// the given node
//

/*
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
*/

#undef InsertHeadList
__inline void InsertHeadList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

    Entry->Flink = ListHead->Flink;
    Entry->Blink = ListHead;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}

//
// Add an entry to the head of a list or add a node at the position after
// the given node (no valid node check)
//

__inline void InsertHeadListUninit(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

    Entry->Flink = ListHead->Flink;
    Entry->Blink = ListHead;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}

//
// Remove an entry from a list
//

/*
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
*/

#undef RemoveEntryList
__inline PLIST_ENTRY RemoveEntryList(PLIST_ENTRY Entry)
{
    AssertValidEntryList(Entry, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_IN_LIST);

    Entry->Flink->Blink = Entry->Blink;
    Entry->Blink->Flink = Entry->Flink;
    Entry->Flink = Entry->Blink = Entry;

    return Entry;
}

/*
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
*/

#undef RemoveHeadList
#define RemoveHeadList(ListHead) \
    RemoveEntryList((ListHead)->Flink)

/*
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
*/

#undef RemoveTailList
#define RemoveTailList(ListHead) \
    RemoveEntryList((ListHead)->Blink)

//
// Move an entry from one list to the tail of another
//

__inline PLIST_ENTRY MoveEntryTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

    Entry->Flink->Blink = Entry->Blink;
    Entry->Blink->Flink = Entry->Flink;

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;

    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);

    return Entry;
}

__inline PLIST_ENTRY MoveHeadTailList(PLIST_ENTRY DestListHead, PLIST_ENTRY SourceListHead)
{
    PLIST_ENTRY             Entry;
    
    AssertValidEntryList(SourceListHead, ASSERT_VALID_ONLY);

    if((Entry = SourceListHead->Flink) != SourceListHead)
    {
        MoveEntryTailList(DestListHead, Entry);
    }
    
    return Entry;
}

#endif // __NTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\makefile.inc ===
DSP: dsstdfx.bin defaultscratchimg.bin

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

dsstdfx.bin defaultscratchimg.bin: dsp\ini\$*.ini
    set _XGPIMAGE_DSP_CODE_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\bin
    set _XGPIMAGE_INI_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\ini
    xgpimage $** $(_NT386TREE)\$*.bin $(SDK_INC_PATH)\$*.h
    copy $(SDK_INC_PATH)\$*.h $(XDK_INC_PATH)\$*.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\common.cpp ===
#include "..\common\common.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\common\refcount.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       refcount.h
 *  Content:    Basic reference-counting class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __REFCOUNT_H__
#define __REFCOUNT_H__

#ifdef __cplusplus

class CRefCount
{
protected:
    DWORD                   m_dwRefCount;

public:
    CRefCount(DWORD dwInitialRefCount = 1);
    virtual ~CRefCount(void);

public:
    virtual DWORD STDMETHODCALLTYPE AddRef(void);
    virtual DWORD STDMETHODCALLTYPE Release(void);
};

__inline CRefCount::CRefCount(DWORD dwInitialRefCount)
    : m_dwRefCount(dwInitialRefCount)
{
}

__inline CRefCount::~CRefCount(void)
{
    ASSERT(!m_dwRefCount);
}

__inline DWORD CRefCount::AddRef(void)
{
    ASSERT(m_dwRefCount < ~0UL);
    return ++m_dwRefCount;
}

__inline DWORD CRefCount::Release(void)
{
    ASSERT(m_dwRefCount);

    if(m_dwRefCount > 0)
    {
        if(!--m_dwRefCount)
        {
            delete this;
            return 0;
        }
    }

    return m_dwRefCount;
}

#endif // __cplusplus

#endif // __REFCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\cue.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.cpp
 *  Content:    XACT runtime voice object implementation
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/22/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"

using namespace XACT;

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::CSoundCue"


CSoundCue::CSoundCue
(
    void
)
{
    DPF_ENTER();

    m_dwCueIndex = -1;
    InitializeListHead(&m_SeqListEntry);
    InitializeListHead(&m_ListEntry);

    m_dwState = CUE_STATE_CREATED;

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::~CSoundCue"

CSoundCue::~CSoundCue
(
    void
)
{
    DPF_ENTER();
    PLIST_ENTRY pEntry;
    CSoundCue *pCue;

    ENTER_EXTERNAL_METHOD();    

    //
    // remove from sequencer list
    //
    
    if (!IsListEmpty(&m_SeqListEntry)){
        g_pEngine->RemoveCueFromSequencerList(this);
    }

    //
    // remove us from the soundbank linked list
    //
    
    m_pSoundBank->RemoveFromList(this);
   
    //
    // release any wavebank references
    //

    PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY pWaveBankEntry = GetWaveBankTable();

    if (m_paWaveBankEntries) {

        for (DWORD i=0;i<m_pSoundEntry->wWaveBankCount;i++) {
            
            CWaveBank *pWaveBank = (CWaveBank *)pWaveBankEntry[i].dwDataOffset;
            pWaveBank->RemoveCueFromList(&m_paWaveBankEntries[i]);
            pWaveBank->Release();
            
        }

        DELETE_A(m_paWaveBankEntries);

    }

    if (m_paTracks) {
        
        //
        // go thorugh each track and free the voices we had allocated
        //
        
        for (DWORD i=0;i<m_pSoundEntry->wTrackCount;i++) {
            
            g_pEngine->FreeEventsAtOrAfter(&m_paTracks[i],0);
            
            if (m_paTracks[i].pSoundSource) {
                m_paTracks[i].pSoundSource->Release();        
            }
                        
        }
        
        DELETE(m_paTracks);
        
    }

    ASSERT(m_pSoundBank);
    
    //
    // free destination voice
    //

    if (m_pControlSoundSource) {
        m_pControlSoundSource->Release();
    }

    DPF_LEAVE_VOID();
}

__inline ULONG CSoundCue::AddRef(void)
{
    ENTER_EXTERNAL_METHOD("CCueInstance::AddRef");
    return CRefCount::AddRef();
}


ULONG CSoundCue::Release(void)
{
    ENTER_EXTERNAL_METHOD("CCueInstance::Release");

    DWORD dwCount = CRefCount::Release();
    if ((dwCount == 1) && (m_dwFlags & XACT_FLAG_SOUNDCUE_AUTORELEASE)){

        //
        // if auto release is set and refcount is down to one
        // it means that we are no longer in the sequencer list
        // and we can free ourselves
        //

        dwCount = Release();

    }

    return dwCount;
}



#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::Initialize"

HRESULT CSoundCue::Initialize(CSoundBank *pSoundBank, DWORD dwCueIndex, CSoundSource *pSoundSource)
{
    HRESULT hr = S_OK;
    CWaveBank *pWaveBank;
    ENTER_EXTERNAL_METHOD();
    DPF_ENTER();

    ASSERT(pSoundBank);

    //
    // we dont dont ADDREF he soundbank since its valid for it to dissappear while Cues are active
    // it will delete all cues in thread safe manner when the soundbank is deleted
    //

    m_pSoundBank = pSoundBank;

    m_dwCueIndex = dwCueIndex;

    PXACT_SOUNDBANK_CUE_ENTRY pCueTable = pSoundBank->GetCueTable();
    PXACT_SOUNDBANK_SOUND_ENTRY pSoundTable = pSoundBank->GetSoundTable();

    m_pSoundEntry = &pSoundTable[pCueTable[dwCueIndex].dwSoundIndex];

    //
    // allocate a context entry for each wavebank we belong to
    // this entry alows each wavebank to track us independently of other wavebanks
    //

    hr = HRFROMP( m_paWaveBankEntries = NEW_A(WAVEBANK_CUE_CONTEXT,m_pSoundEntry->wWaveBankCount));

    if (SUCCEEDED(hr)) {

        //
        // we need to find the wavebank object for each wavebank referenced by this sound
        // this will allow track events to quickly get the wavebank 
        // they require
        //
        
        PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY pWaveBankEntry = GetWaveBankTable();
        for (DWORD i=0;i<m_pSoundEntry->wWaveBankCount;i++) {
            
            if (!pWaveBankEntry[i].dwDataOffset) {
                
                hr = g_pEngine->GetWaveBank(pWaveBankEntry[i].szFriendlyName,&pWaveBank);
                
                if (SUCCEEDED(hr)) {
                    
                    pWaveBankEntry[i].dwDataOffset = (DWORD) pWaveBank;
                    
                    //
                    // addref the wavebank so it does not magically go away from our
                    // under our nose
                    //
                    
                } else {
                    
                    DPF_ERROR("Wavebank (%s) not registered yet. Cue can not play",
                        pWaveBankEntry[i].szFriendlyName);
                    
                }
                
            }
            
            if (SUCCEEDED(hr)) {

                CWaveBank *pWaveBank = (CWaveBank *) pWaveBankEntry[i].dwDataOffset;
                pWaveBank->AddRef();

                m_paWaveBankEntries[i].pSoundCue = this;
                InitializeListHead(&m_paWaveBankEntries[i].ListEntry);

                pWaveBank->AddCueToList(&m_paWaveBankEntries[i]);

            }
            
        }
        
    }

    if (SUCCEEDED(hr)) {

        if (pSoundSource) {
            
            m_pControlSoundSource = pSoundSource->IsPositional() ? pSoundSource : NULL;            
            
            //
            // addref SoundSource. This should bring the current refcount to at least 3
            // one ref on creation from the engine, one when calling CreateSoundSource or 
            // CreateSoundSourceInternal and one from associating it with a Cue
            //
            
            pSoundSource->AddRef();            
            
        }
        
    }
        
    if (SUCCEEDED(hr)) {

        //
        // create an array of track contexts
        //
        
        hr = HRFROMP(m_paTracks = NEW_A(TRACK_CONTEXT,m_pSoundEntry->wTrackCount));
        
    }

    if (SUCCEEDED(hr)) {

        for (DWORD i=0;i<m_pSoundEntry->wTrackCount;i++)
        {
            InitializeListHead(&m_paTracks[i].lstEvents);
            m_paTracks[i].pSoundCue = this;
            m_paTracks[i].wSamplesPerSec = 48000;
            m_paTracks[i].pContentEntry = (PXACT_SOUNDBANK_TRACK_ENTRY)
                ((PUCHAR)m_pSoundBank->GetBaseDataOffset() + m_pSoundEntry->dwTrackTableOffset +
                sizeof(XACT_SOUNDBANK_TRACK_ENTRY)*i);

            if (i == 0 && pSoundSource && !pSoundSource->IsPositional()){

                //
                // a non 3d sound source is just used as track source, not submix
                // destination
                //

                m_paTracks[i].pSoundSource = pSoundSource;
            }

        }

    }

    if (SUCCEEDED(hr)) {

        m_dwState = CUE_STATE_INITIALIZED;

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::Play"

HRESULT CSoundCue::Play(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    ENTER_EXTERNAL_METHOD();
    DWORD dwOldState;

    DPF_ENTER();

    CheckStateTransition(CUE_STATE_PLAYING,&dwOldState);    
    ASSERT(dwOldState != CUE_STATE_PLAYING);
    
    //
    // if we are autorelease add flags to state
    //

    m_dwFlags = dwFlags;

    //
    // First time play
    // add ourselves to the core sequencer so our track events can start
    // getting processed
    //
    
    hr = g_pEngine->AddCueToSequencerList(this);

    //
    // start scheduling track events right away
    //

    if (SUCCEEDED(hr)) {

        hr = ScheduleTrackEvents(XACT_ENGINE_SCHEDULE_QUANTUM);

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;

}


#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::Stop"

HRESULT CSoundCue::Stop(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    ENTER_EXTERNAL_METHOD();
    PLIST_ENTRY pEntry;
    CSoundCue *pCue;

    DPF_ENTER();

    CheckStateTransition(CUE_STATE_STOPPING,NULL);    

    //
    // tell the hw voices associated with this cue to stop now
    // this way by the time dowork is called more time has elapsed
    //

    for (DWORD i=0;i<m_pSoundEntry->wTrackCount;i++) {
                        
        if (m_paTracks[i].pSoundSource) {            
            m_paTracks[i].pSoundSource->Stop();                        
        }
        
    }

    if (dwFlags & XACT_FLAG_SOUNDCUE_AUTORELEASE) {

        //
        // the caller indicated that it wants stop to release the cue when its done...
        //

        m_dwFlags |= XACT_FLAG_SOUNDCUE_AUTORELEASE;

    }

    if (dwFlags & XACT_FLAG_SOUNDCUE_SYNCHRONOUS) {

        //
        // do work will stop and release this cue
        //

        DoWork();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;

}

//
// private methods
//


//
// utility functions
//
#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::GetWaveBank()"

//
// this routine is called by the sequencer so track events
// can get scheduled for execution
//

VOID CSoundCue::GetWaveBank(DWORD dwWaveBankIndex, CWaveBank **ppWaveBank)
{
    DPF_ENTER();

    PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY pWaveBankEntry = GetWaveBankTable();
    pWaveBankEntry += dwWaveBankIndex;
    
    CWaveBank *pWaveBank = (CWaveBank*) pWaveBankEntry->dwDataOffset;
    *ppWaveBank = pWaveBank;
    
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::ScheduleEventsFromContent"

//
// this routine is called by the sequencer so track events from the content
// can get scheduled for execution
//

HRESULT CSoundCue::ScheduleTrackEvents(DWORD dwQuantum)
{
    HRESULT hr = S_OK;
    PTRACK_CONTEXT pTrack;
    PTRACK_EVENT_CONTEXT pEventContext;
    PXACT_TRACK_EVENT pEvent;
    
    REFERENCE_TIME rtTimeThreshold;
    
    ENTER_EXTERNAL_METHOD();
    
    DPF_ENTER();
    
    //
    // run through content for all tracks and submit events up to the time
    // of the current time + dwQuantum
    //
    
    for (DWORD i=0;i<m_pSoundEntry->wTrackCount;i++) {
        
        pTrack = &m_paTracks[i];
        ASSERT(pTrack->pContentEntry->wEventEntryCount >= pTrack->wNextEventIndex);
        
        KeQuerySystemTime((PLARGE_INTEGER)&rtTimeThreshold);
        
        rtTimeThreshold += dwQuantum;            
        
        //
        // this track might have already reached the end of its event table
        //
        
        if (pTrack->wNextEventIndex >= pTrack->pContentEntry->wEventEntryCount)
        {
            continue;
        }
        
        do {
            //
            // retrieve the next event we need to queue up
            // and create an event context for it
            //
            
            hr = HRFROMP(pEventContext = NEW(TRACK_EVENT_CONTEXT));
            
            if (SUCCEEDED(hr)) {
                
                InitializeListHead(&pEventContext->m_ListEntry);
                pEventContext->m_pTrack = pTrack;

                //
                // fine the event data in the content. We create the absolute data offset into the
                // soundbank by 
                // 1) getting the base soundbank data pointer +
                // 2) base data pointer for all events of this tracks
                // 3) data offset of this event form the start of the event data for the track
                //

                pEventContext->m_pEventHeader = (PXACT_TRACK_EVENT_HEADER) 
                    (m_pSoundBank->GetBaseDataOffset() + pTrack->pContentEntry->dwEventDataOffset +
                     pTrack->wNextEventDataOffset);
                
                pEvent = (PXACT_TRACK_EVENT) pEventContext->m_pEventHeader;
                
            }

            //
            // increment event pointers into the content
            //
            
            if (SUCCEEDED(hr)) {
                
                pTrack->wNextEventIndex++;
                pTrack->wNextEventDataOffset += sizeof(XACT_TRACK_EVENT_HEADER) + pEvent->Header.wSize;
                
            }

            //
            // process and submit event to sequencer
            //

            if (SUCCEEDED(hr)) {
                hr = SubmitEvent(pEventContext);
            }

            if (pTrack->wNextEventIndex >= pTrack->pContentEntry->wEventEntryCount)
            {
                break;
            }

            
        } while ((pEventContext->m_rtTimeStamp < rtTimeThreshold) && SUCCEEDED(hr));
        
    }
    
    DPF_LEAVE_HRESULT(hr);
    return hr;
    
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::ScheduleRuntimeEvent"

HRESULT CSoundCue::ScheduleRuntimeEvent(PXACT_TRACK_EVENT pEventDesc, DWORD dwTrackIndex)
{
    HRESULT hr = S_OK;
    DWORD dwStart, dwEnd;
    PTRACK_EVENT_CONTEXT pEventContext = NULL;
    PXACT_TRACK_EVENT pEvent = NULL;

    ENTER_EXTERNAL_METHOD();
    ASSERT_IN_PASSIVE;

    if (dwTrackIndex == XACT_TRACK_INDEX_UNUSED) {

        //
        // this events needs to be scheduled for all tracks
        //

        dwStart = 0; dwEnd = m_pSoundEntry->wTrackCount;

    } else {

        ASSERT(dwTrackIndex < m_pSoundEntry->wTrackCount);
        dwStart = dwTrackIndex;
        dwEnd = dwTrackIndex+1;

    }
    

    for (DWORD i=dwStart;i<dwEnd;i++) {
        
        //
        // create an event context for this event
        //
        
        hr = HRFROMP(pEventContext = NEW(TRACK_EVENT_CONTEXT));
        
        if (SUCCEEDED(hr)) {            
            hr = HRFROMP(pEvent = NEW(XACT_TRACK_EVENT));            
        } else {
            pEvent = NULL;
        }
        
        if (SUCCEEDED(hr)) {            

            //
            // copy user event desc
            //            

            memcpy(pEvent,pEventDesc,sizeof(XACT_TRACK_EVENT));            

            //
            // setup the event context
            //            

            pEventContext->m_pEventHeader = &pEvent->Header;
            pEventContext->m_pTrack = &m_paTracks[i];
            InitializeListHead(&pEventContext->m_ListEntry);

            //
            // the sample time has to be adjusted based on the real playback
            // frequency of the track. When the event was submitted 48k was assumed
            //

            FLOAT fTemp = (FLOAT) pEventContext->m_pEventHeader->lSampleTime;
            fTemp = fTemp * (48000/m_paTracks[i].wSamplesPerSec);
            pEventContext->m_pEventHeader->lSampleTime = (LONG) fTemp;

            //
            // flag this event as being external
            //

            pEvent->Header.dwFlags |= XACT_FLAG_EVENT_RUNTIME;

            //
            // submit event to sequencer
            //

            hr = SubmitEvent(pEventContext);
            
        } else {            

            if (pEvent)
                DELETE(pEvent);
            
            if (pEventContext)
                DELETE(pEventContext);

            break;
        }

    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::SubmitEvent"

HRESULT CSoundCue::SubmitEvent(PTRACK_EVENT_CONTEXT pEventContext)
{

    HRESULT hr = S_OK;
    PXACT_TRACK_EVENT pEvent = (PXACT_TRACK_EVENT) pEventContext->m_pEventHeader;
    PTRACK_CONTEXT pTrack = pEventContext->m_pTrack;

    LPDIRECTSOUNDBUFFER pDSBuffer;
    LPDIRECTSOUNDSTREAM pDSStream;
    BOOL bUpdateTrackTime = FALSE;

    ASSERT(pEvent);
    
    //
    // some events need special processing before they are added to the schedule
    //    

    switch (pEventContext->m_pEventHeader->wType) {
    case eXACTEvent_PlayWithPitchAndVolumeVariation:
    case eXACTEvent_Play:
        
        if (pEvent->Header.dwFlags & XACT_FLAG_EVENT_USES_FXIN) {                    
            //
            // TODO set the buffer to read from an FXIN
            //                                                            
        } else {
            
            WAVEBANKUNIWAVEFORMAT waveFormat;
            CWaveBank *pWaveBank;
            LPWAVEBANKENTRY pWaveBankEntry;
            
            GetWaveBank(pEvent->EventData.Play.PlayDesc.WaveSource.wBankIndex,&pWaveBank);
            
            //
            // get the actual wavebank entry describing the wave we want to play
            //
            
            pWaveBankEntry = pWaveBank->GetWaveBankEntry(                
                pEvent->EventData.Play.PlayDesc.WaveSource.wWaveIndex);
            
            //
            // if this track has no source voice allocated it for it, get one now
            //
            
            if (pTrack->pSoundSource == NULL) {
                
                hr = g_pEngine->CreateSoundSourceInternal(
                    XACT_FLAG_SOUNDSOURCE_2D,
                    pWaveBank,
                    &pTrack->pSoundSource);
                
                if (FAILED(hr)) {
                    
                    DPF_ERROR("Could not allocate voice for Play event");
                    return hr;
                }
                
            }
            
            pDSBuffer = pTrack->pSoundSource->GetDSoundBuffer();
            pDSStream = pTrack->pSoundSource->GetDSoundStream();
            
            //
            // set the proper format for the hw buffer/stream
            //
            
            if (pWaveBankEntry->Format.wFormatTag == WAVEBANKMINIFORMAT_TAG_PCM) {
                
                XAudioCreatePcmFormat(pWaveBankEntry->Format.nChannels,
                    pWaveBankEntry->Format.nSamplesPerSec,
                    (pWaveBankEntry->Format.wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_8 ) ? 8 : 16, 
                    &waveFormat.WaveFormatEx);
                
            } else {
                
                XAudioCreateAdpcmFormat(pWaveBankEntry->Format.nChannels,
                    pWaveBankEntry->Format.nSamplesPerSec,
                    &waveFormat.AdpcmWaveFormat);
                
            }
            
            //
            // keep track of what source freq the wave is so the 
            // sample time stamps in each event can be properly converted
            //
            
            pTrack->wSamplesPerSec = (WORD)waveFormat.WaveFormatEx.nSamplesPerSec;
            
            //
            // BUGBUG at this point we should morph a buffer into a stream, 
            // if the wavebank is streamed
            //
            
            if (pDSBuffer) {                    
                
                hr = pDSBuffer->SetFormat(&waveFormat.WaveFormatEx);
                
                //
                // the buffer size to span entire wavebank. a voice has already been associated with this wavebank
                // making this call very fast
                //
                
                if (SUCCEEDED(hr)){
                    
                    hr = pWaveBank->SetBufferData(pDSBuffer);
                    
                }
                
                if (SUCCEEDED(hr)){
                    
                    //
                    // set the correct play region for this wave and wavebank
                    //
                    
                    hr = pDSBuffer->SetPlayRegion(
                        pWaveBankEntry->PlayRegion.dwStart,
                        pWaveBankEntry->PlayRegion.dwLength);
                    
                }
                
                if (SUCCEEDED(hr)) {
                    
                    //
                    // set loop region
                    //
                    
                    hr = pDSBuffer->SetLoopRegion(
                        pWaveBankEntry->LoopRegion.dwStart,
                        pWaveBankEntry->LoopRegion.dwLength);
                    
                }
                
                if (SUCCEEDED(hr)) {
                    
                    //
                    // associate this source voice with a destination
                    //
                    
                    if (IsPositional() && m_pControlSoundSource){
                        hr = pDSBuffer->SetOutputBuffer(m_pControlSoundSource->GetDSoundBuffer());
                    }
                    
                }
                
            } else { // if DSBUffer
                
                //
                // Stream
                // Get some packets with disk data and submit them to the sound source
                // for streaming
                //
                
            }
            
        } // if FXSOURCE
         
        if (pTrack->wNextEventIndex == 0) {        

            //
            // this is the firt play event for this track.
            // record the start time
            //            

            bUpdateTrackTime = TRUE;
        }
        
        break;
         
    case eXACTEvent_Stop:
        
        //
        // stop does not need any additional processing
        //
        
        break;
      
    case eXACTEvent_LoopStart:
        
        //
        // loop is starting set the loop count,remember index to jump to
        // on loop end. Loops work like this:
        // When the loopStart event is encountered we setup the number of loop
        // we need to execute and the event index into the context we need to loop
        // BACK after the loop ends. that event is the LoopStart
        // event. When we encounter a loopEnd event, we jump back to the cached index.
        // and we actually skip the LoopStart event on any loop after the first one
        //
        
        ASSERT(pTrack->wLoopCount == 0);
        pTrack->wLoopCount = pEvent->EventData.LoopStart.wLoopCount;
        pTrack->wLoopStartEventIndex = pTrack->wNextEventIndex;
        pTrack->wLoopStartEventDataOffset = pTrack->wNextEventDataOffset;
            
        break;
        
    case eXACTEvent_LoopEnd:

        //
        // this event will never make it to the sequencer during looping
        // since it resets the current event index into the content back to the 
        // loop start ...
        //

        if (pTrack->wLoopCount) {
            
            //
            // make the track go back to the loop start index
            //
            
            pTrack->wNextEventIndex = pTrack->wLoopStartEventIndex;
            pTrack->wNextEventDataOffset = pTrack->wLoopStartEventDataOffset;
            
            //
            // decrement loop count
            //
            
            pTrack->wLoopCount--;

            //
            // each time we loop, we update the start time of our track
            // so the events are scheduled relative to the start of the loop
            //

            bUpdateTrackTime = TRUE;
            
        }

        break;

    default:
        
        break;
        
        
    } //switch

    if (bUpdateTrackTime) {

        g_pEngine->GetTime(&pTrack->rtStartTime);                    

    }

    //
    // create an absolute system reference time from event time stamp(in samples)
    //

    if (SUCCEEDED(hr)) {

        g_pEngine->CreateEventTimeStamp(pTrack,
            pEventContext);
        
        g_pEngine->PrintTimeStamps(DPF_FNAME,
            pEventContext,
            pEventContext->m_rtTimeStamp,
            0);
        
        //
        // add to list of events for this track
        //
        
        {
            AutoIrql();
            InsertTailList(&pTrack->lstEvents,&pEventContext->m_ListEntry);
        }
        
        //
        // enqueue this event
        //
        
        hr = g_pEngine->Enqueue(pEventContext);
        
    }

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::IsPositional"

__inline BOOL CSoundCue::IsPositional()
{
    DPF_ENTER();
    return (m_pSoundEntry->dwFlags & XACT_FLAG_SOUND_3D);
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::IsPlaying"

VOID CSoundCue::DoWork()
{
    DPF_ENTER();

    ENTER_EXTERNAL_METHOD();

    PTRACK_CONTEXT pTrack;
    DWORD dwStoppedTracks = 0;
    
    if ((m_dwState == CUE_STATE_STOPPED) || (m_dwState == CUE_STATE_INITIALIZED)) {
        return;
    }

    //
    // figure out if we are still playing
    //

    for (DWORD i=0;i<m_pSoundEntry->wTrackCount;i++) {
        
        pTrack = &m_paTracks[i];
        
        if (m_dwState == CUE_STATE_STOPPING) {
            
            //
            // stopped was called on the api
            // remove any events still scheduled
            // this essentialy forces a stop no matter what the tracks are doing
            //
                        
            if (pTrack->wNextEventIndex) {
                g_pEngine->FreeEventsAtOrAfter(pTrack,0);
            }
            
            //
            // set index to zero to signal the track is back to initial state
            //
            
            pTrack->wNextEventIndex = 0;
            
            dwStoppedTracks++;
            continue;
            
        }

        //
        // A track is considered playing if any of the following is true:
        // 1) it has a voice associted with it and the voice is playing
        // 2) its current event index < then the eventCount for the track
        //
                
        {
            AutoIrql();
            if (!IsListEmpty(&pTrack->lstEvents)) {
                
                //
                // still playing, there are queued events waiting to be dispatched, 
                //
                
                continue;
            }
        }
        
        if (pTrack->wNextEventIndex && 
            (pTrack->wNextEventIndex < pTrack->pContentEntry->wEventEntryCount)) {
            
            //
            // still playing, track was started and are events left to be scheduled
            //
            
            continue;
        }
        
        if (pTrack->pSoundSource) {
            
            if (pTrack->pSoundSource->IsPlaying()) {
                continue;
            }
        }
        
        //
        // if we made it here it means the track is stopped
        //
        
        dwStoppedTracks++;
        
    }

    if (dwStoppedTracks == m_pSoundEntry->wTrackCount) {

        XACT_TRACK_EVENT Event;

        //
        // all tracks are stopped, mark this voice as stopped
        //

        CheckStateTransition(CUE_STATE_STOPPED,NULL);
        
        memset(&Event,0,sizeof(Event));
        Event.Header.wType = eXACTEvent_Stop;
        
        //
        // call the cue in case we need to generate a notification
        // we pass in a stop event we just created here to signal the entire
        // cue has stopped playing
        //
        
        ProcessRuntimeEvent(&Event);

        //
        // cue is stopped, remove from active linked list
        //
        
        g_pEngine->RemoveCueFromSequencerList(this);
        
    } else {

        //
        // we are still playing, schedule some more events
        //

        ScheduleTrackEvents(XACT_ENGINE_SCHEDULE_QUANTUM);

    }

    return ;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::CheckStateTransition"

VOID CSoundCue::CheckStateTransition(DWORD dwNewState, PDWORD pdwOldState)
{
    AutoIrql();
    HRESULT hr = S_OK;
    DPF_ENTER();

    //
    // validate state transition depending on new state
    //

    switch (dwNewState) {
    case CUE_STATE_PLAYING:
        
        switch (m_dwState) {
        case CUE_STATE_STOPPED:
        case CUE_STATE_INITIALIZED:
            
            //
            // valid transition
            //
            
            DPF_INFO("Starting to play cue 0x%x",this);
            break;
        case CUE_STATE_CREATED:
            
            DPF_ERROR("Cue 0x%x not initialized yet!");
            break;
            
        case CUE_STATE_PLAYING:
                       
            DPF_INFO("Cue 0x%x Already Playing",this);           
            break;
            
        }
        
        break;
        
    case CUE_STATE_STOPPING:
            
        switch (m_dwState) {
        case CUE_STATE_PLAYING:
            
            //
            // valid transition
            //
            DPF_INFO("Stopping cue 0x%x",this);
            break;
            
        case CUE_STATE_INITIALIZED:
            
            DPF_WARNING("Cue 0x%x not playing yet",this);
            break;
            
        case CUE_STATE_CREATED:
            
            DPF_ERROR("Cue 0x%x not initialized yet!");
            break;
            
        case CUE_STATE_STOPPED:
            
            DPF_WARNING("Cue 0x%x Already stopped",this);
            break;
            
        }
        
        break;
        
    case CUE_STATE_STOPPED:
        
        switch (m_dwState) {
        case CUE_STATE_STOPPING:
            
            //
            // valid transition
            //
            
            DPF_INFO("Cue 0x%x is now stopped (was in Stopping state)",this);
            break;
            
        case CUE_STATE_INITIALIZED:
            
            DPF_WARNING("Cue 0x%x not playing yet",this);
            break;
            
        case CUE_STATE_CREATED:
            
            DPF_ERROR("Cue 0x%x not initialized yet!");
            break;
            
        case CUE_STATE_PLAYING:
            
            DPF_INFO("Cue 0x%x is now stopped (was in Playing state)",this);
            break;
            
        }
        
        break;        
        
    }

    if (pdwOldState) {
        *pdwOldState = m_dwState;
    }

    m_dwState = dwNewState;

}

#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::ProcessRuntimeEvent"

VOID CSoundCue::ProcessRuntimeEvent(XACT_TRACK_EVENT *pEventDesc)
{
    AutoIrql();

    BOOL bHandledLocally = TRUE;
    
    PNOTIFICATION_CONTEXT pContext;
    DWORD dwNotificationEvent = -1;

    //
    // generate notifications based on runtime events, if the user
    // has registered appropriately
    //

    switch (pEventDesc->Header.wType) {

    case eXACTEvent_PlayWithPitchAndVolumeVariation:
    case eXACTEvent_Play:
        
        dwNotificationEvent = eXACTNotification_Start;
        pContext = &m_aNotificationContexts[dwNotificationEvent];

        //
        // only the first play event of ANY track matters...
        // dont handle the notification for any subsequent plays
        //

        if (pContext->bRegistered && (pContext->PendingNotification.rtTimeStamp != 0))
        {

            bHandledLocally = FALSE;

        } else {

            //
            // call the soundbank in case it has some notifications registered for this
            //
            
            m_pSoundBank->ProcessRuntimeEvent(pEventDesc);
        }

        break;

    case eXACTEvent_Stop:

        //
        // Stop is a special case. This is not a stop that got dispatched from the
        // sequencer. Its instead a made-up stop called from when the Cue realizes all its
        // tracks have stopped playing
        //

        dwNotificationEvent = eXACTNotification_Stop;
        pContext = &m_aNotificationContexts[dwNotificationEvent];

        //
        // call the soundbank in case it has some notifications registered for this
        //

        m_pSoundBank->ProcessRuntimeEvent(pEventDesc);
        break;

    case eXACTEvent_Marker:
        dwNotificationEvent = eXACTNotification_Marker;
        pContext = &m_aNotificationContexts[dwNotificationEvent];

        //
        // copy data to cached context
        //

        memcpy(pContext->PendingNotification.Data.Marker.bData,
            pEventDesc->EventData.Marker.bData, XACT_SIZEOF_MARKER_DATA);

        break;
    }

    if (bHandledLocally) {

        g_pEngine->AddNotificationToPendingList(pContext);

    }            

}


#undef DPF_FNAME
#define DPF_FNAME "CSoundCue::GetNotificationContext"

PNOTIFICATION_CONTEXT CSoundCue::GetNotificationContext(DWORD dwType)
{

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();    
    return &m_aNotificationContexts[dwType];

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\soundbank.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       soundbank.cpp
 *  Content:    XACT runtime soundbank object implementation
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/22/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"

using namespace XACT;


#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::CSoundBank"


CSoundBank::CSoundBank
(
    void
)
{
    DPF_ENTER();

    InitializeListHead(&m_lstCues);
    InitializeListHead(&m_ListEntry);

    ASSERT(g_pEngine);
    g_pEngine->AddRef();

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::~CSoundBank"

CSoundBank::~CSoundBank
(
    void
)
{
    PLIST_ENTRY pEntry;
    CSoundCue *pCue;

    DPF_ENTER();

    ASSERT(g_pEngine);
    g_pEngine->Release();

    //
    // if we still have cues around, delete them here
    //

    pEntry = m_lstCues.Flink;
    while (pEntry != &m_lstCues) 
    {
        pCue = CONTAINING_RECORD(pEntry,CSoundCue,m_ListEntry);        
        pEntry = pEntry->Flink;        
        
        pCue->Stop(XACT_FLAG_SOUNDCUE_SYNCHRONOUS);
        
    }

    //
    // remove any registered cue notifications
    //

    PCUE_INDEX_NOTIFICATION_CONTEXT pCueContext;
    PNOTIFICATION_CONTEXT pContext;
    
    for (DWORD i=0;i<eXACTNotification_Max;i++) {
        
        pContext = GetNotificationContext(i);

        for (DWORD j = 0; j < m_pFileHeader->dwCueEntryCount; j++) {
            
            pCueContext = g_pEngine->GetCueNotificationContext(pContext,j);
            if (pCueContext) {
                DELETE(pCueContext);
            }

        }

    }

    DPF_LEAVE_VOID();
}

__inline ULONG CSoundBank::AddRef(void)
{
    _ENTER_EXTERNAL_METHOD("CSoundBank::AddRef");    
    return CRefCount::AddRef();
}


__inline ULONG CSoundBank::Release(void)
{
    _ENTER_EXTERNAL_METHOD("CSoundBank::Release");
    return CRefCount::Release();
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::Initialize"

HRESULT CSoundBank::Initialize(PVOID pvBuffer, DWORD dwSize)
{
    HRESULT hr = S_OK;

    DPF_ENTER();

    m_pDataBuffer = pvBuffer;
    m_dwDataSize = dwSize;

    m_pFileHeader = (PXACT_SOUNDBANK_FILE_HEADER)m_pDataBuffer;

#ifdef VALIDATE_PARAMETERS
    if (!IsValidHeader()) {
        DPF_ERROR("Invalid Soundbank header (0x%x)",pvBuffer);
    }
#endif

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::GetSoundCueIndexFromFriendlyName"

HRESULT CSoundBank::GetSoundCueIndexFromFriendlyName(LPCSTR lpFriendlyName, PDWORD pdwCueIndex)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!lpFriendlyName)
    {
        DPF_ERROR("No lpFriendlyName specified");
    }

    if(!pdwCueIndex)
    {
        DPF_ERROR("No pdwCueIndex supplied");
    }

#endif // VALIDATE_PARAMETERS

    //
    // search for matching friendly name among cues
    // this is not done super efficiently since we dont expect this function
    // to be used on retail builds
    // caller should use hardcoded CUE index 
    //

    *pdwCueIndex = -1;

    for (DWORD i= 0;i < m_pFileHeader->dwCueEntryCount; i++) 
    {

        if (!strncmp(lpFriendlyName,
            GetCueFriendlyName(i),
            XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH)) {

            *pdwCueIndex = i;
            break;
        }

    }

    if (*pdwCueIndex == -1) {
        DPF_WARNING("Cue friendly name %s not found in cue table for soundbank 0x%x",lpFriendlyName,this);
        hr = E_FAIL;
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::Play"

HRESULT CSoundBank::Play( DWORD dwCueIndex, PXACTSOUNDSOURCE pSoundSourceObject,DWORD dwFlags, PXACTSOUNDCUE *ppCue)
{
    HRESULT hr = S_OK;
    CSoundSource *pSoundSource = (CSoundSource *) pSoundSourceObject;
    CSoundCue *pCue = NULL, *pNewCue = NULL;

    PXACT_SOUNDBANK_CUE_ENTRY pCueTable = GetCueTable();
    PXACT_SOUNDBANK_SOUND_ENTRY pSoundTable = GetSoundTable();


    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!IsValidCue(dwCueIndex))
    {
        DPF_ERROR("Cue index is not valid for this soundbank");
    }


    if(pSoundSource && 
        !IsValidSoundSourceForSound(pSoundSource->GetFlags(),
        pSoundTable[pCueTable[dwCueIndex].dwSoundIndex].dwFlags))
    {
        DPF_ERROR("SoundSource type (0x%x) does not match sound (0x%x) type 0x%x",
                  pSoundSource->GetFlags(),
                  pCueTable[dwCueIndex].dwSoundIndex,
                  pSoundTable[pCueTable[dwCueIndex].dwSoundIndex].dwFlags);

    }

    if (!ppCue && !(dwFlags & XACT_FLAG_SOUNDCUE_AUTORELEASE)) {

        DPF_ERROR("XACT_FLAG_SOUNDCUE_AUTORELEASE must be set if ppCue == NULL");

    }

    if (ppCue && (dwFlags & XACT_FLAG_SOUNDCUE_AUTORELEASE)) {

        DPF_ERROR("No need to supply ppCue if XACT_FLAG_SOUNDCUE_AUTORELEASE is set");

    }

#endif // VALIDATE_PARAMETERS

    //
    // search for any other cues associated with the supplied sound source
    //
    
    
    PLIST_ENTRY pEntry = m_lstCues.Flink;
    while (pEntry != &m_lstCues) 
    {
        pCue = CONTAINING_RECORD(pEntry,CSoundCue,m_ListEntry);
        pEntry = pEntry->Flink;        
        
        //
        // if another cue of the same layer is playing and a source was supplied
        // enforce the layering behavior
        // if now SoundSource was supplied but another cue of the same layer is playing
        
        if (pCue->m_pSoundEntry->wLayer == pSoundTable[pCueTable[dwCueIndex].dwSoundIndex].wLayer)
        {
      
            if (pSoundSource == pCue->m_pControlSoundSource) {
                
                //
                // the cues have the same layer and same voice which means the existing cue
                // must be stopped.
                //
                
                hr = pCue->Stop(XACT_FLAG_SOUNDCUE_SYNCHRONOUS);
                if (FAILED(hr)){
                    break;
                }
                
                //
                // after calling stop on a cue you CANT assume its still allocated
                //

            }                        
            
        }                
        
    }
    
    if (SUCCEEDED(hr) && !pNewCue)
    {
        //
        // create a Cue instance
        //
        
        hr = HRFROMP(pNewCue = NEW(CSoundCue));
        
        if(SUCCEEDED(hr))
        {
            hr = pNewCue->Initialize(this, dwCueIndex, pSoundSource);
        }
        
        if (FAILED(hr))
        {
            pNewCue->Release();
            pNewCue = NULL;
        }
        
        if(SUCCEEDED(hr))
        {        

            //
            // add cue to our list
            //
            
            InsertTailList(&m_lstCues,&pNewCue->m_ListEntry);
            
        }
        
        if (SUCCEEDED(hr) && pSoundSource && pSoundSource->IsPositional()) {
            
            //
            // set the 3d properties associated with the sound, on the destination voice
            //
            
            PXACT_SOUNDBANK_SOUND_ENTRY pSoundEntry = &pSoundTable[pCueTable[dwCueIndex].dwSoundIndex];            
            
            if (pSoundEntry->dw3DParametersOffset != -1) {
                
                PXACT_SOUNDBANK_SOUND_3D_PARAMETERS pParams = (PXACT_SOUNDBANK_SOUND_3D_PARAMETERS)
                    ((PUCHAR)m_pDataBuffer + pSoundEntry->dw3DParametersOffset);
                
                DS3DBUFFER ds3db;
                ZeroMemory(&ds3db,sizeof(DS3DBUFFER));
                
                ds3db.dwSize = sizeof(DS3DBUFFER);
                ds3db.dwInsideConeAngle = pParams->dwInsideConeAngle;
                ds3db.dwOutsideConeAngle = pParams->dwOutsideConeAngle;
                ds3db.flMaxDistance = pParams->flMaxDistance;
                ds3db.flMinDistance = pParams->flMinDistance;
                ds3db.dwMode = pParams->dwMode;
                ds3db.lConeOutsideVolume = pParams->lConeOutsideVolume;
                ds3db.flDistanceFactor = pParams->flDistanceFactor;
                ds3db.flDopplerFactor = pParams->flDopplerFactor;
                ds3db.flRolloffFactor = pParams->flRolloffFactor;
                ds3db.vConeOrientation.x = 1;
                
                hr = pSoundSource->m_HwVoice.pBuffer->SetAllParameters(&ds3db,DS3D_DEFERRED);
                
            }
            
        }

    } //if pNewCue

    if (SUCCEEDED(hr)) {

        if (ppCue) {

            *ppCue = (PXACTSOUNDCUE) pNewCue;

            //
            // handle registration for notifications associated with a CueIndex
            // Since the caller cant register a notification for a cue before it starts playing
            // it instead registers one on the soundbank, for a specific cue index.
            // then when the time comes to play the cue, we register the notification on the specific cue
            //

            PCUE_INDEX_NOTIFICATION_CONTEXT pCueContext;
            PNOTIFICATION_CONTEXT pContext;

            for (DWORD i=0;i<eXACTNotification_Max;i++) {

                pContext = GetNotificationContext(i);

                pCueContext = g_pEngine->GetCueNotificationContext(pContext,dwCueIndex);
                if (pContext->bRegistered && pCueContext) {

                    XACT_NOTIFICATION_DESCRIPTION Desc;

                    memcpy(&Desc,
                        &pContext->PendingNotification.Header,
                        sizeof(Desc));

                    Desc.pSoundCue = (PXACTSOUNDCUE) pNewCue;
                    Desc.pSoundBank = NULL;
                    Desc.dwSoundCueIndex = XACT_SOUNDCUE_INDEX_UNUSED;

                    //
                    // register for this type of notification, on the cue
                    //

                    g_pEngine->HandleNotificationRegistration(&Desc,TRUE);

                }

            }

        }

    }

    if (SUCCEEDED(hr)) {

        //
        // play the cue
        //
        
        hr = pNewCue->Play(dwFlags);
        
    }


    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::Play"

HRESULT CSoundBank::Stop( DWORD dwCueIndex, DWORD dwFlags, PXACTSOUNDCUE pCueObject)
{
    HRESULT hr = S_OK;
    CSoundCue *pCue = (CSoundCue *) pCueObject;
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((dwCueIndex != XACT_SOUNDCUE_INDEX_UNUSED) && !IsValidCue(dwCueIndex))
    {
        DPF_ERROR("Cue index is not valid for this soundbank");
    }

    if((dwCueIndex == XACT_SOUNDCUE_INDEX_UNUSED) && (pCueObject != NULL))
    {
        DPF_ERROR("You cant supply a valid cue instance with an unspecified cue index");
    }

    if((dwCueIndex != XACT_SOUNDCUE_INDEX_UNUSED) && (pCueObject != NULL))
    {
        DPF_ERROR("You cant supply both a valid cue instance AND a valid cue index");
    }

    if (dwFlags & XACT_FLAG_SOUNDCUE_AUTORELEASE) {
        DPF_ERROR("XACT_FLAG_SOUNDCUE_AUTORELEASE is not valid for this API");
    }

#endif

    //
    // instead of calling release after calling stop, instruct the cue to free itself
    // this solves the issue of a cue already being autorelease, us calling stop, cue
    // freeing itself then us try to release again
    //

    dwFlags |= XACT_FLAG_SOUNDCUE_AUTORELEASE; 

    if (pCue == NULL) {

        PLIST_ENTRY pEntry = m_lstCues.Flink;
        while (pEntry != &m_lstCues) 
        {
            pCue = CONTAINING_RECORD(pEntry,CSoundCue,m_ListEntry);
            pEntry = pEntry->Flink;        

            //
            // if the voice has already been associated with another cue, check the layer
            // of the current cue with the layer of the already associated cue
            //
            
            if ((pCue->m_dwCueIndex == dwCueIndex) ||
                (dwCueIndex == XACT_SOUNDCUE_INDEX_UNUSED))
            {                
                hr = pCue->Stop(dwFlags);
            }                        
            
        }

    } else {

        hr = pCue->Stop(dwFlags);

    }
    
            
    DPF_LEAVE_HRESULT(hr);
    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::GetNotificationContext"

PNOTIFICATION_CONTEXT CSoundBank::GetNotificationContext(DWORD dwType)
{

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();    
    return &m_aNotificationContexts[dwType];

}
 

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::ProcessRuntimeEvent"

VOID CSoundBank::ProcessRuntimeEvent(XACT_TRACK_EVENT *pEventDesc)
{
    DWORD dwNotificationEvent;
    BOOL bHandledLocally = FALSE;
    PNOTIFICATION_CONTEXT pContext = NULL;

    AutoIrql();
    switch (pEventDesc->Header.wType) {

    case eXACTEvent_PlayWithPitchAndVolumeVariation:
    case eXACTEvent_Play:

        dwNotificationEvent = eXACTNotification_Start;
        pContext = &m_aNotificationContexts[dwNotificationEvent];

        //
        // increment playing count
        //

        m_dwPlayingCount++;

        if (m_dwPlayingCount == 1) {

            //
            // when the very first cue starts playing for the first time
            // signal a notification that the soundbank has started playing
            //

            bHandledLocally = TRUE;
        }    

        break;

    case eXACTEvent_Stop:

        dwNotificationEvent = eXACTNotification_Stop;
        pContext = &m_aNotificationContexts[dwNotificationEvent];

        if(m_dwPlayingCount) {
            m_dwPlayingCount--;
        } else {
            DPF_INFO("(0x%x)Got stop event without ever getting play event",this);
        }
       
        if (m_dwPlayingCount == 0) {

            //
            // when all cues have stopped playing
            // signal a notification
            //

            bHandledLocally = TRUE;
        }

        break;
    }

    ASSERT(pContext);

    if (bHandledLocally) {

        //
        // the following routine will only add a notification if it has been registered
        //

        g_pEngine->AddNotificationToPendingList(pContext);

    }            

}

#undef DPF_FNAME
#define DPF_FNAME "CSoundBank::RemoveFromList"

void CSoundBank::RemoveFromList(CSoundCue *pCue)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    
    RemoveEntryList(&pCue->m_ListEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\engine.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       engine.cpp
 *  Content:    XACT runtime Engine implementation
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/22/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"


#undef DPF_FNAME
#define DPF_FNAME "XACTEngineCreateI"


EXTERN_C    XACT::CEngine* XACT::g_pEngine = NULL;

VOID
XACTEngineDoWork()
{
    using namespace XACT;

    ENTER_EXTERNAL_FUNCTION();
    CEngine*  pEngine = g_pEngine;

    if(!pEngine)
        return;

    DirectSoundDoWork();
    pEngine->DoWork();

    return;
}



HRESULT
XACTEngineCreate
(
    PXACTENGINE *ppEngine,PXACT_RUNTIME_PARAMETERS pParams
)
{
    using namespace XACT;
    CEngine*  pEngine;
    HRESULT   hr = S_OK;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!ppEngine)
    {
        DPF_ERROR("Failed to supply an PXACTENGINE *");
    }

    if(!pParams)
    {
        DPF_ERROR("Failed to supply PXACT_RUNTIME_PARAMETERS");
    }

    if (!pParams->dwMax2DHwVoices)
    {

        DPF_ERROR("dwMax2dVoices must be at least max(1,number of wavebanks registered at any time)");

    }

#endif // VALIDATE_PARAMETERS
    
    DPF_ENTER();

    //
    // Check to see if the engine object exists
    //

    if(g_pEngine)
    {
        *ppEngine = g_pEngine;
        g_pEngine->AddRef();
    }
    else
    {
        hr = HRFROMP(pEngine = NEW(CEngine));

        if(SUCCEEDED(hr))
        {
            hr = pEngine->Initialize(pParams);
        }

        if(SUCCEEDED(hr))
        {
            *ppEngine = pEngine;
        }
        else
        {
            pEngine->Release();
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


using namespace XACT;


#undef DPF_FNAME
#define DPF_FNAME "CEngine::CEngine"


CEngine::CEngine
(
    void
)
{
    DPF_ENTER();

    m_dwRefCount = 1;

    //
    // Set global engine object pointer
    //

    g_pEngine = this;
    InitializeListHead(&m_lstAvailable2DBuffers);
    InitializeListHead(&m_lstAvailableStreams);
    InitializeListHead(&m_lstAvailable3DBuffers);
    InitializeListHead(&m_lstWaveBanks);
    InitializeListHead(&m_lstSoundBanks);
    InitializeListHead(&m_lstPendingNotifications);

    //
    // sequencer variables
    //

    InitializeListHead(&m_lstActiveCues);
    KeInitializeTimer(&m_TimerObject);
    KeInitializeDpc(&m_DpcObject, DPCTimerCallBack, this);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::~CEngine"

CEngine::~CEngine
(
    void
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    PLIST_ENTRY pEntry;
    CSoundSource *pSoundSource;

    //
    // sequencer de-init
    //

    {
        AutoIrql();
        m_bAllowQueueing = FALSE;
    }

    if(m_bTimerSet){
        KeCancelTimer(&m_TimerObject);
    }

    ASSERT(m_pQueue);
    FreeAllEvents(); // From queue

    ASSERT(IsListEmpty(&m_lstActiveCues));

    DELETE(m_pQueue);

    //
    // free 2d buffers
    //

    pEntry = m_lstAvailable2DBuffers.Flink;
    while (pEntry != &m_lstAvailable2DBuffers) {

        pEntry = RemoveHeadList(&m_lstAvailable2DBuffers);
        pSoundSource = CONTAINING_RECORD(pEntry, CSoundSource, m_ListEntry);

        pSoundSource->Release();

        pEntry = m_lstAvailable2DBuffers.Flink;

    }

    //
    // free 3d buffers
    //

    pEntry = m_lstAvailable3DBuffers.Flink;
    while (pEntry != &m_lstAvailable3DBuffers) {

        pEntry = RemoveHeadList(&m_lstAvailable3DBuffers);
        pSoundSource = CONTAINING_RECORD(pEntry, CSoundSource, m_ListEntry);

        pSoundSource->Release();

        pEntry = m_lstAvailable3DBuffers.Flink;

    }

    //
    // free streams
    //

    pEntry = m_lstAvailableStreams.Flink;
    while (pEntry != &m_lstAvailableStreams) {

        pEntry = RemoveHeadList(&m_lstAvailableStreams);
        pSoundSource = CONTAINING_RECORD(pEntry, CSoundSource, m_ListEntry);

        pSoundSource->Release();

        pEntry = m_lstAvailableStreams.Flink;

    }

    if (m_pDirectSound) {
        m_pDirectSound->Release();
    }

    g_pEngine = NULL;
    DPF_INFO("XACT Engine shutdown completely");

    DPF_LEAVE_VOID();
}

__inline ULONG CEngine::AddRef(void)
{
    _ENTER_EXTERNAL_METHOD("CEngine::AddRef");
    return ++m_dwRefCount;
}

ULONG CEngine::Release(void)
{
    _ENTER_EXTERNAL_METHOD("CEngine::Release");
    
    ASSERT(m_dwRefCount);
    m_dwRefCount--;

    if (m_dwRefCount == m_dwTotalVoiceCount){

        //
        // if the refcount equals the number of pre-allocated voices
        // it means its time to delete the engine object
        //

        delete this;
    }

    return m_dwRefCount;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::Initialize"

HRESULT CEngine::Initialize(PXACT_RUNTIME_PARAMETERS pParams)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    CSoundSource *pSoundSource;
    ENTER_EXTERNAL_METHOD();

    DSBUFFERDESC dsbd;
    DSSTREAMDESC dssd;
    WAVEFORMATEX wfx;

    DPF_ENTER();

    if (SUCCEEDED(hr)) {
        CopyMemory(&m_RuntimeParams, pParams, sizeof(XACT_RUNTIME_PARAMETERS));
        ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
        ZeroMemory( &dssd, sizeof( DSSTREAMDESC ) );
        
        hr = DirectSoundCreate(NULL,&m_pDirectSound, NULL);
    }

    if (SUCCEEDED(hr)) {
        hr = InitializeSequencer(XACT_ENGINE_MAX_CONCURRENT_EVENTS);
    }

    //
    // based on the caller supplied parameters, pre-allocate all dsound buffers and streams
    // we are about to use
    //

    if (SUCCEEDED(hr)) {

        //
        // allocate 2d buffers first
        //
        
        dsbd.dwSize = sizeof( DSBUFFERDESC );
        XAudioCreatePcmFormat(1, 8000, 8, &wfx);
        dsbd.lpwfxFormat = &wfx;
        dssd.lpwfxFormat = &wfx;
        dssd.dwMaxAttachedPackets = XACT_ENGINE_PACKETS_PER_STREAM;

        for (i=0;i<pParams->dwMax2DHwVoices-pParams->dwMaxConcurrentStreams;i++) {
    
            //
            // create the context used to track DS buffers/streams
            //
    
            hr = AllocateSoundSource(&pSoundSource);
    
            if(SUCCEEDED(hr)) {

                m_dwTotalVoiceCount++;

                //
                // add voice to linked list
                //
    
                InsertTailList(&m_lstAvailable2DBuffers,&pSoundSource->m_ListEntry);
    
                //
                // create buffer
                //
        
                hr = m_pDirectSound->CreateSoundBuffer( &dsbd, &pSoundSource->m_HwVoice.pBuffer, NULL );
    
                //
                // tell the voice the dsound flags used
                //
    
                pSoundSource->SetHwVoiceType(0);
    
            } else {

                break;

            }
    
        }

    }

    //
    // create all 3d submix voices
    //

    if (SUCCEEDED(hr)) {

        for (i=0;i<pParams->dwMax3DHwVoices;i++) {
    
            //
            // create the context used to track DS buffers/streams
            //
    
            hr = AllocateSoundSource(&pSoundSource);
    
            if(SUCCEEDED(hr)) {
    
                m_dwTotalVoiceCount++;

                //
                // add voice to linked list
                //
    
                InsertTailList(&m_lstAvailable3DBuffers,&pSoundSource->m_ListEntry);
    
                //
                // create buffer
                //
    
                dsbd.lpwfxFormat = NULL;
                dsbd.dwFlags = DSBCAPS_MIXIN | DSBCAPS_CTRL3D;
        
                hr = m_pDirectSound->CreateSoundBuffer( &dsbd, &pSoundSource->m_HwVoice.pBuffer, NULL );
    
                //
                // tell the voice what hw voice its associated with
                //
    
                pSoundSource->SetHwVoiceType(dsbd.dwFlags);        
    
            } else {
    
                break;
    
            }

        }

    }

    //
    // allocate streams
    //

    if (SUCCEEDED(hr)) {

        for (i=0;i<pParams->dwMaxConcurrentStreams;i++) {
    
            //
            // create the context used to track DS buffers/streams
            //
    
            hr = AllocateSoundSource(&pSoundSource);
    
            if(SUCCEEDED(hr)) {

                m_dwTotalVoiceCount++;

                //
                // add voice to linked list
                //
    
                InsertTailList(&m_lstAvailableStreams,&pSoundSource->m_ListEntry);
    
                //
                // create dsound stream
                //
        
                hr = m_pDirectSound->CreateSoundStream( &dssd, &pSoundSource->m_HwVoice.pStream, NULL);
    
                //
                // tell the voice what hw voice its associated with
                //
    
                pSoundSource->SetHwVoiceType(dssd.dwFlags);        
    
            } else {
    
                break;
    
            }

        }

    }    

    if (SUCCEEDED(hr)) {

        ASSERT(m_dwRefCount == 
            (pParams->dwMax3DHwVoices +\
             pParams->dwMax2DHwVoices)+1);

    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::AllocateSoundSource"

HRESULT CEngine::AllocateSoundSource(CSoundSource **ppSoundSource)
{
    CSoundSource *pSoundSource;
    HRESULT hr = HRFROMP(pSoundSource = NEW(CSoundSource));

    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();
    
    ASSERT(ppSoundSource);

    if(SUCCEEDED(hr)) {

        hr = pSoundSource->Initialize();
        *ppSoundSource = pSoundSource;

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::FreeSoundSource"

void CEngine::FreeSoundSource(CSoundSource *pSoundSource)
{

    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();

    ASSERT(pSoundSource);

    //
    // add the voice in the proper available list.
    //

    ASSERT(pSoundSource->m_dwRefCount == 1);

    if (pSoundSource->IsPositional()) {
        InsertTailList(&m_lstAvailable3DBuffers, &pSoundSource->m_ListEntry);
    } else {

        if (pSoundSource->m_HwVoice.pBuffer) {
            InsertTailList(&m_lstAvailable2DBuffers, &pSoundSource->m_ListEntry);
        }
        
        if (pSoundSource->m_HwVoice.pStream) {
            InsertTailList(&m_lstAvailableStreams, &pSoundSource->m_ListEntry);
        }

    }

}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::DoWork"

VOID CEngine::DoWork()
{
    ENTER_EXTERNAL_METHOD();
    PLIST_ENTRY pEntry;
    CSoundCue *pCue;

    //
    // re-sync offset between cpu clock with apu sample clock
    //
    
    SetTimeOffset();
    
    //
    // tell all active cues to get busy
    //
    
    pEntry = m_lstActiveCues.Flink;
    while (pEntry != &m_lstActiveCues)
    {
        pCue = CONTAINING_RECORD(pEntry, CSoundCue, m_SeqListEntry);
        pEntry = pEntry->Flink;
        
        pCue->DoWork();        
    }
    


}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::GetWaveBank"

HRESULT CEngine::GetWaveBank(LPCSTR lpFriendlyName, CWaveBank **ppWaveBank)
{
    PLIST_ENTRY pEntry;
    CWaveBank *pWaveBank;
    HRESULT hr = E_FAIL;

    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();

    *ppWaveBank = NULL;

    //
    // search wavebank list using wavebank friendly name
    //

    ASSERT(lpFriendlyName);

    if (IsListEmpty(&m_lstWaveBanks)) {
        DPF_WARNING("No wavebanks registered");
        return E_FAIL;
    }

    pEntry = m_lstWaveBanks.Flink;
    while (pEntry != &m_lstWaveBanks) {

        pWaveBank = CONTAINING_RECORD(pEntry, CWaveBank, m_ListEntry);

        if (!strncmp(pWaveBank->m_WaveBankData.pHeader->szBankName,
            lpFriendlyName,
            XACT_SOUNDBANK_WAVEBANK_FRIENDLYNAME_LENGTH)) {

            //
            // found the correct wavebank
            //

            *ppWaveBank = pWaveBank;
            hr = S_OK;

        }

        pEntry = pEntry->Flink;

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;

}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::AddNotificationToPendingList"

VOID CEngine::AddNotificationToPendingList(NOTIFICATION_CONTEXT *pContext)
{

    if (pContext->bRegistered) {
        
        {
            AutoIrql();
            
            InsertTailList(&m_lstPendingNotifications,
                &pContext->ListEntry);
        }
                
        //
        // updated timestamp
        //
        
        KeQuerySystemTime((PLARGE_INTEGER)&pContext->PendingNotification.rtTimeStamp);
                               
        //
        // signal the event if present
        //
        
        if (pContext->PendingNotification.Header.hEvent) {
            SetEvent(pContext->PendingNotification.Header.hEvent);
        }
        
    }            

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::HandleNotificationRegistration"

VOID CEngine::HandleNotificationRegistration(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc, BOOL bRegister)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    PNOTIFICATION_CONTEXT pContext = NULL;

#ifdef VALIDATE_PARAMETERS

    if(!pNotificationDesc)
    {
        DPF_ERROR("No pNotificationDesc supplied");
    }

    if (pNotificationDesc->pSoundBank && pNotificationDesc->pSoundCue) {

        DPF_ERROR("You cant supply pSoundBank AND pSoundCue");
    }

    if (!pNotificationDesc->pSoundBank && !pNotificationDesc->pSoundCue) {

        DPF_ERROR("You must supply pSoundBank OR pSoundCue");
    }

    if ((pNotificationDesc->dwSoundCueIndex != XACT_SOUNDCUE_INDEX_UNUSED) &&
        (!pNotificationDesc->pSoundBank)) { 

        DPF_WARNING("YOu must supply pSoundBank if dwSoundCueIndex is specified");

    }

    //
    // validate notification type
    //

    if ((pNotificationDesc->dwType & XACT_MASK_NOTIFICATION_TYPE) >= eXACTNotification_Max) {
        DPF_ERROR("Invalid notification type");
    }

#endif // VALIDATE_PARAMETERS

    DWORD dwType = pNotificationDesc->dwType & XACT_MASK_NOTIFICATION_TYPE;

    //
    // first retrieve the correct notification context from a soundbank or a cue
    //

    if (pNotificationDesc->pSoundBank) {

        pContext = ((CSoundBank *)pNotificationDesc->pSoundBank)->GetNotificationContext(dwType);

    } else if (pNotificationDesc->pSoundCue) {

        //
        // tell the cue to handle the registration
        //

        pContext = ((CSoundCue *)pNotificationDesc->pSoundCue)->GetNotificationContext(dwType);

    }

    ASSERT(pContext);

    //
    // check if a notification of the same type is already registered
    //
    
#if DBG
    if (bRegister && pContext->bRegistered) {
        
        DPF_WARNING("Notification type %d already registered",
            dwType);
        
    }
    
    if (!bRegister && !pContext->bRegistered) {
        
        DPF_WARNING("Notification type %d never registered",
            dwType);
        
    }
#endif
    
    if (bRegister && !pContext->bRegistered) {
        
        //
        // this could be the first registration for this event/object combo
        //
        
        InitializeListHead(&pContext->ListEntry);
        InitializeListHead(&pContext->lstRegisteredCues);
        
    }
    
    //
    // save the notification description
    //
    
    memcpy(&pContext->PendingNotification.Header,
        pNotificationDesc,
        sizeof(XACT_NOTIFICATION_DESCRIPTION));
    
    
    pContext->bRegistered = bRegister;
    
    if (!IsListEmpty(&pContext->ListEntry)) {
        RemoveEntryList(&pContext->ListEntry);
    }

    if (pNotificationDesc->dwSoundCueIndex != XACT_SOUNDCUE_INDEX_UNUSED) {

        PCUE_INDEX_NOTIFICATION_CONTEXT pCueContext;

        //
        // create a link list of cue indices that are registred for this event type on
        // the soundbank. Then when play is called on the soundbank, using the same CueIndex,
        // turn around and register a notification with the particular cue instance
        //

        pCueContext = GetCueNotificationContext(pContext,pNotificationDesc->dwSoundCueIndex);

        if (bRegister) {                        
            
            if (!pCueContext) {
                
                pCueContext = NEW(CUE_INDEX_NOTIFICATION_CONTEXT);
                
                if (pCueContext) {
                    
                    pCueContext->dwSoundCueIndex = pNotificationDesc->dwSoundCueIndex;
                    InitializeListHead(&pCueContext->ListEntry);
                    InsertTailList(&pContext->lstRegisteredCues,
                        &pCueContext->ListEntry);

                    pCueContext->bPersist = pNotificationDesc->dwType & XACT_FLAG_NOTIFICATION_PERSIST;
                }

            } else {

                DPF_WARNING("SoundCue index %d already registered on soundbank 0x%x",
                    pNotificationDesc->dwSoundCueIndex,
                    pContext->PendingNotification.Header.pSoundBank);

            }

        } else {

            if(!pCueContext) {

                DPF_WARNING("SoundCue index %d never registered on soundbank 0x%x",
                    pNotificationDesc->dwSoundCueIndex,
                    pContext->PendingNotification.Header.pSoundBank);

            } else {

                RemoveEntryList(&pCueContext->ListEntry);
                DELETE(pCueContext);

            }

        }

    }

    return;

}

PCUE_INDEX_NOTIFICATION_CONTEXT
CEngine::GetCueNotificationContext(PNOTIFICATION_CONTEXT pContext,DWORD dwSoundCueIndex)
{

    PLIST_ENTRY pEntry;
    PCUE_INDEX_NOTIFICATION_CONTEXT pCueContext = NULL;

    pEntry = pContext->lstRegisteredCues.Flink;
    while (pEntry && pEntry != &pContext->lstRegisteredCues) {

        pCueContext = CONTAINING_RECORD(pEntry,
            CUE_INDEX_NOTIFICATION_CONTEXT,
            ListEntry);
        
        if (pCueContext->dwSoundCueIndex == dwSoundCueIndex) {
            break;
        } else {
            pCueContext = NULL;
        }

        pEntry = pEntry->Flink;

    }

    return pCueContext;
}


VOID CEngine::IsDuplicateWaveBank(CWaveBank *pWaveBank)
{

#if DBG
    //
    // check if this wavebank has been registered before
    //
    
    CWaveBank *pExistingWaveBank;
    PLIST_ENTRY pEntry = m_lstWaveBanks.Flink;
    while (pEntry != &m_lstWaveBanks) {
        
        pExistingWaveBank = CONTAINING_RECORD(pEntry,CWaveBank,m_ListEntry);
        if (!strncmp(pExistingWaveBank->m_WaveBankData.pHeader->szBankName,
            pWaveBank->m_WaveBankData.pHeader->szBankName,
            WAVEBANKHEADER_BANKNAME_LENGTH)) {
            
            DPF_ERROR("Same wavebank (%s) has already been registered",
                pWaveBank->m_WaveBankData.pHeader->szBankName);
            
            break;
            
        }

        pEntry = pEntry->Flink;
        
    }
#endif
    
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// external methods
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


#undef DPF_FNAME
#define DPF_FNAME "CEngine::LoadDspImage"

HRESULT CEngine::LoadDspImage(PVOID pvBuffer, DWORD dwSize, LPCDSEFFECTIMAGELOC pEffectLoc)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pvBuffer)
    {
        DPF_ERROR("No DSP image buffer supplied");
    }

    if (dwSize == 0)
    {
        DPF_ERROR("Invalid DSP image size");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Download the image, save the description
    //
    
    hr = m_pDirectSound->DownloadEffectsImage(pvBuffer, dwSize, pEffectLoc, &m_pDspImageDesc);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::CreateSoundSource"

HRESULT CEngine::CreateSoundSource(DWORD dwFlags,PXACTSOUNDSOURCE *ppSoundSource)
{
    HRESULT hr = S_OK;
    CSoundSource *pSoundSource;
    PLIST_ENTRY pEntry;

    ASSERT_IN_PASSIVE;
    DPF_ENTER();

    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!ppSoundSource)
    {
        DPF_ERROR("No ppSoundSource supplied");
    }

    if (!IsValidSoundSourceFlags(dwFlags)) {
        DPF_ERROR("Invalid sound source flags specified");
    }

#endif // VALIDATE_PARAMETERS

    //
    // give the caller one of the pre-allocated voices based
    // on the type they are requesting
    //

    if (dwFlags & XACT_FLAG_SOUNDSOURCE_3D) {
        ASSERT(!IsListEmpty(&m_lstAvailable3DBuffers));
        pEntry = RemoveHeadList(&m_lstAvailable3DBuffers);
    } else if (dwFlags & XACT_FLAG_SOUNDSOURCE_2D) {
        ASSERT(!IsListEmpty(&m_lstAvailable2DBuffers));
        pEntry = RemoveHeadList(&m_lstAvailable2DBuffers);
    }
    
    pSoundSource = CONTAINING_RECORD(pEntry, CSoundSource, m_ListEntry);
    *ppSoundSource = pSoundSource;

    pSoundSource->AddRef();

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::CreateSoundSourceInternal"

HRESULT CEngine::CreateSoundSourceInternal(DWORD dwFlags,CWaveBank *pWaveBank, CSoundSource **ppSoundSource)
{
    HRESULT hr = S_OK;
    CSoundSource *pSoundSource = NULL;
    PXACTSOUNDSOURCE pXactSoundSource;
    CWaveBank *pWaveBank2 = NULL;

    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();

    DPF_ENTER();
    ASSERT(ppSoundSource);

    if (pWaveBank == NULL) {

        hr = CreateSoundSource(dwFlags,&pXactSoundSource);
        pSoundSource = (CSoundSource *) pXactSoundSource;

    } else {

        //
        // try to get the voice from the appropriate wavebank
        // the wavebank will try to grab one from the engine internal lists
        // so dont look there if this fails
        //

        hr = pWaveBank->AllocateSoundSource(&pSoundSource);

        if(FAILED(hr)) {

            //
            // ok we are out of voices in the engine as well.
            // try ANY wavebank for an available voice
            //

            PLIST_ENTRY pEntry = m_lstWaveBanks.Flink;
            while (pEntry != &m_lstWaveBanks)
            {

                pWaveBank2 = CONTAINING_RECORD(pEntry, CWaveBank, m_ListEntry);
                hr = pWaveBank2->AllocateSoundSource(&pSoundSource);

                pEntry = pEntry->Flink;

                if (SUCCEEDED(hr)) {

                    //
                    // set the owner to be the wavebank they requested originally since
                    // we want the sound source to be freed to that wavebank, not where
                    // it was allocated from
                    //
                    
                    pSoundSource->SetWaveBankOwner(pWaveBank);

                    break;
                }

            }
            
        }

    }
    
    if (FAILED(hr)) {
        
        //
        // TODO: use priority to steal voices from another sound
        //

    }
    
    *ppSoundSource = pSoundSource;

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::CreateSoundBank"

HRESULT CEngine::CreateSoundBank(PVOID pvBuffer, DWORD dwSize, PXACTSOUNDBANK *ppSoundBank)
{
    HRESULT hr = S_OK;
    CSoundBank* pSoundBank;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pvBuffer)
    {
        DPF_ERROR("No pvBuffer supplied");
    }

    if (dwSize == 0)
    {
        DPF_ERROR("Invalid buffer size");
    }

    if(!ppSoundBank)
    {
        DPF_ERROR("No ppSoundBank supplied");
    }

#endif // VALIDATE_PARAMETERS


    //
    // create the sound bank object
    //

    hr = HRFROMP(pSoundBank = NEW(CSoundBank));
    
    if(SUCCEEDED(hr))
    {
        hr = pSoundBank->Initialize(pvBuffer,dwSize);
    }
    
    if(SUCCEEDED(hr))
    {
        *ppSoundBank = pSoundBank;
    }
    else
    {
        pSoundBank->Release();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::RegisterWaveBank"

HRESULT CEngine::RegisterWaveBank(PVOID pvData, DWORD dwSize, PXACTWAVEBANK *ppWaveBank)
{
    HRESULT hr = S_OK;
    CWaveBank *pWaveBank;    

    DPF_ENTER();

    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pvData)
    {
        DPF_ERROR("No pvData supplied");
    }

    if (dwSize == 0)
    {
        DPF_ERROR("Invalid buffer size");
    }

    if(!ppWaveBank)
    {
        DPF_ERROR("No ppWaveBank supplied");
    }

#endif // VALIDATE_PARAMETERS

    *ppWaveBank = NULL;

    //
    // create a wrapper object to track this wavebank
    //
    
    hr = HRFROMP(pWaveBank = NEW(CWaveBank));

    if(SUCCEEDED(hr))
    {

        hr = pWaveBank->Initialize(pvData,dwSize);

    }

    if(SUCCEEDED(hr)) {

        //
        // add wave wank to our linked list of banks
        //

        IsDuplicateWaveBank(pWaveBank);

        InsertTailList(&m_lstWaveBanks,&pWaveBank->m_ListEntry);
        *ppWaveBank = (PXACTWAVEBANK) pWaveBank;

    } else {

        pWaveBank->Release();

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::RegisterStreamedWaveBank"

HRESULT CEngine::RegisterStreamedWaveBank(PVOID pvStreamingBuffer, DWORD dwSize, HANDLE hFileHandle, DWORD dwOffset, PXACTWAVEBANK *ppWaveBank)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pvStreamingBuffer)
    {
        DPF_ERROR("No pvStreamingBuffer supplied");
    }

    if (dwSize == 0)
    {
        DPF_ERROR("Invalid buffer size");
    }

    if(!hFileHandle)
    {
        DPF_ERROR("Invalid hFileHandle");
    }

    if(!ppWaveBank)
    {
        DPF_ERROR("No ppWaveBank supplied");
    }

#endif // VALIDATE_PARAMETERS

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::UnRegisterWaveBank"

HRESULT CEngine::UnRegisterWaveBank(PXACTWAVEBANK pWaveBankInstance)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ASSERT_IN_PASSIVE;
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS
    if(!pWaveBankInstance)
    {
        DPF_ERROR("No pWaveBankInstance supplied");
    }    
#endif // VALIDATE_PARAMETERS

    CWaveBank *pWaveBank = (CWaveBank *) pWaveBankInstance;

    //
    // remove wave bank from our registered list
    //

    RemoveEntryList(&pWaveBank->m_ListEntry);

    pWaveBank->StopAllCues();

    ASSERT(pWaveBank->m_dwRefCount == 1);

    //
    // release object
    //

    pWaveBank->Release();

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::SetMasterVolume"

HRESULT CEngine::SetMasterVolume(LONG lVolume)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS
    if((lVolume < DSBVOLUME_MIN) || (lVolume > DSBVOLUME_MAX))
    {
        DPF_ERROR("Invalid lVolume (has to be within dsound specifed volume range");
    }
#endif // VALIDATE_PARAMETERS

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::SetListenerParameters"

HRESULT CEngine::SetListenerParameters(LPCDS3DLISTENER pcDs3dListener, LPCDSI3DL2LISTENER pcds3dl, DWORD dwApply)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS
    if ((pcDs3dListener == NULL) && (pcds3dl == NULL)){
        DPF_ERROR("You must supply at least one set of listener parameters");
    }
#endif

    if (pcDs3dListener) {
        hr = m_pDirectSound->SetAllParameters(pcDs3dListener,dwApply);
    }

    if (pcds3dl && SUCCEEDED(hr)) {

        hr = m_pDirectSound->SetI3DL2Listener(pcds3dl,dwApply);

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::GlobalPause"

HRESULT CEngine::GlobalPause(BOOL bPause)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    DPF_LEAVE_HRESULT(hr);

    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::RegisterNotification"

HRESULT CEngine::RegisterNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
{
    HandleNotificationRegistration(pNotificationDesc, TRUE);
    return S_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::UnRegisterNotification"

HRESULT CEngine::UnRegisterNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
{    
    HandleNotificationRegistration(pNotificationDesc, FALSE);
    return S_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::GetNotification"

HRESULT CEngine::GetNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc,PXACT_NOTIFICATION pNotification)
{
    HRESULT hr = S_OK;
    PNOTIFICATION_CONTEXT pContext = NULL;    

    DPF_ENTER();
    AutoIrql();
    
#ifdef VALIDATE_PARAMETERS

    if(!pNotificationDesc)
    {
        DPF_ERROR("No pNotificationDesc supplied");
    }

    ASSERT(!(pNotificationDesc->dwType & XACT_MASK_NOTIFICATION_FLAGS));

    if(!pNotification)
    {
        DPF_ERROR("No pNotification supplied");
    }

    if (pNotificationDesc->pSoundBank && pNotificationDesc->pSoundCue) {

        DPF_ERROR("You cant specify a notification desc that has both pSoundBank and pSoundCue");

    }

    if (pNotificationDesc->dwSoundCueIndex != XACT_SOUNDCUE_INDEX_UNUSED) {

        DPF_WARNING("dwSoundCueIndex is ignored when calling this API. Set to -1");

    }
        
    if ((pNotificationDesc->dwType != XACT_NOTIFICATION_TYPE_UNUSED) && 
        (pNotificationDesc->dwType >= eXACTNotification_Max)) {

        DPF_ERROR("Invalid notification type specified (%d)",
            pNotificationDesc->dwType);

    }

    if ((pNotificationDesc->dwType == XACT_NOTIFICATION_TYPE_UNUSED) && 
        (pNotificationDesc->pSoundBank || pNotificationDesc->pSoundCue)) {

        DPF_ERROR("dwType must be valid if pSoundBank or pSoundCue is supplied");

    }

#endif // VALIDATE_PARAMETERS

    //
    // get a notification from our linked list or soundbank,soundcue
    // based on the criteria specified
    //

    if (pNotificationDesc->dwType == XACT_NOTIFICATION_TYPE_UNUSED) {

        PLIST_ENTRY pEntry;

        //
        // retrieve the next notification regadless of type
        //

        pEntry = m_lstPendingNotifications.Flink;
        while (pEntry != &m_lstPendingNotifications) {

            pContext = CONTAINING_RECORD(pEntry,NOTIFICATION_CONTEXT,ListEntry);
            break;

        }

    } else if (pNotificationDesc->pSoundBank) {
        CSoundBank *pSoundBank = (CSoundBank *) pNotificationDesc->pSoundBank;
        pContext = pSoundBank->GetNotificationContext(pNotificationDesc->dwType);        
    } else {
        CSoundCue *pSoundCue = (CSoundCue *) pNotificationDesc->pSoundCue;
        pContext = pSoundCue->GetNotificationContext(pNotificationDesc->dwType);
    }

    if (IsListEmpty(&pContext->ListEntry)) {

        //
        // this context does not contain a signalled event.
        // only contexts that belong to the global notification list have 
        // pending notifications
        //

        pContext = NULL;
    }

#if DBG
    if (pContext && !pContext->bRegistered) {
        DPF_WARNING("Attempting to retrieve notification type that was never registers");
    }           
#endif

    if (pContext && pContext->bRegistered) {

        RemoveEntryList(&pContext->ListEntry);
        if (!(pContext->PendingNotification.Header.dwType & XACT_FLAG_NOTIFICATION_PERSIST)){
            
            //
            // auto-unregister notification
            //
            
            pContext->bRegistered = FALSE;
            
        }

        //
        // copy pending notification to user-supplied buffer
        //

        memcpy(pNotification,
            &pContext->PendingNotification,
            sizeof(XACT_NOTIFICATION));
                
        
    }
   
    if (!pContext)
        hr = E_FAIL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::FlushNotification"

HRESULT CEngine::FlushNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
{
    HRESULT hr = S_OK;
    PLIST_ENTRY pEntry;
    PNOTIFICATION_CONTEXT pContext = NULL;
    BOOL bFlush = FALSE;
    
    DPF_ENTER();
    
    AutoIrql();

#ifdef VALIDATE_PARAMETERS

    if(!pNotificationDesc)
    {
        DPF_ERROR("No pNotificationDesc supplied");
    }

    ASSERT(pNotificationDesc->dwType & XACT_MASK_NOTIFICATION_FLAGS);

    if ((pNotificationDesc->dwType != XACT_NOTIFICATION_TYPE_UNUSED) && 
        (pNotificationDesc->dwType >= eXACTNotification_Max)) {

        DPF_ERROR("Invalid notification type specified (%d)",
            pNotificationDesc->dwType);

    }

    if (pNotificationDesc->pSoundBank && pNotificationDesc->pSoundCue) {

        DPF_ERROR("You cant specify a notification desc that has both pSoundBank and pSoundCue");

    }

    if ((pNotificationDesc->dwSoundCueIndex != XACT_SOUNDCUE_INDEX_UNUSED) &&
        !pNotificationDesc->pSoundBank){

        DPF_WARNING("You must supply pSoundBank if dwSoundCueIndex is valid");

    }

#endif // VALIDATE_PARAMETERS

    if (pNotificationDesc->pSoundBank &&
        (pNotificationDesc->dwSoundCueIndex != XACT_SOUNDCUE_INDEX_UNUSED)) {
        
        PCUE_INDEX_NOTIFICATION_CONTEXT pCueContext;
        CSoundBank *pSoundBank = (CSoundBank *) pNotificationDesc->pSoundBank;

        //
        // soundCueIndex was specified which means we need to remove it from the soundbanks
        // list of registered cue indices
        //

        pContext = pSoundBank->GetNotificationContext(pNotificationDesc->dwType);        
        pCueContext = GetCueNotificationContext(pContext,pNotificationDesc->dwSoundCueIndex);
        if (pCueContext && !(pCueContext->bPersist)) {

            RemoveEntryList(&pCueContext->ListEntry);
            DELETE(pCueContext);

        }
        
    }

    //
    // flush the appropriate pending notifications
    //

    pEntry = m_lstPendingNotifications.Flink;
    while (pEntry != &m_lstPendingNotifications) {
        
        pContext = CONTAINING_RECORD(pEntry,NOTIFICATION_CONTEXT,ListEntry);
        if (pNotificationDesc->dwType == XACT_NOTIFICATION_TYPE_UNUSED)
        {
            bFlush = TRUE;

        } else if (pNotificationDesc->dwType == 
            (pContext->PendingNotification.Header.dwType & XACT_MASK_NOTIFICATION_TYPE)){

            bFlush = TRUE;
        }

        //
        // flush any notification regadless of type. If pSoundBank is supplied
        // flush all notification associated with that soundbank. Same with pSoundCue
        //
        
        if (pContext->PendingNotification.Header.pSoundBank &&
            (pContext->PendingNotification.Header.pSoundBank != pNotificationDesc->pSoundBank)) {
            
            bFlush = FALSE;
            
        }

        if (pContext->PendingNotification.Header.pSoundCue && 
            (pContext->PendingNotification.Header.pSoundCue != pNotificationDesc->pSoundCue)) {
            
            bFlush = FALSE;
            
        }

        if (bFlush) {

            RemoveEntryList(&pContext->ListEntry);
            if (!(pContext->PendingNotification.Header.dwType & XACT_FLAG_NOTIFICATION_PERSIST)){

                //
                // unregister notification
                //

                pContext->bRegistered = FALSE;

            }

        }
        
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::CommitDefferedSettings"

HRESULT CEngine::CommitDeferredSettings()
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    hr = m_pDirectSound->CommitDeferredSettings();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::ScheduleEvent"

HRESULT CEngine::ScheduleEvent(XACT_TRACK_EVENT *pEventDesc, PXACTSOUNDCUE pSoundCueObject, DWORD dwTrackIndex)
{
    HRESULT hr = S_OK;
    PTRACK_EVENT_CONTEXT pEventContext;
    PXACT_TRACK_EVENT pEvent;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS    
    if(!pEventDesc)
    {
        DPF_ERROR("No pEvent supplied");
    }

    if (pEventDesc->Header.wType >= eXACTEvent_Max)
    {
        DPF_ERROR("Invalid Event type");
    }

    if (pSoundCueObject == NULL) {

        if (pEventDesc->Header.wType != eXACTEvent_SetEffectData) {
            DPF_ERROR("pSoundCue == NULL and eventType == eXACTEvent_SetEffectData is not a valid global event");
        }

        if (dwTrackIndex != XACT_TRACK_INDEX_UNUSED) {

            DPF_ERROR("pSoundCue must be != NULL if a valid dwTrackIndex is supplied");

        }
    }

    if (pSoundCueObject != NULL) {

        //
        // check if the event they are submitting is valid for runtime submission
        //

        if (pEventDesc->Header.wType == eXACTEvent_Play) {
            DPF_ERROR("Play is not a valid event type when submitting events through API");
        }
    }
    
#endif // VALIDATE_PARAMETERS
           
    if (SUCCEEDED(hr)) {

        //
        // pSoundCue is optional since this event can be a global event
        // such as SetEffectData that is not associated with a specific soundsource
        // If pSoundCue is supplied, based on the type of event, we modify source or target voice
        // since the user cant specify a track, only single track sounds are acceptable...
        //
        
        if (pSoundCueObject) {
            
            CSoundCue *pSoundCue = (CSoundCue *) pSoundCueObject;            
            hr = pSoundCue->ScheduleRuntimeEvent(pEventDesc,dwTrackIndex);
            
        } else {

            //
            // create a dummy track context only so we can use the 
            // CreateEventTimestamp function
            //

            TRACK_CONTEXT track;

            memset(&track,0,sizeof(track));            

            //
            // create an event context for this event
            //
            
            hr = HRFROMP(pEventContext = NEW(TRACK_EVENT_CONTEXT));
            
            if (SUCCEEDED(hr)) {
                
                hr = HRFROMP(pEvent = NEW(XACT_TRACK_EVENT));
                
            }
            
            if (SUCCEEDED(hr)) {
                
                //
                // copy user event desc
                //
                
                memcpy(pEvent,pEventDesc,sizeof(XACT_TRACK_EVENT));
                
                //
                // setup the event context
                //
                
                pEventContext->m_pEventHeader = &pEvent->Header;
                
            }
            
            track.wSamplesPerSec = 48000;
            KeQuerySystemTime((PLARGE_INTEGER)&track.rtStartTime);
            InitializeListHead(&track.lstEvents);

            CreateEventTimeStamp(&track,pEventContext);

            //
            // enqueue this event
            //

            hr = Enqueue(pEventContext);

        }
        
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\wavebank.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wavebank.cpp
 *  Content:    XACT runtime wavebank object implementation
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/27/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"
#include "wavbndlr.h"

using namespace XACT;

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::CWaveBank"


CWaveBank::CWaveBank
(
    void
)
{
    DPF_ENTER();
    InitializeListHead(&m_ListEntry);
    InitializeListHead(&m_lstCues);
    InitializeListHead(&m_lstAvailableSources);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::~CWaveBank"

CWaveBank::~CWaveBank
(
    void
)
{
    ENTER_EXTERNAL_METHOD();
    CSoundSource *pSource;

    DPF_ENTER();
    PLIST_ENTRY pEntry;

    g_pEngine->Release();
 
    m_WaveBankData.pvData = NULL;
    m_WaveBankData.dwDataSize = 0;

    pEntry = m_lstAvailableSources.Flink;
    while (pEntry != &m_lstAvailableSources){

        pSource = CONTAINING_RECORD(pEntry,CSoundSource,m_ListEntry);
        pEntry = pEntry->Flink;

        pSource->SetWaveBankOwner(NULL);

        //
        // tell dsound to release the page SGEs
        //

        if (LPDIRECTSOUNDBUFFER pBuffer = pSource->GetDSoundBuffer()) {
            pBuffer->SetBufferData(0,0);
        }

        RemoveEntryList(&pSource->m_ListEntry);
        pSource->Release();

    }

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::Initialize"

HRESULT CWaveBank::Initialize(PVOID pvData, DWORD dwSize)
{
    HRESULT hr = S_OK;
    DWORD dwOffset = 0;
    CSoundSource *pSource;

    ENTER_EXTERNAL_METHOD();
    DPF_ENTER();

    ASSERT(g_pEngine);    
    ASSERT(pvData);
    ASSERT(dwSize);

    g_pEngine->AddRef();

    hr = AllocateSoundSource(&pSource);

    if (SUCCEEDED(hr)) {

        m_WaveBankData.pHeader = (LPWAVEBANKHEADER)((PUCHAR)pvData+dwOffset);
        
#ifdef VALIDATE_PARAMETERS
        //
        // Validate the header
        //
        
        if (m_WaveBankData.pHeader->dwSignature  != WAVEBANKHEADER_SIGNATURE ||
            m_WaveBankData.pHeader->dwVersion    != WAVEBANKHEADER_VERSION ||
            m_WaveBankData.pHeader->dwEntryCount == 0)
        {
            DPF_ERROR("Invalid wavebank header (0x%x)", pvData);
            hr = E_FAIL;
        }
#endif
        
    }

    if (SUCCEEDED(hr)) {
        
        dwOffset += sizeof(WAVEBANKHEADER);
        m_WaveBankData.paMetaData = (LPWAVEBANKENTRY) ((PUCHAR)pvData + dwOffset);
        
        dwOffset += m_WaveBankData.pHeader->dwEntryCount*sizeof(WAVEBANKENTRY);
        m_WaveBankData.pvData = (PVOID) ((PUCHAR)pvData+dwOffset);
        m_WaveBankData.dwDataSize = dwSize - dwOffset;
        
        //
        // map one 2d voice to span the entire data buffer.
        // this makes dsound pre-allocate the SGEs required by all the waves in the bank
        // and minimizes latency when playing voices pointing to this wavebank later
        //

        hr = SetBufferData(pSource->GetDSoundBuffer());

    }

    //
    // the first voice is available for use by a cue since we just used it to map wave data
    // AllocateSoundSource addrefs the source one extra time to bring the voice total to at least 3
    // this way when its released it looks like it was released from a cue and it gets
    // freed back to the wavebank freelist
    //    

    if (SUCCEEDED(hr)) {

        pSource->Release();

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::AllocateSoundSource"

HRESULT CWaveBank::AllocateSoundSource(CSoundSource **ppSource)
{

    HRESULT hr = S_OK;
    ENTER_EXTERNAL_METHOD();

    PLIST_ENTRY pEntry;
    CSoundSource *pSource;

    while (TRUE && SUCCEEDED(hr)) {

        if (!IsListEmpty(&m_lstAvailableSources)) {
            
            pEntry = RemoveHeadList(&m_lstAvailableSources);
            pSource = CONTAINING_RECORD(pEntry,CSoundSource,m_ListEntry);
            
        } else {
            
            //
            // get one from the engine
            //
            
            hr = g_pEngine->CreateSoundSourceInternal(XACT_FLAG_SOUNDSOURCE_2D,NULL,&pSource);        
            
        }
        
        if (SUCCEEDED(hr)){
            
            pSource->AddRef();
            pSource->SetWaveBankOwner(this);
            *ppSource = pSource;
            
        }
        
        if (SUCCEEDED(hr) && pSource->IsPlaying()) {

            DPF_WARNING("Voice form available list was still playing in hw, attempting re-alloc of new one");

            //
            // hmm the free voice we got is still playing...
            // we d rather allocate a new one and leave this one alone for now
            //
            
            pSource->Release();
            
        } else {
            break;
        }

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::FreeSoundSource"

VOID CWaveBank::FreeSoundSource(CSoundSource *pSource)
{

    ENTER_EXTERNAL_METHOD();

    ASSERT(pSource);
    ASSERT(pSource->m_pWaveBankOwner == this);

    InsertTailList(&m_lstAvailableSources,&pSource->m_ListEntry);

}



#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::AddCueToList"

VOID CWaveBank::AddCueToList(PWAVEBANK_CUE_CONTEXT pEntry)
{
    ENTER_EXTERNAL_METHOD();
    InsertTailList(&m_lstCues,
        &pEntry->ListEntry);

}

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::RemoveCueFromList"

VOID CWaveBank::RemoveCueFromList(PWAVEBANK_CUE_CONTEXT pEntry)
{
    ENTER_EXTERNAL_METHOD();
    RemoveEntryList(&pEntry->ListEntry);
}

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::StopAllCues"

VOID CWaveBank::StopAllCues()
{
    ENTER_EXTERNAL_METHOD();
    CSoundCue *pCue = NULL;
    PWAVEBANK_CUE_CONTEXT pCueEntry;

    //
    // stop all cues associated with this wavebank
    //

    PLIST_ENTRY pEntry = m_lstCues.Flink;
    while (pEntry != &m_lstCues){

        pCueEntry = CONTAINING_RECORD(pEntry,WAVEBANK_CUE_CONTEXT,ListEntry);
        pCue = pCueEntry->pSoundCue;
        pEntry = pEntry->Flink;

        DPF_WARNING("You are un-registering wavebank 0x%x still referenced by cue %s.\n"\
            "        This can cause breakup and glitching. Cue %x is no longer valid",
            this,
            pCue->GetFriendlyName(),
            pCue);

        pCue->Stop(XACT_FLAG_SOUNDCUE_SYNCHRONOUS | XACT_FLAG_SOUNDCUE_AUTORELEASE);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\soundsource.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       soundsource.cpp
 *  Content:    XACT runtime sound source object implementation
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/22/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"

using namespace XACT;

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::CSoundSource"


CSoundSource::CSoundSource
(
    void
)
{
    DPF_ENTER();

    ASSERT(g_pEngine);
    g_pEngine->AddRef();

    InitializeListHead(&m_ListEntry);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::~CSoundSource"

CSoundSource::~CSoundSource
(
    void
)
{
    DPF_ENTER();

    ASSERT(g_pEngine);
    g_pEngine->Release();

    if (m_HwVoice.pStream) {

        m_HwVoice.pStream->Release();

    }

    if (m_HwVoice.pBuffer) {

        m_HwVoice.pBuffer->Release();

    }

    ASSERT(m_pWaveBankOwner == NULL);

    DPF_LEAVE_VOID();
}

__inline ULONG CSoundSource::AddRef(void)
{
    _ENTER_EXTERNAL_METHOD("CSoundSource::AddRef");
    return CRefCount::AddRef();
}


ULONG CSoundSource::Release(void)
{
    _ENTER_EXTERNAL_METHOD("CSoundSource::Release");
    DWORD dwRefCount = CRefCount::Release();

    switch(dwRefCount) {
    case 1:

        //
        // return this voice to the engine available buffer list
        //

        ASSERT(g_pEngine);
        ASSERT(m_pWaveBankOwner == NULL);

        g_pEngine->FreeSoundSource(this);
        break;


    case 2:

        //
        // stop the voice. this will not cause any blocking any hw
        //
        
        if (!IsPositional())
        {
            Stop();
        }

        //
        // if this source has a wavebank owner, return this voice
        // to the wavebank available list,since its associated with specific
        // hw scatter gather entries
        //

        if (m_pWaveBankOwner) {
            m_pWaveBankOwner->FreeSoundSource(this);
        }            
        
        break;
    }

    return dwRefCount;

}


#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::Initialize"

HRESULT CSoundSource::Initialize()
{
    HRESULT hr = S_OK;

    DPF_ENTER();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::Stop"

HRESULT CSoundSource::Stop()
{

    HRESULT hr = S_OK;
    //
    // this is an internal method but we want to sync with external api calls
    //

    ENTER_EXTERNAL_METHOD();

    DPF_ENTER();

    if (m_HwVoice.pBuffer) {
        hr = m_HwVoice.pBuffer->Stop();
    } else {

        hr = m_HwVoice.pStream->Flush();
        if (SUCCEEDED(hr)) {
            hr = m_HwVoice.pStream->Pause(DSSTREAMPAUSE_PAUSE);
        }

    }
    
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::Play"

HRESULT CSoundSource::Play()
{    
    HRESULT hr = S_OK;

    //
    // this is an internal method but we want to sync with external api calls
    //

    ENTER_EXTERNAL_METHOD();
    DPF_ENTER();

    if (m_HwVoice.pBuffer) {
        hr = m_HwVoice.pBuffer->Play(0,0,0);
    } else {

        //
        // TODO Implement Streaming Play
        //

    }

    return hr;
    
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetPosition"

HRESULT CSoundSource::SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetPosition(x,y,z,dwApply);
    else 
        hr = m_HwVoice.pStream->SetPosition(x,y,z,dwApply);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetAllParameters"

HRESULT CSoundSource::SetAllParameters(LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetAllParameters(pcDs3dBuffer,dwApply);
    else 
        hr = m_HwVoice.pStream->SetAllParameters(pcDs3dBuffer,dwApply);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetConeOrientation"

HRESULT CSoundSource::SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();
    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetConeOrientation(x, y, z, dwApply);
    else 
        hr = m_HwVoice.pStream->SetConeOrientation(x, y, z, dwApply);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetI3DL2Source"

HRESULT CSoundSource::SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetI3DL2Source(pds3db, dwApply);
    else 
        hr = m_HwVoice.pStream->SetI3DL2Source(pds3db, dwApply);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetVelocity"

HRESULT CSoundSource::SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetVelocity(x, y, z, dwApply);
    else 
        hr = m_HwVoice.pStream->SetVelocity(x, y, z, dwApply);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetMixBins"

HRESULT CSoundSource::SetMixBins(LPCDSMIXBINS pMixBins)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetMixBins(pMixBins);
    else 
        hr = m_HwVoice.pStream->SetMixBins(pMixBins);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}

#undef DPF_FNAME
#define DPF_FNAME "CSoundSource::SetMixBinVolumes"

HRESULT CSoundSource::SetMixBinVolumes(LPCDSMIXBINS pMixBins)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if (m_HwVoice.pBuffer)
        hr = m_HwVoice.pBuffer->SetMixBinVolumes(pMixBins);
    else 
        hr = m_HwVoice.pStream->SetMixBinVolumes(pMixBins);

    DPF_LEAVE_HRESULT(hr);
    return hr;
 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\xactapi.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xactapi.cpp
 *  Content:    XACT runtime Engine API objects and entry points.
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/22/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"

#pragma comment(linker, "/merge:XACTENG_RW=XACTENG")
#pragma comment(linker, "/merge:XACTENG_URW=XACTENG")
#pragma comment(linker, "/merge:XACTENG_RD=XACTENG")
#pragma comment(linker, "/section:XACTENG,ERW")

    
INITIALIZED_CRITICAL_SECTION(g_XACTCriticalSection);

STDAPI_(ULONG) IXACTEngine_AddRef(PXACTENGINE pEngine)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->AddRef();
}

STDAPI_(ULONG) IXACTEngine_Release(PXACTENGINE pEngine)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->Release();
}


STDAPI IXACTEngine_LoadDspImage(PXACTENGINE pEngine, PVOID pvBuffer, DWORD dwSize, LPCDSEFFECTIMAGELOC pEffectLoc)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->LoadDspImage(pvBuffer, dwSize, pEffectLoc);
}

STDAPI IXACTEngine_CreateSoundSource(PXACTENGINE pEngine, DWORD dwFlags, PXACTSOUNDSOURCE *ppSoundSource)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->CreateSoundSource(dwFlags, ppSoundSource);
}

STDAPI IXACTEngine_CreateSoundBank(PXACTENGINE pEngine, PVOID pvBuffer, DWORD dwSize, PXACTSOUNDBANK *ppSoundBank)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->CreateSoundBank(pvBuffer, dwSize, ppSoundBank);
}

STDAPI IXACTEngine_RegisterWaveBank(PXACTENGINE pEngine, PVOID pvData, DWORD dwSize, PXACTWAVEBANK *ppWaveBank)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->RegisterWaveBank(pvData, dwSize, ppWaveBank);
}

STDAPI IXACTEngine_RegisterStreamedWaveBank(PXACTENGINE pEngine, PVOID pvStreamingBuffer, DWORD dwSize, HANDLE hFileHandle, DWORD dwOffset, PXACTWAVEBANK *ppWaveBank)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->RegisterStreamedWaveBank(pvStreamingBuffer, dwSize, hFileHandle, dwOffset, ppWaveBank);
}

STDAPI IXACTEngine_UnRegisterWaveBank(PXACTENGINE pEngine, PXACTWAVEBANK pWaveBank)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->UnRegisterWaveBank(pWaveBank);
}

STDAPI IXACTEngine_SetMasterVolume(PXACTENGINE pEngine, LONG lVolume)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->SetMasterVolume(lVolume);
}

STDAPI IXACTEngine_SetListenerParameters(PXACTENGINE pEngine, LPCDS3DLISTENER pcDs3dListener, LPCDSI3DL2LISTENER pds3dl, DWORD dwApply)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->SetListenerParameters(pcDs3dListener, pds3dl, dwApply);
}

STDAPI IXACTEngine_GlobalPause(PXACTENGINE pEngine, BOOL bPause)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->GlobalPause(bPause);
}

STDAPI IXACTEngine_RegisterNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->RegisterNotification(pNotificationDesc);
}

STDAPI IXACTEngine_UnRegisterNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->UnRegisterNotification(pNotificationDesc);
}

STDAPI IXACTEngine_GetNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc, PXACT_NOTIFICATION pNotification)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->GetNotification(pNotificationDesc, pNotification);
}

STDAPI IXACTEngine_FlushNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->FlushNotification(pNotificationDesc);
}

STDAPI IXACTEngine_ScheduleEvent(PXACTENGINE pEngine, XACT_TRACK_EVENT *pEventDesc, PXACTSOUNDCUE pSoundCue, DWORD dwTrackIndex)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->ScheduleEvent(pEventDesc, pSoundCue, dwTrackIndex);
}

STDAPI IXACTEngine_CommitDeferredSettings(PXACTENGINE pEngine)
{
    using namespace XACT;
    return ((CEngine *)pEngine)->CommitDeferredSettings();
}

//
// soundbank apis
//

STDAPI_(ULONG) IXACTSoundBank_AddRef(PXACTSOUNDBANK pBank)
{
    using namespace XACT;
    return ((CSoundBank *)pBank)->AddRef();
}
STDAPI_(ULONG) IXACTSoundBank_Release(PXACTSOUNDBANK pBank)
{
    using namespace XACT;
    return ((CSoundBank *)pBank)->Release();
}

STDAPI IXACTSoundBank_GetSoundCueIndexFromFriendlyName(PXACTSOUNDBANK pBank, LPCSTR lpFriendlyName, PDWORD pdwCueIndex)
{
    using namespace XACT;
    return ((CSoundBank *)pBank)->GetSoundCueIndexFromFriendlyName(lpFriendlyName, pdwCueIndex);
}

STDAPI IXACTSoundBank_Play(PXACTSOUNDBANK pBank, DWORD dwCueIndex, PXACTSOUNDSOURCE pSoundSource, DWORD dwFlags, PXACTSOUNDCUE *ppCue)
{
    using namespace XACT;
    return ((CSoundBank *)pBank)->Play(dwCueIndex, pSoundSource, dwFlags, ppCue);
}

STDAPI IXACTSoundBank_Stop(PXACTSOUNDBANK pBank, DWORD dwCueIndex, DWORD dwFlags, PXACTSOUNDCUE pCue)
{
    using namespace XACT;
    return ((CSoundBank *)pBank)->Stop(dwCueIndex, dwFlags, pCue);
}


//
// SoundSource apis
//

STDAPI_(ULONG) IXACTSoundSource_AddRef(PXACTSOUNDSOURCE pSoundSource)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->AddRef();
}

STDAPI_(ULONG) IXACTSoundSource_Release(PXACTSOUNDSOURCE pSoundSource)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->Release();
}

STDAPI IXACTSoundSource_SetPosition(PXACTSOUNDSOURCE pSoundSource, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetPosition(x, y, z, dwApply);
}

STDAPI IXACTSoundSource_SetAllParameters(PXACTSOUNDSOURCE pSoundSource, LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetAllParameters(pcDs3dBuffer, dwApply);
}

STDAPI IXACTSoundSource_SetConeOrientation(PXACTSOUNDSOURCE pSoundSource,FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetConeOrientation(x, y, z, dwApply);
}

STDAPI IXACTSoundSource_SetI3DL2Source(PXACTSOUNDSOURCE pSoundSource,LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetI3DL2Source(pds3db,dwApply);
}

STDAPI IXACTSoundSource_SetVelocity(PXACTSOUNDSOURCE pSoundSource,FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetVelocity(x, y, z, dwApply);
}

STDAPI IXACTSoundSource_SetMixBins(PXACTSOUNDSOURCE pSoundSource, LPCDSMIXBINS pMixBins)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetMixBins(pMixBins);
}

STDAPI IXACTSoundSource_SetMixBinVolumes(PXACTSOUNDSOURCE pSoundSource, LPCDSMIXBINS pMixBins)
{
    using namespace XACT;
    return ((CSoundSource *)pSoundSource)->SetMixBinVolumes(pMixBins);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\engine\sequencer.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sequencer.cpp
 *  Content:    XACT runtime Engine sequencer. 
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  1/22/2002   georgioc  Created.
 *
 ****************************************************************************/

#include "xacti.h"
#include "xboxdbg.h"

using namespace XACT;


//
// event names
//

#if DBG

//
// NOTE: the order of the names below MUST match the
// XACT_TRACK_EVENT_TYPES enum in xactp.h
//

EXTERN_C 
char *g_aszXACTEventNames[eXACTEvent_Max] = {

        "PLAY",
        "PLAYWITHPITCHANDAVOLUME",
        "STOP",
        "PITCHANDAVOLUMEVARIATION",
        "SETFREQUENCY",
        "SETVOLUME",
        "SETHEADROOM",
        "SETLFO",
        "SETEG",
        "SETFILTER",
        "MARKER",
        "LOOPSTART",
        "LOOPEND",
        "SETMIXBINVOLUMES",
        "SETEFFECTDATA"        

};

#endif //DBG



// ------------ Event methods ------------------

BOOL TRACK_EVENT_CONTEXT::IsLessThanOrEqual(const REFERENCE_TIME* time) const
{
    return m_rtTimeStamp <= *time;
}

__inline BOOL TRACK_EVENT_CONTEXT::IsLessThan(const TRACK_EVENT_CONTEXT* other) const
{
    return Compare(other) == -1;
}

__inline BOOL TRACK_EVENT_CONTEXT::IsGreaterThan(const TRACK_EVENT_CONTEXT* other) const
{
    return Compare(other) == 1;
}

LONG TRACK_EVENT_CONTEXT::Compare(const TRACK_EVENT_CONTEXT* other) const
{
    // Check time
    if(m_rtTimeStamp < other->m_rtTimeStamp){
        return -1;
    }
    if(m_rtTimeStamp > other->m_rtTimeStamp){
        return 1;
    }
    return 0;
}

/*
 * A priority queue implementation. This queue has the following
 * properties:
 *
 * Inserting is O(log(n))
 * Removing is O(log(n))
 * Poping is O(log(n))
 *
 * Overhead of 8 bytes per element. 4 for the Element pointer, 4 for
 * the queue index inside the element. The queue index is used to
 * enable Remove to operate in O(log(n)) instead of O(n).
 *
 */

#ifdef DO_VERIFY_PRIORITYQUEUE
#define VERIFY_PRIORITYQUEUE Verify()
#else
#define VERIFY_PRIORITYQUEUE (void) 0
#endif

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::CPriorityQueue"

CPriorityQueue::CPriorityQueue()
{
    DPF_ENTER();
    m_paEvents = NULL;
    m_dwCapacity = 0;
    m_dwSize = 0;

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::~CPriorityQueue"

CPriorityQueue::~CPriorityQueue()
{
    DPF_ENTER();
    if (m_paEvents) 
    {
        DELETE_A(m_paEvents);
    }

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Initialize"

HRESULT CPriorityQueue::Initialize(DWORD dwMaxSize)
{
    HRESULT hr = S_OK;
    DPF_ENTER();
    ASSERT(m_paEvents == NULL);

    hr = HRFROMP(m_paEvents = NEW_A(PTRACK_EVENT_CONTEXT,dwMaxSize));

    if (SUCCEEDED(hr)) {

        m_dwCapacity = dwMaxSize;
        VERIFY_PRIORITYQUEUE;

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Remove"

void CPriorityQueue::Remove(PTRACK_EVENT_CONTEXT pEvent)
{
    DPF_ENTER();
    VERIFY_PRIORITYQUEUE;

    //
    // Bubble the event to the top.
    //

    ASSERT(pEvent->m_dwQueueIndex);

    DWORD test_node = pEvent->m_dwQueueIndex;
    while(test_node > 1){
        DWORD parent = test_node / 2;
        Swap(test_node, parent);
        test_node = parent;
    }

    //
    // Remove from queue - this balances the queue again
    //

    Pop2();

    VERIFY_PRIORITYQUEUE;

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::GetNextEventTime"

BOOL CPriorityQueue::GetNextEventTime(REFERENCE_TIME* pTime)
{

    DPF_ENTER();
    VERIFY_PRIORITYQUEUE;
    if(!m_dwSize){
        return false;
    }

    *pTime = At(1)->m_rtTimeStamp;
    return true;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::PopIfLessThanOrEqual"

PTRACK_EVENT_CONTEXT CPriorityQueue::PopIfLessThanOrEqual(const REFERENCE_TIME* rtTime)
{

    DPF_ENTER();
    VERIFY_PRIORITYQUEUE;
    PTRACK_EVENT_CONTEXT pResult = 0;

    if(m_dwSize && At(1)->IsLessThanOrEqual(rtTime)){
        pResult = Pop2();
    }

    return pResult;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Pop"

PTRACK_EVENT_CONTEXT CPriorityQueue::Pop()
{

    DPF_ENTER();
    VERIFY_PRIORITYQUEUE;
    PTRACK_EVENT_CONTEXT pResult = Pop2();
    return pResult;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Pop2"

PTRACK_EVENT_CONTEXT CPriorityQueue::Pop2()
{

    DPF_ENTER();

    //
    // Don't verify the queue, because it won't be valid if we're called from Remove
    // (Because Remove has bubbled the item it wants to remove to the top of the heap.)

    if(m_dwSize <= 0){
        return NULL;
    }

    // Return the top of the queue, and
    // adjust the heap 

    PTRACK_EVENT_CONTEXT pTop = At(1);
    Move(1, m_dwSize); // last element can be moved because it has no children, doesn't leave hole.

    DWORD test_node = 1;
    for(;;){
        DWORD child;
        if ( ( test_node * 2 ) >= m_dwSize )
            break;
        if ( ( test_node * 2 + 1) >= m_dwSize )
            child = test_node * 2;
        else if ( At( test_node * 2)->IsLessThan(At(test_node * 2 + 1)) )
            child = test_node * 2;
        else
            child = test_node * 2 + 1;
        if ( At(test_node)->IsGreaterThan(At(child)) ) {
            Swap(test_node, child);
            test_node = child;
        } else
            break;
    }

    //
    // no longer in queue
    //

    --m_dwSize;
    pTop->m_dwQueueIndex = 0; 

    VERIFY_PRIORITYQUEUE;
    return pTop;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Push"

HRESULT CPriorityQueue::Push(PTRACK_EVENT_CONTEXT pEvent)
{
    HRESULT hr = S_OK;

    DPF_ENTER();
    VERIFY_PRIORITYQUEUE;
    ASSERT(m_paEvents);
    ASSERT(m_dwCapacity);
    ASSERT(m_dwCapacity >= m_dwSize);

    if (m_dwCapacity <= m_dwSize){
        return E_OUTOFMEMORY;
    }

    //
    // At and AtPut are one-based, so pre-increment
    //

    AtPut(++m_dwSize, pEvent); 

    // Bubble into proper position
    DWORD test_node = m_dwSize;
    while ( test_node > 1 ) {
        DWORD parent_node = test_node/2;
        if ( At(parent_node)->IsGreaterThan(At(test_node)) ){
            Swap(parent_node, test_node);
            test_node = parent_node;
        } else
            break;
    }

    VERIFY_PRIORITYQUEUE;
    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::AdjustEventTimes"

VOID CPriorityQueue::AdjustEventTimes(REFERENCE_TIME rtDelta)
{
    DPF_ENTER();
    for(DWORD i = 1; i <= m_dwSize; i++){
        PTRACK_EVENT_CONTEXT pEvent = At(i);
        pEvent->m_rtTimeStamp += rtDelta;
    }

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::AtPut"

__inline VOID CPriorityQueue::AtPut(DWORD dwIndex, PTRACK_EVENT_CONTEXT pEvent)
{
    DPF_ENTER();
    ASSERT(1 <= dwIndex);
    ASSERT(dwIndex <= m_dwSize);
    m_paEvents[dwIndex-1] = pEvent;
    pEvent->m_dwQueueIndex = dwIndex;
    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Move"

VOID CPriorityQueue::Move(DWORD dwDest, DWORD dwSource)
{
    DPF_ENTER();
    ASSERT(1 <= dwDest);
    ASSERT(dwDest <= m_dwSize);
    ASSERT(1 <= dwSource);
    ASSERT(dwSource <= m_dwSize);
    if(dwSource != dwDest){
        m_paEvents[dwDest-1] = m_paEvents[dwSource-1];
        m_paEvents[dwDest-1]->m_dwQueueIndex = dwDest;
        m_paEvents[dwSource-1] = 0;
    }
    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::At"

__inline PTRACK_EVENT_CONTEXT CPriorityQueue::At(DWORD dwIndex)
{
    DPF_ENTER();
    ASSERT(1 <= dwIndex);
    ASSERT(dwIndex <= m_dwSize);
    PTRACK_EVENT_CONTEXT pResult = m_paEvents[dwIndex-1];
    ASSERT(pResult);
    return pResult;
}

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Swap"

VOID CPriorityQueue::Swap(DWORD dwIndex1, DWORD dwIndex2)
{
    DPF_ENTER();

    PTRACK_EVENT_CONTEXT pTemp = At(dwIndex1);
    AtPut(dwIndex1, At(dwIndex2));
    AtPut(dwIndex2, pTemp);
}

#ifdef DBG

#undef DPF_FNAME
#define DPF_FNAME "CPriorityQueue::Verify"

VOID CPriorityQueue::Verify()
{

    if(Initialized()){
        ASSERT(m_paEvents);
        ASSERT(m_dwCapacity);
        ASSERT(m_dwCapacity >= m_dwSize);
        DWORD dwMaxSize = m_dwSize;
        if(dwMaxSize > m_dwCapacity){
            dwMaxSize = m_dwCapacity;
        }

#ifndef DO_FULL_VERIFY_PRIORITYQUEUE
        if(dwMaxSize > 20){
            dwMaxSize = 20;
        }
#endif
        for(DWORD i = 1; i <= dwMaxSize; i++){
            PTRACK_EVENT_CONTEXT pEvent = At(i);
            ASSERT(pEvent->m_dwQueueIndex == i);
            int parent = i / 2;
            if(parent>0){
                if( !m_paEvents[parent-1]->IsLessThan(m_paEvents[i-1]) ){
                    DPF_ERROR("Error: parent: %d is not less than child: %d\n", parent, i);
                }
            }
        }
    }
}

#endif // DBG

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// sequencer methods
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#undef DPF_FNAME
#define DPF_FNAME "CEngine::RemoveCueFromSequencerList"

HRESULT CEngine::RemoveCueFromSequencerList(CSoundCue *pCue)
{

    HRESULT hr = S_OK;
    DPF_ENTER();
    ASSERT(pCue);

    ENTER_EXTERNAL_METHOD();

    RemoveEntryList(&pCue->m_SeqListEntry);    
    pCue->Release();
    
    return hr;

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::AddCueToSequencerList"

HRESULT CEngine::AddCueToSequencerList(CSoundCue *pCue)
{
    HRESULT hr = S_OK;
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    InsertTailList(&m_lstActiveCues,&pCue->m_SeqListEntry);
    pCue->AddRef();


    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::InitializeSequencer"

HRESULT CEngine::InitializeSequencer(DWORD dwMaxConcurrentEvents)
{

    HRESULT hr = S_OK;
    AutoIrql();

    if(m_bAllowQueueing){

        //
        // Already initialized
        //

        return E_FAIL;
    }

    m_bAllowQueueing = TRUE;

    hr = HRFROMP(m_pQueue = NEW(CPriorityQueue));

    if(SUCCEEDED(hr))
    {
        hr = m_pQueue->Initialize(dwMaxConcurrentEvents);
    }

    SetTimeOffset();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::GetTime"

VOID CEngine::GetTime(LPREFERENCE_TIME prtCurrent)
{
    DPF_ENTER();
    AutoIrql();

    DWORD dwPosition = *((PDWORD)0xfe80200c);

    //
    // Check if audio hw counter wrapped
    //

    LONGLONG delta;
    if(dwPosition < m_dwLastPosition){

        if(dwPosition < 100000 && m_dwLastPosition > (1 << 30) ){

            DPF_WARNING("Sample counter wrapped (as it should every 24 hours. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = ((((LONGLONG) 1) << 32) + dwPosition) - m_dwLastPosition;

        } else {

            DPF_WARNING("Sample counter decreased unexpectedly. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = 0;
            m_dwLastPosition = dwPosition;

        }

    } else {

        delta = dwPosition - m_dwLastPosition;

    }

    m_dwLastPosition = dwPosition;
    m_llSampleTime += delta;

    LONGLONG llTemp = m_llSampleTime * 10000;
    llTemp /= 48000;
    llTemp *= 1000;
    *prtCurrent = llTemp;


    DPF_LEAVE_VOID();
    return;
}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::ConvertTimeValues"

VOID CEngine::CreateEventTimeStamp(PTRACK_CONTEXT pTrack, PTRACK_EVENT_CONTEXT pEventContext)
{

    ASSERT(pTrack->wSamplesPerSec);        

    //
    // the event time is calculated based on 
    // 1)the source playback frequency of the track
    // 2)the sample count offset into the track of the particular event
    // 3)the track starting time (when the first PlayEvent was processed)
    // 4) the offset between the audio hw clock and the system clock
    //

    
    LONGLONG llTemp = pEventContext->m_pEventHeader->lSampleTime * 10000;
    llTemp /= pTrack->wSamplesPerSec;
    llTemp *= 1000;
    pEventContext->m_rtTimeStamp = llTemp;

    //
    // add track starting time (this value came from the audio hw clock)
    //

    pEventContext->m_rtTimeStamp += pTrack->rtStartTime;

    //
    // add offset of audio clock from system clock
    //

    pEventContext->m_rtTimeStamp += m_rtTimeOffset;

}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::GetEvent"

HRESULT CEngine::GetEvent(TRACK_EVENT_CONTEXT** ppEvent)
{
    ASSERT(ppEvent);
    DPF_ENTER();

    HRESULT hr = HRFROMP(*ppEvent = NEW(TRACK_EVENT_CONTEXT));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::FreeAllEvents"

VOID CEngine::FreeAllEvents()
{
    AutoIrql();
    DPF_ENTER();
    if(m_pQueue->Initialized()){
        PTRACK_EVENT_CONTEXT pEvent;
        while(pEvent = m_pQueue->Pop()){
            FreeEvent(pEvent);
        }
    }
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::FreeEvent"

VOID CEngine::FreeEvent(PTRACK_EVENT_CONTEXT pEvent)
{
    AutoIrql();
    ASSERT(pEvent);
    
    DPF_ENTER();

    if (pEvent->m_pTrack)
    {

        DPF_BLAB("Freeing Event (0x%x) type %d, track %x",
            pEvent,
            pEvent->m_pEventHeader->wType,
            pEvent->m_pTrack);
        RemoveEntryList(&pEvent->m_ListEntry);

    }

    if (pEvent->m_pEventHeader->dwFlags & XACT_FLAG_EVENT_RUNTIME){

        //
        // API supplied event points to allocated context
        //

        DELETE(pEvent->m_pEventHeader);
    }

    DELETE(pEvent);
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::FreeEventsAtOrAfter"

VOID CEngine::FreeEventsAtOrAfter(PTRACK_CONTEXT pTrack, REFERENCE_TIME timeStamp)
{
    AutoIrql();
    PTRACK_EVENT_CONTEXT pEvent;
    PLIST_ENTRY pEntry;
    REFERENCE_TIME rtCurrent;

    DPF_ENTER();

    //
    // since we are at raised irql we can traverse the event list associated with a voice
    // without asking the track to do it 
    //

    ASSERT(pTrack);

    pEntry = pTrack->lstEvents.Flink;

    GetTime(&rtCurrent);

    // Add timing offset. 
    timeStamp += rtCurrent;

    while (pEntry != &pTrack->lstEvents) {

        pEvent = CONTAINING_RECORD(pEntry, TRACK_EVENT_CONTEXT, m_ListEntry);

        //
        // grab the next pointer before removing this event from the list...
        //

        pEntry = pEntry->Flink;

        //
        // make sure the event was actually queued
        // it can exist in the track list without being in the priority queue
        // since this call could have pre-empted the enqueue
        //

        if((pEvent->m_rtTimeStamp >= timeStamp) && pEvent->m_dwQueueIndex){
            m_pQueue->Remove(pEvent);            
        }

        FreeEvent(pEvent);

    }

}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::SetTimeOffset"

VOID CEngine::SetTimeOffset()
{
    REFERENCE_TIME rtSampleTime,rtSystemTime;

    //
    // the audio hw clock and the system clock are two independent timers
    // both values returned below are in unsing of 100 nsecs.
    // Once in a while we adjust the offset between the clocks to create
    // a time offset used to convert event timestamps (that are in audio hw sampletime)
    // to absolute system times
    //

    AutoIrql();
    GetTime(&rtSampleTime);
    KeQuerySystemTime((PLARGE_INTEGER)&rtSystemTime);

    m_rtTimeOffset = rtSystemTime - rtSampleTime;

}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::Enqueue"

HRESULT CEngine::Enqueue(PTRACK_EVENT_CONTEXT pEvent)
{
    HRESULT hr = S_OK;
    DPF_ENTER();

    REFERENCE_TIME rtCurrentSystemTime;
    

    BOOL bExecuteNow = FALSE;
    BOOL bProcessQueueUpToEvent = FALSE;
        
    KeQuerySystemTime((PLARGE_INTEGER)&rtCurrentSystemTime);
    
    if(rtCurrentSystemTime >= pEvent->m_rtTimeStamp){
        
        bExecuteNow = TRUE;
        bProcessQueueUpToEvent = TRUE;
        
    }
    
    // If the event is scheduled for now or earlier, execute it right away.
    if (bExecuteNow){

        AutoIrql();

        if(bProcessQueueUpToEvent){
            DispatchEventsUntil(&pEvent->m_rtTimeStamp, &rtCurrentSystemTime);
        }

        hr = DispatchEvent(pEvent);

    } else {

        AutoIrql();

        if(!m_bAllowQueueing){
            return E_FAIL;
        }

        pEvent->m_dwQueueIndex = 0;         

        hr = m_pQueue->Push(pEvent);
                
        if(SUCCEEDED(hr)){
            SetTimer();
        }

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::Dispatch"

HRESULT CEngine::Dispatch()
{
    // Execute everything that's less than or equal to now.
    HRESULT hr = S_OK;
    DPF_ENTER();    

    REFERENCE_TIME now;
    KeQuerySystemTime((PLARGE_INTEGER) &now);

    m_bTimerSet = FALSE;

    if(SUCCEEDED(hr)){
        hr = DispatchEventsUntil(&now, &now);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::DispatchEventsUntil"

HRESULT CEngine::DispatchEventsUntil(const REFERENCE_TIME* pTime, const REFERENCE_TIME* pNow)
{
    HRESULT hr = S_OK;
    DPF_ENTER();

    BOOL bFirstEvent = TRUE;
    if(SUCCEEDED(hr)){

        PTRACK_EVENT_CONTEXT pEvent;

        while(pEvent = m_pQueue->PopIfLessThanOrEqual(pNow)){
            hr = DispatchEvent(pEvent);
        }

    }

    SetTimer();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CEngine::DispatchEvent"

HRESULT CEngine::DispatchEvent(PTRACK_EVENT_CONTEXT pEventContext)
{

    ASSERT_IN_DPC;
    HRESULT hr = S_OK;

    LPDIRECTSOUNDBUFFER pDSBuffer;
    LPDIRECTSOUNDSTREAM pDSStream;
    
    PXACT_TRACK_EVENT pEvent = (PXACT_TRACK_EVENT) pEventContext->m_pEventHeader;
    CSoundSource *pSoundSource = pEventContext->m_pTrack->pSoundSource;

    if (pSoundSource) {
        pDSBuffer = pSoundSource->GetDSoundBuffer();
        pDSStream = pSoundSource->GetDSoundStream();
    }

    DPF_ENTER();
    
    PrintTimeStamps("DispatchEvent",pEventContext, pEventContext->m_rtTimeStamp,0);

    switch (pEvent->Header.wType) {
    
    case eXACTEvent_PitchAndVolumeVariation:
        CreateEventVariation(pEventContext);
        break;

    case eXACTEvent_PlayWithPitchAndVolumeVariation:
        CreateEventVariation(pEventContext);

        //
        // fall in below so we can now play the variation
        //

    case eXACTEvent_Play:
        
        ASSERT(pSoundSource);
        hr = pSoundSource->Play();        
        pEventContext->m_pTrack->pSoundCue->ProcessRuntimeEvent(pEvent);
        break;

    case eXACTEvent_Stop:

        //
        // stop the voice playing the current wave/fxin
        //

        ASSERT(pSoundSource);
        hr = pSoundSource->Stop();
        break;

    case eXACTEvent_SetFrequency:

        if (pDSBuffer) {
            hr = pDSBuffer->SetFrequency((DWORD)pEvent->EventData.SetFrequency.wFrequency);
        } else {
            hr = pDSStream->SetFrequency((DWORD)pEvent->EventData.SetFrequency.wFrequency);
        }
        break;

    case eXACTEvent_SetVolume:

        if (pDSBuffer) {
            hr = pDSBuffer->SetVolume((LONG)pEvent->EventData.SetVolume.sVolume);
        } else {
            hr = pDSStream->SetVolume((LONG)pEvent->EventData.SetVolume.sVolume);
        }
        break;

    case eXACTEvent_SetHeadroom:

        if (pDSBuffer) {
            hr = pDSBuffer->SetHeadroom((DWORD)pEvent->EventData.SetHeadroom.wHeadroom);
        } else {
            hr = pDSStream->SetHeadroom((DWORD)pEvent->EventData.SetHeadroom.wHeadroom);
        }
        break;

    case eXACTEvent_SetLFO:

        if (pDSBuffer) {
            hr = pDSBuffer->SetLFO(&pEvent->EventData.SetLFO.Desc);
        } else {
            hr = pDSStream->SetLFO(&pEvent->EventData.SetLFO.Desc);
        }
        break;

    case eXACTEvent_SetEG:

        if (pDSBuffer) {
            hr = pDSBuffer->SetEG(&pEvent->EventData.SetEG.Desc);
        } else {
            hr = pDSStream->SetEG(&pEvent->EventData.SetEG.Desc);
        }
        break;

    case eXACTEvent_SetFilter:

        if (pDSBuffer) {
            hr = pDSBuffer->SetFilter(&pEvent->EventData.SetFilter.Desc);
        } else {
            hr = pDSStream->SetFilter(&pEvent->EventData.SetFilter.Desc);
        }
        break;

    case eXACTEvent_SetEffectData:

        hr = m_pDirectSound->SetEffectData(
            (DWORD)pEvent->EventData.SetEffectData.wEffectIndex,
            (DWORD)pEvent->EventData.SetEffectData.wOffset,
            &pEvent->EventData.SetEffectData.dwData,
            (DWORD)pEvent->EventData.SetEffectData.wDataSize,
            DSFX_IMMEDIATE
            );
        
        break;
    case eXACTEvent_Marker:

        //
        // a marker event is purely a notification generator
        //

        pEventContext->m_pTrack->pSoundCue->ProcessRuntimeEvent(pEvent);
        break;
        
    case eXACTEvent_SetMixBinVolumes:

        DSMIXBINS dsMixBins;
        dsMixBins.dwMixBinCount = pEvent->EventData.SetMixBinVolumes.dwCount;
        dsMixBins.lpMixBinVolumePairs = pEvent->EventData.SetMixBinVolumes.aVolumePairs;

        if (pDSBuffer) {
            hr = pDSBuffer->SetMixBinVolumes(&dsMixBins);
        } else {
            hr = pDSStream->SetMixBinVolumes(&dsMixBins);
        }

        break;

    case eXACTEvent_LoopStart:
        break;
        
    case eXACTEvent_LoopEnd:
        break;
                    
    default:
        DPF_WARNING("(0x%x) Event (%s) not recognised",
            this,
            pEvent,
            g_aszXACTEventNames[pEvent->Header.wType]);
        break;
    }

    //
    // the event has been dispatched. we can now remove it from the track event list
    // and release it
    //

    FreeEvent(pEventContext);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

HRESULT CEngine::CreateEventVariation(PTRACK_EVENT_CONTEXT pEventContext)
{

    
    HRESULT hr = S_OK;

    ASSERT_IN_DPC;
    KeSaveFloatingPointState(&m_fps);

    //
    // we will touch fp state, so save it here
    //


    FLOAT fTemp = 0.0f, fRange = 0.0f, fRandom = 1.0f;
    
    LPDIRECTSOUNDBUFFER pDSBuffer;
    LPDIRECTSOUNDSTREAM pDSStream;
    
    PXACT_TRACK_EVENT pEvent = (PXACT_TRACK_EVENT) pEventContext->m_pEventHeader;
    PXACT_EVENT_PITCH_VOLUME_VAR_DESC pVarDesc = NULL;

    ASSERT (pEventContext->m_pTrack->pSoundSource);
    pDSBuffer = pEventContext->m_pTrack->pSoundSource->GetDSoundBuffer();
    pDSStream = pEventContext->m_pTrack->pSoundSource->GetDSoundStream();
    
    switch (pEvent->Header.wType) {
    case eXACTEvent_PitchAndVolumeVariation:
        pVarDesc = &pEvent->EventData.PitchAndVolumeVariation.VarDesc;

    case eXACTEvent_PlayWithPitchAndVolumeVariation:

        if (pVarDesc == NULL)
            pVarDesc = &pEvent->EventData.PlayWithPitchAndVolumeVariation.VarDesc;

        ULONG seed = (ULONG)pEventContext->m_rtTimeStamp;
        fRandom = (FLOAT)(RtlRandom(&seed) & 0x7FFFFFFF);
        fRandom = fRandom/(FLOAT)0x7FFFFFFF;

        fRange = (FLOAT)(pVarDesc->Pitch.sPitchHi - 
            pVarDesc->Pitch.sPitchLo);
        
        //
        // create a random pitch value
        // 
        
        fTemp = fRandom*fRange + pVarDesc->Pitch.sPitchLo;
        if (pDSBuffer) {
            hr = pDSBuffer->SetPitch((LONG)fTemp);
        } else {
            hr = pDSStream->SetPitch((LONG)fTemp);
        }

        //
        // create a random volume value
        // 
        
        fRange = (FLOAT)(pVarDesc->Volume.sVolHi - 
            pVarDesc->Volume.sVolLo);
        

        fTemp = fRandom*fRange + pVarDesc->Volume.sVolLo;
        if (pDSBuffer) {
            hr = pDSBuffer->SetVolume((LONG)fTemp);
        } else {
            hr = pDSStream->SetVolume((LONG)fTemp);
        }

        break; 
        
    } // switch


    KeRestoreFloatingPointState(&m_fps);
    return hr;
   
}

#undef DPF_FNAME
#define DPF_FNAME "CEngine::SetTimer"

VOID CEngine::SetTimer()
{

    AutoIrql();

    REFERENCE_TIME rtNextEventTime;
    if(m_pQueue->GetNextEventTime(&rtNextEventTime)){
        
        if(!m_bTimerSet || (rtNextEventTime < m_rtNextEventTime)){
            
            m_rtNextEventTime = rtNextEventTime;
            m_bTimerSet = TRUE;
            
            KeSetTimer(&m_TimerObject, * (LARGE_INTEGER*) &rtNextEventTime, &m_DpcObject); 
            
        }
        
    }

    return;
}

VOID CEngine::DPCTimerCallBack(
        PKDPC Dpc,
        PVOID DeferredContext,
        PVOID SystemArgument1,
        PVOID SystemArgument2
        )
{
    ((CEngine*) DeferredContext)->Dispatch();
}


#if DBG

#undef DPF_FNAME
#define DPF_FNAME "CEngine::PrintTimeStampInfo"

VOID CEngine::PrintTimeStamps(LPCSTR lpcszName, TRACK_EVENT_CONTEXT *pEvent, REFERENCE_TIME rt, REFERENCE_TIME rt1)
{


    LARGE_INTEGER time,time1;
    time.QuadPart = rt;
    time1.QuadPart = rt1;

    if (rt1 == 0) {
        KeQuerySystemTime(&time1);
    }

    //
    // convert to milliseconds
    //

    time.QuadPart = time.QuadPart/10000;
    time1.QuadPart = time1.QuadPart/10000;
    
    if (pEvent) {
        
        DPF_BLAB("Function (%s), EventType (%s), EventTime (%u %u), currentTime (%u %u)\n",             
            lpcszName,
            g_aszXACTEventNames[pEvent->m_pEventHeader->wType],
            time.HighPart,
            time.LowPart,
            time1.HighPart,
            time1.LowPart);

    } else {
        
        DPF_BLAB("Function (%s), EventTime (%u %u), currentTime (%u %u)\n", 
            lpcszName,
            time.HighPart,
            time.LowPart,
            time1.HighPart,
            time1.LowPart);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\xact\runtime\inc\xacti.h ===
/***************************************************************************
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xacti.h
 *  Content:    XACT runtime main internal header file.
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *  01/23/2002  georgioc  Created.
 *
 ***************************************************************************/

#ifndef __XACTI_H__
#define __XACTI_H__


#pragma code_seg("XACTENG")
#pragma data_seg("XACTENG_RW")
#pragma const_seg("XACTENG_RD")
#pragma bss_seg("XACTENG_URW")


#define NAMESPACE XACT

#include "common.h"

//
// use a bunch of dsound common utility functions for debug prints, memory alloc etc
//

#include <wavbndlr.h>

//
// API defines for XACT
//

#include "xactp.h"

//
// critical section
//

EXTERN_C CRITICAL_SECTION g_XACTCriticalSection;

__inline BOOL XACTEnterCriticalSection(void)
{
    if(PASSIVE_LEVEL != KeGetCurrentIrql())
    {
        return FALSE;
    }

    EnterCriticalSection(&g_XACTCriticalSection); 

    return TRUE;
}

__inline void XACTLeaveCriticalSection(void)
{
    LeaveCriticalSection(&g_XACTCriticalSection);
}


namespace XACT {

//
// Automatic (functon-scope) locking mechanism
//

class CAutoLock
{
private:
    BOOL                    m_fLocked;

public:
    CAutoLock(void);
    ~CAutoLock(void);
};

__inline CAutoLock::CAutoLock(void)
{
    m_fLocked = (BOOLEAN)XACTEnterCriticalSection();
}

__inline CAutoLock::~CAutoLock(void)
{
    if(m_fLocked)
    {
        XACTLeaveCriticalSection();
    }
}

#define AutoLock() \
    CAutoLock __AutoLock


#define ENTER_EXTERNAL_FUNCTION() \
    AutoLock()

#define ENTER_EXTERNAL_METHOD() \
    AutoLock(); \

#define _ENTER_EXTERNAL_METHOD(name) \
    AutoLock(); \


class CLocalAutoLock
{
private:
    CRITICAL_SECTION        *m_pCr;
    
public:
    CLocalAutoLock(CRITICAL_SECTION *pCr);
    ~CLocalAutoLock(void);
};

__inline CLocalAutoLock::CLocalAutoLock(CRITICAL_SECTION *pCr)
{
    if(PASSIVE_LEVEL == KeGetCurrentIrql())
    {
        EnterCriticalSection(pCr); 
        m_pCr = pCr;
    } else {
        m_pCr = NULL;
    }
    
}

__inline CLocalAutoLock::~CLocalAutoLock(void)
{
    if(m_pCr)
    {
        LeaveCriticalSection(m_pCr);
    }
}




#define ENTER_INTERNAL_METHOD() \
    CLocalAutoLock Lock(&m_cr); \


class CSoundBank;
class CSoundCue;
class CSoundSource;
class CWaveBank;
class CSequencer;
class CEngine;
class CPriorityQueue;

//
// forward declarations
//

typedef struct _TRACK_CONTEXT TRACK_CONTEXT;
typedef struct _TRACK_EVENT_CONTEXT TRACK_EVENT_CONTEXT;
typedef struct _NOTIFICATION_CONTEXT NOTIFICATION_CONTEXT;
typedef struct _CUE_INDEX_NOTIFICATION_CONTEXT CUE_INDEX_NOTIFICATION_CONTEXT;

//
// globals
//

EXTERN_C CEngine * g_pEngine;


//
// xact runtime engine implementation object
//

#define XACT_ENGINE_MAX_CONCURRENT_EVENTS   100
#define XACT_ENGINE_PACKETS_PER_STREAM 2
#define XACT_ENGINE_SCHEDULE_QUANTUM	(5*10000) //5ms in units of 100nsecs

class CEngine
    : public IXACTEngine
{
public:
    CEngine();
    ~CEngine();
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE LoadDspImage(PVOID pvBuffer, DWORD dwSize, LPCDSEFFECTIMAGELOC pEffectLoc);
    HRESULT STDMETHODCALLTYPE CreateSoundSource(DWORD dwFlags, PXACTSOUNDSOURCE *ppSoundSource);
    HRESULT STDMETHODCALLTYPE CreateSoundBank(PVOID pvBuffer, DWORD dwSize, PXACTSOUNDBANK *ppSoundBank);
    HRESULT STDMETHODCALLTYPE RegisterWaveBank(PVOID pvData, DWORD dwSize, PXACTWAVEBANK *ppWaveBank);
    HRESULT STDMETHODCALLTYPE RegisterStreamedWaveBank(PVOID pvStreamingBuffer, DWORD dwSize, HANDLE hFileHandle, DWORD dwOffset, PXACTWAVEBANK *ppWaveBank);
    HRESULT STDMETHODCALLTYPE UnRegisterWaveBank(PXACTWAVEBANK pWaveBank);
    HRESULT STDMETHODCALLTYPE SetMasterVolume(LONG lVolume);
    HRESULT STDMETHODCALLTYPE SetListenerParameters(LPCDS3DLISTENER pcDs3dListener, LPCDSI3DL2LISTENER pds3dl, DWORD dwApply);
    HRESULT STDMETHODCALLTYPE GlobalPause(BOOL bPause); 
    HRESULT STDMETHODCALLTYPE RegisterNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc);
    HRESULT STDMETHODCALLTYPE UnRegisterNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc);
    HRESULT STDMETHODCALLTYPE GetNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc, PXACT_NOTIFICATION pNotificationEvent);
    HRESULT STDMETHODCALLTYPE FlushNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc);
    HRESULT STDMETHODCALLTYPE CommitDeferredSettings();
    HRESULT STDMETHODCALLTYPE ScheduleEvent(XACT_TRACK_EVENT *pEventDesc, PXACTSOUNDCUE pSoundCue, DWORD dwTrackIndex);

    //
    // non exported methods
    //

    HRESULT Initialize(PXACT_RUNTIME_PARAMETERS pParams);
    HRESULT GetWaveBank(LPCSTR lpFriendlyName, CWaveBank **ppWaveBank);
    VOID    DoWork();
    HRESULT CreateSoundSourceInternal(DWORD dwFlags, CWaveBank *pWaveBank, CSoundSource **ppSoundSource);
    VOID IsDuplicateWaveBank(CWaveBank *pWaveBank);

    BOOL   IsValidSoundSourceFlags(DWORD dwFlags)
    {
        if (!(dwFlags & XACT_MASK_SOUNDSOURCE_FLAGS)) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    //
    // notifications
    //

    VOID HandleNotificationRegistration(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc, BOOL bRegister);
    VOID AddNotificationToPendingList(NOTIFICATION_CONTEXT *pNotification);
    CUE_INDEX_NOTIFICATION_CONTEXT *GetCueNotificationContext(NOTIFICATION_CONTEXT *pContext,DWORD dwSoundCueIndex);

    //
    // sequencer methods
    //

    STDMETHOD(InitializeSequencer)(DWORD dwMaxEvents);
	HRESULT AddCueToSequencerList(CSoundCue *pCue);
    HRESULT RemoveCueFromSequencerList(CSoundCue *pCue);

    VOID GetTime(LPREFERENCE_TIME prtCurrent);

    STDMETHOD(Enqueue)(TRACK_EVENT_CONTEXT* pEvent);
    VOID FreeAllEvents();
    HRESULT CreateEventVariation(TRACK_EVENT_CONTEXT *pEventContext);
    VOID FreeEventsAtOrAfter(TRACK_CONTEXT *pTrack, REFERENCE_TIME timeStamp);
    VOID CreateEventTimeStamp(TRACK_CONTEXT *pTrack, TRACK_EVENT_CONTEXT *pEventContext);

#if DBG
    VOID PrintTimeStamps(LPCSTR lpcszName, TRACK_EVENT_CONTEXT *pEvent, REFERENCE_TIME rt, REFERENCE_TIME rt1);
#else
    VOID PrintTimeStamps(LPCSTR lpcszName, TRACK_EVENT_CONTEXT *pEvent, REFERENCE_TIME rt, REFERENCE_TIME rt1)
    {}
#endif

    VOID SetTimeOffset();

private:

    //
    // This method is called at DPC time to dispatch any currently waiting events
    //

    STDMETHOD(Dispatch)();
    STDMETHOD(DispatchEventsUntil)(const REFERENCE_TIME* pTime, const REFERENCE_TIME* pNow);
    STDMETHOD(DispatchEvent)(TRACK_EVENT_CONTEXT* pEvent);

    VOID SetTimer();

    static VOID DPCTimerCallBack(
        PKDPC Dpc,
        PVOID DeferredContext,
        PVOID SystemArgument1,
        PVOID SystemArgument2
        );

    HRESULT GetEvent(TRACK_EVENT_CONTEXT** ppEvent);
    VOID FreeEvent(TRACK_EVENT_CONTEXT* pEvent);

protected:

    
    friend class CSoundSource;
    HRESULT AllocateSoundSource(CSoundSource **ppSoundSource);
    void FreeSoundSource(CSoundSource *pSoundSource);


    LPDSEFFECTIMAGEDESC     m_pDspImageDesc;
    LPDIRECTSOUND           m_pDirectSound;

    LIST_ENTRY  m_lstAvailable2DBuffers;
    LIST_ENTRY  m_lstAvailable3DBuffers;
    LIST_ENTRY  m_lstAvailableStreams;

    LIST_ENTRY  m_lstWaveBanks;
    LIST_ENTRY  m_lstSoundBanks;

    LIST_ENTRY  m_lstActiveCues;
    LIST_ENTRY  m_lstPendingNotifications;

    DWORD       m_dwTotalVoiceCount;
    DWORD       m_dwRefCount;

    XACT_RUNTIME_PARAMETERS m_RuntimeParams;

    //
    // sequencer variables
    //

    BOOL            m_bAllowQueueing;
    BOOL            m_bTimerSet;

    KTIMER          m_TimerObject;
    KDPC            m_DpcObject;
    KFLOATING_SAVE  m_fps;


    DWORD           m_dwLastPosition;
    ULONGLONG       m_llSampleTime;
    REFERENCE_TIME  m_rtNextEventTime;
    REFERENCE_TIME  m_rtTimeOffset;

    CPriorityQueue  *m_pQueue;

};

//
// context used for tracking the cues associated with a wavebank
//

typedef struct _WAVEBANK_CUE_CONTEXT {

    CSoundCue   *pSoundCue;
    LIST_ENTRY  ListEntry;

} WAVEBANK_CUE_CONTEXT, *PWAVEBANK_CUE_CONTEXT;

//
// notification structs
//

typedef struct _CUE_INDEX_NOTIFICATION_CONTEXT {

    LIST_ENTRY  ListEntry;
    DWORD       dwSoundCueIndex;
    BOOL        bPersist;

} CUE_INDEX_NOTIFICATION_CONTEXT, *PCUE_INDEX_NOTIFICATION_CONTEXT, *LPCUE_INDEX_NOTIFICATION_CONTEXT;

//
// notification context
//

typedef struct _NOTIFICATION_CONTEXT {

    BOOL                    bRegistered;
    XACT_NOTIFICATION       PendingNotification;
    LIST_ENTRY              lstRegisteredCues;
    LIST_ENTRY              ListEntry;

} NOTIFICATION_CONTEXT, *PNOTIFICATION_CONTEXT, *LPNOTIFICATION_CONTEXT;


//
// soundbank object
//

class CSoundBank
    : public IXACTSoundBank, public CRefCount
{
public:
    CSoundBank();
    ~CSoundBank();
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE GetSoundCueIndexFromFriendlyName(LPCSTR lpFriendlyName, PDWORD pdwCueIndex);
    HRESULT STDMETHODCALLTYPE Play( DWORD dwCueIndex, PXACTSOUNDSOURCE pSoundSource, DWORD dwFlags, PXACTSOUNDCUE *ppCue);
    HRESULT STDMETHODCALLTYPE Stop( DWORD dwCueIndex, DWORD dwFlags, PXACTSOUNDCUE pCue);

    //
    // non exported
    //

    NOTIFICATION_CONTEXT * GetNotificationContext(DWORD dwType);    
    VOID ProcessRuntimeEvent(XACT_TRACK_EVENT *pEventDesc);


private:

    friend class CEngine;
    friend class CSoundCue;

    HRESULT Initialize(PVOID pvBuffer, DWORD dwSize);
#if DBG
    BOOL    IsValidCue(DWORD dwCueIndex)
    {
        
        if (dwCueIndex > m_pFileHeader->dwCueEntryCount) {
            return FALSE;
        }

        return TRUE;
    }

    BOOL    IsValidHeader()
    {
        
        if (((DWORD)XACT_SOUNDBANK_HEADER_SIGNATURE) != m_pFileHeader->dwSignature) {
            DPF_ERROR("Invalid soundbank signature in header");
            return FALSE;
        }

        if (XACT_SOUNDBANK_HEADER_VERSION != m_pFileHeader->dwVersion) {

            DPF_ERROR("Invalid version (%d) in header. Current %d",m_pFileHeader->dwVersion, XACT_SOUNDBANK_HEADER_VERSION);
            return FALSE;

        }

        return TRUE;
    }

    BOOL    IsValidSoundSourceForSound(DWORD dwSoundSourceFlags, DWORD dwSoundFlags)
    {
        if ((dwSoundSourceFlags & XACT_FLAG_SOUNDSOURCE_3D) && (dwSoundFlags & XACT_FLAG_SOUNDSOURCE_3D)) {
            return TRUE;
        } else if ((dwSoundSourceFlags & XACT_FLAG_SOUNDSOURCE_3D) && (dwSoundFlags & XACT_FLAG_SOUNDSOURCE_2D)) {
            return TRUE;
        } else if ((dwSoundSourceFlags & XACT_FLAG_SOUNDSOURCE_2D) && (dwSoundFlags & XACT_FLAG_SOUNDSOURCE_2D)) {
            return TRUE;
        } else {
            return FALSE;
        }
    }
#endif

    //
    // utility functions
    //

    PXACT_SOUNDBANK_CUE_ENTRY GetCueTable()
    {
        return (PXACT_SOUNDBANK_CUE_ENTRY) ((PUCHAR)m_pDataBuffer+sizeof(XACT_SOUNDBANK_FILE_HEADER));       
    }

    LPCSTR GetCueFriendlyName(DWORD dwCueIndex)
    {
        PXACT_SOUNDBANK_CUE_ENTRY pCueTable = GetCueTable();
        return pCueTable[dwCueIndex].szFriendlyName;
    }

    PXACT_SOUNDBANK_SOUND_ENTRY GetSoundTable()
    {
        return (PXACT_SOUNDBANK_SOUND_ENTRY) ((PUCHAR)m_pDataBuffer+sizeof(XACT_SOUNDBANK_FILE_HEADER)+
            sizeof(XACT_SOUNDBANK_CUE_ENTRY)*m_pFileHeader->dwCueEntryCount);     
    }

    PUCHAR GetBaseDataOffset()
    {
        return (PUCHAR)m_pDataBuffer;
    }

    void RemoveFromList(CSoundCue *pCue);    

protected:

    friend class CSoundCue;

    PXACT_SOUNDBANK_FILE_HEADER m_pFileHeader;

    PVOID   m_pDataBuffer;
    DWORD   m_dwDataSize;

    LIST_ENTRY  m_ListEntry;
    LIST_ENTRY  m_lstCues;

    DWORD       m_dwPlayingCount;

    NOTIFICATION_CONTEXT    m_aNotificationContexts[eXACTNotification_Max];

};

//
// Cue Object
//

class CSoundCue
    : public CRefCount
{
public:
    CSoundCue();
    ~CSoundCue();
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT Initialize(CSoundBank *pSoundBank, DWORD dwCueIndex, CSoundSource *pSoundSource);
    HRESULT STDMETHODCALLTYPE Play(DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE Stop(DWORD dwFlags);

    VOID DoWork();
    NOTIFICATION_CONTEXT * GetNotificationContext(DWORD dwType);    

    typedef enum _CUE_STATE{
        CUE_STATE_CREATED = 0,
        CUE_STATE_INITIALIZED,
        CUE_STATE_PLAYING,
        CUE_STATE_STOPPING,
        CUE_STATE_STOPPED
    } CUE_STATE;

    VOID GetWaveBank(DWORD dwWaveBankIndex, CWaveBank **ppWaveBank);
    LPCSTR GetFriendlyName()
    {
        return m_pSoundBank->GetCueFriendlyName(m_dwCueIndex);
    }

    PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY GetWaveBankTable()
    {
        return (PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY) ((PUCHAR)m_pSoundBank->GetBaseDataOffset() + m_pSoundEntry->dwWaveBankTableOffset);
    }

protected:

    friend class CSoundBank;
    friend class CWaveBank;
    friend class CEngine;

    CSoundBank                  *m_pSoundBank;

    PXACT_SOUNDBANK_SOUND_ENTRY m_pSoundEntry;

    LIST_ENTRY                  m_ListEntry;
    LIST_ENTRY                  m_SeqListEntry;
    PWAVEBANK_CUE_CONTEXT       m_paWaveBankEntries;
    DWORD                       m_dwCueIndex;


    HRESULT ScheduleTrackEvents(DWORD dwQuantum);
    HRESULT ScheduleRuntimeEvent(XACT_TRACK_EVENT *pEventDesc, DWORD dwTrackIndex);

    VOID ProcessRuntimeEvent(XACT_TRACK_EVENT *pEventDesc);
    
    BOOL IsPositional();

private:

    VOID CheckStateTransition(DWORD dwNewState, PDWORD pdwOldState);
    HRESULT SubmitEvent(TRACK_EVENT_CONTEXT *pEventContext);
    
    NOTIFICATION_CONTEXT        m_aNotificationContexts[eXACTNotification_Max];
    TRACK_CONTEXT               *m_paTracks;
    DWORD                       m_dwState;
    DWORD                       m_dwFlags;
    CSoundSource                *m_pControlSoundSource;

};

//
// soundsource object
//

class CSoundSource
    : public IXACTSoundSource, public CRefCount
{
public:
    CSoundSource();
    ~CSoundSource();
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply);
    HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply);
    HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
    HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins);
    HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins);

    //
    // utility functions
    //

    DWORD GetFlags()
    {
        DWORD dwSoundSourceFlags = 0;
        if (m_HwVoice.dwFlags & DSBCAPS_CTRL3D) {
            dwSoundSourceFlags |= XACT_FLAG_SOUNDSOURCE_3D;
        }

        return dwSoundSourceFlags;
    }

    BOOL IsPositional()
    {        
        return (m_HwVoice.dwFlags & DSBCAPS_CTRL3D);
    }

    __inline LPDIRECTSOUNDBUFFER GetDSoundBuffer()
    {

        return m_HwVoice.pBuffer;

    }

    __inline LPDIRECTSOUNDSTREAM GetDSoundStream()
    {

        return m_HwVoice.pStream;

    }

    BOOL IsPlaying()
    {

        DWORD dwStatus;

        if (m_HwVoice.pBuffer) {
            
            m_HwVoice.pBuffer->GetStatus(&dwStatus);
            return (dwStatus & DSBSTATUS_PLAYING);

        } else {

            m_HwVoice.pStream->GetStatus(&dwStatus);
            return (dwStatus & (DSSTREAMSTATUS_PLAYING | DSSTREAMSTATUS_PAUSED ));
        }

    }

    VOID SetWaveBankOwner(CWaveBank *pWaveBank)
    {

        m_pWaveBankOwner = pWaveBank;

    }

private:

    friend class CEngine;
    friend class CSoundBank;
    friend class CSequencer;
    friend class CSoundCue;
    friend class CWaveBank;

    HRESULT Initialize();
    HRESULT Stop();
    HRESULT Play();

    LIST_ENTRY              m_ListEntry;
    CWaveBank               *m_pWaveBankOwner;

protected:
    friend class CEngine;

    __inline void SetHwVoiceType(DWORD dwDSoundFlags)
    {
        //
        // dsound flags for buffer/stream
        //

        m_HwVoice.dwFlags = dwDSoundFlags;
    }
    
    struct {
        
        LPDIRECTSOUNDBUFFER     pBuffer;
        LPDIRECTSOUNDSTREAM     pStream;
        DWORD   dwFlags;

    } m_HwVoice;

};



// ****************************************************************************
// private objects
// ****************************************************************************

//
// wavebank object
//

class CWaveBank : public CRefCount
{
public:
    CWaveBank();
    ~CWaveBank();
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT Initialize(PVOID pBuffer, DWORD dwSize);
    HRESULT AllocateSoundSource(CSoundSource **ppSoundSource);
    VOID FreeSoundSource(CSoundSource *pSoundSource);

    VOID RemoveCueFromList(WAVEBANK_CUE_CONTEXT *pEntry);
    VOID AddCueToList(WAVEBANK_CUE_CONTEXT *pEntry);
    VOID StopAllCues();

    __inline LPWAVEBANKENTRY GetWaveBankEntry(DWORD dwWaveIndex)
    {

        return &m_WaveBankData.paMetaData[dwWaveIndex];

    }

    __inline HRESULT SetBufferData(LPDIRECTSOUNDBUFFER pBuffer)
    {

        ASSERT(pBuffer);
        return pBuffer->SetBufferData(m_WaveBankData.pvData, m_WaveBankData.dwDataSize);

    }

protected:
    friend class CEngine;

    WAVEBANKSECTIONDATA m_WaveBankData;
    LIST_ENTRY          m_lstAvailableSources;
    LIST_ENTRY          m_lstCues;
    LIST_ENTRY          m_ListEntry;

};

__inline ULONG CWaveBank::AddRef(void)
{
    _ENTER_EXTERNAL_METHOD("CWaveBank::AddRef");
    return CRefCount::AddRef();
}


__inline ULONG CWaveBank::Release(void)
{
    _ENTER_EXTERNAL_METHOD("CWaveBank::Release");
    return CRefCount::Release();
}

//
// track context
//

typedef struct _TRACK_CONTEXT {

    //
    // source voice for this track
    //

    CSoundSource        *pSoundSource;

    //
    // parent cue back pointer
    //

    CSoundCue           *pSoundCue;

    //
    // list of currently queued events
    //

	LIST_ENTRY          lstEvents;

    //
    // index into content for next event to process
    //

    WORD                wNextEventDataOffset;
    WORD                wNextEventIndex;

    //
    // loop start indices
    //

    WORD                wLoopStartEventDataOffset;
    WORD                wLoopStartEventIndex;

    //
    // current source playback frequency
    //

    WORD                wSamplesPerSec;
    
    //
    // remaining loop count
    //

    WORD                wLoopCount;

    //
    // timestamp in absolute system time
    //

    REFERENCE_TIME  rtStartTime;
    
    //
    // pointer to the track entry in the soundbank data block
    //

    PXACT_SOUNDBANK_TRACK_ENTRY   pContentEntry;

} TRACK_CONTEXT, *PTRACK_CONTEXT;


//
// track event context
//

typedef struct _TRACK_EVENT_CONTEXT {
    LIST_ENTRY      m_ListEntry;
    DWORD           m_dwQueueIndex;    
    PTRACK_CONTEXT  m_pTrack;
    PXACT_TRACK_EVENT_HEADER    m_pEventHeader;

    REFERENCE_TIME  m_rtTimeStamp;

    BOOL IsLessThanOrEqual(const REFERENCE_TIME* time) const;
    BOOL IsLessThan(const TRACK_EVENT_CONTEXT* other) const;
    BOOL IsGreaterThan(const TRACK_EVENT_CONTEXT* other) const;
    LONG Compare(const TRACK_EVENT_CONTEXT* other) const;

} TRACK_EVENT_CONTEXT, *PTRACK_EVENT_CONTEXT;

//
// priority queue used by sequencer
//

class CPriorityQueue {

public:
    CPriorityQueue();
    ~CPriorityQueue();

    HRESULT Initialize(DWORD maxSize);
    __inline BOOL Initialized() { return m_paEvents != 0; }
    PTRACK_EVENT_CONTEXT Pop();
    PTRACK_EVENT_CONTEXT PopIfLessThanOrEqual(const REFERENCE_TIME* pTime);
    BOOL GetNextEventTime(REFERENCE_TIME* pTime);
    VOID Remove(PTRACK_EVENT_CONTEXT pEvent);
    HRESULT Push(PTRACK_EVENT_CONTEXT pEvent);
    VOID AdjustEventTimes(REFERENCE_TIME delta);

#ifdef DBG
    VOID Verify();
    VOID Print();
    VOID Print2(bool bPrintEvents);
#endif

    __inline DWORD Size() { return m_dwSize; }
private:

    PTRACK_EVENT_CONTEXT Pop2();
    PTRACK_EVENT_CONTEXT At(DWORD index); // One based index into priority queue
    VOID AtPut(DWORD index, PTRACK_EVENT_CONTEXT pEvent);
    VOID Swap(DWORD index1, DWORD index2);
    VOID Move(DWORD dest, DWORD source);
    PTRACK_EVENT_CONTEXT* m_paEvents;
    DWORD m_dwCapacity;
    DWORD m_dwSize;

};

} //namespace





#endif // __XACTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\backend.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       backend.c
 *  Content:    converts our YUV format into a bitmap.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xmv.h>

#include "decoder.h"

/*
 * Convert our internal YUV format into a standard YUY2 buffer.
 */

static
void RenderToYUY2
(
    DWORD MBWidth, 
    DWORD MBHeight, 
    BYTE *pY, 
    BYTE *pU, 
    BYTE *pV,
    BYTE *pDestination, 
    DWORD DestinationPitch
)
{
    DWORD iWidthY;
    DWORD iWidthUV;
    DWORD PitchAdjust;

    DWORD x;

    // Make sure that our parameters are all 8-byte aligned.
    ASSERT(((DWORD)pY) % 8 == 0); 
    ASSERT(((DWORD)pU) % 8 == 0); 
    ASSERT(((DWORD)pV) % 8 == 0); 
    ASSERT(((DWORD)pDestination) % 8 == 0); 
    ASSERT(DestinationPitch % 8 == 0);

    iWidthY  = MACROBLOCK_SIZE * MBWidth;
    iWidthUV = BLOCK_SIZE * MBWidth;

    PitchAdjust = DestinationPitch - MBWidth * MACROBLOCK_SIZE * 2;

    while(MBHeight--)
    {
        x = MBWidth;

        while (x--)
        {
            __asm
            {
                mov         esi, pY
                mov         edi, pDestination
                mov         ecx, pU
                mov         edx, pV
                mov         eax, BLOCK_SIZE

            L1: movq        mm2, [ecx]          ; 8 U values
                movq        mm3, [edx]          ; 8 V values
                pxor        mm4, mm4
                pxor        mm6, mm6
                pxor        mm0, mm0
                pxor        mm1, mm1
                punpcklbw   mm4, mm2
                punpckhbw   mm6, mm2
                movq        mm5, mm4
                movq        mm7, mm6
                punpckhwd   mm5, mm0            ; spread Us into 4 MMX registers
                punpckhwd   mm7, mm0            ;   ..u...u...u...u...u...u...u...u.
                punpcklwd   mm4, mm0
                punpcklwd   mm6, mm0

                pxor        mm2, mm2
                add         ecx, iWidthUV
                add         edx, iWidthUV

                punpcklbw   mm0, mm3            ; spread Vs and then OR them into Us 
                punpcklwd   mm1, mm0            ;   v.u.v.u.v.u.v.u.v.u.v.u.v.u.v.u.
                punpckhwd   mm2, mm0
                por         mm4, mm1
                por         mm5, mm2

                movq        mm0, [esi]          ; 16 Y values from the current line
                movq        mm1, [esi+8]

                pxor        mm2, mm2
                punpckhbw   mm2, mm3
                pxor        mm3, mm3
                punpcklwd   mm3, mm2
                por         mm6, mm3
                pxor        mm3, mm3
                punpckhwd   mm3, mm2
                por         mm7, mm3

                add         esi, iWidthY        ; spread Ys and output the final results
                pxor        mm2, mm2            ;   vyuyvyuyvyuyvyuyvyuyvyuyvyuyvyuy
                movq        mm3, mm0
                punpcklbw   mm0, mm2
                por         mm0, mm4
                movq        [edi], mm0          ; notice that we output 32 bytes (4 qwords)
                punpckhbw   mm3, mm2            ; without any intervening memory access
                por         mm3, mm5            ; to achieve maximum memory write perf
                movq        [edi+8], mm3
                movq        mm3, mm1
                punpcklbw   mm1, mm2
                por         mm1, mm6
                movq        [edi+16], mm1
                punpckhbw   mm3, mm2
                por         mm3, mm7
                movq        [edi+24], mm3

                movq        mm0, [esi]          ; 16 Y values from the next line
                movq        mm1, [esi+8]
                add         edi, DestinationPitch
                pxor        mm2, mm2
                movq        mm3, mm0
                punpcklbw   mm0, mm2
                por         mm0, mm4
                movq        [edi], mm0
                punpckhbw   mm3, mm2
                por         mm3, mm5
                movq        [edi+8], mm3
                movq        mm3, mm1
                punpcklbw   mm1, mm2
                por         mm1, mm6
                movq        [edi+16], mm1
                punpckhbw   mm3, mm2
                por         mm3, mm7
                movq        [edi+24], mm3

                add         esi, iWidthY
                add         edi, DestinationPitch
                dec         eax
                jnz         L1
            }

            pY += MACROBLOCK_SIZE;
            pU += BLOCK_SIZE;
            pV += BLOCK_SIZE;

            pDestination += MACROBLOCK_SIZE * 2;
        }

        pY += (MACROBLOCK_SIZE - 1) * iWidthY;
        pU += (BLOCK_SIZE - 1) * iWidthUV;
        pV += (BLOCK_SIZE - 1) * iWidthUV;

        pDestination += PitchAdjust + DestinationPitch * (MACROBLOCK_SIZE - 1);
    }

    __asm emms;
}

/*
 * Converts the current YUV buffer into the format we want to display.
 */

void RenderBitmap
(
    XMVDecoder *pDecoder,
    D3DSurface *pSurface
)
{
    D3DLOCKED_RECT Rect;
    D3DSURFACE_DESC Desc;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, 0, D3DLOCK_TILED);

#if DBG

    if (Desc.Width != pDecoder->Width || Desc.Height != pDecoder->Height)
    {
        RIP("The target surface must have exactly the same size as the decoded video.");
    }

#endif DBG

    switch(Desc.Format)
    {
    case D3DFMT_YUY2:

        RenderToYUY2(pDecoder->MBWidth, 
                     pDecoder->MBHeight, 
                     pDecoder->pYDisplayed, 
                     pDecoder->pUDisplayed, 
                     pDecoder->pVDisplayed,
                     Rect.pBits, 
                     Rect.Pitch);

        break;

    default:
        RIP("Unsupported target surface format, only YUY2 is supported at this time.");
        break;
    }

#if DBG && 0

    // Draw a grid on top of the rendered frame so that we can figure out what
    // macroblocks contain the drawing errors.
    //
    {
        WORD *pPixel;
        DWORD x, y;

        for (y = 0; y < Desc.Height; y++)
        {
            pPixel = (WORD *)((BYTE *)Rect.pBits + y * Rect.Pitch);

            // Double the middle line.
            if (y % 16 == 0 || y == Desc.Height / 2 + 1)
            {
                for (x = 0; x < Desc.Width; x++)
                {
                    *pPixel = (*pPixel & 0xFF00) | 0x40;

                    pPixel++;
                }
            }
            else
            {
                for (x = 0; x < Desc.Width; x++)
                {
                    // Double the middle line.
                    if (x % 16 == 0 || x == Desc.Width / 2 + 1)
                    {
                        *pPixel = (*pPixel & 0xFF00) | 0x40;
                    }

                    pPixel++;
                }
            }
        }
    }

#endif DBG

    D3DSurface_UnlockRect(pSurface);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\decoder.h ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       decoder.h
 *  Content:    The main definitions for the XMV decoder.
 *
 ****************************************************************************/

#pragma once

/* 
 * Constants
 */

// Y block size.
#define MACROBLOCK_SIZE     16

// UV block size
#define BLOCK_SIZE          8

/* 
 * Debug stuff
 */

#if DBG
#    define RIP(msg)   XDebugError("XMV", msg)
#else
#    define RIP(msg)
#endif

/*
 * It really sucks that we have three different structures to represent the
 * same data for audio information, but it is really handy to have this info
 * in exact the form we need in each of the three places (file, API and 
 * implementation).
 */

typedef struct _XMVAudioImplementation
{
    // The WAVE_FORMAT tag that describes how the audio data in the stream is
    // encoded.  This can be either WAVE_FORMAT_PCM or WAVE_FORMAT_ADPCM.
    //
    DWORD WaveFormat;

    // The number of channels in the audio stream.  Can be 1, 2, 4 or 6.
    DWORD ChannelCount;

    // The number of samples per second (Hz) in the audio stream.
    DWORD SamplesPerSecond;

    // The number of bits in each sample.  
    DWORD BitsPerSample;
}
XMVAudioImplementation;

/* 
 * Information we need to save about the macroblocks while decoding.  We need
 * to keep two rows of these around for the decoding to work properly.
 *
 * We pre-allocate this along with the decoder simply to avoid doing memory
 * allocations each time we go to decode a frame.  We always allocate on blank
 * dummy entry to the left of our entries so that the CBPCY code doesn't have
 * to do any special casing.
 */

typedef struct _XMVMacroblockCBPCY
{
    BYTE Y1:1;
    BYTE Y2:1;
    BYTE Y3:1;
    BYTE Y4:1;
    BYTE U:1;
    BYTE V:1;
}
XMVMacroblockCBPCY;

/*
 * Holds all of the information needed by the block decoder in a handy little
 * package.  Saves us from 
 */

typedef struct _XMVACCoefficientDecoderTable
{
    WORD *pDTCACDecoderTable;
    DWORD DCTACDecoderEscapeCode;

    DWORD StartIndexOfLastRun;

    BYTE *RunTable;
    BYTE *NotLastDeltaRunTable;
    BYTE *LastDeltaRunTable;

    char *LevelTable;
    BYTE *NotLastDeltaLevelTable;
    BYTE *LastDeltaLevelTable;
}
XMVACCoefficientDecoderTable;

/*
 * The main XMV decoder structure, holds absolutely everything we need to do 
 * the decoding.
 */

struct _XMVDecoder
{
    /*
     * Members used by the file loader
     */

    // The size of the source file.
    LONGLONG FileSize;

    // How much of that file we've consumed.
    LONGLONG FileSizeRead;

    // The source file.
    HANDLE hFile;

    // The size of each of our buffers.
    DWORD BufferSize;

    // The buffer we're currently decoding from.
    BYTE *pDecodingBuffer;

    // The number of frames left in that buffer.
    DWORD RemainingFrames;

    // The buffer we're currently loading into.
    BYTE *pLoadingBuffer;

    // Where we are currently reading from in the file.
    OVERLAPPED Overlapped;

    // The size of the header on the initial frame of the video.
    DWORD InitialFrameHeaderSize;

    /*
     * Information needed by the decoder.
     */

    // The geometry of the video.  The surface that each frame is rendered
    // onto must be exactly this size.  If width and height are zero then 
    // there is no video stream in this file.
    //
    DWORD Width;
    DWORD Height;

    // The frame rate of the file.
    DWORD FramesPerSecond;

    // The number of slices the picture is divided into.
    DWORD Slices;

    // Various flags about how the picture is encoded.  This could be packed
    // a bit more but why bother to save a few bytes?
    //
    BOOLEAN MixedPelMotionCompensationEnable; 
    BOOLEAN LoopFilterEnabled; 
    BOOLEAN VariableSizedTransformEnabled;
    BOOLEAN XIntra8IPictureCodingEnabled;
    BOOLEAN HybridMotionVectorEnabled;
    BOOLEAN DCTTableSwitchingEnabled;

    // The number of audio streams encoded in this file.
    DWORD AudioStreamCount;

    // Array of audio descriptors.
    XMVAudioImplementation *Audio;

    /*
     * Members used during the actual decoding process
     */

    // Whether the next frame has already been decoded.
    BOOL IsNextFrameDecoded;

    // The size of the next packet.
    DWORD NextPacketSize;

    // The size of the UV part of the frame buffer.
    DWORD UVWidth;
    DWORD UVHeight;

    // The size of the picture in macroblocks.
    DWORD MBWidth;
    DWORD MBHeight;

    // The frame buffer currently being displayed.
    BYTE *pYDisplayed;
    BYTE *pUDisplayed;
    BYTE *pVDisplayed;

    // The frame buffer currently being built.
    BYTE *pYBuilding;
    BYTE *pUBuilding;
    BYTE *pVBuilding;

    // The macroblock CBPCY values for the previous row.
    XMVMacroblockCBPCY *pCBPCY;

    // The DC Precitors for the lower blocks of all of the macroblocks in the 
    // previous row.
    //
    short *pYAC;
    short *pUAC;
    short *pVAC;

    /*
     * Bit walker members
     */

    // Holds a byte-swapped version of 4 bytes of the buffer.
    DWORD BitCache;

    // The number of valid bits left in the cache.
    DWORD BitsRemaining;

    // The next 4 bytes we'll read from in the decoding buffer.
    BYTE *pDecodingPosition;
};

/* 
 * The rendering frontend (frontend.c)
 */

XMVACCoefficientDecoderTable g_InterDecoderTables[];
XMVACCoefficientDecoderTable g_IntraDecoderTables[];

BYTE g_HorizontalZigzag[];
BYTE g_VerticalZigzag[];
BYTE g_NormalZigzag[]; 

void DecodeOneFrame(XMVDecoder *pDecoder);

/*
 * The rendering backend (backend.c)
 */

void RenderBitmap(XMVDecoder *pDecoder, D3DSurface *pSurface);

/*
 * The huffman decoding routines and tables (huffman.c)
 */

WORD g_Huffman_ICBPCY[];

#define INTRADCYTCOEF_ESCAPE_CODE 119

WORD g_Huffman_DCTDCy_Talking[];
WORD g_Huffman_DCTDCy_HighMotion[];

#define INTRADCUVTCOEF_ESCAPE_CODE 119

WORD g_Huffman_DCTDCc_Talking[];
WORD g_Huffman_DCTDCc_HighMotion[];

DWORD HuffmanDecode(XMVDecoder *pDecoder, WORD *pHuffmanTable);

/*
 * The bit walker (bits.c)
 */

#if DBG

extern DWORD g_TotalBitsRead;

#endif

DWORD ReadOneBit(XMVDecoder *pDecoder);
DWORD ReadTriStateBits(XMVDecoder *pDecoder);

DWORD ReadBits(XMVDecoder *pDecoder, DWORD Bits);
DWORD PeekBits(XMVDecoder *pDecoder, DWORD Bits);
void  SkipBits(XMVDecoder *pDecoder, DWORD Bits);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\bits.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bits.c
 *  Content:    walks the video frame portion of the input buffer
 *
 ****************************************************************************/

#include <xtl.h>
#include <xmv.h>
#include <xdbg.h>

#include "decoder.h"

#if DBG

DWORD g_TotalBitsRead;

#endif DBG

/*
 * Read one bit 
 */

DWORD ReadOneBit
(
    XMVDecoder *pDecoder
)
{

#if DBG
    g_TotalBitsRead += 1;
#endif DBG

    // Do the trivial thing if all of the bits fit into our little cache.
    if (pDecoder->BitsRemaining)
    {
        pDecoder->BitsRemaining--;

        return (pDecoder->BitCache >> pDecoder->BitsRemaining) & 1;
    }

    // Otherwise the read is split up between two blocks.
    else
    {
        // Load up the next part, swapping the bytes as we go.
        *((BYTE *)&pDecoder->BitCache + 3) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 2) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 1) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 0) = *pDecoder->pDecodingPosition++;

        // Remember how much we'll have left.
        pDecoder->BitsRemaining = 31;

        // Return the result.
        return (pDecoder->BitCache >> 31) & 1;
    }
}

/*
 * Read a tri-state bit encoding.
 */

DWORD ReadTriStateBits
(
    XMVDecoder *pDecoder
)
{
    DWORD Bits;

    Bits = ReadOneBit(pDecoder);

    if (Bits)
    {
        return ReadOneBit(pDecoder) + 1;
    }
    else
    {
        return 0;
    }
}

/*
 * Read some bits from the buffer
 */

DWORD ReadBits
(   
    XMVDecoder *pDecoder, 
    DWORD Bits
)
{
    DWORD FirstPart;
    DWORD SecondPartBits;

    ASSERT(Bits > 0 && Bits <= 32);

#if DBG
    g_TotalBitsRead += Bits;
#endif DBG

    // Do the trivial thing if all of the bits fit into our little cache.
    if (Bits <= pDecoder->BitsRemaining)
    {
        pDecoder->BitsRemaining -= Bits;

        return (pDecoder->BitCache >> pDecoder->BitsRemaining) & (0xFFFFFFFF >> (32 - Bits));
    }

    // Otherwise the read is split up between two blocks.
    else
    {
        // Save what we have.  Note the second multiplication is because the
        // intel processor only knows about shifts between 0 and 31 bits, not
        // 32.
        //
        FirstPart  = pDecoder->BitCache & (0xFFFFFFFF >> (32 - pDecoder->BitsRemaining));
        FirstPart *= !!pDecoder->BitsRemaining;

        SecondPartBits = Bits - pDecoder->BitsRemaining;
    
        // Load up the next part, swapping the bytes as we go.
        *((BYTE *)&pDecoder->BitCache + 3) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 2) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 1) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 0) = *pDecoder->pDecodingPosition++;

        // Remember how much we'll have left.
        pDecoder->BitsRemaining = 32 - SecondPartBits;

        // Return the result.
        return (FirstPart << SecondPartBits) | (pDecoder->BitCache >> pDecoder->BitsRemaining);
    }
}

/*
 * Read some bits from the buffer without consuming them.
 */

DWORD PeekBits
(
    XMVDecoder *pDecoder, 
    DWORD Bits
)
{
    DWORD FirstPart;
    DWORD SecondPartBits;
    DWORD TemporaryCache;

    ASSERT(Bits > 0 && Bits <= 32);

    // Do the trivial thing if all of the bits fit into our little cache.
    if (Bits <= pDecoder->BitsRemaining)
    {
        return (pDecoder->BitCache >> (pDecoder->BitsRemaining - Bits)) & (0xFFFFFFFF >> (32 - Bits));
    }

    // Otherwise the read is split up between two blocks.
    else
    {
        // Save what we have.  Note the second multiplication is because the
        // intel processor only knows about shifts between 0 and 31 bits, not
        // 32.  If BitsRemaining is zero then we need to do extra work to
        // ensure that FirstPart is also zero.
        //
        FirstPart  = pDecoder->BitCache & (0xFFFFFFFF >> (32 - pDecoder->BitsRemaining));
        FirstPart *= !!pDecoder->BitsRemaining;

        SecondPartBits = Bits - pDecoder->BitsRemaining;
    
        // Load up the next part, swapping the bytes as we go.
        *((BYTE *)&TemporaryCache + 3) = *(pDecoder->pDecodingPosition + 0);
        *((BYTE *)&TemporaryCache + 2) = *(pDecoder->pDecodingPosition + 1);
        *((BYTE *)&TemporaryCache + 1) = *(pDecoder->pDecodingPosition + 2);
        *((BYTE *)&TemporaryCache + 0) = *(pDecoder->pDecodingPosition + 3);

        // Return the result.
        return (FirstPart << SecondPartBits) | (TemporaryCache >> (32 - SecondPartBits));
    }
}

/*
 * Consume some bits from the buffer without reading them.
 */

void SkipBits
(
    XMVDecoder *pDecoder, 
    DWORD Bits
)
{
#if DBG
    g_TotalBitsRead += Bits;
#endif DBG

    // Do the trivial thing if all of the bits are in our little cache.
    if (Bits <= pDecoder->BitsRemaining)
    {
        pDecoder->BitsRemaining -= Bits;
    }

    // Otherwise we need to skip along to another buffer.
    else
    {
        // Forget about the bits we currently have loaded.
        Bits -= pDecoder->BitsRemaining;

        // If we're skipping more than 8 bits then just zoom on past.
        pDecoder->pDecodingPosition += Bits / 8;

        // Load up the next part, swapping the bytes as we go.
        *((BYTE *)&pDecoder->BitCache + 3) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 2) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 1) = *pDecoder->pDecodingPosition++;
        *((BYTE *)&pDecoder->BitCache + 0) = *pDecoder->pDecodingPosition++;

        // Remember how much we'll have left.
        pDecoder->BitsRemaining = 32 - (Bits % 8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\huffman.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       huffman.c
 *  Content:    Holds all of our huffman tables.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xmv.h>

#include "decoder.h"

/* 
 * Entry for the huffman decoder tables.
 */

typedef struct _HUFFMAN_ENTRY
{
    WORD Symbol:12;
    WORD Length:4;
}
HUFFMAN_ENTRY;

/*
 * Huffman decoder routine
 *
 * andrewso: I am not at all convinced that the complexity of the huffman
 *   tables is truely necessary.  This might be an area where we can save a 
 *   ton of memory (which is a lot as those chips are light).  This needs
 *   more investigation.
 */

DWORD HuffmanDecode
(
    XMVDecoder *pDecoder, 
    WORD *pHuffmanTable
)
{
    DWORD Index, Table;
    HUFFMAN_ENTRY *pTables;
    HUFFMAN_ENTRY *pEntryTable;

    pTables = (HUFFMAN_ENTRY *)pHuffmanTable;

    Table = 0;

    for (;;)
    {
        pEntryTable = pTables + pTables[Table].Symbol;

        Index = PeekBits(pDecoder, pTables[Table].Length);

        if (pEntryTable[Index].Length > 0)
        {
            SkipBits(pDecoder, pEntryTable[Index].Length);

            return pEntryTable[Index].Symbol;
        }
        else
        {
            SkipBits(pDecoder, pTables[Table].Length);

            Table = pEntryTable[Index].Symbol;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\decoder.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       decoder.c
 *  Content:    manages loading and parsering XMV data.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xmv.h>

#include "..\inc\xmvformat.h"

#include "decoder.h"

#define MAX_BUFFER_SIZE     (512 * 1024)

/*
 * Create the decoder, load the headers from the movie file and create
 * all of the video decoding buffers.
 */

HRESULT XMVCreateDecoder
(
    char *szFileName, 
    XMVDecoder **ppDecoder
)
{
    LONGLONG FileSize;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BYTE *pBuffer = NULL;
    BYTE *pFrame  = NULL;

    DWORD BytesRead;
    OVERLAPPED Overlapped;
    DWORD Size, TotalSize;
    DWORD AudioStreamCount;
    DWORD i;
    BYTE *pWalk;

    XMVVideoDataHeader *pVideoDataHeader;
    XMVAudioDataHeader *pAudioDataHeader;
    XMVDecoder         *pDecoder = NULL;

    HRESULT hr;

    memset(&Overlapped, 0, sizeof(Overlapped));

    // Open the input file.
    hFile = CreateFile(szFileName, 
                       GENERIC_READ, 
                       FILE_SHARE_READ, 
                       NULL, 
                       OPEN_EXISTING, 
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto LastError;
    }

    // Remember the file's size.
    if (!GetFileSizeEx(hFile, (LARGE_INTEGER *)&FileSize))
    {
        goto LastError;
    }

    // Reserve enough address space for our maximum buffer sizes.
    pBuffer = (BYTE *)VirtualAlloc(NULL, MAX_BUFFER_SIZE * 2, MEM_RESERVE, PAGE_READWRITE);

    if (!pBuffer)
    {
        goto LastError;
    }

    // Commit the first page.
    if (!VirtualAlloc(pBuffer, 4096, MEM_COMMIT, PAGE_READWRITE))
    {
        goto LastError;
    }

    // Read the first page from the file.  This is a royal pain in the neck
    // because we opened it for overlapped IO.  We'll take the pain for this
    // pair of reads.
    //
    Overlapped.Offset     = 0;
    Overlapped.OffsetHigh = 0;

    if (!ReadFile(hFile, pBuffer, 4096, NULL, &Overlapped))
    {
        if (GetLastError() != ERROR_IO_PENDING)
        {
            goto LastError;
        }
    }

    // Wait for the read to finish.
    if (!GetOverlappedResult(hFile, &Overlapped, &BytesRead, TRUE))
    {
        goto LastError;
    }

    // Find the location of the header.
    pVideoDataHeader = (XMVVideoDataHeader *)pBuffer;

    // Make sure it's valid.

#if DBG

    if (BytesRead != 4096 
        || pVideoDataHeader->MagicCookie != XMV_MAGIC_COOKIE 
        || pVideoDataHeader->FileVersion != XMV_FILE_VERSION)
    {
        RIP("Input is not a valid XMV file.\n");
    }
    
#endif DBG

    // Commit all of the memory we need for the input buffers.
    if (!VirtualAlloc(pBuffer + 4096, 
                      pVideoDataHeader->RequiredBufferSize * 2 - 4096, 
                      MEM_COMMIT, 
                      PAGE_READWRITE))
    {
        goto LastError;
    }

    // Check for a buffer overrun.
    if (pVideoDataHeader->ThisPacketSize > pVideoDataHeader->RequiredBufferSize)
    {
        RIP("Bad input file - buffer overrun.");
        hr = E_FAIL;

        goto Error;
    }

    TotalSize = pVideoDataHeader->RequiredBufferSize * 2;

    // Allocate our decoder object, zero it out then populate its members.
    AudioStreamCount = pVideoDataHeader->AudioStreamCount;

    Size = sizeof(*pDecoder) 
            + sizeof(XMVAudioImplementation) * AudioStreamCount
            + sizeof(XMVMacroblockCBPCY) * (pVideoDataHeader->Width / MACROBLOCK_SIZE + 1)
            + sizeof(short) * (pVideoDataHeader->Width / MACROBLOCK_SIZE) * BLOCK_SIZE * 4;

    TotalSize += Size;

    pDecoder = malloc(Size);

    if (!pDecoder)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    memset(pDecoder, 0, Size);

    // Buffer members.
    pDecoder->RemainingFrames  = 0;
    pDecoder->FileSize         = FileSize;
    pDecoder->FileSizeRead     = 4096;
    pDecoder->hFile            = hFile;;
    pDecoder->BufferSize       = pVideoDataHeader->RequiredBufferSize;

    pDecoder->pDecodingBuffer  = pBuffer + pDecoder->BufferSize;
    pDecoder->pLoadingBuffer   = pBuffer;

    // Decoder information.
    pDecoder->Width            = pVideoDataHeader->Width;
    pDecoder->Height           = pVideoDataHeader->Height;
    pDecoder->FramesPerSecond  = pVideoDataHeader->FramesPerSecond;
    pDecoder->Slices           = pVideoDataHeader->Slices;

    // Flags
    pDecoder->MixedPelMotionCompensationEnable = pVideoDataHeader->MixedPelMotionCompensationEnable; 
    pDecoder->LoopFilterEnabled                = pVideoDataHeader->LoopFilterEnabled; 
    pDecoder->VariableSizedTransformEnabled    = pVideoDataHeader->VariableSizedTransformEnabled;
    pDecoder->XIntra8IPictureCodingEnabled     = pVideoDataHeader->XIntra8IPictureCodingEnabled;
    pDecoder->HybridMotionVectorEnabled        = pVideoDataHeader->HybridMotionVectorEnabled;
    pDecoder->DCTTableSwitchingEnabled         = pVideoDataHeader->DCTTableSwitchingEnabled;

    // Audio stream information.
    pDecoder->AudioStreamCount = AudioStreamCount;

    if (AudioStreamCount)
    {
        pDecoder->Audio        = (XMVAudioImplementation *)(pDecoder + 1);

        pAudioDataHeader = pVideoDataHeader->AudioHeaders;

        for (i = 0; i < AudioStreamCount; i++)
        {
            pDecoder->Audio[i].WaveFormat       = pAudioDataHeader->WaveFormat;
            pDecoder->Audio[i].ChannelCount     = pAudioDataHeader->ChannelCount;
            pDecoder->Audio[i].SamplesPerSecond = pAudioDataHeader->SamplesPerSecond;
            pDecoder->Audio[i].BitsPerSample    = pAudioDataHeader->BitsPerSample;

            pAudioDataHeader++;
        }
    }

    // Save the size of the header.
    pDecoder->InitialFrameHeaderSize = (BYTE *)(pVideoDataHeader->AudioHeaders + AudioStreamCount) - pBuffer;

    // Initialize the frame buffers.
    pDecoder->UVWidth  = pDecoder->Width / 2;
    pDecoder->UVHeight = pDecoder->Height / 2;

    pDecoder->MBWidth  = pDecoder->Width / MACROBLOCK_SIZE;
    pDecoder->MBHeight = pDecoder->Height / MACROBLOCK_SIZE;

    // Set up the CBPCY fields.
    pWalk = (BYTE *)(pDecoder + 1);

    pDecoder->pCBPCY = (XMVMacroblockCBPCY *)pWalk;
    pWalk += sizeof(XMVMacroblockCBPCY) * (pDecoder->MBWidth  + 1);

    pDecoder->pYAC = (short *)pWalk;
    pWalk += sizeof(short) * pDecoder->MBWidth * MACROBLOCK_SIZE;

    pDecoder->pUAC = (short *)pWalk;
    pWalk += sizeof(short) * pDecoder->MBWidth * BLOCK_SIZE;

    pDecoder->pVAC = (short *)pWalk;
    pWalk += sizeof(short) * pDecoder->MBWidth * BLOCK_SIZE;

    // Initialize the memory for the frame buffers.  These are almost always
    // big enough to use Virtual Alloc so just use that...
    //
    Size = 2 * (pDecoder->Width * pDecoder->Height + 2 * pDecoder->UVWidth * pDecoder->UVHeight);

    TotalSize += Size;

    pFrame = VirtualAlloc(NULL, Size, MEM_COMMIT, PAGE_READWRITE);
    pWalk  = pFrame;

    // The frame buffer currently being displayed.
    pDecoder->pYDisplayed = pWalk;
    pWalk += pDecoder->Width * pDecoder->Height;

    pDecoder->pUDisplayed = pWalk;
    pWalk += pDecoder->UVWidth * pDecoder->UVHeight;

    pDecoder->pVDisplayed = pWalk;
    pWalk += pDecoder->UVWidth * pDecoder->UVHeight;

    // Set the U & V buffers so that we'll display black if this frame ever
    // gets presented.
    //
    memset(pDecoder->pUDisplayed, 0x80, pDecoder->UVWidth * pDecoder->UVHeight);
    memset(pDecoder->pVDisplayed, 0x80, pDecoder->UVWidth * pDecoder->UVHeight);

    // The frame buffer currently being built.
    pDecoder->pYBuilding = pWalk;
    pWalk += pDecoder->Width * pDecoder->Height;

    pDecoder->pUBuilding = pWalk;
    pWalk += pDecoder->UVWidth * pDecoder->UVHeight;

    pDecoder->pVBuilding = pWalk;
    pWalk += pDecoder->UVWidth * pDecoder->UVHeight;

// TEMPORARY UNTIL WE START ACTUALLY DECODING.
memset(pDecoder->pUBuilding, 0x80, pDecoder->UVWidth * pDecoder->UVHeight);
memset(pDecoder->pVBuilding, 0x80, pDecoder->UVWidth * pDecoder->UVHeight);

    // Read in the rest of the buffer while we finish our initialization.  The
    // header will always fit in the first 4096 bytes of the file so we can
    // party on it all we need.
    //
    pDecoder->Overlapped.Offset     = 4096;
    pDecoder->Overlapped.OffsetHigh = 0;

    if (!ReadFile(hFile, 
                  pBuffer + 4096, 
                  pVideoDataHeader->ThisPacketSize - 4096, 
                  NULL, 
                  &pDecoder->Overlapped))
    {
        if (GetLastError() != ERROR_IO_PENDING)
        {
            goto LastError;
        }
    }

    *ppDecoder = pDecoder;

#if DBG
    DbgPrint("XMV: Total allocated memory: %d bytes (%d K)\n", TotalSize, TotalSize / 1024);
#endif DBG

    return NOERROR;

LastError:
    hr = HRESULT_FROM_WIN32(GetLastError());

Error:

    if (pDecoder)
    {
        free(pDecoder);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        // Make sure any pending reads are done.
        GetOverlappedResult(hFile, &Overlapped, &BytesRead, TRUE);

        CloseHandle(hFile);
    }

    if (pBuffer)
    {
        VirtualFree(pBuffer, 0, MEM_RELEASE);
    }

    if (pFrame)
    {
        VirtualFree(pFrame, 0, MEM_RELEASE);
    }

    return hr;
}

/*
 * Destroy decoder, freeing all memory and closing the input file.
 */

void XMVCloseDecoder
(
    XMVDecoder *pDecoder
)
{
    BYTE *pBuffer;
    DWORD BytesRead;

    if (pDecoder)
    {
        // UNDONE: Need to wait on any pending reads...
        if (pDecoder->hFile != INVALID_HANDLE_VALUE)
        {
            // Make sure any pending reads are done.
            GetOverlappedResult(pDecoder->hFile, &pDecoder->Overlapped, &BytesRead, TRUE);

            CloseHandle(pDecoder->hFile);
        }

        if (pDecoder->pDecodingBuffer < pDecoder->pLoadingBuffer)
        {
            pBuffer = pDecoder->pDecodingBuffer;
        }
        else
        {
            pBuffer = pDecoder->pLoadingBuffer;
        }

        if (pBuffer)
        {
            VirtualFree(pBuffer, 0, MEM_RELEASE);
        }

        if (pDecoder->pYDisplayed < pDecoder->pYBuilding)
        {
            pBuffer = pDecoder->pYDisplayed;
        }
        else
        {
            pBuffer = pDecoder->pYBuilding;
        }

        if (pBuffer)
        {
            VirtualFree(pBuffer, 0, MEM_RELEASE);
        }

        free(pDecoder);
    }
}

/*
 * Get the general information about the file.
 */

void XMVGetVideoDescriptor
(
    XMVDecoder *pDecoder, 
    XMVVideoDescriptor *pVideoDescriptor
)
{
    pVideoDescriptor->Width            = pDecoder->Width;
    pVideoDescriptor->Height           = pDecoder->Height;
    pVideoDescriptor->FramesPerSecond  = pDecoder->FramesPerSecond;
    pVideoDescriptor->AudioStreamCount = pDecoder->AudioStreamCount;
}

/*
 * Get information about a specific audio stream.
 */

void XMVGetAudioDescriptor
(
    XMVDecoder *pDecoder, 
    DWORD AudioStream, 
    XMVAudioDescriptor *pAudioDescriptor
)
{
    if (AudioStream >= pDecoder->AudioStreamCount)
    {
        RIP("Invalid audio stream index.");
    }

    pAudioDescriptor->WaveFormat       = pDecoder->Audio[AudioStream].WaveFormat;
    pAudioDescriptor->ChannelCount     = pDecoder->Audio[AudioStream].ChannelCount;
    pAudioDescriptor->SamplesPerSecond = pDecoder->Audio[AudioStream].SamplesPerSecond;
    pAudioDescriptor->BitsPerSample    = pDecoder->Audio[AudioStream].BitsPerSample;
}

/*
 * Tell the decoder to play one of the audio tracks in the XMV file.  The 
 * caller can optionally get the IDirectSoundStream interface to manually
 * adjust the sound parameters.
 *
 * This API can be called multiple times for different streams to allow
 * them to be played at the same time.
 *
 * The Flags and pMixBins parameters are used when creating the stream.  
 * These can be safely set to zero and NULL, respectively.
 *
 * ppStream may be NULL if the caller does not want direct access to the
 * stream.
 */

HRESULT XMVEnableAudioStream
(
    XMVDecoder *pDecoder, 
    DWORD AudioStream, 
    DWORD Flags, 
    DSMIXBINS *pMixBins, 
    IDirectSoundStream **ppStream
)
{
    RIP("Audio is NYI");
    
    return E_NOTIMPL;
}

/*
 * Get the next frame to display.
 *
 * This method has four possible return values:
 *
 *   XMV_NOFRAME - There is no new data and the passed-in surface
 *       is unchanged.
 *
 *   XMV_NEWFRAME - The surface contains a new frame that needs to be
 *       displayed.
 *
 *   XMV_ENDOFILE - The movie is over, throw your trash away and go home.
 *
 *   XMV_FAIL - Some major catastrophy happened that prevents the video from
 *       being decoded any further.  This only happens with major data 
 *       corruption or some kind of read error.
 *
 * The Width and Height of the surface must match that of the video.
 *
 * This method must be called occasionally even if there is no video in the
 * input file, simply pass NULL for the surface.
 */

XMVRESULT XMVGetNextFrame
(
    XMVDecoder *pDecoder, 
    D3DSurface *pSurface
)
{
    DWORD BytesRead;
    DWORD Error;
    BYTE *pBuffer, *pSwap;
    DWORD i;

    BYTE *pStartFrame;
    DWORD FrameSize;

    XMVVideoPacketHeader *pVideoPacketHeader;

    /*
     * The decoder works as follows...
     *
     *  We always try to keep the frame that we're currently displaying
     *  on the screen and the next frame we want to display in memory.
     *
     *  When a new frame is displayed, we swap it to the current frame
     *  slot and mark the next frame as being dirty.
     *
     *  We load and decode that next frame at the very next call to this
     *  routine.  If we are unable to, such as the IO is not yet complete,
     *  then we leave it marked as dirty.
     *
     *  If the next frame is not ready when we need to display it then we 
     *  continue displaying the old frame until it is ready, then we will
     *  use the sychronization logic to skip back up to the correct 
     *  frame.
     */

    // Do we need to decode the next frame?
    if (!pDecoder->IsNextFrameDecoded)
    {
        // If we're out of frames, get the ones we just loaded in the
        // background and start a new set loading.
        //
        if (!pDecoder->RemainingFrames)
        {
            // Are we done?
            if (pDecoder->FileSizeRead == pDecoder->FileSize)
            {
                // If the audio is not done then don't report the EOF yet.
                if (/* Is Audio done? */ FALSE)
                {
                    return XMV_NOFRAME;
                }
                else
                {
                    return XMV_ENDOFFILE;
                }
            }

            // Check to see if the read is done....
            if (GetOverlappedResult(pDecoder->hFile, &pDecoder->Overlapped, &BytesRead, FALSE))
            {
                // Remember how much we read.
                pDecoder->FileSizeRead += BytesRead;

                // Swap the buffers.
                pBuffer = pDecoder->pLoadingBuffer;
                pDecoder->pLoadingBuffer = pDecoder->pDecodingBuffer;
                pDecoder->pDecodingBuffer = pBuffer;

                // Skip the initial header.
                pBuffer += pDecoder->InitialFrameHeaderSize;
                pDecoder->InitialFrameHeaderSize = 0;

                // Save the next packet size.
                pDecoder->NextPacketSize = ((XMVPacketHeader *)pBuffer)->NextPacketSize;

                pBuffer += sizeof(XMVPacketHeader);
                                         
                // Load the headers.
                pVideoPacketHeader = (XMVVideoPacketHeader *)pBuffer;

                pBuffer += sizeof(pVideoPacketHeader) 
                             + sizeof(XMVAudioStreamHeader) * pDecoder->AudioStreamCount;

                // Save our position in the buffer.
                pDecoder->pDecodingPosition = pBuffer;

                // We now have frames!
                pDecoder->RemainingFrames = pVideoPacketHeader->FrameCount;

                // Pump more data into the audio streams.
                pBuffer += pVideoPacketHeader->VideoStreamLength;

                for (i = 0; i < pDecoder->AudioStreamCount; i++)
                {
                    ASSERT((DWORD)pBuffer % 4 == 0);

                    // PumpMoreAudio(pBuffer, pDecoder->AudioStreams[i].AudioStreamSize);

                    pBuffer += (pVideoPacketHeader->AudioStreams[i].AudioStreamSize + 3) & ~3;
                }
            }

            // Error case.
            else
            {
                Error = GetLastError();

                // If we're waiting on the IO to finish, just do nothing.
                if (Error != ERROR_IO_INCOMPLETE)
                {
                    RIP("Unable to read from the input file.");
                    return XMV_FAIL;
                }
            }

        }
    }

    // Start the next load if needed and if we're done with that buffer.  We
    // do this before we decode the frame as the time we're doing that is an
    // optimal time to be loading stuff off the disk.
    //
    if (/* Done with that buffer */ TRUE && pDecoder->NextPacketSize)
    {
        // Start the next load.
        pDecoder->Overlapped.Offset     = (DWORD)(pDecoder->FileSizeRead & 0xFFFFFFFF);
        pDecoder->Overlapped.OffsetHigh = (DWORD)(pDecoder->FileSizeRead >> 32);

        if (pDecoder->NextPacketSize > pDecoder->BufferSize)
        {
            RIP("Bad input file - buffer overrun.");

            return XMV_FAIL;
        }

        if (!ReadFile(pDecoder->hFile, 
                      pDecoder->pLoadingBuffer, 
                      pDecoder->NextPacketSize, 
                      NULL, 
                      &pDecoder->Overlapped))
        {
            if (GetLastError() != ERROR_IO_PENDING)
            {
                RIP("Unable to read from the input file.");
                return XMV_FAIL;
            }
        }

        pDecoder->NextPacketSize = 0;
    }

    // Decode the next frame if we need to.
    if (!pDecoder->IsNextFrameDecoded && pDecoder->RemainingFrames)
    {
        // Set the buffer to the start of the frame pointer.
        FrameSize   = ((XMVVideoFrame *)pDecoder->pDecodingPosition)->FrameSize;
        pStartFrame = pDecoder->pDecodingPosition + sizeof(XMVVideoFrame);
        
        pDecoder->pDecodingPosition = pStartFrame;
        pDecoder->BitsRemaining     = 0;                

        // Decode the frame (frontend.c)
        DecodeOneFrame(pDecoder);

        // Reset to the start of the next frame.
        pDecoder->pDecodingPosition = pStartFrame + FrameSize;

        // Remember that we did it.
        pDecoder->RemainingFrames--;
        pDecoder->IsNextFrameDecoded = TRUE;
    }

    // Is it time to swap and we have the next frame...
    if (/* time to swap? */ TRUE && pDecoder->IsNextFrameDecoded)
    {
        // Swap the next frame to the current frame.
        pSwap                 = pDecoder->pYDisplayed;
        pDecoder->pYDisplayed = pDecoder->pYBuilding;
        pDecoder->pYBuilding  = pSwap;

        pSwap                 = pDecoder->pUDisplayed;
        pDecoder->pUDisplayed = pDecoder->pUBuilding;
        pDecoder->pUBuilding  = pSwap;

        pSwap                 = pDecoder->pVDisplayed;
        pDecoder->pVDisplayed = pDecoder->pVBuilding;
        pDecoder->pVBuilding  = pSwap;

        // Remember that we have to do the next frame.
        pDecoder->IsNextFrameDecoded = FALSE;

        // Convert the YUV format to whatever output we want (backend.c)
        RenderBitmap(pDecoder, pSurface);

        return XMV_NEWFRAME;
    }
    else
    {
        return XMV_NOFRAME;
    }
}

/*
 * Get the current frame.  This will not decode the next frame.
 *
 * This method cannot fail.  If it is called before the first call to 
 * GetNextFrame then the surface will be black.  If it's called after the end
 * of the file then it will return the very last frame.
 *
 * The passed-in surface does not have to have the same format as the one
 * passed into GetNextFrame.
 */

void XMVGetCurrentFrame
(
    XMVDecoder *pDecoder, 
    D3DSurface *pSurface
)
{
    // Convert the YUV format to whatever output we want (backend.c)
    RenderBitmap(pDecoder, pSurface);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\frontend.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       frontend.c
 *  Content:    parses the on-disk format to YUV macroblocks.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xmv.h>

#include "decoder.h"

/* 
 * Converts the unquantized AC coefficient array for a block into a block of
 * pixels.  
 */

// !!! andrewso: We can probably improve this a bit as we always know we
//   have SSE1 available.
//
void InverseDCT
(
    BYTE *pDestination, 
    DWORD Pitch,
    long *ReconstructedACCoefficients
)
{
  	long buf [72];
    long *rgblk = (long *)(((long)buf+32) & 0xFFFFFFE0);

    static const LONGLONG M1 = 0x023508E4023508E4;     //W7,W1-W7
    static const LONGLONG M2 = 0x0235F2B20235F2B2;     //W7,0-(W1+W7)
    static const LONGLONG M3 = 0x0968FCE10968FCE1;     //W3,0-(W3-W5)
    static const LONGLONG M4 = 0x0968F04F0968F04F;     //W3,0-(W3+W5)
    static const LONGLONG M5 = 0x0454F1380454F138;     //W6,0-(W2+W6)
    static const LONGLONG M6 = 0x0454062004540620;     //W6,W2-W6
    static const LONGLONG M7 = 0x0000008000000080;
    static const LONGLONG M8 = 0x00B55a8000B55a80;     //181,(181<<16)
    static const LONGLONG M9 = 0x0000023500000235;
    static const LONGLONG M10 = 0x000000B5000000B5;    //181,181
    static const LONGLONG low15mask = 0x00007fff00007fff;
    LONGLONG t64;

    _asm
    {
            mov         esi,ReconstructedACCoefficients
            mov         edi,rgblk
            mov         ecx,-4
            xor         ebx,ebx
HLoop:
            lea         eax,[esi+ecx*8]

            pcmpeqb     mm0,mm0
            psrld       mm0,16

            movq        mm4,[eax+32+16*2]
            movq        mm1,mm4
            movq        mm5,[eax+32+112*2]
            paddd       mm1,mm5
            pslld       mm1,16
            pand        mm4,mm0
            pand        mm5,mm0
            por         mm5,mm1
            por         mm4,mm1
            movq        mm1,M1
            pmaddwd     mm4,mm1
            movq        mm1,M2
            pmaddwd     mm5,mm1
            
            movq        mm6,[eax+32+80*2]
            movq        mm1,mm6
            movq        mm7,[eax+32+48*2]
            paddd       mm1,mm7
            pslld       mm1,16
            pand        mm6,mm0
            pand        mm7,mm0
            por         mm6,mm1
            por         mm7,mm1
            movq        mm1,M3
            pmaddwd     mm6,mm1
            movq        mm1,M4
            pmaddwd     mm7,mm1

            movq        mm3,[eax+32+32*2]
            movq        mm1,mm3
            movq        mm2,[eax+32+96*2]
            paddd       mm1,mm2
            pslld       mm1,16
            pand        mm3,mm0
            pand        mm2,mm0
            por         mm3,mm1
            por         mm2,mm1
            movq        mm1,M6
            pmaddwd     mm3,mm1
            movq        mm1,M5
            pmaddwd     mm2,mm1

            movq        mm0,mm6
            paddd       mm6,mm4
            psubd       mm4,mm0

            movq        mm0,mm7
            paddd       mm7,mm5
            psubd       mm5,mm0

            movq        mm0,mm5
            paddd       mm5,mm4
            psubd       mm4,mm0

            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8

            movq        mm0,[esi+ecx*8+32]
            lea         eax,[esi+ecx*8]
            movq        [edi+4],mm4
            pslld       mm0,16
            psrad       mm0,5
            movq        mm1,M7
            paddd       mm0,mm1
            movq        mm1,[eax+32+64*2]
            pslld       mm1,16
            psrad       mm1,5
            movq        mm4,mm0
            psubd       mm0,mm1
            paddd       mm1,mm4

            movq        mm4,mm1
            psubd       mm1,mm3
            paddd       mm3,mm4

            movq        mm4,mm0
            psubd       mm0,mm2
            paddd       mm2,mm4

            movq        mm4,mm3
            psubd       mm3,mm6
            paddd       mm6,mm4
            psrad       mm3,8
            psrad       mm6,8

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases
            
            movq        mm4,mm5
            pslld       mm4,17
            psrlw       mm4,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm4
            movq        mm4,M8
            pmaddwd     mm5,mm4
            movq        mm4,M7
            paddd       mm5,mm4
            psrad       mm5,8
#endif

            movq        mm4,mm2
            psubd       mm2,mm5
            paddd       mm5,mm4
            psrad       mm2,8
            psrad       mm5,8

            movq        mm4,mm6
            punpckldq   mm6,mm5
            punpckhdq   mm4,mm5
            packssdw    mm6,mm6
            
            movq        mm5,mm2
            punpckldq   mm2,mm3
            movd        [edi],mm6
            punpckhdq   mm5,mm3
            packssdw    mm5,mm5
            movd        [edi+12+16],mm5
            packssdw    mm2,mm4
            movq        mm4,[edi+4]
            movq        [edi+12],mm2

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases

            movq        mm2,mm4
            pslld       mm4,17
            psrlw       mm4,1
            pslld       mm2,1
            psrld       mm2,16
            psllw       mm2,8
            por         mm2,mm4
            movq        mm4,M8
            pmaddwd     mm4,mm2
            movq        mm2,M7
            paddd       mm4,mm2
            psrad       mm4,8
#endif
            
            movq        mm2,mm0
            psubd       mm0,mm4
            paddd       mm4,mm2
            psrad       mm0,8
            psrad       mm4,8

            movq        mm2,mm1
            psubd       mm1,mm7
            paddd       mm7,mm2
            psrad       mm1,8
            psrad       mm7,8

            movq        mm2,mm4
            punpckldq   mm4,mm7
            punpckhdq   mm2,mm7

            movq        mm7,mm1
            punpckldq   mm1,mm0
            punpckhdq   mm7,mm0
            packssdw    mm4,mm1
            movq        [edi+4],mm4
            packssdw    mm2,mm7
            inc         ecx
            movq        [edi+4+16],mm2
            lea         edi,[edi+32]
            jl          HLoop

            xor         ecx,ecx
            mov         esi,rgblk
            mov         edi,pDestination
            mov         edx,Pitch
VLoop:

            pcmpeqb     mm1,mm1    //Generate constant 4
            psrld       mm1,31
            pslld       mm1,2

            movd        mm4,[esi+ecx*2+16]
            movd        mm5,[esi+ecx*2+112]
            movq        mm0,mm4
            paddw       mm0,mm5
            punpcklwd   mm4,mm0
            punpcklwd   mm5,mm0
            movq        mm0,M1
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            movq        mm0,M2
            pmaddwd     mm5,mm0
            paddd       mm5,mm1
            psrad       mm4,3
            psrad       mm5,3
        
            movd        mm6,[esi+ecx*2+80]
            movd        mm7,[esi+ecx*2+48]
            movq        mm0,mm6
            paddw       mm0,mm7
            punpcklwd   mm6,mm0
            punpcklwd   mm7,mm0
            movq        mm0,M3
            pmaddwd     mm6,mm0
            paddd       mm6,mm1
            movq        mm0,M4
            pmaddwd     mm7,mm0
            paddd       mm7,mm1
            psrad       mm6,3
            psrad       mm7,3

            movd        mm2,[esi+ecx*2+96]
            movd        mm3,[esi+ecx*2+32]
            movq        mm0,mm2
            paddw       mm0,mm3
            punpcklwd   mm2,mm0
            punpcklwd   mm3,mm0
            movq        mm0,M5
            pmaddwd     mm2,mm0
            paddd       mm2,mm1
            movq        mm0,M6
            pmaddwd     mm3,mm0
            paddd       mm3,mm1
            psrad       mm2,3
            psrad       mm3,3

            movq        mm0,mm4
            psubd       mm4,mm6
            paddd       mm6,mm0

            movq        mm0,mm5
            psubd       mm5,mm7
            paddd       mm7,mm0

            movq        mm0,mm4
            psubd       mm4,mm5
            paddd       mm5,mm0
 
            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8            

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases
            
            pslld       mm1,5  //Generate constant 128
            movq        mm0,mm5
            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm0
            movq        mm0,M8
            pmaddwd     mm5,mm0
            movq        mm0,mm4
            paddd       mm5,mm1
            psrad       mm5,8

            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm4,1
            psrld       mm4,16
            psllw       mm4,8
            por         mm4,mm0
            movq        mm0,M8
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            psrad       mm4,8
#endif

            movq        t64,mm4

            pslld       mm1,6   //Generate 8192

            movd        mm0,[esi+ecx*2]
            punpcklwd   mm0,mm0
            pslld       mm0,16
            psrad       mm0,8
            paddd       mm0,mm1
            movd        mm4,[esi+ecx*2+64]
            punpcklwd   mm4,mm4
            pslld       mm4,16
            psrad       mm4,8
            movq        mm1,mm0
            psubd       mm0,mm4
            paddd       mm4,mm1

            movq        mm1,mm4
            psubd       mm4,mm3
            paddd       mm3,mm1

            movq        mm1,mm0
            psubd       mm0,mm2
            paddd       mm2,mm1

            movq        mm1,mm3
            psubd       mm3,mm6
            psrad       mm3,14
            paddd       mm6,mm1
            psrad       mm6,14

            packssdw    mm6,mm6
            packuswb    mm6,mm6
            movd        eax,mm6
            mov         [edi],ax

            lea         ebx,[edi+edx*8]
            sub         ebx,edx
            packssdw    mm3,mm3
            packuswb    mm3,mm3
            movd        eax,mm3
            mov         [ebx],ax

            movq        mm6,t64

            movq        mm1,mm4
            psubd       mm4,mm7
            psrad       mm4,14
            paddd       mm7,mm1
            psrad       mm7,14

            packssdw    mm4,mm4
            packuswb    mm4,mm4
            movd        eax,mm4
            mov         [edi+edx*4],ax
            lea         ebx,[edi+edx*2]
            packssdw    mm7,mm7
            packuswb    mm7,mm7
            movd        eax,mm7
            mov         [ebx+edx],ax

            movq        mm1,mm2
            psubd       mm2,mm5
            psrad       mm2,14
            paddd       mm5,mm1
            psrad       mm5,14

            lea         ebx,[ebx+edx*2]
            packssdw    mm2,mm2
            packuswb    mm2,mm2
            movd        eax,mm2
            mov         [ebx+edx*2],ax
            
            packssdw    mm5,mm5
            packuswb    mm5,mm5
            movd        eax,mm5
            mov         [edi+edx],ax
  
            movq        mm3,mm0
            psubd       mm0,mm6
            psrad       mm0,14
            paddd       mm6,mm3
            psrad       mm6,14
            packssdw    mm0,mm0
            packuswb    mm0,mm0
            movd        eax,mm0
            mov         [ebx+edx],ax
            packssdw    mm6,mm6
            packuswb    mm6,mm6
            movd        eax,mm6
            mov         [edi+edx*2],ax

            add         edi,2
            add         ecx,2
            cmp         ecx,8
            jnz         VLoop
            emms
        }    
}

/*
 * Decodes a block for a baseline I-frame.  The Top.... and Left... AC
 * Coefficient arrays will get overwritten with the values from this
 * 
 */

void DecodeBaselineIFrameBlock
(
    XMVDecoder *pDecoder,
    BYTE *pDestination,
    DWORD Pitch,
    DWORD DCStepSize,
    DWORD PictureQuantizerScale,
    BOOL  HasEncodedACCoefficientInformation,
    BOOL ACPredictionEnabled,
    short TopLeftQuantizedDCCoefficient,
    short *TopQuantizedACCoefficients,
    short *LeftQuantizedACCoefficients, 
    WORD *pDCDifferentialTable,
    DWORD DCDifferentialEscapeCode,
    XMVACCoefficientDecoderTable *pACDecoderTable,
    DWORD *pEscape3RunLength,
    DWORD *pEscape3LevelLength
)
{
    short DCPredictor;
    short DCDifferential;
    short QuantizedDCCoefficient;
    BOOL  IsPredictedLeft;
    DWORD DCMagnitude;
    long  ReconstructedACCoefficients[64];
    BYTE *pZigZag;
    long  QuantizedACCoefficient;
    DWORD DoubleQuantizerScale;
    DWORD QuantizerScaleOdd;

    DWORD CoefficientCounter;
    DWORD Index;
    BOOL  Done;
    DWORD Run;
    long  Level;
    DWORD Sign;
    DWORD CoefficientIndex;

    DWORD i, Bit;

    //
    // Calculate the DC predictor for this block.
    //

    if (abs(TopLeftQuantizedDCCoefficient - TopQuantizedACCoefficients[0]) <= abs(TopLeftQuantizedDCCoefficient - LeftQuantizedACCoefficients[0]))
    {
        DCPredictor = LeftQuantizedACCoefficients[0];
        IsPredictedLeft = TRUE;
    }
    else 
    {
        DCPredictor = TopQuantizedACCoefficients[0];
        IsPredictedLeft = FALSE;
    }

    //
    // Decode the DC differential.
    //

    // Read the table entry.
    DCMagnitude = HuffmanDecode(pDecoder, pDCDifferentialTable);

    // Escaped values are encoded directly as an 8-bit value.
    if (DCMagnitude == DCDifferentialEscapeCode)
    {
        DCMagnitude = ReadBits(pDecoder, 8);

        ASSERT(DCMagnitude != 0);
    }

    // Read the sign bit if necessary.
    if (DCMagnitude && ReadOneBit(pDecoder))
    {
        DCDifferential = - (short)DCMagnitude;
    }
    else
    {
        DCDifferential = (short)DCMagnitude;
    }

    //
    // Set the quantized and non-quantized DC coefficient.
    //

    QuantizedDCCoefficient = DCPredictor + DCDifferential;

    TopQuantizedACCoefficients[0]  = QuantizedDCCoefficient;
    LeftQuantizedACCoefficients[0] = QuantizedDCCoefficient;

    // Set up the AC Coefficient block.
    ReconstructedACCoefficients[0] = QuantizedDCCoefficient * DCStepSize;

    memset(ReconstructedACCoefficients + 1, 0, sizeof(ReconstructedACCoefficients) - sizeof(ReconstructedACCoefficients[0]));

    //
    // Initialize the arrays for the quantized AC coefficients.  We need to
    // keep these around as other blocks may want to use these values to do AC
    // coefficient prediction.
    //

    if (ACPredictionEnabled)
    {
        // The mmx routine we use to do the DCT inversion assumes that the
        // AC coefficients are rotated...this forces us to use the vertical
        // opposite predicted arrays...
        //
        if (IsPredictedLeft)
        {
            memset(TopQuantizedACCoefficients + 1, 0, sizeof(TopQuantizedACCoefficients[1]) * 7);
            pZigZag = g_VerticalZigzag;
        }
        else
        {
            memset(LeftQuantizedACCoefficients + 1,  0, sizeof(LeftQuantizedACCoefficients[1]) * 7);
            pZigZag = g_HorizontalZigzag;
        }
    }
    else
    {
        memset(TopQuantizedACCoefficients + 1,  0, sizeof(TopQuantizedACCoefficients[1]) * 7);
        memset(LeftQuantizedACCoefficients + 1, 0, sizeof(TopQuantizedACCoefficients[1]) * 7);

        pZigZag = g_NormalZigzag;
    }

    //
    // Read in the AC coefficients if this block has any.   This will inverse-
    // zigzag and invert-quantize the input at the same time except for the
    // ACs that are in either the first row or the first column.
    //

    DoubleQuantizerScale = PictureQuantizerScale * 2;
    QuantizerScaleOdd = (PictureQuantizerScale & 1) ? PictureQuantizerScale : PictureQuantizerScale - 1;

    if (HasEncodedACCoefficientInformation)
    {
        CoefficientCounter = 1;

        do
        {
            Index = HuffmanDecode(pDecoder, pACDecoderTable->pDTCACDecoderTable);
            ASSERT(Index <= pACDecoderTable->DCTACDecoderEscapeCode);

            // Normal case.
            if (Index != pACDecoderTable->DCTACDecoderEscapeCode)
            {
                Done = (Index >= pACDecoderTable->StartIndexOfLastRun);

                Run   = pACDecoderTable->RunTable[Index];
                Level = pACDecoderTable->LevelTable[Index];

                if (ReadOneBit(pDecoder))
                {
                    Level = -Level;
                }
            }

            // ESC + 1
            else if (ReadOneBit(pDecoder))
            {
                Index = HuffmanDecode(pDecoder, pACDecoderTable->pDTCACDecoderTable);

                Done = (Index >= pACDecoderTable->StartIndexOfLastRun);

                Run   = pACDecoderTable->RunTable[Index];
                Level = pACDecoderTable->LevelTable[Index];

                if (!Done)
                {
                    Level = Level + pACDecoderTable->NotLastDeltaLevelTable[Run];
                }
                else
                {
                    Level = Level + pACDecoderTable->LastDeltaLevelTable[Run];
                }

                if (ReadOneBit(pDecoder))
                {
                    Level = -Level;
                }
            }

            // ESC + 01
            else if (ReadOneBit(pDecoder))
            {
                Index = HuffmanDecode(pDecoder, pACDecoderTable->pDTCACDecoderTable);

                Done = (Index >= pACDecoderTable->StartIndexOfLastRun);

                Run   = pACDecoderTable->RunTable[Index];
                Level = pACDecoderTable->LevelTable[Index];

                if (!Done)
                {
                    Run = Run + pACDecoderTable->NotLastDeltaRunTable[Level] + 1;
                }
                else
                {
                    Run = Run + pACDecoderTable->LastDeltaRunTable[Level] + 1;
                }

                if (ReadOneBit(pDecoder))
                {
                    Level = -Level;
                }
            }

            // ESC + 00
            else
            {
                Done = ReadOneBit(pDecoder);

                if (!*pEscape3RunLength)
                {
                    if (PictureQuantizerScale >= 8)
                    {
                        i = 0;
                        Bit = 0;

                        while (i < 6 && !Bit)
                        {
                            Bit = ReadOneBit(pDecoder);
                            i++;
                        }

                        if (Bit)
                        {
                            *pEscape3LevelLength = i + 1;
                        }
                        else
                        {
                            *pEscape3LevelLength = 8;
                        }
                    }
                    else
                    {
                        *pEscape3LevelLength = ReadBits(pDecoder, 3);

                        if (!*pEscape3LevelLength)
                        {
                            *pEscape3LevelLength = 8 + ReadOneBit(pDecoder);
                        }
                    }

                    *pEscape3RunLength = 3 + ReadBits(pDecoder, 2);
                }

                Run   = ReadBits(pDecoder, *pEscape3RunLength);   
                Sign  = ReadOneBit(pDecoder);
                Level = ReadBits(pDecoder, *pEscape3LevelLength);

                if (Sign)
                {
                    Level = -Level;
                }
            }

            // Zip past the run of zeros.
            CoefficientCounter += Run;

            // Prevent a potential buffer overrun.
            if (CoefficientCounter > 63)
            {
                RIP("Buffer overrun while decoding file, bad file.");

                CoefficientCounter = 63;
            }

            // De-zigzag the coefficient we just decoded.
            CoefficientIndex = pZigZag[CoefficientCounter];

            // If this AC coefficient is in either the first row or column
            // then we need to store it in the Top/Left arrays.
            //
            // Top
            if (CoefficientIndex / 8 == 0)
            {
                LeftQuantizedACCoefficients[CoefficientIndex] += (short)Level;
            }

            // Left
            else if (CoefficientIndex % 8 == 0)
            {
                TopQuantizedACCoefficients[CoefficientIndex / 8] += (short)Level;
            }

            // Other
            else if (Level > 0)
            {
                ReconstructedACCoefficients[CoefficientIndex] = DoubleQuantizerScale * Level + QuantizerScaleOdd;
            }

            else // Level < 0
            {
                ReconstructedACCoefficients[CoefficientIndex] = DoubleQuantizerScale * Level - QuantizerScaleOdd;
            }

            CoefficientCounter++;
        }
        while(!Done);
    }

    // 
    // Inverse Quantize and propigate the first row and column AC coefficients
    // to the unquantized coefficient matrix.  The other coefficients are done
    // as they are read in.
    //

    for (i = 1; i < 8; i++)
    {
        QuantizedACCoefficient = LeftQuantizedACCoefficients[i];

        if (QuantizedACCoefficient == 0)
        {
            ReconstructedACCoefficients[i] = 0;
        }
        else if (QuantizedACCoefficient > 0)
        {
            ReconstructedACCoefficients[i] = DoubleQuantizerScale * QuantizedACCoefficient + QuantizerScaleOdd;
        }
        else // QuantizedACCoefficient < 0
        {
            ReconstructedACCoefficients[i] = DoubleQuantizerScale * QuantizedACCoefficient - QuantizerScaleOdd;
        }

        QuantizedACCoefficient = TopQuantizedACCoefficients[i];

        if (QuantizedACCoefficient == 0)
        {
            ReconstructedACCoefficients[i * 8] = 0;
        }
        else if (QuantizedACCoefficient > 0)
        {
            ReconstructedACCoefficients[i * 8] = DoubleQuantizerScale * QuantizedACCoefficient + QuantizerScaleOdd;
        }
        else // QuantizedACCoefficient < 0
        {
            ReconstructedACCoefficients[i * 8] = DoubleQuantizerScale * QuantizedACCoefficient - QuantizerScaleOdd;
        }
    }
    
    // 
    // Convert the AC coefficients into a bitmap.
    //

    InverseDCT(pDestination, Pitch, ReconstructedACCoefficients);
}

/* 
 * Decodes the guts of a baseline I-frame
 */
 
#if DBG

DWORD g_IFrameCount;

#endif DBG

void DecodeBaselineIFrame
(
    XMVDecoder *pDecoder,
    DWORD PictureQuantizerScale
)
{
    DWORD MBWidth;
    DWORD MBHeight;

    DWORD DCStepSize;
    short DefaultDCPredictor;

    BYTE *pY;
    BYTE *pU;
    BYTE *pV;
    BYTE *pBlock;

    DWORD YPitch, UVPitch;

    DWORD Escape3RunLength;
    DWORD Escape3LevelLength;

    // Frame header.
    BOOL  MBLevelDCTACCoding;

    XMVACCoefficientDecoderTable *pDCTACInterCodingSetTable;
    XMVACCoefficientDecoderTable *pDCTACIntraCodingSetTable;

    // CBPCY Decoding.
    XMVMacroblockCBPCY CBPCYTopLeft, CBPCYTop;
    XMVMacroblockCBPCY *pCBPCYLine;

    DWORD DecodedCBPCY, DecodedY1, DecodedY2, DecodedY3, DecodedY4;

    BOOL ACPredictionEnabled;

    // Block decoding tables.
    WORD *pYDCDifferentialTable;
    WORD *pUVDCDifferentialTable;

    DWORD MBACCodingSetIndex;

    short YLeftACQuantizedCoefficients[2][BLOCK_SIZE];
    short YDCTopLeft[2], YDCTop;
    short YDCTopLeftForNextMacroblock;
    short *pYACLine;

    short ULeftACQuantizedCoefficients[BLOCK_SIZE];
    short UDCTopLeft, UDCTop;
    short *pUACLine;

    short VLeftACQuantizedCoefficients[BLOCK_SIZE];
    short VDCTopLeft, VDCTop;
    short *pVACLine;

    DWORD x, y, block;

#if DBG

    g_IFrameCount++;

#endif DBG

    MBWidth  = pDecoder->MBWidth;
    MBHeight = pDecoder->MBHeight;

    pY = pDecoder->pYBuilding;
    pU = pDecoder->pUBuilding;
    pV = pDecoder->pVBuilding;

#if DBG
    memset(pY, 0xFF, MBWidth * MACROBLOCK_SIZE * MBHeight * MACROBLOCK_SIZE);
    memset(pU, 0xFF, MBWidth * BLOCK_SIZE * MBHeight * BLOCK_SIZE);
    memset(pV, 0xFF, MBWidth * BLOCK_SIZE * MBHeight * BLOCK_SIZE);
#endif

    YPitch  = MBWidth * MACROBLOCK_SIZE;
    UVPitch = MBWidth * BLOCK_SIZE;

    if (PictureQuantizerScale <= 4)
    {
        DCStepSize = 8;
    }
    else
    {
        DCStepSize = PictureQuantizerScale / 2 + 6;
    }

    Escape3RunLength = 0;
    Escape3LevelLength = 0;

    // Initialize our YACPrecition tables.
    memset(pDecoder->pYAC, 0, sizeof(short) * MACROBLOCK_SIZE * MBWidth);
    memset(pDecoder->pUAC, 0, sizeof(short) * BLOCK_SIZE * MBWidth);
    memset(pDecoder->pVAC, 0, sizeof(short) * BLOCK_SIZE * MBWidth);

    DefaultDCPredictor = (short)((1024 + (DCStepSize >> 1)) / DCStepSize);

    for (x = 0; x < MBWidth; x++)
    {
        *(pDecoder->pYAC + x * MACROBLOCK_SIZE) = DefaultDCPredictor;
        *(pDecoder->pYAC + x * MACROBLOCK_SIZE + BLOCK_SIZE) = DefaultDCPredictor;

        *(pDecoder->pUAC + x * BLOCK_SIZE) = DefaultDCPredictor;
        *(pDecoder->pVAC + x * BLOCK_SIZE) = DefaultDCPredictor;
    }

    // Use the preallocated CBPCY array, setting the extra one off to
    // the far left so things work for the beginning of a row.
    //
    pCBPCYLine = pDecoder->pCBPCY + 1;

    // Blank it out, along with the "Last" one, to set to the default values.
    ASSERT(sizeof(XMVMacroblockCBPCY) == 1);

    memset(pDecoder->pCBPCY + 1, 0, sizeof(XMVMacroblockCBPCY) * MBWidth);

    // Are the DCT AC codes done at a macroblock level?
    MBLevelDCTACCoding = ReadOneBit(pDecoder);

    // If not, read the code up-front.
    if (!MBLevelDCTACCoding)
    {
        // The picture-wide DCT AC inter coding set index.
        pDCTACInterCodingSetTable = &g_InterDecoderTables[ReadTriStateBits(pDecoder)];

        // The picture-wide DCT AC intra coding set index (table 2).
        pDCTACIntraCodingSetTable = &g_IntraDecoderTables[ReadTriStateBits(pDecoder)];
    }

    // Which intra table to use.
    if (!ReadOneBit(pDecoder))
    {
        // Talking
        pYDCDifferentialTable  = g_Huffman_DCTDCy_Talking;
        pUVDCDifferentialTable = g_Huffman_DCTDCc_Talking;
    }
    else
    {
        // High motion
        pYDCDifferentialTable  = g_Huffman_DCTDCy_HighMotion;
        pUVDCDifferentialTable = g_Huffman_DCTDCc_HighMotion;
    }

    // Iterate through all of the macroblocks.
    for (y = 0; y < MBHeight; y++)
    {
        // Reset the line arrays.
        pCBPCYLine = pDecoder->pCBPCY + 1;
        *(BYTE *)&CBPCYTopLeft = 0;

        pYACLine      = pDecoder->pYAC;
        YDCTopLeft[0] = DefaultDCPredictor;

        pUACLine   = pDecoder->pUAC;
        UDCTopLeft = DefaultDCPredictor;

        pVACLine   = pDecoder->pVAC;
        VDCTopLeft = DefaultDCPredictor;

        memset(YLeftACQuantizedCoefficients, 0, sizeof(YLeftACQuantizedCoefficients));
        memset(ULeftACQuantizedCoefficients, 0, sizeof(ULeftACQuantizedCoefficients));
        memset(VLeftACQuantizedCoefficients, 0, sizeof(VLeftACQuantizedCoefficients));

        YLeftACQuantizedCoefficients[0][0] = DefaultDCPredictor;
        YLeftACQuantizedCoefficients[1][0] = DefaultDCPredictor;
        ULeftACQuantizedCoefficients[0]    = DefaultDCPredictor;
        VLeftACQuantizedCoefficients[0]    = DefaultDCPredictor;

        for (x = 0; x < MBWidth; x++)
        {
#if DBG
            g_TotalBitsRead = 0;
#endif DBG

#if DBG && 0

if (g_IFrameCount == 4 && x < 8 && y == 18)
{
    _asm int 3;
}

#endif DBG

            // Read the decoded iCBPCY.
            DecodedCBPCY = HuffmanDecode(pDecoder, g_Huffman_ICBPCY);

            DecodedY1 = (DecodedCBPCY >> 5) & 1;
            DecodedY2 = (DecodedCBPCY >> 4) & 1;
            DecodedY3 = (DecodedCBPCY >> 3) & 1;
            DecodedY4 = (DecodedCBPCY >> 2) & 1;

            // Calculate the CBPCY
            //
            // Y1 = (LT4 == T3 ? L2 : T3) ^ DecodedY1
            // Y2 = (T3 == T4 ? Y1 : T4) ^ DecodedY2
            // Y3 = (L2 == Y1 ? L4 : Y1) ^ DecodedY3
            // Y4 = (Y1 == Y2 ? Y3 : Y2) ^ DecodedY4
            //  U = DecodedU
            //  V = DecodedV
            //
            // We store all of the CBPCY values from the previous line in the
            // pCBPCYLine array.  The new values for this line are constructed
            // directly in that array so that the array contains the values
            // for this row up until the column we're building, but then
            // contains the values for the previous row.
            //
            // The algorithm for processing the row is:
            //
            //   Set TopLeft = 0
            //   for each x in the macroblock row
            //     Set Top = Line[x]
            //     Calculate Line[x] using TopLeft, Top and Line[x - 1] as Left
            //     TopLeft = Top
            //
            *(BYTE *)&CBPCYTop = *(BYTE *)(pCBPCYLine);

            pCBPCYLine->Y1 = (BYTE)((CBPCYTopLeft.Y4 == CBPCYTop.Y3 ? (pCBPCYLine - 1)->Y2 : CBPCYTop.Y3) ^ DecodedY1);
            pCBPCYLine->Y2 = (BYTE)((CBPCYTop.Y3 == CBPCYTop.Y4 ? pCBPCYLine->Y1 : CBPCYTop.Y4) ^ DecodedY2);
            pCBPCYLine->Y3 = (BYTE)(((pCBPCYLine - 1)->Y2 == pCBPCYLine->Y1 ? (pCBPCYLine - 1)->Y4 : pCBPCYLine->Y1) ^ DecodedY3);
            pCBPCYLine->Y4 = (BYTE)((pCBPCYLine->Y1 == pCBPCYLine->Y2 ? pCBPCYLine->Y3 : pCBPCYLine->Y2) ^ DecodedY4);
            pCBPCYLine->U  = (BYTE)((DecodedCBPCY >> 1) & 1);
            pCBPCYLine->V  = (BYTE)((DecodedCBPCY >> 0) & 1);

            *(BYTE *)&CBPCYTopLeft = *(BYTE *)&CBPCYTop;

            // Read the AC prediction flag.
            ACPredictionEnabled = ReadOneBit(pDecoder);

            // Read the macroblock-level DTC AC 
            if (MBLevelDCTACCoding && *(BYTE *)pCBPCYLine)
            {
                MBACCodingSetIndex = ReadTriStateBits(pDecoder);

                pDCTACInterCodingSetTable = &g_InterDecoderTables[MBACCodingSetIndex];
                pDCTACIntraCodingSetTable = &g_IntraDecoderTables[MBACCodingSetIndex];
            }

            // We use the same mechanism for keeping track of the most recent
            // Quantized AC Coefficients and DC Coefficients so we can do AC
            // coefficient prediction.  We do the same as with the CBPCY array
            // in that we only keep one row of coefficients but with the added
            // complexity of having to keep track of multiple lefts due to the
            // TopLeft/TopRight/BottomLeft/BottomRight order of the blocks
            // inside of the macroblock.
            //
            YDCTopLeftForNextMacroblock = *(pYACLine + BLOCK_SIZE);
            YDCTopLeft[1] = YLeftACQuantizedCoefficients[0][0];

            // For each of the Y block...
            for (block = 0; block < 4; block++)
            {
                pBlock = pY + BLOCK_SIZE * (block & 1) + BLOCK_SIZE * YPitch * (block >> 1);

                YDCTop = (pYACLine + (block & 1) * BLOCK_SIZE)[0];

                // Decode the block.
                DecodeBaselineIFrameBlock(pDecoder,
                                          pBlock,
                                          YPitch,
                                          DCStepSize,
                                          PictureQuantizerScale,
                                          (*(BYTE *)pCBPCYLine) & (1 << block),
                                          ACPredictionEnabled,
                                          YDCTopLeft[block >> 1],
                                          pYACLine + (block & 1) * BLOCK_SIZE,
                                          YLeftACQuantizedCoefficients[block >> 1], 
                                          pYDCDifferentialTable,
                                          INTRADCYTCOEF_ESCAPE_CODE,
                                          pDCTACIntraCodingSetTable,
                                          &Escape3RunLength,
                                          &Escape3LevelLength);

                YDCTopLeft[block >> 1] = YDCTop;

#if DBG && 0

if (g_IFrameCount == 4 && x < 8 && y == 18)
{
    DWORD i, j;

    DbgPrint("----- Y block # %d for Macroblock %d-%d\n\n", block, x, y);

    for (j = 0; j < BLOCK_SIZE; j++)
    {
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            DbgPrint("%02X ", *(pBlock + i + j * YPitch));
        }

        DbgPrint("\n");
    }

    DbgPrint("\n");
}

#endif DBG

            }

            // Remember the next top left.
            YDCTopLeft[0] = YDCTopLeftForNextMacroblock;

            // Move to the next pair.
            pYACLine += MACROBLOCK_SIZE;

            // Move to the next macroblock.
            pY += MACROBLOCK_SIZE;

            // The U Block.
            UDCTop = pUACLine[0];

            DecodeBaselineIFrameBlock(pDecoder,
                                      pU,
                                      UVPitch,
                                      DCStepSize,
                                      PictureQuantizerScale,
                                      pCBPCYLine->U,
                                      ACPredictionEnabled,
                                      UDCTopLeft,
                                      pUACLine,
                                      ULeftACQuantizedCoefficients, 
                                      pUVDCDifferentialTable,
                                      INTRADCUVTCOEF_ESCAPE_CODE,
                                      pDCTACInterCodingSetTable,
                                      &Escape3RunLength,
                                      &Escape3LevelLength);

            UDCTopLeft = UDCTop;
            pUACLine  += BLOCK_SIZE;

#if DBG && 0

if (g_IFrameCount == 4 && x < 8 && y == 18)
{
    DWORD i, j;

    DbgPrint("----- U block for Macroblock %d-%d\n\n", x, y);

    for (j = 0; j < BLOCK_SIZE; j++)
    {
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            DbgPrint("%02X ", *(pU + i + j * UVPitch));
        }

        DbgPrint("\n");
    }

    DbgPrint("\n");
}

#endif DBG

            pU += BLOCK_SIZE;

            // The V Block.
            VDCTop = pVACLine[0];

            DecodeBaselineIFrameBlock(pDecoder,
                                      pV,
                                      UVPitch,
                                      DCStepSize,
                                      PictureQuantizerScale,
                                      pCBPCYLine->V,
                                      ACPredictionEnabled,
                                      VDCTopLeft,
                                      pVACLine,
                                      VLeftACQuantizedCoefficients, 
                                      pUVDCDifferentialTable,
                                      INTRADCUVTCOEF_ESCAPE_CODE,
                                      pDCTACInterCodingSetTable,
                                      &Escape3RunLength,
                                      &Escape3LevelLength);

            VDCTopLeft = VDCTop;
            pVACLine  += BLOCK_SIZE;

#if DBG && 0

if (g_IFrameCount == 4 && x < 8 && y == 18)
{
    DWORD i, j;

    DbgPrint("----- V block for Macroblock %d-%d\n\n", x, y);

    for (j = 0; j < BLOCK_SIZE; j++)
    {
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            DbgPrint("%02X ", *(pV + i + j * UVPitch));
        }

        DbgPrint("\n");
    }

    DbgPrint("\n");
}

#endif DBG


            pV += BLOCK_SIZE;

            // Move to the next CBPCY macroblock descriptor.
            pCBPCYLine++;
        }

        // pY now points to the second row of a macroblock...move it down to 
        // point to the first row of the next row of macroblock.
        //
        pY += YPitch * (MACROBLOCK_SIZE - 1);

        // pU and pV points to the second of a block, move it down to point to
        // the first row of the next row of blocks.
        //
        pU += UVPitch * (BLOCK_SIZE - 1);
        pV += UVPitch * (BLOCK_SIZE - 1);
    }
}

/* 
 * Decodes an I-frame.
 */

void DecodeIFrame
(
    XMVDecoder *pDecoder
)
{
    DWORD XINTRA8Encoded = FALSE;
    DWORD PictureQuantizerScale;

    //
    // Decode the rest of the frame header.
    //

    // Ignore the buffer-fullness field.
    SkipBits(pDecoder, 7);

    // Read the picture quantizer field.
    PictureQuantizerScale = ReadBits(pDecoder, 5);

    // Get the XINTRA8 encoding mode but only if it's enabled.
    if (pDecoder->XIntra8IPictureCodingEnabled)
    {
        XINTRA8Encoded = ReadOneBit(pDecoder);
    }

    // Decode the proper frame.
    if (!XINTRA8Encoded)
    {
        DecodeBaselineIFrame(pDecoder, PictureQuantizerScale);
    }
    else
    {
        _asm int 3;
        //DecoderXINTRA8IFrame(pDecoder, &FrameData);
    }
}

/*
 * Decodes on frame into the next frame's YUV buffer.  This assumes that
 * the bit stream pointers have already been set up.
 */

void DecodeOneFrame
(
    XMVDecoder *pDecoder
)
{
    // I-Frame.
    if (!ReadOneBit(pDecoder))
    {
        DecodeIFrame(pDecoder);
    }

    // P-Frame
    else
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\inc\xmvformat.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xmvformat.h
 *  Content:    Xbox FMV file format
 *
 ****************************************************************************/

#pragma once

// This should be changed to '1' when we're sure that the format is stable.
// The decoder will refuse to load any version of the file that does not
// match.
//
#define XMV_FILE_VERSION        (-1)

// The magic cookie used to identify XMV files.
#define XMV_MAGIC_COOKIE        ('Xbox')

/*
// The data in the XMV file is organized into video packets designed to be
// loaded into a constant-sized buffer.  Each packet starts with the size
// of the next packet to allow it to be loaded via an overlapped IO call
// while the current packet is being processed.
*/

/*
// The very first video packet starts with a header describing the contents
// of the file followed by the normal video packet data.  The size of the
// first packet includes the size of this header so it can be read into
// the normal read buffer.
*/

// NOTE: I've tapped this down to 12 bytes to ensure that our packet
//   header size is always under 4096 bytes.  We need to keep it under 16 byes
//   or this little assumption I've made won't be true in perverse cases.
//
typedef struct _XMVAudioDataHeader
{
    // The WAVE_FORMAT tag that describes how the audio data in the stream is
    // encoded.  This can be either WAVE_FORMAT_PCM or WAVE_FORMAT_ADPCM.
    //
    WORD WaveFormat;

    // The number of channels in the audio stream.  Can be 1, 2, 4 or 6.
    WORD ChannelCount;

    // The number of samples per second (Hz) in the audio stream.
    DWORD SamplesPerSecond;

    // The number of bits in each sample.  
    DWORD BitsPerSample;
}
XMVAudioDataHeader;

typedef struct _XMVVideoDataHeader
{
    // A kinda-unique value to help verify that the decoder is actually
    // loading an XMV file.  Defined to always be XMV_MAGIC_COOKIE.
    //
    DWORD MagicCookie;

    // The file format version of this file to ensure that the version
    // of xmvtool that creates the XMV file matches the version of the
    // decoder.
    //
    DWORD FileVersion;

    // The size of the very first packet.
    DWORD ThisPacketSize;

    // The number of frames per second to display the video at.  All timing of
    // the playback is based off this value.  It can be any integer value
    // from zero to 60.  
    //
    DWORD FramesPerSecond;

    // The number of slices that the picture is divided into.
    DWORD Slices;

    // Various flags about how the picture is encoded.  This could be packed
    // a bit more but why bother to save a few bytes?
    //
    BOOLEAN MixedPelMotionCompensationEnable; 
    BOOLEAN LoopFilterEnabled; 
    BOOLEAN VariableSizedTransformEnabled;
    BOOLEAN XIntra8IPictureCodingEnabled;
    BOOLEAN HybridMotionVectorEnabled;
    BOOLEAN DCTTableSwitchingEnabled;
    
    // The width of the encoded video in pixels.  If this is zero then there
    // is no video encoded in this file.
    //
    DWORD Width;

    // The height of the encoded video in pixels.
    DWORD Height;

    // The buffer size required to load all of the video packets in this
    // file.
    //
    DWORD RequiredBufferSize;

    // The number of audio streams contained in each video packet.
    DWORD AudioStreamCount;

    // The descriptor for each audio stream.
    XMVAudioDataHeader AudioHeaders[0];
}
XMVVideoDataHeader;

/*
// The size of each video packet must be a multiple of 4096 bytes.
// 
// Every video packet begins with the following header:
*/

typedef struct _XMVPacketHeader
{
    // The size of the next video packet in bytes, including this
    // header.
    //
    DWORD NextPacketSize;
}
XMVPacketHeader;

/*
// The VideoPacketHeader immediately the PacketHeader.  It contains all of the
// information necessary for the decoder to find the different streams needed 
// to reconstruct the video.
*/

typedef struct _XMVAudioStreamHeader
{
    // The length of the audio data in the stream in bytes.  The actual space
    // reserved for the stream is always a multiple of 4 bytes.
    //
    DWORD AudioStreamSize;
}
XMVAudioStreamHeader;

typedef struct _XMVVideoPacketHeader
{
    // The length of the video stream in bytes.  Any padding needed
    // to take the packet out to a multiple of 4096 bytes should 
    // be added as zeros at the end of this stream.
    //
    // The size is not inclusive of any headers, including this one.
    //
    DWORD VideoStreamLength:24;

    // The number of frames encoded within this packet.  The time
    // represented by this packet is base solely off of the framerate and the
    // count here.  So if the video is encoded at 30fps and this packet
    // contains 15 frames then the packet represents exactly 1/2 a second.
    //
    DWORD FrameCount:8;

    // The audio stream sizes.  Each video packet contains the same
    // number of audio streams and they're always encoded in the
    // exact same order.
    //
    XMVAudioStreamHeader AudioStreams[0];
}
XMVVideoPacketHeader;

/*
// The data in the video stream doesn't seem to have any easy way to determine
// what the size of the data for each frame is.  The decode doesn't care much
// about this but it makes the tools difficult to implement.  Just shove
// a DWORD in front of each one for now and do something more fancy if this
// should prove to be too much.
*/

typedef struct _XMVVideoFrame
{
    DWORD FrameSize;
}
XMVVideoFrame;

/*
// ADPCM audio streams can't allow a single packet to cross a page boundary 
// or we'll have to allocate the entire buffer in contiguous memory...
// something I do not want to have to do.  We will instead break the stream
// up into chunks that do not cross such a boundary and can be fed
// individually to the audio hardware.
//
// A chunk always starts exactly at a page boundary.  The size in the chunk
// header always indicates how much audio data is contained in that chunk. 
// The next chunk starts at the next page boundary.
*/

typedef struct _XMVADPCMChunk
{
    // The size of the audio data in this chunk, not including any padding
    // needed to take this out to a page boundary.
    //
    DWORD AudioDataSize;
}
XMVADPCMChunk;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\test\main.c ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    App to test TV output

--*/

#include <xtl.h>
#include <xmv.h>

//------------------------------------------------------------------------------
// Intialize D3D.
//
void
Init()
{
    D3DPRESENT_PARAMETERS d3dpp;

    // Make D3D go.

    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;

    // Create the device.
    Direct3D_CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        NULL);
}

//==============================================================================
// Main goo.
//==============================================================================

//------------------------------------------------------------------------------
// Main entrypoint.
//
void __cdecl main()
{
    BOOL Enabled = FALSE;

    RECT SourceRect, DestRect;
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT rect;
    D3DSurface *pBackBuffer;
    D3DSurface *pSurfaceShow, *pSurfaceDraw, *pSurfaceSwap;

    DWORD x, y, t;
    DWORD *pBits;

    XMVDecoder *pDecoder;
    XMVVideoDescriptor VideoDescriptor;
    XMVRESULT xr;

    // Set up D3D.
    Init();

    // Load the movie.
    if (FAILED(XMVCreateDecoder("d:\\movies\\test00.xmv", &pDecoder)))
    {
        _asm int 3;
    }

    XMVGetVideoDescriptor(pDecoder, &VideoDescriptor);

    // Get the back buffer.
    D3DDevice_GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
    D3DSurface_GetDesc(pBackBuffer, &Desc);

    // Set up the overlay surfaces.
    D3DDevice_CreateImageSurface(VideoDescriptor.Width, VideoDescriptor.Height, D3DFMT_YUY2, &pSurfaceShow);
    D3DDevice_CreateImageSurface(VideoDescriptor.Width, VideoDescriptor.Height, D3DFMT_YUY2, &pSurfaceDraw);

    // Prepare the overlay rectangle.
    SourceRect.left = 0;
    SourceRect.top  = 0;
    SourceRect.right = VideoDescriptor.Width;
    SourceRect.bottom = VideoDescriptor.Height;

    DestRect.left   = 0;
    DestRect.right  = Desc.Width;
    DestRect.top    = 0;
    DestRect.bottom = Desc.Height;

    // Create my famous striped screen and present it.
    D3DSurface_LockRect(pBackBuffer, &rect, 0, D3DLOCK_TILED);

    for (y = 0; y < Desc.Height; y++)
    {
        pBits = (DWORD *)((BYTE *)rect.pBits + rect.Pitch * y);

        for (x = 0; x < Desc.Width; x++)
        {
            if (x & 0x20)
            {
                *pBits = 0x007F7F7F;
            }
            else
            {
                t = (x / 32) * 127 / (Desc.Width / 32);

                *pBits =  0x00010000 * t
                          | 0x00000001 * (127 - t);
            }

            pBits++;
        }
    }

    D3DDevice_Swap(0);

    // Do our loop!
    for(;;)
    {
        xr = XMVGetNextFrame(pDecoder, pSurfaceDraw);

        switch(xr)
        {
        case XMV_NOFRAME:
            break;

        case XMV_NEWFRAME:

            // Swap the surfaces.
            pSurfaceSwap = pSurfaceShow;
            pSurfaceShow = pSurfaceDraw;
            pSurfaceDraw = pSurfaceSwap;

            if (!Enabled)
            {
                D3DDevice_EnableOverlay(TRUE);
                Enabled = TRUE;
            }

            while(!D3DDevice_GetOverlayUpdateStatus())
                ;

            D3DDevice_UpdateOverlay(pSurfaceShow, &SourceRect, &DestRect, FALSE, 0x00000000);

            break;

        case XMV_ENDOFFILE:

            if (Enabled)
            {
                D3DDevice_EnableOverlay(FALSE);
                Enabled = FALSE;
            }
            break;

        case XMV_FAIL:
            _asm int 3;
            break;
        }
        
        D3DDevice_BlockUntilVerticalBlank();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\decoder\tables.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tables.c
 *  Content:    Holds all of the tables.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xmv.h>

#include "decoder.h"

/*
 * Rotated zigzag arrays that are used to map from the linear zig-zag format
 * the ACs are written in to our rectangular format.
 */

// !!! andrewso: these might not be quite right...the MMX routine seems to
//  expect the ACs to be rotated from where they would be normally but these
//  actually seem to be more correct.  This need a little more investigation
//  to figure out the actual differences.

BYTE g_HorizontalZigzag[] = 
{
     0,  8,  1, 16, 24,  9,  2,  3,
    10, 17, 32, 40, 25, 18, 11,  4,
     5,  6, 12, 19, 26, 33, 48, 56,
    41, 34, 27, 20, 13,  7, 14, 15,
    21, 28, 35, 42, 49, 57, 50, 43,
    36, 29, 22, 23, 30, 37, 44, 51,
    58, 59, 52, 45, 38, 31, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63,
};

BYTE g_VerticalZigzag[] = 
{
     0,  1,  2,  8,  3,  4,  5,  9,
    16, 24, 17, 10, 11,  6,  7, 13,
    12, 19, 18, 25, 32, 40, 33, 26,
    27, 20, 14, 15, 22, 21, 28, 35,
    34, 41, 48, 56, 49, 42, 43, 36,
    29, 30, 23, 31, 38, 37, 44, 51,
    50, 57, 58, 59, 52, 45, 39, 46,
    53, 60, 61, 54, 47, 55, 62, 63,
};

BYTE g_NormalZigzag[] = 
{
     0,  1,  8, 16,  9,  2,  3, 10,
    17, 24, 32, 25, 18, 11,  4,  5,
    12,  6, 19, 26, 33, 40, 48, 41,
    34, 27, 20, 13,  7, 14, 15, 21,
    28, 35, 42, 49, 56, 57, 50, 43,
    36, 29, 22, 23, 30, 31, 37, 44,
    51, 58, 59, 52, 45, 38, 39, 46,
    47, 53, 60, 61, 54, 55, 62, 63,
};

/*
 * Huffman tables
 */

WORD g_Huffman_ICBPCY[] =
{
    // Tables
    0x600F, 0x304F, 0x3057, 0x305F, 0x3067, 0x306F, 0x3077, 0x307F, 
    0x1087, 0x3089, 0x3091, 0x1099, 0x409B, 0x10AB, 0x20AD, 

    // Table 0
    0x0006, 0x6014, 0x600C, 0x000A, 0x5008, 0x5008, 0x5010, 0x5010, 
    0x0001, 0x0008, 0x5003, 0x5003, 0x5004, 0x5004, 0x0005, 0x0003, 
    0x0002, 0x0009, 0x5002, 0x5002, 0x6030, 0x6038, 0x0007, 0x6001, 
    0x4020, 0x4020, 0x4020, 0x4020, 0x6023, 0x0004, 0x6018, 0x6028, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 

    // Table 1
    0x1007, 0x1007, 0x1007, 0x1007, 0x3026, 0x302F, 0x303B, 0x3005, 

    // Table 2
    0x1006, 0x1006, 0x1006, 0x1006, 0x201B, 0x201B, 0x3036, 0x301F, 

    // Table 3
    0x1022, 0x1022, 0x1022, 0x1022, 0x3009, 0x3032, 0x2017, 0x2017, 

    // Table 4
    0x100A, 0x100A, 0x100A, 0x100A, 0x300D, 0x000B, 0x200E, 0x200E, 

    // Table 5
    0x3027, 0x000C, 0x202A, 0x202A, 0x100B, 0x100B, 0x100B, 0x100B, 

    // Table 6
    0x200F, 0x200F, 0x303A, 0x3021, 0x102C, 0x102C, 0x102C, 0x102C, 

    // Table 7
    0x1012, 0x1012, 0x1012, 0x1012, 0x000D, 0x301A, 0x302E, 0x3011, 

    // Table 8
    0x1024, 0x1013, 

    // Table 9
    0x101C, 0x101C, 0x101C, 0x101C, 0x2016, 0x2016, 0x302B, 0x000E, 

    // Table 10
    0x3033, 0x3037, 0x203C, 0x203C, 0x1034, 0x1034, 0x1034, 0x1034, 

    // Table 11
    0x103E, 0x1039, 

    // Table 12
    0x3025, 0x3025, 0x4019, 0x403D, 0x201D, 0x201D, 0x201D, 0x201D, 
    0x202D, 0x202D, 0x202D, 0x202D, 0x2035, 0x2035, 0x2035, 0x2035, 

    // Table 13
    0x1015, 0x103F, 

    // Table 14
    0x101E, 0x101E, 0x2029, 0x2031, 
};

WORD g_Huffman_DCTDCy_Talking[] =
{
    // Tables
    0x8006, 0x6106, 0x2146, 0x114A, 0x814C, 0x824C, 

    // Table 0
    0x7008, 0x7008, 0x0001, 0x800C, 0x7009, 0x7009, 0x0004, 0x800D, 
    0x5003, 0x5003, 0x5003, 0x5003, 0x5003, 0x5003, 0x5003, 0x5003, 
    0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 
    0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 
    0x6006, 0x6006, 0x6006, 0x6006, 0x700A, 0x700A, 0x0002, 0x800E, 
    0x5004, 0x5004, 0x5004, 0x5004, 0x5004, 0x5004, 0x5004, 0x5004, 
    0x6007, 0x6007, 0x6007, 0x6007, 0x700B, 0x700B, 0x0003, 0x800F, 
    0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 

    // Table 1
    0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 
    0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 
    0x501D, 0x501D, 0x6022, 0x6024, 0x501F, 0x501F, 0x6027, 0x6028, 
    0x3019, 0x3019, 0x3019, 0x3019, 0x3019, 0x3019, 0x3019, 0x3019, 
    0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 
    0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 
    0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 
    0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 

    // Table 2
    0x1011, 0x1011, 0x2018, 0x2016, 

    // Table 3
    0x1012, 0x1013, 

    // Table 4
    0x6029, 0x6029, 0x6029, 0x6029, 0x802D, 0x802C, 0x802E, 0x0005, 
    0x6026, 0x6026, 0x6026, 0x6026, 0x6025, 0x6025, 0x6025, 0x6025, 
    0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 
    0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 0x401C, 
    0x501E, 0x501E, 0x501E, 0x501E, 0x501E, 0x501E, 0x501E, 0x501E, 
    0x702A, 0x702A, 0x702B, 0x702B, 0x6023, 0x6023, 0x6023, 0x6023, 
    0x5020, 0x5020, 0x5020, 0x5020, 0x5020, 0x5020, 0x5020, 0x5020, 
    0x5021, 0x5021, 0x5021, 0x5021, 0x5021, 0x5021, 0x5021, 0x5021, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 

    // Table 5
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x8068, 0x8069, 0x806A, 0x806B, 0x806C, 0x806D, 0x806E, 0x806F, 
    0x8070, 0x8071, 0x8072, 0x8073, 0x8074, 0x8075, 0x8076, 0x8077, 
    0x7032, 0x7032, 0x7031, 0x7031, 0x7033, 0x7033, 0x7034, 0x7034, 
    0x7035, 0x7035, 0x7030, 0x7030, 0x7036, 0x7036, 0x7037, 0x7037, 
    0x7038, 0x7038, 0x7039, 0x7039, 0x703A, 0x703A, 0x703B, 0x703B, 
    0x703C, 0x703C, 0x703D, 0x703D, 0x703E, 0x703E, 0x703F, 0x703F, 
    0x7040, 0x7040, 0x7041, 0x7041, 0x7042, 0x7042, 0x7043, 0x7043, 
    0x7044, 0x7044, 0x7045, 0x7045, 0x7046, 0x7046, 0x7047, 0x7047, 
    0x7048, 0x7048, 0x7049, 0x7049, 0x704A, 0x704A, 0x704B, 0x704B, 
    0x704C, 0x704C, 0x704D, 0x704D, 0x704E, 0x704E, 0x704F, 0x704F, 
    0x7050, 0x7050, 0x7051, 0x7051, 0x7052, 0x7052, 0x7053, 0x7053, 
    0x7054, 0x7054, 0x7055, 0x7055, 0x7056, 0x7056, 0x7057, 0x7057, 
    0x7058, 0x7058, 0x7059, 0x7059, 0x705A, 0x705A, 0x705B, 0x705B, 
    0x705C, 0x705C, 0x705D, 0x705D, 0x705E, 0x705E, 0x705F, 0x705F, 
    0x7060, 0x7060, 0x7061, 0x7061, 0x7062, 0x7062, 0x7063, 0x7063, 
    0x7064, 0x7064, 0x7065, 0x7065, 0x7066, 0x7066, 0x7067, 0x7067, 
};

WORD g_Huffman_DCTDCc_Talking[] =
{
    // Tables
    0x8007, 0x1107, 0x4109, 0x7119, 0x1199, 0x319B, 0x81A3, 

    // Table 0
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x8010, 0x8014, 0x0005, 0x0001, 0x6008, 0x6008, 0x6008, 0x6008, 
    0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 
    0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x8015, 0x0003, 0x700E, 0x700E, 0x6009, 0x6009, 0x6009, 0x6009, 
    0x8011, 0x8016, 0x8012, 0x0002, 0x600B, 0x600B, 0x600B, 0x600B, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x600A, 0x600A, 0x600A, 0x600A, 0x600C, 0x600C, 0x600C, 0x600C, 
    0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 
    0x8013, 0x0004, 0x700F, 0x700F, 0x600D, 0x600D, 0x600D, 0x600D, 
    0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 

    // Table 1
    0x1018, 0x1017, 

    // Table 2
    0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 
    0x4029, 0x402B, 0x3027, 0x3027, 0x3028, 0x3028, 0x3025, 0x3025, 

    // Table 3
    0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 
    0x0006, 0x702E, 0x602D, 0x602D, 0x502C, 0x502C, 0x502C, 0x502C, 
    0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 
    0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 0x301F, 
    0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 
    0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 0x3024, 
    0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 
    0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 0x3022, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 
    0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 0x101A, 

    // Table 4
    0x101C, 0x101B, 

    // Table 5
    0x3026, 0x3023, 0x3020, 0x3021, 0x201D, 0x201D, 0x201E, 0x201E, 

    // Table 6
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x8068, 0x8069, 0x806A, 0x806B, 0x806C, 0x806D, 0x806E, 0x806F, 
    0x8070, 0x8071, 0x8072, 0x8073, 0x8074, 0x8075, 0x8076, 0x8077, 
    0x7030, 0x7030, 0x7031, 0x7031, 0x7032, 0x7032, 0x7033, 0x7033, 
    0x7034, 0x7034, 0x7035, 0x7035, 0x7036, 0x7036, 0x7037, 0x7037, 
    0x7038, 0x7038, 0x7039, 0x7039, 0x703A, 0x703A, 0x703B, 0x703B, 
    0x703C, 0x703C, 0x703D, 0x703D, 0x703E, 0x703E, 0x703F, 0x703F, 
    0x7040, 0x7040, 0x7041, 0x7041, 0x7042, 0x7042, 0x7043, 0x7043, 
    0x7044, 0x7044, 0x7045, 0x7045, 0x7046, 0x7046, 0x7047, 0x7047, 
    0x7048, 0x7048, 0x7049, 0x7049, 0x704A, 0x704A, 0x704B, 0x704B, 
    0x704C, 0x704C, 0x704D, 0x704D, 0x704E, 0x704E, 0x704F, 0x704F, 
    0x7050, 0x7050, 0x7051, 0x7051, 0x7052, 0x7052, 0x7053, 0x7053, 
    0x7054, 0x7054, 0x7055, 0x7055, 0x7056, 0x7056, 0x7057, 0x7057, 
    0x7058, 0x7058, 0x7059, 0x7059, 0x705A, 0x705A, 0x705B, 0x705B, 
    0x705C, 0x705C, 0x705D, 0x705D, 0x705E, 0x705E, 0x705F, 0x705F, 
    0x7060, 0x7060, 0x7061, 0x7061, 0x7062, 0x7062, 0x7063, 0x7063, 
    0x7064, 0x7064, 0x7065, 0x7065, 0x7066, 0x7066, 0x7067, 0x7067, 
};

WORD g_Huffman_DCTDCy_HighMotion[] =
{
    // Tables
    0x9007, 0x7207, 0x1287, 0x9289, 0x6489, 0x14C9, 0x84CB, 

    // Table 0
    0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 
    0x8011, 0x8011, 0x0001, 0x9018, 0x8012, 0x8012, 0x0002, 0x0003, 
    0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 
    0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 0x5005, 
    0x700D, 0x700D, 0x700D, 0x700D, 0x8013, 0x8013, 0x9019, 0x901A, 
    0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 
    0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 
    0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 
    0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x700E, 0x700E, 0x700E, 0x700E, 0x8014, 0x8014, 0x901B, 0x0004, 
    0x600A, 0x600A, 0x600A, 0x600A, 0x600A, 0x600A, 0x600A, 0x600A, 
    0x700F, 0x700F, 0x700F, 0x700F, 0x901C, 0x901D, 0x8015, 0x8015, 
    0x600B, 0x600B, 0x600B, 0x600B, 0x600B, 0x600B, 0x600B, 0x600B, 
    0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 
    0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 
    0x7010, 0x7010, 0x7010, 0x7010, 0x8016, 0x8016, 0x8017, 0x8017, 
    0x600C, 0x600C, 0x600C, 0x600C, 0x600C, 0x600C, 0x600C, 0x600C, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 

    // Table 1
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 0x101E, 
    0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 
    0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 0x3026, 
    0x5030, 0x5030, 0x5030, 0x5030, 0x7037, 0x7039, 0x6033, 0x6033, 
    0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 0x402A, 
    0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 
    0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 
    0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 
    0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 0x2022, 

    // Table 2
    0x101F, 0x1021, 

    // Table 3
    0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 
    0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 0x502E, 
    0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 
    0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 0x502F, 
    0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 
    0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 
    0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 
    0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 0x402B, 
    0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 
    0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 
    0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 
    0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 0x402D, 
    0x6032, 0x6032, 0x6032, 0x6032, 0x6032, 0x6032, 0x6032, 0x6032, 
    0x903F, 0x0006, 0x803D, 0x803D, 0x0005, 0x903E, 0x803B, 0x803B, 
    0x6035, 0x6035, 0x6035, 0x6035, 0x6035, 0x6035, 0x6035, 0x6035, 
    0x803C, 0x803C, 0x803A, 0x803A, 0x7038, 0x7038, 0x7038, 0x7038, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 0x2023, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 

    // Table 4
    0x3028, 0x3028, 0x3028, 0x3028, 0x3028, 0x3028, 0x3028, 0x3028, 
    0x3027, 0x3027, 0x3027, 0x3027, 0x3027, 0x3027, 0x3027, 0x3027, 
    0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 
    0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 0x2024, 
    0x402C, 0x402C, 0x402C, 0x402C, 0x5031, 0x5031, 0x6036, 0x6034, 
    0x3029, 0x3029, 0x3029, 0x3029, 0x3029, 0x3029, 0x3029, 0x3029, 
    0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 
    0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 0x2025, 

    // Table 5
    0x1040, 0x1042, 

    // Table 6
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x8050, 0x8051, 0x8052, 0x8053, 0x8054, 0x8055, 0x8056, 0x8057, 
    0x8058, 0x8059, 0x805A, 0x805B, 0x805C, 0x805D, 0x805E, 0x805F, 
    0x8060, 0x8061, 0x8062, 0x8063, 0x8064, 0x8065, 0x8066, 0x8067, 
    0x8068, 0x8069, 0x806A, 0x806B, 0x806C, 0x806D, 0x806E, 0x806F, 
    0x8070, 0x8071, 0x8072, 0x8073, 0x8074, 0x8075, 0x8076, 0x8077, 
    0x7045, 0x7045, 0x7046, 0x7046, 0x7047, 0x7047, 0x7048, 0x7048, 
    0x7049, 0x7049, 0x704A, 0x704A, 0x7044, 0x7044, 0x704B, 0x704B, 
    0x704C, 0x704C, 0x704D, 0x704D, 0x704E, 0x704E, 0x704F, 0x704F, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
};

WORD g_Huffman_DCTDCc_HighMotion[] =
{
    // Tables
    0x9005, 0x5205, 0x5225, 0x8245, 0x8345, 

    // Table 0
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
    0x6007, 0x6007, 0x6007, 0x6007, 0x6007, 0x6007, 0x6007, 0x6007, 
    0x700A, 0x700A, 0x700A, 0x700A, 0x800D, 0x800D, 0x0001, 0x9010, 
    0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 
    0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 0x5006, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 0x4004, 
    0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 0x6008, 
    0x700B, 0x700B, 0x700B, 0x700B, 0x800E, 0x800E, 0x9011, 0x0003, 
    0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 0x6009, 
    0x700C, 0x700C, 0x700C, 0x700C, 0x9012, 0x0002, 0x800F, 0x800F, 
    0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 
    0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 
    0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 
    0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 0x4005, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 
    0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 0x3003, 

    // Table 1
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x501F, 0x5020, 0x401D, 0x401D, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 
    0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 0x1013, 

    // Table 2
    0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 
    0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 0x1014, 
    0x2019, 0x2019, 0x2019, 0x2019, 0x2019, 0x2019, 0x2019, 0x2019, 
    0x5022, 0x5023, 0x401E, 0x401E, 0x301C, 0x301C, 0x301C, 0x301C, 

    // Table 3
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x6025, 0x6025, 0x6025, 0x6025, 0x0004, 0x802E, 0x7027, 0x7027, 
    0x7028, 0x7028, 0x7029, 0x7029, 0x7024, 0x7024, 0x702B, 0x702B, 
    0x702C, 0x702C, 0x702D, 0x702D, 0x6021, 0x6021, 0x6021, 0x6021, 
    0x602A, 0x602A, 0x602A, 0x602A, 0x6026, 0x6026, 0x6026, 0x6026, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 

    // Table 4
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 
    0x8068, 0x8069, 0x806A, 0x806B, 0x806C, 0x806D, 0x806E, 0x806F, 
    0x8070, 0x8071, 0x8072, 0x8073, 0x8074, 0x8075, 0x8076, 0x8077, 
    0x7030, 0x7030, 0x7031, 0x7031, 0x7032, 0x7032, 0x7033, 0x7033, 
    0x7034, 0x7034, 0x7035, 0x7035, 0x7036, 0x7036, 0x7037, 0x7037, 
    0x7038, 0x7038, 0x7039, 0x7039, 0x703A, 0x703A, 0x703B, 0x703B, 
    0x703C, 0x703C, 0x703D, 0x703D, 0x703E, 0x703E, 0x703F, 0x703F, 
    0x7040, 0x7040, 0x7041, 0x7041, 0x7042, 0x7042, 0x7043, 0x7043, 
    0x7044, 0x7044, 0x7045, 0x7045, 0x7046, 0x7046, 0x7047, 0x7047, 
    0x7048, 0x7048, 0x7049, 0x7049, 0x704A, 0x704A, 0x704B, 0x704B, 
    0x704C, 0x704C, 0x704D, 0x704D, 0x704E, 0x704E, 0x704F, 0x704F, 
    0x7050, 0x7050, 0x7051, 0x7051, 0x7052, 0x7052, 0x7053, 0x7053, 
    0x7054, 0x7054, 0x7055, 0x7055, 0x7056, 0x7056, 0x7057, 0x7057, 
    0x7058, 0x7058, 0x7059, 0x7059, 0x705A, 0x705A, 0x705B, 0x705B, 
    0x705C, 0x705C, 0x705D, 0x705D, 0x705E, 0x705E, 0x705F, 0x705F, 
    0x7060, 0x7060, 0x7061, 0x7061, 0x7062, 0x7062, 0x7063, 0x7063, 
    0x7064, 0x7064, 0x7065, 0x7065, 0x7066, 0x7066, 0x7067, 0x7067, 
};

// andrewso: I'm not sure which of these we truely need.  Switch them in
//   as we find we need them.
//
#if 0

WORD g_Huffman_MV_Talking[] =
{
    // Tables
    0x605A, 0x209A, 0x509E, 0x50BE, 0x50DE, 0x50FE, 0x511E, 0x513E, 
    0x515E, 0x517E, 0x519E, 0x51BE, 0x31DE, 0x31E6, 0x11EE, 0x41F0, 
    0x4200, 0x1210, 0x4212, 0x1222, 0x1224, 0x2226, 0x622A, 0x326A, 
    0x4272, 0x5282, 0x52A2, 0x22C2, 0x32C6, 0x42CE, 0x52DE, 0x62FE, 
    0x333E, 0x3346, 0x334E, 0x6356, 0x4396, 0x33A6, 0x53AE, 0x63CE, 
    0x640E, 0x644E, 0x648E, 0x24CE, 0x34D2, 0x24DA, 0x24DE, 0x24E2, 
    0x14E6, 0x34E8, 0x24F0, 0x34F4, 0x44FC, 0x450C, 0x251C, 0x5520, 
    0x2540, 0x1544, 0x2546, 0x154A, 0x554C, 0x356C, 0x4574, 0x3584, 
    0x558C, 0x55AC, 0x55CC, 0x35EC, 0x55F4, 0x3614, 0x261C, 0x4620, 
    0x5630, 0x6650, 0x5690, 0x66B0, 0x36F0, 0x16F8, 0x16FA, 0x26FC, 
    0x1700, 0x1702, 0x4704, 0x1714, 0x1716, 0x3718, 0x5720, 0x4740, 
    0x3750, 0x4758, 

    // Table 0
    0x0004, 0x6007, 0x6008, 0x0001, 0x000A, 0x0002, 0x5004, 0x5004, 
    0x0005, 0x0006, 0x0003, 0x0007, 0x4001, 0x4001, 0x4001, 0x4001, 
    0x5005, 0x5005, 0x0008, 0x0009, 0x4002, 0x4002, 0x4002, 0x4002, 
    0x5006, 0x5006, 0x000B, 0x6009, 0x4003, 0x4003, 0x4003, 0x4003, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 
    0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 

    // Table 1
    0x100A, 0x100A, 0x200E, 0x200F, 

    // Table 2
    0x2010, 0x2010, 0x2010, 0x2010, 0x2010, 0x2010, 0x2010, 0x2010, 
    0x4028, 0x4028, 0x5041, 0x000C, 0x4029, 0x4029, 0x000D, 0x5042, 
    0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 
    0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 0x100B, 

    // Table 3
    0x3021, 0x3021, 0x3021, 0x3021, 0x5048, 0x000F, 0x0010, 0x000E, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 
    0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 0x100C, 

    // Table 4
    0x244B, 0x244B, 0x244B, 0x244B, 0x244B, 0x244B, 0x244B, 0x244B, 
    0x0011, 0x0012, 0x0018, 0x503C, 0x3019, 0x3019, 0x3019, 0x3019, 
    0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 
    0x0017, 0x503D, 0x0013, 0x0014, 0x4025, 0x4025, 0x0015, 0x0016, 

    // Table 5
    0x2011, 0x2011, 0x2011, 0x2011, 0x2011, 0x2011, 0x2011, 0x2011, 
    0x301E, 0x301E, 0x301E, 0x301E, 0x5043, 0x0019, 0x5044, 0x001A, 
    0x2012, 0x2012, 0x2012, 0x2012, 0x2012, 0x2012, 0x2012, 0x2012, 
    0x402A, 0x402A, 0x001E, 0x001D, 0x5045, 0x001B, 0x5046, 0x001C, 

    // Table 6
    0x301F, 0x301F, 0x301F, 0x301F, 0x3020, 0x3020, 0x3020, 0x3020, 
    0x2013, 0x2013, 0x2013, 0x2013, 0x2013, 0x2013, 0x2013, 0x2013, 
    0x402B, 0x402B, 0x001F, 0x5047, 0x402C, 0x402C, 0x402D, 0x402D, 
    0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 0x2014, 

    // Table 7
    0x5049, 0x0021, 0x402E, 0x402E, 0x402F, 0x402F, 0x0022, 0x0020, 
    0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 0x2016, 
    0x3022, 0x3022, 0x3022, 0x3022, 0x504A, 0x504B, 0x0023, 0x504C, 
    0x504D, 0x0028, 0x0029, 0x002A, 0x0027, 0x0026, 0x0024, 0x0025, 

    // Table 8
    0x4030, 0x4030, 0x4031, 0x4031, 0x3023, 0x3023, 0x3023, 0x3023, 
    0x002B, 0x504E, 0x002C, 0x504F, 0x4032, 0x4032, 0x0033, 0x002D, 
    0x002E, 0x002F, 0x5050, 0x0030, 0x0035, 0x0034, 0x0031, 0x0032, 
    0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 0x2017, 

    // Table 9
    0x0036, 0x5051, 0x0037, 0x0038, 0x0039, 0x5052, 0x4033, 0x4033, 
    0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 0x2018, 
    0x5053, 0x003C, 0x4034, 0x4034, 0x0041, 0x0042, 0x0040, 0x003E, 
    0x003F, 0x003D, 0x003A, 0x003B, 0x3024, 0x3024, 0x3024, 0x3024, 

    // Table 10
    0x004B, 0x0049, 0x004A, 0x0048, 0x0043, 0x503E, 0x4026, 0x4026, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x503F, 0x0045, 0x0046, 0x0044, 0x301C, 0x301C, 0x301C, 0x301C, 
    0x4027, 0x4027, 0x0047, 0x5040, 0x301D, 0x301D, 0x301D, 0x301D, 

    // Table 11
    0x004C, 0x004D, 0x4035, 0x4035, 0x004E, 0x0055, 0x004F, 0x0050, 
    0x4036, 0x4036, 0x4037, 0x4037, 0x4038, 0x4038, 0x4039, 0x4039, 
    0x0056, 0x0051, 0x5054, 0x5055, 0x0052, 0x5056, 0x0059, 0x0057, 
    0x0053, 0x5057, 0x0054, 0x0058, 0x403A, 0x403A, 0x403B, 0x403B, 

    // Table 12
    0x1063, 0x1063, 0x1063, 0x1063, 0x30DD, 0x30DE, 0x2099, 0x2099, 

    // Table 13
    0x209A, 0x209A, 0x30DF, 0x30E0, 0x30E1, 0x30E2, 0x209B, 0x209B, 

    // Table 14
    0x1068, 0x1069, 

    // Table 15
    0x20A3, 0x20A3, 0x20A3, 0x20A3, 0x4162, 0x4163, 0x4164, 0x4165, 
    0x4166, 0x4167, 0x4168, 0x4169, 0x416A, 0x416B, 0x416C, 0x416D, 

    // Table 16
    0x416E, 0x416F, 0x4170, 0x4171, 0x4172, 0x4173, 0x4174, 0x4175, 
    0x4176, 0x4177, 0x4178, 0x4179, 0x30E8, 0x30E8, 0x30E9, 0x30E9, 

    // Table 17
    0x1058, 0x1059, 

    // Table 18
    0x208B, 0x208B, 0x208B, 0x208B, 0x4131, 0x4132, 0x4133, 0x4134, 
    0x105A, 0x105A, 0x105A, 0x105A, 0x105A, 0x105A, 0x105A, 0x105A, 

    // Table 19
    0x105B, 0x105C, 

    // Table 20
    0x105D, 0x105E, 

    // Table 21
    0x208E, 0x208F, 0x105F, 0x105F, 

    // Table 22
    0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 
    0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 
    0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 
    0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 0x1060, 
    0x51D4, 0x51D4, 0x62C9, 0x62CA, 0x62CB, 0x62CC, 0x62CD, 0x62CE, 
    0x62CF, 0x62D0, 0x62D1, 0x62D2, 0x62D3, 0x62D4, 0x62D5, 0x62D6, 
    0x62D7, 0x62D8, 0x62D9, 0x62DA, 0x62DB, 0x62DC, 0x62DD, 0x62DE, 
    0x62DF, 0x62E0, 0x62E1, 0x62E2, 0x62E3, 0x62E4, 0x62E5, 0x62E6, 

    // Table 23
    0x208C, 0x208C, 0x30D0, 0x30D1, 0x30D2, 0x30D3, 0x208D, 0x208D, 

    // Table 24
    0x4135, 0x4136, 0x4137, 0x4138, 0x30CA, 0x30CA, 0x30CB, 0x30CB, 
    0x30CC, 0x30CC, 0x30CD, 0x30CD, 0x30CE, 0x30CE, 0x30CF, 0x30CF, 

    // Table 25
    0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 
    0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 
    0x209C, 0x209C, 0x209C, 0x209C, 0x209C, 0x209C, 0x209C, 0x209C, 
    0x51FC, 0x51FD, 0x51FE, 0x51FF, 0x5200, 0x5201, 0x5202, 0x5203, 

    // Table 26
    0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 
    0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 0x1065, 
    0x5204, 0x5205, 0x5206, 0x5207, 0x5208, 0x5209, 0x520A, 0x520B, 
    0x520C, 0x520D, 0x520E, 0x520F, 0x5210, 0x5211, 0x5212, 0x5213, 

    // Table 27
    0x1066, 0x1066, 0x209D, 0x209E, 

    // Table 28
    0x1067, 0x1067, 0x1067, 0x1067, 0x209F, 0x209F, 0x30E5, 0x30E6, 

    // Table 29
    0x4155, 0x4156, 0x4157, 0x4158, 0x4159, 0x415A, 0x415B, 0x415C, 
    0x415D, 0x415E, 0x415F, 0x4160, 0x30E3, 0x30E3, 0x30E4, 0x30E4, 

    // Table 30
    0x5214, 0x5215, 0x5216, 0x5217, 0x5218, 0x5219, 0x521A, 0x521B, 
    0x521C, 0x521D, 0x521E, 0x521F, 0x5220, 0x5221, 0x5222, 0x5223, 
    0x5224, 0x5225, 0x5226, 0x5227, 0x5228, 0x5229, 0x522A, 0x522B, 
    0x4151, 0x4151, 0x4152, 0x4152, 0x4153, 0x4153, 0x4154, 0x4154, 

    // Table 31
    0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 
    0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 0x20A0, 
    0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 
    0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x20A1, 
    0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 
    0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 0x20A2, 
    0x30E7, 0x30E7, 0x30E7, 0x30E7, 0x30E7, 0x30E7, 0x30E7, 0x30E7, 
    0x522C, 0x522C, 0x6361, 0x6362, 0x4161, 0x4161, 0x4161, 0x4161, 

    // Table 32
    0x30F4, 0x30F5, 0x20A7, 0x20A7, 0x106A, 0x106A, 0x106A, 0x106A, 

    // Table 33
    0x30EA, 0x30EB, 0x30EC, 0x30ED, 0x20A4, 0x20A4, 0x20A5, 0x20A5, 

    // Table 34
    0x20A6, 0x20A6, 0x30EE, 0x30EF, 0x30F0, 0x30F1, 0x30F2, 0x30F3, 

    // Table 35
    0x30F6, 0x30F6, 0x30F6, 0x30F6, 0x30F6, 0x30F6, 0x30F6, 0x30F6, 
    0x6363, 0x6364, 0x6365, 0x6366, 0x6367, 0x6368, 0x6369, 0x636A, 
    0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 
    0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 0x20A8, 
    0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 
    0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 0x20A9, 
    0x636B, 0x636C, 0x636D, 0x636E, 0x636F, 0x6370, 0x6371, 0x6372, 
    0x6373, 0x6374, 0x6375, 0x6376, 0x6377, 0x6378, 0x6379, 0x637A, 

    // Table 36
    0x417C, 0x417D, 0x417E, 0x417F, 0x4180, 0x4181, 0x4182, 0x4183, 
    0x4184, 0x4185, 0x4186, 0x4187, 0x4188, 0x4189, 0x30F7, 0x30F7, 

    // Table 37
    0x30F8, 0x30F9, 0x30FA, 0x30FB, 0x30FC, 0x30FD, 0x30FE, 0x30FF, 

    // Table 38
    0x5245, 0x5246, 0x5247, 0x5248, 0x5249, 0x524A, 0x524B, 0x524C, 
    0x524D, 0x524E, 0x524F, 0x5250, 0x5251, 0x5252, 0x5253, 0x5254, 
    0x5255, 0x5256, 0x5257, 0x5258, 0x5259, 0x525A, 0x525B, 0x525C, 
    0x525D, 0x525E, 0x525F, 0x5260, 0x417A, 0x417A, 0x417B, 0x417B, 

    // Table 39
    0x643B, 0x643C, 0x643D, 0x643E, 0x643F, 0x6440, 0x6441, 0x6442, 
    0x6443, 0x6444, 0x6445, 0x6446, 0x6447, 0x6448, 0x6449, 0x644A, 
    0x522D, 0x522D, 0x522E, 0x522E, 0x522F, 0x522F, 0x5230, 0x5230, 
    0x5231, 0x5231, 0x5232, 0x5232, 0x5233, 0x5233, 0x5234, 0x5234, 
    0x5235, 0x5235, 0x5236, 0x5236, 0x5237, 0x5237, 0x5238, 0x5238, 
    0x5239, 0x5239, 0x523A, 0x523A, 0x523B, 0x523B, 0x523C, 0x523C, 
    0x523D, 0x523D, 0x523E, 0x523E, 0x523F, 0x523F, 0x5240, 0x5240, 
    0x5241, 0x5241, 0x5242, 0x5242, 0x5243, 0x5243, 0x5244, 0x5244, 

    // Table 40
    0x637B, 0x637C, 0x637D, 0x637E, 0x637F, 0x6380, 0x6381, 0x6382, 
    0x6383, 0x6384, 0x6385, 0x6386, 0x6387, 0x6388, 0x6389, 0x638A, 
    0x638B, 0x638C, 0x638D, 0x638E, 0x638F, 0x6390, 0x6391, 0x6392, 
    0x6393, 0x6394, 0x6395, 0x6396, 0x6397, 0x6398, 0x6399, 0x639A, 
    0x639B, 0x639C, 0x639D, 0x639E, 0x639F, 0x63A0, 0x63A1, 0x63A2, 
    0x63A3, 0x63A4, 0x63A5, 0x63A6, 0x63A7, 0x63A8, 0x63A9, 0x63AA, 
    0x63AB, 0x63AC, 0x63AD, 0x63AE, 0x63AF, 0x63B0, 0x63B1, 0x63B2, 
    0x63B3, 0x63B4, 0x63B5, 0x63B6, 0x63B7, 0x63B8, 0x63B9, 0x63BA, 

    // Table 41
    0x63BB, 0x63BC, 0x63BD, 0x63BE, 0x63BF, 0x63C0, 0x63C1, 0x63C2, 
    0x63C3, 0x63C4, 0x63C5, 0x63C6, 0x63C7, 0x63C8, 0x63C9, 0x63CA, 
    0x63CB, 0x63CC, 0x63CD, 0x63CE, 0x63CF, 0x63D0, 0x63D1, 0x63D2, 
    0x63D3, 0x63D4, 0x63D5, 0x63D6, 0x63D7, 0x63D8, 0x63D9, 0x63DA, 
    0x63DB, 0x63DC, 0x63DD, 0x63DE, 0x63DF, 0x63E0, 0x63E1, 0x63E2, 
    0x63E3, 0x63E4, 0x63E5, 0x63E6, 0x63E7, 0x63E8, 0x63E9, 0x63EA, 
    0x63EB, 0x63EC, 0x63ED, 0x63EE, 0x63EF, 0x63F0, 0x63F1, 0x63F2, 
    0x63F3, 0x63F4, 0x63F5, 0x63F6, 0x63F7, 0x63F8, 0x63F9, 0x63FA, 

    // Table 42
    0x63FB, 0x63FC, 0x63FD, 0x63FE, 0x63FF, 0x6400, 0x6401, 0x6402, 
    0x6403, 0x6404, 0x6405, 0x6406, 0x6407, 0x6408, 0x6409, 0x640A, 
    0x640B, 0x640C, 0x640D, 0x640E, 0x640F, 0x6410, 0x6411, 0x6412, 
    0x6413, 0x6414, 0x6415, 0x6416, 0x6417, 0x6418, 0x6419, 0x641A, 
    0x641B, 0x641C, 0x641D, 0x641E, 0x641F, 0x6420, 0x6421, 0x6422, 
    0x6423, 0x6424, 0x6425, 0x6426, 0x6427, 0x6428, 0x6429, 0x642A, 
    0x642B, 0x642C, 0x642D, 0x642E, 0x642F, 0x6430, 0x6431, 0x6432, 
    0x6433, 0x6434, 0x6435, 0x6436, 0x6437, 0x6438, 0x6439, 0x643A, 

    // Table 43
    0x20AA, 0x20AB, 0x106B, 0x106B, 

    // Table 44
    0x106C, 0x106C, 0x106C, 0x106C, 0x3100, 0x3101, 0x3102, 0x3103, 

    // Table 45
    0x20AD, 0x20AE, 0x106D, 0x106D, 

    // Table 46
    0x106E, 0x106E, 0x20AF, 0x20B0, 

    // Table 47
    0x20B1, 0x20B2, 0x106F, 0x106F, 

    // Table 48
    0x1070, 0x1071, 

    // Table 49
    0x310F, 0x3110, 0x20B3, 0x20B3, 0x1072, 0x1072, 0x1072, 0x1072, 

    // Table 50
    0x1073, 0x1073, 0x20B4, 0x20B5, 

    // Table 51
    0x3104, 0x3105, 0x3106, 0x3107, 0x3108, 0x3109, 0x20AC, 0x20AC, 

    // Table 52
    0x419A, 0x419B, 0x419C, 0x419D, 0x419E, 0x419F, 0x310A, 0x310A, 
    0x310B, 0x310B, 0x310C, 0x310C, 0x310D, 0x310D, 0x310E, 0x310E, 

    // Table 53
    0x418A, 0x418B, 0x418C, 0x418D, 0x418E, 0x418F, 0x4190, 0x4191, 
    0x4192, 0x4193, 0x4194, 0x4195, 0x4196, 0x4197, 0x4198, 0x4199, 

    // Table 54
    0x1074, 0x1074, 0x20B6, 0x20B7, 

    // Table 55
    0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 
    0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 
    0x41A0, 0x41A0, 0x5261, 0x5262, 0x3111, 0x3111, 0x3111, 0x3111, 
    0x3112, 0x3112, 0x3112, 0x3112, 0x3113, 0x3113, 0x3113, 0x3113, 

    // Table 56
    0x1076, 0x1076, 0x20B8, 0x20B9, 

    // Table 57
    0x1077, 0x1078, 

    // Table 58
    0x20BC, 0x20BD, 0x1079, 0x1079, 

    // Table 59
    0x107A, 0x107B, 

    // Table 60
    0x20BA, 0x20BA, 0x20BA, 0x20BA, 0x20BA, 0x20BA, 0x20BA, 0x20BA, 
    0x5263, 0x5264, 0x5265, 0x5266, 0x5267, 0x5268, 0x5269, 0x526A, 
    0x526B, 0x526C, 0x526D, 0x526E, 0x526F, 0x5270, 0x5271, 0x5272, 
    0x5273, 0x5274, 0x5275, 0x5276, 0x5277, 0x5278, 0x5279, 0x527A, 

    // Table 61
    0x311D, 0x311E, 0x311F, 0x3120, 0x3121, 0x3122, 0x20BB, 0x20BB, 

    // Table 62
    0x41AB, 0x41AC, 0x41AD, 0x41AE, 0x41AF, 0x41B0, 0x41B1, 0x41B2, 
    0x41B3, 0x41B4, 0x41B5, 0x41B6, 0x41B7, 0x41B8, 0x3114, 0x3114, 

    // Table 63
    0x3115, 0x3116, 0x3117, 0x3118, 0x3119, 0x311A, 0x311B, 0x311C, 

    // Table 64
    0x52BB, 0x52BC, 0x52BD, 0x52BE, 0x52BF, 0x52C0, 0x52C1, 0x52C2, 
    0x52C3, 0x52C4, 0x52C5, 0x52C6, 0x41A1, 0x41A1, 0x41A2, 0x41A2, 
    0x41A3, 0x41A3, 0x41A4, 0x41A4, 0x41A5, 0x41A5, 0x41A6, 0x41A6, 
    0x41A7, 0x41A7, 0x41A8, 0x41A8, 0x41A9, 0x41A9, 0x41AA, 0x41AA, 

    // Table 65
    0x527B, 0x527C, 0x527D, 0x527E, 0x527F, 0x5280, 0x5281, 0x5282, 
    0x5283, 0x5284, 0x5285, 0x5286, 0x5287, 0x5288, 0x5289, 0x528A, 
    0x528B, 0x528C, 0x528D, 0x528E, 0x528F, 0x5290, 0x5291, 0x5292, 
    0x5293, 0x5294, 0x5295, 0x5296, 0x5297, 0x5298, 0x5299, 0x529A, 

    // Table 66
    0x529B, 0x529C, 0x529D, 0x529E, 0x529F, 0x52A0, 0x52A1, 0x52A2, 
    0x52A3, 0x52A4, 0x52A5, 0x52A6, 0x52A7, 0x52A8, 0x52A9, 0x52AA, 
    0x52AB, 0x52AC, 0x52AD, 0x52AE, 0x52AF, 0x52B0, 0x52B1, 0x52B2, 
    0x52B3, 0x52B4, 0x52B5, 0x52B6, 0x52B7, 0x52B8, 0x52B9, 0x52BA, 

    // Table 67
    0x30D6, 0x30D7, 0x2090, 0x2090, 0x1061, 0x1061, 0x1061, 0x1061, 

    // Table 68
    0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 
    0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 0x1062, 
    0x51FA, 0x51FB, 0x4144, 0x4144, 0x4145, 0x4145, 0x4146, 0x4146, 
    0x4147, 0x4147, 0x4148, 0x4148, 0x4149, 0x4149, 0x414A, 0x414A, 

    // Table 69
    0x2091, 0x2091, 0x2092, 0x2092, 0x30D8, 0x30D9, 0x2093, 0x2093, 

    // Table 70
    0x2094, 0x2095, 0x2096, 0x2097, 

    // Table 71
    0x414B, 0x414C, 0x414D, 0x414E, 0x414F, 0x4150, 0x30DA, 0x30DA, 
    0x30DB, 0x30DB, 0x30DC, 0x30DC, 0x2098, 0x2098, 0x2098, 0x2098, 

    // Table 72
    0x51F8, 0x51F9, 0x4139, 0x4139, 0x413A, 0x413A, 0x413B, 0x413B, 
    0x413C, 0x413C, 0x413D, 0x413D, 0x413E, 0x413E, 0x413F, 0x413F, 
    0x4140, 0x4140, 0x4141, 0x4141, 0x4142, 0x4142, 0x4143, 0x4143, 
    0x30D4, 0x30D4, 0x30D4, 0x30D4, 0x30D5, 0x30D5, 0x30D5, 0x30D5, 

    // Table 73
    0x6327, 0x6328, 0x6329, 0x632A, 0x632B, 0x632C, 0x632D, 0x632E, 
    0x632F, 0x6330, 0x6331, 0x6332, 0x6333, 0x6334, 0x6335, 0x6336, 
    0x6337, 0x6338, 0x6339, 0x633A, 0x633B, 0x633C, 0x633D, 0x633E, 
    0x633F, 0x6340, 0x6341, 0x6342, 0x6343, 0x6344, 0x6345, 0x6346, 
    0x6347, 0x6348, 0x6349, 0x634A, 0x634B, 0x634C, 0x634D, 0x634E, 
    0x634F, 0x6350, 0x6351, 0x6352, 0x6353, 0x6354, 0x6355, 0x6356, 
    0x6357, 0x6358, 0x6359, 0x635A, 0x635B, 0x635C, 0x635D, 0x635E, 
    0x635F, 0x6360, 0x51D5, 0x51D5, 0x51D6, 0x51D6, 0x51D7, 0x51D7, 

    // Table 74
    0x51D8, 0x51D9, 0x51DA, 0x51DB, 0x51DC, 0x51DD, 0x51DE, 0x51DF, 
    0x51E0, 0x51E1, 0x51E2, 0x51E3, 0x51E4, 0x51E5, 0x51E6, 0x51E7, 
    0x51E8, 0x51E9, 0x51EA, 0x51EB, 0x51EC, 0x51ED, 0x51EE, 0x51EF, 
    0x51F0, 0x51F1, 0x51F2, 0x51F3, 0x51F4, 0x51F5, 0x51F6, 0x51F7, 

    // Table 75
    0x62E7, 0x62E8, 0x62E9, 0x62EA, 0x62EB, 0x62EC, 0x62ED, 0x62EE, 
    0x62EF, 0x62F0, 0x62F1, 0x62F2, 0x62F3, 0x62F4, 0x62F5, 0x62F6, 
    0x62F7, 0x62F8, 0x62F9, 0x62FA, 0x62FB, 0x62FC, 0x62FD, 0x62FE, 
    0x62FF, 0x6300, 0x6301, 0x6302, 0x6303, 0x6304, 0x6305, 0x6306, 
    0x6307, 0x6308, 0x6309, 0x630A, 0x630B, 0x630C, 0x630D, 0x630E, 
    0x630F, 0x6310, 0x6311, 0x6312, 0x6313, 0x6314, 0x6315, 0x6316, 
    0x6317, 0x6318, 0x6319, 0x631A, 0x631B, 0x631C, 0x631D, 0x631E, 
    0x631F, 0x6320, 0x6321, 0x6322, 0x6323, 0x6324, 0x6325, 0x6326, 

    // Table 76
    0x107C, 0x107C, 0x107C, 0x107C, 0x20BE, 0x20BE, 0x3123, 0x3124, 

    // Table 77
    0x107D, 0x107E, 

    // Table 78
    0x107F, 0x1080, 

    // Table 79
    0x20C0, 0x20C1, 0x1081, 0x1081, 

    // Table 80
    0x1082, 0x1083, 

    // Table 81
    0x1084, 0x1085, 

    // Table 82
    0x20C5, 0x20C5, 0x20C5, 0x20C5, 0x41BA, 0x41BB, 0x41BC, 0x41BD, 
    0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 

    // Table 83
    0x1087, 0x1088, 

    // Table 84
    0x1089, 0x108A, 

    // Table 85
    0x3125, 0x3126, 0x3127, 0x3128, 0x3129, 0x312A, 0x20BF, 0x20BF, 

    // Table 86
    0x312B, 0x312B, 0x312B, 0x312B, 0x52C7, 0x52C8, 0x41B9, 0x41B9, 
    0x20C2, 0x20C2, 0x20C2, 0x20C2, 0x20C2, 0x20C2, 0x20C2, 0x20C2, 
    0x20C3, 0x20C3, 0x20C3, 0x20C3, 0x20C3, 0x20C3, 0x20C3, 0x20C3, 
    0x20C4, 0x20C4, 0x20C4, 0x20C4, 0x20C4, 0x20C4, 0x20C4, 0x20C4, 

    // Table 87
    0x41CE, 0x41CF, 0x41D0, 0x41D1, 0x41D2, 0x41D3, 0x312C, 0x312C, 
    0x312D, 0x312D, 0x312E, 0x312E, 0x20C6, 0x20C6, 0x20C6, 0x20C6, 

    // Table 88
    0x312F, 0x3130, 0x20C7, 0x20C7, 0x20C8, 0x20C8, 0x20C9, 0x20C9, 

    // Table 89
    0x41BE, 0x41BF, 0x41C0, 0x41C1, 0x41C2, 0x41C3, 0x41C4, 0x41C5, 
    0x41C6, 0x41C7, 0x41C8, 0x41C9, 0x41CA, 0x41CB, 0x41CC, 0x41CD, 
};

WORD g_Huffman_MV_HighMotion[] =
{
    // Tables
    0x5097, 0x50B7, 0x50D7, 0x50F7, 0x5117, 0x5137, 0x5157, 0x5177, 
    0x5197, 0x51B7, 0x51D7, 0x51F7, 0x5217, 0x5237, 0x3257, 0x525F, 
    0x427F, 0x228F, 0x5293, 0x52B3, 0x12D3, 0x42D5, 0x22E5, 0x12E9, 
    0x22EB, 0x22EF, 0x32F3, 0x42FB, 0x330B, 0x4313, 0x4323, 0x4333, 
    0x4343, 0x3353, 0x335B, 0x5363, 0x4383, 0x3393, 0x539B, 0x23BB, 
    0x33BF, 0x43C7, 0x43D7, 0x43E7, 0x43F7, 0x4407, 0x3417, 0x241F, 
    0x2423, 0x1427, 0x1429, 0x242B, 0x342F, 0x2437, 0x443B, 0x344B, 
    0x3453, 0x345B, 0x4463, 0x4473, 0x2483, 0x2487, 0x148B, 0x448D, 
    0x349D, 0x44A5, 0x24B5, 0x34B9, 0x44C1, 0x34D1, 0x44D9, 0x44E9, 
    0x34F9, 0x3501, 0x4509, 0x4519, 0x4529, 0x3539, 0x3541, 0x3549, 
    0x3551, 0x3559, 0x4561, 0x4571, 0x4581, 0x1591, 0x1593, 0x2595, 
    0x3599, 0x25A1, 0x35A5, 0x35AD, 0x45B5, 0x35C5, 0x35CD, 0x35D5, 
    0x35DD, 0x35E5, 0x45ED, 0x45FD, 0x360D, 0x4615, 0x4625, 0x1635, 
    0x1637, 0x3639, 0x1641, 0x2643, 0x4647, 0x2657, 0x365B, 0x4663, 
    0x4673, 0x3683, 0x468B, 0x469B, 0x46AB, 0x36BB, 0x46C3, 0x46D3, 
    0x26E3, 0x36E7, 0x36EF, 0x46F7, 0x2707, 0x370B, 0x3713, 0x471B, 
    0x272B, 0x472F, 0x473F, 0x474F, 0x275F, 0x2763, 0x1767, 0x3769, 
    0x3771, 0x2779, 0x477D, 0x178D, 0x378F, 0x1797, 0x1799, 0x179B, 
    0x379D, 0x47A5, 0x47B5, 0x47C5, 0x37D5, 0x47DD, 0x47ED, 

    // Table 0
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x0001, 0x0003, 0x5004, 0x0004, 0x0007, 0x0008, 0x4001, 0x4001, 
    0x000B, 0x5005, 0x4002, 0x4002, 0x0009, 0x000C, 0x444B, 0x444B, 
    0x0002, 0x000A, 0x5006, 0x0005, 0x5007, 0x0006, 0x4003, 0x4003, 

    // Table 1
    0x0013, 0x000D, 0x000E, 0x5035, 0x300F, 0x300F, 0x300F, 0x300F, 
    0x0010, 0x5036, 0x0011, 0x5037, 0x0012, 0x000F, 0x4021, 0x4021, 
    0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 
    0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 

    // Table 2
    0x0014, 0x0015, 0x001F, 0x001B, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x001C, 0x001A, 0x0016, 0x0017, 0x001D, 0x001E, 0x0018, 0x0019, 
    0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 
    0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 0x1009, 

    // Table 3
    0x4022, 0x4022, 0x5038, 0x0026, 0x0020, 0x0021, 0x0022, 0x5039, 
    0x200A, 0x200A, 0x200A, 0x200A, 0x200A, 0x200A, 0x200A, 0x200A, 
    0x3010, 0x3010, 0x3010, 0x3010, 0x503A, 0x0023, 0x0024, 0x0025, 
    0x3011, 0x3011, 0x3011, 0x3011, 0x4023, 0x4023, 0x4024, 0x4024, 

    // Table 4
    0x002B, 0x503B, 0x002C, 0x0027, 0x503C, 0x0028, 0x002D, 0x0029, 
    0x200B, 0x200B, 0x200B, 0x200B, 0x200B, 0x200B, 0x200B, 0x200B, 
    0x3012, 0x3012, 0x3012, 0x3012, 0x4025, 0x4025, 0x503D, 0x002A, 
    0x200C, 0x200C, 0x200C, 0x200C, 0x200C, 0x200C, 0x200C, 0x200C, 

    // Table 5
    0x506C, 0x002E, 0x506D, 0x506E, 0x002F, 0x0030, 0x4032, 0x4032, 
    0x301E, 0x301E, 0x301E, 0x301E, 0x0034, 0x0038, 0x0035, 0x0031, 
    0x0036, 0x0032, 0x506F, 0x003A, 0x003B, 0x0039, 0x0037, 0x0033, 
    0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 0x200D, 

    // Table 6
    0x301F, 0x301F, 0x301F, 0x301F, 0x003C, 0x003D, 0x4033, 0x4033, 
    0x200E, 0x200E, 0x200E, 0x200E, 0x200E, 0x200E, 0x200E, 0x200E, 
    0x0043, 0x0040, 0x5070, 0x0041, 0x4034, 0x4034, 0x0042, 0x003E, 
    0x3020, 0x3020, 0x3020, 0x3020, 0x5071, 0x5072, 0x003F, 0x0044, 

    // Table 7
    0x3013, 0x3013, 0x3013, 0x3013, 0x503E, 0x004A, 0x0045, 0x004B, 
    0x3014, 0x3014, 0x3014, 0x3014, 0x0049, 0x503F, 0x5040, 0x5041, 
    0x5042, 0x0046, 0x0047, 0x5043, 0x4026, 0x4026, 0x5044, 0x004C, 
    0x3015, 0x3015, 0x3015, 0x3015, 0x0048, 0x5045, 0x5046, 0x5047, 

    // Table 8
    0x3016, 0x3016, 0x3016, 0x3016, 0x3017, 0x3017, 0x3017, 0x3017, 
    0x004F, 0x5048, 0x0052, 0x0050, 0x3018, 0x3018, 0x3018, 0x3018, 
    0x4027, 0x4027, 0x5049, 0x0053, 0x504A, 0x0054, 0x4028, 0x4028, 
    0x0051, 0x004D, 0x504B, 0x504C, 0x504D, 0x004E, 0x4029, 0x4029, 

    // Table 9
    0x005A, 0x5058, 0x0061, 0x005B, 0x0055, 0x5059, 0x402D, 0x402D, 
    0x0056, 0x005C, 0x402E, 0x402E, 0x0062, 0x005D, 0x0057, 0x0058, 
    0x505A, 0x005E, 0x0059, 0x0065, 0x402F, 0x402F, 0x0063, 0x005F, 
    0x3019, 0x3019, 0x3019, 0x3019, 0x505B, 0x505C, 0x0060, 0x0064, 

    // Table 10
    0x5066, 0x0066, 0x0072, 0x006F, 0x0067, 0x0068, 0x5067, 0x5068, 
    0x006E, 0x5069, 0x506A, 0x0069, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x301C, 0x301C, 0x301C, 0x301C, 0x006A, 0x006B, 0x506B, 0x006C, 
    0x301D, 0x301D, 0x301D, 0x301D, 0x0073, 0x0070, 0x0071, 0x006D, 

    // Table 11
    0x007C, 0x504E, 0x504F, 0x0081, 0x0074, 0x5050, 0x007D, 0x5051, 
    0x402A, 0x402A, 0x0075, 0x0076, 0x0077, 0x5052, 0x0082, 0x007E, 
    0x5053, 0x5054, 0x402B, 0x402B, 0x0078, 0x5055, 0x0079, 0x007A, 
    0x402C, 0x402C, 0x007B, 0x5056, 0x0083, 0x007F, 0x0080, 0x5057, 

    // Table 12
    0x0084, 0x0085, 0x505D, 0x0086, 0x0096, 0x0095, 0x0087, 0x505E, 
    0x505F, 0x0090, 0x5060, 0x0088, 0x4030, 0x4030, 0x0091, 0x0089, 
    0x5061, 0x5062, 0x0092, 0x0093, 0x5063, 0x008A, 0x008B, 0x008C, 
    0x4031, 0x4031, 0x0094, 0x008D, 0x5064, 0x008E, 0x008F, 0x5065, 

    // Table 13
    0x314A, 0x314A, 0x314A, 0x314A, 0x314B, 0x314B, 0x314B, 0x314B, 
    0x314C, 0x314C, 0x314C, 0x314C, 0x4270, 0x4270, 0x5425, 0x5426, 
    0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 
    0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 0x1073, 

    // Table 14
    0x314D, 0x314E, 0x20C3, 0x20C3, 0x1074, 0x1074, 0x1074, 0x1074, 

    // Table 15
    0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 
    0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 0x1075, 
    0x3154, 0x3154, 0x3154, 0x3154, 0x5429, 0x542A, 0x542B, 0x542C, 
    0x542D, 0x542E, 0x542F, 0x5430, 0x5431, 0x5432, 0x5433, 0x5434, 

    // Table 16
    0x4271, 0x4272, 0x4273, 0x4274, 0x4275, 0x4276, 0x4277, 0x4278, 
    0x314F, 0x314F, 0x3150, 0x3150, 0x20C4, 0x20C4, 0x20C4, 0x20C4, 

    // Table 17
    0x20C5, 0x20C6, 0x20C7, 0x20C8, 

    // Table 18
    0x4279, 0x4279, 0x5427, 0x5428, 0x3151, 0x3151, 0x3151, 0x3151, 
    0x3152, 0x3152, 0x3152, 0x3152, 0x3153, 0x3153, 0x3153, 0x3153, 
    0x20C9, 0x20C9, 0x20C9, 0x20C9, 0x20C9, 0x20C9, 0x20C9, 0x20C9, 
    0x20CA, 0x20CA, 0x20CA, 0x20CA, 0x20CA, 0x20CA, 0x20CA, 0x20CA, 

    // Table 19
    0x5417, 0x5418, 0x5419, 0x541A, 0x541B, 0x541C, 0x541D, 0x541E, 
    0x541F, 0x5420, 0x5421, 0x5422, 0x5423, 0x5424, 0x4267, 0x4267, 
    0x4268, 0x4268, 0x4269, 0x4269, 0x426A, 0x426A, 0x426B, 0x426B, 
    0x426C, 0x426C, 0x426D, 0x426D, 0x426E, 0x426E, 0x426F, 0x426F, 

    // Table 20
    0x10A3, 0x10A4, 

    // Table 21
    0x211D, 0x211D, 0x211D, 0x211D, 0x4377, 0x4378, 0x4379, 0x437A, 
    0x10A5, 0x10A5, 0x10A5, 0x10A5, 0x10A5, 0x10A5, 0x10A5, 0x10A5, 

    // Table 22
    0x10A6, 0x10A6, 0x2121, 0x2122, 

    // Table 23
    0x10A7, 0x10A8, 

    // Table 24
    0x10A9, 0x10A9, 0x2123, 0x2124, 

    // Table 25
    0x2125, 0x2126, 0x10AA, 0x10AA, 

    // Table 26
    0x3214, 0x3215, 0x211E, 0x211E, 0x211F, 0x211F, 0x2120, 0x2120, 

    // Table 27
    0x438B, 0x438C, 0x438D, 0x438E, 0x438F, 0x4390, 0x4391, 0x4392, 
    0x4393, 0x4394, 0x3209, 0x3209, 0x320A, 0x320A, 0x320B, 0x320B, 

    // Table 28
    0x320C, 0x320D, 0x320E, 0x320F, 0x3210, 0x3211, 0x3212, 0x3213, 

    // Table 29
    0x4395, 0x4396, 0x3216, 0x3216, 0x3217, 0x3217, 0x3218, 0x3218, 
    0x3219, 0x3219, 0x321A, 0x321A, 0x321B, 0x321B, 0x321C, 0x321C, 

    // Table 30
    0x321D, 0x321D, 0x321E, 0x321E, 0x321F, 0x321F, 0x3220, 0x3220, 
    0x3221, 0x3221, 0x3222, 0x3222, 0x3223, 0x3223, 0x4397, 0x4398, 

    // Table 31
    0x437B, 0x437C, 0x437D, 0x437E, 0x437F, 0x4380, 0x4381, 0x4382, 
    0x4383, 0x4384, 0x4385, 0x4386, 0x4387, 0x4388, 0x4389, 0x438A, 

    // Table 32
    0x4280, 0x4281, 0x4282, 0x4283, 0x3155, 0x3155, 0x3156, 0x3156, 
    0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 

    // Table 33
    0x1077, 0x1077, 0x1077, 0x1077, 0x20CB, 0x20CB, 0x3157, 0x3158, 

    // Table 34
    0x1078, 0x1078, 0x1078, 0x1078, 0x20CC, 0x20CC, 0x3159, 0x315A, 

    // Table 35
    0x4284, 0x4284, 0x5449, 0x544A, 0x4285, 0x4285, 0x4286, 0x4286, 
    0x20CD, 0x20CD, 0x20CD, 0x20CD, 0x20CD, 0x20CD, 0x20CD, 0x20CD, 
    0x4287, 0x4287, 0x4288, 0x4288, 0x4289, 0x4289, 0x428A, 0x428A, 
    0x428B, 0x428B, 0x428C, 0x428C, 0x428D, 0x428D, 0x428E, 0x428E, 

    // Table 36
    0x428F, 0x4290, 0x315B, 0x315B, 0x315C, 0x315C, 0x315D, 0x315D, 
    0x315E, 0x315E, 0x315F, 0x315F, 0x20CE, 0x20CE, 0x20CE, 0x20CE, 

    // Table 37
    0x3160, 0x3161, 0x3162, 0x3163, 0x3164, 0x3165, 0x3166, 0x3167, 

    // Table 38
    0x5435, 0x5436, 0x5437, 0x5438, 0x5439, 0x543A, 0x543B, 0x543C, 
    0x543D, 0x543E, 0x543F, 0x5440, 0x5441, 0x5442, 0x5443, 0x5444, 
    0x5445, 0x5446, 0x5447, 0x5448, 0x427A, 0x427A, 0x427B, 0x427B, 
    0x427C, 0x427C, 0x427D, 0x427D, 0x427E, 0x427E, 0x427F, 0x427F, 

    // Table 39
    0x20D2, 0x20D3, 0x1079, 0x1079, 

    // Table 40
    0x107A, 0x107A, 0x107A, 0x107A, 0x316A, 0x316B, 0x316C, 0x316D, 

    // Table 41
    0x107B, 0x107B, 0x107B, 0x107B, 0x107B, 0x107B, 0x107B, 0x107B, 
    0x20D7, 0x20D7, 0x20D7, 0x20D7, 0x42A3, 0x42A4, 0x42A5, 0x42A6, 

    // Table 42
    0x42A7, 0x42A8, 0x316F, 0x316F, 0x20D8, 0x20D8, 0x20D8, 0x20D8, 
    0x107C, 0x107C, 0x107C, 0x107C, 0x107C, 0x107C, 0x107C, 0x107C, 

    // Table 43
    0x3168, 0x3168, 0x4291, 0x4292, 0x20CF, 0x20CF, 0x20CF, 0x20CF, 
    0x20D0, 0x20D0, 0x20D0, 0x20D0, 0x4293, 0x4294, 0x4295, 0x4296, 

    // Table 44
    0x4297, 0x4298, 0x4299, 0x429A, 0x429B, 0x429C, 0x429D, 0x429E, 
    0x429F, 0x42A0, 0x3169, 0x3169, 0x20D1, 0x20D1, 0x20D1, 0x20D1, 

    // Table 45
    0x20D4, 0x20D4, 0x20D4, 0x20D4, 0x20D5, 0x20D5, 0x20D5, 0x20D5, 
    0x20D6, 0x20D6, 0x20D6, 0x20D6, 0x316E, 0x316E, 0x42A1, 0x42A2, 

    // Table 46
    0x10B6, 0x10B6, 0x10B6, 0x10B6, 0x212D, 0x212D, 0x323C, 0x323D, 

    // Table 47
    0x10B7, 0x10B7, 0x212E, 0x212F, 

    // Table 48
    0x2130, 0x2131, 0x10B8, 0x10B8, 

    // Table 49
    0x10B9, 0x10BA, 

    // Table 50
    0x10BB, 0x10BC, 

    // Table 51
    0x213C, 0x213D, 0x10BD, 0x10BD, 

    // Table 52
    0x2132, 0x2132, 0x323E, 0x323F, 0x3240, 0x3241, 0x3242, 0x3243, 

    // Table 53
    0x2133, 0x2134, 0x2135, 0x2136, 

    // Table 54
    0x2137, 0x2137, 0x2137, 0x2137, 0x324C, 0x324C, 0x43D9, 0x43DA, 
    0x2138, 0x2138, 0x2138, 0x2138, 0x2139, 0x2139, 0x2139, 0x2139, 

    // Table 55
    0x3255, 0x3256, 0x3257, 0x3258, 0x213A, 0x213A, 0x213B, 0x213B, 

    // Table 56
    0x3244, 0x3245, 0x3246, 0x3247, 0x3248, 0x3249, 0x324A, 0x324B, 

    // Table 57
    0x324D, 0x324E, 0x324F, 0x3250, 0x3251, 0x3252, 0x3253, 0x3254, 

    // Table 58
    0x43DB, 0x43DC, 0x43DD, 0x43DE, 0x43DF, 0x43E0, 0x43E1, 0x43E2, 
    0x43E3, 0x43E4, 0x43E5, 0x43E6, 0x43E7, 0x43E8, 0x43E9, 0x43EA, 

    // Table 59
    0x43EB, 0x43EC, 0x43ED, 0x43EE, 0x43EF, 0x43F0, 0x43F1, 0x43F2, 
    0x43F3, 0x43F4, 0x43F5, 0x43F6, 0x43F7, 0x43F8, 0x43F9, 0x43FA, 

    // Table 60
    0x10BE, 0x10BE, 0x213E, 0x213F, 

    // Table 61
    0x2140, 0x2141, 0x10BF, 0x10BF, 

    // Table 62
    0x10C0, 0x10C1, 

    // Table 63
    0x10C2, 0x10C2, 0x10C2, 0x10C2, 0x10C2, 0x10C2, 0x10C2, 0x10C2, 
    0x43FF, 0x4400, 0x4401, 0x4402, 0x4403, 0x4404, 0x4405, 0x4406, 

    // Table 64
    0x3261, 0x3262, 0x3263, 0x3264, 0x3265, 0x3266, 0x2142, 0x2142, 

    // Table 65
    0x2143, 0x2143, 0x2143, 0x2143, 0x43FB, 0x43FC, 0x43FD, 0x43FE, 
    0x2144, 0x2144, 0x2144, 0x2144, 0x2145, 0x2145, 0x2145, 0x2145, 

    // Table 66
    0x2146, 0x2147, 0x2148, 0x2149, 

    // Table 67
    0x3259, 0x325A, 0x325B, 0x325C, 0x325D, 0x325E, 0x325F, 0x3260, 

    // Table 68
    0x4407, 0x4408, 0x4409, 0x440A, 0x440B, 0x440C, 0x440D, 0x440E, 
    0x440F, 0x4410, 0x4411, 0x4412, 0x4413, 0x4414, 0x4415, 0x4416, 

    // Table 69
    0x3177, 0x3178, 0x20D9, 0x20D9, 0x107D, 0x107D, 0x107D, 0x107D, 

    // Table 70
    0x107E, 0x107E, 0x107E, 0x107E, 0x107E, 0x107E, 0x107E, 0x107E, 
    0x42B9, 0x42BA, 0x317E, 0x317E, 0x317F, 0x317F, 0x3180, 0x3180, 

    // Table 71
    0x20DC, 0x20DC, 0x20DC, 0x20DC, 0x3181, 0x3181, 0x42BB, 0x42BC, 
    0x107F, 0x107F, 0x107F, 0x107F, 0x107F, 0x107F, 0x107F, 0x107F, 

    // Table 72
    0x1080, 0x1080, 0x1080, 0x1080, 0x20DD, 0x20DD, 0x3184, 0x3185, 

    // Table 73
    0x317A, 0x317B, 0x317C, 0x317D, 0x20DA, 0x20DA, 0x20DB, 0x20DB, 

    // Table 74
    0x3170, 0x3170, 0x42A9, 0x42AA, 0x3171, 0x3171, 0x3172, 0x3172, 
    0x3173, 0x3173, 0x3174, 0x3174, 0x3175, 0x3175, 0x3176, 0x3176, 

    // Table 75
    0x3179, 0x3179, 0x42AB, 0x42AC, 0x42AD, 0x42AE, 0x42AF, 0x42B0, 
    0x42B1, 0x42B2, 0x42B3, 0x42B4, 0x42B5, 0x42B6, 0x42B7, 0x42B8, 

    // Table 76
    0x42BD, 0x42BE, 0x42BF, 0x42C0, 0x42C1, 0x42C2, 0x42C3, 0x42C4, 
    0x42C5, 0x42C6, 0x42C7, 0x42C8, 0x3182, 0x3182, 0x3183, 0x3183, 

    // Table 77
    0x20E4, 0x20E4, 0x319C, 0x319D, 0x1081, 0x1081, 0x1081, 0x1081, 

    // Table 78
    0x1082, 0x1082, 0x1082, 0x1082, 0x319E, 0x319F, 0x31A0, 0x31A1, 

    // Table 79
    0x3186, 0x3187, 0x20DE, 0x20DE, 0x20DF, 0x20DF, 0x20E0, 0x20E0, 

    // Table 80
    0x3189, 0x318A, 0x318B, 0x318C, 0x318D, 0x318E, 0x20E1, 0x20E1, 

    // Table 81
    0x3198, 0x3199, 0x319A, 0x319B, 0x20E2, 0x20E2, 0x20E3, 0x20E3, 

    // Table 82
    0x42C9, 0x42CA, 0x42CB, 0x42CC, 0x42CD, 0x42CE, 0x42CF, 0x42D0, 
    0x42D1, 0x42D2, 0x42D3, 0x42D4, 0x42D5, 0x42D6, 0x3188, 0x3188, 

    // Table 83
    0x318F, 0x318F, 0x3190, 0x3190, 0x3191, 0x3191, 0x3192, 0x3192, 
    0x3193, 0x3193, 0x3194, 0x3194, 0x42D7, 0x42D8, 0x42D9, 0x42DA, 

    // Table 84
    0x42DB, 0x42DC, 0x42DD, 0x42DE, 0x42DF, 0x42E0, 0x42E1, 0x42E2, 
    0x42E3, 0x42E4, 0x3195, 0x3195, 0x3196, 0x3196, 0x3197, 0x3197, 

    // Table 85
    0x108B, 0x108C, 

    // Table 86
    0x108D, 0x108E, 

    // Table 87
    0x108F, 0x108F, 0x2100, 0x2101, 

    // Table 88
    0x1090, 0x1090, 0x1090, 0x1090, 0x2102, 0x2102, 0x31D5, 0x31D6, 

    // Table 89
    0x1091, 0x1091, 0x2105, 0x2106, 

    // Table 90
    0x20F9, 0x20F9, 0x20FA, 0x20FA, 0x31BF, 0x31C0, 0x31C1, 0x31C2, 

    // Table 91
    0x31CB, 0x31CC, 0x20FB, 0x20FB, 0x20FC, 0x20FC, 0x20FD, 0x20FD, 

    // Table 92
    0x20FE, 0x20FE, 0x20FE, 0x20FE, 0x431B, 0x431C, 0x431D, 0x431E, 
    0x431F, 0x4320, 0x4321, 0x4322, 0x4323, 0x4324, 0x4325, 0x4326, 

    // Table 93
    0x31CF, 0x31D0, 0x31D1, 0x31D2, 0x31D3, 0x31D4, 0x20FF, 0x20FF, 

    // Table 94
    0x31D7, 0x31D8, 0x31D9, 0x31DA, 0x2103, 0x2103, 0x2104, 0x2104, 

    // Table 95
    0x31DD, 0x31DE, 0x31DF, 0x31E0, 0x31E1, 0x31E2, 0x2107, 0x2107, 

    // Table 96
    0x31E3, 0x31E4, 0x2108, 0x2108, 0x2109, 0x2109, 0x210A, 0x210A, 

    // Table 97
    0x31C3, 0x31C4, 0x31C5, 0x31C6, 0x31C7, 0x31C8, 0x31C9, 0x31CA, 

    // Table 98
    0x4327, 0x4328, 0x4329, 0x432A, 0x432B, 0x432C, 0x432D, 0x432E, 
    0x432F, 0x4330, 0x4331, 0x4332, 0x31CD, 0x31CD, 0x31CE, 0x31CE, 

    // Table 99
    0x4343, 0x4344, 0x4345, 0x4346, 0x4347, 0x4348, 0x4349, 0x434A, 
    0x434B, 0x434C, 0x434D, 0x434E, 0x31DB, 0x31DB, 0x31DC, 0x31DC, 

    // Table 100
    0x31E5, 0x31E6, 0x31E7, 0x31E8, 0x31E9, 0x31EA, 0x31EB, 0x31EC, 

    // Table 101
    0x4333, 0x4334, 0x4335, 0x4336, 0x4337, 0x4338, 0x4339, 0x433A, 
    0x433B, 0x433C, 0x433D, 0x433E, 0x433F, 0x4340, 0x4341, 0x4342, 

    // Table 102
    0x10AB, 0x10AB, 0x10AB, 0x10AB, 0x10AB, 0x10AB, 0x10AB, 0x10AB, 
    0x4399, 0x439A, 0x439B, 0x439C, 0x439D, 0x439E, 0x439F, 0x43A0, 

    // Table 103
    0x10AC, 0x10AD, 

    // Table 104
    0x10AE, 0x10AF, 

    // Table 105
    0x322F, 0x3230, 0x2128, 0x2128, 0x10B0, 0x10B0, 0x10B0, 0x10B0, 

    // Table 106
    0x10B1, 0x10B2, 

    // Table 107
    0x2129, 0x212A, 0x10B3, 0x10B3, 

    // Table 108
    0x10B4, 0x10B4, 0x10B4, 0x10B4, 0x10B4, 0x10B4, 0x10B4, 0x10B4, 
    0x43B7, 0x43B8, 0x43B9, 0x43BA, 0x43BB, 0x43BC, 0x43BD, 0x43BE, 

    // Table 109
    0x212B, 0x212C, 0x10B5, 0x10B5, 

    // Table 110
    0x2127, 0x2127, 0x3229, 0x322A, 0x322B, 0x322C, 0x322D, 0x322E, 

    // Table 111
    0x43B1, 0x43B2, 0x43B3, 0x43B4, 0x43B5, 0x43B6, 0x3224, 0x3224, 
    0x3225, 0x3225, 0x3226, 0x3226, 0x3227, 0x3227, 0x3228, 0x3228, 

    // Table 112
    0x43CF, 0x43D0, 0x43D1, 0x43D2, 0x43D3, 0x43D4, 0x43D5, 0x43D6, 
    0x43D7, 0x43D8, 0x3231, 0x3231, 0x3232, 0x3232, 0x3233, 0x3233, 

    // Table 113
    0x3234, 0x3235, 0x3236, 0x3237, 0x3238, 0x3239, 0x323A, 0x323B, 

    // Table 114
    0x43A1, 0x43A2, 0x43A3, 0x43A4, 0x43A5, 0x43A6, 0x43A7, 0x43A8, 
    0x43A9, 0x43AA, 0x43AB, 0x43AC, 0x43AD, 0x43AE, 0x43AF, 0x43B0, 

    // Table 115
    0x43BF, 0x43C0, 0x43C1, 0x43C2, 0x43C3, 0x43C4, 0x43C5, 0x43C6, 
    0x43C7, 0x43C8, 0x43C9, 0x43CA, 0x43CB, 0x43CC, 0x43CD, 0x43CE, 

    // Table 116
    0x42F3, 0x42F4, 0x42F5, 0x42F6, 0x31A3, 0x31A3, 0x31A4, 0x31A4, 
    0x1083, 0x1083, 0x1083, 0x1083, 0x1083, 0x1083, 0x1083, 0x1083, 

    // Table 117
    0x31A9, 0x31AA, 0x20EB, 0x20EB, 0x1084, 0x1084, 0x1084, 0x1084, 

    // Table 118
    0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 
    0x31AB, 0x31AB, 0x42F7, 0x42F8, 0x20EC, 0x20EC, 0x20EC, 0x20EC, 

    // Table 119
    0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 
    0x20ED, 0x20ED, 0x20ED, 0x20ED, 0x42F9, 0x42FA, 0x42FB, 0x42FC, 

    // Table 120
    0x1087, 0x1087, 0x20F0, 0x20F1, 

    // Table 121
    0x20F2, 0x20F2, 0x31B4, 0x31B5, 0x1088, 0x1088, 0x1088, 0x1088, 

    // Table 122
    0x31B6, 0x31B7, 0x31B8, 0x31B9, 0x1089, 0x1089, 0x1089, 0x1089, 

    // Table 123
    0x108A, 0x108A, 0x108A, 0x108A, 0x108A, 0x108A, 0x108A, 0x108A, 
    0x31BA, 0x31BA, 0x4305, 0x4306, 0x20F3, 0x20F3, 0x20F3, 0x20F3, 

    // Table 124
    0x20E5, 0x20E6, 0x20E7, 0x20E8, 

    // Table 125
    0x31A5, 0x31A6, 0x31A7, 0x31A8, 0x20E9, 0x20E9, 0x20EA, 0x20EA, 

    // Table 126
    0x31B0, 0x31B1, 0x31B2, 0x31B3, 0x20EE, 0x20EE, 0x20EF, 0x20EF, 

    // Table 127
    0x4317, 0x4318, 0x4319, 0x431A, 0x31BB, 0x31BB, 0x31BC, 0x31BC, 
    0x31BD, 0x31BD, 0x31BE, 0x31BE, 0x20F4, 0x20F4, 0x20F4, 0x20F4, 

    // Table 128
    0x20F5, 0x20F6, 0x20F7, 0x20F8, 

    // Table 129
    0x31A2, 0x31A2, 0x42E5, 0x42E6, 0x42E7, 0x42E8, 0x42E9, 0x42EA, 
    0x42EB, 0x42EC, 0x42ED, 0x42EE, 0x42EF, 0x42F0, 0x42F1, 0x42F2, 

    // Table 130
    0x42FD, 0x42FE, 0x42FF, 0x4300, 0x4301, 0x4302, 0x4303, 0x4304, 
    0x31AC, 0x31AC, 0x31AD, 0x31AD, 0x31AE, 0x31AE, 0x31AF, 0x31AF, 

    // Table 131
    0x4307, 0x4308, 0x4309, 0x430A, 0x430B, 0x430C, 0x430D, 0x430E, 
    0x430F, 0x4310, 0x4311, 0x4312, 0x4313, 0x4314, 0x4315, 0x4316, 

    // Table 132
    0x210B, 0x210C, 0x1092, 0x1092, 

    // Table 133
    0x210D, 0x210E, 0x1093, 0x1093, 

    // Table 134
    0x1094, 0x1095, 

    // Table 135
    0x31F3, 0x31F4, 0x210F, 0x210F, 0x1096, 0x1096, 0x1096, 0x1096, 

    // Table 136
    0x31F9, 0x31FA, 0x31FB, 0x31FC, 0x1097, 0x1097, 0x1097, 0x1097, 

    // Table 137
    0x2115, 0x2116, 0x1098, 0x1098, 

    // Table 138
    0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 
    0x3200, 0x3200, 0x4375, 0x4376, 0x211A, 0x211A, 0x211A, 0x211A, 

    // Table 139
    0x109A, 0x109B, 

    // Table 140
    0x211B, 0x211B, 0x3201, 0x3202, 0x109C, 0x109C, 0x109C, 0x109C, 

    // Table 141
    0x109D, 0x109E, 

    // Table 142
    0x109F, 0x10A0, 

    // Table 143
    0x10A1, 0x10A2, 

    // Table 144
    0x31F5, 0x31F6, 0x2110, 0x2110, 0x2111, 0x2111, 0x31F7, 0x31F8, 

    // Table 145
    0x2112, 0x2112, 0x2112, 0x2112, 0x31FD, 0x31FD, 0x4363, 0x4364, 
    0x2113, 0x2113, 0x2113, 0x2113, 0x2114, 0x2114, 0x2114, 0x2114, 

    // Table 146
    0x2117, 0x2117, 0x2117, 0x2117, 0x4365, 0x4366, 0x4367, 0x4368, 
    0x4369, 0x436A, 0x436B, 0x436C, 0x436D, 0x436E, 0x436F, 0x4370, 

    // Table 147
    0x4371, 0x4372, 0x4373, 0x4374, 0x31FE, 0x31FE, 0x31FF, 0x31FF, 
    0x2118, 0x2118, 0x2118, 0x2118, 0x2119, 0x2119, 0x2119, 0x2119, 

    // Table 148
    0x3203, 0x3204, 0x3205, 0x3206, 0x3207, 0x3208, 0x211C, 0x211C, 

    // Table 149
    0x435F, 0x4360, 0x4361, 0x4362, 0x31ED, 0x31ED, 0x31EE, 0x31EE, 
    0x31EF, 0x31EF, 0x31F0, 0x31F0, 0x31F1, 0x31F1, 0x31F2, 0x31F2, 

    // Table 150
    0x434F, 0x4350, 0x4351, 0x4352, 0x4353, 0x4354, 0x4355, 0x4356, 
    0x4357, 0x4358, 0x4359, 0x435A, 0x435B, 0x435C, 0x435D, 0x435E, 
};

WORD g_Huffman_PCBPCY[] = 
{
    // Tables
    0x700D, 0x608D, 0x60CD, 0x610D, 0x614D, 0x418D, 0x319D, 0x41A5, 
    0x51B5, 0x81D5, 0x52D5, 0x22F5, 0x32F9, 

    // Table 0
    0x7041, 0x0002, 0x605C, 0x605C, 0x5068, 0x5068, 0x5068, 0x5068, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 
    0x606C, 0x606C, 0x6058, 0x6058, 0x507C, 0x507C, 0x507C, 0x507C, 
    0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x7000, 0x0004, 0x6074, 0x6074, 0x504C, 0x504C, 0x504C, 0x504C, 
    0x6064, 0x6064, 0x0005, 0x0003, 0x6042, 0x6042, 0x0006, 0x0001, 
    0x5070, 0x5070, 0x5070, 0x5070, 0x5078, 0x5078, 0x5078, 0x5078, 
    0x4054, 0x4054, 0x4054, 0x4054, 0x4054, 0x4054, 0x4054, 0x4054, 
    0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 
    0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 
    0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 
    0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 

    // Table 1
    0x3079, 0x3079, 0x3079, 0x3079, 0x3079, 0x3079, 0x3079, 0x3079, 
    0x605B, 0x6001, 0x5028, 0x5028, 0x4065, 0x4065, 0x4065, 0x4065, 
    0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 
    0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 
    0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 
    0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 0x206A, 
    0x305A, 0x305A, 0x305A, 0x305A, 0x305A, 0x305A, 0x305A, 0x305A, 
    0x5004, 0x5004, 0x5002, 0x5002, 0x404F, 0x404F, 0x404F, 0x404F, 

    // Table 2
    0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 
    0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 
    0x5047, 0x5047, 0x505F, 0x505F, 0x0008, 0x6038, 0x504B, 0x504B, 
    0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 
    0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 
    0x5077, 0x5077, 0x5059, 0x5059, 0x404D, 0x404D, 0x404D, 0x404D, 
    0x307F, 0x307F, 0x307F, 0x307F, 0x307F, 0x307F, 0x307F, 0x307F, 
    0x602C, 0x600C, 0x5020, 0x5020, 0x506B, 0x506B, 0x6030, 0x0007, 

    // Table 3
    0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 
    0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 0x2056, 
    0x507B, 0x507B, 0x601C, 0x0009, 0x503F, 0x503F, 0x503E, 0x503E, 
    0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 
    0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 
    0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 0x2062, 
    0x5010, 0x5010, 0x000B, 0x6014, 0x5073, 0x5073, 0x6067, 0x000A, 
    0x406F, 0x406F, 0x406F, 0x406F, 0x4057, 0x4057, 0x4057, 0x4057, 

    // Table 4
    0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 
    0x4071, 0x4071, 0x4071, 0x4071, 0x406D, 0x406D, 0x406D, 0x406D, 
    0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 
    0x3076, 0x3076, 0x3076, 0x3076, 0x3076, 0x3076, 0x3076, 0x3076, 
    0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 
    0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 0x2052, 
    0x5063, 0x5063, 0x5053, 0x5053, 0x5008, 0x5008, 0x6034, 0x000C, 
    0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 0x3045, 

    // Table 5
    0x204A, 0x204A, 0x204A, 0x204A, 0x307A, 0x307A, 0x3072, 0x3072, 
    0x3061, 0x3061, 0x405D, 0x4075, 0x2043, 0x2043, 0x2043, 0x2043, 

    // Table 6
    0x107E, 0x107E, 0x107E, 0x107E, 0x204E, 0x204E, 0x3066, 0x3051, 

    // Table 7
    0x2003, 0x2003, 0x2003, 0x2003, 0x3017, 0x3017, 0x3033, 0x3033, 
    0x4009, 0x4013, 0x300A, 0x300A, 0x302E, 0x302E, 0x300B, 0x300B, 

    // Table 8
    0x5031, 0x5029, 0x500D, 0x5005, 0x5035, 0x501D, 0x4011, 0x4011, 
    0x3022, 0x3022, 0x3022, 0x3022, 0x3032, 0x3032, 0x3032, 0x3032, 
    0x300F, 0x300F, 0x300F, 0x300F, 0x302F, 0x302F, 0x302F, 0x302F, 
    0x2036, 0x2036, 0x2036, 0x2036, 0x2036, 0x2036, 0x2036, 0x2036, 

    // Table 9
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 0x203D, 
    0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 
    0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 
    0x602A, 0x602A, 0x602A, 0x602A, 0x8039, 0x8025, 0x7019, 0x7019, 
    0x5015, 0x5015, 0x5015, 0x5015, 0x5015, 0x5015, 0x5015, 0x5015, 
    0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 
    0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 
    0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 
    0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 0x302D, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 0x301A, 
    0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 
    0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 
    0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 
    0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 0x300E, 
    0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 
    0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 
    0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 
    0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 0x301E, 
    0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 
    0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 
    0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 
    0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 0x3023, 

    // Table 10
    0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 
    0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 0x1024, 
    0x203A, 0x203A, 0x203A, 0x203A, 0x203A, 0x203A, 0x203A, 0x203A, 
    0x501B, 0x5016, 0x4026, 0x4026, 0x4027, 0x4027, 0x4021, 0x4021, 

    // Table 11
    0x201F, 0x2037, 0x103B, 0x103B, 

    // Table 12
    0x1018, 0x1018, 0x1018, 0x1018, 0x3007, 0x302B, 0x2012, 0x2012, 
};

WORD g_Huffman_PCBPCY_HighRate[] =
{
    // Tables
    0x9013, 0x7213, 0x7293, 0x3313, 0x331B, 0x1323, 0x1325, 0x1327, 
    0x1329, 0x432B, 0x833B, 0x243B, 0x443F, 0x244F, 0x1453, 0x3455, 
    0x345D, 0x1465, 0x2467, 

    // Table 0
    0x0006, 0x9079, 0x0008, 0x0007, 0x9056, 0x0001, 0x9046, 0x904A, 
    0x805E, 0x805E, 0x8076, 0x8076, 0x806E, 0x806E, 0x906A, 0x9052, 
    0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 
    0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 0x507F, 
    0x8041, 0x8041, 0x904E, 0x9062, 0x807A, 0x807A, 0x0003, 0x9072, 
    0x6064, 0x6064, 0x6064, 0x6064, 0x6064, 0x6064, 0x6064, 0x6064, 
    0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 
    0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 0x506C, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 0x3040, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 0x307C, 
    0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 
    0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 0x505C, 
    0x6058, 0x6058, 0x6058, 0x6058, 0x6058, 0x6058, 0x6058, 0x6058, 
    0x0005, 0x0002, 0x904D, 0x905F, 0x0004, 0x9055, 0x9077, 0x9069, 
    0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 
    0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 0x504C, 
    0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 
    0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 0x5078, 
    0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 
    0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 0x5074, 
    0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 
    0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 0x5068, 
    0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 
    0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 
    0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 
    0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 0x407E, 
    0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 
    0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 0x5054, 
    0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 
    0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 0x5070, 
    0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 
    0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 0x507D, 
    0x806D, 0x806D, 0x805D, 0x805D, 0x9071, 0x906F, 0x8075, 0x8075, 
    0x6042, 0x6042, 0x6042, 0x6042, 0x6042, 0x6042, 0x6042, 0x6042, 
    0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 
    0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 
    0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 
    0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 0x4048, 
    0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 
    0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 
    0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 
    0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 0x4044, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 
    0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 
    0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 
    0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 
    0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 

    // Table 1
    0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 
    0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 0x303E, 
    0x000E, 0x7037, 0x000B, 0x000A, 0x703B, 0x702C, 0x701C, 0x000D, 
    0x701F, 0x000C, 0x0009, 0x700F, 0x5000, 0x5000, 0x5000, 0x5000, 
    0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 
    0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 
    0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 
    0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 0x2057, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 

    // Table 2
    0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 
    0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 
    0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 
    0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 0x204F, 
    0x7035, 0x7008, 0x0011, 0x0010, 0x6038, 0x6038, 0x0012, 0x700C, 
    0x6034, 0x6034, 0x7030, 0x700D, 0x7004, 0x702D, 0x000F, 0x7014, 
    0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 
    0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 
    0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 0x1059, 

    // Table 3
    0x1043, 0x1043, 0x1043, 0x1043, 0x3047, 0x3053, 0x203C, 0x203C, 

    // Table 4
    0x3067, 0x304B, 0x303D, 0x305B, 0x2073, 0x2073, 0x206B, 0x206B, 

    // Table 5
    0x103F, 0x1065, 

    // Table 6
    0x1045, 0x1066, 

    // Table 7
    0x1051, 0x1049, 

    // Table 8
    0x107B, 0x105A, 

    // Table 9
    0x201E, 0x201E, 0x201E, 0x201E, 0x2005, 0x2005, 0x2005, 0x2005, 
    0x2011, 0x2011, 0x2011, 0x2011, 0x401B, 0x400A, 0x3022, 0x3022, 

    // Table 10
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 0x2015, 
    0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 
    0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 0x4006, 
    0x7012, 0x7012, 0x801A, 0x800B, 0x602A, 0x602A, 0x602A, 0x602A, 
    0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 0x5007, 
    0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 
    0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 
    0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 
    0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 0x302B, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 
    0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 0x1020, 

    // Table 11
    0x2017, 0x202E, 0x1028, 0x1028, 

    // Table 12
    0x1036, 0x1036, 0x1036, 0x1036, 0x1036, 0x1036, 0x1036, 0x1036, 
    0x2029, 0x2029, 0x2029, 0x2029, 0x4018, 0x4026, 0x4027, 0x4019, 

    // Table 13
    0x2024, 0x203A, 0x1033, 0x1033, 

    // Table 14
    0x1039, 0x102F, 

    // Table 15
    0x2001, 0x2001, 0x2009, 0x2009, 0x3023, 0x3003, 0x200E, 0x200E, 

    // Table 16
    0x101D, 0x101D, 0x101D, 0x101D, 0x2002, 0x2002, 0x3016, 0x3013, 

    // Table 17
    0x1010, 0x1031, 

    // Table 18
    0x2032, 0x2025, 0x1021, 0x1021, 
};


WORD g_Huffman_PCBPCY_MidRate[] =
{
    // Tables
    0x7011, 0x6091, 0x60D1, 0x6111, 0x6151, 0x3191, 0x3199, 0x41A1, 
    0x11B1, 0x21B3, 0x41B7, 0x71C7, 0x2247, 0x324B, 0x5253, 0x5273, 
    0x3293, 

    // Table 0
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 0x2040, 
    0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 0x4050, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 0x4060, 
    0x6078, 0x6078, 0x6074, 0x6074, 0x0003, 0x0006, 0x6058, 0x6058, 
    0x407C, 0x407C, 0x407C, 0x407C, 0x407C, 0x407C, 0x407C, 0x407C, 
    0x504C, 0x504C, 0x504C, 0x504C, 0x6064, 0x6064, 0x0004, 0x707E, 
    0x5054, 0x5054, 0x5054, 0x5054, 0x5068, 0x5068, 0x5068, 0x5068, 
    0x5070, 0x5070, 0x5070, 0x5070, 0x0001, 0x707D, 0x0005, 0x0002, 
    0x505C, 0x505C, 0x505C, 0x505C, 0x506C, 0x506C, 0x506C, 0x506C, 
    0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 
    0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 0x3048, 
    0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 
    0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 0x3044, 

    // Table 1
    0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 0x305E, 
    0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 
    0x504F, 0x504F, 0x6030, 0x6028, 0x6004, 0x6010, 0x0008, 0x0007, 
    0x3046, 0x3046, 0x3046, 0x3046, 0x3046, 0x3046, 0x3046, 0x3046, 
    0x3052, 0x3052, 0x3052, 0x3052, 0x3052, 0x3052, 0x3052, 0x3052, 
    0x307A, 0x307A, 0x307A, 0x307A, 0x307A, 0x307A, 0x307A, 0x307A, 
    0x403E, 0x403E, 0x403E, 0x403E, 0x405F, 0x405F, 0x405F, 0x405F, 
    0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 0x306E, 

    // Table 2
    0x304A, 0x304A, 0x304A, 0x304A, 0x304A, 0x304A, 0x304A, 0x304A, 
    0x3062, 0x3062, 0x3062, 0x3062, 0x3062, 0x3062, 0x3062, 0x3062, 
    0x0009, 0x000A, 0x5047, 0x5047, 0x5038, 0x5038, 0x6063, 0x6014, 
    0x306A, 0x306A, 0x306A, 0x306A, 0x306A, 0x306A, 0x306A, 0x306A, 
    0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 
    0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 0x2045, 
    0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 
    0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 0x205D, 

    // Table 3
    0x5057, 0x5057, 0x5077, 0x5077, 0x000D, 0x000B, 0x5066, 0x5066, 
    0x404E, 0x404E, 0x404E, 0x404E, 0x503F, 0x503F, 0x6034, 0x6073, 
    0x3051, 0x3051, 0x3051, 0x3051, 0x3051, 0x3051, 0x3051, 0x3051, 
    0x5043, 0x5043, 0x6020, 0x000C, 0x505A, 0x505A, 0x507B, 0x507B, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 
    0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 0x1041, 

    // Table 4
    0x4072, 0x4072, 0x4072, 0x4072, 0x6053, 0x602C, 0x606B, 0x000E, 
    0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 0x3049, 
    0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 0x3055, 
    0x3061, 0x3061, 0x3061, 0x3061, 0x3061, 0x3061, 0x3061, 0x3061, 
    0x4065, 0x4065, 0x4065, 0x4065, 0x503D, 0x503D, 0x506F, 0x506F, 
    0x4059, 0x4059, 0x4059, 0x4059, 0x0010, 0x6008, 0x601C, 0x000F, 
    0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 0x3069, 
    0x3071, 0x3071, 0x3071, 0x3071, 0x3071, 0x3071, 0x3071, 0x3071, 

    // Table 5
    0x203C, 0x203C, 0x3056, 0x3076, 0x107F, 0x107F, 0x107F, 0x107F, 

    // Table 6
    0x3079, 0x304D, 0x3075, 0x306D, 0x1042, 0x1042, 0x1042, 0x1042, 

    // Table 7
    0x2011, 0x2011, 0x2011, 0x2011, 0x3019, 0x3019, 0x4006, 0x4007, 
    0x103B, 0x103B, 0x103B, 0x103B, 0x103B, 0x103B, 0x103B, 0x103B, 

    // Table 8
    0x1039, 0x100D, 

    // Table 9
    0x2001, 0x203A, 0x1024, 0x1024, 

    // Table 10
    0x1018, 0x1018, 0x1018, 0x1018, 0x1018, 0x1018, 0x1018, 0x1018, 
    0x401B, 0x4003, 0x3032, 0x3032, 0x2015, 0x2015, 0x2015, 0x2015, 

    // Table 11
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 0x1067, 
    0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 
    0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 
    0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 
    0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 0x2037, 
    0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 
    0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 0x3009, 
    0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 
    0x7022, 0x700A, 0x600B, 0x600B, 0x5002, 0x5002, 0x5002, 0x5002, 

    // Table 12
    0x100C, 0x100C, 0x201F, 0x201D, 

    // Table 13
    0x104B, 0x104B, 0x104B, 0x104B, 0x300F, 0x3017, 0x2035, 0x2035, 

    // Table 14
    0x2031, 0x2031, 0x2031, 0x2031, 0x2031, 0x2031, 0x2031, 0x2031, 
    0x5027, 0x5012, 0x4023, 0x4023, 0x301E, 0x301E, 0x301E, 0x301E, 
    0x2005, 0x2005, 0x2005, 0x2005, 0x2005, 0x2005, 0x2005, 0x2005, 
    0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 

    // Table 15
    0x3033, 0x3033, 0x3033, 0x3033, 0x3016, 0x3016, 0x3016, 0x3016, 
    0x402A, 0x402A, 0x402B, 0x402B, 0x3029, 0x3029, 0x3029, 0x3029, 
    0x302F, 0x302F, 0x302F, 0x302F, 0x4013, 0x4013, 0x501A, 0x5026, 
    0x202D, 0x202D, 0x202D, 0x202D, 0x202D, 0x202D, 0x202D, 0x202D, 

    // Table 16
    0x302E, 0x3025, 0x2036, 0x2036, 0x105B, 0x105B, 0x105B, 0x105B, 
};

WORD g_Huffman_PCBPCY_LowRate[] =
{
    // Tables
    0x6015, 0x6055, 0x6095, 0x60D5, 0x4115, 0x3125, 0x312D, 0x2135, 
    0x1139, 0x113B, 0x513D, 0x515D, 0x317D, 0x1185, 0x1187, 0x1189, 
    0x118B, 0x418D, 0x319D, 0x21A5, 0x21A9, 

    // Table 0
    0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 
    0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 
    0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 
    0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 
    0x6068, 0x0002, 0x507C, 0x507C, 0x4048, 0x4048, 0x4048, 0x4048, 
    0x4044, 0x4044, 0x4044, 0x4044, 0x4050, 0x4050, 0x4050, 0x4050, 
    0x4060, 0x4060, 0x4060, 0x4060, 0x6070, 0x0001, 0x605C, 0x606C, 
    0x6078, 0x6074, 0x504C, 0x504C, 0x0003, 0x6058, 0x5054, 0x5054, 

    // Table 1
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x6072, 0x6059, 0x602C, 0x0005, 0x6030, 0x0009, 0x6028, 0x0008, 
    0x506D, 0x506D, 0x0006, 0x0004, 0x506E, 0x506E, 0x505E, 0x505E, 
    0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 0x307D, 
    0x3042, 0x3042, 0x3042, 0x3042, 0x3042, 0x3042, 0x3042, 0x3042, 
    0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 0x303C, 
    0x5020, 0x5020, 0x507A, 0x507A, 0x601C, 0x0007, 0x5056, 0x5056, 

    // Table 2
    0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 
    0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 
    0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 
    0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 0x1064, 
    0x000E, 0x6034, 0x000F, 0x6038, 0x5061, 0x5061, 0x6008, 0x000C, 
    0x6010, 0x0010, 0x5049, 0x5049, 0x5055, 0x5055, 0x505D, 0x505D, 
    0x6065, 0x000A, 0x507F, 0x507F, 0x5071, 0x5071, 0x5079, 0x5079, 
    0x604E, 0x6004, 0x000B, 0x000D, 0x5069, 0x5069, 0x5075, 0x5075, 

    // Table 3
    0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 
    0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 0x2041, 
    0x6014, 0x603E, 0x5046, 0x5046, 0x4045, 0x4045, 0x4045, 0x4045, 
    0x0011, 0x6057, 0x5076, 0x5076, 0x4051, 0x4051, 0x4051, 0x4051, 
    0x0014, 0x0012, 0x5052, 0x5052, 0x6066, 0x0013, 0x504A, 0x504A, 
    0x5062, 0x5062, 0x506A, 0x506A, 0x404D, 0x404D, 0x404D, 0x404D, 
    0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 
    0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 0x207E, 

    // Table 4
    0x2036, 0x2036, 0x2036, 0x2036, 0x3022, 0x3022, 0x3026, 0x3026, 
    0x2009, 0x2009, 0x2009, 0x2009, 0x4003, 0x400E, 0x301B, 0x301B, 

    // Table 5
    0x302B, 0x3023, 0x2005, 0x2005, 0x1018, 0x1018, 0x1018, 0x1018, 

    // Table 6
    0x203A, 0x203A, 0x301F, 0x3016, 0x1047, 0x1047, 0x1047, 0x1047, 

    // Table 7
    0x103F, 0x103F, 0x2037, 0x2029, 

    // Table 8
    0x1073, 0x104F, 

    // Table 9
    0x106B, 0x1053, 

    // Table 10
    0x302E, 0x302E, 0x302E, 0x302E, 0x3025, 0x3025, 0x3025, 0x3025, 
    0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
    0x3011, 0x3011, 0x3011, 0x3011, 0x301E, 0x301E, 0x301E, 0x301E, 
    0x302A, 0x302A, 0x302A, 0x302A, 0x401A, 0x401A, 0x500B, 0x5006, 

    // Table 11
    0x205B, 0x205B, 0x205B, 0x205B, 0x205B, 0x205B, 0x205B, 0x205B, 
    0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 0x2021, 
    0x3019, 0x3019, 0x3019, 0x3019, 0x5007, 0x500A, 0x4012, 0x4012, 
    0x2035, 0x2035, 0x2035, 0x2035, 0x2035, 0x2035, 0x2035, 0x2035, 

    // Table 12
    0x100C, 0x100C, 0x100C, 0x100C, 0x302F, 0x3015, 0x2039, 0x2039, 

    // Table 13
    0x106F, 0x1024, 

    // Table 14
    0x103D, 0x1043, 

    // Table 15
    0x105A, 0x105F, 

    // Table 16
    0x1077, 0x107B, 

    // Table 17
    0x1063, 0x1063, 0x1063, 0x1063, 0x1063, 0x1063, 0x1063, 0x1063, 
    0x3027, 0x3027, 0x4002, 0x400F, 0x2032, 0x2032, 0x2032, 0x2032, 

    // Table 18
    0x200D, 0x200D, 0x3017, 0x3013, 0x1067, 0x1067, 0x1067, 0x1067, 

    // Table 19
    0x201D, 0x202D, 0x1031, 0x1031, 

    // Table 20
    0x104B, 0x104B, 0x203B, 0x2033, 
};

#endif 0

WORD g_Huffman_DCTACInter_HighMotion[] =
{
    // Tables
    0x601E, 0x505E, 0x507E, 0x309E, 0x50A6, 0x50C6, 0x50E6, 0x5106, 
    0x5126, 0x4146, 0x1156, 0x3158, 0x3160, 0x4168, 0x1178, 0x417A, 
    0x118A, 0x318C, 0x1194, 0x4196, 0x31A6, 0x41AE, 0x21BE, 0x31C2, 
    0x21CA, 0x41CE, 0x11DE, 0x31E0, 0x21E8, 0x11EC, 

    // Table 0
    0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 
    0x0009, 0x0007, 0x5022, 0x5022, 0x4001, 0x4001, 0x4001, 0x4001, 
    0x4017, 0x4017, 0x4017, 0x4017, 0x6003, 0x0003, 0x5002, 0x5002, 
    0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 0x3063, 
    0x0005, 0x0006, 0x5075, 0x5075, 0x406C, 0x406C, 0x406C, 0x406C, 
    0x0002, 0x6031, 0x6064, 0x607F, 0x000A, 0x0004, 0x0001, 0x6082, 
    0x502A, 0x502A, 0x5079, 0x5079, 0x4071, 0x4071, 0x4071, 0x4071, 
    0x6036, 0x0008, 0x507C, 0x507C, 0x5018, 0x5018, 0x6086, 0x6004, 

    // Table 1
    0x3092, 0x3092, 0x3092, 0x3092, 0x400A, 0x400A, 0x4040, 0x4040, 
    0x000C, 0x500C, 0x000B, 0x5026, 0x301B, 0x301B, 0x301B, 0x301B, 
    0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 
    0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 0x1005, 

    // Table 2
    0x2090, 0x2090, 0x2090, 0x2090, 0x2090, 0x2090, 0x2090, 0x2090, 
    0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 0x2043, 
    0x2006, 0x2006, 0x2006, 0x2006, 0x2006, 0x2006, 0x2006, 0x2006, 
    0x50A6, 0x509C, 0x000D, 0x502D, 0x4066, 0x4066, 0x4025, 0x4025, 

    // Table 3
    0x206D, 0x206D, 0x208C, 0x208C, 0x3007, 0x3072, 0x208E, 0x208E, 

    // Table 4
    0x3097, 0x3097, 0x3097, 0x3097, 0x30A8, 0x30A8, 0x30A8, 0x30A8, 
    0x5038, 0x000F, 0x000E, 0x5055, 0x3076, 0x3076, 0x3076, 0x3076, 
    0x201A, 0x201A, 0x201A, 0x201A, 0x201A, 0x201A, 0x201A, 0x201A, 
    0x3008, 0x3008, 0x3008, 0x3008, 0x5080, 0x0010, 0x5044, 0x0011, 

    // Table 5
    0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 
    0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 0x1023, 
    0x404F, 0x404F, 0x5033, 0x0012, 0x4009, 0x4009, 0x0014, 0x0013, 
    0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 0x2046, 

    // Table 6
    0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 
    0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 0x1019, 
    0x4096, 0x4096, 0x500B, 0x505C, 0x4095, 0x4095, 0x407A, 0x407A, 
    0x3037, 0x3037, 0x3037, 0x3037, 0x4098, 0x4098, 0x403C, 0x403C, 

    // Table 7
    0x4093, 0x4093, 0x0016, 0x0018, 0x3024, 0x3024, 0x3024, 0x3024, 
    0x202B, 0x202B, 0x202B, 0x202B, 0x202B, 0x202B, 0x202B, 0x202B, 
    0x208A, 0x208A, 0x208A, 0x208A, 0x208A, 0x208A, 0x208A, 0x208A, 
    0x509B, 0x0015, 0x5047, 0x0017, 0x3032, 0x3032, 0x3032, 0x3032, 

    // Table 8
    0x2065, 0x2065, 0x2065, 0x2065, 0x2065, 0x2065, 0x2065, 0x2065, 
    0x407D, 0x407D, 0x401C, 0x401C, 0x509E, 0x001C, 0x501D, 0x001A, 
    0x406E, 0x406E, 0x4051, 0x4051, 0x001D, 0x5067, 0x509A, 0x5057, 
    0x3094, 0x3094, 0x3094, 0x3094, 0x4053, 0x4053, 0x0019, 0x001B, 

    // Table 9
    0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 
    0x3049, 0x3049, 0x402C, 0x404C, 0x203F, 0x203F, 0x203F, 0x203F, 

    // Table 10
    0x103B, 0x1088, 

    // Table 11
    0x101E, 0x101E, 0x101E, 0x101E, 0x2011, 0x2011, 0x305F, 0x3060, 

    // Table 12
    0x3042, 0x3035, 0x2048, 0x2048, 0x30A4, 0x3021, 0x20A3, 0x20A3, 

    // Table 13
    0x2091, 0x2091, 0x2091, 0x2091, 0x4078, 0x4062, 0x307E, 0x307E, 
    0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 0x1085, 

    // Table 14
    0x100E, 0x109F, 

    // Table 15
    0x201F, 0x201F, 0x201F, 0x201F, 0x20A5, 0x20A5, 0x20A5, 0x20A5, 
    0x3074, 0x3074, 0x4081, 0x404E, 0x3013, 0x3013, 0x4016, 0x4058, 

    // Table 16
    0x1087, 0x105D, 

    // Table 17
    0x305E, 0x306A, 0x207B, 0x207B, 0x1077, 0x1077, 0x1077, 0x1077, 

    // Table 18
    0x1073, 0x100D, 

    // Table 19
    0x2039, 0x2039, 0x2039, 0x2039, 0x406B, 0x4015, 0x30A1, 0x30A1, 
    0x2089, 0x2089, 0x2089, 0x2089, 0x2010, 0x2010, 0x2010, 0x2010, 

    // Table 20
    0x2068, 0x2068, 0x3012, 0x3020, 0x1059, 0x1059, 0x1059, 0x1059, 

    // Table 21
    0x3045, 0x3045, 0x302F, 0x302F, 0x2041, 0x2041, 0x2041, 0x2041, 
    0x200F, 0x200F, 0x200F, 0x200F, 0x4030, 0x4070, 0x308B, 0x308B, 

    // Table 22
    0x1099, 0x1099, 0x2027, 0x206F, 

    // Table 23
    0x104A, 0x104A, 0x104A, 0x104A, 0x30A0, 0x3028, 0x204D, 0x204D, 

    // Table 24
    0x20A2, 0x2034, 0x1083, 0x1083, 

    // Table 25
    0x3014, 0x3014, 0x4029, 0x4056, 0x303A, 0x303A, 0x3054, 0x3054, 
    0x2069, 0x2069, 0x2069, 0x2069, 0x304B, 0x304B, 0x3061, 0x3061, 

    // Table 26
    0x109D, 0x102E, 

    // Table 27
    0x103D, 0x103D, 0x103D, 0x103D, 0x2050, 0x2050, 0x30A7, 0x303E, 

    // Table 28
    0x2052, 0x208D, 0x108F, 0x108F, 

    // Table 29
    0x105B, 0x105A, 
};

WORD g_Huffman_DCTACIntra_HighMotion[] =
{
    // Tables
    0x702A, 0x40AA, 0x40BA, 0x40CA, 0x40DA, 0x40EA, 0x40FA, 0x410A, 
    0x411A, 0x412A, 0x113A, 0x213C, 0x4140, 0x4150, 0x1160, 0x4162, 
    0x1172, 0x4174, 0x1184, 0x2186, 0x418A, 0x319A, 0x41A2, 0x31B2, 
    0x31BA, 0x11C2, 0x11C4, 0x11C6, 0x41C8, 0x31D8, 0x21E0, 0x21E4, 
    0x31E8, 0x21F0, 0x11F4, 0x31F6, 0x21FE, 0x3202, 0x220A, 0x420E, 
    0x121E, 0x1220, 

    // Table 0
    0x4013, 0x4013, 0x4013, 0x4013, 0x4013, 0x4013, 0x4013, 0x4013, 
    0x7015, 0x0001, 0x000B, 0x0008, 0x5022, 0x5022, 0x5022, 0x5022, 
    0x000A, 0x7023, 0x0003, 0x7044, 0x000D, 0x7005, 0x0010, 0x0005, 
    0x6039, 0x6039, 0x000F, 0x7048, 0x6004, 0x6004, 0x0007, 0x0002, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x5014, 0x5014, 0x5014, 0x5014, 0x708A, 0x7078, 0x000C, 0x0004, 
    0x5003, 0x5003, 0x5003, 0x5003, 0x502E, 0x502E, 0x502E, 0x502E, 
    0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 
    0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 0x3001, 
    0x6082, 0x6082, 0x000E, 0x708D, 0x507D, 0x507D, 0x507D, 0x507D, 
    0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 
    0x4077, 0x4077, 0x4077, 0x4077, 0x4077, 0x4077, 0x4077, 0x4077, 
    0x702F, 0x704C, 0x603F, 0x603F, 0x0006, 0x0009, 0x6086, 0x6086, 

    // Table 1
    0x203A, 0x203A, 0x203A, 0x203A, 0x403B, 0x0011, 0x3025, 0x3025, 
    0x1006, 0x1006, 0x1006, 0x1006, 0x1006, 0x1006, 0x1006, 0x1006, 

    // Table 2
    0x2045, 0x2045, 0x2045, 0x2045, 0x305E, 0x305E, 0x0012, 0x40A7, 
    0x1007, 0x1007, 0x1007, 0x1007, 0x1007, 0x1007, 0x1007, 0x1007, 

    // Table 3
    0x205A, 0x205A, 0x205A, 0x205A, 0x3060, 0x3060, 0x0013, 0x0014, 
    0x20B9, 0x20B9, 0x20B9, 0x20B9, 0x2008, 0x2008, 0x2008, 0x2008, 

    // Table 4
    0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 0x1099, 
    0x3051, 0x3051, 0x407A, 0x0015, 0x2009, 0x2009, 0x2009, 0x2009, 

    // Table 5
    0x300A, 0x300A, 0x400C, 0x0016, 0x4058, 0x4055, 0x407F, 0x0017, 
    0x1095, 0x1095, 0x1095, 0x1095, 0x1095, 0x1095, 0x1095, 0x1095, 

    // Table 6
    0x409E, 0x4046, 0x304D, 0x304D, 0x4068, 0x0019, 0x300B, 0x300B, 
    0x30A4, 0x30A4, 0x0018, 0x408B, 0x2079, 0x2079, 0x2079, 0x2079, 

    // Table 7
    0x401A, 0x001D, 0x4066, 0x001F, 0x209F, 0x209F, 0x209F, 0x209F, 
    0x20A1, 0x20A1, 0x20A1, 0x20A1, 0x001E, 0x001A, 0x001B, 0x001C, 

    // Table 8
    0x205D, 0x205D, 0x205D, 0x205D, 0x4026, 0x0021, 0x0022, 0x0020, 
    0x1091, 0x1091, 0x1091, 0x1091, 0x1091, 0x1091, 0x1091, 0x1091, 

    // Table 9
    0x2018, 0x2018, 0x2018, 0x2018, 0x4027, 0x0023, 0x405F, 0x0024, 
    0x109B, 0x109B, 0x109B, 0x109B, 0x109B, 0x109B, 0x109B, 0x109B, 

    // Table 10
    0x1016, 0x1050, 

    // Table 11
    0x207E, 0x2017, 0x108F, 0x108F, 

    // Table 12
    0x0025, 0x4032, 0x30A3, 0x30A3, 0x3031, 0x3031, 0x3019, 0x3019, 
    0x1097, 0x1097, 0x1097, 0x1097, 0x1097, 0x1097, 0x1097, 0x1097, 

    // Table 13
    0x3049, 0x3049, 0x0026, 0x40A6, 0x3083, 0x3083, 0x3063, 0x3063, 
    0x0027, 0x0028, 0x3087, 0x3087, 0x2040, 0x2040, 0x2040, 0x2040, 

    // Table 14
    0x1024, 0x1057, 

    // Table 15
    0x4041, 0x40A5, 0x0029, 0x405B, 0x2030, 0x2030, 0x2030, 0x2030, 
    0x1054, 0x1054, 0x1054, 0x1054, 0x1054, 0x1054, 0x1054, 0x1054, 

    // Table 16
    0x1093, 0x109D, 

    // Table 17
    0x101B, 0x101B, 0x101B, 0x101B, 0x101B, 0x101B, 0x101B, 0x101B, 
    0x3047, 0x3047, 0x30B6, 0x30B6, 0x3072, 0x3072, 0x402D, 0x408C, 

    // Table 18
    0x1033, 0x1064, 

    // Table 19
    0x2092, 0x20AF, 0x100D, 0x100D, 

    // Table 20
    0x302B, 0x302B, 0x4020, 0x4067, 0x2080, 0x2080, 0x2080, 0x2080, 
    0x205C, 0x205C, 0x205C, 0x205C, 0x3065, 0x3065, 0x3089, 0x3089, 

    // Table 21
    0x1090, 0x1090, 0x1090, 0x1090, 0x30B8, 0x3081, 0x3053, 0x307C, 

    // Table 22
    0x2061, 0x2061, 0x2061, 0x2061, 0x3075, 0x3075, 0x4076, 0x4021, 
    0x10AA, 0x10AA, 0x10AA, 0x10AA, 0x10AA, 0x10AA, 0x10AA, 0x10AA, 

    // Table 23
    0x207B, 0x207B, 0x3073, 0x302C, 0x1084, 0x1084, 0x1084, 0x1084, 

    // Table 24
    0x3036, 0x3037, 0x201E, 0x201E, 0x2035, 0x2035, 0x20B4, 0x20B4, 

    // Table 25
    0x106C, 0x10AE, 

    // Table 26
    0x100E, 0x1088, 

    // Table 27
    0x10AD, 0x101C, 

    // Table 28
    0x403E, 0x4062, 0x304B, 0x304B, 0x2098, 0x2098, 0x2098, 0x2098, 
    0x2070, 0x2070, 0x2070, 0x2070, 0x202A, 0x202A, 0x202A, 0x202A, 

    // Table 29
    0x3043, 0x303D, 0x2059, 0x2059, 0x108E, 0x108E, 0x108E, 0x108E, 

    // Table 30
    0x10B0, 0x10B0, 0x2094, 0x2056, 

    // Table 31
    0x2071, 0x206F, 0x20B1, 0x20B5, 

    // Table 32
    0x3085, 0x3011, 0x200F, 0x200F, 0x10A8, 0x10A8, 0x10A8, 0x10A8, 

    // Table 33
    0x204E, 0x20B2, 0x2042, 0x2029, 

    // Table 34
    0x10AB, 0x10AC, 

    // Table 35
    0x2096, 0x2096, 0x2010, 0x2010, 0x20A2, 0x20A2, 0x3012, 0x30B7, 

    // Table 36
    0x1052, 0x1052, 0x20B3, 0x20A0, 

    // Table 37
    0x103C, 0x103C, 0x103C, 0x103C, 0x209A, 0x209A, 0x304F, 0x3074, 

    // Table 38
    0x206E, 0x206D, 0x201D, 0x209C, 

    // Table 39
    0x2034, 0x2034, 0x2034, 0x2034, 0x301F, 0x301F, 0x4038, 0x4069, 
    0x106A, 0x106A, 0x106A, 0x106A, 0x106A, 0x106A, 0x106A, 0x106A, 

    // Table 40
    0x10A9, 0x106B, 

    // Table 41
    0x104A, 0x1028, 
};

WORD g_Huffman_DCTACInter_Talking[] =
{
    // Tables
    0x7020, 0x10A0, 0x40A2, 0x30B2, 0x40BA, 0x40CA, 0x40DA, 0x40EA, 
    0x40FA, 0x410A, 0x211A, 0x411E, 0x212E, 0x3132, 0x413A, 0x314A, 
    0x1152, 0x2154, 0x2158, 0x315C, 0x1164, 0x3166, 0x216E, 0x1172, 
    0x3174, 0x317C, 0x1184, 0x2186, 0x418A, 0x419A, 0x11AA, 0x31AC, 

    // Table 0
    0x0009, 0x706C, 0x000B, 0x0005, 0x601C, 0x601C, 0x7028, 0x0008, 
    0x6064, 0x6064, 0x7070, 0x0004, 0x6066, 0x6066, 0x606A, 0x606A, 
    0x505D, 0x505D, 0x505D, 0x505D, 0x706E, 0x7074, 0x7072, 0x7002, 
    0x0006, 0x702B, 0x6068, 0x6068, 0x5017, 0x5017, 0x5017, 0x5017, 
    0x405A, 0x405A, 0x405A, 0x405A, 0x405A, 0x405A, 0x405A, 0x405A, 
    0x4056, 0x4056, 0x4056, 0x4056, 0x4056, 0x4056, 0x4056, 0x4056, 
    0x5062, 0x5062, 0x5062, 0x5062, 0x6020, 0x6020, 0x000A, 0x700F, 
    0x5060, 0x5060, 0x5060, 0x5060, 0x6024, 0x6024, 0x0003, 0x0001, 
    0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 
    0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000, 
    0x5001, 0x5001, 0x5001, 0x5001, 0x7052, 0x0002, 0x0007, 0x702E, 
    0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 0x400E, 
    0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 
    0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 
    0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 
    0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 0x2051, 

    // Table 1
    0x1078, 0x1003, 

    // Table 2
    0x2004, 0x2004, 0x2004, 0x2004, 0x000D, 0x000C, 0x3053, 0x3053, 
    0x1079, 0x1079, 0x1079, 0x1079, 0x1079, 0x1079, 0x1079, 0x1079, 

    // Table 3
    0x2057, 0x2057, 0x3005, 0x307F, 0x1034, 0x1034, 0x1034, 0x1034, 

    // Table 4
    0x3082, 0x3082, 0x0010, 0x000F, 0x207A, 0x207A, 0x207A, 0x207A, 
    0x2083, 0x2083, 0x2083, 0x2083, 0x3084, 0x3084, 0x000E, 0x4006, 

    // Table 5
    0x0014, 0x4047, 0x0011, 0x0012, 0x2094, 0x2094, 0x2094, 0x2094, 
    0x305B, 0x305B, 0x404E, 0x0013, 0x3021, 0x3021, 0x3025, 0x3025, 

    // Table 6
    0x4032, 0x408B, 0x402F, 0x4044, 0x201D, 0x201D, 0x201D, 0x201D, 
    0x2010, 0x2010, 0x2010, 0x2010, 0x0015, 0x4038, 0x0017, 0x0016, 

    // Table 7
    0x001B, 0x001A, 0x4063, 0x4085, 0x0019, 0x0018, 0x307E, 0x307E, 
    0x103A, 0x103A, 0x103A, 0x103A, 0x103A, 0x103A, 0x103A, 0x103A, 

    // Table 8
    0x203D, 0x203D, 0x203D, 0x203D, 0x3080, 0x3080, 0x001C, 0x405E, 
    0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 0x1076, 

    // Table 9
    0x3081, 0x3081, 0x4043, 0x4019, 0x4029, 0x001D, 0x402C, 0x4011, 
    0x2037, 0x2037, 0x2037, 0x2037, 0x203F, 0x203F, 0x203F, 0x203F, 

    // Table 10
    0x207B, 0x2041, 0x1018, 0x1018, 

    // Table 11
    0x1031, 0x1031, 0x1031, 0x1031, 0x1031, 0x1031, 0x1031, 0x1031, 
    0x307D, 0x307D, 0x001E, 0x001F, 0x207C, 0x207C, 0x207C, 0x207C, 

    // Table 12
    0x1008, 0x1008, 0x2089, 0x208C, 

    // Table 13
    0x205C, 0x205C, 0x3030, 0x308E, 0x1058, 0x1058, 0x1058, 0x1058, 

    // Table 14
    0x202A, 0x202A, 0x202A, 0x202A, 0x301B, 0x301B, 0x400D, 0x4016, 
    0x208A, 0x208A, 0x208A, 0x208A, 0x3015, 0x3015, 0x3055, 0x3055, 

    // Table 15
    0x1012, 0x1012, 0x1012, 0x1012, 0x3033, 0x308D, 0x2040, 0x2040, 

    // Table 16
    0x1035, 0x104F, 

    // Table 17
    0x2067, 0x206B, 0x1007, 0x1007, 

    // Table 18
    0x1048, 0x1048, 0x2013, 0x2092, 

    // Table 19
    0x104D, 0x104D, 0x104D, 0x104D, 0x203E, 0x203E, 0x3090, 0x301F, 

    // Table 20
    0x103B, 0x1046, 

    // Table 21
    0x2009, 0x2009, 0x2049, 0x2049, 0x204A, 0x204A, 0x3050, 0x303C, 

    // Table 22
    0x2091, 0x202D, 0x101A, 0x101A, 

    // Table 23
    0x1065, 0x104C, 

    // Table 24
    0x2093, 0x2093, 0x308F, 0x3027, 0x206F, 0x206F, 0x200A, 0x200A, 

    // Table 25
    0x2014, 0x2014, 0x300C, 0x3023, 0x1022, 0x1022, 0x1022, 0x1022, 

    // Table 26
    0x1071, 0x1026, 

    // Table 27
    0x2042, 0x2039, 0x1088, 0x1088, 

    // Table 28
    0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 0x1086, 
    0x2069, 0x2069, 0x2069, 0x2069, 0x405F, 0x4036, 0x300B, 0x300B, 

    // Table 29
    0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 0x1061, 
    0x2054, 0x2054, 0x2054, 0x2054, 0x306D, 0x306D, 0x4077, 0x4059, 

    // Table 30
    0x1087, 0x101E, 

    // Table 31
    0x204B, 0x204B, 0x3075, 0x3073, 0x1045, 0x1045, 0x1045, 0x1045, 
};

WORD g_Huffman_DCTACIntra_Talking[] =
{
    // Tables
    0x501C, 0x203C, 0x4040, 0x4050, 0x4060, 0x4070, 0x4080, 0x4090, 
    0x40A0, 0x30B0, 0x30B8, 0x20C0, 0x10C4, 0x30C6, 0x40CE, 0x30DE, 
    0x30E6, 0x30EE, 0x10F6, 0x40F8, 0x1108, 0x210A, 0x310E, 0x3116, 
    0x111E, 0x3120, 0x4128, 0x1138, 

    // Table 0
    0x0008, 0x0003, 0x4010, 0x4010, 0x501B, 0x0005, 0x0002, 0x0006, 
    0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 
    0x0001, 0x5011, 0x5059, 0x0004, 0x4055, 0x4055, 0x5003, 0x5023, 
    0x3001, 0x3001, 0x3001, 0x3001, 0x0009, 0x0007, 0x4002, 0x4002, 

    // Table 1
    0x1004, 0x1004, 0x2056, 0x2065, 

    // Table 2
    0x2005, 0x2005, 0x2005, 0x2005, 0x000A, 0x000C, 0x306F, 0x306F, 
    0x3040, 0x3040, 0x4078, 0x000B, 0x2037, 0x2037, 0x2037, 0x2037, 

    // Table 3
    0x3006, 0x3006, 0x4014, 0x000E, 0x4049, 0x4046, 0x3013, 0x3013, 
    0x2033, 0x2033, 0x2033, 0x2033, 0x4030, 0x000D, 0x306D, 0x306D, 

    // Table 4
    0x3071, 0x3071, 0x0012, 0x0011, 0x3007, 0x3007, 0x4077, 0x0010, 
    0x2024, 0x2024, 0x2024, 0x2024, 0x301D, 0x301D, 0x4009, 0x000F, 

    // Table 5
    0x201C, 0x201C, 0x201C, 0x201C, 0x306B, 0x306B, 0x4008, 0x0014, 
    0x2084, 0x2084, 0x2084, 0x2084, 0x3075, 0x3075, 0x4025, 0x0013, 

    // Table 6
    0x102A, 0x102A, 0x102A, 0x102A, 0x102A, 0x102A, 0x102A, 0x102A, 
    0x0015, 0x0017, 0x4034, 0x0016, 0x2063, 0x2063, 0x2063, 0x2063, 

    // Table 7
    0x305A, 0x305A, 0x0018, 0x4057, 0x3073, 0x3073, 0x4015, 0x0019, 
    0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 0x102F, 

    // Table 8
    0x2060, 0x2060, 0x2060, 0x2060, 0x001B, 0x001A, 0x3067, 0x3067, 
    0x2012, 0x2012, 0x2012, 0x2012, 0x3069, 0x3069, 0x303D, 0x303D, 

    // Table 9
    0x3043, 0x302B, 0x203A, 0x203A, 0x105D, 0x105D, 0x105D, 0x105D, 

    // Table 10
    0x2035, 0x2035, 0x2017, 0x2017, 0x2076, 0x2076, 0x3082, 0x3045, 

    // Table 11
    0x201F, 0x2027, 0x103B, 0x103B, 

    // Table 12
    0x104E, 0x104C, 

    // Table 13
    0x207C, 0x207C, 0x3018, 0x307D, 0x3028, 0x3080, 0x200C, 0x200C, 

    // Table 14
    0x205B, 0x205B, 0x205B, 0x205B, 0x300E, 0x300E, 0x405C, 0x4036, 
    0x302D, 0x302D, 0x4054, 0x401A, 0x4074, 0x402E, 0x3042, 0x3042, 

    // Table 15
    0x1016, 0x1016, 0x1016, 0x1016, 0x2053, 0x2053, 0x306E, 0x3070, 

    // Table 16
    0x2066, 0x2066, 0x2058, 0x2058, 0x2064, 0x2064, 0x3032, 0x303C, 

    // Table 17
    0x203F, 0x203F, 0x2051, 0x2051, 0x3062, 0x304D, 0x306A, 0x3072, 

    // Table 18
    0x105E, 0x1041, 

    // Table 19
    0x4029, 0x406C, 0x307E, 0x307E, 0x2047, 0x2047, 0x2047, 0x2047, 
    0x304F, 0x304F, 0x3052, 0x3052, 0x2050, 0x2050, 0x2050, 0x2050, 

    // Table 20
    0x1061, 0x103E, 

    // Table 21
    0x100A, 0x100A, 0x2020, 0x207B, 

    // Table 22
    0x104A, 0x104A, 0x104A, 0x104A, 0x3019, 0x3081, 0x200D, 0x200D, 

    // Table 23
    0x204B, 0x204B, 0x3021, 0x3068, 0x1026, 0x1026, 0x1026, 0x1026, 

    // Table 24
    0x102C, 0x100B, 

    // Table 25
    0x2039, 0x2039, 0x305F, 0x3048, 0x107A, 0x107A, 0x107A, 0x107A, 

    // Table 26
    0x2031, 0x2031, 0x2031, 0x2031, 0x2079, 0x2079, 0x2079, 0x2079, 
    0x2044, 0x2044, 0x2044, 0x2044, 0x407F, 0x400F, 0x4083, 0x4022, 

    // Table 27
    0x1038, 0x101E, 
};

WORD g_Huffman_DCTACInter_MPEG4[] =
{
    // Tables
    0x3012, 0x101A, 0x301C, 0x4024, 0x6034, 0x2074, 0x1078, 0x207A, 
    0x207E, 0x1082, 0x3084, 0x108C, 0x108E, 0x1090, 0x1092, 0x1094, 
    0x2096, 0x309A, 

    // Table 0
    0x0004, 0x0003, 0x0002, 0x0005, 0x2000, 0x2000, 0x300C, 0x0001, 

    // Table 1
    0x1012, 0x1001, 

    // Table 2
    0x3026, 0x3024, 0x3022, 0x301F, 0x300D, 0x3002, 0x201C, 0x201C, 

    // Table 3
    0x4045, 0x4044, 0x4043, 0x4042, 0x402B, 0x402A, 0x4028, 0x4003, 
    0x3041, 0x3041, 0x3040, 0x3040, 0x303F, 0x303F, 0x303D, 0x303D, 

    // Table 4
    0xFDCD, 0x0007, 0x000F, 0x000E, 0x000D, 0x000C, 0x000B, 0x0009, 
    0x0008, 0x0010, 0x000A, 0x0011, 0x4066, 0x4066, 0x4066, 0x4066, 
    0x0006, 0x6055, 0x6054, 0x6053, 0x6052, 0x6051, 0x6050, 0x604F, 
    0x604E, 0x603B, 0x6035, 0x6034, 0x6033, 0x6032, 0x6031, 0x6030, 
    0x602F, 0x602E, 0x601A, 0x6017, 0x6006, 0x6005, 0x504D, 0x504D, 
    0x504C, 0x504C, 0x504B, 0x504B, 0x504A, 0x504A, 0x5049, 0x5049, 
    0x5048, 0x5048, 0x5047, 0x5047, 0x5046, 0x5046, 0x502D, 0x502D, 
    0x502C, 0x502C, 0x5013, 0x5013, 0x500E, 0x500E, 0x5004, 0x5004, 

    // Table 5
    0x2019, 0x2016, 0x103A, 0x103A, 

    // Table 6
    0x1008, 0x1007, 

    // Table 7
    0x203E, 0x203C, 0x200A, 0x2009, 

    // Table 8
    0x200B, 0x2010, 0x2036, 0x2037, 

    // Table 9
    0x1014, 0x100F, 

    // Table 10
    0x3011, 0x3015, 0x301B, 0x301E, 0x3021, 0x3029, 0x3038, 0x3039, 

    // Table 11
    0x101D, 0x1018, 

    // Table 12
    0x1023, 0x1020, 

    // Table 13
    0x1027, 0x1025, 

    // Table 14
    0x1057, 0x1056, 

    // Table 15
    0x1059, 0x1058, 

    // Table 16
    0x205A, 0x205B, 0x205C, 0x205D, 

    // Table 17
    0x305E, 0x305F, 0x3060, 0x3061, 0x3062, 0x3063, 0x3064, 0x3065, 
};

WORD g_Huffman_DCTACIntra_MPEG4[] =
{
    // Tables
    0x3012, 0x101A, 0x201C, 0x3020, 0x4028, 0x6038, 0x1078, 0x107A, 
    0x207C, 0x2080, 0x3084, 0x108C, 0x108E, 0x1090, 0x1092, 0x3094, 
    0x109C, 0x209E, 

    // Table 0
    0x0005, 0x0004, 0x0003, 0x0002, 0x2000, 0x2000, 0x3001, 0x0001, 

    // Table 1
    0x101B, 0x1002, 

    // Table 2
    0x2004, 0x2003, 0x1043, 0x1043, 

    // Table 3
    0x302E, 0x302A, 0x3007, 0x3006, 0x301C, 0x3005, 0x2025, 0x2025, 

    // Table 4
    0x4052, 0x4050, 0x4034, 0x4054, 0x4037, 0x4026, 0x401D, 0x4008, 
    0x3044, 0x3044, 0x3031, 0x3031, 0x304E, 0x304E, 0x304B, 0x304B, 

    // Table 5
    0xFDCD, 0x0008, 0x0010, 0x000E, 0x000D, 0x000C, 0x000B, 0x0007, 
    0x0009, 0x0011, 0x000A, 0x000F, 0x4066, 0x4066, 0x4066, 0x4066, 
    0x0006, 0x605F, 0x605E, 0x605D, 0x605C, 0x605B, 0x604C, 0x6046, 
    0x6040, 0x603F, 0x6038, 0x6035, 0x6032, 0x602C, 0x6027, 0x6020, 
    0x601F, 0x600F, 0x602F, 0x600E, 0x600D, 0x600C, 0x5059, 0x5059, 
    0x5058, 0x5058, 0x5056, 0x5056, 0x5045, 0x5045, 0x503E, 0x503E, 
    0x503C, 0x503C, 0x503A, 0x503A, 0x505A, 0x505A, 0x502B, 0x502B, 
    0x501E, 0x501E, 0x500B, 0x500B, 0x500A, 0x500A, 0x5009, 0x5009, 

    // Table 6
    0x1011, 0x1010, 

    // Table 7
    0x1013, 0x1012, 

    // Table 8
    0x2049, 0x2048, 0x2015, 0x2014, 

    // Table 9
    0x2016, 0x2017, 0x2022, 0x203D, 

    // Table 10
    0x3018, 0x3019, 0x301A, 0x3023, 0x3036, 0x3024, 0x3029, 0x3039, 

    // Table 11
    0x1028, 0x1021, 

    // Table 12
    0x1030, 0x102D, 

    // Table 13
    0x1033, 0x103B, 

    // Table 14
    0x1047, 0x1041, 

    // Table 15
    0x3042, 0x304A, 0x3055, 0x3057, 0x3062, 0x3063, 0x3064, 0x3065, 

    // Table 16
    0x104F, 0x104D, 

    // Table 17
    0x2051, 0x2053, 0x2060, 0x2061, 
};

/*
 * Run tables
 */

//Talking
BYTE g_InterRunAtIndex_Talking[148] = 
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    2,    2,    2,    2,    2,    3,    3,
   3,    3,    4,    4,    4,    4,    5,    5,    5,    5,
   6,    6,    6,    7,    7,    7,    8,    8,    8,    9,
   9,    9,   10,   10,   10,   11,   11,   11,   12,   12,
  12,   13,   13,   14,   14,   15,   15,   16,   17,   18,
  19,   20,   21,   22,   23,   24,   25,   26,   27,   28,
  29,    0,    0,    0,    0,    0,    1,    1,    1,    1,
   2,    2,    2,    3,    3,    3,    4,    4,    5,    5,
   6,    6,    7,    7,    8,    8,    9,    9,   10,   10,
  11,   11,   12,   12,   13,   13,   14,   14,   15,   15,
  16,   17,   18,   19,   20,   21,   22,   23,   24,   25,
  26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
  36,   37,   38,   39,   40,   41,   42,   43,   
};

BYTE g_IntraRunAtIndex_Talking[132] = 
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
   2,    2,    2,    2,    2,    3,    3,    3,    3,    3,
   3,    3,    4,    4,    4,    4,    4,    5,    5,    5,
   5,    6,    6,    6,    6,    7,    7,    7,    8,    8,
   8,    9,    9,    9,   10,   10,   10,   11,   11,   11,
  12,   12,   12,   13,   13,   13,   14,   14,   15,   15,
  16,   17,   18,   19,   20,    0,    0,    0,    0,    1,
   1,    1,    1,    2,    2,    2,    3,    3,    3,    4,
   4,    5,    5,    6,    6,    7,    7,    8,    8,    9,
   9,   10,   10,   11,   11,   12,   12,   13,   13,   14,
  15,   16,   17,   18,   19,   20,   21,   22,   23,   24,
  25,   26,   
};

char g_InterLevelAtIndex_Talking[148] = 
{
   1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
  11,   12,   13,   14,    1,    2,    3,    4,    5,    6,
   7,    8,    9,    1,    2,    3,    4,    5,    1,    2,
   3,    4,    1,    2,    3,    4,    1,    2,    3,    4,
   1,    2,    3,    1,    2,    3,    1,    2,    3,    1,
   2,    3,    1,    2,    3,    1,    2,    3,    1,    2,
   3,    1,    2,    1,    2,    1,    2,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    2,    3,    4,    5,    1,    2,    3,    4,
   1,    2,    3,    1,    2,    3,    1,    2,    1,    2,
   1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
   1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,   
};

char g_IntraLevelAtIndex_Talking[132] = 
{
   1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
  11,   12,   13,   14,   15,   16,    1,    2,    3,    4,
   5,    6,    7,    8,    9,   10,   11,    1,    2,    3,
   4,    5,    6,    7,    8,    1,    2,    3,    4,    5,
   6,    7,    1,    2,    3,    4,    5,    1,    2,    3,
   4,    1,    2,    3,    4,    1,    2,    3,    1,    2,
   3,    1,    2,    3,    1,    2,    3,    1,    2,    3,
   1,    2,    3,    1,    2,    3,    1,    2,    1,    2,
   1,    1,    1,    1,    1,    1,    2,    3,    4,    1,
   2,    3,    4,    1,    2,    3,    1,    2,    3,    1,
   2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,  
};

// High motion
BYTE g_InterRunAtIndex_HighMotion[168] = 
{
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    2,    2,    2,    2,    2,    2,
    2,    2,    3,    3,    3,    3,    3,    3,    3,    4,
    4,    4,    4,    4,    5,    5,    5,    5,    5,    6,
    6,    6,    6,    7,    7,    7,    7,    8,    8,    8,
    9,    9,    9,   10,   10,   10,   11,   11,   11,   12,
   12,   13,   13,   14,   14,   15,   15,   16,   16,   17,
   18,   19,   20,   21,   22,   23,   24,   25,   26,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    1,    1,
    1,    1,    1,    2,    2,    2,    2,    3,    3,    3,
    3,    4,    4,    4,    5,    5,    5,    6,    6,    6,
    7,    7,    8,    8,    9,    9,   10,   10,   11,   11,
   12,   12,   13,   13,   14,   14,   15,   16,   17,   18,
   19,   20,   21,   22,   23,   24,   25,   26,   27,   28,
   29,   30,   31,   32,   33,   34,   35,   36,  
};
BYTE g_IntraRunAtIndex_HighMotion[185] = 
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    2,    2,    2,    2,    2,    2,
   2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
   3,    3,    3,    3,    3,    3,    3,    4,    4,    4,
   4,    4,    4,    5,    5,    5,    5,    5,    6,    6,
   6,    6,    7,    7,    7,    7,    8,    8,    8,    8,
   9,    9,    9,    9,   10,   10,   10,   11,   11,   11,
  12,   12,   12,   13,   13,   13,   14,   14,   14,   15,
  15,   15,   16,   16,   17,   17,   18,   19,   20,   21,
  22,   23,   24,   25,   26,   27,   28,   29,   30,    0,
   0,    0,    0,    0,    0,    1,    1,    1,    1,    1,
   2,    2,    2,    2,    3,    3,    3,    3,    4,    4,
   4,    5,    5,    6,    6,    7,    7,    8,    8,    9,
   9,   10,   10,   11,   11,   12,   12,   13,   13,   14,
  14,   15,   15,   16,   17,   18,   19,   20,   21,   22,
  23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
  33,   34,   35,   36,   37, 
};

char g_InterLevelAtIndex_HighMotion[168] = 
{
    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
   21,   22,   23,    1,    2,    3,    4,    5,    6,    7,
    8,    9,   10,   11,    1,    2,    3,    4,    5,    6,
    7,    8,    1,    2,    3,    4,    5,    6,    7,    1,
    2,    3,    4,    5,    1,    2,    3,    4,    5,    1,
    2,    3,    4,    1,    2,    3,    4,    1,    2,    3,
    1,    2,    3,    1,    2,    3,    1,    2,    3,    1,
    2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    2,    3,    4,    5,    6,    7,    8,    9,    1,    2,
    3,    4,    5,    1,    2,    3,    4,    1,    2,    3,
    4,    1,    2,    3,    1,    2,    3,    1,    2,    3,
    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
    1,    2,    1,    2,    1,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,
};

char g_IntraLevelAtIndex_HighMotion[185] = 
{
   1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
  11,   12,   13,   14,   15,   16,   17,   18,   19,    1,
   2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
  12,   13,   14,   15,    1,    2,    3,    4,    5,    6,
   7,    8,    9,   10,   11,   12,    1,    2,    3,    4,
   5,    6,    7,    8,    9,   10,   11,    1,    2,    3,
   4,    5,    6,    1,    2,    3,    4,    5,    1,    2,
   3,    4,    1,    2,    3,    4,    1,    2,    3,    4,
   1,    2,    3,    4,    1,    2,    3,    1,    2,    3,
   1,    2,    3,    1,    2,    3,    1,    2,    3,    1,
   2,    3,    1,    2,    1,    2,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   2,    3,    4,    5,    6,    1,    2,    3,    4,    5,
   1,    2,    3,    4,    1,    2,    3,    4,    1,    2,
   3,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   2,    1,    2,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,  
};

// MPEG4
BYTE g_InterRunAtIndex_MPEG4[102] = 
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,1,1,1,1,1,1,2,2,
	2,2,3,3,3,4,4,4,5,5,
	5,6,6,6,7,7,8,8,9,9,
	10,10,11,12,13,14,15,16,17,18,
	19,20,21,22,23,24,25,26,0,0,
	0,1,1,2,3,4,5,6,7,8,
	9,10,11,12,13,14,15,16,17,18,
	19,20,21,22,23,24,25,26,27,28,
	29,30,31,32,33,34,35,36,37,38,
	39,40
};

BYTE g_IntraRunAtIndex_MPEG4[102] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,1,1,1,
	1,1,1,1,1,1,1,2,2,2,
	2,2,3,3,3,3,4,4,4,5,
	5,5,6,6,6,7,7,7,8,8,
	9,9,10,11,12,13,14,0,0,0,
	0,0,0,0,0,1,1,1,2,2,
	3,3,4,4,5,5,6,6,7,8,
	9,10,11,12,13,14,15,16,17,18,
	19,20
};

char g_InterLevelAtIndex_MPEG4[102] = 
{
	1,2,3,4,5,6,7,8,9,10,
	11,12,1,2,3,4,5,6,1,2,
	3,4,1,2,3,1,2,3,1,2,
	3,1,2,3,1,2,1,2,1,2,
	1,2,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,2,
	3,1,2,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1	
};

char g_IntraLevelAtIndex_MPEG4[102] = 
{
	1,2,3,4,5,6,7,8,9,10,
	11,12,13,14,15,16,17,18,19,20,
	21,22,23,24,25,26,27,1,2,3,
	4,5,6,7,8,9,10,1,2,3,
	4,5,1,2,3,4,1,2,3,1,
	2,3,1,2,3,1,2,3,1,2,
	1,2,1,1,1,1,1,1,2,3,
	4,5,6,7,8,1,2,3,1,2,
	1,2,1,2,1,2,1,2,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1
};

// Talking
BYTE g_InterNotLastDeltaOfRunAtLevel_Talking[15] = 
{
	-1, 29, 15, 12, 5, 2, 1, 1, 1, 1, 0,
	 0,  0,  0, 0, 
};

BYTE g_InterLastDeltaOfRunAtLevel_Talking[6] = 
{
	 -1, 43, 15, 3, 1, 0,
};

BYTE g_InterNotLastDeltaOfLevelAtRun_Talking[30] = 
{
  14,    9,    5,    4,    4,    4,    3,    3,    3,    3,    3,
   3,    3,    2,    2,    2,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,
};

BYTE g_InterLastDeltaOfLevelAtRun_Talking[44] = 
{
   5,    4,    3,    3,    2,    2,    2,    2,    2,    2,    2,
   2,    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
};

BYTE g_IntraNotLastDeltaOfRunAtLevel_Talking[17] = 
{
	-1, 20, 15, 13, 6, 4, 3, 3, 2, 1, 1,
	 1,  0, 0, 0, 0, 0,
};

BYTE g_IntraLastDeltaOfRunAtLevel_Talking[5] = 
{
	 -1, 26, 13, 3, 1,
};

BYTE g_IntraNotLastDeltaOfLevelAtRun_Talking[21] = 
{ 
   16,   11,    8,    7,    5,    4,    4,    3,    3,    3,    3,
    3,    3,    3,    2,    2,    1,    1,    1,    1,    1,
};

BYTE g_IntraLastDeltaOfLevelAtRun_Talking[27] = 
{ 
    4,    4,    3,    3,    2,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};

// High motion
BYTE g_InterNotLastDeltaOfRunAtLevel_HighMotion[24] = 
{
  -1,  26,  16,  11,   7,   5,   3,   3,   2,   1,   1,
   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,
};

BYTE g_InterLastDeltaOfRunAtLevel_HighMotion[10] = 
{
  -1,  36,  14,   6,   3,   1,   0,   0,   0,   0,
};

BYTE g_InterNotLastDeltaOfLevelAtRun_HighMotion[27] = 
{
  23,   11,    8,    7,    5,    5,    4,    4,    3,    3,    3,
    3,    2,    2,    2,    2,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};

BYTE g_InterLastDeltaOfLevelAtRun_HighMotion[37] = 
{ 
    9,    5,    4,    4,    3,    3,    3,    2,    2,    2,    2,
    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,
};

BYTE g_IntraNotLastDeltaOfRunAtLevel_HighMotion[20] = 
{
  -1,  30,  17,  15,   9,   5,   4,   3,   3,   3,   3,
   3,   2,   1,   1,   1,   0,   0,   0,   0,
};

BYTE g_IntraLastDeltaOfRunAtLevel_HighMotion[7] = 
{
  -1,  37,  15,   4,   3,   1,   0,
};

BYTE g_IntraNotLastDeltaOfLevelAtRun_HighMotion[31] = 
{ 
   19,   15,   12,   11,    6,    5,    4,    4,    4,    4,    3,
    3,    3,    3,    3,    3,    2,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,
};

BYTE g_IntraLastDeltaOfLevelAtRun_HighMotion[38] = 
{ 
    6,    5,    4,    4,    3,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,
};

// MPEG4
BYTE g_InterNotLastDeltaOfRunAtLevel_MPEG4[13] = 
{
	-1, 26, 10, 6, 2, 1, 1,
	 0,  0,  0, 0, 0, 0  
};

BYTE g_InterLastDeltaOfRunAtLevel_MPEG4[4] = 
{ 
	 -1, 40, 1, 0
};

BYTE g_InterNotLastDeltaOfLevelAtRun_MPEG4[27] = 
{
	12, 6, 4, 3, 3, 3, 3, 2, 2, 2, 2,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1
};

BYTE g_InterLastDeltaOfLevelAtRun_MPEG4[41] = 
{
	 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1
};

BYTE g_IntraNotLastDeltaOfRunAtLevel_MPEG4[28] = 
{
	-1, 14, 9, 7, 3, 2, 1, 1, 1, 1,
	 1,  0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0,  0, 0, 0, 0, 0, 0, 0
};

BYTE g_IntraLastDeltaOfRunAtLevel_MPEG4[9] = 
{
	 -1, 20, 6, 1, 0, 0, 0, 0, 0
};

BYTE g_IntraNotLastDeltaOfLevelAtRun_MPEG4[15] = 
{
	27, 10, 5, 4, 3, 3, 3, 3, 2, 2, 1,
	 1, 1, 1, 1
};

BYTE g_IntraLastDeltaOfLevelAtRun_MPEG4[21] = 
{
	 8, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1,
	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};

/*
 * AC Decoder tables
 */

XMVACCoefficientDecoderTable g_InterDecoderTables[] =
{
    {
        g_Huffman_DCTACInter_Talking,
        148,
        81,
        g_InterRunAtIndex_Talking,
        g_InterNotLastDeltaOfRunAtLevel_Talking,
        g_InterLastDeltaOfRunAtLevel_Talking,
        g_InterLevelAtIndex_Talking,
        g_InterNotLastDeltaOfLevelAtRun_Talking,
        g_InterLastDeltaOfLevelAtRun_Talking
    },

    {
        g_Huffman_DCTACInter_HighMotion,
        168,
        99,
        g_InterRunAtIndex_HighMotion,
        g_InterNotLastDeltaOfRunAtLevel_HighMotion,
        g_InterLastDeltaOfRunAtLevel_HighMotion,
        g_InterLevelAtIndex_HighMotion,
        g_InterNotLastDeltaOfLevelAtRun_HighMotion,
        g_InterLastDeltaOfLevelAtRun_HighMotion
    },

    {
        g_Huffman_DCTACInter_MPEG4,
        102,
        58,
        g_InterRunAtIndex_MPEG4,
        g_InterNotLastDeltaOfRunAtLevel_MPEG4,
        g_InterLastDeltaOfRunAtLevel_MPEG4,
        g_InterLevelAtIndex_MPEG4,
        g_InterNotLastDeltaOfLevelAtRun_MPEG4,
        g_InterLastDeltaOfLevelAtRun_MPEG4
    },
};

XMVACCoefficientDecoderTable g_IntraDecoderTables[] =
{
    {
        g_Huffman_DCTACIntra_Talking,
        132,
        85,
        g_IntraRunAtIndex_Talking,
        g_IntraNotLastDeltaOfRunAtLevel_Talking,
        g_IntraLastDeltaOfRunAtLevel_Talking,
        g_IntraLevelAtIndex_Talking,
        g_IntraNotLastDeltaOfLevelAtRun_Talking,
        g_IntraLastDeltaOfLevelAtRun_Talking
    },

    {
        g_Huffman_DCTACIntra_HighMotion,
        185,
        119,
        g_IntraRunAtIndex_HighMotion,
        g_IntraNotLastDeltaOfRunAtLevel_HighMotion,
        g_IntraLastDeltaOfRunAtLevel_HighMotion,
        g_IntraLevelAtIndex_HighMotion,
        g_IntraNotLastDeltaOfLevelAtRun_HighMotion,
        g_IntraLastDeltaOfLevelAtRun_HighMotion
    },

    {
        g_Huffman_DCTACIntra_MPEG4,
        102,
        67,
        g_IntraRunAtIndex_MPEG4,
        g_IntraNotLastDeltaOfRunAtLevel_MPEG4,
        g_IntraLastDeltaOfRunAtLevel_MPEG4,
        g_IntraLevelAtIndex_MPEG4,
        g_IntraNotLastDeltaOfLevelAtRun_MPEG4,
        g_IntraLastDeltaOfLevelAtRun_MPEG4
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\asfguids.h ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       asfguids.h
 *  Content:    Tables used to convert the ASF guids to something
 *              more easily consumed.
 *
 * This utility is currently only used for testing as we're not exactly
 * sure what conversions we want to do yet.
 *
 ****************************************************************************/

ASF_GUID(ASF_Header_Object,                      0x75B22630, 0x668E, 0x11CF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C)  
ASF_GUID(ASF_Data_Object,                        0x75B22636, 0x668E, 0x11CF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C)
ASF_GUID(ASF_Simple_Index_Object,                0x33000890, 0xE5B1, 0x11CF, 0x89, 0xF4, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xCB)
ASF_GUID(ASF_File_Properties_Object,             0x8CABDCA1, 0xA947, 0x11CF, 0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65)
ASF_GUID(ASF_Stream_Properties_Object,           0xB7DC0791, 0xA9B7, 0x11CF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65)
ASF_GUID(ASF_Stream_Bitrate_Properties_Object,   0x7BF875CE, 0x468D, 0x11D1, 0x8D, 0x82, 0x00, 0x60, 0x97, 0xC9, 0xA2, 0xB2)
ASF_GUID(ASF_Content_Description_Object,         0x75B22633, 0x668E, 0x11CF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C)
ASF_GUID(ASF_Extended_Content_Description_Object,0x298AE614, 0x2622, 0x4c17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9C)
ASF_GUID(ASF_Script_Command_Object,              0x1EFB1A30, 0x0B62, 0x11D0, 0xA3, 0x9B, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6)
ASF_GUID(ASF_Marker_Object,                      0xF487CD01, 0xA951, 0x11CF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65)
ASF_GUID(ASF_Clock_Object,                       0x5FBF03B5, 0xA92E, 0x11CF, 0x8E, 0xE3, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65)
ASF_GUID(ASF_Bitrate_Mutual_Exclusion_Object,    0xD6E229DC, 0x35DA, 0x11D1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE)
ASF_GUID(ASF_Codec_List_Object,                  0x86D15240, 0x311D, 0x11D0, 0xA3, 0xA4, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6)
ASF_GUID(ASF_Metadata_Object,                    0xA69609E7, 0x517B, 0x11d2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9)
ASF_GUID(ASF_Error_Correction_Object,            0x75B22635, 0x668E, 0x11CF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C)
ASF_GUID(ASF_Padding_Object,                     0x1806D474, 0xCADF, 0x4509, 0xA4, 0xBA, 0x9A, 0xAB, 0xCB, 0x96, 0xAA, 0xE8)
ASF_GUID(ASF_Audio_Media,                        0xF8699E40, 0x5B4D, 0x11CF, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B)
ASF_GUID(ASF_Video_Media,                        0xBC19EFC0, 0x5B4D, 0x11CF, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B)
ASF_GUID(ASF_Command_Media,                      0x59DACFC0, 0x59E6, 0x11D0, 0xA3, 0xAC, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6)
ASF_GUID(ASF_No_Error_Correction,                0x20FB5700, 0x5B55, 0x11CF, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B)
ASF_GUID(ASF_Audio_Spread,                       0xBFC3CD50, 0x618F, 0x11CF, 0x8B, 0xB2, 0x00, 0xAA, 0x00, 0xB4, 0xE2, 0x20)
ASF_GUID(ASF_Mutex_Bitrate,                      0xD6E22A01, 0x35DA, 0x11D1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE)
ASF_GUID(ASF_Mutex_Unknown,                      0xD6E22A02, 0x35DA, 0x11D1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE)
ASF_GUID(ASF_Packet_Clock_1,                     0xABD3D211, 0xA9BA, 0x11cf, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\fileio.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fileio.c
 *  Content:    Multi-streamed file read utility
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <assert.h>

#include "fileio.h"
#include "xmvtool.h"

#define FILE_MAPPING_GRANULARITY    (64 * 1024)
#define FILE_WINDOW_SIZE            (2 * FILE_MAPPING_GRANULARITY)

/*
 * Opens the file, initializing the media file structure plus an initial 
 * stream.
 */

void OpenMediaFile
(
    MediaFile *pFile, 
    char *szFile
)
{
    // Make sure everything is initialized correctly.
    assert(!pFile->Initialized);

    pFile->hFile        = INVALID_HANDLE_VALUE;
    pFile->hFileMapping = NULL;
    pFile->pFileBase    = NULL;
    pFile->FileLength   = 0;
    pFile->RangeStart   = 0;
    pFile->RangeEnd     = 0;

    pFile->Initialized  = TRUE;
    
    // Open the file.
    pFile->hFile = CreateFileA(szFile, 
                               GENERIC_READ, 
                               FILE_SHARE_READ, 
                               NULL, 
                               OPEN_EXISTING, 
                               FILE_FLAG_NO_BUFFERING, 
                               NULL);

    if (pFile->hFile == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "ERROR: Unable to open input file '%s'.\n", szFile);

        // Does not return.
        Done();
    }

    // Remember the file's size.
    if (!GetFileSizeEx(pFile->hFile, (LARGE_INTEGER *)&pFile->FileLength))
    {
        fprintf(stderr, "ERROR: Unable to read the input file's size.\n");

        // Does not return.
        Done();
    }

    // Create the mapping.
    pFile->hFileMapping = CreateFileMapping(pFile->hFile, 
                                            NULL,
                                            PAGE_READONLY,
                                            0,
                                            0,
                                            NULL);

    if (!pFile->hFileMapping)
    {
        fprintf(stderr, "ERROR: Unable to open input file '%s'.\n", szFile);

        // Does not return.
        Done();
    }
}

/*
 * Closes a file.  All streams are closed as well.
 */

void CloseMediaFile
(
    MediaFile *pFile
)
{
    if (pFile->Initialized)
    {
        if (pFile->pFileBase)
        {
            UnmapViewOfFile(pFile->pFileBase);
            pFile->pFileBase = NULL;
        }

        if (pFile->hFileMapping)
        {
            CloseHandle(pFile->hFileMapping);
            pFile->hFileMapping = NULL;
        }

        if (pFile->hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(pFile->hFile);
            pFile->hFile = INVALID_HANDLE_VALUE;
        }
    }
}

/*
 * Opens a stream in a file.
 */

void OpenMediaStream
(
    MediaFile *pFile, 
    MediaStream *pStream
)
{
    pStream->pFile  = pFile;
    pStream->Offset = 0;
}

/*
 * Returns the size of the file.
 */

LONGLONG GetMediaSize
(
    MediaStream *pStream
)
{
    return pStream->pFile->FileLength;
}

/*
 * Returns the stream's position in the file.
 */

LONGLONG GetStreamPosition
(
    MediaStream *pStream
)
{
    return pStream->Offset;
}


/*
 * Reset a stream back to the beginning of the file.
 */

void ResetMediaStream
(
    MediaStream *pStream
)
{
    pStream->Offset = 0;
}

/*
 * Clones the state of one stream into another.
 */

void CloneMediaStream
(
    MediaStream *pSource, 
    MediaStream *pDest
)
{
    memcpy(pDest, pSource, sizeof(MediaStream));
}

/*
 * Reads data out of a stream.  This pointer is only valid until the next
 * read.
 */

void *ReadStream
(
    MediaStream *pStream, 
    DWORD Size
)
{
    LONGLONG OffsetStart, OffsetEnd, NewStart;
    DWORD WindowSize;
    MediaFile *pFile;

    // We need to save 4K for alignment issues.
    assert(Size <= FILE_MAPPING_GRANULARITY);

    pFile = pStream->pFile;

    OffsetStart = pStream->Offset;
    OffsetEnd   = OffsetStart + Size;

    if (OffsetEnd > pFile->FileLength)
    {
        fprintf(stderr, "ERROR: Attempted to read beyond the end of the input file.\n");

        // Never returns.
        Done();
    }

    // If this part of the file is not mapped in, grab it.
    if (OffsetStart < pFile->RangeStart || OffsetEnd > pFile->RangeEnd)
    {
        // Destroy the current mapping.
        if (pFile->pFileBase)
        {
            UnmapViewOfFile(pFile->pFileBase);
            pFile->pFileBase = NULL;
        }

        // Create a new one on a 4k boundary in the file.
        NewStart = OffsetStart & ~(FILE_MAPPING_GRANULARITY - 1);

        if (NewStart + FILE_WINDOW_SIZE > pFile->FileLength)
        {
            WindowSize = (DWORD)(pFile->FileLength - NewStart);
        }
        else
        {
            WindowSize = FILE_WINDOW_SIZE;
        }

        pFile->pFileBase = (BYTE *)MapViewOfFile(pFile->hFileMapping,
                                                 FILE_MAP_READ,
                                                 (DWORD)(NewStart >> 32),
                                                 (DWORD)NewStart,
                                                 WindowSize);

        if (!pFile->pFileBase)
        {
            fprintf(stderr, "ERROR: Unable to read the input file (%d).\n", GetLastError());

            // Does not return.
            Done();
        }
        
        pFile->RangeStart = NewStart;
        pFile->RangeEnd   = NewStart + FILE_WINDOW_SIZE;
    }

    // Remember what we read.
    pStream->Offset = OffsetEnd;

    // Return the pointer.
    return pFile->pFileBase + (OffsetStart - pFile->RangeStart);
}

/*
 * Skips data in the stream.
 */

void SkipStreamData
(
    MediaStream *pStream, 
    LONGLONG Size
)
{
    pStream->Offset += Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\fileio.h ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fileio.h
 *  Content:    Multi-streamed file read utility
 *
 ****************************************************************************/

#define FILE_MAPPING_GRANULARITY    (64 * 1024)
#define FILE_WINDOW_SIZE            (2 * FILE_MAPPING_GRANULARITY)

/*
 * It's kinda weird that we need such a complicated file-io process for what
 * amounts to a silly little tool but we ultimately need to be able to read
 * multiple streams through a file or even the same stream multiple times.
 * We do all this complication here to avoid having to do any of this on the 
 * Xbox when all it wants to do is play a movie.
 *
 * This may not be the optimal way of doing this but should work for now.
 */

typedef struct _MediaFile MediaFile;

/*
 * A stream in the file.  Must be caller-allocated but does not need to be
 * zero-initialized.
 */

typedef struct _MediaStream
{
    // The containing file.
    MediaFile *pFile;

    // The current offset of this stream in the file, from the first byte of
    // the file.
    //
    LONGLONG Offset;
}
MediaStream;

/*
 * The main structure for a file.  This must be allocatedby the caller.  
 * Closing this file closes all streams.
 */ 

typedef struct _MediaFile
{
    // Only used so this structure can be zero-initialized.
    BOOL Initialized;

    // The file information.
    HANDLE hFile;
    HANDLE hFileMapping;
    BYTE  *pFileBase;

    LONGLONG FileLength;

    // The range of the file mapped in.
    LONGLONG RangeStart;
    LONGLONG RangeEnd;
}
MediaFile;

/*
 * APIs.  All of these methods call "Done()" if there is an error.
 */

// Opens the file, initializing the media file structure plus an initial 
// stream.
//
void OpenMediaFile(MediaFile *pFile, char *szFile);

// Closes a file.  All streams are closed as well.
void CloseMediaFile(MediaFile *pFile);

// Opens a stream in a file.
void OpenMediaStream(MediaFile *pFile, MediaStream *pStream);

// Returns the size of the file.
LONGLONG GetMediaSize(MediaStream *pStream);

// Returns the stream's position in the file.
LONGLONG GetStreamPosition(MediaStream *pStream);

// Reset a stream back to the beginning of the file.
void ResetMediaStream(MediaStream *pStream);

// Clones the state of one stream into another.
void CloneMediaStream(MediaStream *pSource, MediaStream *pDest);

// Reads data out of a stream.  This pointer is only valid until the next 
// read.
//
void *ReadStream(MediaStream *pStream, DWORD Size);

// Skips data in the stream.
void SkipStreamData(MediaStream *pStream, LONGLONG Size);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, 100, 100, 0xbbbbff);
    
    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(215, 220, 210, 40, 0x000080);
        
        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\asfparser.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       asfparser.c
 *  Content:    ASF file parser
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "fileio.h"
#include "xmvtool.h"

// The default packet size of the ASF file.
static DWORD g_DefaultPacketSize;

/*
 * Structures
 */

/* 
 * File structures...helpers to more easily parse the file
 */

#pragma pack(push, 1)

//
// Base object structure, all objects start with these two fields
// 

typedef struct _BaseObject
{
    GUID     ID;
    LONGLONG Size;
} 
BaseObject;

// 
// ASF header object structures.  
//

typedef struct _HeaderObject
{
    DWORD SubObjectCount;
    BYTE  Reserved1;
    BYTE  Reserved2;
}
HeaderObject;

typedef struct _FilePropertiesObject
{
    GUID     FileID;
    LONGLONG FileSize;
    LONGLONG CreationDate;
    LONGLONG DataPacketsCount;
    LONGLONG PlayDuration;
    LONGLONG SendDuration;
    LONGLONG Preroll;
    DWORD    Flags;
    DWORD    MinimumDataPacketSize;
    DWORD    MaximumDataPacketSize;
    DWORD    MaximumBitrate;
}
FilePropertiesObject;

typedef struct _StreamPropertiesObject
{
    GUID     StreamType;
    GUID     ErrorCorrectionType;
    LONGLONG TimeOffset;
    DWORD    TypeSpecificDataLength;
    DWORD    ErrorCorrectionDataLength;
    WORD     Flags;
    DWORD    Reserved;
}
StreamPropertiesObject;

typedef struct _VideoMediaData
{
    DWORD    EncodedImageWidth;
    DWORD    EncodedImageHeight;
    BYTE     Reserved;
    WORD     FormatDataSize;
}
VideoMediaData;

typedef struct _VideoFormatData
{
    DWORD    FormatDataSize;
    LONG     ImageWidth;
    LONG     ImageHeight;
    WORD     Reserved;
    WORD     BitsPerPixel;
    DWORD    CompressionID;
    DWORD    ImageSize;
    LONG     HorizontalPixelsPerMeter;
    LONG     VerticalPixelsPerMeter;
    DWORD    ColorsUsed;
    DWORD    ImportantColors;
}
VideoFormatData;

typedef struct _WMV2VideoFormatData
{
    DWORD    Unused:7;
    DWORD    SliceCode:3;  // Slice size.
    DWORD    DCTTableSwitchingEnabled:1;
    DWORD    HybridMotionVectorEnabled:1;
    DWORD    XIntra8IPictureCodingEnabled:1;
    DWORD    VariableSizedTransformEnabled:1;
    DWORD    LoopFilterEnabled:1; 
    DWORD    MixedPelMotionCompensationEnable:1; 
    DWORD    BitRate:11;
    DWORD    FrameRate:5;
} 
WMV2VideoFormatData;

typedef struct _AudioMediaData
{
    WORD     CodecID;
    WORD     ChannelCount;
    DWORD    SamplesPerSecond;
    DWORD    AveBytesPerSecond;
    WORD     BlockAlignment;
    WORD     BitsPerSample;
    WORD     CodecDataSize;
}
AudioMediaData;

typedef struct _SpreadAudioData
{
    BYTE     Span;
    WORD     VirtualPacketLength;
    WORD     VirtualChunkLength;
    WORD     SilenceDataLength;
}
SpreadAudioData;

typedef struct _ClockObject
{
    GUID     ClockType;
    WORD     ClockSize;
    DWORD    Reserved;
}
ClockObject;

typedef struct _CodecListObject
{
    GUID     Reserved;
    DWORD    EntryCount;
}
CodecListObject;

typedef struct _ScriptCommandObject
{
    GUID     Reserved;
    WORD     CommandCount;
    WORD     CommandTypeCount;
}
ScriptCommandObject;

typedef struct _ScriptCommandData
{
    DWORD    PresentationTime;
    WORD     TypeIndex;
    WORD     CommandNameLength;
}
ScriptCommandData;

typedef struct _MarkerObject
{
    GUID     Reserved;
    DWORD    MarkerCount;
    WORD     Reserved2;
    WORD     NameLength;
}
MarkerObject;

typedef struct _MarkerData
{
    LONGLONG Offset;
    LONGLONG PresentationTime;
    WORD     EntryLength;
    DWORD    SendTime;
    DWORD    Flags;
    DWORD    MarkerDescriptionLength;
}
MarkerData;

typedef struct _BitrateExclusionObject
{
    GUID     ExclusionType;
    WORD     StreamNumbersCount;
}
BitrateExclusionObject;

typedef struct _ErrorCorrectionObject
{
    GUID     ErrorCorrectionType;
    DWORD    DataLength;
}
ErrorCorrectionObject;

typedef struct ContentDescriptionObject
{
    WORD     TitleLength;
    WORD     AuthorLength;
    WORD     CopyrightLength;
    WORD     DescriptionLength;
    WORD     RatingLength;
}
ContentDescriptionObject;

typedef struct _StreamBitrateObject
{
    WORD     RecordCount;
}
StreamBitrateObject;

typedef struct _StreamBitrateData
{
    WORD     Flags;
    DWORD    AverageBitrate;
}
StreamBitrateData;

//
// ASF Data object structures
//

typedef struct _DataObject
{
    GUID     FileID;
    LONGLONG PacketCount;
    WORD     Reserved;
}
DataObject;

typedef struct _PayloadParsingInfo
{
    BYTE     LengthTypeFlags;
    BYTE     PropertyFlags;
}
PayloadParsingInfo;

typedef struct _PayloadParsingInfoField
{
    BYTE     MultiplePayloads:1;
    BYTE     SequenceType:2;
    BYTE     PaddingLengthType:2;
    BYTE     PacketLengthType:2;
    BYTE     ErrorCorrectionPresent:1;

    BYTE     ReplicatedDataLengthType:2;
    BYTE     OffsetIntoMediaObjectLengthType:2;
    BYTE     MediaObjectNumberLengthType:2;
    BYTE     StreamNumberLengthType:2;
}
PayloadParsingInfoField;

//
// ASF Index object structures.
//

typedef struct _IndexObject
{

    GUID     FileID;
    LONGLONG IndexEntryTimeInterval;
    DWORD    MaximumPacketCount;
    DWORD    IndexEntryCount;
}
IndexObject;

typedef struct _IndexData
{
    DWORD    PacketNumber;
    WORD     PacketCount;
}
IndexData;

#pragma pack(pop)

//
// Manages the information needed to walk over an individual stream.
//

typedef struct _StreamIterator
{
    // The stream we're using to read.
    MediaStream Stream;

    // Total number of remaining packets.
    LONGLONG PacketCount;

    BYTE *pPacketStart;

    DWORD PacketLength;
    DWORD PaddingLength;

    PayloadParsingInfoField PayloadInfo;

    DWORD PayloadDataLengthType;
    DWORD PayloadDataAndHeaderLength;
    DWORD PayloadStream;

    DWORD PayloadCount;

    DWORD CompressedPayloadRemainingData;
    DWORD PresentationTimeDelta;

    // Not sure what we're doing this this stuff...save it for now but it may
    // get evicted from this object.
    //
    DWORD MediaObjectNumber;
    DWORD OffsetIntoMediaObject;
    DWORD ReplicatedDataLength;
    DWORD ObjectSize;
    DWORD ObjectPres;
}
StreamIterator;

//
// Basic data structure we use to walk over the file
//

typedef struct _AsfFile
{
    // The default size of a packet.
    DWORD DefaultPacketSize;

    // Helpers to iterate over all of the streams.
    StreamIterator Streams[0];
}
AsfFile;

//
// Hold the information about one payload.
//

typedef struct _AsfPayload
{
    BYTE *pData;
    DWORD Size;

    DWORD MediaObjectNumber;
    DWORD OffsetIntoMediaObject;
    DWORD ObjectSize;
    DWORD ObjectPres;
}
AsfPayload;

/*
 * GUID tables
 */

#define ASF_GUID(n, a, b, c, d, e, f, g, h, i, j, k) n,

typedef enum _ASF_ID
{
    #include "asfguids.h"

    ASF_MAX
} 
ASF_GUID_ID;

#undef ASF_GUID

#define ASF_GUID(n, a, b, c, d, e, f, g, h, i, j, k) { a, b, c, { d, e, f, g, h, i, j, k } },

static GUID g_ASF_GUIDs[][4] = 
{
    #include "asfguids.h"
};

#undef ASF_GUID

/* 
 * Converts a guid to an ASF_ index which is much easier to deal with.
 */

static
DWORD IndexOfGUID
(
    GUID *pGUID
)
{
    DWORD i;
    
    // A table of constant guids...this is screaming for some type
    // of hash lookup.
    //
    for (i = 0; i < ASF_MAX; i++)
    {
        if (!memcmp(pGUID, g_ASF_GUIDs[i], sizeof(GUID)))
        {
            break;
        }
    }

    return i;
}

/*
 * Read a byte
 */

static
BYTE ReadByte
(
    MediaStream *pStream
)
{
    return *(BYTE *)ReadStream(pStream, 1);
}

/* 
 * Read a word
 */

static
WORD ReadWord
(
    MediaStream *pStream
)
{
    return *(WORD *)ReadStream(pStream, 2);
}

/*
 * Read a dword
 */

static
DWORD ReadDword
(
    MediaStream *pStream
)
{
    return *(DWORD *)ReadStream(pStream, 4);
}

/*
 * Read a variable-size field.
 */

#define SIZE_NONE       0
#define SIZE_BYTE       1
#define SIZE_WORD       2
#define SIZE_DWORD      3

static
DWORD ReadVariableField
(
    MediaStream *pStream,
    DWORD Size
)
{
    switch(Size)
    {
    default:
    case SIZE_NONE:

        return 0;

    case SIZE_BYTE:

        return *(BYTE *)ReadStream(pStream, 1);

    case SIZE_WORD:

        return *(WORD *)ReadStream(pStream, 2);

    case SIZE_DWORD:

        return *(DWORD *)ReadStream(pStream, 4);

    };
}

/*
 * Check the file to see if it's one of us.
 */

BOOL AsfCheckFormat
(
   MediaFile *pMediaFile
)
{
    MediaStream Stream;
    BaseObject *pObject;
    DWORD       iASF;

    OpenMediaStream(pMediaFile, &Stream);

    // Don't fall off the end.
    if (GetMediaSize(&Stream) < sizeof(BaseObject))
    {
        return FALSE;
    }

    // Read the first object.
    pObject = (BaseObject *)ReadStream(&Stream, sizeof(BaseObject));
    iASF = IndexOfGUID(&pObject->ID);

    return iASF == ASF_Header_Object;
}

/*
 * Process the header object.
 */

void *AsfOpenMedia
(
    MediaFile *pMediaFile,
    FileContents *ContentsArray
)
{
    MediaStream              Stream;
    AsfFile                 *pFile;

    BaseObject              *pObject;
    HeaderObject            *pHeader;
    FilePropertiesObject    *pFileProperties;
    StreamPropertiesObject  *pStreamProperties;
    DataObject              *pDataObject;
    VideoFormatData         *pVideoFormat;
    VideoMediaData          *pVideoMedia;
    DWORD                   *pWMV2VideoFormatRaw;
    WMV2VideoFormatData      WMV2VideoFormat;
    AudioMediaData          *pAudioMedia;

    LONGLONG HeaderObjectSize;
    LONGLONG ObjectSize;
    LONGLONG InitialOffset;

    DWORD SubObjectCount;
    DWORD iASF, iType, iError, i;
    DWORD DefaultPacketSize;
    DWORD StreamNumber = 0;

    DWORD ErrorLength;
    DWORD FormatDataSize;
    LONGLONG PacketCount;

    //
    // Read the header object.
    //

    // Go back to the beginning.
    OpenMediaStream(pMediaFile, &Stream);

    pObject = (BaseObject *)ReadStream(&Stream, sizeof(BaseObject));

    HeaderObjectSize = pObject->Size;
    iASF = IndexOfGUID(&pObject->ID);
    
    if (iASF != ASF_Header_Object)
    {
        fprintf(stderr, "ERROR: Invalid input file format; file is not a valid ASF file.\n");

        // Does not return.
        Done();
    }

    pHeader = (HeaderObject*)ReadStream(&Stream, sizeof(HeaderObject));

    SubObjectCount = pHeader->SubObjectCount;

    //
    // Load the sub objects.
    //

    while (SubObjectCount--)
    {
        InitialOffset = GetStreamPosition(&Stream);

        pObject = (BaseObject *)ReadStream(&Stream, sizeof(BaseObject));
        
        iASF = IndexOfGUID(&pObject->ID);
        ObjectSize = pObject->Size;

        switch(iASF)
        {
        default:
            SkipStreamData(&Stream, pObject->Size - sizeof(BaseObject));
            break;

        case ASF_File_Properties_Object:

            pFileProperties = (FilePropertiesObject *)ReadStream(&Stream, sizeof(FilePropertiesObject));

            DefaultPacketSize = pFileProperties->MaximumDataPacketSize;

            break;

        case ASF_Stream_Properties_Object:

            pStreamProperties = (StreamPropertiesObject *)ReadStream(&Stream, sizeof(StreamPropertiesObject));

            // Streams start at one, there is no stream zero.
            StreamNumber++;

            iType  = IndexOfGUID(&pStreamProperties->StreamType);
            iError = IndexOfGUID(&pStreamProperties->ErrorCorrectionType);

            ErrorLength = pStreamProperties->ErrorCorrectionDataLength;

            switch(iType)
            {
            default:
            case ASF_Command_Media:

                SkipStreamData(&Stream, pStreamProperties->TypeSpecificDataLength);
                break;

            case ASF_Video_Media:

                pVideoMedia = (VideoMediaData *)ReadStream(&Stream, sizeof(VideoMediaData));

                ContentsArray[StreamNumber].StreamType = STREAM_VIDEO;
                ContentsArray[StreamNumber].VideoStream.Width  = pVideoMedia->EncodedImageWidth;
                ContentsArray[StreamNumber].VideoStream.Height = pVideoMedia->EncodedImageHeight;

                FormatDataSize = pVideoMedia->FormatDataSize;

                pVideoFormat = (VideoFormatData *)ReadStream(&Stream, sizeof(VideoFormatData));

                ContentsArray[StreamNumber].VideoStream.CompressionID = pVideoFormat->CompressionID;

                if (ContentsArray[StreamNumber].VideoStream.CompressionID == '2VMW')
                {
                    // Is this always true?
                    assert(FormatDataSize - sizeof(VideoFormatData) == sizeof(WMV2VideoFormatData));

                    // We need to swap the bytes of the format code.
                    pWMV2VideoFormatRaw = (DWORD *)ReadStream(&Stream, sizeof(DWORD));
                    
                    *(DWORD *)&WMV2VideoFormat =   ((*pWMV2VideoFormatRaw & 0x000000FF) << 24)
                                                 | ((*pWMV2VideoFormatRaw & 0x0000FF00) << 8)
                                                 | ((*pWMV2VideoFormatRaw & 0x00FF0000) >> 8)
                                                 | ((*pWMV2VideoFormatRaw & 0xFF000000) >> 24);

                    ContentsArray[StreamNumber].VideoStream.FramesPerSecond                  = WMV2VideoFormat.FrameRate;
                    ContentsArray[StreamNumber].VideoStream.Slices                           = WMV2VideoFormat.SliceCode;
                    ContentsArray[StreamNumber].VideoStream.MixedPelMotionCompensationEnable = (BOOLEAN)WMV2VideoFormat.MixedPelMotionCompensationEnable; 
                    ContentsArray[StreamNumber].VideoStream.LoopFilterEnabled                = (BOOLEAN)WMV2VideoFormat.LoopFilterEnabled;
                    ContentsArray[StreamNumber].VideoStream.VariableSizedTransformEnabled    = (BOOLEAN)WMV2VideoFormat.VariableSizedTransformEnabled;
                    ContentsArray[StreamNumber].VideoStream.XIntra8IPictureCodingEnabled     = (BOOLEAN)WMV2VideoFormat.XIntra8IPictureCodingEnabled;
                    ContentsArray[StreamNumber].VideoStream.HybridMotionVectorEnabled        = (BOOLEAN)WMV2VideoFormat.HybridMotionVectorEnabled;
                    ContentsArray[StreamNumber].VideoStream.DCTTableSwitchingEnabled         = (BOOLEAN)WMV2VideoFormat.DCTTableSwitchingEnabled;
                }
                else
                {
                    SkipStreamData(&Stream, FormatDataSize - sizeof(VideoFormatData));
                }

                break;

            case ASF_Audio_Media:

                pAudioMedia = (AudioMediaData *)ReadStream(&Stream, sizeof(AudioMediaData));

                ContentsArray[StreamNumber].StreamType = STREAM_AUDIO;

                ContentsArray[StreamNumber].AudioStream.WaveFormat       = pAudioMedia->CodecID;
                ContentsArray[StreamNumber].AudioStream.ChannelCount     = pAudioMedia->ChannelCount;
                ContentsArray[StreamNumber].AudioStream.SamplesPerSecond = pAudioMedia->SamplesPerSecond;
                ContentsArray[StreamNumber].AudioStream.BitsPerSample    = pAudioMedia->BitsPerSample;

                SkipStreamData(&Stream, pAudioMedia->CodecDataSize);

                break;
            }

            SkipStreamData(&Stream, ErrorLength);

            break;
        }

        assert(GetStreamPosition(&Stream) - InitialOffset == ObjectSize);
    }

    assert(GetStreamPosition(&Stream) == HeaderObjectSize);

    //
    // Load the data header object
    //

    pObject = (BaseObject *)ReadStream(&Stream, sizeof(BaseObject));

    iASF = IndexOfGUID(&pObject->ID);

    if (iASF != ASF_Data_Object)
    {
        fprintf(stderr, "ERROR: Invalid input file format; file is not a valid ASF file.\n");

        // Does not return.
        Done();
    }

    pDataObject = (DataObject *)ReadStream(&Stream, sizeof(DataObject));
    PacketCount = pDataObject->PacketCount;

    //
    // Create the file object.
    //

    pFile = (AsfFile *)malloc(sizeof(AsfFile) + sizeof(StreamIterator) * (StreamNumber + 1));

    if (!pFile)
    {
        fprintf(stderr, "ERROR: Unable to allocate memory.\n");

        // Does not return;
        Done();
    }

    memset(pFile, 0, sizeof(AsfFile) + sizeof(StreamIterator) * (StreamNumber + 1));

    // Fill in the file info.
    pFile->DefaultPacketSize = DefaultPacketSize;

    // Fill in the stream array.
    for (i = 0; i <= StreamNumber; i++)
    {
        CloneMediaStream(&Stream, &pFile->Streams[i].Stream);
        pFile->Streams[i].PacketCount = PacketCount;
    }

    return pFile;
}

/*
 * Destroy the file object.  The file will get closed by the main routine.
 */

void AsfCloseMedia
(
    void *pFile
)
{
    free(pFile);
}

/*
 * Find the next payload for a stream.
 */

DWORD g_Packet;

static
BOOL GetNextPayload
(
    AsfFile *pFile,
    DWORD StreamNumber,
    AsfPayload *pPayload
)
{
    LONGLONG PacketOffset;
    BYTE FirstByte;
    PayloadParsingInfoField PayloadInfo;
    DWORD PayloadDataLength;

    StreamIterator *pIterator;
    MediaStream *pStream;
    
    // Make this more convenient.
    pIterator = &pFile->Streams[StreamNumber];
    pStream = &pIterator->Stream;

    do
    {
        if (!pIterator->PayloadCount)
        {
            SkipStreamData(pStream, pIterator->PaddingLength);
        
            if (!pIterator->PacketCount)
            {
                memset(pPayload, 0, sizeof(AsfPayload));

                return FALSE;
            }

g_Packet++;

            pIterator->PacketCount--;

            // Save the starting spot.
            PacketOffset = GetStreamPosition(pStream);

            // Load the first byte so we can determine if we have an error correction
            // information.
            //
            FirstByte = ReadByte(pStream);

            if (FirstByte & 0x80)
            {
                SkipStreamData(pStream, FirstByte & 0x0F);

                // Load the header for the next packet.
                memcpy(&pIterator->PayloadInfo, ReadStream(pStream, sizeof(PayloadParsingInfoField)), sizeof(PayloadParsingInfoField));
            }
            else
            {
                *((BYTE *)&pIterator->PayloadInfo + 0) = FirstByte;
                *((BYTE *)&pIterator->PayloadInfo + 1) = ReadByte(pStream);
            }

            // Load the rest of the decription field.
            pIterator->PacketLength  = ReadVariableField(pStream, pIterator->PayloadInfo.PacketLengthType);
            (void)ReadVariableField(pStream, pIterator->PayloadInfo.SequenceType);  // Sequence
            pIterator->PaddingLength = ReadVariableField(pStream, pIterator->PayloadInfo.PaddingLengthType);
            (void)ReadDword(pStream);      // send time
            (void)ReadWord(pStream);       // duration

            if (pIterator->PacketLength == 0)
            {
                pIterator->PacketLength = pFile->DefaultPacketSize;
            }

            // A single payload packet.
            if (!pIterator->PayloadInfo.MultiplePayloads)
            {
                pIterator->PayloadCount = 1;
                pIterator->PayloadDataLengthType = SIZE_NONE;

                pIterator->PayloadDataAndHeaderLength = pIterator->PacketLength - (DWORD)(GetStreamPosition(pStream) - PacketOffset) - pIterator->PaddingLength;
            }
            else
            {
                FirstByte = ReadByte(pStream);

                pIterator->PayloadCount = FirstByte & 0x3F;
                pIterator->PayloadDataLengthType = FirstByte >> 6;
                pIterator->PayloadDataAndHeaderLength = 0;
            }
        }

        // Save the current stream pointer.
        PacketOffset = GetStreamPosition(pStream);

        // If we're not in the middle of a compressed payload then get the
        // next header.
        //
        if (!pIterator->CompressedPayloadRemainingData)
        {
            pIterator->PayloadStream         = ReadByte(pStream) & 0x7F;
            pIterator->MediaObjectNumber     = ReadVariableField(pStream, pIterator->PayloadInfo.MediaObjectNumberLengthType);
            pIterator->OffsetIntoMediaObject = ReadVariableField(pStream, pIterator->PayloadInfo.OffsetIntoMediaObjectLengthType);
            pIterator->ReplicatedDataLength  = ReadVariableField(pStream, pIterator->PayloadInfo.ReplicatedDataLengthType);

            pIterator->ObjectSize = 0;

            if (pIterator->ReplicatedDataLength >= 8)
            {
                pIterator->ObjectSize = ReadDword(pStream);
                pIterator->ObjectPres = ReadDword(pStream);

                SkipStreamData(pStream, pIterator->ReplicatedDataLength - 8);
            }
            else if (pIterator->ReplicatedDataLength == 1)
            {
                pIterator->PresentationTimeDelta = ReadByte(pStream);

                // I love how this was documented...
                pIterator->ObjectPres = pIterator->OffsetIntoMediaObject;
                pIterator->OffsetIntoMediaObject = 0;
            }
            else
            {
                SkipStreamData(pStream, pIterator->ReplicatedDataLength);
            }

            // Get the size of the payload.
            if (pIterator->PayloadDataLengthType != SIZE_NONE)
            {
                PayloadDataLength = ReadVariableField(pStream, pIterator->PayloadDataLengthType);
            }
            else
            {
                PayloadDataLength = pIterator->PayloadDataAndHeaderLength - (DWORD)(GetStreamPosition(pStream) - PacketOffset);
            }

            // Remember it if we're doing a compressed payload.
            if (pIterator->ReplicatedDataLength == 1)
            {
                pIterator->CompressedPayloadRemainingData = PayloadDataLength;
            }
        }

        // Compressed payloads have their sizes encoded directly in the data.
        if (pIterator->CompressedPayloadRemainingData)
        {
            PayloadDataLength = ReadByte(pStream);

            // The Subpayload size does not include the 1-byte header.
            pIterator->CompressedPayloadRemainingData -= PayloadDataLength + 1;

            // Use this as the object size as well.
            pIterator->ObjectSize = PayloadDataLength;
        }

        if (!pIterator->CompressedPayloadRemainingData)
        {
            pIterator->PayloadCount--;
        }

        pPayload->pData = (BYTE *)ReadStream(pStream, PayloadDataLength);
        pPayload->Size  = PayloadDataLength;

        pPayload->MediaObjectNumber     = pIterator->MediaObjectNumber;
        pPayload->OffsetIntoMediaObject = pIterator->OffsetIntoMediaObject;
        pPayload->ObjectSize            = pIterator->ObjectSize;
        pPayload->ObjectPres            = pIterator->ObjectPres;

        // Adjust the presentation time for compress payloads.
        if (pIterator->CompressedPayloadRemainingData)
        {
            pIterator->ObjectPres += pIterator->PresentationTimeDelta;
        }
    }
    while (pIterator->PayloadStream != StreamNumber);

    return TRUE;
}

/*
 * Get one video frame from a video stream.
 */

BOOL AsfGetNextVideoFrame
(
    void *pFileHandle, 
    DWORD StreamNumber, 
    BYTE **ppVideoBuffer, 
    BYTE *pVideoBufferMax
)
{
    AsfFile    *pFile;
    AsfPayload  Payload;
  
    DWORD Size;

    pFile = (AsfFile *)pFileHandle;

    if (!GetNextPayload(pFile, StreamNumber, &Payload))
    {
        return FALSE;
    }

    Size = Payload.ObjectSize;

    for (;;)
    {
        assert(Size >= Payload.Size);

        if (*ppVideoBuffer + Payload.Size > pVideoBufferMax)
        {
            fprintf(stderr, "ERROR: The buffer is too small to encode this data, increase its size.\n");
            Done();
        }

        // Copy the data into the buffer.
        memcpy(*ppVideoBuffer, Payload.pData, Payload.Size);

        // Adjust it all.
        *ppVideoBuffer += Payload.Size;
        Size           -= Payload.Size;

        if (!Size)
        {
            break;
        }

        if (!GetNextPayload(pFile, StreamNumber, &Payload))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
 * Get one frame's worth of audio
 */

void AsfGetNextAudioFrame
(   
    void *pFile, 
    DWORD StreamNumber, 
    DWORD FPS, 
    BYTE **ppAudioBuffer, 
    BYTE *pAudioBufferMax
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\xmvtool.h ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xmvtool.h
 *  Content:    XMV conversion utility
 *
 * This utility is currently only used for testing as we're not exactly
 * sure what conversions we want to do yet.
 *
 ****************************************************************************/

// 256 streams per input file should be more than enough.
#define MAX_STREAMS   256

/*
 * Structures
 */

//
// Describes the streams in a file.
//

#define STREAM_EMPTY    0
#define STREAM_VIDEO    1
#define STREAM_AUDIO    2

typedef struct _VideoStream
{
    DWORD   StreamType;

    DWORD   CompressionID;
    DWORD   Width;
    DWORD   Height;

    DWORD   FramesPerSecond;
    DWORD   Slices;

    BOOLEAN MixedPelMotionCompensationEnable; 
    BOOLEAN LoopFilterEnabled; 
    BOOLEAN VariableSizedTransformEnabled;
    BOOLEAN XIntra8IPictureCodingEnabled;
    BOOLEAN HybridMotionVectorEnabled;
    BOOLEAN DCTTableSwitchingEnabled;
}
VideoStream;

typedef struct _AudioStream
{
    DWORD   StreamType;

    DWORD WaveFormat;
    DWORD ChannelCount;
    DWORD SamplesPerSecond;
    DWORD BitsPerSample;
}
AudioStream;

typedef union _FileContents
{
    DWORD           StreamType;
    VideoStream     VideoStream;
    AudioStream     AudioStream;
}
FileContents;

/*
 * The following function prototypes are used to manage a file.
 */

typedef BOOL  (*CheckFormat)(MediaFile *pMediaFile);
typedef void *(*OpenMedia)(MediaFile *pMediaFile, FileContents *ContentsArray);
typedef BOOL  (*GetNextVideoFrame)(void *pFile, DWORD StreamNumber, BYTE **ppVideoBuffer, BYTE *pVideoBufferMax);
typedef void  (*GetNextAudioFrame)(void *pFile, DWORD StreamNumber, DWORD FPS, BYTE **ppAudioBuffer, BYTE *pAudioBufferMax);
typedef void  (*CloseMedia)(void *pFile);

/*
 * Panic method, call for any abnormal exit from the tool.  This method
 * never returns.
 */

void Done();

/*
 * ASF parser methods.
 */

BOOL  AsfCheckFormat(MediaFile *pMediaFile);
void *AsfOpenMedia(MediaFile *pMediaFile, FileContents *ContentsArray);
BOOL  AsfGetNextVideoFrame(void *pFile, DWORD StreamNumber, BYTE **ppVideoBuffer, BYTE *pVideoBufferMax);
void  AsfGetNextAudioFrame(void *pFile, DWORD StreamNumber, DWORD FPS, BYTE **ppAudioBuffer, BYTE *pAudioBufferMax);
void  AsfCloseMedia(void *pFile);

/*
 * XMV parser methods.
 */

BOOL  XmvCheckFormat(MediaFile *pMediaFile);
void *XmvOpenMedia(MediaFile *pMediaFile, FileContents *ContentsArray);
BOOL  XmvGetNextVideoFrame(void *pFile, DWORD StreamNumber, BYTE **ppVideoBuffer, BYTE *pVideoBufferMax);
void  XmvGetNextAudioFrame(void *pFile, DWORD StreamNumber, DWORD FPS, BYTE **ppAudioBuffer, BYTE *pAudioBufferMax);
void  XmvCloseMedia(void *pFile);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\xmvtool.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xmvtool.c
 *  Content:    XMV conversion utility
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <setjmp.h>
#include <xboxverp.h>

#include "..\inc\xmvformat.h"

#include "fileio.h"
#include "xmvtool.h"

/*
 * Parsed versions of the command-line parameters.
 */

#define COMMAND_INFO    1
#define COMMAND_CONVERT 2

DWORD g_Command;
char *g_szInputFile;
char *g_szOutputFile;

DWORD g_OutputBufferSize = 128 * 1024;

/*
 * Globals
 */

// The following array maps from the stream number in the output file
// to the method and stream number we need to use to get the stream data.
//
struct _StreamMap
{
    GetNextVideoFrame pfnGetNextVideoFrame;
    void *pFileHandle;
    DWORD VideoStream;

    VideoStream *pVideoStreamInfo;

    struct _AudioMap
    {
        GetNextAudioFrame pfnGetNextAudioFrame;
        void *pFileHandle;
        DWORD AudioStream;

        AudioStream *pAudioStreamInfo;
    }
    AudioMap[MAX_STREAMS];
}
g_StreamMap;

// Describes an input file.
#define FILEDESC_UNKNOWN    0
#define FILEDESC_ASF        1
#define FILEDESC_XMV        2

typedef struct _InputFile
{
    DWORD FileType;

    void *pFile;

    OpenMedia         pfnOpenMedia;
    GetNextVideoFrame pfnGetNextVideoFrame;
    GetNextAudioFrame pfnGetNextAudioFrame;
    CloseMedia        pfnCloseMedia;
}
InputFile;

MediaFile g_InputFile;
InputFile g_InputFileDesc;

HANDLE  g_hOutputFile = INVALID_HANDLE_VALUE;

// We use setjmp/longjump to avoid having to manually unwind
// the stack when we get an error or finish processing the file.  This
// works fine because we never store anything that needs to be destroyed
// in local variables so no function in this file has any cleanup code
// except in the main routine after the setjmp.

jmp_buf g_Done;

// Memory allocations for the stream buffer arrays and the actual
// stream buffers themselves.
//
void *g_pStreamBufferArrays;
void *g_pStreamBuffers;

/*
 * We jump out of here whenever anything bad happens to avoid having
 * to manually unwind the stack.
 */

void Done()
{
    longjmp(g_Done, -1);
}

/* 
 * Displays the usage for this tool. 
 */ 

void Usage()
{
    fprintf(stderr,
            "\nxmvtool version " VER_PRODUCTVERSION_STR "\n\n"
            "Usage: xmvtool <command> <parameters>\n\n"
            "    xmvtool info <input file> - dump information about the input file\n\n"
            "    xmvtool convert [options] <input file> <output file>\n\n"
            "        /b <size>  set the size of the decoder's input buffer, in Kilobytes (512 max, multiple of 4)\n"
            "\n");
}

/*
 * Parse the command line and initialize all of the option global variables.
 */

// All this stuff is temporary until I decide exactly how to handle the nasty
// command lines we're going to use.
//
BOOL ParseCommandLine
(
    int argc, 
    char **argv
)
{
    int i;
    DWORD BufferSize;

    if (argc < 2)
    {
        return FALSE;
    }

    // The first option must be a command...
    if (!_stricmp(argv[1], "info"))
    {
        g_Command = COMMAND_INFO;

        if (argc != 3)
        {
            return FALSE;
        }

        g_szInputFile = argv[2];
    }
    else if (!strcmp(argv[1], "convert"))
    {
        g_Command = COMMAND_CONVERT;

        i = 2;

        if (argc == 6)
        {
            if (!_stricmp(argv[2], "/b") || !_stricmp(argv[2], "-b"))
            {
                BufferSize = atol(argv[3]);

                if (BufferSize == 0 || BufferSize > 512 || BufferSize % 4)
                {
                    return FALSE;
                }

                g_OutputBufferSize = BufferSize * 1024;
            }

            i = 4;
        }

        if (argc - i != 2)
        {
            return FALSE;
        }

        g_szInputFile = argv[i];
        g_szOutputFile = argv[i + 1];
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

/*
 * Open the files and prepares for reading.
 */

void OpenFiles()
{
    //
    // Open the input file.
    //

    OpenMediaFile(&g_InputFile, g_szInputFile);

    if (AsfCheckFormat(&g_InputFile))
    {
        g_InputFileDesc.FileType             = FILEDESC_ASF;
        g_InputFileDesc.pfnOpenMedia         = AsfOpenMedia;
        g_InputFileDesc.pfnGetNextVideoFrame = AsfGetNextVideoFrame;
        g_InputFileDesc.pfnGetNextAudioFrame = AsfGetNextAudioFrame;
        g_InputFileDesc.pfnCloseMedia        = AsfCloseMedia;
    }
    else if (XmvCheckFormat(&g_InputFile))
    {
        g_InputFileDesc.FileType             = FILEDESC_XMV;
        g_InputFileDesc.pfnOpenMedia         = XmvOpenMedia;
        g_InputFileDesc.pfnGetNextVideoFrame = XmvGetNextVideoFrame;
        g_InputFileDesc.pfnGetNextAudioFrame = XmvGetNextAudioFrame;
        g_InputFileDesc.pfnCloseMedia        = XmvCloseMedia;
    }
    else
    {
        g_InputFileDesc.FileType = FILEDESC_UNKNOWN;
    }

    // Make sure this is an ASF file.
    if (g_InputFileDesc.FileType == FILEDESC_UNKNOWN)
    {
        fprintf(stderr, "ERROR: Unknown media type\n");
        Done();
    }

    //
    // Open the output file.
    //

    if (g_szOutputFile)
    {
        // Open the file.
        g_hOutputFile = CreateFileA(g_szOutputFile, 
                                    GENERIC_WRITE, 
                                    0, 
                                    NULL, 
                                    CREATE_ALWAYS, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);

        if (g_hOutputFile == INVALID_HANDLE_VALUE)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open ouput file '%s'.\n", 
                    g_szOutputFile);

            // Does not return.
            Done();
        }
    }
}

/*
 * Dump the information about the input file
 */

void Info()
{
    FileContents ContentsArray[MAX_STREAMS];
    DWORD i;

    // Get the file information.
    memset(ContentsArray, 0, sizeof(ContentsArray));

    g_InputFileDesc.pFile = g_InputFileDesc.pfnOpenMedia(&g_InputFile, ContentsArray);

    if (g_InputFileDesc.FileType == FILEDESC_ASF)
    {
        printf("%s - Asf File:\n\n", g_szInputFile);
    }
    else
    {
        printf("%s - Xmv File:\n\n", g_szInputFile);
    }

    // Dump it.
    for (i = 0; i < MAX_STREAMS; i++)
    {
        if (ContentsArray[i].StreamType == STREAM_VIDEO)
        {
            printf("    ---- Stream        : %d\n", i);
            printf("    Compresssion ID    : %c%c%c%c\n", ContentsArray[i].VideoStream.CompressionID, ContentsArray[i].VideoStream.CompressionID >> 8, ContentsArray[i].VideoStream.CompressionID >> 16, ContentsArray[i].VideoStream.CompressionID >> 24);
            printf("    Frames per second  : %d\n", ContentsArray[i].VideoStream.FramesPerSecond);
            printf("    Width              : %d\n", ContentsArray[i].VideoStream.Width);
            printf("    Height             : %d\n\n", ContentsArray[i].VideoStream.Height);
        }
        else if (ContentsArray[i].StreamType == STREAM_AUDIO)
        {
            printf("    ---- Stream        : %d\n", i);
            printf("    Wave Format        : %X\n", ContentsArray[i].AudioStream.WaveFormat);
            printf("    Channel count      : %d\n", ContentsArray[i].AudioStream.ChannelCount);
            printf("    Samples Per Second : %d\n", ContentsArray[i].AudioStream.SamplesPerSecond);
            printf("    Bits Per Sample    : %d\n\n", ContentsArray[i].AudioStream.BitsPerSample);
        }
    }
}

/*
 * Process each frame, pack them into a buffer and write to disk.
 *
 * A video packet gets built through the following process:
 *
 *  1) The video and audio data for a single frame get collected and stored
 *     in the appropriate video/audio stream staging buffers.  These buffers
 *     are considerably oversized.
 *
 *  2) We calculate whether the current video packet would overflow the
 *    output buffer size if this frame were included.  If not, then we
 *     move on to step 1 for the next frame.
 *
 *  3) If there is an existing pending packet then it gets flushed to disk
 *     (step 5) and the current staging buffers become pending.
 *
 *  4) The next video packet is assembled.
 *
 *  5) Update the size of the next video packet in this one and write it
 *     to disk.
 *
 * To do this, we need two buffers for the video stream and each audio
 * stream.  The video and audio streams need to be oversized to handle
 * storing audio/video data until we figure out whether it actually fits
 * in this packet...otherwise there is a chance that the buffer could
 * overflow.
 *
 */

void ProcessFrames
(
    DWORD VideoStreamCount,
    DWORD AudioStreamCount
)
{
    BYTE *pVideoBufferHeaderNext;

    XMVPacketHeader      *pPacketHeader;
    XMVPacketHeader      *pPendingPacketHeader;
    XMVVideoDataHeader   *pVideoDataHeader;
    XMVAudioDataHeader   *pAudioDataHeader;
    XMVVideoPacketHeader *pVideoPacketHeader;
    XMVVideoPacketHeader *pPendingVideoPacketHeader;

    DWORD CurrentPacketSize;
    DWORD PotentialPacketSize;
    DWORD PaddedCurrentPacketSize;

    DWORD VideoBufferSize;
    DWORD AudioBufferSize;
    DWORD PendingVideoBufferSize;
    DWORD PendingVideoPaddingSize;

    DWORD iStream, Size, Written;
    BYTE *pb;

    BYTE *pVideoBufferStart;
    BYTE *pVideoBufferPending;
    BYTE *pVideoBufferPrevious;
    BYTE *pVideoBufferCurrent;
    BYTE *pVideoBufferSwap;

    BYTE **pAudioBufferStart;
    BYTE **pAudioBufferPending;
    BYTE **pAudioBufferPrevious;
    BYTE **pAudioBufferCurrent;
    BYTE **pAudioBufferSwap;

    DWORD FrameCount;
    DWORD ThisFrameSize;
    DWORD StreamCount;
    DWORD OutputBufferWriteCount;
    DWORD FramesPerSecond;
    DWORD PaddingSize;

    ThisFrameSize = 0;
    OutputBufferWriteCount = 0;
    VideoBufferSize = 0;
    AudioBufferSize = 0;

    StreamCount = VideoStreamCount + AudioStreamCount;

    if (!VideoStreamCount)
    {
        FramesPerSecond = 30;
    }
    else
    {
        FramesPerSecond = g_StreamMap.pVideoStreamInfo->FramesPerSecond;
    }

    //
    // Allocate the output buffers.  The memory must be stored in globals
    // in order to be destroyed correctly.
    //

    assert(!g_pStreamBufferArrays && !g_pStreamBuffers);

    g_pStreamBufferArrays = malloc(sizeof(DWORD) * AudioStreamCount * 4);

    if (!g_pStreamBufferArrays)
    {
        fprintf(stderr, "ERROR: Unable to allocate an output buffers.\n");

        // Does not return.
        Done();
    }

    pAudioBufferStart    = (BYTE **)g_pStreamBufferArrays;
    pAudioBufferPending  = pAudioBufferStart + StreamCount;
    pAudioBufferPrevious = pAudioBufferPending + StreamCount;
    pAudioBufferCurrent  = pAudioBufferPrevious + StreamCount;

    g_pStreamBuffers = VirtualAlloc(NULL,
                                    g_OutputBufferSize * 2 * (AudioStreamCount + 1) * 2,
                                    MEM_COMMIT,
                                    PAGE_READWRITE);

    if (!g_pStreamBuffers)
    {
        fprintf(stderr, "ERROR: Unable to allocate an output buffers.\n");

        // Does not return.
        Done();
    }

    // Set up the video buffers.
    pb = (BYTE *)g_pStreamBuffers;

    pVideoBufferStart = pb;
    pb += g_OutputBufferSize * 2;

    pVideoBufferPending = pb;
    pb += g_OutputBufferSize * 2;

    // Set up the audio buffers.
    for (iStream = 0; iStream < AudioStreamCount; iStream++)
    {
        pAudioBufferStart[iStream] = pb;
        pb += g_OutputBufferSize * 2;

        pAudioBufferPending[iStream] = pb;
        pb += g_OutputBufferSize * 2;
    }

    do
    {
#if DBG
        memset(pVideoBufferStart, 0x69, g_OutputBufferSize * 2);

        for (iStream = 0; iStream < AudioStreamCount; iStream++)
        {
            memset(pAudioBufferStart[iStream], 0x69, g_OutputBufferSize * 2);
        }
#endif

        FrameCount = 0;

        // Use locals until we can transfer any tail frames out of the pending
        // buffers.
        //
        pVideoBufferHeaderNext = pVideoBufferStart;

        // The first packet contains a whole buncha-buncha nifty information
        if (OutputBufferWriteCount == 0)
        {
            pVideoDataHeader        = (XMVVideoDataHeader *)pVideoBufferHeaderNext;
            pVideoBufferHeaderNext += sizeof(XMVVideoDataHeader);

            // Fill it in.
            pVideoDataHeader->MagicCookie                      = XMV_MAGIC_COOKIE;
            pVideoDataHeader->FileVersion                      = XMV_FILE_VERSION;
            pVideoDataHeader->FramesPerSecond                  = FramesPerSecond;
            pVideoDataHeader->Slices                           = g_StreamMap.pVideoStreamInfo->Slices;
            pVideoDataHeader->MixedPelMotionCompensationEnable = g_StreamMap.pVideoStreamInfo->MixedPelMotionCompensationEnable;
            pVideoDataHeader->LoopFilterEnabled                = g_StreamMap.pVideoStreamInfo->LoopFilterEnabled;
            pVideoDataHeader->VariableSizedTransformEnabled    = g_StreamMap.pVideoStreamInfo->VariableSizedTransformEnabled;
            pVideoDataHeader->XIntra8IPictureCodingEnabled     = g_StreamMap.pVideoStreamInfo->XIntra8IPictureCodingEnabled;
            pVideoDataHeader->HybridMotionVectorEnabled        = g_StreamMap.pVideoStreamInfo->HybridMotionVectorEnabled;
            pVideoDataHeader->DCTTableSwitchingEnabled         = g_StreamMap.pVideoStreamInfo->DCTTableSwitchingEnabled;
            pVideoDataHeader->Width                            = VideoStreamCount ? g_StreamMap.pVideoStreamInfo->Width : 0;
            pVideoDataHeader->Height                           = VideoStreamCount ? g_StreamMap.pVideoStreamInfo->Height : 0;
            pVideoDataHeader->RequiredBufferSize               = g_OutputBufferSize;
            pVideoDataHeader->AudioStreamCount                 = AudioStreamCount;

            // Save the audio stream information.
            for (iStream = 0; iStream < AudioStreamCount; iStream++)
            {
                pAudioDataHeader        = (XMVAudioDataHeader *)pVideoBufferHeaderNext;
                pVideoBufferHeaderNext += sizeof(XMVAudioDataHeader);

                pAudioDataHeader->WaveFormat       = (WORD)g_StreamMap.AudioMap[iStream].pAudioStreamInfo->WaveFormat;
                pAudioDataHeader->ChannelCount     = (WORD)g_StreamMap.AudioMap[iStream].pAudioStreamInfo->ChannelCount;
                pAudioDataHeader->SamplesPerSecond = g_StreamMap.AudioMap[iStream].pAudioStreamInfo->SamplesPerSecond;
                pAudioDataHeader->BitsPerSample    = g_StreamMap.AudioMap[iStream].pAudioStreamInfo->BitsPerSample;
            }
        }

        // Save space for the packet headers.
        pPacketHeader = (XMVPacketHeader *)pVideoBufferHeaderNext;
        pVideoBufferHeaderNext += sizeof(XMVPacketHeader);

        // Save space for the video packet header.  This will get filled in
        // just before this packet gets written to disk.
        //
        pVideoPacketHeader = (XMVVideoPacketHeader *)pVideoBufferHeaderNext;
        pVideoBufferHeaderNext += sizeof(XMVVideoPacketHeader) + sizeof(XMVAudioStreamHeader) * AudioStreamCount;

        // If there is a frame hanging off the end of the previous packet then
        // we need to copy it to the beginning of this packet then zero pad
        // out what we copied.
        //
        if (ThisFrameSize)
        {
            // Our state is:
            //
            //  pVideoBufferStart hold the start of the current video stream
            //  pVideoBufferHeaderNext holds where to write the next data to 
            //      the video stream
            //  pAudioBufferStart[0..] holds empty audio stream buffers
            //  p*BufferPrevious holds a pointer to the beginning of the last
            //      frame data for each buffer
            //  p*BufferCurrent holds a pointer to the end of the last frame 
            //      data for each buffer
            //
            Size = pVideoBufferCurrent - pVideoBufferPrevious;

            memcpy(pVideoBufferHeaderNext, pVideoBufferPrevious, Size);

            pVideoBufferPrevious = pVideoBufferHeaderNext;
            pVideoBufferCurrent  = pVideoBufferHeaderNext + Size;

            for (iStream = 0; iStream < AudioStreamCount; iStream++)
            {
                Size = pAudioBufferCurrent[iStream] - pAudioBufferPrevious[iStream];

                memcpy(pAudioBufferStart[iStream], pAudioBufferPrevious[iStream], Size);

                pAudioBufferPrevious[iStream] = pAudioBufferStart[iStream];
                pAudioBufferCurrent[iStream]  = pAudioBufferStart[iStream] + Size;

                ThisFrameSize += Size;
            }

            FrameCount++;
        }
        else
        {
            pVideoBufferPrevious = pVideoBufferHeaderNext;
            pVideoBufferCurrent  = pVideoBufferHeaderNext;

            for (iStream = 0; iStream < AudioStreamCount; iStream++)
            {
                pAudioBufferPrevious[iStream] = pAudioBufferStart[iStream];
                pAudioBufferCurrent[iStream]  = pAudioBufferStart[iStream];
            }
        }

        // Remember the size of what we've done so far.
        CurrentPacketSize = pVideoBufferHeaderNext - pVideoBufferStart + ThisFrameSize;

        // Loop through the input stream until we have enough data to fill
        // the output buffer.
        //
        for(;;)
        {            
            // Remember the frame we just finished.
            pVideoBufferPrevious = pVideoBufferCurrent;

            memcpy(pAudioBufferPrevious, pAudioBufferCurrent, sizeof(DWORD) * AudioStreamCount);

            // Reset.
            ThisFrameSize = 0;

            // Get the next video frame.
            if (VideoStreamCount)
            {
                // Save room for the header.
                pVideoBufferCurrent += sizeof(XMVVideoFrame);

                if (!g_StreamMap.pfnGetNextVideoFrame(g_StreamMap.pFileHandle,
                                                      g_StreamMap.VideoStream,
                                                      &pVideoBufferCurrent,
                                                      pVideoBufferStart + g_OutputBufferSize * 2))
                {
                    break;
                }

                ThisFrameSize += pVideoBufferCurrent - pVideoBufferPrevious;

                PaddingSize = (ThisFrameSize + 3) & ~3 - ThisFrameSize;
                memset(pVideoBufferCurrent, 0, PaddingSize);

                ThisFrameSize += PaddingSize;
                pVideoBufferCurrent += PaddingSize;

                ((XMVVideoFrame *)pVideoBufferPrevious)->FrameSize = ThisFrameSize - sizeof(XMVVideoFrame);
            }

            // Get the next audio frame.
            for (iStream = 0; iStream < AudioStreamCount; iStream++)
            {
                g_StreamMap.AudioMap[iStream].pfnGetNextAudioFrame(g_StreamMap.AudioMap[iStream].pFileHandle,
                                                                   g_StreamMap.AudioMap[iStream].AudioStream,
                                                                   FramesPerSecond,
                                                                   &pAudioBufferCurrent[iStream],
                                                                   pAudioBufferStart[iStream] + g_OutputBufferSize * 2);

                ThisFrameSize += (pAudioBufferCurrent[iStream] - pAudioBufferPrevious[iStream]);
            }

            // Make sure it just isn't too danged big.
            if (ThisFrameSize > g_OutputBufferSize)
            {
                fprintf(stderr, "ERROR: A frame can't be encoded in the size of a single buffer.  Increase the buffer size.\n");

                // Never returns.
                Done();
            }

            // Audio streams need to always be DWORD aligned.  This means we
            // might have to insert up to 3 bytes of padding for each stream and
            // is a bit hard to keep track of when maintaining a running total.
            // Try to calculate the size and, in the process, figure out if
            // we've overrun our buffer.
            //
            // We always need to pad the very last frame with 3 bytes to avoid
            // running off the end of the buffer in the decoder.
            //
            VideoBufferSize = pVideoBufferCurrent - pVideoBufferStart;

            for (iStream = 0; iStream < AudioStreamCount; iStream++)
            {
                AudioBufferSize += (pAudioBufferCurrent[iStream] - pAudioBufferStart[iStream] + 3) & ~3;
            }

            PotentialPacketSize = VideoBufferSize + AudioBufferSize;

            if (PotentialPacketSize > g_OutputBufferSize)
            {
                break;
            }

            if (FrameCount == 255)
            {
                fprintf(stderr, "WARNING: A buffer can only contain 255 frames and the current buffer still has room.  Consider reducing its size.\n");
                break;
            }

            CurrentPacketSize = PotentialPacketSize;

            FrameCount++;
        }

        // We're done.
        if (FrameCount == 0)
        {
            CurrentPacketSize = 0;
        }

        // The packets are always padded out to the nearest page, get that size.
        PaddedCurrentPacketSize = (CurrentPacketSize + 4095) & ~4095;

        // Fill out the rest of the video packet header.  The video stream must
        // contain any padding we need.
        //
        pVideoPacketHeader->VideoStreamLength 
            = (pVideoBufferPrevious - pVideoBufferHeaderNext) + (PaddedCurrentPacketSize - CurrentPacketSize);

        pVideoPacketHeader->FrameCount = FrameCount;

        for (iStream = 0; iStream < AudioStreamCount; iStream++)
        {
            pVideoPacketHeader->AudioStreams[iStream].AudioStreamSize
                = pAudioBufferPrevious[iStream] - pAudioBufferStart[iStream];
        }
        
        // If this isn't the first buffer then spit out the pending buffer
        // now the we know the sizes.
        //
        if (OutputBufferWriteCount != 0)
        {
            pPendingPacketHeader->NextPacketSize = PaddedCurrentPacketSize;

            // Pad and write out the video packet.
            memset(pVideoBufferPending + PendingVideoBufferSize, 0, PendingVideoPaddingSize);

            Size = PendingVideoBufferSize + PendingVideoPaddingSize;

            if (!WriteFile(g_hOutputFile, pVideoBufferPending, Size, &Written, NULL)
                || Written != Size)
            {
                fprintf(stderr, "ERROR: Unable to write to the output file.\n");

                // Never returns.
                Done();
            }

            // Write out the audio packets.
            for (iStream = 0; iStream < AudioStreamCount; iStream++)
            {
                // Pad and write the audio streams.
                Size = pPendingVideoPacketHeader->AudioStreams[iStream].AudioStreamSize;
                
                memset(pAudioBufferPending[iStream] + Size, 0, 3);

                Size = (Size + 3) & ~3;

                if (!WriteFile(g_hOutputFile, 
                               pAudioBufferPending[iStream], 
                               Size, 
                               &Written, 
                               NULL)
                    || Written != Size)
                {
                    fprintf(stderr, "ERROR: Unable to write to the output file.\n");

                    // Never returns.
                    Done();
                }
            }           
        }
        else
        {
            // Save the size of the current packet in the header.
            pVideoDataHeader->ThisPacketSize = PaddedCurrentPacketSize;
        }

        // Swap the current buffer to the pending buffer.
        pVideoBufferSwap    = pVideoBufferStart;
        pVideoBufferStart   = pVideoBufferPending;
        pVideoBufferPending = pVideoBufferSwap;

        pAudioBufferSwap    = pAudioBufferStart;
        pAudioBufferStart   = pAudioBufferPending;
        pAudioBufferPending = pAudioBufferSwap;

        PendingVideoBufferSize    = pVideoBufferPrevious - pVideoBufferPending;
        PendingVideoPaddingSize   = PaddedCurrentPacketSize - CurrentPacketSize;
        pPendingVideoPacketHeader = pVideoPacketHeader;
        pPendingPacketHeader      = pPacketHeader;

        OutputBufferWriteCount++;
    }
    while(FrameCount);
}

/*
 * Converts the input file into a XMV file.
 */

void Convert()
{
    FileContents ContentsArray[MAX_STREAMS];
    DWORD VideoStreamCount, AudioStreamCount;

    DWORD i;

    g_InputFileDesc.pFile = g_InputFileDesc.pfnOpenMedia(&g_InputFile, ContentsArray);

    // Get the file information.
    memset(ContentsArray, 0, sizeof(ContentsArray));

    g_InputFileDesc.pFile = g_InputFileDesc.pfnOpenMedia(&g_InputFile, ContentsArray);

    // Build the stream mapping table.
    VideoStreamCount = 0;
    AudioStreamCount = 0;

    for (i = 0; i < MAX_STREAMS; i++)
    {
        if (ContentsArray[i].StreamType == STREAM_VIDEO)
        {
            if (VideoStreamCount > 0)
            {
                fprintf(stderr, "ERROR: XMV files only support one video stream and more than one has been specified.\n");
                Done();
            }
        
            if (ContentsArray[i].VideoStream.CompressionID != '2VMW')
            {
                fprintf(stderr, "ERROR: XMV only supports WMV2 encoded video streams.\n");
                Done();
            }

            if (ContentsArray[i].VideoStream.Width % 16 || ContentsArray[i].VideoStream.Height % 16)
            {
                fprintf(stderr, "ERROR: The height and width of the video stream must be a multiple of 16.\n");
                Done();
            }

            g_StreamMap.pfnGetNextVideoFrame = g_InputFileDesc.pfnGetNextVideoFrame;
            g_StreamMap.pFileHandle          = g_InputFileDesc.pFile;
            g_StreamMap.VideoStream          = i;
            g_StreamMap.pVideoStreamInfo     = &ContentsArray[i].VideoStream;

            VideoStreamCount++;
        }
        else if (ContentsArray[i].StreamType == STREAM_AUDIO)
        {
            g_StreamMap.AudioMap[i].pfnGetNextAudioFrame = g_InputFileDesc.pfnGetNextAudioFrame;
            g_StreamMap.AudioMap[i].pFileHandle          = g_InputFileDesc.pFile;
            g_StreamMap.AudioMap[i].AudioStream          = i;
            g_StreamMap.AudioMap[i].pAudioStreamInfo     = &ContentsArray[i].AudioStream;
        }
    }

    // NYI: We don't do audio yet.
    ProcessFrames(VideoStreamCount, 0);
}

/*
 * Main entrypoint
 */

int __cdecl main
(
    int argc, 
    char **argv
)
{
    if (!ParseCommandLine(argc, argv))
    {
        Usage();
        return 1;
    }

    // This app only has one mode of error recovery: QUIT!  We use
    // setjmp/longjmp to avoid manually unwinding the stack.  This only
    // affects the optimizations of this routine and of "Done".
    //
    // The one side-effect is that all resource destruction must happen
    // at the end of this routine.
    //
    if (setjmp(g_Done) == 0)
    {
        OpenFiles();

        //
        // Parse the file.
        //

        switch(g_Command)
        {
        case COMMAND_INFO:
            Info();
            break;

        case COMMAND_CONVERT:
            Convert();
            break;
        }
    }
    
    //
    // Clean up.
    //

    if (g_pStreamBufferArrays)
    {
        free(g_pStreamBufferArrays);
    }

    if (g_pStreamBuffers)
    {
        VirtualFree(g_pStreamBuffers, 0, MEM_RELEASE);
    }

    if (g_hOutputFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hOutputFile);
    }

    if (g_InputFileDesc.FileType != FILEDESC_UNKNOWN && g_InputFileDesc.pFile)
    {
        g_InputFileDesc.pfnCloseMedia(g_InputFileDesc.pFile);
    }

    CloseMediaFile(&g_InputFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\xmv\xmvtool\xmvparser.c ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xvmparser.c
 *  Content:    XMV file parser
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "fileio.h"
#include "xmvtool.h"

#include "..\inc\xmvformat.h"

//
// Manages the information needed to walk over an individual stream.
//

typedef struct _XsfAudioStream
{
    // The amount of audio data remaining in this stream.
    DWORD AudioDataSize;

    // The number of audio bytes remaining.
    DWORD AudioStreamRemaining;

    // The number of bytes to skip at the end of this buffer
    // to get to the next one.
    //
    DWORD BytesToSkip;
    
    // The total size of the next buffer / 4096.
    DWORD NextPacketSize;

    // The stream that contains the audio data.
    MediaStream Stream;
}
XsfAudioStream;

//
// Basic data structure we use to walk over the file
//

typedef struct _XsfFile
{
    // Number of frames in this buffer.
    DWORD FrameCount;

    // The amount of video data that remains.
    DWORD VideoStreamRemaining;

    // How many bytes to skip to get to the next stream.
    DWORD BytesToSkip;

    // Video stream.
    MediaStream VideoStream;

    // The total size of the next packet.
    DWORD NextPacketSize;

    // The number of audio streams.
    DWORD AudioStreamCount;

    // Helpers to iterate over all of the streams.
    XsfAudioStream AudioStreams[0];
}
XsfFile;

/*
 * Check the file to see if it's one of us.
 */

BOOL  XmvCheckFormat
(
    MediaFile *pMediaFile
)
{
    MediaStream Stream;
    XMVPacketHeader *pPacketHeader;
    XMVVideoDataHeader *pVideoDataHeader;

    OpenMediaStream(pMediaFile, &Stream);

    // Don't fall off the end.
    if (GetMediaSize(&Stream) < sizeof(XMVPacketHeader) + sizeof(XMVVideoDataHeader))
    {
        return FALSE;
    }

    // Read the first object.
    pPacketHeader = (XMVPacketHeader *)ReadStream(&Stream, sizeof(XMVPacketHeader));
    pVideoDataHeader = (XMVVideoDataHeader *)ReadStream(&Stream, sizeof(XMVVideoDataHeader));

    return pVideoDataHeader->MagicCookie == XMV_MAGIC_COOKIE
        && pVideoDataHeader->FileVersion == XMV_FILE_VERSION;
}

/*
 * Process the header.
 */

void *XmvOpenMedia
(
    MediaFile *pMediaFile, 
    FileContents *ContentsArray
)
{
    XsfFile *pFile;

    MediaStream Stream;
    DWORD i;

    XMVPacketHeader *pPacketHeader;
    XMVVideoDataHeader *pVideoDataHeader;
    XMVAudioDataHeader *pAudioDataHeader;

    DWORD AudioStreamCount; 

    DWORD VideoStreamSize;
    DWORD AudioStreamSize[MAX_STREAMS];
    
    DWORD FirstPacketSize;

    OpenMediaStream(pMediaFile, &Stream);

    // Read the video information.
    pVideoDataHeader = (XMVVideoDataHeader *)ReadStream(&Stream, sizeof(XMVVideoDataHeader));

    AudioStreamCount = pVideoDataHeader->AudioStreamCount;
    FirstPacketSize  = pVideoDataHeader->ThisPacketSize;

    // Fill the video info into the end of the contents array after where 
    // we'll put all of the audio stuff.  
    //
    if (pVideoDataHeader->Width != 0)
    {
        ContentsArray[AudioStreamCount].StreamType                  = STREAM_VIDEO;
        ContentsArray[AudioStreamCount].VideoStream.CompressionID   = '2VMW';
        ContentsArray[AudioStreamCount].VideoStream.FramesPerSecond = pVideoDataHeader->FramesPerSecond;
        ContentsArray[AudioStreamCount].VideoStream.Width           = pVideoDataHeader->Width;
        ContentsArray[AudioStreamCount].VideoStream.Height          = pVideoDataHeader->Height;
    }

    // Do all of the audio streams.
    for (i = 0; i < AudioStreamCount; i++)
    {
        pAudioDataHeader = (XMVAudioDataHeader *)ReadStream(&Stream, sizeof(XMVAudioDataHeader));

        ContentsArray[i].StreamType                   = STREAM_AUDIO;
        ContentsArray[i].AudioStream.WaveFormat       = pAudioDataHeader->WaveFormat;
        ContentsArray[i].AudioStream.ChannelCount     = pAudioDataHeader->ChannelCount;
        ContentsArray[i].AudioStream.SamplesPerSecond = pAudioDataHeader->SamplesPerSecond;
        ContentsArray[i].AudioStream.BitsPerSample    = pAudioDataHeader->BitsPerSample;
    }

    // Allocate the object.
    pFile = (XsfFile *)malloc(sizeof(XsfFile) + sizeof(XsfAudioStream) * AudioStreamCount);

    if (!pFile)
    {
        fprintf(stderr, "ERROR: Unable to allocate memory.\n");
        Done();
    }

    // Fill it in.
    pFile->FrameCount           = 0;
    pFile->BytesToSkip          = 0;
    pFile->VideoStreamRemaining = 0;
    pFile->NextPacketSize       = FirstPacketSize - (DWORD)GetStreamPosition(&Stream);

    CloneMediaStream(&Stream, &pFile->VideoStream);

    pFile->AudioStreamCount     = AudioStreamCount;

    for (i = 0; i < AudioStreamCount; i++)
    {
        pFile->AudioStreams[i].AudioDataSize        = 0;
        pFile->AudioStreams[i].BytesToSkip          = 0;
        pFile->AudioStreams[i].AudioStreamRemaining = 0;
        pFile->AudioStreams[i].NextPacketSize       = FirstPacketSize - (DWORD)GetStreamPosition(&Stream);

        CloneMediaStream(&Stream, &pFile->AudioStreams[i].Stream);
    }

    return pFile;
}

/*
 * Destroy the file object.  The file will get closed by the main routine.
 */

void  XmvCloseMedia
(
    void *pFile
)
{
    free(pFile);
}

/*
 * Get one video frame from a video stream.
 */

BOOL XmvGetNextVideoFrame
(
    void *pFileHandle, 
    DWORD StreamNumber, 
    BYTE **ppVideoBuffer, 
    BYTE *pVideoBufferMax
)
{
    XsfFile *pFile;
    MediaStream *pStream;

    XMVPacketHeader *pPacketHeader;
    XMVVideoPacketHeader *pVideoPacketHeader;

    DWORD ThisPacketSize;
    DWORD NextPacketSize;
    DWORD VideoFrameSize;
    DWORD ReadSize;

    BYTE *pVideoFrame;

    LONGLONG InitialPacketOffset;

    pFile = (XsfFile *)pFileHandle;
    pStream = &pFile->VideoStream;

    if (!pFile->FrameCount)
    {
        // Skip the rest of this packet.
        SkipStreamData(pStream, pFile->BytesToSkip + pFile->VideoStreamRemaining);

        // Save our current spot in the stream.
        InitialPacketOffset = GetStreamPosition(pStream);

        // Figure out the size of the next packet.
        if (!pFile->NextPacketSize)
        {
            return FALSE;
        }

        ThisPacketSize = pFile->NextPacketSize;

        // Read the next packet size and save it.
        pPacketHeader = (XMVPacketHeader *)ReadStream(pStream, sizeof(XMVPacketHeader));
        pFile->NextPacketSize = pPacketHeader->NextPacketSize;

        // Load the video packet header.
        pVideoPacketHeader = (XMVVideoPacketHeader *)ReadStream(pStream, sizeof(XMVVideoPacketHeader));

        // Save the video stream length and the frame count.
        pFile->VideoStreamRemaining = pVideoPacketHeader->VideoStreamLength;
        pFile->FrameCount           = pVideoPacketHeader->FrameCount;

        // Skip past the audio stream info.
        SkipStreamData(pStream, pFile->AudioStreamCount * sizeof(XMVAudioStreamHeader));

        // Figure out how much goo to skip at the end of the video stream to
        // get to the next packet.
        //
        pFile->BytesToSkip = ThisPacketSize - (DWORD)(GetStreamPosition(pStream) - InitialPacketOffset) - pFile->VideoStreamRemaining;
    }

    // Save the current offset so we can remember how much space we've
    // consumed.
    //
    InitialPacketOffset = GetStreamPosition(pStream);

    // Read the frame size.
    VideoFrameSize = ((XMVVideoFrame *)ReadStream(pStream, sizeof(XMVVideoFrame)))->FrameSize;

    if (*ppVideoBuffer + VideoFrameSize > pVideoBufferMax)
    {
        fprintf(stderr, "ERROR: The buffer is too small to encode this data, increase its size.\n");
        Done();
    }

    // Read the frame.
    while (VideoFrameSize)
    {
        ReadSize = VideoFrameSize > FILE_MAPPING_GRANULARITY ? FILE_MAPPING_GRANULARITY : VideoFrameSize;

        pVideoFrame = ReadStream(pStream, ReadSize);

        // Copy it.
        memcpy(*ppVideoBuffer, pVideoFrame, ReadSize);

        *ppVideoBuffer += ReadSize;

        VideoFrameSize -= ReadSize;
    }


    // Remember what we did.
    pFile->FrameCount--;
    pFile->VideoStreamRemaining -= (DWORD)(GetStreamPosition(pStream) - InitialPacketOffset);

    return TRUE;
}

/*
 * Get one frame's worth of audio
 */

void XmvGetNextAudioFrame
(
    void *pFile, 
    DWORD StreamNumber, 
    DWORD FPS, 
    BYTE **ppAudioBuffer, 
    BYTE *pAudioBufferMax
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\av.h ===
/*--

Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#if !defined(_NTSYSTEM_)
#define NTKERNELAVAPI DECLSPEC_IMPORT
#else
#define NTKERNELAVAPI
#endif

//
// AV pack identifiers
//
#define AV_PACK_NONE                      0x00000000

#define AV_PACK_STANDARD                  0x00000001
#define AV_PACK_RFU                       0x00000002
#define AV_PACK_SCART                     0x00000003
#define AV_PACK_HDTV                      0x00000004
#define AV_PACK_VGA                       0x00000005
#define AV_PACK_SVIDEO                    0x00000006
#define AV_PACK_MAX                       0x00000007

#define AV_PACK_MASK                      0x000000FF

//
// AV_ region types
//
#define AV_STANDARD_NTSC_M                0x00000100
#define AV_STANDARD_NTSC_J                0x00000200
#define AV_STANDARD_PAL_I                 0x00000300
#define AV_STANDARD_PAL_M                 0x00000400
#define AV_STANDARD_MAX                   0x00000500

#define AV_STANDARD_MASK                  0x0000FF00
#define AV_STANDARD_BIT_SHIFT             8

// Allows 16:9 for all SDTV and DTV modes.  HDTV 
// modes (720p and 1080i) are assumed to support 16:9.
//
#define AV_FLAGS_WIDESCREEN               0x00010000
#define AV_FLAGS_LETTERBOX                0x00100000

#define AV_ASPECT_RATIO_MASK              (AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)

// 480i support is assumed.
#define AV_FLAGS_HDTV_480i                0x00000000
#define AV_FLAGS_HDTV_720p                0x00020000
#define AV_FLAGS_HDTV_1080i               0x00040000
#define AV_FLAGS_HDTV_480p                0x00080000

#define AV_HDTV_MODE_MASK                 (AV_FLAGS_HDTV_480p | AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i | AV_FLAGS_HDTV_480i)

// Whether the display is interlaced or not.
#define AV_FLAGS_INTERLACED               0x00200000

// Indicates a field-rendered mode.
#define AV_FLAGS_FIELD                    0x01000000

// Indicates that this is in the funky pixel aspect ratio mode.
#define AV_FLAGS_10x11PAR                 0x02000000

// The refresh rate supported by the display.
#define AV_FLAGS_60Hz                     0x00400000
#define AV_FLAGS_50Hz                     0x00800000

#define AV_REFRESH_MASK                   (AV_FLAGS_60Hz | AV_FLAGS_50Hz)

#define AV_USER_FLAGS_MASK                (AV_ASPECT_RATIO_MASK | AV_HDTV_MODE_MASK | AV_FLAGS_60Hz)
#define AV_USER_FLAGS_BIT_SHIFT           16

//
// TV encoder options
//

// !!! Do not change the MACROVISION_MODE value without
//    updating the DVD software!

#define AV_OPTION_MACROVISION_MODE        1
#define AV_OPTION_ENABLE_CC               2
#define AV_OPTION_DISABLE_CC              3
#define AV_OPTION_SEND_CC_DATA            4
#define AV_QUERY_CC_STATUS                5
#define AV_QUERY_AV_CAPABILITIES          6
#define AV_OPTION_BLANK_SCREEN            9
#define AV_OPTION_MACROVISION_COMMIT      10
#define AV_OPTION_FLICKER_FILTER          11
#define AV_OPTION_ZERO_MODE               12
#define AV_OPTION_QUERY_MODE              13
#define AV_OPTION_ENABLE_LUMA_FILTER      14
#define AV_OPTION_GUESS_FIELD             15
#define AV_QUERY_ENCODER_TYPE             16
#define AV_QUERY_MODE_TABLE_VERSION       17

//
// TV encoder types.
//

#define AV_ENCODER_CONEXANT_871           0

//
// Macrovision modes
//

#define AV_MV_OFF                         0
#define AV_MV_AGC_ONLY                    1
#define AV_MV_TWO_STRIPES_PLUS_AGC        2
#define AV_MV_FOUR_STRIPES_PLUS_AGC       3

NTKERNELAVAPI
ULONG
NTAPI
AvSetDisplayMode(
    IN  PVOID RegisterBase,
    IN  ULONG Step,
    IN  ULONG DisplayMode,            // mode from the AV_MODE list (avmode.h)
    IN  ULONG SourceColorFormat,      // D3DFORMAT
    IN  ULONG Pitch,
    IN  ULONG FrameBuffer
    );

NTKERNELAVAPI
VOID
NTAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

NTKERNELAVAPI
PVOID
NTAPI
AvGetSavedDataAddress(
    VOID
    );

NTKERNELAVAPI
VOID
NTAPI
AvSetSavedDataAddress(
    PVOID Address
    );

VOID
NTAPI
AvRelocateSavedDataAddress(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAVAPI
ULONG
NTAPI
AvSMCVideoModeToAVPack(
    ULONG VideoMode
    );

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\recovpch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include <ntos.h>
#include <smcdef.h>
#include <scsi.h>
#include <stdio.h>
#include <xdbg.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#define XFONT_TRUETYPE
#include <xfont.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\dvdauth.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      dvdauth.cpp
// Contents:  Contains DVD authentication-related functionality.  Code is
//            99% cut-and-paste from ntos\idex\cdrom.c.
// Revisions: 23-Aug-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "recovpch.h"
#include "imagefile.h"
#include "xsum.h"
#include <idex.h>
#include <assert.h>

// Imagebld public key stolen from sdktools\imagebld.new\keydata.cpp.  Used
// as a red key.
UCHAR RedPublicKeyData[] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};

BYTE rgbyGreenHash[] =
{
    0x31,  0xE6,  0xF5,  0x27,  0x56,
    0xFA,  0x7A,  0x66,  0xA5,  0x13,
    0x82,  0x14,  0x12,  0x4F,  0xB2,
    0x12,  0x57,  0xC9,  0x24,  0xC5
};

extern TCHAR g_szAuthCheckMatch[100];

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



/*++

Routine Description:

    This routine verifies the authoring signature of the supplied DVD-X2 control
    data structure.

Arguments:

    ControlData - Specifies the control data structure to be verified.

Return Value:

    Status of operation.

--*/
NTSTATUS VerifyDVDX2AuthoringSignature(IN PDVDX2_CONTROL_DATA ControlData,
                                       TCHAR *szResult)
{
    UCHAR AuthoringDigest[XC_DIGEST_LEN];
    PUCHAR Workspace;
    NTSTATUS status;
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];


    //
    // Calculate the digest for bytes 0 to 1226 of the control data structure
    // and verify that this matches the authoring hash stored in the control
    // data structure.
    //

    XCCalcDigest((PUCHAR)&ControlData->LayerDescriptor,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, LayerDescriptor), AuthoringDigest);

    if (!RtlEqualMemory(AuthoringDigest, ControlData->AuthoringHash,
        XC_DIGEST_LEN)) {
        wsprintf(szResult, TEXT("Failed to verify control data"));
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Allocate a workspace to do the digest verification.
    //

    ASSERT(XCCalcKeyLen(XePublicKeyData) == XCCalcKeyLen(RedPublicKeyData));
    Workspace = (PUCHAR)ExAllocatePoolWithTag(XCCalcKeyLen(RedPublicKeyData) * 2,
        'sWxI');

    if (Workspace == NULL) {
        wsprintf(szResult, TEXT("Failed to verify control data"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    
    // Determine which key the disc is signed with.

    // Is it signed with the red key?  Compare it against the known-red key.
    if (XCVerifyDigest(ControlData->AuthoringSignature, RedPublicKeyData,
                       Workspace, AuthoringDigest))
    {
        // Red key
        status = STATUS_SUCCESS;
        wsprintf(szResult, TEXT("[Red-signed DVD-X2]"));
        goto done;
    }


    // It's not the red key; before we check against the green key, first check
    // to see if the xbox itself is signed with the green key (if it's not,
    // then it's not a retail box, and couldn't read green discs anyways)

    // Compute the SHA digest of the public key to determine if it's the
    // green key
    XcSHAInit((PUCHAR)&SHAHash);
    XcSHAUpdate((PUCHAR)&SHAHash, (PUCHAR)XePublicKeyData,
        sizeof RedPublicKeyData);
    XcSHAFinal((PUCHAR)&SHAHash, SHADigest);

    if (memcmp(SHADigest, rgbyGreenHash, sizeof(rgbyGreenHash)))
    {
        // The rom was not signed with the green key; we don't know what it is
        goto unknownSig;
    }

    // The Xbox is indeed a retail xbox; compare the ROM key with the DVD to
    // see if the DVD is green-signed
    if (!XCVerifyDigest(ControlData->AuthoringSignature, XePublicKeyData,
                       Workspace, AuthoringDigest))
    {
        // Unknown disc signature
unknownSig:
        wsprintf(szResult, TEXT("Unknown disc signature"));
        status = STATUS_SUCCESS;
        goto done;
    }

    // If here, then the dvd is signed with the green (retail) key
    status = STATUS_SUCCESS;
    wsprintf(szResult, TEXT("[Green-signed DVD-X2]"));

done:

    ExFreePool(Workspace);

    return status;
}


/*++

Routine Description:

    This routine decrypts the host challenge response table of the supplied
    DVD-X2 control data structure.

Arguments:

    ControlData - Specifies the control data structure that contains the host
        challenge response table to be decrypted.

Return Value:

    None.

--*/
VOID DecryptHostChallengeResponseTable(IN PDVDX2_CONTROL_DATA ControlData)
{
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT RC4KeyStruct;

    //
    // Compute the SHA-1 hash of the data between bytes 1183 to 1226 of the
    // control data structure.
    //

    XcSHAInit((PUCHAR)&SHAHash);
    XcSHAUpdate((PUCHAR)&SHAHash, (PUCHAR)&ControlData->AuthoringTimeStamp,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringTimeStamp));
    XcSHAFinal((PUCHAR)&SHAHash, SHADigest);

    //
    // Compute a 56-bit RC4 session key from the SHA-1 hash.
    //

    XcRC4Key((PUCHAR)&RC4KeyStruct, 56 / 8, SHADigest);

    //
    // Decrypt the host challenge response table in place using the RC4 session
    // key.
    //

    XcRC4Crypt((PUCHAR)&RC4KeyStruct,
        sizeof(ControlData->HostChallengeResponseTable.Entries),
        (PUCHAR)&ControlData->HostChallengeResponseTable.Entries);
}

/*++

Routine Description:

    This routine issues the supplied challenge to the drive and checks the
    response from the drive.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    ControlData - Specifies the control data structure.

    HostChallengeResponseEntry - Specifies the challenge to issue.

    FirstChallenge - Specifies TRUE if this is the first challenge being made to
        the drive.

    FinalChallenge - Specifies TRUE if this is the final challenge being made to
        the drive.

Return Value:

    Status of operation.

--*/
NTSTATUS AuthenticationChallenge(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDVDX2_CONTROL_DATA ControlData,
    IN PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY HostChallengeResponseEntry,
    IN BOOLEAN FirstChallenge,
    IN BOOLEAN FinalChallenge,
    TCHAR *szResult
    )
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    DVDX2_AUTHENTICATION Authentication;

    ASSERT(HostChallengeResponseEntry->ChallengeLevel == 1);

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Prepare the authentication page.
    //

    RtlZeroMemory(&Authentication, sizeof(DVDX2_AUTHENTICATION));

    *((PUSHORT)&Authentication.Header.ModeDataLength) =
        IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION) -
        FIELD_OFFSET(DVDX2_AUTHENTICATION, Header.MediumType));
    Authentication.AuthenticationPage.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    Authentication.AuthenticationPage.PageLength = sizeof(DVDX2_AUTHENTICATION_PAGE) -
        FIELD_OFFSET(DVDX2_AUTHENTICATION_PAGE, PartitionArea);
    Authentication.AuthenticationPage.CDFValid = 1;
    Authentication.AuthenticationPage.DiscCategoryAndVersion =
        (ControlData->LayerDescriptor.BookType << 4) +
        ControlData->LayerDescriptor.BookVersion;
    Authentication.AuthenticationPage.DrivePhaseLevel = 1;
    Authentication.AuthenticationPage.ChallengeID = HostChallengeResponseEntry->ChallengeID;
    Authentication.AuthenticationPage.ChallengeValue = HostChallengeResponseEntry->ChallengeValue;

    if (!FirstChallenge) {
        Authentication.AuthenticationPage.Authentication = 1;
    }

    if (FinalChallenge) {
        Authentication.AuthenticationPage.PartitionArea = 1;
    }

    //
    // Issue the challenge to the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
    PassThrough.DataBuffer = &Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        DeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), NULL, 0,
        NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        wsprintf(szResult, TEXT("Challenge operation failed ") \
                           TEXT("(status=%08x)"), status);
        return status;
    }

    //
    // Read the response from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        DeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), NULL, 0,
        NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        wsprintf(szResult, TEXT("Response operation failed (status=%08x)"),
                           status);
        return status;
    }

    //
    // Check that the drive's response matches the expected response.
    //

    if (!Authentication.AuthenticationPage.Authentication ||
        (Authentication.AuthenticationPage.ResponseValue !=
        HostChallengeResponseEntry->ResponseValue)) {
        wsprintf(szResult, TEXT("Invalid challenge response from drive."));
        return STATUS_TOO_MANY_SECRETS;
    }

    return STATUS_SUCCESS;
}
bool AuthenticateDisc(DVDX2_AUTHENTICATION Authentication,
                      DVDX2_CONTROL_DATA ControlData,
                      PDEVICE_OBJECT DeviceObject,
                      TCHAR *szResult)
{
    NTSTATUS Status;
    LONG StartingIndex;
    LONG Index;
    LONG EndingIndex;
    BOOLEAN FirstChallenge;
    PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY HostChallengeResponseEntry;

    // Verify that the disc category and version from the authentication
    // page matches the control data structure.
    if (Authentication.AuthenticationPage.DiscCategoryAndVersion !=
        (ControlData.LayerDescriptor.BookType << 4) +
         ControlData.LayerDescriptor.BookVersion)
    {
        wsprintf(szResult, TEXT("Disc category and version mismatch.\n"));
        return false;
    }

    // Verify that the encrypted digest stored in the control data structure
    // matches the digest of the structure.

    Status = VerifyDVDX2AuthoringSignature(&ControlData, szResult);
    if (!NT_SUCCESS(Status)) {
        //szResult already filled in by VerifyDVDX2AuthoringSignature
        return false;
    }

    // Decrypt the contents of the host challenge response table.
    DecryptHostChallengeResponseTable(&ControlData);

    // Validate the the host challenge response table is the expected version
    // and that there are the expected number of entries in the table.
    if ((ControlData.HostChallengeResponseTable.Version != 1) ||
        (ControlData.HostChallengeResponseTable.NumberOfEntries == 0) ||
        (ControlData.HostChallengeResponseTable.NumberOfEntries >
            DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT)) {
        wsprintf(szResult, TEXT("Invalid host challenge response table"));
        return false;
    }

    // Walk through the host challenge response starting at a random starting
    // index and issue challenge response values.
    StartingIndex = KeQueryPerformanceCounter().LowPart %
                    ControlData.HostChallengeResponseTable.NumberOfEntries;
    FirstChallenge = TRUE;

    DWORD dwAuthAttempted = 0, dwAuthSucceeded = 0;
    for(Index = 0; Index < ControlData.HostChallengeResponseTable.NumberOfEntries; Index++) {
        HostChallengeResponseEntry = &ControlData.HostChallengeResponseTable.Entries[Index];

        TCHAR sz[100];
        wsprintf(sz, TEXT("Challenge on index %d -"), Index);
        OutputDebugString(sz);

        // Check if this is a supported challenge level.  If so, issue the
        // authentication challenge to the DVD-X2 drive.
        if (HostChallengeResponseEntry->ChallengeLevel == 1) {
            dwAuthAttempted |= 1 << Index;

            Status = AuthenticationChallenge(DeviceObject, &ControlData,
                            HostChallengeResponseEntry, FirstChallenge, FALSE,
                            szResult);

            if (!NT_SUCCESS(Status))
            {
                wsprintf(sz, TEXT("Failed authentication on index %d!\r\n"), Index);
                OutputDebugString(sz);
            } else
                dwAuthSucceeded |= 1 << Index;
            
            wsprintf(sz, TEXT("passed.\r\n"), Index);
            OutputDebugString(sz);

            EndingIndex = Index;
            FirstChallenge = FALSE;
        }
        else {
            wsprintf(sz, TEXT("skipped.\r\n"), Index);
            OutputDebugString(sz);
        }
    }
    
    // Generate the checkmatch string
    wsprintf(g_szAuthCheckMatch, TEXT("Check: 0x%06X Match: 0x%06X"),
            dwAuthAttempted, dwAuthSucceeded);
    
    // If we found a challenge response table with no entries that we can
    // process, then fail authentication.  We need at least one entry in order
    // to issue the final request to switch to the Xbox partition.
    if (EndingIndex == -1) {
        wsprintf(szResult, TEXT("No usable challenge response entries."));
        return false;
    }

    // Issue the last challenge response entry again, but this time switch to
    // the Xbox partition.
    HostChallengeResponseEntry = &ControlData.HostChallengeResponseTable.Entries[EndingIndex];

    Status = AuthenticationChallenge(DeviceObject, &ControlData,
                                     HostChallengeResponseEntry, FALSE, TRUE,
                                     szResult);

    if (!NT_SUCCESS(Status))
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\imagefile.cpp ===
#include "recovpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::read():fopen failed!! - '%s'\n", file );
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to get the backbuffer\n" );
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, D3DLOCK_TILED);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to lock the backbuffer\n" );
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\dvdverify.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      dvdverify.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "recovpch.h"
#include "xboxverp.h"
#include "xboxvideo.h"
#include "imagefile.h"
#include "xsum.h"
#include <idex.h>
#include <assert.h>


#define VERSION_SIG "XBOX_DVD_LAYOUT_TOOL_SIG"

struct VERSION_INFO 
{
    BYTE rgbySig[32];
    BYTE rgbyLayoutVersion[8];
    BYTE rgbyPremasterVersion[8];
    BYTE rgPadding[2048-32-8-8];    // fill with zeros
};
        
#define ONE_SECTOR 2048
#define SECTOR_BATCH 16 // batch 16 sectors at a time for optimization.

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL OBJECTS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_pVideo             -- Interface to the xbox video display
CXBoxVideo* g_pVideo;

// g_pBackgroundBitmap  -- The bitmap to display behind the text & progress bar
BitmapFile* g_pBackgroundBitmap;

// DVDDevice            -- The internal name of dvd drive.
COBJECT_STRING DVDDevice = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Cdrom0"));

// g_cSectors           -- Total number of sectors on the dvd (media area)
DWORD g_cSectors;

// g_dwTimeStart        -- Time that the verification started
DWORD g_dwTimeStart;

VERSION_INFO g_verinfo;
bool g_fVersionValid, g_fDone;
TCHAR g_szLayoutVersion[100], g_szPremasterVersion[100];
TCHAR g_szSignature[100], g_szAuthCheckMatch[100];


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ EXTERNAL FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// AuthenticateDisc     -- Verifies that the disc in the drive is an
    //                         authentic DVD-X2.
extern bool AuthenticateDisc(DVDX2_AUTHENTICATION Authentication,
                             DVDX2_CONTROL_DATA ControlData,
                             PDEVICE_OBJECT DeviceObject,
                             TCHAR *szResult);


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DrawMessage
// Purpose:   Outputs a one or two line message to the screen
// Arguments: pcszTextLine1 -- First line to output
//            pcszTextLine2 -- Second line to output
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
VOID DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2)
{
    // If the video display or background bitmap failed to load, then we should
    // never have gotten here.
    assert(g_pVideo && g_pBackgroundBitmap);

    // Set the screen back to it's original state (just the background
    // image)
    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());

    if (NULL != pcszTextLine2)
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine1);

    if (NULL != pcszTextLine2)
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT +
                           ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);

    if (g_fDone)
    {
        // Add version info line
        if (!g_fVersionValid)
            g_pVideo->DrawText(SCREEN_X_CENTER,
                               MENUBOX_TEXTAREA_Y2 - 30,
                               SCREEN_DEFAULT_TEXT_FG_COLOR,
                               SCREEN_DEFAULT_TEXT_BG_COLOR,
                               TEXT("No version info on disc"));
        else
        {
            g_pVideo->DrawText(SCREEN_X_CENTER,
                               MENUBOX_TEXTAREA_Y2 - 50,
                               SCREEN_DEFAULT_TEXT_FG_COLOR,
                               SCREEN_DEFAULT_TEXT_BG_COLOR,
                               g_szLayoutVersion);
            g_pVideo->DrawText(SCREEN_X_CENTER,
                               MENUBOX_TEXTAREA_Y2 - 50 + FONT_DEFAULT_HEIGHT +
                               ITEM_VERT_SPACING,
                               SCREEN_DEFAULT_TEXT_FG_COLOR,
                               SCREEN_DEFAULT_TEXT_BG_COLOR,
                               g_szPremasterVersion);
        }
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y2 - 65 - FONT_DEFAULT_HEIGHT +
                           ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           g_szSignature);

        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y2 - 70 - FONT_DEFAULT_HEIGHT * 2+
                           ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           g_szAuthCheckMatch);
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UpdateProgress
// Purpose:   Updates the onscreen progress display.  This includes the
//            progress bar and 'time remaining' displays.
// Arguments: dwLSN     -- The current LSN being handled.  Used to determine
//                         percentage complete.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
VOID UpdateProgress(DWORD dwLSN)
{
    // Keep track of the last progress output so that we can avoid unnecessary
    // screen renders.
    static DWORD s_dwProgPercent = -1;

    // Calculate the percentage of the disc that's been handled.
    DWORD dwProgPercent = dwLSN * 100 / g_cSectors;

    // We only need to update if the onscreen display may change
    if (dwProgPercent !=  s_dwProgPercent) {
        DrawMessage(TEXT("Verifying disc"), TEXT("Please wait"));

        // Draw progress bar background
        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_X2 + PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y2 + PROGRESS_BORDER_OUTER_OFFSET,
                          COLOR_BRIGHT_GREEN);

        // Draw progress bar bkgnd
        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_GAP,
                          PROGRESS_Y1 - PROGRESS_BORDER_GAP,
                          PROGRESS_X2 + PROGRESS_BORDER_GAP,
                          PROGRESS_Y2 + PROGRESS_BORDER_GAP,
                          COLOR_BLACK);

        // Draw progress bar
        g_pVideo->DrawBox(PROGRESS_X1,
                          PROGRESS_Y1,
                          PROGRESS_X1 + ((PROGRESS_WIDTH / 100) * dwProgPercent),
                          PROGRESS_Y2,
                          SCREEN_DEFAULT_TEXT_FG_COLOR);

        g_pVideo->ShowScreen();

        s_dwProgPercent = dwProgPercent;
    }
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  OpenDVD
// Purpose:   Sends the appropriate command to the DVD drive commanding it to
//            open.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void OpenDVD()
{
    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
                      SMC_DVD_TRAY_OPERATION_OPEN);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CloseDVD
// Purpose:   Sends the appropriate command to the DVD drive commanding it to
//            close.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CloseDVD()
{
    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
                      SMC_DVD_TRAY_OPERATION_CLOSE);
}

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WaitForAnyButton
// Purpose:   Waits for a button to be pressed.
// UNDONE:    This function was cut-and-paste from recovery.cpp, and as such
//            contains a lot of unnecessary code.  This will eventually be
//            pared down to the minimal required functionality.
//            As a result, this function is left as-is and is uncommented.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void WaitForAnyButton()
{
    DWORD dwNewVideoMode;
    BOOL fYButton;
    PDWORD pdwNewVideoMode = &dwNewVideoMode;
    PBOOL pfYButton = &fYButton;
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    ASSERT(pdwNewVideoMode);
    *pdwNewVideoMode = 0xFFFFFFFF;

    while (!fButtonPressed) {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals)) {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++) {
                if ((1 << i) & dwRemovals) {
                    if (NULL != hPads[i])
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                }

                if ((1 << i) & dwInsertions) {
                    if (NULL == hPads[i])
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++) {
            if ((1 << i) & dwPads) {
                if (NULL != hPads[i]) {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State)) {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
                                *pdwNewVideoMode = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                                *pdwNewVideoMode = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                                *pdwNewVideoMode = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;
                            
                            if (pfYButton)
                                *pfYButton = (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] >
                                                XINPUT_ANALOGBUTTONTHRESHOLD);
                        }
                    }
                }
            }

            if (fButtonPressed || (*pdwNewVideoMode != 0xFFFFFFFF)) {
                fButtonPressed = TRUE;
                break;
            }
        }
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MSBtoLSB
// Purpose:   Converts a big-endian value to little-endian.  Does the same
//            thing as 'ntohl()', which is part of winsock (which the XDK
//            doesn't appear to include).
// Arguments: dwMSB         -- The big-endian value to convert
// Return:    dwLSB         -- The little-endian equivalent of dwMSB
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MSBtoLSB(DWORD dwMSB)
{
    return (((dwMSB & 0xFF000000) >> 24) |
            ((dwMSB & 0x00FF0000) >>  8) |
            ((dwMSB & 0x0000FF00) <<  8) |
            ((dwMSB & 0x000000FF) << 24));
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   Main entry point to application
// Arguments: None 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void __cdecl main()
{
    // szResult     -- Contains result string of the verification process
    TCHAR           szResult[1000];

    // szTemp       -- Temporary string buffer
    TCHAR           szTemp[100];

    // xsum         -- Ongoing checksum of all data on disc (in media region)
    CCheckSum       xsum;

    // fFirstTime   -- true if this is the first disc handled
    bool            fFirstTime = true;
    
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DVDX2_CONTROL_DATA ControlData;
    DVDX2_AUTHENTICATION Authentication;
    PDEVICE_OBJECT DeviceObject;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    OBJECT_ATTRIBUTES oa;
    LARGE_INTEGER liByteOffset;

    // Status vars
    NTSTATUS        Status;
    IO_STATUS_BLOCK ioStatus;
    
    // Initialize core peripheral port support
    XInitDevices(0, NULL);

    // Prepare the SCSI pass through structure.
    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    // Create the video subsytem and background bitmap objects
    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;
    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap)) {
        OutputDebugString(TEXT("Couldn't allocate video objects"));
        Sleep(INFINITE);
    }

    // Initialize the screen and read in the background bitmap
    g_pBackgroundBitmap->read(0, 0, FILE_DATA_IMAGE_DIRECTORY_A "\\backgrnd.bmp");
    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    g_fDone = false;
    // Loop forever.
    while (true) {
        // Ask the user to insert a disc...
        if (fFirstTime) {
			DrawMessage(TEXT("Insert a DVD-X2 disc to verify"),
						TEXT("and then press any button on the controller"));
            fFirstTime = false;
        }
		else
	        DrawMessage(szResult, TEXT("Insert a new disc to verify and ")\
                                  TEXT("press any button"));
        g_pVideo->ShowScreen();

        // Open the tray...
        OpenDVD();

        // ...and wait for them to press a button.
        WaitForAnyButton();

        g_fDone = false;

        DrawMessage(TEXT("Authenticating disc"), TEXT("Please Wait"));
        g_pVideo->ShowScreen();

        // Close the tray
        CloseDVD();

        // Get a reference to the dvd object so that we can query it for info.
        Status = ObReferenceObjectByName((POBJECT_STRING)&DVDDevice, 0,
                                         IoDeviceObjectType, NULL,
                                         (PVOID*)&DeviceObject);
        if (!NT_SUCCESS(Status)) {
            wsprintf(szResult, TEXT("ERROR: Failed to open DVD-X2 reference ") \
                               TEXT("(error 0x%08X)."), Status);
            // Note: Don't "goto done" since we don't want to close the dvd ref
            continue;
        }

        // Request the authentication page from the DVD-X2 drive.
        OutputDebugString(TEXT("\r\nRequesting Authentication Data...\r\n"));
        
        RtlZeroMemory(&Authentication, sizeof(DVDX2_AUTHENTICATION));
        RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
        PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
        PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
        PassThrough.DataBuffer = &Authentication;
        PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);
        
        RtlZeroMemory(Cdb, sizeof(CDB));
        Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
        Cdb->MODE_SENSE10.PageCode      = DVDX2_MODE_PAGE_AUTHENTICATION;
        *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
              (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

        Sleep(20000);

Read1:
        Status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
            DeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), NULL, 0,
            NULL, FALSE);

        if (!NT_SUCCESS(Status)) {

            //
            // If the drive reported back an authentication failure at this point,
            // then change the error to STATUS_UNRECOGNIZED_MEDIA to help
            // distinguish between a disc that doesn't contain any anti-piracy
            // protection from a disc that failed the anti-piracy checks below.
            //
            switch(Status) {
            case STATUS_DEVICE_NOT_READY:
                OutputDebugString(TEXT("Device wasn't ready to read auth data - Sleeping 1/2 second...\r\n"));
                Sleep(500);
                goto Read1;

            case STATUS_TOO_MANY_SECRETS:
                wsprintf(szResult, TEXT("ERROR: Too many secrets."));
                goto done;

            case STATUS_UNRECOGNIZED_MEDIA:
                wsprintf(szResult, TEXT("ERROR: Unrecognized media."));
                goto done;
            
            case STATUS_NO_MEDIA_IN_DEVICE:
                wsprintf(szResult, TEXT("ERROR: No media in device."));
                goto done;
            
            default:
                wsprintf(szResult, TEXT("ERROR: Failed to get auth data ") \
                                   TEXT("(error 0x%08X)."), Status);
                goto done;
            }
        }

        OutputDebugString(TEXT("Obtained Authentication Data...\r\n"));


        // Check if the DVD-X2 drive thinks that this is a valid CDF header.
        if (Authentication.AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
            wsprintf(szResult, TEXT("ERROR: Unrecognized media"));
            goto done;
        }



        // Request the xcontrol region from the drive. this is necessary to
        // obtain the desired drive geometry -- we need to determine how many
        // sectors are present on the disc.
        OutputDebugString(TEXT("Requesting XControl Data...\r\n"));

        PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
        PassThrough.DataBuffer = &ControlData;
        PassThrough.DataTransferLength = sizeof(DVDX2_CONTROL_DATA);

        RtlZeroMemory(Cdb, sizeof(CDB));
        Cdb->READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
        *((PUSHORT)&Cdb->READ_DVD_STRUCTURE.AllocationLength) = (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_CONTROL_DATA));
        *((PULONG)Cdb->READ_DVD_STRUCTURE.RMDBlockNumber)     = IdexConstantUlongByteSwap((ULONG)(~DVDX2_CONTROL_DATA_BLOCK_NUMBER));
        Cdb->READ_DVD_STRUCTURE.LayerNumber = (UCHAR)(~DVDX2_CONTROL_DATA_LAYER);
        Cdb->READ_DVD_STRUCTURE.Format      = DvdPhysicalDescriptor;
        Cdb->READ_DVD_STRUCTURE.Control     = 0xC0;
Read:
        Status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
                  DeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
                  NULL, 0, NULL, FALSE);

        if (!NT_SUCCESS(Status)) {
            switch(Status) {
            case STATUS_DEVICE_NOT_READY:
                OutputDebugString(TEXT("Device wasn't ready to read xcontrol")\
                                  TEXT(" - Sleeping 1/2 second...\r\n"));
                Sleep(500);
                goto Read;

            case STATUS_UNRECOGNIZED_MEDIA:
                wsprintf(szResult, TEXT("ERROR: Unrecognized media."));
                goto done;
            
            case STATUS_NO_MEDIA_IN_DEVICE:
                wsprintf(szResult, TEXT("ERROR: No media in device."));
                goto done;
            
            default:
                wsprintf(szResult, TEXT("ERROR: Failed to get xcontrol ") \
                                   TEXT("(error 0x%08X)."), Status);
                goto done;
            }
        }

        if (!AuthenticateDisc(Authentication, ControlData, DeviceObject, szResult))
            goto done;

        // If here, then authentication succeeded and szResult contains the 
        // type of disc signature (red or green). Store it away for later display
        wcscpy(g_szSignature, szResult);
        wsprintf(szResult, TEXT("Disc signature: %s\r\n"), g_szSignature);
        OutputDebugString(szResult);

        DrawMessage(TEXT("Verifying disc"), TEXT("Please Wait"));
        g_pVideo->ShowScreen();
        OutputDebugString(TEXT("Disc authenticated!\r\n"));
        
        // Calculate the total number of bytes in the media region
        // The data returned from the dvd drive is in MSB format; we need it in
        // LSB, so convert now
        DWORD dwLayer0Start = MSBtoLSB(ControlData.LayerDescriptor.StartingDataSector);
        DWORD dwLayer0End   = MSBtoLSB(ControlData.LayerDescriptor.EndLayerZeroSector);
        DWORD dwLayer1Start = 0xFFFFFF ^ dwLayer0End;
        DWORD dwLayer1End   = MSBtoLSB(ControlData.LayerDescriptor.EndDataSector);
        
        g_cSectors = (dwLayer0End - dwLayer0Start + 1)  + (dwLayer1End - dwLayer1Start + 1); 
        wsprintf(szResult, TEXT("Sectors on dvd: %d\r\n"), g_cSectors);
        OutputDebugString(szResult);

        // Read the version info of tools (xbLayout, xbPremaster) used to
        // generate this disc
        liByteOffset.QuadPart = 33 * 2048;  // Location of version info
        Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                                         &g_verinfo, ONE_SECTOR,&liByteOffset);
        if (!NT_SUCCESS(Status)) {
            // Failed to read the block containing the version information
            wsprintf(szResult, TEXT("Error (0x%08X) reading version data"), 
                               Status);
            goto done;
        }
        g_fVersionValid = !memcmp(g_verinfo.rgbySig, VERSION_SIG,
                                  sizeof(VERSION_SIG));
        if (g_fVersionValid)
        {
            wsprintf(g_szLayoutVersion, TEXT("xbLayout version: %d.%d.%d.%d"),
                   *(WORD*)&g_verinfo.rgbyLayoutVersion[0],
                   *(WORD*)&g_verinfo.rgbyLayoutVersion[2],
                   *(WORD*)&g_verinfo.rgbyLayoutVersion[4],
                   *(WORD*)&g_verinfo.rgbyLayoutVersion[6]);
            wsprintf(g_szPremasterVersion, TEXT("xbPremaster version: %d.%d.%d.%d"),
                   *(WORD*)&g_verinfo.rgbyPremasterVersion[0],
                   *(WORD*)&g_verinfo.rgbyPremasterVersion[2],
                   *(WORD*)&g_verinfo.rgbyPremasterVersion[4],
                   *(WORD*)&g_verinfo.rgbyPremasterVersion[6]);
        }

        // Read all data on the disc, calculating the green checksum as we go.
        BYTE rgby[ONE_SECTOR * SECTOR_BATCH];
        DWORD dwSector = 0;
        int i = 0, cPlaceholders = 0;
        g_dwTimeStart = GetTickCount();
        while (dwSector < g_cSectors) {
            // Debugging output
            if (((i++)%1000) == 0)
            {
                wsprintf(szTemp, TEXT("Sector %d  (xsum = 0x%08X)\r\n"),
                         dwSector, xsum.DwRunningSum());
                OutputDebugString(szTemp);
            }
            
            // Read the next batch of sectors.
            DWORD dwSectorsToRead = min(SECTOR_BATCH, g_cSectors - dwSector);
            liByteOffset.QuadPart = (__int64)dwSector * ONE_SECTOR;
            Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                                             rgby, ONE_SECTOR*dwSectorsToRead,
                                             &liByteOffset);
            if (!NT_SUCCESS(Status)) {
                if (Status != STATUS_INVALID_DEVICE_REQUEST) {
                    wsprintf(szResult, TEXT("Error (0x%08X) reading sector %d"), 
                                       Status, dwSector);
                    goto done;
                }

                // Failed to read a batch.  Assumption is because there's a
                // placeholder somewhere in the batch (or we're near the end of
                // the disc).  We're not sure where the read failed in there,
                // so we reread one sector at a time; the first one that fails
                // is the start of the placeholder.
                wsprintf(szTemp, TEXT("Failed to read batch at %d (Error 0x%08X). Reading")\
                                 TEXT(" per-sector: "), dwSector, Status);
                OutputDebugString(szTemp);

                int iSector = 0;
                while(dwSector < g_cSectors) {
                    // Sanity check - we should never read more than
                    // SECTOR_BATCH blocks in this inner loop.
                    assert (iSector < SECTOR_BATCH);

                    OutputDebugString(TEXT("."));
                    Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                                                     rgby, ONE_SECTOR,
                                                     &liByteOffset);
                    if (!NT_SUCCESS(Status)) {
                        if (Status != STATUS_INVALID_DEVICE_REQUEST) {
                            wsprintf(szResult, TEXT("Error (0x%08X) reading sector %d"), 
                                     Status, dwSector);
                            goto done;
                        }

                        // Failed to read the sector - this must be the PH!

                        // Do basic verification that it's not a disc error by
                        // verifying that the data at 'dwSector + 4095' is not
                        // readable, and 'dwSector + 4096' is.
                        LARGE_INTEGER liTemp = liByteOffset;
                        liTemp.QuadPart += 4095 * 2048;
                        Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                                                         rgby, ONE_SECTOR,
                                                         &liTemp);
                        if (NT_SUCCESS(Status)) {
                            // Successfully read the sector 4095 sectors after
                            // the start of the presumed placeholder -- therefore
                            // it's not a placeholder!
                            wsprintf(szTemp, TEXT("\r\nDisc error found ")
                                             TEXT("at sector 0x%06X\r\n"),
                                             dwSector);
                            OutputDebugString(szTemp);
                            wsprintf(szResult, TEXT("Disc error 1 found at sector 0x%06X"), 
                                     dwSector);
                            goto done;
                        }

                        // Verify the next sector (dwSector + 4096) is readable
                        liTemp.QuadPart += 2048;
                        Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                                                         rgby, ONE_SECTOR,
                                                         &liTemp);
                        if (!NT_SUCCESS(Status)) {
                            // Failed to read the sector 4096 sectors after
                            // the start of the presumed placeholder -- 
                            // therefore it's not a placeholder!
                            wsprintf(szTemp, TEXT("\r\nDisc error found ")
                                             TEXT("at sector 0x%06X\r\n"),
                                             dwSector);
                            OutputDebugString(szTemp);
                            wsprintf(szResult, TEXT("Disc error 2 found at sector 0x%06X"), 
                                     dwSector);
                            goto done;
                        }

                        // increment the placeholder count -- if there're more
                        // than 16, then an error occurred somewhere
                        cPlaceholders++;
                        if (cPlaceholders > 16)
                        {
                            wsprintf(szTemp, TEXT("\r\nToo many placeholders ")
                                             TEXT("determined at sector ")
                                             TEXT("0x%06X\r\n"), dwSector);
                            OutputDebugString(szTemp);
                            wsprintf(szResult, TEXT("Disc error 3 found at sector 0x%06X"), 
                                     dwSector);
                            goto done;
                        }

                        // If here, then it's a placeholder -- skip it
                        wsprintf(szTemp, TEXT("\r\nFailed to read block %d ")\
                                         TEXT("from DVD-X2.  Skipping to ") \
                                         TEXT("%d\r\n"), dwSector,
                                         dwSector + 4096);
                        OutputDebugString(szTemp);
                        dwSector += 4096;
                        break;
                    }

                    // successfully read the sector.  Checksum the data
                    xsum.SumBytes(rgby, ONE_SECTOR);
                    liByteOffset.QuadPart += ONE_SECTOR;
                    dwSector++;
                    iSector++;
                }
            } else {
                // Checksum the data
                xsum.SumBytes(rgby, ONE_SECTOR * dwSectorsToRead);

                // Update the progress bar
                UpdateProgress(dwSector);

                // Track how many sectors we just processed
                dwSector += dwSectorsToRead;
            }
        }

        // Generate the checksum string for display
        wsprintf(szResult, TEXT("Xbox Media CRC: 0x%08X"), xsum.DwFinalSum());

        // Output diagnostic info to kd
        wsprintf(szTemp, TEXT("Finished checksum:  %d sectors read, xsum=0x%08X\r\n"),
                 dwSector, xsum.DwFinalSum());
        OutputDebugString(szTemp);

done:
        // No longer need the reference to the dvd device, so release it.
        ObDereferenceObject(DeviceObject);

        // Reset the checksum for the next disc
        xsum.Reset();
        
		// Loop back around to output the message and wait for the next disc.
        g_fDone = true;
    }

    // We should never get here.  Cleanup anyways
    if (g_pVideo)
        delete g_pVideo;
    if (g_pBackgroundBitmap)
        delete g_pBackgroundBitmap;

    ASSERT(false);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName )
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Under UMA emulation, we copy the data from AGP memory to video memory.
    // This will not be necessary with final hardware
    D3D_CopyContiguousMemoryToVideo( m_pVidMemData );

    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\xcbase.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcbase.c

Abstract:

    Contains implementation of base level crypto function

--*/

#include <windows.h>
#include <assert.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>
#include <benaloh.h>

#include "des.h"
#include "tripldes.h"
#include "modes.h"

//
// Reverse ASN.1 Encodings of possible hash identifiers.  
//
static PBYTE shaEncodings[] = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" };

VOID
XCCalcDigest(
    IN  PBYTE   pbMsgData,
    IN  DWORD   dwMsgDataLen,
    IN  PBYTE   pbDigest
    )
/*++

Routine Description:

    This function calculates a digest (hash) for the given daata

Arguments:

Return Value:

    None

--*/
{
    A_SHA_CTX   SHAHash;
    BYTE        abSHADigest[A_SHA_DIGEST_LEN];

    XcSHAInit((PUCHAR)&SHAHash);
    XcSHAUpdate((PUCHAR)&SHAHash, (PBYTE)&dwMsgDataLen, sizeof(DWORD));
    XcSHAUpdate((PUCHAR)&SHAHash, pbMsgData, dwMsgDataLen);
    XcSHAFinal((PUCHAR)&SHAHash, abSHADigest);

    memcpy(pbDigest, abSHADigest, A_SHA_DIGEST_LEN);
}

BOOL XCVerifyPKCS1SigningFmt(
    IN  BSAFE_PUB_KEY* pKey,
    IN  BYTE* pbDigest,
    IN  BYTE* pbPKCS1Format
    )
{
    BYTE**    rgEncOptions;
    BYTE      rgbTmpHash[A_SHA_DIGEST_LEN + 16];
    DWORD     i;
    DWORD     cb;
    BYTE*     pbStart;
    DWORD     cbTmp;

    rgEncOptions = shaEncodings;

    // 
    // reverse the hash to match the signature.
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        rgbTmpHash[i] = pbDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    // 
    // see if it matches.
    //
    if (memcmp(rgbTmpHash, pbPKCS1Format, A_SHA_DIGEST_LEN)) {
        return FALSE;
    }

    cb = A_SHA_DIGEST_LEN;

    //
    // check for any signature type identifiers
    //
    for (i = 0; 0 != *rgEncOptions[i]; i += 1) {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp)) {
            // adjust the end of the hash data. 
            cb += cbTmp;   
            break;
        }
    }

    // 
    // check to make sure the rest of the PKCS #1 padding is correct
    //
    if ((0x00 != pbPKCS1Format[cb]) || (0x00 != pbPKCS1Format[pKey->datalen]) ||
         (0x1 != pbPKCS1Format[pKey->datalen - 1])) {
        return FALSE;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++) {
        if (0xff != pbPKCS1Format[i]) {
            return FALSE;
        }
    }

    return TRUE;
}



DWORD
XCCalcSigSize(
    IN  PBYTE  pbPrivateKey
    )
/*++

Routine Description:

    Calculates size of the signature based on the private key

Arguments:

Return Value:

    Size of the signature

--*/
{
    LPBSAFE_PRV_KEY pPrvKey = (LPBSAFE_PRV_KEY)pbPrivateKey;

    return (pPrvKey->bitlen + 7) / 8;
}


DWORD
XCCalcKeyLen(
    IN  PBYTE  pbPublicKey
    )
/*++

Routine Description:

    Calculates the keylen stored in the key

Arguments:

Return Value:

    Returns the value of keylen 

--*/
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;

    return pPubKey->keylen;
}




BOOLEAN
XCVerifyDigest(
    IN   PBYTE   pbSig,
    IN   PBYTE   pbPublicKey,
    IN   PBYTE   pbWorkspace,
    IN   PBYTE   pbCompareDigest
    )
/*++

Routine Description:

    This function decrypts and verifies a digest (hash) with the given public key

Arguments:

    pbSig - Supplies the encrypted signature

    pbPublicKey - Supplies a pointer to the public key data

    pbWorkspace - Supplies a buffer to be used as workspace.  This
                  must be at least 2 * keylen

    pbCompareDigest - Supplies the digest to compare 


Return Value:

    TRUE if signature matches, FALSE otherwise

--*/
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;
    PBYTE           pbOutput;
    PBYTE           pbInput;
    DWORD           dwSigLen;

    dwSigLen = (pPubKey->bitlen + 7) / 8;

    pbOutput = pbWorkspace;
    pbInput = (PBYTE)((ULONG_PTR)pbWorkspace + pPubKey->keylen);

    memset(pbInput, 0, pPubKey->keylen);
    memcpy(pbInput, pbSig, dwSigLen);

    if (!XcPKEncPublic((PUCHAR)pPubKey, pbInput, pbOutput)) {
        return FALSE;
    }


    if (!XCVerifyPKCS1SigningFmt(pPubKey, pbCompareDigest, pbOutput)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\dvdverify\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "recovpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

    // Always do interlaced output on an HDTV.
    if (XGetAVPack() == XC_AV_PACK_HDTV)
    {
        d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;
    }

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Background_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\Installer.cpp ===
//-----------------------------------------------------------------------------
// File: Installer.cpp
//
// Desc: 
//
// Hist: 04.18.01 - New for CliffG
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include "xtl.h"
#include "ntos.h"
#include <scsi.h>
#include <stdio.h>
#include <xdbg.h>
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
#include "xboxverp.h"
#include "xconfig.h"
#include "xboxp.h"
#include "xdisk.h"
#include "XBFont.h"
#include "XBUtil.h"
#include "Resource.h"

//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
#ifdef E3
COBJECT_STRING CDrive = CONSTANT_OBJECT_STRING(OTEXT("\\??\\C:"));
COBJECT_STRING CHdPartition1 = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\"));
#endif

COBJECT_STRING EDrive = CONSTANT_OBJECT_STRING(OTEXT("\\??\\E:"));
COBJECT_STRING EHdPartition1 = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\DEVKIT"));

COBJECT_STRING TDrive = CONSTANT_OBJECT_STRING(OTEXT("\\??\\T:"));
COBJECT_STRING THdPartition1 = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\TDATA"));

COBJECT_STRING UDrive = CONSTANT_OBJECT_STRING(OTEXT("\\??\\U:"));
COBJECT_STRING UHdPartition1 = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\UDATA"));

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 20

#ifdef E3
void SetLaunchTitle(void);
#endif

void DrawProgressBar(int);
BOOL EnumFiles(PCOSTR pcszSrcPath);
BOOL CopyFiles(PCOSTR pcszSrcPath, PCOSTR pcszDestPath);

_int64 g_cBytesToCopy = 0;
_int64 g_cBytesCopied = 0;
int g_cFilesToCopy = 0;
int g_cFilesCopied = 0;

bool g_bHasFiles = true;
bool g_bHasTData = true;
bool g_bHasUData = true;

static const WCHAR* g_RStrings[] =
	{
	// RS_WELCOME
	L"This program is about to install files\nonto your Xbox. Press any button to\nbegin copying files.",

	// RS_ERROR_INVALID_MEDIA
	L"This demo disk is not configured properly\nThe Xbox Installer could not find\nany files to copy.\n\nPress and gamepad button to reboot.\n",

	// RS_PREPARING_COPY
	L"Preparing to copy files...",

	// RS_WARN_INSUFFICIENT_DISKSPACE
	L"Your Xbox hard drive may not have\nsufficient disk space for this installation.\nIf you are upgrading an existing set\nof files, this install may succeed.\n\nPress any gamepad button to continue",

	// RS_ERROR_COPY_FAILED
	L"File copy has failed!\n\nThis can be caused by several problems:\n   1) insufficient hard disk space\n   2) corrupt files or media\n   3) invalid file timestamps\n\nPress any gamepad button to reboot",

	// RS_EJECTING_DVD
	L"Ejecting DVD Drive...",

	// RS_COPY_COMPLETE
	L"File copy is complete. Please remove\nthe disk and press any gamepad button\nto reboot the Xbox.",

	// RS_XBOX_VERSION
	L"Xbox version %hs",

	// RS_COPYING
	L"Copying files to the hard disk...\n\nCurrently copying:\n%S"
	};

enum STR_INDEX
	{
    RS_WELCOME = 0,
	RS_ERROR_INVALID_MEDIA,
	RS_PREPARING_COPY,
	RS_WARN_INSUFFICIENT_DISKSPACE,
	RS_ERROR_COPY_FAILED,
	RS_EJECTING_DVD,
	RS_COPY_COMPLETE,
	RS_XBOX_VERSION,
	RS_COPYING
	};

//-----------------------------------------------------------------------------
// Global rendering variables
//-----------------------------------------------------------------------------
LPDIRECT3D8        g_pD3D               = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice         = NULL;
LPDIRECT3DTEXTURE8 g_pBackgroundTexture = NULL;
CXBPackedResource  g_xprResource;
CXBFont            g_Font;

// Global instance of gamepad devices
HANDLE g_hGamepads[4];


//-----------------------------------------------------------------------------
// Name: InitGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT HrInitGamepads(void)
	{

    XDEVICE_PREALLOC_TYPE deviceTypes[] =
		{
			{XDEVICE_TYPE_GAMEPAD, 4},
			{XDEVICE_TYPE_MEMORY_UNIT, 2}
		};

    // Initialize core peripheral port support
    XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);

    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Open the devices
    for (DWORD i=0; i<XGetPortCount(); i++)
		{
		if (dwDeviceMask & (1 << i)) 
            g_hGamepads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL);
        else
            g_hGamepads[i] = NULL;
		}

    return S_OK;
	}

//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT HrInitD3D(void)
	{
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    g_pD3D = Direct3DCreate8( D3D_SDK_VERSION );
	if (!g_pD3D)
		{
		OutputDebugString("Error: Couldn't create Direct3D\n");
		return E_FAIL;
		}

    if (FAILED(g_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pd3dDevice)))
		{
		OutputDebugString("Error: Couldn't create Direct3D device\n");
        return E_FAIL;
		}

    return S_OK;
	}

HRESULT HrLoadResources(void)
	{
	HRESULT hr;

    if (FAILED(hr = g_Font.Create(g_pd3dDevice, "Font.xpr")))
		{
        OutputDebugString("ERROR: Could not find Font.xpr\n");
        return hr;
		}

    if (FAILED(hr = g_xprResource.Create(g_pd3dDevice, "Resource.xpr", resource_NUM_RESOURCES)))
		{
        OutputDebugString("ERROR: Could not find Resource.xpr\n");
        return hr;
		}
    g_pBackgroundTexture = g_xprResource.GetTexture(resource_Background_OFFSET);

	return S_OK;
	}

//-----------------------------------------------------------------------------
// Name: DrawMessage()
// Desc: 
//-----------------------------------------------------------------------------
void DrawMessage(const WCHAR* str, int lProgress)
	{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB = NULL;
    
	if (g_pVB == NULL)
		{
        g_pd3dDevice->CreateVertexBuffer(4 * 5 * sizeof(FLOAT), D3DUSAGE_WRITEONLY, 0L, D3DPOOL_DEFAULT, &g_pVB);
        
		struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };

        BACKGROUNDVERTEX *v;

        g_pVB->Lock(0, 0, (BYTE**)&v, 0);
        v[0].p = D3DXVECTOR4(  0,   0, 1.0f, 1.0f); v[0].tu = 0.0f; v[0].tv = 0.0f; 
        v[1].p = D3DXVECTOR4(640,   0, 1.0f, 1.0f); v[1].tu = 639.0f; v[1].tv = 0.0f; 
        v[2].p = D3DXVECTOR4(  0, 480, 1.0f, 1.0f); v[2].tu = 0.0f; v[2].tv = 479.0f; 
        v[3].p = D3DXVECTOR4(640, 480, 1.0f, 1.0f); v[3].tu = 639.0f; v[3].tv = 479.0f; 
        g_pVB->Unlock();
		}

    // Set states
    g_pd3dDevice->SetTexture(0, g_pBackgroundTexture);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP);
    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX1);
    g_pd3dDevice->SetStreamSource(0, g_pVB, 6 * sizeof(FLOAT));

    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// Show version
	WCHAR szBuildString[80];

	wsprintfW(szBuildString, g_RStrings[RS_XBOX_VERSION], VER_PRODUCTVERSION_STR);
    g_Font.DrawText(190.0f, 356.0f, 0xFFFFFFA4, szBuildString);

    // Show text
    FLOAT fXStart = 115.0f;
    FLOAT fYStart = 135.0f;

    g_Font.DrawText(fXStart, fYStart, 0xFFFFFFA4, str);

	if (lProgress >= 0)
		DrawProgressBar(lProgress);

	g_pd3dDevice->Present(NULL, NULL, NULL, NULL);
	}

void DrawProgressBar(int lProgress)
	{
    // First time around, allocate a vertex buffer
	static LPDIRECT3DVERTEXBUFFER8 g_pvbProgress = NULL;
	struct BACKGROUNDVERTEX { D3DXVECTOR4 p; DWORD color; };
    BACKGROUNDVERTEX *v;

	if (g_pvbProgress == NULL)
        g_pd3dDevice->CreateVertexBuffer(4 * 5 * sizeof(FLOAT), D3DUSAGE_WRITEONLY, 0L, D3DPOOL_DEFAULT, &g_pvbProgress);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

	// Draw the progress container first    
    g_pvbProgress->Lock(0, 0, (BYTE**)&v, 0);
    v[0].p = D3DXVECTOR4(211, 276, 1.0f, 1.0f); v[0].color = 0xFF73C034; 
    v[1].p = D3DXVECTOR4(428, 276, 1.0f, 1.0f); v[1].color = 0xFF73C034; 
    v[2].p = D3DXVECTOR4(211, 324, 1.0f, 1.0f); v[2].color = 0xFF73C034; 
    v[3].p = D3DXVECTOR4(428, 324, 1.0f, 1.0f); v[3].color = 0xFF73C034; 
    g_pvbProgress->Unlock();
	g_pd3dDevice->SetStreamSource(0, g_pvbProgress, sizeof(BACKGROUNDVERTEX));
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// Then, clear the inside of the progress container first    
    g_pvbProgress->Lock(0, 0, (BYTE**)&v, 0);
    v[0].p = D3DXVECTOR4(215, 280, 1.0f, 1.0f); v[0].color = 0xFF000000; 
    v[1].p = D3DXVECTOR4(424, 280, 1.0f, 1.0f); v[1].color = 0xFF000000; 
    v[2].p = D3DXVECTOR4(215, 320, 1.0f, 1.0f); v[2].color = 0xFF000000; 
    v[3].p = D3DXVECTOR4(424, 320, 1.0f, 1.0f); v[3].color = 0xFF000000; 
    g_pvbProgress->Unlock();
	g_pd3dDevice->SetStreamSource(0, g_pvbProgress, sizeof(BACKGROUNDVERTEX));
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// Finally, draw the actual progress bar
    g_pvbProgress->Lock(0, 0, (BYTE**)&v, 0);
    v[0].p = D3DXVECTOR4(217, 282, 1.0f, 1.0f); v[0].color = 0xFFFFFFA4; 
    v[1].p = D3DXVECTOR4((FLOAT)(217 + (205 * lProgress) / 100), 282, 1.0f, 1.0f); v[1].color = 0xFFFFFFA4; 
    v[2].p = D3DXVECTOR4(217, 318, 1.0f, 1.0f); v[2].color = 0xFFFFFFA4; 
    v[3].p = D3DXVECTOR4((FLOAT)(217 + (205 * lProgress) / 100), 318, 1.0f, 1.0f); v[3].color = 0xFFFFFFA4; 
    g_pvbProgress->Unlock();
	g_pd3dDevice->SetStreamSource(0, g_pvbProgress, sizeof(BACKGROUNDVERTEX));
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
	}

BOOL FIsAButtonDown(void)
	{
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
		{
        dwPads |= dwInsertions;
        dwPads &= ~dwRemovals;

        for (i = 0; i < XGetPortCount(); i++)
			{
            if ((1 << i) & dwRemovals)
				{
                if (NULL != hPads[i])
					{
                    XInputClose(hPads[i]);
                    hPads[i] = NULL;
					}
				}

            if ((1 << i) & dwInsertions)
				{
                if (NULL == hPads[i])
                    hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
	            }
		    }
		}

    for (i = 0; i < XGetPortCount(); i++)
		{
        if ((1 << i) & dwPads)
			{
            if (NULL != hPads[i])
				{
                XINPUT_STATE State;

                if (ERROR_SUCCESS == XInputGetState(hPads[i], &State))
					{
                    if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                             (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                             (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                             (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                             (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                             (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                             (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        return TRUE;
	                }
		        }
			}
		}

	return FALSE;
	}

void WaitForAnyButton(void)
	{
	if (FIsAButtonDown())
		while (FIsAButtonDown());
	while (!FIsAButtonDown());
	}

//-----------------------------------------------------------------------------
// Name: EjectDVD()
// Desc: 
//-----------------------------------------------------------------------------
void EjectDVD(void)
	{
    HANDLE hDevice;
    hDevice = CreateFile(OTEXT("CdRom0:"), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hDevice)
		{
        SCSI_PASS_THROUGH_DIRECT PassThrough;
        DWORD cbBytes;
        PCDB Cdb;
        SENSE_DATA SenseData;

        RtlZeroMemory(&PassThrough, sizeof(PassThrough));

        PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
        PassThrough.DataIn = SCSI_IOCTL_DATA_IN;

        Cdb = (PCDB)&PassThrough.Cdb;

        Cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
        Cdb->START_STOP.LoadEject = 1;
        Cdb->START_STOP.Start = 0;

        DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(PassThrough), &SenseData, sizeof(SenseData), &cbBytes, NULL);
        CloseHandle(hDevice);
		}
    else
		{
        OutputDebugString("EjectDVD() could not open DVD device\n");
	    }
	}

BOOL EnumFiles(PCOSTR pcszSrcPath)
	{
    WIN32_FIND_DATA wfd;
    BOOL bRet = FALSE;
	int nSrcLen = ocslen(pcszSrcPath);
    HANDLE hFind = FindFirstFile(pcszSrcPath, &wfd);
	_int64 i64FileSize;

    if (INVALID_HANDLE_VALUE != hFind)
	    {
        OCHAR szSrcFile[MAX_PATH];
		ocscpy(szSrcFile, pcszSrcPath);
        do
			{
			i64FileSize = wfd.nFileSizeHigh;
			i64FileSize <<= 32;
			i64FileSize += wfd.nFileSizeLow;
			g_cBytesToCopy += i64FileSize;

            lstrcpynO(&(szSrcFile[nSrcLen - 1]), wfd.cFileName, ARRAYSIZE(szSrcFile) - (nSrcLen - 1));
                     
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
                int nFileLen = ocslen(wfd.cFileName);

                lstrcpynO(&(szSrcFile[nSrcLen + nFileLen - 1]), OTEXT("\\*"), ARRAYSIZE(szSrcFile) - (nSrcLen + nFileLen - 1));
                bRet = EnumFiles(szSrcFile);
                if (!bRet)
                    break;
				}
            else
	            {
				g_cFilesToCopy++;
				bRet = TRUE;
				}
			} while (FindNextFile(hFind, &wfd));
        
        FindClose(hFind);
		}
    else if (ERROR_FILE_NOT_FOUND == GetLastError())
	    {
        OutputDebugString("FindFirstFile error FILE_NOT_FOUND\n");
        bRet = TRUE;
	    }

    return bRet;
	}

//-----------------------------------------------------------------------------
// Name: CopyFiles()
// Desc: Copies files from a source path to a destination path. The source path
//       is a filter that can be passed to FindFirstFile() and is currently
//       required to end in "<\\*>".  The destination path should end with a 
//       trailing backslash ('\')
//-----------------------------------------------------------------------------
WCHAR g_szCopyText[512];

BOOL CopyFiles(PCOSTR pcszSrcPath, PCOSTR pcszDestPath)
	{
    WIN32_FIND_DATA wfd;
    BOOL bRet = FALSE;
    int nSrcLen = ocslen(pcszSrcPath);
    int nDestLen = ocslen(pcszDestPath);
    HANDLE hFind = FindFirstFile(pcszSrcPath, &wfd);
    _int64 i64FileSize;

    if (INVALID_HANDLE_VALUE != hFind)
		{
        OCHAR szSrcFile[MAX_PATH], szDestFile[MAX_PATH];
        ocscpy(szSrcFile, pcszSrcPath);
        ocscpy(szDestFile, pcszDestPath);

        do
			{
            lstrcpynO(&(szSrcFile[nSrcLen - 1]), wfd.cFileName, ARRAYSIZE(szSrcFile) - (nSrcLen - 1));
            lstrcpynO(&(szDestFile[nDestLen]), wfd.cFileName, ARRAYSIZE(szDestFile) - nDestLen);
                     
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
                int nFileLen = ocslen(wfd.cFileName);
                
                bRet = CreateDirectory(szDestFile, NULL);
				HRESULT hr = GetLastError();
                if ((bRet == 0) && (ERROR_ALREADY_EXISTS != hr))
                    break;

                lstrcpynO(&(szSrcFile[nSrcLen + nFileLen - 1]), OTEXT("\\*"), ARRAYSIZE(szSrcFile) - (nSrcLen + nFileLen - 1));
                lstrcpynO(&(szDestFile[nDestLen + nFileLen]), OTEXT("\\"), ARRAYSIZE(szDestFile) - (nDestLen + nFileLen));

                bRet = CopyFiles(szSrcFile, szDestFile);
                if (!bRet)
                    break;
	            }
            else
		        {
				int PercentageDone;

				// Bytes completed
				PercentageDone = (int)(((double)g_cBytesCopied / (double)g_cBytesToCopy) * 100.0);
				
				// Files completed
				//PercentageDone = (int)(((float)g_cFilesCopied / (float)g_cFilesToCopy) * 100.0f)

                DrawMessage(g_szCopyText, PercentageDone);
                bRet = CopyFile(szSrcFile, szDestFile, FALSE);
				g_cFilesCopied++;

				i64FileSize = wfd.nFileSizeHigh;
				i64FileSize <<= 32;
				i64FileSize += wfd.nFileSizeLow;
				g_cBytesCopied += i64FileSize;
                
				//
                // Files coming off of CD/DVD end up read-only, so clear
                // all of the attributes.. (otherwise dosnet won't work)
                //
                SetFileAttributes(szDestFile, FILE_ATTRIBUTE_NORMAL);
                if (!bRet)
                    break;

				wsprintfW(g_szCopyText, g_RStrings[RS_COPYING], wfd.cFileName);
	            }
			} while (FindNextFile(hFind, &wfd));
			FindClose(hFind);
		}
    else if (ERROR_FILE_NOT_FOUND == GetLastError())
		{
        OutputDebugString("FindFirstFile error FILE_NOT_FOUND\n");
        bRet = TRUE;
	    }
	
    return bRet;
	}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
	{
    WIN32_FIND_DATA wfd;
	HANDLE hFind;
    
	// Initialize Direct3D & Backround Image
    if (FAILED(HrInitD3D()))
        return;
    
	if (FAILED(HrLoadResources()))
		return;

    // Initialize gamepads
    if (FAILED(HrInitGamepads()))
        return;

	hFind = FindFirstFile(OTEXT("D:\\Files"), &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		{
		OutputDebugString("Info: No E: files\n");
		g_bHasFiles = false;
		}
	else
		{
		OutputDebugString("Info: Has E: files\n");
		FindClose(hFind);
		}

	// ensure that the disc has a "TDATA" directory
	hFind = FindFirstFile(OTEXT("D:\\TDATA"), &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		{
		OutputDebugString("Info: No T: files\n");
		g_bHasTData = false;
		}
	else
		{
		OutputDebugString("Info: Has T: files\n");
		FindClose(hFind);
		}

	// ensure that the disc has a "UDATA" directory
	hFind = FindFirstFile(OTEXT("D:\\UDATA"), &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		{
		OutputDebugString("Info: No U: files\n");
		g_bHasUData = false;
		}
	else
		{
		OutputDebugString("Info: Has U: files\n");
		FindClose(hFind);
		}

	// make sure that the disc has something to copy
	if (!g_bHasFiles && !g_bHasTData && !g_bHasUData)
		{
		DrawMessage(g_RStrings[RS_ERROR_INVALID_MEDIA], -1);
		OutputDebugString("Error: no files on the disc to copy\n");
		WaitForAnyButton();
		XLaunchNewImage(NULL, NULL);
		}

#ifdef E3
	// Mount the C: drive
    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING)&CDrive, (POBJECT_STRING)&CHdPartition1)))
		{
        OutputDebugString("Error: Could not map a drive letter to partition1\n");
        return;
		}
#endif

    // Mount the E: drive
	if (g_bHasFiles)
		{
		OutputDebugString("Mounting the E: drive\n");
		if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING)&EDrive, (POBJECT_STRING)&EHdPartition1)))
			{
			OutputDebugString("ERROR: Could not map a drive letter to partition1\n");
			return;
			}
		}

    // Mount the T: drive
    if (g_bHasTData)
		{
		OutputDebugString("Mounting the T: drive\n");
		if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING)&TDrive, (POBJECT_STRING)&THdPartition1)))
			{
			OutputDebugString("ERROR: Could not map a drive letter to partition1\n");
			return;
			}
		}

	// Mount the U: drive
    if (g_bHasUData)
		{
		OutputDebugString("Mounting the U: drive\n");
		if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING)&UDrive, (POBJECT_STRING)&UHdPartition1)))
			{
			OutputDebugString("ERROR: Could not map a drive letter to partition1\n");
			return;
			}
		}

    // Put up the initial screen
	OutputDebugString("Displaying the welcome screen\n");
    DrawMessage(g_RStrings[RS_WELCOME], -1);
	WaitForAnyButton();

	// enumerate all of the files on the disc to get an accurate progress counter
	OutputDebugString("Enumerating files on the disc\n");
	DrawMessage(g_RStrings[RS_PREPARING_COPY], 0);
	if (g_bHasFiles)
		EnumFiles(OTEXT("D:\\Files\\*"));
	if (g_bHasTData)
		EnumFiles(OTEXT("D:\\TDATA\\*"));
	if (g_bHasUData)
		EnumFiles(OTEXT("D:\\UDATA\\*"));

	// Determine the free space on the hard disk. If there isn't enough, warn.
	if (g_bHasFiles)
		{
		_int64 i64BytesFree;
		GetDiskFreeSpaceEx("E:\\", NULL, NULL, (ULARGE_INTEGER *)&i64BytesFree);
		if (i64BytesFree < g_cBytesToCopy)
			{
			DrawMessage(g_RStrings[RS_WARN_INSUFFICIENT_DISKSPACE], -1);
			WaitForAnyButton();
			}

		// Perform the file copy from the disc to the E:\ drive
		if (!CopyFiles(OTEXT("D:\\Files\\*"), OTEXT("E:\\")))
			{
			OutputDebugString("Critical error: file copy has failed");
			DrawMessage(g_RStrings[RS_ERROR_COPY_FAILED], -1);
			EjectDVD();
			WaitForAnyButton();
			XLaunchNewImage(NULL, NULL);
			}
		}

	if (g_bHasTData)
		{
		if (!CopyFiles(OTEXT("D:\\TDATA\\*"), OTEXT("T:\\")))
			{
			OutputDebugString("Critical error: file copy has failed");
			DrawMessage(g_RStrings[RS_ERROR_COPY_FAILED], -1);
			EjectDVD();
			WaitForAnyButton();
			XLaunchNewImage(NULL, NULL);
			}
		}

	if (g_bHasUData)
		{
		if (!CopyFiles(OTEXT("D:\\UDATA\\*"), OTEXT("U:\\")))
			{
			OutputDebugString("Critical error: file copy has failed");
			DrawMessage(g_RStrings[RS_ERROR_COPY_FAILED], -1);
			EjectDVD();
			WaitForAnyButton();
			XLaunchNewImage(NULL, NULL);
			}
		}

#ifdef E3
	SetLaunchTitle();
#endif

	// Eject the DVD drive
	DrawMessage(g_RStrings[RS_EJECTING_DVD], -1);
    EjectDVD();
	DrawMessage(g_RStrings[RS_COPY_COMPLETE], -1);
	WaitForAnyButton();

    // reboot the machine
	XLaunchNewImage(NULL, NULL);
	}

#ifdef E3

void SetLaunchTitle(void)
	{
	char szBuffer[MAX_PATH], szLaunch[360], *pch;
	FILE *fp;

	if (!(fp = fopen("D:\\LAUNCH.TXT", "rt")))
		return;
	fgets(szBuffer, MAX_PATH, fp);
	fclose(fp);

	// skip the initial XE:\, E:\ or \ symbols
	pch = szBuffer;
	if (('X' == toupper(*pch)) && ('E' == toupper(*(pch+1))) && (':' == *(pch+2)) && ('\\' == *(pch+3)))
		pch += 4;
	else if (('E' == toupper(*pch)) && (':' == *(pch+1)) && ('\\' == *(pch+2)))
		pch += 3;
	else if ('\\' == *pch)
		pch++;

	ZeroMemory(szLaunch, 360);
	sprintf(szLaunch, "\\Device\\Harddisk0\\partition1\\DEVKIT\\%s", pch);

	// replace the final '\' with a ';'
	pch = &(szLaunch[strlen(szLaunch) - 1]);
	while (*pch != '\\')
		*pch--;
	*pch = ';';

	if (!(fp = fopen("C:\\dashboard.xbx", "wb")))
		return;
	fwrite(szLaunch, 360, 1, fp);
	fclose(fp);
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    //m_xprResource.Destroy(); !!!

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset )
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset )
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset )
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset )
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset )
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset )
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName );

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName )
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName )
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName )
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName )
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName )
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 5, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 6 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xbetools\installer\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Help\cafehelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
// cafehelp.cpp
//
// email	date		change
// briancr	10/21/94	created
//
// copyright 1994 Microsoft

// cafehelp will take a list of files with comments (see specification below)
// and generate an RTF file for compilation with hc31.

// comment specification:
// BEGIN_HELP_COMMENT
// Function: <return type> <class name::><function name>(<parameter list>)
// Description: <description to eol>
// Return: <return value description to eol>
// Param: <param name> <param description to eol>
// END_HELP_COMMENT

#include "stdafx.h"
#include "cafehelp.h"

void main(int argc, char **argv)
{
	CStringList listFiles;
	CStdioFile fRTF;

	// process cmd line args
	if (ProcessCmdLine(argc, argv)) {

		// read the list of files
		if (ReadFileList(strListFile, listFiles)) {

			// open the RTF file
			if (fRTF.Open(strRTFFile, CFile::modeCreate | CFile::modeWrite)) {

				// generate header in RTF file
				RTFHeader(fRTF);

				// iterate through each file in the list and read all comment blocks
				for (POSITION pos = listFiles.GetHeadPosition(); pos != NULL; ) {
					ProcessCommentBlocks(listFiles.GetNext(pos), fRTF);
				}

				// generate end of RTF file
				RTFEnd(fRTF);

				// close the RTF file
				fRTF.Close();
			}
			else {
				Error("Unable to open the RTF file (%s).", (LPCTSTR)strRTFFile);
			}
		}
		else {
			Error("Unable to open the list of files (%s).", (LPCTSTR)strListFile);
		}
	}
	else {
		Usage();
	}

	// success
	exit(0);
}

BOOL ReadFileList(CString strFilename, CStringList &listFiles)
{
	CStdioFile fList;
	CString strBuffer;

	// clear the list of files
	listFiles.RemoveAll();

	Debug("Reading file list (%s)", (LPCTSTR)strFilename);

	// open the file list file for reading
	if (fList.Open(strFilename, CFile::modeRead)) {

		// read each line from the file until eof is reached
		while (fList.ReadString(strBuffer.GetBuffer(512), 511)) {
			strBuffer.ReleaseBuffer();

			// allow a semicolon (;) as the first character to denote the line as a comment
			if (strBuffer.GetAt(0) != ';') {

				// remove trailing \n
				strBuffer = EliminateTrailingChars(strBuffer, "\n");

				// add this filename to the list of files
				listFiles.AddTail(strBuffer);
			}
		}

		// close the file list file
		fList.Close();

		return TRUE;
	}

	return FALSE;
}

void RTFHeader(CStdioFile &fRTF)
{
	Debug("Writing RTF header.");

	for (int i = 0; !cstrRTFHeader[i].IsEmpty(); i++) {
		fRTF.WriteString(cstrRTFHeader[i]);
	}
}

void ProcessCommentBlocks(CString strFilename, CStdioFile &fRTF)
{
	Debug("Processing file (%s)", (LPCTSTR)strFilename);

	CStdioFile fSrc;
	BOOL bComment = FALSE;
	BOOL bReadingComment = FALSE;

	// open the file
	if (fSrc.Open(strFilename, CFile::modeRead)) {
		int nLine = 0;
		CString strLine;
		BOOL fFunction;
		BOOL fDescription;
		BOOL fReturn;
		BOOL fParam;

		// read each line from the file until eof
		while (fSrc.ReadString(strLine.GetBuffer(512), 511)) {
			strLine.ReleaseBuffer();
			nLine++;

			// are we currently reading a comment?
			if (bReadingComment) {

				// figure out which description it is

				// end of comment?
				if (strLine.Find(cstrEndComment) != -1) {
					// write out end of comment
					RTFEndOfFunction(strLine, strFilename, nLine, fRTF);
					// mark that we're done reading the comment
					bReadingComment = FALSE;
				}
				else {
					// function?
					if (strLine.Find(cstrFunction) != -1) {
						// be sure this line isn't entered twice in the same block
						if (!fFunction) {
							RTFFunction(strLine, strFilename, nLine, fRTF);
							fFunction = TRUE;
						}
						// function line occured more than once in the same block
						else {
							Warning("Multiple %s entries, ignoring this entry (%s, %d).", (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
						}
					}
					else {
						// description?
						if (strLine.Find(cstrDescription) != -1) {
							// we must have a function line before a description
							if (fFunction) {
								// be sure this line isn't entered twice in the same block
								if (!fDescription) {
									RTFDescription(strLine, strFilename, nLine, fRTF);
									fDescription = TRUE;
								}
								// description line occurs more than once in the same block
								else {
									Warning("Multiple %s entries, ignoring this entry (%s, %d).", (LPCTSTR)cstrDescription, (LPCTSTR)strFilename, nLine);
								}
							}
							// must have function line before description
							else {
								Warning("%s line before %s, ignoring this entry (%s, %d).", (LPCTSTR)cstrDescription, (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
							}
						}
						else {
							// return?
							if (strLine.Find(cstrReturn) != -1) {
								// we must have a function line before return
								if (fFunction) {
									// be sure this line isn't entered twice in the same block
									if (!fReturn) {
										RTFReturn(strLine, strFilename, nLine, fRTF);
										fReturn = TRUE;
									}
									// return line occurs more than once in the same block
									else {
										Warning("Multiple %s entries, ignoring this entry (%s, %d).", (LPCTSTR)cstrReturn, (LPCTSTR)strFilename, nLine);
									}
								}
								// must have function line before return
								else {
									Warning("%s line before %s, ignoring this entry (%s, %d).", (LPCTSTR)cstrReturn, (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
								}
							}
							else {
								// parameter?
								if (strLine.Find(cstrParam) != -1) {
									// we must have a function line before a parameter
									if (fFunction) {
										// write out the parameter header if this is the first parameter for this block
										if (!fParam) {
											RTFParamHdr(strLine, strFilename, nLine, fRTF);
										}
										RTFParam(strLine, strFilename, nLine, fRTF);
										fParam = TRUE;
									}
									// must have function line before parameter
									else {
										Warning("%s line before %s, ignoring this entry (%s, %d).", (LPCTSTR)cstrParam, (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
									}
								}
								else {
									// begin comment?
									if (strLine.Find(cstrBeginComment) != -1) {
										Warning("%s found within comment block (%s, %d).", (LPCTSTR)cstrBeginComment, (LPCTSTR)strFilename, nLine);
									}
									else {
										Warning("Unknown line (%s, %d).", (LPCTSTR)strFilename, nLine);
									}
								}
							}
						}
					}
				}
			}
			// we're not reading a comment
			else {
				// does this line mark the beginning of a comment?
				if (strLine.Find(cstrBeginComment) != -1) {
					// start of a comment block
					// mark that we found at least one comment in this file
					bComment = TRUE;
					// mark that we're now reading a comment
					bReadingComment = TRUE;
					// mark indicators as false
					fFunction = FALSE;
					fDescription = FALSE;
					fReturn = FALSE;
					fParam = FALSE;
				}
			}
		}

		// close the file
		fSrc.Close();

		// if we still think we're reading a comment, let the user know
		if (bReadingComment) {
			Warning("No %s found before reaching end of file (%s).", (LPCTSTR)cstrEndComment, (LPCTSTR)strFilename);
		}

		// if we didn't find any comment blocks in the file, let the user know
		if (!bComment) {
			Warning("No comment blocks found in file (%s).", (LPCTSTR)strFilename);
		}
	}
	// unable to open the file
	else {
		Warning("Unable to open file to read comment blocks (%s).", (LPCTSTR)strFilename);
	}
}

void RTFFunction(CString strLine, CString strFilename, int nLine, CStdioFile &fRTF)
{
	Debug("Processing function: %s", (LPCTSTR)strLine);

	CString strReturnType;
	CString strClassName;
	CString strFunction;
	CString strParamList;
	int nPos;

	// find the function keyword and move to the end of it
	nPos = strLine.Find(cstrFunction);
	strReturnType = strLine.Mid(nPos+cstrFunction.GetLength());

	// find the begining of the return type (eliminate white space)
	strReturnType = EliminateLeadingChars(strReturnType, " ");

	// find the end of the return type
	nPos = strReturnType.FindOneOf(" \t");
	if (nPos == -1) {
		nPos = 0;
	}
	// if the first space is after the first paren, then there is no return type
	// i.e. spaces separating parameters
	if (nPos > strReturnType.FindOneOf("(")) {
		nPos = 0;
	}

	// the class name starts after the return type
	strClassName = strReturnType.Mid(nPos);
	strReturnType = strReturnType.Left(nPos);

	// find the beginning of the class name
	strClassName = EliminateLeadingChars(strClassName, " ");

	// find the end of the class name
	nPos = strClassName.FindOneOf(":");
	if (nPos == -1) {
		nPos = 0;
	}
	// if the first : is after the first paren, then there is no class name
	// i.e. class::name is used in the parameter list
	if (nPos > strClassName.FindOneOf("(")) {
		nPos = 0;
	}

	// the function starts after the class name
	strFunction = strClassName.Mid(nPos);
	strClassName = strClassName.Left(nPos);

	// find the beginning of the function (skip :: if it exists)
	strFunction = EliminateLeadingChars(strFunction, " :");

	// find the end of the function
	nPos = strFunction.FindOneOf("(");
	if (nPos == -1) {
		nPos = 0;
	}

	// the parameter list starts after the function
	strParamList = strFunction.Mid(nPos);
	strFunction = strFunction.Left(nPos);

	// remove trailing \n
	strParamList = EliminateTrailingChars(strParamList, "\n");

	// write the function to the RTF file
	fRTF.WriteString(cstrBeginFunc);
	fRTF.WriteString(cstrBeginIDFunc);
	fRTF.WriteString("id_"+strClassName+"_"+strFunction);
	fRTF.WriteString(cstrEndIDFunc);
	fRTF.WriteString(cstrBeginIndexFunc);
	if (!strClassName.IsEmpty()) {
		fRTF.WriteString(strClassName+"; ");
	}
	fRTF.WriteString(strFunction);
	fRTF.WriteString(cstrEndIndexFunc);
	fRTF.WriteString(cstrBeginTopicFunc);
	if (!strClassName.IsEmpty()) {
		fRTF.WriteString(strClassName+"::");
	}
	fRTF.WriteString(strFunction);
	fRTF.WriteString(cstrEndTopicFunc);
	fRTF.WriteString(cstrBeginTextFunc);
	if (!strReturnType.IsEmpty()) {
		fRTF.WriteString(strReturnType+" ");
	}
	if (!strClassName.IsEmpty()) {
		fRTF.WriteString(strClassName+"::");
	}
	fRTF.WriteString(strFunction+strParamList);
	fRTF.WriteString(cstrEndTextFunc);

	UNREFERENCED_PARAMETER(strFilename);
	UNREFERENCED_PARAMETER(nLine);
}

void RTFDescription(CString strLine, CString strFilename, int nLine, CStdioFile &fRTF)
{
	Debug("Processing description: %s", (LPCSTR)strLine);

	CString strDescription;
	int nPos;

	// find the description keyword and move to the end of it
	nPos = strLine.Find(cstrDescription);
	strDescription = strLine.Mid(nPos+cstrDescription.GetLength());

	// find the begining of the description (eliminate white space)
	strDescription = EliminateLeadingChars(strDescription, " ");

	// remove trailing \n
	strDescription = EliminateTrailingChars(strDescription, "\n");

	// write the description to the RTF file
	fRTF.WriteString(cstrBeginDesc);
	fRTF.WriteString(strDescription);
	fRTF.WriteString(cstrEndDesc);

	UNREFERENCED_PARAMETER(strFilename);
	UNREFERENCED_PARAMETER(nLine);
}

void RTFReturn(CString strLine, CString strFilename, int nLine, CStdioFile &fRTF)
{
	Debug("Processing return: %s", (LPCSTR)strLine);

	CString strReturn;
	int nPos;

	// find the description keyword and move to the end of it
	nPos = strLine.Find(cstrReturn);
	strReturn = strLine.Mid(nPos+cstrReturn.GetLength());

	// find the begining of the return (eliminate white space)
	strReturn = EliminateLeadingChars(strReturn, " ");

	// remove trailing \n
	strReturn = EliminateTrailingChars(strReturn, "\n");

	// write the return desc to the RTF file
	fRTF.WriteString(cstrBeginReturn);
	fRTF.WriteString(strReturn);
	fRTF.WriteString(cstrEndReturn);

	UNREFERENCED_PARAMETER(strFilename);
	UNREFERENCED_PARAMETER(nLine);
}

void RTFParamHdr(CString strLine, CString strFilename, int nLine, CStdioFile &fRTF)
{
	Debug("Processing param hdr: %s", (LPCSTR)strLine);

	// write the parameter header to the RTF file
	fRTF.WriteString(cstrParamHdr);

	UNREFERENCED_PARAMETER(strFilename);
	UNREFERENCED_PARAMETER(nLine);
}

void RTFParam(CString strLine, CString strFilename, int nLine, CStdioFile &fRTF)
{
	Debug("Processing param: %s", (LPCSTR)strLine);

	CString strParam;
	CString strParamDesc;
	int nPos;

	// find the parameter keyword and move to the end of it
	nPos = strLine.Find(cstrParam);
	strParam = strLine.Mid(nPos+cstrParam.GetLength());

	// find the begining of the parameter (eliminate white space)
	strParam = EliminateLeadingChars(strParam, " ");

	// find the end of the parameter
	nPos = strParam.FindOneOf(" \t");
	if (nPos == -1) {
		nPos = 0;
	}

	// the parameter description starts after the parameter
	strParamDesc = strParam.Mid(nPos);
	strParam = strParam.Left(nPos);

	// find the beginning of the parameter description
	strParamDesc = EliminateLeadingChars(strParamDesc, " ");

	// remove trailing \n
	strParamDesc = EliminateTrailingChars(strParamDesc, "\n");

	// write the parameter to the RTF file
	fRTF.WriteString(cstrBeginParamName);
	fRTF.WriteString(strParam);
	fRTF.WriteString(cstrEndParamName);
	fRTF.WriteString(cstrBeginParamDesc);
	fRTF.WriteString(strParamDesc);
	fRTF.WriteString(cstrEndParamDesc);

	UNREFERENCED_PARAMETER(strFilename);
	UNREFERENCED_PARAMETER(nLine);
}

void RTFEndOfFunction(CString strLine, CString strFilename, int nLine, CStdioFile &fRTF)
{
	Debug("Processing end of function: %s", (LPCSTR)strLine);

	CString strLineNum;
	int nPos;

	// write the reference for this function to the RTF file
	fRTF.WriteString(cstrBeginFuncRef);
	// only include filename
	nPos = strFilename.ReverseFind('\\');
	if (nPos != -1) {
		strFilename = strFilename.Mid(nPos+1);
	}
	fRTF.WriteString(strFilename);
	strLineNum.Format(", %d", nLine+1);
	fRTF.WriteString(strLineNum);
	fRTF.WriteString(cstrEndFuncRef);

	// write the end of function to the RTF file
	fRTF.WriteString(cstrEndFunc);

	UNREFERENCED_PARAMETER(nLine);
}


CString EliminateLeadingChars(CString str, CString strSet)
{
	while (str.FindOneOf(strSet) == 0) {
		str = str.Mid(1);
	}
	return str;
}

CString EliminateTrailingChars(CString str, CString strSet)
{
	while (str.FindOneOf(strSet) == str.GetLength()-1) {
		str = str.Left(str.GetLength()-1);
	}
	return str;
}

void RTFEnd(CStdioFile &fRTF)
{
	Debug("Writing RTF end.");

	// write the end of the RTF file
	fRTF.WriteString(cstrRTFEnd);
}

void Error(LPCSTR szMsg, ...)
{
	char szBuf[512];

	va_list marker;
	va_start(marker, szMsg);
	_vsnprintf(szBuf, 512, szMsg, marker);
	va_end(marker);

	fprintf(stderr, "CAFEHelp Error: %s\n", szBuf);
	exit(-2);
}

void Warning(LPCSTR szMsg, ...)
{
	char szBuf[512];

	va_list marker;
	va_start(marker, szMsg);
	_vsnprintf(szBuf, 512, szMsg, marker);
	va_end(marker);

	fprintf(stderr, "CAFEHelp Warning: %s\n", szBuf);
}

void Debug(LPCSTR szMsg, ...)
{
	#ifdef _DEBUG

		char szBuf[512];

		va_list marker;
		va_start(marker, szMsg);
		_vsnprintf(szBuf, 512, szMsg, marker);
		va_end(marker);

		fprintf(stderr, "CAFEHelp Debug: %s\n", szBuf);
	#else
		UNREFERENCED_PARAMETER(szMsg);
	#endif // _DEBUG
}

BOOL ProcessCmdLine(int argc, char **argv)
{
	Debug("Processing command line args.");

	int i;

	// loop through args
	for (i = 1; i < argc; i++) {

		// ignore preceeding - or / by looking at second char
		switch (argv[i][1]) {
			// set the list file
			case 'l': {
				// parameter following this switch is the filename
				i++;
				if (i < argc) {
					strListFile = argv[i];
				}
				else {
					Usage();
					return FALSE;
				}
				break;
			}
			// set the output file
			case 'o': {
				// parameter following this switch is the filename
				i++;
				if (i < argc) {
					strRTFFile = argv[i];
				}
				else {
					Usage();
					return FALSE;
				}
				break;
			}
			case '?': {
				// display usage information
				Usage();
				return FALSE;
			}
			default: {
				Warning("Unrecognized switch: %s", argv[i]);
				Usage();
				return FALSE;
			}
		}
	}

	Debug("File list filename = %s", (LPCSTR)strListFile);
	Debug("RTF filename = %s", (LPCSTR)strRTFFile);

	return TRUE;
}

void Usage(void)
{
	fprintf(stdout, "\nCAFE Help File Generation System\n");
	fprintf(stdout, "Copyright 1994 Microsoft\n\n");
	fprintf(stdout, "Usage: cafehelp [-l <filename> -o <filename> -?]\n");
	fprintf(stdout, "-l <filename> : specify filename of file containing list of files to parse\n");
	fprintf(stdout, "  (defaults to cafehelp.lst)\n");
	fprintf(stdout, "-o <filename> : specify filename of output file\n");
	fprintf(stdout, "  (defaults to cafehelp.rtf)\n");
	fprintf(stdout, "-? : displays this usage message\n");
	#ifdef _DEBUG
		fprintf(stdout, "\n(debug build)\n");
	#endif // _DEBUG

	exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Help\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
// stdafx.cpp
//
// email	date		change
// briancr	10/21/94	created
//
// copyright 1994 Microsoft

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Help\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
// stdafx.h
//
// email	date		change
// briancr	10/21/94	created
//
// copyright 1994 Microsoft

#include <afx.h>
#include <afxcoll.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Help\cafehelp.h ===
/////////////////////////////////////////////////////////////////////////////
// cafehelp.h
//
// email	date		change
// briancr	10/21/94	created
//
// copyright 1994 Microsoft


// RTF filename
CString strListFile = "cafehelp.lst";
CString strRTFFile = "cafehelp.rtf";

// comment block constants
const CString cstrBeginComment = "BEGIN_HELP_COMMENT";
const CString cstrEndComment = "END_HELP_COMMENT";
const CString cstrFunction = "Function:";
const CString cstrDescription = "Description:";
const CString cstrReturn = "Return:";
const CString cstrParam = "Param:";

// prototypes
void Error(LPCSTR szMsg, ...);
void Warning(LPCSTR szMsg, ...);
void Debug(LPCSTR szMsg, ...);
BOOL ProcessCmdLine(int argc, char **argv);
void Usage(void);

BOOL ReadFileList(CString strFilename, CStringList &listFiles);
void RTFHeader(CStdioFile &file);
void ProcessCommentBlocks(CString strFilename, CStdioFile &file);
void RTFFunction(CString strLine, CString strFilename, int nLine, CStdioFile &file);
void RTFDescription(CString strLine, CString strFilename, int nLine, CStdioFile &file);
void RTFReturn(CString strLine, CString strFilename, int nLine, CStdioFile &file);
void RTFParamHdr(CString strLine, CString strFilename, int nLine, CStdioFile &file);
void RTFParam(CString strLine, CString strFilename, int nLine, CStdioFile &file);
void RTFEndOfFunction(CString strLine, CString strFilename, int nLine, CStdioFile &file);
CString EliminateLeadingChars(CString str, CString strSet);
CString EliminateTrailingChars(CString str, CString strSet);
void RTFEnd(CStdioFile &file);


// RTF header
CString cstrRTFHeader[] = { "{\\rtf1\\ansi \\deff0\\deflang1033{\\fonttbl{\\f0\\froman\\fcharset0\\fprq2 Tms Rmn{\\*\\falt Times New Roman};}{\\f2\\fswiss\\fcharset0\\fprq2 Helv{\\*\\falt Helvetica};}{\\f8\\froman\\fcharset0\\fprq2 Times;}{\\f7\\fswiss\\fcharset0\\fprq2 MS Sans Serif;}",
							"{\\f9\\fswiss\\fcharset0\\fprq2 Helvetica;}}{\\colortbl;\\red0\\green0\\blue0;\\red0\\green0\\blue255;\\red0\\green255\\blue255;\\red0\\green255\\blue0;\\red255\\green0\\blue255;\\red255\\green0\\blue0;\\red255\\green255\\blue0;\\red255\\green255\\blue255;\\red0\\green0\\blue128;",
							"\\red0\\green128\\blue128;\\red0\\green128\\blue0;\\red128\\green0\\blue128;\\red128\\green0\\blue0;\\red128\\green128\\blue0;\\red128\\green128\\blue128;\\red192\\green192\\blue192;}{\\stylesheet{\\nowidctlpar \\fs20 \\snext0 Normal;}{\\s1\\sb240\\nowidctlpar \\b\\f2\\ul ",
							"\\sbasedon0\\snext0 heading 1;}{\\s2\\sb120\\nowidctlpar \\b\\f2 \\sbasedon0\\snext0 heading 2;}{\\s3\\li360\\nowidctlpar \\b \\sbasedon0\\snext17 heading 3;}{\\s4\\li360\\nowidctlpar \\ul \\sbasedon0\\snext17 heading 4;}{\\s5\\li720\\nowidctlpar \\b\\fs20 \\sbasedon0\\snext17 ",
							"heading 5;}{\\s6\\li720\\nowidctlpar \\fs20\\ul \\sbasedon0\\snext17 heading 6;}{\\s7\\li720\\nowidctlpar \\i\\fs20 \\sbasedon0\\snext17 heading 7;}{\\s8\\li720\\nowidctlpar \\i\\fs20 \\sbasedon0\\snext17 heading 8;}{\\s9\\li720\\nowidctlpar \\i\\fs20 \\sbasedon0\\snext17 ",
							"heading 9;}{\\*\\cs10 \\additive Default Paragraph Font;}{\\*\\cs15 \\additive\\f0\\fs16\\up6\\lang1033 \\sbasedon10 footnote reference;}{\\s16\\nowidctlpar \\fs20 \\sbasedon0\\snext16 footnote text;}{\\s17\\li720\\nowidctlpar \\fs20 \\sbasedon0\\snext17 Normal Indent;}{",
							"\\s18\\fi-240\\li480\\sb80\\nowidctlpar\\tx480 \\f9 \\sbasedon0\\snext18 nscba;}{\\s19\\fi-240\\li240\\sa20\\nowidctlpar \\f9 \\sbasedon0\\snext19 j;}{\\s20\\li480\\sa20\\nowidctlpar \\f9 \\sbasedon0\\snext20 ij;}{\\s21\\sb80\\sa20\\nowidctlpar \\f9 \\sbasedon0\\snext21 btb;}{",
							"\\s22\\fi-240\\li2400\\sb20\\sa20\\nowidctlpar \\f9\\fs20 \\sbasedon0\\snext22 ctcb;}{\\s23\\fi-240\\li480\\sa40\\nowidctlpar\\tx480 \\f9 \\sbasedon0\\snext23 ns;}{\\s24\\sa120\\nowidctlpar \\f9\\fs28 \\sbasedon0\\snext24 TT;}{\\s25\\fi-240\\li2400\\sa20\\nowidctlpar \\f9 ",
							"\\sbasedon0\\snext25 crtj;}{\\s26\\fi-240\\li480\\nowidctlpar\\tx480 \\f9 \\sbasedon0\\snext26 nsca;}{\\s27\\sa20\\nowidctlpar \\f9 \\sbasedon0\\snext27 bt;}{\\s28\\li240\\sb120\\sa40\\nowidctlpar \\f9 \\sbasedon0\\snext28 Hf;}{\\s29\\li240\\sb120\\sa40\\nowidctlpar \\f9 ",
							"\\sbasedon0\\snext29 Hs;}{\\s30\\li480\\sb120\\sa40\\nowidctlpar \\f9 \\sbasedon0\\snext30 RT;}{\\s31\\fi-2160\\li2160\\sb240\\sa80\\nowidctlpar\\tx2160 \\f9 \\sbasedon0\\snext31 c;}{\\s32\\li2160\\sa20\\nowidctlpar \\f9 \\sbasedon0\\snext32 ct;}{\\s33\\li240\\sa20\\nowidctlpar \\f9 ",
							"\\sbasedon0\\snext33 it;}{\\s34\\li480\\nowidctlpar \\f9\\fs20 \\sbasedon0\\snext34 nsct;}{\\s35\\fi-160\\li400\\sb80\\sa40\\nowidctlpar \\f9 \\sbasedon0\\snext35 nscb;}{\\s36\\fi-2640\\li2880\\sb120\\sa40\\nowidctlpar\\brdrb\\brdrs\\brdrw15 \\brdrbtw\\brdrs\\brdrw15 \\tx2880 \\f9 ",
							"\\sbasedon0\\snext36 HC2;}{\\s37\\fi-2640\\li2880\\sb120\\sa20\\nowidctlpar\\tx2880 \\f9 \\sbasedon0\\snext37 C2;}{\\s38\\fi-240\\li2400\\sa20\\nowidctlpar \\f9\\fs20 \\sbasedon0\\snext38 ctc;}{\\s39\\li2160\\sb160\\nowidctlpar \\f9 \\sbasedon0\\snext39 crt;}{",
							"\\s40\\li480\\sb20\\sa40\\nowidctlpar \\f9 \\sbasedon0\\snext40 or;}{\\s41\\fi-259\\li360\\sb40\\sa40\\nowidctlpar\\tx360 \\f7\\fs20 \\sbasedon0\\snext41 Ln1;}{\\s42\\li115\\sb80\\sa80\\nowidctlpar \\f7\\fs20 \\sbasedon0\\snext0 *Intro;}{\\s43\\li115\\sb80\\sa80\\keepn\\nowidctlpar \\b\\f7 ",
							"\\sbasedon3\\snext42 *Title;}{\\s44\\fi-245\\li360\\sb80\\nowidctlpar \\f7\\fs20 \\snext44 *Jl;}{\\s45\\li360\\sb40\\sa40\\nowidctlpar \\f7\\fs20 \\snext0 Lp1;}{\\s46\\fi-1800\\li1915\\sb60\\sl-240\\slmult0\\nowidctlpar\\tx1915 \\f7\\fs20 \\sbasedon0\\snext46 Tph;}{",
							"\\s47\\li115\\sb120\\sa80\\nowidctlpar \\b\\f7\\fs20 \\snext41 Proch;}{\\*\\cs48 \\additive\\super \\sbasedon10 endnote reference;}}{\\info{\\title AFXCORE}{\\subject MFC Core RTF Help}{\\author AFX}{\\creatim\\yr1992\\mo10\\dy7\\hr11\\min4}{\\version1}{\\edmins12}{\\nofpages0}",
							"{\\nofwords0}{\\nofchars0}{\\vern49221}}\\widowctrl\\ftnbj\\aenddoc\\makebackup\\hyphcaps0 \\fet0\\sectd \\linex576\\endnhere {\\*\\pnseclvl1\\pnucrm\\pnstart1\\pnindent720\\pnhang{\\pntxta .}}{\\*\\pnseclvl2\\pnucltr\\pnstart1\\pnindent720\\pnhang{\\pntxta .}}{\\*\\pnseclvl3",
							"\\pndec\\pnstart1\\pnindent720\\pnhang{\\pntxta .}}{\\*\\pnseclvl4\\pnlcltr\\pnstart1\\pnindent720\\pnhang{\\pntxta )}}{\\*\\pnseclvl5\\pndec\\pnstart1\\pnindent720\\pnhang{\\pntxtb (}{\\pntxta )}}{\\*\\pnseclvl6\\pnlcltr\\pnstart1\\pnindent720\\pnhang{\\pntxtb (}{\\pntxta )}}",
							"{\\*\\pnseclvl7\\pnlcrm\\pnstart1\\pnindent720\\pnhang{\\pntxtb (}{\\pntxta )}}{\\*\\pnseclvl8\\pnlcltr\\pnstart1\\pnindent720\\pnhang{\\pntxtb (}{\\pntxta )}}{\\*\\pnseclvl9\\pnlcrm\\pnstart1\\pnindent720\\pnhang{\\pntxtb (}{\\pntxta )}}\\pard\\plain \\sl240\\slmult0\\widctlpar ",
							"\\fs20 \n",
							"" };

// Function
const CString cstrBeginFunc = "{\\cs15\\fs16\\up6 ";
const CString cstrBeginIDFunc = "#{\\footnote \\pard\\plain \\sl240\\slmult0\\widctlpar \\fs20 {\\cs15\\fs16\\up6 #} "; // + id
const CString cstrEndIDFunc = "}\n";
const CString cstrBeginIndexFunc = "K{\\footnote \\pard\\plain \\s16\\widctlpar \\fs20 {\\cs15\\fs16\\up6 K} "; // + index entry text (class; func)
const CString cstrEndIndexFunc = "}}{\\f8\\fs22  }\n";
const CString cstrBeginTopicFunc = "{\\cs15\\fs16\\up6 ${\\footnote \\pard\\plain \\s16\\widctlpar \\fs20 {\\cs15\\fs16\\up6 $} "; // + topic entry text (class::func)
const CString cstrEndTopicFunc = "}}{\\f8\\fs22  }\n";
const CString cstrBeginTextFunc = "{\\f8\\fs32 "; // + ret class::func(param)
const CString cstrEndTextFunc = "}\n";

// Description
const CString cstrBeginDesc = "{\\f8\\fs22 \\par \\par "; // + description
const CString cstrEndDesc = "\\par \\par }\n";

// Return
const CString cstrBeginReturn = "{\\b\\f8\\fs22 Return value: \\par }{\\f8\\fs22 \\par }{\\f8\\fs22 "; // + return desc
const CString cstrEndReturn = "\\par \\par }\n";

// Parameters
const CString cstrParamHdr = "{\\b\\f8\\fs22 Parameters: \\par }{\\f8\\fs22 \\par }\n";
const CString cstrBeginParamName = "{\\i\\f8\\fs22 "; // + parameter name
const CString cstrEndParamName = "}\n";
const CString cstrBeginParamDesc = "{\\f8\\fs22 : "; // + parameter desc
const CString cstrEndParamDesc = "\\par \\par }\n";

// End of function
const CString cstrBeginFuncRef = "{\\b\\f8\\fs22 Reference: }{\\f8\\fs22 "; // + filename, line num
const CString cstrEndFuncRef = "\\par }";
const CString cstrEndFunc = "{\\f8\\fs22 \\par \\page }\n";

// RTF end
const CString cstrRTFEnd = "}\n";



/* RTF header

{\rtf1\ansi \deff0\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn{\*\falt Times New Roman};}{\f2\fswiss\fcharset0\fprq2 Helv{\*\falt Helvetica};}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}
{\f9\fswiss\fcharset0\fprq2 Helvetica;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;
\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar \fs20 \snext0 Normal;}{\s1\sb240\nowidctlpar \b\f2\ul 
\sbasedon0\snext0 heading 1;}{\s2\sb120\nowidctlpar \b\f2 \sbasedon0\snext0 heading 2;}{\s3\li360\nowidctlpar \b \sbasedon0\snext17 heading 3;}{\s4\li360\nowidctlpar \ul \sbasedon0\snext17 heading 4;}{\s5\li720\nowidctlpar \b\fs20 \sbasedon0\snext17 
heading 5;}{\s6\li720\nowidctlpar \fs20\ul \sbasedon0\snext17 heading 6;}{\s7\li720\nowidctlpar \i\fs20 \sbasedon0\snext17 heading 7;}{\s8\li720\nowidctlpar \i\fs20 \sbasedon0\snext17 heading 8;}{\s9\li720\nowidctlpar \i\fs20 \sbasedon0\snext17 
heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\*\cs15 \additive\f0\fs16\up6\lang1033 \sbasedon10 footnote reference;}{\s16\nowidctlpar \fs20 \sbasedon0\snext16 footnote text;}{\s17\li720\nowidctlpar \fs20 \sbasedon0\snext17 Normal Indent;}{
\s18\fi-240\li480\sb80\nowidctlpar\tx480 \f9 \sbasedon0\snext18 nscba;}{\s19\fi-240\li240\sa20\nowidctlpar \f9 \sbasedon0\snext19 j;}{\s20\li480\sa20\nowidctlpar \f9 \sbasedon0\snext20 ij;}{\s21\sb80\sa20\nowidctlpar \f9 \sbasedon0\snext21 btb;}{
\s22\fi-240\li2400\sb20\sa20\nowidctlpar \f9\fs20 \sbasedon0\snext22 ctcb;}{\s23\fi-240\li480\sa40\nowidctlpar\tx480 \f9 \sbasedon0\snext23 ns;}{\s24\sa120\nowidctlpar \f9\fs28 \sbasedon0\snext24 TT;}{\s25\fi-240\li2400\sa20\nowidctlpar \f9 
\sbasedon0\snext25 crtj;}{\s26\fi-240\li480\nowidctlpar\tx480 \f9 \sbasedon0\snext26 nsca;}{\s27\sa20\nowidctlpar \f9 \sbasedon0\snext27 bt;}{\s28\li240\sb120\sa40\nowidctlpar \f9 \sbasedon0\snext28 Hf;}{\s29\li240\sb120\sa40\nowidctlpar \f9 
\sbasedon0\snext29 Hs;}{\s30\li480\sb120\sa40\nowidctlpar \f9 \sbasedon0\snext30 RT;}{\s31\fi-2160\li2160\sb240\sa80\nowidctlpar\tx2160 \f9 \sbasedon0\snext31 c;}{\s32\li2160\sa20\nowidctlpar \f9 \sbasedon0\snext32 ct;}{\s33\li240\sa20\nowidctlpar \f9 
\sbasedon0\snext33 it;}{\s34\li480\nowidctlpar \f9\fs20 \sbasedon0\snext34 nsct;}{\s35\fi-160\li400\sb80\sa40\nowidctlpar \f9 \sbasedon0\snext35 nscb;}{\s36\fi-2640\li2880\sb120\sa40\nowidctlpar\brdrb\brdrs\brdrw15 \brdrbtw\brdrs\brdrw15 \tx2880 \f9 
\sbasedon0\snext36 HC2;}{\s37\fi-2640\li2880\sb120\sa20\nowidctlpar\tx2880 \f9 \sbasedon0\snext37 C2;}{\s38\fi-240\li2400\sa20\nowidctlpar \f9\fs20 \sbasedon0\snext38 ctc;}{\s39\li2160\sb160\nowidctlpar \f9 \sbasedon0\snext39 crt;}{
\s40\li480\sb20\sa40\nowidctlpar \f9 \sbasedon0\snext40 or;}{\s41\fi-259\li360\sb40\sa40\nowidctlpar\tx360 \f7\fs20 \sbasedon0\snext41 Ln1;}{\s42\li115\sb80\sa80\nowidctlpar \f7\fs20 \sbasedon0\snext0 *Intro;}{\s43\li115\sb80\sa80\keepn\nowidctlpar \b\f7 
\sbasedon3\snext42 *Title;}{\s44\fi-245\li360\sb80\nowidctlpar \f7\fs20 \snext44 *Jl;}{\s45\li360\sb40\sa40\nowidctlpar \f7\fs20 \snext0 Lp1;}{\s46\fi-1800\li1915\sb60\sl-240\slmult0\nowidctlpar\tx1915 \f7\fs20 \sbasedon0\snext46 Tph;}{
\s47\li115\sb120\sa80\nowidctlpar \b\f7\fs20 \snext41 Proch;}{\*\cs48 \additive\super \sbasedon10 endnote reference;}}{\info{\title AFXCORE}{\subject MFC Core RTF Help}{\author AFX}{\creatim\yr1992\mo10\dy7\hr11\min4}{\version1}{\edmins12}{\nofpages0}
{\nofwords0}{\nofchars0}{\vern49221}}\widowctrl\ftnbj\aenddoc\makebackup\hyphcaps0 \fet0\sectd \linex576\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \sl240\slmult0\widctlpar 
\fs20 

*/

/* Function

{\cs15\fs16\up6 
#{\footnote \pard\plain \sl240\slmult0\widctlpar \fs20 {\cs15\fs16\up6 #} id_for_entry}
K{\footnote \pard\plain \s16\widctlpar \fs20 {\cs15\fs16\up6 K} Index entry goes here (class <semi> func)}}{\f2  }{\cs15\fs16\up6 
${\footnote \pard\plain \s16\widctlpar \fs20 {\cs15\fs16\up6 $} Entry name goes here (class::func)}}{\f2  }
{\b\f2\fs24 Class::Func(params)}

*/

/* Description

{\f2 
\par 
\par The description of the function goes here.
\par 
\par }

*/

/* Return

{\b\f2 Return value:
\par }{\f2 
\par }{\f2 The description of the return value goes here.
\par 
\par 
\par }

*/

/* Parameters

{\b\f2 Parameters:
\par }{\f2 
\par }{\i\f2 paramName}{\f2 : The description of the parameter goes here
\par 
\par 
\par }

*/

/* End of comment

{\f2 \par \page }

*/

/* RTF End

}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\applog.h ===
/////////////////////////////////////////////////////////////////////////////
// applog.h
//
// email	date		change
// briancr	02/06/95	created
//
// copyright 1994 Microsoft

// Interface of the application logging system

#ifndef __APPLOG_H__
#define __APPLOG_H__

#include "targxprt.h"

/////////////////////////////////////////////////////////////////////////////
// CAppLog

class TARGET_CLASS CAppLog
{
// ctor, dtor
public:
	CAppLog(void);
	~CAppLog();

// operations
public:
	BOOL Write(LPCSTR szFormat, ...);
	BOOL Read(LPSTR acBuf, DWORD* pccBuf);
	BOOL Clear(void);

// data
protected:
	CString m_strFilename;
	CStdioFile m_file;

	static const DWORD m_dwMaxLength;

	// critical section object to make access to this object thread safe
	CRITICAL_SECTION m_critsec;
};

// global declaration, since we want access to this object throughout CAFE
extern TARGET_DATA CAppLog applog;

#define APPLOG applog.Write

#endif // __APPLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\bldtools.h ===
#ifndef __BLDTOOLS_H
#define __BLDTOOLS_H

#include "target.h"

#ifdef EXPORT_BLDTOOLS
  #define BLDTOOLS_CLASS AFX_EXT_CLASS
#else
  #define BLDTOOLS_CLASS __declspec(dllimport)
	#ifdef _DEBUG
		#pragma comment(lib, "bldtoold.lib")
	#else
		#pragma comment(lib, "bldtools.lib")
	#endif
#endif


/////////////////////////////////////////////////////////////////////////////
// CConsoleTarget

class BLDTOOLS_CLASS CConsoleTarget: public CTarget
{
// ctor/dtor
public:
	CConsoleTarget(HANDLE hOutput) { m_hViewport = hOutput; }
	virtual ~CConsoleTarget() {}

// operations
public:

  virtual DWORD GetExitCode(void) { return m_dwExitCode; }
  virtual LPCSTR GetLastOutput(void);
  virtual LPCSTR GetLastCmdLine(void);

  //review(CFlaat): should these be declared at the CGUITarget level instead of at CTarget?
	virtual BOOL Attach(void) { ASSERT(FALSE); return FALSE; }
	
	// exit the target
	virtual BOOL Exit(void) { ASSERT(FALSE); return FALSE; }

// attributes
public:
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey) = 0;

	virtual BOOL ApplySettings(CSettings* pSettings) { return TRUE; UNREFERENCED_PARAMETER(pSettings); }

// operations (internal)
protected:
	virtual BOOL InitializeSettings(void) { return TRUE; }

  // create the target's process
  virtual BOOL CreateTargetProcess(LPCSTR szCmdLine, DWORD dwCreationFlags, LPCSTR szEnvBlock, LPCSTR szWorkDir);

// buffer declarations
protected:

  class COutputBuffer
  {
  public:
    LPCSTR GetAsSZ(void);
    BOOL Append(LPCSTR szText, UINT cchBytes);
    void ResetContents(void);
    BOOL IsEmpty(void);

  protected:
    enum { BufSize = (2 * 1024) };
    char m_acBuf[BufSize];
    char *m_pcNext;
    BOOL m_bFull;
  };

// data
protected:
  HANDLE m_hViewport, m_hCapture;
  DWORD m_dwExitCode;        // holds exit code of last invocation
  COutputBuffer m_bufOutput;
};



/////////////////////////////////////////////////////////////////////////////
// CCompilerDriver

class CLinker;

const CString strCompilerTargetKey("CompilerDriver");


class BLDTOOLS_CLASS CCompilerDriver: public CConsoleTarget
{
// ctor/dtor
public:
	CCompilerDriver(HANDLE hOutput) : CConsoleTarget(hOutput)	{ }
	virtual ~CCompilerDriver()									{ }

// operations
public:
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);

	virtual BOOL CompileOnly(LPCSTR szSrcFile, LPCSTR szCompileArgs=0);                         // CL -c [...]
	virtual BOOL CompileAndLink(LPCSTR szSrcFile, LPCSTR szCompileArgs=0, LPCSTR szLinkArgs=0); // CL [...] -link [...]
  virtual BOOL LinkOnly(LPCSTR szObjFile, LPCSTR szLinkArgs=0);                               // CL -link [...]

// testing operations
public:

// operations (internal)
protected:
	virtual BOOL InitializeSettings(void);

// data
protected:
  CLinker *m_pLinker;
};


class BLDTOOLS_CLASS CX86CompilerDriver: public CCompilerDriver
{
// ctor/dtor
public:
	CX86CompilerDriver(HANDLE hOutput) : CCompilerDriver(hOutput)	{ }
	virtual ~CX86CompilerDriver()									{}

// operations
public:
//	virtual BOOL Initialize(CString strKey);
};



/////////////////////////////////////////////////////////////////////////////
// CExecutable

const CString strExecManagerKey("ExecManager");

class BLDTOOLS_CLASS CExecutable : public CConsoleTarget
{
// ctor/dtor
public:
	CExecutable(HANDLE hOutput) : CConsoleTarget(hOutput)	{ }
	virtual ~CExecutable()									{ }

// operations
public:
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);

  virtual void SetFileName(LPCSTR szExeFile);

	virtual BOOL Execute(void) = 0;

// testing operations
public:

// operations (internal)
protected:
	virtual BOOL InitializeSettings(void);

// data
protected:

};


class BLDTOOLS_CLASS CX86Executable: public CExecutable
{
// ctor/dtor
public:
	CX86Executable(HANDLE hOutput) : CExecutable(hOutput)	{ }
	virtual ~CX86Executable()	{}

// operations
public:
	virtual BOOL Execute(void);
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
};


#endif __BLDTOOLS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\dllmain.h ===
///////////////////////////////////////////////////////////////////////////////
//	dllmain.h
//
//	Created by :			Date :
//		BrianCr				12/29/94
//
//	Description :
//		Exports for each subsuite DLL
//		This file must be included once in each subsuite DLL
//
//		Notes: originally, DllMain was included in subsuite.lib.
//		Apparently, exports from a lib are not exported from a DLL unless
//		they're called.
//

#ifndef __DLLMAIN_H__
#define __DLLMAIN_H__

#ifndef _AFXDLL

#error Only include this file in once in a SubSuite DLL. (_AFXDLL not defined.)

#else // _AFXDLL

///////////////////////////////////////////////////////////////////////////////
//	Debug/Retail mismatch identification
//  We want to be able to identify debug and retail builds of subsuite DLLs

extern "C" __declspec(dllexport) BOOL IsDebugBuild(void)
{
	#ifdef _DEBUG
		return TRUE;
	#else
		return FALSE;
	#endif
}
#endif // _AFXDLL

#endif // __DLLMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\guitarg.h ===
/////////////////////////////////////////////////////////////////////////////
// guitargt.h
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Interface of the CTarget class

#ifndef __GUITARGT_H__
#define __GUITARGT_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "settings.h"
#include "target.h"

#include "guixprt.h"

extern GUI_DATA HANDLE g_hTargetProc;


// forward declaration
class CToolset;

/////////////////////////////////////////////////////////////////////////////
// CGUITarget

class GUI_CLASS CGUITarget: public CTarget
{
    CString m_strTitle;

// ctor/dtor
public:
	CGUITarget(const CString& );
	virtual ~CGUITarget();

// operations
public:
	// launch the target
	virtual BOOL Launch(void);
	virtual BOOL Attach(void);
	
	// exit the target
	virtual BOOL Exit(void);

	// active status
	virtual BOOL IsActive(void);

// attributes
public:
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey) = 0;

	virtual BOOL ApplySettings(CSettings* pSettings);

// operations (internal)
protected:
	virtual HWND FindTarget(CString strClass, DWORD dwProcessId = 0);
	virtual BOOL InitializeSettings(void);

  // create the target's process
  virtual BOOL CreateTargetProcess(LPCSTR szCmdLine, DWORD dwCreationFlags, LPCSTR szEnvBlock, LPCSTR szWorkDir);

// data
public:
	// REVIEW(briancr): shouldn't this class really contain a UIWindow class or something, instead of an HWND?
	HWND m_hWnd;
};

#endif // __GUITARGT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\guiv1.h ===
/////////////////////////////////////////////////////////////////////////////
// guiv1.h
//
// email	date		change
// briancr	12/05/94	created
//
// copyright 1994 Microsoft

// Backward compatibility

#ifndef __GUIV1_H__
#define __GUIV1_H__

#include "settings.h"
#include "log.h"

#include "guixprt.h"

// REVIEW(briancr): these objects are declared as globals for backward compatibility

// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
extern GUI_DATA CLog* gpLog;
#define LOG gpLog
extern GUI_DATA CSettings* gpsettingsCmdLine;
#define CMDLINE gpsettingsCmdLine

//REVIEW(michma): this is a work-around to allow suite dlls to call
// GetUserTargetPlatforms (in shl.dll) while the test lists are being
// processed at load time.  GetUserTargetPlatforms() used to use a
// COConnection object for its work, but now COConnection is initialized
// by an IDE object which doesn't exist while suite dlls are being loaded.

extern GUI_DATA CString gplatformStr;

#define CAFE_LANG_ENGLISH	0
#define CAFE_LANG_GERMAN	1
#define CAFE_LANG_JAPANESE	2

#define MAX_ATOM_LENGTH 256

#define INITIALIZE_STRING "Initializing..."

GUI_API int GetLang(void);
GUI_API void SetLang(int lang);

GUI_API HINSTANCE GetLangDllHandle(void);
GUI_API void SetLangDllHandle(HINSTANCE hLangDll);

GUI_API int GetSysLang(void);

// hotkey stuff
enum EHotKey { HOTKEY_RUN, HOTKEY_SINGLE, HOTKEY_STEPOVER, HOTKEY_BREAK, HOTKEY_STEPBREAK};

extern GUI_DATA HANDLE g_hSingleStep;
extern GUI_DATA HANDLE g_hUserAbort;
extern GUI_DATA HWND g_hwndHotKey;
extern GUI_DATA EHotKey g_hkToDo;
extern GUI_DATA int g_stopStep;

GUI_API void WaitStepInstructions( LPCSTR szFmt, ... );

#endif // __CAFEV1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\evnthdlr.h ===
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	evnthdlr.h

	Author: Sean Christofferson

	24 July 1997 - Created

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// COM headers
#ifndef __EVENT_HANDLER_H__
#define __EVENT_HANDLER_H__

#define _WIN32_DCOM
#include <objbase.h>
#include <ocidl.h>

// Automation headers
#include <objmodel\appauto.h>
#include <objmodel\appguid.h>
//review (hardcoded GUID for debug MSDEV CLSID, hope it won't chnage, otherwise we will need to adjust it here)
// {E8BEA480-DDE4-11CF-9C4A-00A0C90A632C}
DEFINE_GUID(CLSID_DebugApp, 
0xE8BEA480, 0xDDE4, 0x11CF, 0x9C, 0x4A, 0x0, 0xA0, 0xC9, 0xA, 0x63, 0x2C);

#include <objmodel\bldauto.h>
#include <objmodel\bldguid.h>

#include <objmodel\dbgauto.h>
#include <objmodel\dbgguid.h>

#include <objmodel\textauto.h>
#include <objmodel\textguid.h>

// C Library headers
#include <assert.h>


// Define an inline function for HRESULT checking if one does not already exist
#ifndef VERIFY_OK
#define VERIFY_OK(x) {hres = x; assert(SUCCEEDED(hres));}
#endif

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
class __declspec(dllexport) CEventHandler : public IApplicationEvents
{
	public:
		// IUnknown Methods
		HRESULT __stdcall QueryInterface(const IID&, void**);
		ULONG	__stdcall AddRef();
		ULONG	__stdcall Release();

		// IDispatch Methods
		HRESULT __stdcall GetIDsOfNames(
			const IID&,
			OLECHAR**, 
			unsigned int, 
			LCID, 
			DISPID*
			);
		HRESULT __stdcall GetTypeInfo(
			unsigned int,
			LCID,
			ITypeInfo**
			);
		HRESULT __stdcall GetTypeInfoCount(
			unsigned int*
			);
		HRESULT __stdcall Invoke(
			DISPID,
			REFIID,
			LCID,
			WORD,
			DISPPARAMS*,
			VARIANT*,
			EXCEPINFO*,
			unsigned int*
			);

		// IApplicationEvents Methods
		HRESULT __stdcall BeforeBuildStart();
		HRESULT __stdcall BuildFinish(long nNumErrors, long nNumWarnings);
		HRESULT __stdcall BeforeApplicationShutDown() ;
		HRESULT __stdcall DocumentOpen(IDispatch* theDocument) ;
		HRESULT __stdcall BeforeDocumentClose(IDispatch* theDocument) ;
		HRESULT __stdcall DocumentSave(IDispatch* theDocument) ;
		HRESULT __stdcall NewDocument(IDispatch* theDocument) ;
		HRESULT __stdcall WindowActivate(IDispatch* theWindow) ;
		HRESULT __stdcall WindowDeactivate(IDispatch* theWindow) ;
		HRESULT __stdcall WorkspaceOpen() ;
		HRESULT __stdcall WorkspaceClose() ;
		HRESULT __stdcall NewWorkspace() ;

		// Constructors and Destructors
		CEventHandler();
		~CEventHandler();

		// MsDev Communication
		void Connect(BOOL isDebug);
		void Disconnect();

		// Wait methods
		void WaitForBuildStart();
		bool WaitForBuildFinish(int TimeoutInMintues);
		void WaitForApplicationShutDown();
		void WaitForDocumentOpen();
		void WaitForDocumentClose();
		void WaitForDocumentSave();
		void WaitForNewDocument();
		void WaitForWindowActivate();
		void WaitForWindowDeactivate();
		void WaitForWorkspaceOpen();
		void WaitForWorkspaceClose();
		void WaitForNewWorkspace();

//interface pointers to be kept while tests running
	public:
	//add more Target-lifetime interfaces as they're needed here.
	//do not add short-lived objects (like IWindow)!!!
		IApplication	*m_pApp;
		IDebugger		*m_pDbg;
	private:
		IConnectionPoint*m_pICP;

		// Connection point cookie
		DWORD m_dwConnectionID;

		// Event Handles
		HANDLE m_hevntBuildStart;
		HANDLE m_hevntBuildFinish;
		HANDLE m_hevntAppShutdown;
		HANDLE m_hevntDocOpen;
		HANDLE m_hevntDocClose;
		HANDLE m_hevntDocSave;
		HANDLE m_hevntNewDoc;
		HANDLE m_hevntWndActivate;
		HANDLE m_hevntWndDeactivate;
		HANDLE m_hevntWorkspaceOpen;
		HANDLE m_hevntWorkspaceClose;
		HANDLE m_hevntNewWorkspace;

		// Reference Count
		long m_cRef;
}; 

#endif
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	file evnthdlr.h
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\edge.h ===
/////////////////////////////////////////////////////////////////////////////
// edge.h
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1994 Microsoft

// Interface of the CArc class

#ifndef __EDGE_H__
#define __EDGE_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "test.h"

///////////////////////////////////////////////////////////////////////////////
// CEdge class

typedef CTest CEdge;

#endif //__EDGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\guixprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	guixprt.h (gui export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		GUI DLL defines
//

#ifndef __GUIXPRT_H__
#define __GUIXPRT_H__

#ifdef EXPORT_GUI
	#define GUI_CLASS AFX_EXT_CLASS
	#define GUI_API   AFX_EXT_API
	#define GUI_DATA  AFX_EXT_DATA
#else
	#define GUI_CLASS __declspec(dllimport)
	#define GUI_API   __declspec(dllimport)
	#define GUI_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "guid.lib")
	#else
		#pragma comment(lib, "gui.lib")
	#endif
#endif

#endif // __GUIXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\idetarg.h ===
/////////////////////////////////////////////////////////////////////////////
// idetargt.h
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Interface of the CTarget class

#ifndef __IDETARGT_H__
#define __IDETARGT_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "settings.h"
#include "guitarg.h"
#include "..\src\support\guitools\ide\shl\coconnec.h"
#include "idexprt.h"
#include "..\src\support\guitools\ide\connec.h"


/////////////////////////////////////////////////////////////////////////////
// CIDE

const CString strIDETargetKey = "IDE";

class IDE_CLASS CIDE: public CGUITarget
{
// ctor/dtor
public:
	CIDE();
	virtual ~CIDE();

// operations
public:
	// launch the IDE
	virtual BOOL Launch(void);

	// exit the IDE
	virtual BOOL Exit(void);

	// active status
	virtual BOOL IsActive(void);

	virtual BOOL SetEnvironmentVar(LPCSTR pszEnvVar, LPCSTR pszValue);
	virtual BOOL GetEnvironmentVar(LPCSTR pszEnvVar, CString &strValue);

	// The following 2 functions enable/disable writing a message to the log that the Exception dilaog was found
	void EnableExceptionMessageHandling(void)	{ m_EnableExceptionMessageHandling = TRUE; }
	void DisableExceptionMessageHandling(void)	{ m_EnableExceptionMessageHandling = FALSE; }

// operations
public:
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);
	virtual BOOL SetConnections(HWND hwndDlg) = 0;
	// record heap usage information from the IDE
	BOOL RecordHeapUse(void);

// testing operations
public:
	virtual COConnection* GetConnectionInfo(void);

/*
	virtual COSource* NewSourceEditor(void);
	virtual COProject* NewProject(void);
	virtual CODebug* NewDebugger(void);

	virtual COSource* GetSourceEditor(void);
	virtual COProject* GetProject(void);
	virtual CODebug* GetDebugger(void);
*/

// operations (internal)
protected:
	virtual BOOL InitializeSettings(void);

	CString GetKeyExt(void);
	void DeleteKeyExt(void);
	
// data
public:
	DWORD m_dwLaunchTime;
	// each IDE has a single connection info object
	COConnection* m_pConnectionInfo;

protected:
	CConnections m_connec;
	// heap use message id
	static UINT m_msgHeapUse;
	// heap use log path/filename
	CString m_strHeapUseFilename;

protected:
	// the following members are used in conjunction with imehook.dll.
	// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).

	// we use imehook.dll only on nt/j. 
	BOOL m_bRunningOnNTJ;
	// handle to imehook.dll.
	HINSTANCE m_hIMEHookDll;
	// pointers to HookIDE() and UnhookIDE() in imehook.dll.
	void (FAR WINAPI *m_lpfnHookIDE)(HWND);
	void (FAR WINAPI *m_lpfnUnhookIDE)(HWND);
};


/////////////////////////////////////////////////////////////////////////////
// CX86IDE

class IDE_CLASS CX86IDE: public CIDE
{
// ctor/dtor
public:
	CX86IDE();
	virtual ~CX86IDE();
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);
	virtual BOOL InitializeSettings(void);
	virtual BOOL SetConnections(HWND hwndDlg);
// data
private:
	CSettings *m_psettingsTCPIP;
	CSettings *m_psettingsSerial;
};

/////////////////////////////////////////////////////////////////////////////
// CWin32sIDE

class IDE_CLASS CWin32sIDE: public CX86IDE
{
// ctor/dtor
public:
	CWin32sIDE();
	virtual ~CWin32sIDE();
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);
	virtual BOOL InitializeSettings(void);
	virtual BOOL SetConnections(HWND hwndDlg);
// data
private:
	CSettings *m_psettingsSerial;
};

/////////////////////////////////////////////////////////////////////////////
// C68KIDE

class IDE_CLASS C68KIDE: public CX86IDE
{
// ctor/dtor
public:
	C68KIDE();
	virtual ~C68KIDE();
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);
	virtual BOOL InitializeSettings(void);
	virtual BOOL SetConnections(HWND hwndDlg);
// data
private:
	CSettings *m_psettingsTCPIP;
	CSettings *m_psettingsSerial;
	CSettings *m_psettingsAT;
};

/////////////////////////////////////////////////////////////////////////////
// CPMacIDE

class IDE_CLASS CPMacIDE: public CX86IDE
{
// ctor/dtor
public:
	CPMacIDE();
	virtual ~CPMacIDE();
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey);
	virtual BOOL ApplySettings(CSettings* pSettings);
	virtual BOOL InitializeSettings(void);
	virtual BOOL SetConnections(HWND hwndDlg);
// data
private:
	CSettings *m_psettingsTCPIP;
	CSettings *m_psettingsSerial;
	CSettings *m_psettingsAT;
};

/////////////////////////////////////////////////////////////////////////////
// CMIPSIDE

class IDE_CLASS CMIPSIDE: public CX86IDE
{
// ctor/dtor
public:
	CMIPSIDE();
	virtual ~CMIPSIDE();
};

/////////////////////////////////////////////////////////////////////////////
// CAlphaIDE

class IDE_CLASS CAlphaIDE: public CX86IDE
{
// ctor/dtor
public:
	CAlphaIDE();
	virtual ~CAlphaIDE();
};

/////////////////////////////////////////////////////////////////////////////
// CPowerPCIDE

class IDE_CLASS CPowerPCIDE: public CX86IDE  // Review: PowerMac derives like this as well.  It doesn't really make sense.
{
// ctor/dtor
public:
	CPowerPCIDE();
	virtual ~CPowerPCIDE();
};

#endif // __IDETARGT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\idexprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	idexprt.h (ide export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		IDE DLL defines
//

#ifndef __IDEXPRT_H__
#define __IDEXPRT_H__

#ifdef EXPORT_IDE
	#define IDE_CLASS AFX_EXT_CLASS
	#define IDE_API   AFX_EXT_API
	#define IDE_DATA  AFX_EXT_DATA
#else
	#define IDE_CLASS __declspec(dllimport)
	#define IDE_API   __declspec(dllimport)
	#define IDE_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "ided.lib")
	#else
		#pragma comment(lib, "ide.lib")
	#endif
#endif

#endif // __GUIXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\log.h ===
/////////////////////////////////////////////////////////////////////////////
// log.h
//
// email        date            change
// cflaat       11/01/94        created
//
// copyright 1994 Microsoft

// CLog interface

#ifndef __LOG_H
#define __LOG_H

#pragma warning(disable: 4251)

#ifndef EXPORT_LOG
	#ifdef _DEBUG
		#pragma comment(lib, "logd.lib")
	#else
		#pragma comment(lib, "log.lib")
	#endif
#endif

/*
    CLog
    ====

    This file and design copyright 1993-94 by Microsoft Corp.
    Created by CFlaat, based on the CLogRecorder class by RickKr.
    
      This class represents an abstract interface for a self-contained
    logging system.  A specific implementation of this interface is
    required to actually do anything.  [TODO(CFlaat): more discussion]

*/

#ifndef PRINTF_ARGS

// this is for declaring a printf-style argument list

#define PRINTF_ARGS LPCSTR a_szFormat,...

// this macro can only be used by members of CLog-derived classes which use PRINTF_ARGS

#define ParseArguments()\
{\
	va_list marker;\
	va_start( marker, a_szFormat );\
	_vsnprintf( m_acArgBuf, m_cchArgBuf, a_szFormat, marker );\
	va_end( marker );\
}
#else

#pragma message("multiple definitions of PRINTF_ARGS!!!")
#endif



class AFX_EXT_CLASS CLog
{
public:

  CLog(HANDLE hOutput = 0,      // output handle for tagged log entries & comments
       BOOL bRecordComments = FALSE);

  virtual ~CLog(void);

  virtual BOOL BeginSubSuite(LPCSTR, LPCSTR = 0);
  virtual BOOL EndSubSuite(void);

  virtual BOOL BeginTest(LPCSTR szTestName, long cCompares = -1);
  virtual BOOL EndTest(void);                         // this is called after each test case

// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordSuccess(LPCSTR a_szFormat, ...)
// Description: Record a success in the log for the current test. A call to this function causes the current test to log a success and increments the success count by 1.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
  virtual BOOL RecordSuccess(PRINTF_ARGS);            // product passed a test
// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordFailure(LPCSTR a_szFormat, ...)
// Description: Record a failure in the log for the current test. A call to this function causes the current test to fail and increments the fail count by 1.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
  virtual BOOL RecordFailure(PRINTF_ARGS);            // product failed a test
// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordInfo(LPCSTR a_szFormat, ...)
// Description: Record an informational message in the log for the current test.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
  virtual BOOL RecordTestKeys(PRINTF_ARGS) = 0;                       // records test keystrokes.
// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordTestKeys(LPCSTR szFile, LPCSTR a_szFormat, ...)
// Description: Record the contents of a text file in the log for the current test.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFile A pointer to a string that contains the name of the file to include in the log.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
												 
  virtual BOOL RecordInfo(PRINTF_ARGS) = 0;                           // recorded but ignored
// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordTextFile(LPCSTR szFile, LPCSTR a_szFormat, ...)
// Description: Record the contents of a text file in the log for the current test.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFile A pointer to a string that contains the name of the file to include in the log.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
  virtual BOOL RecordTextFile(LPCSTR szFile, PRINTF_ARGS) = 0;  // append a text file to the log
// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordCriticalError(LPCSTR a_szFormat, ...)
// Description: Record a critical error in the log for the current test. Use this function when a unrecoverable error occurs while testing. A call to this function causes the current test to fail and increments the fail count by 1.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
  virtual BOOL RecordCriticalError(PRINTF_ARGS) = 0;  // called for errors that force test termination

// BEGIN_HELP_COMMENT
// Function: BOOL CLog::RecordCompare(BOOL bSuccess, LPCSTR a_szFormat, ...)
// Description: Record information or a failure in the log for the current test.
// Return: A Boolean value that indicates the result of bSuccess.
// Param: bSuccess A Boolean value that specifies whether to record information (TRUE) or a failure (FALSE).
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
	virtual BOOL RecordCompare(BOOL bSuccess, PRINTF_ARGS) = 0;             // called to record based on bSuccess

// BEGIN_HELP_COMMENT
// Function: BOOL CLog::Comment(LPCSTR a_szFormat, ...)
// Description: Record a comment in the log for the current test.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: a_szFormat A pointer to a string that contains the format-specifiers for the remaining variable number of arguments. This format-specifier string is the same format as the format-specifier string for printf.
// Param: ... A variable number of arguments that are expanded into a string as specified by the format-specifier string.
// END_HELP_COMMENT
  virtual BOOL Comment(PRINTF_ARGS) = 0;              // chatty trace commentary that can be ignored
						      // or dumped at the CAFE driver's discretion

  virtual long GetSuiteFailCount(void)               // current failures in this suite
    { return m_cSuiteFailures; }

  virtual long GetSubSuiteFailCount(void)            // current failures in this subsuite
    { return m_cSubSuiteFailures; }

  virtual long GetTestSuccessCount(void)             // current successes in this test,
    { return m_cTestSuccesses; }                      // i.e. # times RecordSuccess called

  virtual long GetTestFailCount(void)                // current failures in this test,
    { return m_cTestFailures; }                      // i.e. # times RecordFailure called
  
  virtual long GetTotalFailCount(void)                           // Total # of failures in this suite run.
    { return m_cTotalFailures; }
  
  const CString& GetTestName()                                           // Current running test.
	{ return m_strTestName; }


  BOOL GetLogDebugOutput(void);         // Should debug output from target be logged?
  BOOL SetLogDebugOutput(BOOL);         // Set state of logging target debug output.

protected:

  BOOL m_bTestRunning;

  long     // type is long in case we want to utilize negative values
    m_cTestsFinished,
    m_cSuiteFailures,
    m_cSubSuiteFailures,
    m_cTestFailures,
	m_cTestSuccesses,
	m_cTotalFailures,                                // a count of the total number of failures (number of times RecordFailure is called)
	m_cTotalTestFailures,                            // a count of the total number of failures during a test (number of times RecordFailure is called while a test is running)
	m_cExpectedCompares;                             // a count of the expected number of successes+failures for each test

  CString
    m_strSubSuiteName,
    m_strSubSuiteOwner,
    m_strTestName;

  BOOL m_bRecordComments;
  BOOL m_bLogDebugOutput;
  CFile *m_pfOutput;

// these next two are for handling printf-style arguments in conjunction with the PARSE_ARGS macro

  enum { m_cchArgBuf = 4000 };
  char * m_acArgBuf; // [m_cchArgBuf];

protected:
  CString GetOSDescription(void); // e.g. "Windows NT 3.5, build 807"

	// UGLY_HACK(briancr): this code is here to log info to a server about who runs CAFE
	// remove it as soon as possible
public:
	BOOL m_bBigBro;
};

#endif  // __LOG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\mstwrap.h ===
///////////////////////////////////////////////////////////////////////////////
//	TESTWRAP.H
//
//	Created by :			Date :
//		DavidGa					8/14/93
//
//	Description :
//		Declaration of MS Test wrapping class
//

#ifndef __TESTWRAP_H__
#define __TESTWRAP_H__
#include "t4ctrl.h"		// MS Test DLL calls

#include "guixprt.h"

#pragma comment(lib, "mstest40.LIB")

#define TIMEOUT 3
//timeout in seconds for the functions in mstest40.DLL, which must have its timeout:
/*
	WFndWndC
	WEditClick
	WEditSetFocus
	WComboSetText
*/


class GUI_CLASS CMSTest
{
/////////////////////////////////////////////////////////////////////////////
// TEST struct conversions
public:
	static void Convert(WNDPOS const wndpos, CPoint& pt);
	static void Convert(CPoint const pt, WNDPOS& wndpos);
	static CPoint Convert(WNDPOS const wndpos);

	static void Convert(WNDSIZ const wndsiz, CSize& size);
	static void Convert(CSize const size, WNDSIZ& wndsiz);
	static CSize Convert(WNDSIZ const wndsiz);

	static void Convert(WNDPOSSIZ const wndpossiz, CRect& rc);
	static void Convert(CRect const rc, WNDPOSSIZ& wndpossiz);
	static CRect Convert(WNDPOSSIZ const wndpossiz);

/////////////////////////////////////////////////////////////////////////////
// TESTCTRL Wrappers
public:

//---------------------------------------------------------------------------
// Miscelaneous routines
//---------------------------------------------------------------------------

//static long WMessage        (HWND hWnd, UINT wMsg);
//static long WMessageW       (HWND hWnd, UINT wMsg, WPARAM wp);
//static long WMessageL       (HWND hWnd, UINT wMsg, LPARAM lp);
//static long WMessageWL      (HWND hWnd, UINT wMsg, WPARAM wp, LPARAM lp);
static HWND WGetFocus       (void);
//static void WDisplayInfo    (HWND, UINT);
//static void WGetInfo        (HWND, LPINFO);
//static void WStaticSetClass (LPSTR);
//static void WResetClasses   (void);
static BOOL WIsVisible      (HWND hwnd);
//static long WTextLen        (HWND hWnd);
static void WGetText        (HWND hwnd, CString& strBuffer);
//static void WSetText        (HWND hWnd, LPCSTR lpcszText);
//static int  WNumAltKeys     (void);
//static void WGetAltKeys     (CString& strBuff);
//static int  WNumDupAltKeys  (void);
//static void WGetDupAltKeys  (CString& strBuff);

//---------------------------------------------------------------------------
// General Window routines
//---------------------------------------------------------------------------

static HWND WFndWndWait   (LPCSTR lpcszCaption, UINT uFlags, UINT uSeconds);
static HWND WFndWndWaitC  (LPCSTR lpcszCaption, LPCSTR lpcszClass, UINT uFlags, UINT uSeconds);
static HWND WFndWnd       (LPCSTR lpcszCaption, UINT uFlags);
static HWND WFndWndC      (LPCSTR lpcszCaption, LPCSTR lpcszClass, UINT uFlags);
//static void WMinWnd       (HWND hWnd);
static void WMaxWnd       (HWND hWnd);
//static void WResWnd       (HWND hWnd);
//static void WSetWndPosSiz (HWND hWnd, int x,  int y, int w, int h);
//static void WSetWndPos    (HWND hWnd, int x,  int y);
static void  WSetWndSiz    (HWND hwnd, int w,  int h);
//static void WAdjWndPosSiz (HWND hWnd, int dx, int dy, int dw, int dh);
//static void WAdjWndPos    (HWND hWnd, int dx, int dy);
//static void WAdjWndSiz    (HWND hWnd, int dw, int dh);
//static void WGetWndPosSiz (HWND hWnd, LPWNDPOSSIZ lpWndPosSiz, BOOL fRelative);
//static void WGetWndPos    (HWND hWnd, LPWNDPOS    lpWndPos,    BOOL fRelative);
static CSize WGetWndSiz    (HWND hwnd);
static void  WSetActWnd    (HWND hwnd);
static HWND WGetActWnd    (HWND hwnd);
//static BOOL WIsMaximized  (HWND hWnd);
//static BOOL WIsMinimized  (HWND hWnd);

//---------------------------------------------------------------------------
// Menu routines
//---------------------------------------------------------------------------
static void WMenu              (LPCSTR lpcszName);
//static void FAR     WMenuEx            (LPCSTR lpcszName, ...)
static BOOL WMenuExists        (LPCSTR lpcszName);
static BOOL WMenuGrayed        (LPCSTR lpcszName);
static BOOL WMenuChecked       (LPCSTR lpcszName);
static BOOL WMenuEnabled       (LPCSTR lpcszName);
static int  WMenuCount         (void);
static void WMenuText          (LPCSTR lpcszName, CString& strBuffer);
//static int  WMenuLen           (LPCSTR lpcszName);
//static void WMenuFullText      (LPCSTR lpcszName, CString& strBuffer);
//static int  WMenuFullLen       (LPCSTR lpcszName);
static void WMenuEnd           (void);
//static BOOL WSysMenuExists     (HWND hWnd);
//static void WSysMenu           (HWND hWnd);
//static int  WMenuNumAltKeys    (void);
//static void WMenuGetAltKeys    (CString& strBuff);
//static int  WMenuNumDupAltKeys (void);
//static void WMenuGetDupAltKeys (CString& strBuff);
//static BOOL WMenuSeparator     (int iIndex);

// Obsolete.
//----------
//static void WMenuX             (int iIndex);
//static BOOL WMenuGrayedX       (int iIndex);
//static BOOL WMenuCheckedX      (int iIndex);
//static BOOL WMenuEnabledX      (int iIndex);

//---------------------------------------------------------------------------
// Command button routines.
//---------------------------------------------------------------------------

//static void WButtonSetClass (LPCSTR lpcszClassName);
static BOOL WButtonExists   (LPCSTR lpcszName);
static BOOL WButtonEnabled  (LPCSTR lpcszName);
static BOOL WButtonFocus    (LPCSTR lpcszName);
static void WButtonClick    (LPCSTR lpcszName);
//static void WButtonHide     (LPCSTR lpcszName);
//static void WButtonShow     (LPCSTR lpcszName);
//static void WButtonEnable   (LPCSTR lpcszName);
//static void WButtonDisable  (LPCSTR lpcszName);
//static BOOL WButtonDefault  (LPCSTR lpcszName);
//static int WButtonDefaults (void);
static void WButtonSetFocus (LPCSTR lpcszName);

//---------------------------------------------------------------------------
// CheckBox routines
//---------------------------------------------------------------------------
//static void WCheckSetClass (LPCSTR lpcszClassName);
static BOOL WCheckExists   (LPCSTR lpcszName);
static BOOL WCheckEnabled  (LPCSTR lpcszName);
static BOOL WCheckFocus    (LPCSTR lpcszName);
static int  WCheckState    (LPCSTR lpcszName);
static void WCheckClick    (LPCSTR lpcszName);
//static void WCheckHide     (LPCSTR lpcszName);
//static void WCheckShow     (LPCSTR lpcszName);
//static void WCheckEnable   (LPCSTR lpcszName);
//static void WCheckDisable  (LPCSTR lpcszName);
static void WCheckCheck    (LPCSTR lpcszName);
static void WCheckUnCheck  (LPCSTR lpcszName);
static void WCheckSetFocus (LPCSTR lpcszName);


//---------------------------------------------------------------------------
// Option Button routines
//---------------------------------------------------------------------------
//static void WOptionSetClass (LPCSTR lpcszClassName);
static BOOL WOptionExists   (LPCSTR lpcszName);
static BOOL WOptionEnabled  (LPCSTR lpcszName);
static BOOL WOptionFocus    (LPCSTR lpcszName);
static int  WOptionState    (LPCSTR lpcszName);
static void WOptionClick    (LPCSTR lpcszName);
//static void WOptionHide     (LPCSTR lpcszName);
//static void WOptionShow     (LPCSTR lpcszName);
//static void WOptionEnable   (LPCSTR lpcszName);
//static void WOptionDisable  (LPCSTR lpcszName);
static void WOptionSelect   (LPCSTR lpcszName);
static void WOptionSetFocus (LPCSTR lpcszName);


//---------------------------------------------------------------------------
// Listbox routines
//---------------------------------------------------------------------------
static void WListSetClass     (LPCSTR lpcszClassName);
static BOOL WListExists       (LPCSTR lpcszName);
static int  WListCount        (LPCSTR lpcszName);
static void WListText         (LPCSTR lpcszName, CString& strBuffer);
static int  WListLen          (LPCSTR lpcszName);
static int  WListIndex        (LPCSTR lpcszName);
//static int  WListTopIndex     (LPCSTR lpcszName);
static void WListItemText     (LPCSTR lpcszName, int iIndex, CString& strBuffer);
static int  WListItemLen      (LPCSTR lpcszName, int iIndex);
static int  WListItemExists   (LPCSTR lpcszName, LPCSTR lpcszItem);
static void WListItemClk      (LPCSTR lpcszName, int iIndex, int nOffset = 0);
static void WListItemClk      (LPCSTR lpcszName, LPCSTR lpcszItem, int nOffset = 0);
static void WListItemCtrlClk  (LPCSTR lpcszName, int iIndex, int nOffset = 0);
static void WListItemCtrlClk  (LPCSTR lpcszName, LPCSTR lpcszItem, int nOffset = 0);
static void WListItemShftClk  (LPCSTR lpcszName, int iIndex, int nOffset = 0);
static void WListItemShftClk  (LPCSTR lpcszName, LPCSTR lpcszItem, int nOffset = 0);
static void WListItemDblClk   (LPCSTR lpcszName, int iIndex, int nOffset = 0);
static void WListItemDblClk   (LPCSTR lpcszName, LPCSTR lpcszItem, int nOffset = 0);
static int  WListSelCount     (LPCSTR lpcszName);
static void WListSelItems     (LPCSTR lpcszName, LPINT lpIntArray);
//static void WListClear        (LPCSTR lpcszName);
//static void WListAddItem      (LPCSTR lpcszName, LPCSTR lpcszItem);
//static void WListDelItem      (LPCSTR lpcszName, int iIndex);
//static void WListDelItem      (LPCSTR lpcszName, LPCSTR lpcszItem);
static BOOL WListEnabled      (LPCSTR lpcszName);
static void WListSetFocus     (LPCSTR lpcszName);

//---------------------------------------------------------------------------
// Listview routines
//---------------------------------------------------------------------------
static int  WViewCount      (LPCSTR lpcszName);
static BOOL WViewEnabled    (LPCSTR lpcszName);
static void WViewSetFocus   (LPCSTR lpcszName);
static int  WViewSelItem    (LPCSTR lpcszName, LPCSTR lpcszItem);
static void WViewItemClk	(LPCSTR lpcszName, LPCSTR lpcszItem);
static void WViewItemClk	(LPCSTR lpcszName, int iIndex);
static BOOL WViewItemExists	(LPCSTR lpcszName,  LPCSTR lpcszItem);
static int  WViewItemIndex	(LPCSTR lpcszName,  LPCSTR lpcszItem);


//---------------------------------------------------------------------------
// Combobox routines
//---------------------------------------------------------------------------
//static void WComboSetClass    (LPCSTR lpcszName);
//static void WComboSetLBClass  (LPCSTR lpcszName);
static BOOL WComboExists      (LPCSTR lpcszName);
static int  WComboCount       (LPCSTR lpcszName);
static void WComboText        (LPCSTR lpcszName, CString& strBuff);
static int  WComboLen         (LPCSTR lpcszName);
static int  WComboIndex       (LPCSTR lpcszName);
static void WComboSetText     (LPCSTR lpcszName, LPCSTR lpcszText);
static void WComboSelText     (LPCSTR lpcszName, CString& strBuff);
static int  WComboSelLen      (LPCSTR lpcszName);
static void WComboItemText    (LPCSTR lpcszName, int iIndex, CString& strBuff);
static int  WComboItemLen     (LPCSTR lpcszName, int iIndex);
static int  WComboItemExists  (LPCSTR lpcszName, LPCSTR lpcszItem);
static void WComboItemClk     (LPCSTR lpcszName, int iIndex);
static void WComboItemClk     (LPCSTR lpcszName, LPCSTR lpcszItem);
static void WComboItemDblClk  (LPCSTR lpcszName, int iIndex);
static void WComboItemDblClk  (LPCSTR lpcszName, LPCSTR lpcszItem);
//static void WComboClear       (LPCSTR lpcszName);
//static void WComboAddItem     (LPCSTR lpcszName, LPCSTR lpcszText);
//static void WComboDelItem     (LPCSTR lpcszName, int iIndex);
//static void WComboDelItem     (LPCSTR lpcszName, LPCSTR lpcszItem);
static BOOL WComboEnabled     (LPCSTR lpcszName);
static void WComboSetFocus    (LPCSTR lpcszName);


//---------------------------------------------------------------------------
// Editbox routines
//---------------------------------------------------------------------------
//static void WEditSetClass (LPCSTR lpcszClassName);
static BOOL WEditExists   (LPCSTR lpcszName);
static long WEditLen      (LPCSTR lpcszName);
static void WEditText     (LPCSTR lpcszName, CString& strBuff);
static void WEditSetText  (LPCSTR lpcszName, LPCSTR lpcszText);
static void WEditSelText  (LPCSTR lpcszName, CString& strBuff);
static long WEditSelLen   (LPCSTR lpcszName);
//static void WEditLineText (LPCSTR lpcszName, long lIndex, CString& strBuff);
//static long WEditLineLen  (LPCSTR lpcszName, long lIndex);
//static long WEditPos      (LPCSTR lpcszName);
//static long WEditLine     (LPCSTR lpcszName);
//static long WEditChar     (LPCSTR lpcszName);
//static long WEditFirst    (LPCSTR lpcszName);
//static long WEditLines    (LPCSTR lpcszName);
static void WEditClick    (LPCSTR lpcszName);
static BOOL WEditEnabled  (LPCSTR lpcszName);
static void WEditSetFocus (LPCSTR lpcszName) ;
//---------------------------------------------------------------------------
// Static control routines
//---------------------------------------------------------------------------
static BOOL WStaticExists   (LPCSTR lpcszName);
//MSTEST40.DLL does not export WStaticLen nor WStaticText nor WStaticSetClass
//static long WStaticLen		(LPCSTR lpcszName);
static void WStaticText     (LPCSTR lpcszName, CString& strBuff);
//static void WStaticSetClass (LPCSTR);

//---------------------------------------------------------------------------
// Error routines
//---------------------------------------------------------------------------
//static int  WError     (void);
//static void WErrorSet  (int errValue);
//static void WErrorText (CString& strBuff);
//static int  WErrorLen  (void);
//static void WErrorTrap (int iTrapID, int iAction, FARPROC lpfnCallBack);

/////////////////////////////////////////////////////////////////////////////
// TESTEVNT Wrappers
//

static int QueKeys (LPCSTR);
static int QueKeyDn (LPCSTR);
static int QueKeyUp (LPCSTR);
static int DoKeys (LPCSTR sz, BOOL bLiteral = FALSE, int nWaitForIdleTime = 5000);
static int DoKeyshWnd (HWND, LPCSTR, BOOL bLiteral = FALSE, int nWaitForIdleTime  = 5000);

static void QuePause (DWORD dw);
static int QueSetSpeed (WORD w);
static int QueSetFocus (HWND hwnd);
static int QueSetRelativeWindow (HWND hwnd);

static int QueMouseMove (POINT pt);
static int QueMouseDn (int, POINT pt);
static int QueMouseUp (int, POINT pt);
static int QueMouseClick (int, POINT pt);
static int QueMouseDblClk (int, POINT pt);
static int QueMouseDblDn (int, POINT pt);

//static int TimeDelay (int);

static int QueFlush (BOOL bRestoreKeyState = TRUE);
//static void QueEmpty (void);

/////////////////////////////////////////////////////////////////////////////
// TESTEVNT Wrappers
//

//static int CompFiles (CHAR FAR *lpszFileName1, INT Scr1, CHAR FAR *lpszFileName2, INT Scr2, INT CompareType);
//static int CompScreenActivate(CHAR FAR *lpszFileName, CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, wRect *lpRect, INT Scr1, INT Hide, //static int lag);
//static int CompScreen(CHAR FAR *lpszFileName, wRect *lpRect, INT Scr1, INT Hide, //static int lag);
//static int CompWindowActivate(CHAR FAR *lpszFileName, CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, INT Scr1, INT Hide, //static int lag);
//static int CompWindow(CHAR FAR *lpszFileName, INT hWnd, INT Scr1, INT Hide, //static int lag);
//static int DelScreen (CHAR FAR *lpszFileName, INT Scr);
//static int DumpFileToClip(CHAR FAR *lpszFileName, INT Scr);
//static int DumpScreenActivate(CHAR FAR *lpszFileName, CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, wRect *lpRect, INT Action, INT Scr1, //static int lag);
//static int DumpScreen(CHAR FAR *lpszFileName, wRect *lpRect, INT Action, INT Scr1, //static int lag);
//static int DumpSrnToClipActivate (CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, wRect *lpRect, INT Hide);
//static int DumpSrnToClip (wRect *lpRect, INT Hide);
//static int DumpWindowActivate(CHAR FAR *lpszFileName, CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, INT Action, INT Scr1, //static int lag);
//static int DumpWindow(CHAR FAR *lpszFileName, INT wHnd, INT Action, INT Scr1, //static int lag);
//static int DumpWndToClipActivate (CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, INT Hide);
//static int DumpWndToClip (INT hWnd, INT Hide);
//static int FileInfo(CHAR FAR *lpszFileName, wRect *lpRect, INT *VideoMode, INT *Count);
//static int GetDLLVersion (CHAR FAR *lpszFileName);
//static int GetMaxScreen(CHAR FAR *lpszFileName);
//static int GetOS (CHAR FAR *lpszFileName);
//static int SaveFileToDIB (CHAR FAR *lpszFileName1, INT Scr, CHAR FAR *lpszFileName2);
//static int SaveSrnToDIBActivate(CHAR FAR *lpszFileName, CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, wRect *lpRect, INT Hide);
//static int SaveSrnToDIB(CHAR FAR *lpszFileName, wRect *lpRect, INT Hide);
//static int SaveWndToDIBActivate(CHAR FAR *lpszFileName, CHAR FAR *OpenKeys, CHAR FAR *CloseKeys, INT Hide);
//static int SaveWndToDIB(CHAR FAR *lpszFileName, INT hWnd, INT Hide);
//static int ViewScreen(CHAR FAR *lpszFileName, INT hWnd, INT Scr1, INT Action);

};

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
extern GUI_DATA CMSTest MST;

#endif //__TESTWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\ime32.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1985-92, Microsoft Corporation

Module Name:

    ime.h

Abstract:

    Procedure declarations, constant definitions and macros for the IME
    component.

--*/

#ifndef _IME_
#define _IME_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifdef KOREA     // BeomOh - 10/05/92
#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)
#endif // KOREA

//
//      Virtual Keys
//
#ifdef KOREA    // BeomOh - 9/29/92
#define VK_FINAL        0x18    /* dummy VK to make final on mouse down */
#define VK_CONVERT      0x1C
#define VK_NONCONVERT   0x1D
#define VK_ACCEPT       0x1E
#define VK_MODECHANGE   0x1F
#else // KOREA
#define VK_DBE_ALPHANUMERIC              0x0f0
#define VK_DBE_KATAKANA                  0x0f1
#define VK_DBE_HIRAGANA                  0x0f2
#define VK_DBE_SBCSCHAR                  0x0f3
#define VK_DBE_DBCSCHAR                  0x0f4
#define VK_DBE_ROMAN                     0x0f5
#define VK_DBE_NOROMAN                   0x0f6
#define VK_DBE_ENTERWORDREGISTERMODE     0x0f7
#define VK_DBE_ENTERIMECONFIGMODE        0x0f8
#define VK_DBE_FLUSHSTRING               0x0f9
#define VK_DBE_CODEINPUT                 0x0fa
#define VK_DBE_NOCODEINPUT               0x0fb
#define VK_DBE_DETERMINESTRING           0x0fc
#endif // KOREA


//
//     switch for wParam of IME_SETCONVERSIONWINDOW
//
#define	MCW_DEFAULT             0x00
#define	MCW_RECT                0x01
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04
#define	MCW_VERTICAL            0x08
#define MCW_HIDDEN              0x10

//
//    switch for wParam of IME_SETCONVERSIONMODE
//       and IME_GETCONVERSIONMODE
//
#define IME_MODE_ALPHANUMERIC	0x0001
#ifdef KOREA    // BeomOh - 9/29/92
#define IME_MODE_SBCSCHAR       0x0002
#define IME_MODE_HANJACONVERT   0x0004
#else
#define IME_MODE_KATAKANA	0x0002
#define IME_MODE_HIRAGANA	0x0004
#define IME_MODE_SBCSCHAR	0x0008
#define IME_MODE_DBCSCHAR	0x0010
#define IME_MODE_ROMAN		0x0020
#define IME_MODE_NOROMAN	0x0040
#define IME_MODE_CODEINPUT	0x0080
#define IME_MODE_NOCODEINPUT	0x0100
//
// 0x1, 0x2, 0x4, 0x20, 0x40, 0x80, 0x100 is not for CWIN  ;Internal
// 0x8, 0x10, and below IME_MODE_??? will be use by CWIN   ;Internal
//
#endif

//
//     IME APIs
//
#define IME_GETIMECAPS            0x03
#define IME_SETOPEN               0x04
#define	IME_GETOPEN               0x05
#define IME_GETVERSION            0x07
#define IME_SETCONVERSIONWINDOW   0x08
#ifdef  KOREA
#define IME_MOVEIMEWINDOW         IME_SETCONVERSIONWINDOW
#else
#endif
#define IME_SETCONVERSIONMODE     0x10
#ifdef KOREA    // BeomOh - 10/23/92
#define IME_SET_MODE              0x12
#else
#endif
#define IME_GETCONVERSIONMODE     0x11
#define IME_SENDVKEY              0x13
#define IME_ENTERWORDREGISTERMODE 0x18
#define IME_SETCONVERSIONFONTEX   0x19
#ifdef  KOREA   // 01/12/93 KDLee MSCH
#define IME_GETMNTABLE            0x42  // reserved for HWIN ;Internal
#endif

//#ifdef PEN                                    ;Internal
//#endif                                        ;Internal

#ifdef KOREA    // BeomOh - 9/29/92
//
// IME_CODECONVERT subfunctions
//
#define IME_BANJAtoJUNJA        0x13
#define IME_JUNJAtoBANJA        0x14
#define IME_JOHABtoKS           0x15
#define IME_KStoJOHAB           0x16

//
// IME_AUTOMATA subfunctions
//
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03

//
// IME_HANJAMODE subfunctions
//
#define IME_REQUEST_CONVERT     0x01
#define IME_ENABLE_CONVERT      0x02

//
// IME_MOVEIMEWINDOW subfunctions
//
#define INTERIM_WINDOW          0x00
#define MODE_WINDOW             0x01
#define HANJA_WINDOW            0x02
#endif // KOREA

//
//







// CTRL_MODIFY is "or" all modify bits, but now only one

//
//    error code
//
#define IME_RS_ERROR            0x01    // genetal error
#define IME_RS_NOIME            0x02    // IME is not installed
#define IME_RS_TOOLONG          0x05    // given string is too long
#define IME_RS_ILLEGAL          0x06    // illegal charactor(s) is string
#define IME_RS_NOTFOUND         0x07    // no (more) candidate
#define IME_RS_NOROOM           0x0a    // no disk/memory space
#define IME_RS_DISKERROR        0x0e    // disk I/O error
#define IME_RS_INVALID          0x11    // Win3.1/NT
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode

//
//   report messge from IME to WinApps
//
#define WM_IME_REPORT		0x0280

//
//   report message parameter for WM_IME_REPORT
//
#define IR_STRINGSTART		0x100
#define IR_STRINGEND		0x101
#define IR_OPENCONVERT		0x120
#define IR_CHANGECONVERT	0x121
#define IR_CLOSECONVERT		0x122
#define IR_FULLCONVERT		0x123
#define IR_IMESELECT		0x130
#define IR_STRING		0x140
#define IR_DBCSCHAR             0x160
#define IR_UNDETERMINE          0x170
#define IR_STRINGEX             0x180   // New for 3.1

#define WM_IMEKEYDOWN           0x290
#define WM_IMEKEYUP             0x291


LRESULT WINAPI SendIMEMessageExA(HWND, LPARAM);
LRESULT WINAPI SendIMEMessageExW(HWND, LPARAM);
#ifdef UNICODE
#define SendIMEMessageEx  SendIMEMessageExW
#else
#define SendIMEMessageEx  SendIMEMessageExA
#endif // !UNICODE

#ifndef _WINDEF_
typedef unsigned int UINT;
#endif // _WINDEF_

//
// IMESTRUCT structure for SendIMEMessageEx
//
typedef struct tagIMESTRUCT {
    UINT     fnc;        // function code
    WPARAM   wParam;     // word parameter
    UINT     wCount;     // word counter
    UINT     dchSource;  // offset to Source from top of memory object
    UINT     dchDest;    // offset to Desrination from top of memory object
    LPARAM   lParam1;
    LPARAM   lParam2;
    LPARAM   lParam3;
} IMESTRUCT,*PIMESTRUCT,NEAR *NPIMESTRUCT,FAR *LPIMESTRUCT;




//
// UNDETERMINESTRING structure for IR_UNDETERMINE
//
typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT,*PUNDETERMINESTRUCT,NEAR *NPUNDETERMINESTRUCT,FAR *LPUNDETERMINESTRUCT;


typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT,NEAR *NPSTRINGEXSTRUCT,FAR *LPSTRINGEXSTRUCT;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _IME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\platform.h ===
/*
    PLATFORM.H
    ==========

    Copyright 1995 Microsoft Corp.


    History:

    Who      When       What
    ---------------------------
    CFlaat   5-30-95   Created
    CFlaat   6-25-95   Finished creating
    CFlaat   6-27-95   Added Win32s



      This file represents the interface of the CPlatform
	class, a mechanism by which CAFE tests and toolsets can
	indicate their hardware, OS, and language properties.

*/


#ifndef __PLATFORM_H__
#define __PLATFORM_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "toolxprt.h"

/*
    CPlatform class

        An instance of this class represents some platform or range of
    platforms.  The OS model is a tree, which currently looks like this:

         Any
		/   \
	  Mac   Win32
     /  |   |   
  PPC 68K   +- Intel
            +- MIPS
			+- Alpha
			\- PowerPC


    Likely future additions are PA-RISC for Win32 and possibly
	the Copland OS for Mac.

	    Languages are not modeled as a tree, but must either match
    exactly or have a test marked as working with language "Any".

	    The most important comparison between CPlatform instances
	is through the "Includes" function.  This returns true if one
	platform description is general enough to "include" another.
	The idea is that a test's set of platform information will be
	compared against a product's, to see if the scope of a test
	"includes" that product.

*/

class TOOLSET_CLASS CPlatform
{
public:

  // available languages

  class CLanguage;

  static CLanguage const AnyLanguage;

  static CLanguage const English;
  static CLanguage const German;
  static CLanguage const Japanese;


  // available operating systems

  class COS;

  static COS const AnyOS;  // this includes all OS's

  static COS const Win32;  // this includes all Win32 OS's
    static COS const Win32Mips;
    static COS const Win32Alpha;
    static COS const Win32PowerPC;
    static COS const Win32Intel;
      static COS const Win32s;   // subtype of Win32Intel

  static COS const Mac;  // this includes all Mac OS's
    static COS const Mac68K;
    static COS const MacPowerPC;

  static COS const Xbox;  // this includes all Xbox OS's

// arrays of OS's & languages

  typedef CArray<COS *, COS *> COSArray;
  typedef CArray<CLanguage *, CLanguage *> CLangArray;


public:

  CPlatform(const COS &rOS, const CLanguage &rLang);  // client ctor
  CPlatform(const CPlatform &rPlatform);  // copy ctor

  int operator ==(const CPlatform &rPlatform) const;  // comparison
  int operator !=(const CPlatform &rPlatform) const;  // comparison
  BOOL Includes(const CPlatform &rPlatform) const;    // asks the question "are you as general or more general than this platform"

  void AssertValid(void) const;

  static const COSArray * GetOSArray(void);
  static const CLangArray * GetLangArray(void);

protected:

  // OS data

  COS const &m_rOS;

  // language data

  CLanguage const &m_rLang;

  // arrays of "real live" OS's & languages, excluding abstract ones

  static COSArray s_aryOS;
  static CLangArray s_aryLang;


public:

  class TOOLSET_CLASS COS
  {
  friend class CPlatform;
  
  protected:

    unsigned const m_uLowerLimit, m_uUpperLimit;
    CString m_strName, m_strShortName;
    BOOL m_bAbstract;

    BOOL IsAbstract(void) const;

  public:

    COS(LPCSTR szName, LPCSTR szShortName, unsigned const uLowerLimit, unsigned const uUpperLimit, BOOL bAbstract);  // ctor for platform.cxx only
    int operator ==(const COS &rOS) const;  // comparison
    int operator !=(const COS &rOS) const;  // comparison
    BOOL Includes(const COS &rOS) const;    // asks the question "are you either as general or more general than rOS?"

    LPCSTR GetName(void) const { return m_strName; }
    LPCSTR GetShortName(void) const { return m_strShortName; }

    void AssertValid(void) const;
  };


  class TOOLSET_CLASS CLanguage
  {
  friend class CPlatform;

  protected:

    unsigned const m_uID;
	  BOOL m_bDBCS;
	  CString m_strName;
    BOOL m_bAbstract;

    BOOL IsAbstract(void) const;

  public:

    CLanguage(LPCSTR szName, unsigned const uID, BOOL bDBCS, BOOL bAbstract);
  	int operator ==(const CLanguage &rLang) const;
  	int operator !=(const CLanguage &rLang) const;
  	BOOL IsDoubleByte(void) const;

    LPCSTR GetName(void) const { return m_strName; }

    void AssertValid(void) const;
  };


protected:

friend class CLanguage;
friend class COS;

  static void RegisterOS(COS *pOS);
  static void RegisterLanguage(CLanguage *pLang);

};

CPlatform::COS TOOLSET_API *GetOSFromShortName(LPCSTR szShortName);
CPlatform::CLanguage TOOLSET_API *GetLangFromName(LPCSTR szName);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\rawstrng.h ===
/////////////////////////////////////////////////////////////////////////////
// rawstrng.h
//
// email	date		change
// jimgries	3/30/95     created
//
// copyright 1995 Microsoft

// Interface of the CRawListString class.

// Derive privately because we don't want people using this kind of
// item as a string.
class CRawListString : private CString
{                                                               
    int m_nLen;
    char* m_pStartPos;
    BOOL m_bParsed;

public:
    CRawListString();
    CRawListString(const CString& str);
    virtual ~CRawListString();

    void Reset();
    operator LPCSTR() const;

    friend CRawListString& operator>>(CRawListString&, int&);
    friend CRawListString& operator>>(CRawListString&, CString&);
    friend class CSuiteDoc;
};

CRawListString& operator>>(CRawListString&, int&);
CRawListString& operator>>(CRawListString&, CString&);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\randtest.h ===
/////////////////////////////////////////////////////////////////////////////
// randtest.h
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1994 Microsoft

// Interface of the CRandomTest class

#ifndef __RANDTEST_H__
#define __RANDTEST_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "test.h"
#include "vertex.h"
#include "set.h"

///////////////////////////////////////////////////////////////////////////////
// CRandomTest macros -- for use in derived classes

#define DECLARE_RANDOM_TEST(this_class, subsuite_class)			\
		DECLARE_DYNAMIC(this_class)								\
	public:														\
		this_class(subsuite_class* pSubSuite);					\
		subsuite_class* GetSubSuite(void);

#define IMPLEMENT_RANDOM_TEST(this_class, base_class, test_name, num_comparisons, subsuite_class, pre_cond, post_cond)	\
	IMPLEMENT_DYNAMIC(this_class, base_class)													\
	this_class::this_class(subsuite_class* pSubSuite)											\
	: base_class(pSubSuite, test_name, num_comparisons, NULL, pre_cond, post_cond)				\
	{																							\
	}																							\
	subsuite_class* this_class::GetSubSuite(void)												\
	{																							\
		ASSERT(m_pSubSuite->IsKindOf(RUNTIME_CLASS(subsuite_class)));							\
		return (subsuite_class*)m_pSubSuite;													\
	}

// empty set
extern const CSet<CVertex> EmptySet;

// vertex addition
CSet<CVertex> operator+(const CVertex& lhsVertex, const CVertex& rhsVertex);

///////////////////////////////////////////////////////////////////////////////
//	CTest abstract base class

class CRandomTest : public CTest
{
	DECLARE_DYNAMIC(CRandomTest)

// constructor/destructor
public:
	CRandomTest(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL, CSet<CVertex> setPreCond = EmptySet, CSet<CVertex> setPostCond = EmptySet);
	virtual ~CRandomTest();

// Operations
public:
	virtual void PreRun(void);

	BOOL SetPreCond(CSet<CVertex>& setPreCond);
	CSet<CVertex>& GetPreCond(void);

	BOOL SetPostCond(CSet<CVertex>& setPostCond);
	CSet<CVertex>& GetPostCond(void);

// Data
protected:
	// test attributes: pre- and post-conditions
	CSet<CVertex> m_setPreCond;
	CSet<CVertex> m_setPostCond;

// don't want anyone to call these
protected:
	CRandomTest() { }
};

// test types
#define TEST_TYPE_RANDOM	0x03

// accel ed vertices
extern const CVertex AccelBegin;
extern const CVertex AccelOpen;
// bitmap ed vertices
extern const CVertex BmpBegin;
extern const CVertex BmpOpen;
// cursor ed vertices
extern const CVertex CursorBegin;
extern const CVertex CursorOpen;
// debugger vertices
extern const CVertex DbgBegin;
extern const CVertex DbgDebug;
// dialog ed vertices
extern const CVertex DialogBegin;
extern const CVertex DialogOpen;
// icon ed vertices
extern const CVertex IconBegin;
extern const CVertex IconOpen;
// menu ed vertices
extern const CVertex MenuBegin;
extern const CVertex MenuOpen;
// project vertices
extern const CVertex ProjBegin;
extern const CVertex ProjOpen;
extern const CVertex ProjBuilt;
// res script vertices
extern const CVertex ResBegin;
extern const CVertex ResOpen;
// source ed vertices
extern const CVertex SrcBegin;
extern const CVertex SrcOpen;
// string ed vertices
extern const CVertex StringBegin;
extern const CVertex StringOpen;
// toolbar ed vertices
extern const CVertex ToolbarBegin;
extern const CVertex ToolbarOpen;
// version ed vertices
extern const CVertex VersionBegin;
extern const CVertex VersionOpen;

#endif //__RANDTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\set.h ===
/////////////////////////////////////////////////////////////////////////////
// set.h
//
// email	date		change
// briancr	08/02/95	created
//
// copyright 1995 Microsoft

// Interface of the CSet<T> class

#ifndef __SET_H__
#define __SET_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSet class

template <class T> class CSet: public CObject
{
// constructor/destructor
public:
	CSet();
	CSet(const T item);
	CSet(const CSet<T>& set);
	virtual ~CSet();

// operations
public:
	void Add(const T item);
	void Add(const CSet<T>& set);
	void Copy(const CSet<T>& set);
	void RemoveAll(void);

	POSITION GetStartPosition(void) const;
	T GetNext(POSITION& pos) const;

	BOOL Contains(const T& item) const;
	BOOL IsEmpty(void) const;
	int GetSize(void) const;

	CSet<T>& operator=(const CSet<T>& set);
	BOOL operator==(const CSet<T>& set);
	BOOL operator!=(const CSet<T>& set);
	CSet<T> operator+(const CSet<T>& set);

// data types
protected:
	typedef CArray<T, T&> SetArray;

// data
protected:
	SetArray* m_pSet;
};

#endif //__SET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\shlv1.h ===
/////////////////////////////////////////////////////////////////////////////
// shlv1.h
//
// email	date		change
// briancr	12/05/94	created
//
// copyright 1994 Microsoft

// Backward compatibility

#ifndef __SHLV1_H__
#define __SHLV1_H__

#include "..\support\guitools\ide\shl\uwbframe.h"
#include "..\support\guitools\ide\shl\cowrkspc.h"

#include "shlxprt.h"

#pragma warning(disable: 4091)

#define LANG_JAPAN 1000

#define MAX_ATOM_LENGTH 256

//#define XSAFETY ((CVCTools*)m_pToolset)->GetIDE()->IsActive()
#define XSAFETY (((CIDESubSuite*)GetSubSuite())->GetIDE()->IsActive())

SHL_API LPCSTR CAFEv1GetLocString(UINT id, int nOffset = -1);

SHL_API struct LOCSTR_STRUCT
{
	UINT id;			// IDSS_FOO
	LPCSTR string;		// "localized 'foo'"
};

extern SHL_DATA LOCSTR_STRUCT m_aLocStr[];
extern SHL_DATA LOCSTR_STRUCT m_aLocStrJ[];

#endif // __SHLV1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\shlxprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	shlxprt.h (shell export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		SHL DLL defines
//

#ifndef __SHLXPRT_H__
#define __SHLXPRT_H__

#ifdef EXPORT_SHELL
	#define SHL_CLASS AFX_EXT_CLASS
	#define SHL_API   AFX_EXT_API
	#define SHL_DATA  AFX_EXT_DATA
#else
	#define SHL_CLASS __declspec(dllimport)
	#define SHL_API   __declspec(dllimport)
	#define SHL_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "shld.lib")
	#else
		#pragma comment(lib, "shl.lib")
	#endif
#endif

#endif // __GUIXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\subsuite.h ===
/////////////////////////////////////////////////////////////////////////////
// subsuite.h
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Interface of the CSubSuite class

#ifndef __SUBSUITE_H__
#define __SUBSUITE_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifdef _DEBUG
	#pragma comment(lib, "subsuitd.lib")
#else
	#pragma comment(lib, "subsuite.lib")
#endif

#include "log.h"
#include "settings.h"

class CTest;	// Forward declaration.
class CToolset;
class CIDE;
	
///////////////////////////////////////////////////////////////////////////////
// TESTLIST macros
//
// To create a list of tests, call the TESTLIST macros as follows:
//
// BEGIN_TESTLIST(CThisClass'sName)
//   TEST(CTestClass, "Test name", [ Run | NoRun ], Pre-condition, Post-condition)
// END_TESTLIST()

#define DECLARE_TESTLIST()						\
	protected:									\
		virtual void InitializeTestList(void);

#define BEGIN_TESTLIST(this_class)												\
	void this_class::InitializeTestList(void)									\
	{																			\
		const char* const THIS_FUNCTION = #this_class "::InitializeTestList";	\
		CTest* pTest;															\
		CTest* pTestDependency;													\
		POSITION pos;															\
		m_listTests.RemoveAll();

#define TEST(test_class, test_run)				\
		pTest = new test_class(this);			\
		pTest->SetRunState(test_run);			\
		m_listTests.AddTail(pTest);

// in order for the chain of dependencies to work properly, we must store a
// pointer to the instantiation of the dependency (i.e., we can't instantiate
// another test because it won't have a dependency.
// to do this, we'll iterate through all the tests "registered" so far
// and use MFC's RTTI to find the test of the correct type
#define DEPENDENCY(test_dependency)				\
		for (pos = m_listTests.GetHeadPosition(); pos != NULL; ) {		\
			pTestDependency = m_listTests.GetNext(pos);							\
			if (pTestDependency->IsKindOf(RUNTIME_CLASS(test_dependency))) {	\
				pTest->SetDependency(pTestDependency);							\
				break;															\
			}																	\
		}																		\
		if (pos == NULL) {														\
			CString str;														\
			str.Format("%s: unable to find the dependency specified (%s) for the test: '%s'.", THIS_FUNCTION, #test_dependency, (LPCSTR)pTest->GetName()); \
			AfxMessageBox(str);													\
		}

#define END_TESTLIST()										\
		DBG_UNREFERENCED_LOCAL_VARIABLE(pTest);				\
		DBG_UNREFERENCED_LOCAL_VARIABLE(pos);				\
		DBG_UNREFERENCED_LOCAL_VARIABLE(pTestDependency);	\
	}

///////////////////////////////////////////////////////////////////////////////
// CSubSuite helper macros -- used by IMPLEMENT_SUBSUITE

#define IMPLEMENT_INSTANTIATESUBSUITE(this_class)									\
		this_class *suiteTable[20];													\
		int noAttached=0;

#define IMPLEMENT_CREATESUBSUITE(this_class)										\
	extern "C" __declspec(dllexport) CSubSuite* CreateSubSuite(LPCSTR SzCmdLine)	\
	{																				\
		ASSERT(noAttached<20);														\
		suiteTable[noAttached]= new this_class;										\
		TRACE1(#this_class " constructing the object@%x\n",suiteTable[noAttached]);	\
		suiteTable[noAttached]->m_CmdLine=SzCmdLine;								\
		return suiteTable[noAttached++];											\
	}

#define IMPLEMENT_DESTROYSUBSUITE(this_class)										\
	extern "C" __declspec(dllexport) void DestroySubSuite(CSubSuite *psuite)		\
	{	int i;																		\
		ASSERT(noAttached<=20);														\
		for(i=0;i<noAttached;i++)													\
			if(suiteTable[i]==psuite)												\
			{																		\
				TRACE1(#this_class " destructing the object@%x\n",suiteTable[i]);	\
				delete suiteTable[i];												\
				suiteTable[i]=NULL;													\
				break;																\
			}																		\
		if(i==noAttached-1)noAttached--;											\
	}

#define IMPLEMENT_ISDEBUGBUILD(debug_build)											\
	extern "C" __declspec(dllexport) BOOL IsDebugBuild(void)						\
	{																				\
		return debug_build;															\
	}

#define IMPLEMENT_DLLMAIN(this_class)												\
	static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };						\
	extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)	\
	{																				\
		if (dwReason == DLL_PROCESS_ATTACH) {										\
			TRACE0(#this_class " DLL Initializing!\n");								\
			AfxInitExtensionModule(extensionDLL, hInstance);						\
			new CDynLinkLibrary(extensionDLL);										\
		}																			\
		else if (dwReason == DLL_PROCESS_DETACH) {									\
			while(--noAttached>=0)													\
			{																		\
				if(suiteTable[noAttached]==NULL)									\
					continue;														\
				TRACE1(#this_class " destructing the object@%x\n",suiteTable[noAttached]);\
				delete suiteTable[noAttached];										\
				suiteTable[noAttached]=NULL;										\
			}																		\
			TRACE0(#this_class "DLL Terminating!\n");								\
			AfxTermExtensionModule(extensionDLL);									\
																					\
		}																			\
		return 1;																	\
		UNREFERENCED_PARAMETER(lpReserved);											\
	}

#ifdef _DEBUG
	#define DEBUGBUILD TRUE
#else
	#define DEBUGBUILD FALSE
#endif

///////////////////////////////////////////////////////////////////////////////
// CSubSuite macros -- for use in user derived classes

// includes DECLARE_DYNAMIC in the subsuite and provides a constructor
// use this macro in the definition of the subsuite class
#define DECLARE_SUBSUITE(this_class)			\
		DECLARE_DYNAMIC(this_class)				\
	public:										\
		this_class(void);

// includes IMPLEMENT_DYNAMIC in the subsuite and provides the constructor
// implementation, subsuite instantiation, and CreateSubSuite implementation
#define IMPLEMENT_SUBSUITE(this_class, base_class, subsuite_name, subsuite_owner)	\
	IMPLEMENT_DYNAMIC(this_class, base_class)										\
	this_class::this_class(void)													\
	: base_class(subsuite_name, subsuite_owner)										\
	{																				\
	}																				\
	IMPLEMENT_INSTANTIATESUBSUITE(this_class)										\
	IMPLEMENT_CREATESUBSUITE(this_class)											\
/*	IMPLEMENT_DESTROYSUBSUITE(this_class)	*/										\
	IMPLEMENT_ISDEBUGBUILD(DEBUGBUILD)												\
	IMPLEMENT_DLLMAIN(this_class)


// define default RUN and NORUN constants
#define RUN CTest::RS_Run
#define DONTRUN CTest::RS_NoRun

// preconditions and postconditions are not completely defined yet
// for now, we'll just define these constants that will be used in the TEST macro
#define NO_PRE_COND NULL
#define NO_POST_COND NULL

///////////////////////////////////////////////////////////////////////////////
//	CSubSuite class

class CSubSuite: public CObject
{
	DECLARE_DYNAMIC(CSubSuite)

// data types
public:
	// typedef for the test list
	typedef CTypedPtrList<CPtrList, CTest*> TestList;

// constructor/destructor
public:
	CSubSuite(LPCSTR pszName, LPCSTR pszOwner);
	virtual ~CSubSuite();

// Attributes
public:
	CString GetName(void);
	CString GetOwner(void);
	TestList* GetTestList(void);

	CToolset* GetToolset(void);
	CLog* GetLog(void);

	CString GetCWD(void);
	CSettings *m_SuiteParams;
	CString m_CmdLine;
// Operations
public:
	// if the user wants to do any set up before the subsuite is run,
	// he/she needs to override SetUp and call the base class's SetUp.
	virtual void SetUp(BOOL bCleanUp);
	// if the user wants to do any clean up after the subsuite is run,
	// he/she needs to override CleanUp and call the base class's CleanUp.
	virtual void CleanUp(void);

// supporting operations
public:
	// Load Initialization should never be overridden
	void LoadInitialization(HINSTANCE hDLL);
	// do not override Initialize and Finalize unless you have a good reason
	virtual BOOL Initialize(CToolset* pToolset);
	virtual BOOL Finalize(void);


// test list
protected:
	// use DECLARE_TESTLIST in your derived class to override InitializeTestList
	virtual void InitializeTestList(void) = 0;

// Data
protected:
	// store the subsuite's name and owner
	CString m_strName;
	CString m_strOwner;
	// store the list of tests in this subsuite
	TestList m_listTests;
	// store the toolset and the log
	CToolset* m_pToolset;
	CLog* m_pLog;
	// store the current working directory
	CString m_strCWD;
	// store this DLLs handle
	HINSTANCE m_hDLL;

	// Store the start and end times of this subsuite.
	CTime m_timeStart;
	CTime m_timeEnd;

// no one should call these
protected:
	CSubSuite();
};

///////////////////////////////////////////////////////////////////////////////
// CGUISubSuite

class CGUISubSuite: public CSubSuite
{
	DECLARE_DYNAMIC(CGUISubSuite)

// ctor/dtor
public:
	CGUISubSuite(LPCSTR pszName, LPCSTR pszOwner);
	~CGUISubSuite();

// supporting operations
	virtual BOOL Initialize(CToolset* pToolset);
	virtual BOOL Finalize(void);

// no one should call these
protected:
	CGUISubSuite();
};

///////////////////////////////////////////////////////////////////////////////
// CIDESubSuite

class CIDESubSuite: public CGUISubSuite
{
	DECLARE_DYNAMIC(CIDESubSuite)

// ctor/dtor
public:
	CIDESubSuite(LPCSTR pszName, LPCSTR pszOwner);
	~CIDESubSuite();

// operations
public:
	CIDE* GetIDE(void);
	// in case memory leaks must be set to !=0
	void ExpectedMemLeaks(int nExpectedLeaks);

// supporting operations
	virtual BOOL Initialize(CToolset* pToolset);
	virtual BOOL Finalize(void);

	virtual void CleanUp(void);

// data
protected:
	CIDE* m_pIDE;

// no one should call these
protected:
	CIDESubSuite();
};

#endif //__SUBSUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\Strings.h ===
#define IDSS_WORKBENCH_TITLEBAR						5000
#define IDSS_WORKBENCH_CLASSNAME					5001
#define IDSS_FIF_OCCURANCES							5002
#define IDSS_FIF_NOTFOUND							5003
#define IDSS_FIF_TITLE								5004
#define IDSS_SB_TITLE								5005
#define IDSS_TB_TITLE								5006
#define IDSS_TB_STANDARD							5007
#define IDSS_TB_EDIT								5008
#define IDSS_TB_RESOURCE							5009
#define IDSS_TB_DEBUG								5010
#define IDSS_TB_BROWSE								5011
#define IDSS_TB_BUILD								5012
#define IDSS_TB_CONTROLS							5013
#define IDSS_TB_DIALOG								5014
#define IDSS_TB_COLORS								5015
#define IDSS_TB_GRAPHICS							5016
#define IDSS_TB_TEXT_TOOL							5017
#define IDSS_TB_BAD_PARAM							5018
#define IDSS_THREAD_TITLE							5019
#define IDSS_EXCPT_TITLE							5020
#define IDSS_EXCPT_EXCEPT_NAME						5021
#define IDSS_BP_TITLE								5022
#define IDSS_QW_TITLE								5023
#define IDSS_FSA_TITLE								5024
#define IDSS_FO_TITLE								5025
#define IDSS_NEW_SOURCE								5026
#define IDSS_NEW_PROJECT							5027
#define IDSS_NEW_RC									5028
#define IDSS_NEW_BINARY								5029
#define IDSS_NEW_BITMAP								5030
#define IDSS_NEW_ICON								5031
#define IDSS_NEW_CURSOR								5032
#define IDSS_NEW_TITLE								5033
#define IDSS_NEW_RES_TITLE							5034
#define IDSS_RT_ACCELERATOR							5035
#define IDSS_RT_BITMAP								5036
#define IDSS_RT_CURSOR								5037
#define IDSS_RT_DIALOG								5038
#define IDSS_RT_ICON								5039
#define IDSS_RT_MENU								5040
#define IDSS_RT_STRING_TABLE						5041
#define IDSS_RT_VERSION								5042
#define IDSS_READY									5043
#define IDSS_NR_TITLE								5044
#define IDSS_IR_TITLE								5045
#define IDSS_ER_TITLE								5046
#define IDSS_PROP_TITLE								5047
#define IDSS_GOTO_TITLE								5048
#define IDSS_OD_TITLE								5049
#define IDSS_BRS_REFERENCES							5050
#define IDSS_BRS_DEFINITIONS						5051
#define IDSS_AW_TITLE_NEWPROJ						5052
#define IDSS_AW_TITLE_APPWIZ						5053
#define IDSS_AW_TITLE_CONFIRM						5054
#define IDSS_AW_TITLE_DBSOURCE						5055
#define IDSS_AW_TITLE_PROGRESS						5056
#define IDSS_AW_TITLE_STEP							5057
#define IDSS_AW_TITLE_OF							5058
#define IDSS_CLOSE									5059
#define IDSS_HELP									5060
#define IDSS_MSG_REQPRJ								5061
#define IDSS_MSG_OVRPRJ								5062
#define IDSS_NEW_TB_TITLE							5063
#define IDSS_CUSTOMIZE_TITLE						5064
#define IDSS_PROJGRP_SOURCE							5065
#define IDSS_PROJ_OPTIONS_TITLE						5066
#define IDSS_FD_TITLE								5067
#define IDSS_ADD_DIR_TITLE							5068
#define IDSS_REP_TITLE								5069
#define IDSS_STATBAR_COMPILING						5070
#define IDSS_STATBAR_PREPROCESSING					5071
#define IDSS_DBG_BREAK								5072
#define IDSS_DBG_RUN								5073
#define IDSS_PF_WIN32_X86							5074
#define IDSS_PF_MAC_68K								5075
#define IDSS_PF_WIN32_MIPS							5076
#define IDSS_FS_TITLE								5077
#define IDSS_DBG_BREAK_AT							5078
#define IDSS_DONE_DEP_UPDATE						5079
#define IDSS_DIALOG									5080
#define IDS_DIRECTORIES								5081
#define IDSS_RESOLVE_AMBIGUITY_TITLE				5082
#define IDSS_BRZ_FILEOUTLINE						5083
#define IDSS_BRZ_DEFREF								5084
#define IDSS_BRZ_DERCLASS							5085
#define IDSS_BRZ_BASECLASS							5086
#define IDSS_BRZ_CALLGRAPH							5087
#define IDSS_BRZ_CALLERGRAPH						5088
#define IDSS_RT_BINARY								5089
#define IDSS_NEW_RCT								5090
#define IDSS_BP_CONDITION_TITLE						5091
#define IDSS_OK										5092
#define IDSS_EXE_FOR_DBG_SESSION					5093
#define IDSS_YES									5094
#define IDSS_REPLACE								5095
#define IDSS_NOT_FOUND								5096
#define IDSS_WRAP_THIS_MAKEFILE						5097
#define IDSS_CATEGORY_GENERAL						5098
#define IDSS_PROJTYPE_APPWIZ_APP					5099
#define IDSS_PROJTYPE_APPWIZ_DLL					5100
#define IDSS_PROJTYPE_OLE_CONTROLWIZ				5101
#define IDSS_PROJTYPE_APPLICATION					5102
#define IDSS_PROJTYPE_DLL							5103
#define IDSS_PROJTYPE_CONSOLE						5104
#define IDSS_PROJTYPE_STATIC_LIB					5105
#define IDSS_PROJTYPE_QUICKWIN						5106
#define IDSS_PROJTYPE_STD_GRAPH						5107
#define IDSS_PROJTYPE_GENPROJECT					5108
#define IDSS_PROJTYPE_EXT_TARG						5109
#define IDSS_PROJTYPE_CUST_APPWIZ					5110
#define IDSS_SAVE									5111
#define IDSS_PROJSET_GENERAL						5112
#define IDSS_PROJSET_DEBUG							5113
#define IDSS_PROJSET_CUSTBUILD						5114
#define IDSS_PROJSET_CPLUSPLUS						5115
#define IDSS_PROJSET_FORTRAN						5116
#define IDSS_PROJSET_LINKER							5117
#define IDSS_PROJSET_RESOURCES						5118
#define IDSS_PROJSET_TYPE_LIB						5119
#define IDSS_PROJSET_BROWSER						5120
#define IDSS_REMOTE_EXE_NAME_REQUIRED				5121
#define IDSS_REMOTE_LOCAL_EXE_MISMATCH				5122
#define IDSS_CANCEL									5123
#define IDSS_PROJ_WORKSPACE_TITLE					5124
#define IDSS_WRKSPC_BUILD_PANE						5125
#define IDSS_WRKSPC_HELP_PANE						5126
#define IDSS_WRKSPC_RESOURCE_PANE					5127
#define IDSS_WRKSPC_CLASS_PANE						5128
#define IDSS_VAR_PROP_TYPE							5129
#define IDSS_ASM_WND_TITLE							5130
#define IDSS_VAR_WND_TITLE							5131
#define IDSS_WATCH_WND_TITLE						5132
#define IDSS_MEM_WND_TITLE							5133
#define IDSS_REG_WND_TITLE							5134
#define IDSS_STACK_WND_TITLE						5135
#define IDSS_CONNEC_DLG_TITLE						5136
#define IDSS_VAR_PANE_THIS							5137
#define IDSS_VAR_PANE_AUTO							5138
#define IDSS_VAR_PANE_LOCALS						5139
#define IDSS_WATCH_PANE_WATCH1						5140
#define IDSS_WATCH_PANE_WATCH2						5141
#define IDSS_WATCH_PANE_WATCH3						5142
#define IDSS_WATCH_PANE_WATCH4						5143
#define IDSS_CREATE_DIR_PROMPT						5144
#define IDSS_BUILD_BROWSE_INFO_FILE					5145
#define IDSS_READ_ONLY								5146
#define IDSS_NO										5147
#define IDSS_FIND_LOCAL_MODULE_DLG_TITLE			5148
#define IDSS_OUTPUT_FILE							5149
#define IDSS_GENERATE_BROWSE_INFO					5150
#define IDSS_TIP_TITLE								5151
#define IDSS_OPENWRKDLG_TITLE						5152
#define IDSS_UPDATEDEP_TITLE						5153
#define IDSS_INFOTITLE_NOT_FOUND					5154
#define IDSS_MEMORY_ADDRESS_EDIT					5155
#define IDSS_LISTBOX_BUILD_SETTING_CFG				5156
#define IDSS_DLG_TITLE_WIN32_SERIAL					5157
#define IDSS_DLG_TITLE_WIN32_TCPIP					5158
#define IDSS_DLG_TITLE_MAC68K_SERIAL				5159
#define IDSS_DLG_TITLE_MAC68K_APPLETALK				5160
#define IDSS_DLG_TITLE_MAC68K_TCPIP					5161
#define IDSS_DLG_TITLE_MACPPC_SERIAL				5162
#define IDSS_DLG_TITLE_MACPPC_APPLETALK				5163
#define IDSS_DLG_TITLE_MACPPC_TCPIP					5164
#define IDSS_PLATFORM_WIN32							5165
#define IDSS_PLATFORM_MAC68K						5166
#define IDSS_PLATFORM_MACPPC						5167
#define IDSS_CONNECTION_LOCAL						5168
#define IDSS_CONNECTION_SERIAL						5169
#define IDSS_CONNECTION_TCPIP						5170
#define IDSS_CONNECTION_APPLETALK					5171
#define IDSS_CONNECTOR_COM1							5172
#define IDSS_CONNECTOR_COM2							5173
#define IDSS_CONNECTOR_COM3							5174
#define IDSS_CONNECTOR_COM4							5175
#define IDSS_BAUD_300								5176
#define IDSS_BAUD_600								5177
#define IDSS_BAUD_1200								5178
#define IDSS_BAUD_1800								5179
#define IDSS_BAUD_2400								5180
#define IDSS_BAUD_4800								5181
#define IDSS_BAUD_7200								5182
#define IDSS_BAUD_9600								5183
#define IDSS_BAUD_14400								5184
#define IDSS_BAUD_19200								5185
#define IDSS_BAUD_38400								5186
#define IDSS_BAUD_57600								5187
#define IDSS_DATA_BITS_5							5188
#define IDSS_DATA_BITS_6							5189
#define IDSS_DATA_BITS_7							5190
#define IDSS_DATA_BITS_8							5191
#define IDSS_FLOW_CONTROL_HARDWARE					5192
#define IDSS_FLOW_CONTROL_XONXOFF					5193
#define IDSS_STOP_BITS_1							5194
#define IDSS_STOP_BITS_1_PT_5						5195
#define IDSS_STOP_BITS_2							5196
#define IDSS_PARITY_NONE							5197
#define IDSS_PARITY_ODD								5198
#define IDSS_PARITY_EVEN							5199
#define IDSS_BP_CONDITION_BUTTON					5200
#define IDSS_PROJECT_IS_READ_ONLY					5201
#define IDSS_OPT_DEBUG_RETURN_VALUE					5202
#define IDSS_NEW_PROJ_LOCATION_ACCEL				5203
#define IDSS_REPLACE_EXISTING_FILE					5204
#define IDSS_TOP_LEVEL_PROJECT						5205
#define IDSS_SUBPROJECT_OF							5206
#define IDSS_INSERT_PROJ_ACCEL						5207
#define IDSS_BUILD_DEBUG							5208
#define IDSS_BUILD_RELEASE							5209
#define IDSS_WRKSPC_DATA_PANE						5210
#define IDSS_DLG_TITLE_BROWSE						5211
#define IDSS_OG_TITLE								5212
#define IDSS_OG_CUSTOM_TITLE						5213
#define IDSS_COMPATIBILITY_PROP_PAGE				5214
#define IDSS_DLG_TITLE_DEF_PROJECT_CONFIG			5215
#define IDSS_ERR_CHECK_CXX0017						5216
#define IDSS_WRKSPC_GALLERY_PANE					5217
#define IDSS_WRKSPC_EXPLORER_PANE					5218
#define IDSS_GALLERY_COMP_FOLDER					5219
#define IDSS_GALLERY_CONTROL_FOLDER					5220
#define IDSS_EXPLORER_DESKTOP						5221
#define IDSS_EXPLORER_MYCOMPUTER					5222
#define IDSS_EXPLORER_NETWORK						5223
#define IDSS_DELETE_TITLE							5224
#define IDSS_TB_WIZBAR								5225
#define IDSS_CUSTKB_MAIN							5226
#define IDSS_CUSTKB_VIEW							5227
#define IDSS_WIZBAR_HANDLER							5228
#define IDSS_WIZBAR_VIRTUAL							5229
#define IDSS_WIZBAR_MEMBER							5230
#define IDSS_NEW_CLASS								5231
#define IDSS_WIZBAR_CLASSDEF						5232
#define IDSS_WIZBAR_FUNCTDEF						5233
#define IDSS_WIZBAR_FUNCTDECL						5234
#define IDSS_NOFILE									5235
#define IDSS_STOREDPROC								5236
#define IDSS_TABLE									5237
#define IDSS_DIAGRAM								5238
#define IDSS_VIEW									5239
#define IDSS_WIN32_DEBUG							5240
#define IDSS_SQL_LOGIN								5241
#define IDSS_QUERY									5242
#define IDSS_TRIGGER								5243
#define IDSS_RUN_STOREDPROC							5244
#define IDSS_SQLSYNTAX_OK							5245
#define IDS_CONN_FAILED								5246
#define IDSS_IVTOPIC_TITLE							5247
#define IDSS_WORKSPACE_TITLE						5248
#define IDSS_RESULTS_TITLE							5249
#define IDSS_FP_TITLE								5250
#define IDSS_FIND_TITLE								5251
#define IDSS_IVBOOKMARKS_TITLE						5252
#define IDSS_DEFINESUBSETS_TITLE					5253
#define IDSS_SELECTSUBSETS_TITLE					5254
#define IDSS_SEARCH_TITLE							5255
#define IDSS_RESULTSPROPS_TITLE						5256
#define IDSS_FU_TITLE								5257
#define IDSS_ADDIVBOOKMARK_TITLE					5258
#define IDSS_EDITIVBOOKMARK_TITLE					5259
#define IDS_SEARCHFAILED							5260
#define IDS_SELECT_DSN								5261
#define IDSS_OPT_DEBUG_EDIT_AND_CONTINUE			5262
#define IDSS_ATTACH_TO_PROCESS_DLG_TITLE			5263
#define IDSS_ASSERTION_FAILED						5264
#define IDSS_ASSERTION_FROM_DEBUGLIB				5265
#define IDSS_OUTPUTWIN_COMPILING					5266
#define IDSS_OUTPUTWIN_LINKING						5267
#define IDSS_OUTPUTWIN_RC_COMPILING					5268
#define IDSS_OUTPUTWIN_CREATING_LIB					5269
#define IDSS_FUNNY_PROJ_NAME						5270
#define IDSS_PB_CUSTBLD_DESC_1						5271
#define IDSS_PB_CUSTBLD_DESC_2						5272
#define IDSS_RETURNED								5273
#define IDSS_RESOLVE_SOURCE_AMBIGUITY_TITLE			5274
#define IDS_STRING_START_MENU_RANGE					5999
#define IDS_FILEMENU								6000
#define IDS_EDITMENU								6001
#define IDS_VIEWMENU								6002
#define IDS_INSERTMENU								6003
#define IDS_BUILDMENU								6004
#define IDS_DEBUGMENU								6005
#define IDS_TOOLSMENU								6006
#define IDS_WINDOWMENU								6007
#define IDS_HELPMENU								6008
#define IDS_IMAGEMENU								6009
#define IDS_LAYOUTMENU								6010
#define IDS_PROJECTMENU								6011
#define IDS_ADDTOPROJECT							6012
#define IDS_SAVEWRK									6013
#define IDS_DATACON									6014
#define IDS_NEW										6100
#define IDS_OPEN									6101
#define IDS_CLOSE									6102
#define IDS_SAVE									6103
#define IDS_SAVEAS									6104
#define IDS_SAVEALL									6105
#define IDS_FINDINFILES								6106
#define IDS_PAGESETUP								6107
#define IDS_PRINT									6108
#define IDS_EXIT									6109
#define IDS_OPENWRK									6110
#define IDS_CLOSEWRK								6111
#define IDS_UNDO									6112
#define IDS_REDO									6113
#define IDS_CUT										6114
#define IDS_COPY									6115
#define IDS_PASTE									6116
#define IDS_CLEAR									6117
#define IDS_SELECTALL								6118
#define IDS_FIND									6119
#define IDS_REPLACE									6120
#define IDS_GOTO									6121
#define IDS_BOOKMARK								6122
#define IDS_PROPERTIES								6123
#define IDS_RESSYMBOLS								6124
#define IDS_RESINCLUDES								6125
#define IDS_FULLSCREEN								6126
#define IDS_TOOLBARS								6127
#define IDS_OUTPUT									6128
#define IDS_CLASSWIZARD								6129
#define IDS_WORKSPACE								6130
#define IDS_WATCH									6131
#define IDS_VARIABLES								6132
#define IDS_REGISTERS								6133
#define IDS_MEMORY									6134
#define IDS_CALLSTACK								6135
#define IDS_DISASSEMBLY								6136
#define IDS_GALLERY									6137
#define IDS_ADDFILES								6138
#define IDS_TARGET									6139
#define IDS_INSERTFILE								6140
#define IDS_COMPILE									6141
#define IDS_BUILD									6142
#define IDS_REBUILDALL								6143
#define IDS_STOPBUILD								6144
#define IDS_EXECUTE									6145
#define IDS_SETTINGS								6146
#define IDS_UPDATEDEP								6147
#define IDS_PROFILE									6148
#define IDS_NEWRESOURCE								6149
#define IDS_TESTDLG									6150
#define IDS_NEWSTRING								6151
#define IDS_NEWACCELERATOR							6152
#define IDS_INVERTCOLORS							6153
#define IDS_FLIPHORIZ								6154
#define IDS_FLIPVERT								6155
#define IDS_ROTATE90								6156
#define IDS_DEBUG									6157
#define IDS_GO										6158
#define IDS_STEPINTO								6159
#define IDS_STEPTOCURSOR							6160
#define IDS_ATTACHTOPROCESS							6161
#define IDS_RESTART									6162
#define IDS_STOPDEBUGGING							6163
#define IDS_BREAK									6164
#define IDS_STEPOVER								6165
#define IDS_STOPRETURN								6166
#define IDS_BREAKPOINTS								6167
#define IDS_QUICKWATCH								6168
#define IDS_EXCEPTIONS								6169
#define IDS_THREADS									6170
#define IDS_CUSTOMIZE								6171
#define IDS_OPTIONS									6172
#define IDS_RECORD									6173
#define IDS_PLAYBACK								6174
#define IDS_UPDATEREMOTE							6175
#define IDS_BROWSE									6176
#define IDS_CONNECTION								6177
#define IDS_NEWWINDOW								6178
#define IDS_SPLITWINDOW								6179
#define IDS_HIDEWINDOW								6180
#define IDS_CASCADE									6181
#define IDS_TILEHORIZ								6182
#define IDS_TILEVERT								6183
#define IDS_CLOSEALL								6184
#define IDS_TIPOFTHEDAY								6185
#define IDS_NEWSTRINGBLOCK							6186
#define IDS_DELSTRINGBLOCK							6187
#define IDSS_WRKSPC_CLASS_PROP_PAGE					6188
#define IDSS_WRKSPC_GLOBALS_PROP_PAGE				6189
#define IDSS_WRKSPC_GLOBALS_ITEM_NAME				6190
#define IDSS_WRKSPC_NO_PROPERTIES					6191
#define IDSS_WRKSPC_GOTO_DEFINITION					6192
#define IDSS_WRKSPC_GOTO_DECLARATION				6193
#define IDSS_VAR_WND_CALLS							6194
#define IDSS_PROGRAM_ARGUMENTS						6195
#define IDS_GLOBALWORKSPACE							6196
#define IDS_DEFALTCONFIG							6197
#define IDS_EXPORTMAK								6198
#define IDS_GUIDESETTINGS							6199
#define IDSS_WRKSPC_ADDTOGALLERY					6200
#define IDSS_WRKSPC_ADDTOPROJECT					6201
#define IDSS_WRKSPC_PROPERTIES						6202
#define IDSS_WRKSPC_DELETE							6203
#define IDS_IV_F1LOOKUP_SOMEHITS					6204
#define IDS_IV_F1LOOKUP_NOHITS						6205
#define IDS_IV_F1LOOKUP_ONEHIT						6206
#define IDS_IV_TOPICWND_TITLE						6207
#define IDS_MACROS									6208
#define IDS_NEWDEVIMG								6209
#define IDS_TOOLBAR_EDITOR							6210
#define IDS_CLSWZ_NEWCLASS							6211
#define IDSS_PROJTYPE_DATABASE						6212
#define IDS_VIEWDEBUGWNDS							6213
#define IDS_SETACTIVEPROJ							6214
#define IDS_TOPICWND								6215
#define IDS_RESULTWND								6216
#define IDS_IVBOOKMARKS								6217
#define IDS_DEFINESUBSETS							6218
#define IDS_SELECTSUBSETS							6219
#define IDS_SEARCH									6220
#define IDSS_PANE_DEBUG_OUTPUT						6221
#define IDS_DSN_NAME								6222
#define IDS_LOGIN_ID								6223
#define IDS_PASSWORD								6224
#define IDS_OPTIONS1								6225
#define IDSS_PROJTYPE_JAVA_PROJECT					7000
#define IDSS_PROJTYPE_JAVA_APPWIZ					7001
#define IDSS_PROJTYPE_MAKEFILE						7002
#define IDSS_WRKSPC_INTERFACE_PROP_PAGE				7003
#define IDSS_FIND_SYMBOLS_DLG_TITLE					7004
#define IDS_BUILDCOMMANDS							7005
#define IDS_OUTPUTFILE								7006
#define IDS_QUERYMENU								7007
#define IDS_GROUPBY									7008
#define IDS_VERIFYSQL								7009
#define IDS_TOOLSRUN								7010
#define IDSS_OG_FILE_NOT_EXIST						7011
#define IDSS_COMPONENTS_DIR							7012
#define IDSS_OG_INSERT								7013
#define IDSS_OG_INSERT_CONFIRM1						7014
#define IDSS_OG_INSERT_CONFIRM2						7015
#define IDSS_COMP_DLG_BAR_GAL_NAME					7016
#define IDSS_COMP_DLG_BAR_FILE_NAME					7017
#define IDSS_COMP_DLG_BAR_DESC						7018
#define IDSS_COMP_DLG_BAR_WIZ_TITLE					7019
#define IDSS_COMP_ACTX_CONT_GAL_NAME				7020
#define IDSS_COMP_ACTX_CONT_FILE_NAME				7021
#define IDSS_COMP_ACTX_CONT_DESC					7022
#define IDSS_COMP_ACTX_CONT_WIZ_TITLE				7023
#define IDSS_COMP_CLIP_ASST_GAL_NAME				7024
#define IDSS_COMP_CLIP_ASST_FILE_NAME				7025
#define IDSS_COMP_CLIP_ASST_DESC					7026
#define IDSS_COMP_CLIP_ASST_WIZ_TITLE				7027
#define IDSS_COMP_DOC_REG_GAL_NAME					7028
#define IDSS_COMP_DOC_REG_FILE_NAME					7029
#define IDSS_COMP_DOC_REG_DESC						7030
#define IDSS_COMP_DOC_REG_WIZ_TITLE					7031
#define IDSS_COMP_IDLE_TIME_PROC_GAL_NAME			7032
#define IDSS_COMP_IDLE_TIME_PROC_FILE_NAME			7033
#define IDSS_COMP_IDLE_TIME_PROC_DESC				7034
#define IDSS_COMP_IDLE_TIME_PROC_WIZ_TITLE			7035
#define IDSS_COMP_MAPI_GAL_NAME						7036
#define IDSS_COMP_MAPI_FILE_NAME					7037
#define IDSS_COMP_MAPI_DESC							7038
#define IDSS_COMP_MAPI_WIZ_TITLE					7039
#define IDSS_COMP_OWNER_DRAW_CTRLS_GAL_NAME			7040
#define IDSS_COMP_OWNER_DRAW_CTRLS_FILE_NAME		7041
#define IDSS_COMP_OWNER_DRAW_CTRLS_DESC				7042
#define IDSS_COMP_OWNER_DRAW_CTRLS_WIZ_TITLE		7043
#define IDSS_COMP_PALETTE_GAL_NAME					7044
#define IDSS_COMP_PALETTE_FILE_NAME					7045
#define IDSS_COMP_PALETTE_DESC						7046
#define IDSS_COMP_PALETTE_WIZ_TITLE					7047
#define IDSS_COMP_POPUP_MENU_GAL_NAME				7048
#define IDSS_COMP_POPUP_MENU_FILE_NAME				7049
#define IDSS_COMP_POPUP_MENU_DESC					7050
#define IDSS_COMP_POPUP_MENU_WIZ_TITLE				7051
#define IDSS_COMP_PROGRESS_DLG_GAL_NAME				7052
#define IDSS_COMP_PROGRESS_DLG_FILE_NAME			7053
#define IDSS_COMP_PROGRESS_DLG_DESC					7054
#define IDSS_COMP_PROGRESS_DLG_WIZ_TITLE			7055
#define IDSS_COMP_SPLASH_SCREEN_GAL_NAME			7056
#define IDSS_COMP_SPLASH_SCREEN_FILE_NAME			7057
#define IDSS_COMP_SPLASH_SCREEN_DESC				7058
#define IDSS_COMP_SPLASH_SCREEN_WIZ_TITLE			7059
#define IDSS_COMP_SPLIT_BARS_GAL_NAME				7060
#define IDSS_COMP_SPLIT_BARS_FILE_NAME				7061
#define IDSS_COMP_SPLIT_BARS_DESC					7062
#define IDSS_COMP_SPLIT_BARS_WIZ_TITLE				7063
#define IDSS_COMP_STATUS_BAR_GAL_NAME				7064
#define IDSS_COMP_STATUS_BAR_FILE_NAME				7065
#define IDSS_COMP_STATUS_BAR_DESC					7066
#define IDSS_COMP_STATUS_BAR_WIZ_TITLE				7067
#define IDSS_DONT_DISPLAY_TIME						7068
#define IDSS_COMP_SYS_INFO_GAL_NAME					7069
#define IDSS_COMP_SYS_INFO_FILE_NAME				7070
#define IDSS_COMP_SYS_INFO_DESC						7071
#define IDSS_COMP_SYS_INFO_WIZ_TITLE				7072
#define IDSS_COMP_TIP_OF_DAY_GAL_NAME				7073
#define IDSS_COMP_TIP_OF_DAY_FILE_NAME				7074
#define IDSS_COMP_TIP_OF_DAY_DESC					7075
#define IDSS_COMP_TIP_OF_DAY_WIZ_TITLE				7076
#define IDSS_COMP_TOOLTIPS_GAL_NAME					7077
#define IDSS_COMP_TOOLTIPS_FILE_NAME				7078
#define IDSS_COMP_TOOLTIPS_DESC						7079
#define IDSS_COMP_TOOLTIPS_WIZ_TITLE				7080
#define IDSS_COMP_WIN_MM_GAL_NAME					7081
#define IDSS_COMP_WIN_MM_FILE_NAME					7082
#define IDSS_COMP_WIN_MM_DESC						7083
#define IDSS_COMP_WIN_MM_WIZ_TITLE					7084
#define IDSS_COMP_WIN_SOCKETS_GAL_NAME				7085
#define IDSS_COMP_WIN_SOCKETS_FILE_NAME				7086
#define IDSS_COMP_WIN_SOCKETS_DESC					7087
#define IDSS_COMP_WIN_SOCKETS_WIZ_TITLE				7088
#define IDSS_ADD_CONSTRUCT_CODE_HERE				7089
#define IDSS_AW_TITLE_1								7090
#define IDSS_AW_TITLE_2								7091
#define IDSS_NEW_ACTIVE_SERVER_PAGE					7092
#define IDSS_NEW_HEADER								7093
#define IDSS_NEW_CPP_SOURCE							7094
#define IDSS_NEW_HTML_PAGE							7095
#define IDSS_NEW_MACRO								7096
#define IDSS_NEW_ODBC_SCRIPT						7097
#define IDSS_NEW_RESOURCE_SCRIPT					7098
#define IDSS_NEW_RESOURCE_TEMPLATE					7099
#define IDSS_NEW_TEXT								7100
#define IDSS_PROJWIZ_FINISH							7101
#define IDSS_INSERT_INTO_HTML_MENU					7102
#define IDSS_INSERT_INTO_HTML_ACTIVEX_CONTROL_MENU	7103
#define IDSS_INSERT_CTRL_DLG_TITLE					7104
#define IDSS_DOES_NOT_CONTAIN_DEBUG_INFO			7105
#define IDSS_ADD_TO_PROJECT							7106
#define IDSS_PROJTYPE_ATL_COM_WIZ					7107
#define IDSS_ATL_OBJ_WIZ_TITLE						7108
#define IDSS_ATL_OBJ_WIZ_PROP_TITLE					7109
#define IDSS_USE_EXISTING_CLASS_ID					7110
#define IDSS_RSLA_DLG_TITLE							7111
#define IDSS_BP_EDIT_CODE_BUTTON					7112
#define IDSS_EC_DELAYED_DUE_TO_CTOR_DTOR			7113
#define IDSS_EC_ONLY_ASM_AVAILABLE					7114
#define IDSS_PROJTYPE_ISAPI_EXTENSION				7115
#define IDSS_EC_TITLE								7116
#define IDSS_CHOOSE_DIR_TITLE						7117
#define IDSS_VS_HELP_TITLE							7118
#define IDSS_EXCEPTION_DIVIDE_BY_ZERO				7119
#define IDSS_STEP_INTO_SPECIFIC_ACCEL				7120
#define IDSS_THREAD_EXIT_CODE						7121
#define IDSS_THREAD_SET_FOCUS						7122
#define IDSS_THREAD_SUSPEND							7123
#define IDSS_THREAD_RESUME							7124
#define IDS_NEW_ATL_OBJECT							7125
#define IDSS_EC_POINT_OF_EXECUTION_MOVED			7216
#define IDSS_EC_LOCAL_VAR_REMOVED					7217
#define IDSS_CLW_TITLE								7218

// XBox-specific
#define IDSS_PLATFORM_XBOX      9000
#define IDSS_PROJTYPE_XBOX_GAME 9010
#define IDSS_PROJTYPE_XBOX_LIB  9011
#define IDSS_PROJSET_IMAGEBLD   9050

#define IDS_STRING_END_MENU_RANGE					9999
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\settings.h ===
/////////////////////////////////////////////////////////////////////////////
// settings.h
//
// email	date		change
// briancr	11/02/94	created
//
// copyright 1994 Microsoft

// Interface of the CSettings class

#ifndef __SETTINGS_H__
#define __SETTINGS_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "targxprt.h"

#pragma warning(disable: 4251)

/////////////////////////////////////////////////////////////////////////////
// setting constants

// CAFE
const CString settingCAFEKey = "CAFEKey";
//const CString settingToolset = "Toolset";
const CString settingPlatform = "target_platforms";
const CString settingDoSingleStep = "SingleStep";
const CString settingNewKey = "NewKey";
// UGLY_HACK(briancr): this code is here to log info to a server about who runs CAFE
// remove it as soon as possible
const CString settingBigBro = "BigBro";

// command line
const CString settingRun = "run";
const CString settingSTFFile = "stf";
const CString settingInfiniteIdleWaits = "inf_waits";
const CString settingSleep = "sleep";

// windows (including toolbars)
const CString settingCAFEWndX = "WndX";
const CString settingCAFEWndY = "WndY";
const CString settingCAFEWndWidth = "WndWidth";
const CString settingCAFEWndHeight = "WndHeight";
const CString settingStdToolbar = "CAFETB";
const CString settingCAFETBDock = "CAFETBDock";
const CString settingCAFETBX = "CAFETBX";
const CString settingCAFETBY = "CAFETBY";
const CString settingSubSuiteToolbar = "SSTB";
const CString settingSSTBDock = "SSTBDock";
const CString settingSSTBX = "SSTBX";
const CString settingSSTBY = "SSTBY";
const CString settingViewportToolbar = "PortTB";
const CString settingPortTBDock = "PortTBDock";
const CString settingPortTBX = "PortTBX";
const CString settingPortTBY = "PortTBY";
const CString settingStatusBar = "StatusBar";
const CString settingWaitStepWndX = "WaitStepX";
const CString settingWaitStepWndY = "WaitStepY";
const CString settingWaitStepWndWidth = "WaitStepWidth";
const CString settingWaitStepWndHeight = "WaitStepHeight";


// logging
const CString settingLogResultsFile = "ResultsFile";
const CString settingLogSummaryFile = "SummaryFile";
const CString settingLogWorkDir = "WorkDir";
const CString settingLogMaxFail = "MaxFail";
const CString settingLogUseCom = "UseCom";
const CString settingLogCom = "Com";
const CString settingLogBaudRate = "BaudRate";
const CString settingLogPost = "Post";
const CString settingLogComments = "Comments";

// viewport
const CString settingHeaderFilter = "HeaderFilter";
const CString settingSummaryFilter = "SummaryFilter";
const CString settingCommentsFilter = "CommentsFilter";
const CString settingResultsFilter = "ResultsFilter";
const CString settingFailureFilter = "FailureFilter";
const CString settingInfoFilter = "InfoFilter";
const CString settingSeparatorFilter = "SeparatorFilter";
const CString settingSuccessFilter = "SuccessFilter";
const CString settingStepFilter = "StepFilter";
const CString settingSelectedFilter = "SelectedFilter";

// toolset settings
const CString settingLanguage = "Lang";
const CString settingDebugBuild = "Debug";
const CString settingLanguageKey = "LangKey";
const CString settingDebugBuildKey = "DebugKey";

// toolset environment settings
const CString settingPathEnv = "PATH";
const CString settingLibEnv	= "LIB";
const CString settingIncludeEnv	= "INCLUDE";

// general tool settings
const CString settingDebugProcess = "Debug_Thread";
const CString settingFilename = "Filename";
const CString settingDebugFilename = "DebugFilename";
const CString settingCmdLine = "CmdLine";
const CString settingWorkingDir = "WorkDir";

// GUI tool settings
const CString settingWndTitle = "WndTitle";
const CString settingWndClass = "WndClass";
const CString settingIgnoreASSERT = "IgnoreASSERT";
const CString settingBreakASSERT = "BreakASSERT";
const CString settingNewApp = "NewApp";
const CString settingClose = "Close";
const CString settingPersist = "Persist";

// IDE settings
const CString settingIDEKeyExt = "KeyExt";
const CString settingIDEUseKey = "UseKey";
const CString settingIDEKey = "Key";
const CString settingConnection = "connections";
const CString settingRemoteLocalPath = "remote_local_path";
const CString settingRemoteSharePath = "remote_share_path";

const CString cstrKeyRoot = "Software\\Microsoft\\";

// Serial connection settings
const CString settingConnector = "connector";
const CString settingBaudRate = "baud_rate";
const CString settingFlowControl = "flow_control";
const CString settingDataBits = "data_bits";
const CString settingStopBits = "stop_bits";
const CString settingParity = "parity";

// TCP/IP connection settings
const CString settingRemoteIPAddress = "remote_ip_address";
const CString settingRemoteIPPassword = "remote_ip_password";

// Appletalk connection settings
const CString settingRemoteZone = "remote_zone";
const CString settingRemoteMachName = "remote_machine_name";
const CString settingRemoteATPassword = "remote_at_password";


/////////////////////////////////////////////////////////////////////////////
// CSettings

class TARGET_CLASS CSettings
{
// constructor/destructor
public:
	CSettings(CString strBaseSubKey = "") : m_bReadOnly(FALSE), m_strKey(strBaseSubKey) { }
	virtual ~CSettings();

// operations
public:
	// check whether a setting is defined or not
	virtual BOOL IsDefined(CString strSetting);

	// set the key to write settings to
	BOOL SetKey(CString strKey);

	// set/get text values
	virtual BOOL SetTextValue(CString strSetting, CString strValue, BOOL bOverride = TRUE);
	virtual CString GetTextValue(CString strSetting, CString strDefault = "");

	// set/get boolean values
	virtual BOOL SetBooleanValue(CString strSetting, BOOL bValue, BOOL bOverride = TRUE);
	virtual BOOL GetBooleanValue(CString strSetting, BOOL bDefault = FALSE);
	
	// set/get int values
	virtual BOOL SetIntValue(CString strSetting, int nValue, BOOL bOverride = TRUE);
	virtual int GetIntValue(CString strSetting, int nDefault = 0);

	// delete a setting
	virtual BOOL Delete(CString strSetting);

	// read/write settings from/to registry
	virtual BOOL ReadRegistry(void);
	virtual BOOL WriteRegistry(void);

	// dump settings
	#ifdef _DEBUG
		void DumpSettings(CString strDesc);
	#endif // _DEBUG

// operations (internal)
protected:
	BOOL InterpretBooleanValue(CString &strValue, BOOL bDefault = FALSE);
	BOOL WriteRegistryValue(CString strSetting, CString strValue);
	CString ReadRegistryValue(CString strSetting);
	BOOL DeleteRegistryValue(CString strSetting);

// data
protected:
	CString m_strKey;
	BOOL m_bReadOnly;

	static CString strKeyClass;

	CMapStringToString m_mapSettings;
};

extern TARGET_DATA  BOOL gbLastSubSuite;
extern TARGET_DATA  BOOL gbPersistTarget;

#endif // __SETTINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\support.h ===
///////////////////////////////////////////////////////////////////////////////
//	support.h
//
//	Created by :			Date :
//		BrianCr				12/05/94
//
//	Description :
//		Precompiled header for all of the CAFE support files
//
//  	Other projects may include CAFE.H in their own precompiled headers,
//		and can then avoid including any other CAFE headers, (or for that 
//		matter <afxwin.h> or <afxext.h>)
//

#ifndef __SUPPORT_H__
#define __SUPPORT_H__

#define __CAFE_H__
#define __WB_H__

#pragma warning(disable: 4275)

// log
#include "log.h"

// target
#include "settings.h"
#include "testxcpt.h"

// gui
#include "mstwrap.h"		// MFC-ized wrapper for MS Test
#include "..\src\support\guitools\imewrap.h"		// wrapper for the Japanese IME
#include "..\src\support\guitools\testutil.h"		// base level utility/cases class
#include "..\src\support\guitools\uwindow.h"		// basis of UIWindow utility classes
#include "..\src\support\guitools\udialog.h"
#include "..\src\support\guitools\umsgbox.h"
#include "..\src\support\guitools\coclip.h"			// Component Object classes

// ide
#include "..\src\support\guitools\ide\sym\cmdids.h"
#include "..\src\support\guitools\ide\sym\menuids.h"
#include "..\src\support\guitools\ide\sym\dockids.h" // taken directly from sushi project
#include "..\src\support\guitools\ide\sym\qcqp.h"   // munged together from sushi project
#include "..\src\support\guitools\ide\sym\vshell.h"
#include "..\src\support\guitools\ide\sym\vres.h"
#include "..\src\support\guitools\ide\sym\vcpp32.h"
#include "..\src\support\guitools\ide\sym\vproj.h"
#include "..\src\support\guitools\ide\sym\shrdres.h"
#include "..\src\support\guitools\ide\sym\appwz.h"
#include "..\src\support\guitools\ide\sym\clswiz.h"
#include "..\src\support\guitools\ide\sym\optnbsc.h"	// options id's
#include "..\src\support\guitools\ide\sym\optncplr.h"
#include "..\src\support\guitools\ide\sym\optnlib.h"
#include "..\src\support\guitools\ide\sym\optnlink.h"
#include "..\src\support\guitools\ide\sym\optnmtl.h"
#include "..\src\support\guitools\ide\sym\optnrc.h"
#include "..\src\support\guitools\ide\sym\projprop.h"	// Project specific properites
#define __UNDO_H__			// Prevents #inclusion of some SUSHI headers
#define __SLOBWND_H__
#include "..\src\support\guitools\ide\sym\slob.h"		// some ID's were moved from props.h
#include "..\src\support\guitools\ide\sym\68k\optncplr.h"
#include "..\src\support\guitools\ide\sym\68k\optnmrc.h"
#include "..\src\support\guitools\ide\filetabl.h"		// File table struct and utilities for table driven tests

// shl
#include "..\src\support\guitools\ide\shl\umainfrm.h"
#include "..\src\support\guitools\ide\shl\wb_props.h"   // defines all workbench properties used by GetProperty() function
#include "Strings.h"									// IDSS_ localized string IDs
#include "..\src\support\guitools\ide\shl\wbutil.h"		// Workbench-specific global utilities
#include "..\src\support\guitools\ide\shl\uwbframe.h"   // UWindow based utility classes
#include "..\src\support\guitools\ide\shl\ucommdlg.h"
#include "..\src\support\guitools\ide\shl\upropwnd.h"
#include "..\src\support\guitools\ide\shl\udockwnd.h"
#include "..\src\support\guitools\ide\shl\utbardlg.h"
#include "..\src\support\guitools\ide\shl\utoolbar.h"
#include "..\src\support\guitools\ide\shl\uitabdlg.h"
#include "..\src\support\guitools\ide\shl\uioptdlg.h"
#include "..\src\support\guitools\ide\shl\ucustdlg.h"
#include "..\src\support\guitools\ide\shl\uioutput.h"
#include "..\src\support\guitools\ide\shl\uiwbmsg.h"
#include "..\src\support\guitools\ide\shl\uiwbdlg.h"
#include "..\src\support\guitools\ide\shl\uiconnec.h"
#include "..\src\support\guitools\ide\shl\uiconset.h"
#include "..\src\support\guitools\ide\shl\coconnec.h"
#include "..\src\support\guitools\ide\shl\cowrkspc.h"
#include "..\src\support\guitools\ide\shl\coenv.h"

// eds
#include "..\src\support\guitools\ide\eds\ueditor.h"
#include "..\src\support\guitools\ide\eds\ufindinf.h"
#include "..\src\support\guitools\ide\eds\cofile.h"		// Component-Object based utility classes.
#include "..\src\support\guitools\ide\eds\macrodlg.h"

// src
#include "..\src\support\guitools\ide\src\cosource.h"
#include "..\src\support\guitools\ide\src\cohtml.h"
#include "..\src\support\guitools\ide\src\uinsctrl.h"
#include "..\src\support\guitools\ide\src\ufindrep.h"

// res
#include "..\src\support\guitools\ide\res\uresedit.h"
#include "..\src\support\guitools\ide\res\urestabl.h"
#include "..\src\support\guitools\ide\res\uresbrws.h"
#include "..\src\support\guitools\ide\res\ustredit.h"
#include "..\src\support\guitools\ide\res\uaccedit.h"
#include "..\src\support\guitools\ide\res\uveredit.h"
#include "..\src\support\guitools\ide\res\udlgedit.h"
#include "..\src\support\guitools\ide\res\uimgedit.h"
#include "..\src\support\guitools\ide\res\umenedit.h"
#include "..\src\support\guitools\ide\res\usymdlg.h"
#include "..\src\support\guitools\ide\res\coresscr.h"

// prj
#include "..\src\support\guitools\ide\prj\uprjfile.h"
#include "..\src\support\guitools\ide\prj\uitarget.h"
#include "..\src\support\guitools\ide\prj\uogaldlg.h"
#include "..\src\support\guitools\ide\prj\uprjtdlg.h"
#include "..\src\support\guitools\ide\prj\uprojwiz.h"
#include "..\src\support\guitools\ide\prj\uiextwiz.h"
#include "..\src\support\guitools\ide\prj\uappwiz.h"
#include "..\src\support\guitools\ide\prj\ucwzdlg.h"
#include "..\src\support\guitools\ide\prj\utstapwz.h"
#include "..\src\support\guitools\ide\prj\odbcdlgs.h"
#include "..\src\support\guitools\ide\prj\uictrlwz.h"
#include "..\src\support\guitools\ide\prj\uiwizbar.h"
#include "..\src\support\guitools\ide\prj\coprject.h"
#include "..\src\support\guitools\ide\prj\cocompon.h"

// wrk
#include "..\src\support\guitools\ide\wrk\uiwrkspc.h"

// dbg
#include "..\src\support\guitools\ide\dbg\parse.h"		//Utility
#include "..\src\support\guitools\ide\dbg\uiqw.h"		// User-Interface based utility classes.
#include "..\src\support\guitools\ide\dbg\uibp.h"
#include "..\src\support\guitools\ide\dbg\uimem.h"
#include "..\src\support\guitools\ide\dbg\uieewnd.h"
#include "..\src\support\guitools\ide\dbg\uiwatch.h"
#include "..\src\support\guitools\ide\dbg\uivar.h"
#include "..\src\support\guitools\ide\dbg\uilocals.h"
#include "..\src\support\guitools\ide\dbg\uireg.h"
#include "..\src\support\guitools\ide\dbg\uicp.h"
#include "..\src\support\guitools\ide\dbg\uidam.h"
#include "..\src\support\guitools\ide\dbg\uiexcpt.h"
#include "..\src\support\guitools\ide\dbg\uistack.h"
#include "..\src\support\guitools\ide\dbg\uithread.h"
#include "..\src\support\guitools\ide\dbg\uibrowse.h"
#include "..\src\support\guitools\ide\dbg\uidebug.h"
#include "..\src\support\guitools\ide\dbg\uiattach.h"
#include "..\src\support\guitools\ide\dbg\coee.h"
#include "..\src\support\guitools\ide\dbg\cobp.h"
#include "..\src\support\guitools\ide\dbg\comem.h"
#include "..\src\support\guitools\ide\dbg\codebug.h"
#include "..\src\support\guitools\ide\dbg\cocp.h"
#include "..\src\support\guitools\ide\dbg\coreg.h"
#include "..\src\support\guitools\ide\dbg\costack.h"
#include "..\src\support\guitools\ide\dbg\cothread.h"
#include "..\src\support\guitools\ide\dbg\coexcpt.h"
#include "..\src\support\guitools\ide\dbg\codam.h"
#include "..\src\support\guitools\ide\dbg\cobrowse.h"
#include "..\src\support\guitools\ide\dbg\colocals.h"
#include "..\src\support\guitools\ide\dbg\cowatch.h"
#include "..\src\support\guitools\ide\dbg\coauto.h"

// backward compatibility
#include "guiv1.h"

#endif //__SUPPORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\T4CTRL.H ===
//---------------------------------------------------------------------------
// T4CTRL.H
//
// Constants, structures, and API prototypes for C interaction with
// T4CTRL*.DLL components of Microsoft Test 4.0b.
//
// Copyright (c) 1991-1997, Microsoft Corporation. All rights reserved.
//---------------------------------------------------------------------------

#ifndef _WINDOWS_
#error This include file requires windows.h be included before this file!
#endif

#ifndef _T4CTRL_H_

#ifdef __cplusplus
extern "C" {
#endif

//#ifndef APIENTRY
//#define APIENTRY FAR PASCAL
//#endif

#ifndef WINAPIV
#define WINAPIV FAR CDECL
#endif

// T4CTRL Trapable Runtime errors
//-----------------------------------------------------------------------------
#define ERR_NO_ERROR                    0
#define ERR_MENU_NOT_FOUND              1
#define ERR_MENU_ITEM_NOT_FOUND         2
#define ERR_NOT_A_LISTBOX               3
#define ERR_LISTBOX_NOT_FOUND           4
#define ERR_ITEM_NOT_IN_LISTBOX         5
#define ERR_INVALID_LISTBOX_INDEX       6
#define ERR_LISTBOX_HAS_NO_STRINGS      7
#define ERR_LISTBOX_IS_NOT_MULTISELECT  8
#define ERR_NOT_A_COMBOBOX              9
#define ERR_COMBOBOX_NOT_FOUND         10
#define ERR_ITEM_NOT_IN_COMBOBOX       11
#define ERR_INVALID_COMBOBOX_INDEX     12
#define ERR_COMBOBOX_HAS_NO_EDITBOX    13
#define ERR_COMBOBOX_HAS_NO_STRINGS    14
#define ERR_NOT_AN_EDITBOX             15
#define ERR_EDITBOX_NOT_FOUND          16
#define ERR_BUTTON_NOT_FOUND           17
#define ERR_OPTION_BUTTON_NOT_FOUND    18
#define ERR_CHECKBOX_NOT_FOUND         19
#define ERR_INVALID_WINDOW_HANDLE      20
#define ERR_NO_SYSTEM_MENU             21
#define ERR_INVALID_MENU_INDEX         22
#define ERR_NOT_A_PUSHBUTTON           23
#define ERR_NOT_A_CHECKBOX             24
#define ERR_NOT_AN_OPTION_BUTTON       25
#define ERR_UNABLE_TO_ENTER_MENU_MODE  26
#define ERR_INVALID_SELECTION          27
#define ERR_CONTROL_IS_DISABLED        28
#define ERR_CANT_MOVE_WND              29
#define ERR_CANT_SIZE_WND              30
#define ERR_CANT_ADJ_SIZE_POS_WND      31
#define ERR_WINDOW_DOES_NOT_EXIST      32
#define ERR_WINDOW_STILL_EXISTS        33
#define ERR_CANT_FIND_LBBOX            34
#define ERR_NOT_OPERATOR_NOT_ALLOWED   35
#define ERR_CANT_ADD_NULL_ITEM         36
#define ERR_INVALID_LINE_INDEX         37
#define ERR_NOT_A_STATIC               38
#define ERR_STATIC_NOT_FOUND           39
#define ERR_NO_CUSTOM_CLASS_SET        40
#define ERR_NOT_A_CUSTOM               41
#define ERR_CUSTOM_NOT_FOUND           42
#define ERR_INVALID_X_Y                43
#define ERR_INVALID_MOUSE_BUTTON       44
#define ERR_NOT_A_SCROLLBAR            45
#define ERR_SCROLLBAR_NOT_FOUND        46
#define ERR_INVALID_SCROLL_POS         47
#define ERR_CANT_ENTER_MENU_MODE       48
#define ERR_DOKEYS_SYNTAX_ERROR        49
#define ERR_PLAYBACK_INTERRUPTION      50
#define ERR_DEADLOCK                   51
#define ERR_NT_CANT_START_PROCESS      52
#define ERR_NT_SYSTEM_ERROR            53
#define ERR_OUT_OF_SYSTEM_RESOURCES    54
#define ERR_VM_INVALID_VM              55
#define ERR_VM_NO_PIPES_OPEN           56
#define ERR_VM_PARAMETERS_OUT_OF_RANGE 57
#define ERR_VM_PIPE_ALREADY_OPEN       58
#define ERR_VM_PIPE_NOT_OPEN           59
#define ERR_VM_WIN32_API_NOT_SUPPORTED 60
#define ERR_VM_WIN31_API_NOT_SUPPORTED 61
#define ERR_VXD_NOT_LOADED             62
#define ERR_CANT_SCROLL_ITEM           63
#define ERR_CANT_GET_ITEM_RECT         64
#define ERR_OUT_OF_MEMORY              65
#define ERR_BAD_READ_STRING_POINTER    66
#define ERR_BAD_WRITE_STRING_POINTER   67
#define ERR_BAD_DEADLOCK_TIMEOUT       68
#define ERR_CANT_CLICK_ITEM_OR_CONTROL 69

#ifdef WIN16

#define ERR_NOT_A_DATAWINDOW           70
#define ERR_DATAWINDOW_NOT_FOUND       71
#define ERR_NOT_A_TABLE                72
#define ERR_TABLE_NOT_FOUND            73
#define ERR_GETTING_CELL_TEXT          74
#define ERR_SAVING_DATA                75

#else
// New 3.x Stuff
//-----------------------------------------------------------------------------
#define ERR_NOT_A_TAB_CTRL             70
#define ERR_TAB_CTRL_NOT_FOUND         71
#define ERR_TAB_ITEM_NOT_FOUND         72
#define ERR_NOT_A_VIEW_CTRL            73
#define ERR_VIEW_CTRL_NOT_FOUND        74
#define ERR_ITEM_NOT_IN_VIEW           75
#define ERR_VIEW_IS_NOT_MULTISELECT    76
#define ERR_HEADER_NOT_IN_VIEW         77
#define ERR_ITEM_NOT_IN_SELECTION      78
#define ERR_NOT_A_HEADER_CTRL          79
#define ERR_HEADER_CTRL_NOT_FOUND      80
#define ERR_HEADER_ITEM_NOT_FOUND      81
#define ERR_NOT_A_TOOLBAR              82
#define ERR_TOOLBAR_NOT_FOUND          83
#define ERR_TOOLBAR_BUTTON_NOT_FOUND   84
#define ERR_NOT_A_SLIDER               85
#define ERR_SLIDER_NOT_FOUND           86
#define ERR_NOT_A_SPIN_CTRL            87
#define ERR_SPIN_CTRL_NOT_FOUND        88
#define ERR_NOT_A_TREE_CTRL            89
#define ERR_TREE_CTRL_NOT_FOUND        90
#define ERR_TREE_ITEM_NOT_FOUND        91
#define ERR_NOT_A_STATUSBAR            92
#define ERR_STATUSBAR_NOT_FOUND        93
#define ERR_STATUSBAR_ITEM_NOT_FOUND   94
#define ERR_NOT_A_TOOLTIPS             95
#define ERR_TOOLTIPS_NOT_FOUND         96
#define ERR_TASKBAR_NOT_FOUND          97
#define ERR_TASKBAR_CLOCK_NOT_FOUND    98
#define ERR_TASKBAR_ICON_NOT_FOUND     99
#define ERR_CANT_FIND_SPACE            100
#define ERR_NOT_A_PROGRESS_CTRL        101
#define ERR_PROGRESS_CTRL_NOT_FOUND    102
#define ERR_CANT_ACCESS_SHARED_MEMORY  103
#endif

#ifndef RC_INVOKED

// wFlag supported by all WFndWndxxx() api
//-----------------------------------------------------------------------------
#ifndef FW_DEFAULT
#define FW_DEFAULT      0x0000  // default
#define FW_PREFIX       0x4000
#define FW_ERROR        0x2000  // default
#define FW_NOERROR      0x0000  // default
#define FW_DIALOG       0x1000
#define FW_DIALOGOK     0x0000  // default
#define FW_MAXIMIZE     0x0800
#define FW_MINIMIZE     0x0400
#define FW_IGNOREFILE   0x0200
#define FW_NOIGNOREFILE 0x0000  // default
#define FW_AMPERSANDOPT 0x0100
#define FW_AMPERSAND    0x0000  // default
#define FW_RESTORE      0x0080
#define FW_NOEXIST      0x0040
#define FW_EXIST        0x0000  // default
#define FW_CHILDNOTOK   0x0020
#define FW_CHILDOK      0x0000  // default
#define FW_HIDDENOK     0x0010
#define FW_HIDDENNOTOK  0x0000  // default
#define FW_ACTIVE       0x0008
#define FW_ALL          0x0000  // default
#define FW_CASE         0x0004
#define FW_NOCASE       0x0000  // default
#define FW_PART         0x0002
#define FW_FULL         0x0000  // default
#define FW_FOCUS        0x0001
#define FW_NOFOCUS      0x0000  // default
#define FW_RESTOREICON  (FW_FOCUS | FW_RESTORE)
#define FW_ACTIVE_ONLY  (FW_ACTIVE | FW_CHILDNOTOK)

//-----------------------------------------------------------------------------
#define FW_CHECKCHAR    0x8000  // INTERNAL USE ONLY
//-----------------------------------------------------------------------------
#endif

// Special Coordinate values to specify center of control, or for some controls
// Unoccuppied "Space"
//---------------------------------------------------------------------------
#ifdef WIN32
    #define W_SPACE       (0x7FFFFFFFL)
    #define W_CENTER      (0x7FFFFFFEL)  // W_SPACE - 1
#else
    #define W_SPACE       (0x7FFF)
    #define W_CENTER      (0x7FFE)       // W_SPACE - 1
#endif

// Miscelaneous routines
//---------------------------------------------------------------------------
LONG WINAPI   WMessage              (HWND hWnd, UINT wMsg);
LONG WINAPI   WMessageW             (HWND hWnd, UINT wMsg, WPARAM wp);
LONG WINAPI   WMessageL             (HWND hWnd, UINT wMsg, LPARAM lp);
LONG WINAPI   WMessageWL            (HWND hWnd, UINT wMsg, WPARAM wp, LPARAM lp);
HWND WINAPI   WGetFocus             (void);
void WINAPI   WResetClasses         (void);
BOOL WINAPI   WIsVisible            (HWND hWnd);
LONG WINAPI   WTextLen              (HWND hWnd);
void WINAPI   WGetText              (HWND hWnd, LPSTR lpszBuffer);
void WINAPI   WSetText              (HWND hWnd, LPSTR lpszText);
int  WINAPI   WNumAltKeys           (void);
void WINAPI   WGetAltKeys           (LPSTR lpszBuff);
int  WINAPI   WNumDupAltKeys        (void);
void WINAPI   WGetDupAltKeys        (LPSTR lpszBuff);
void WINAPI   WDisplayInfo          (HWND, UINT);
//void WINAPI   WEnableOptionalParam  (void);

DWORD WINAPI  SetDefaultWaitTimeout (DWORD dwDefWait);
DWORD WINAPI  SetRetryInterval      (DWORD dwRetryInterval);

#ifdef WIN32
DWORD WINAPI  SetSuspendedTimeout   (DWORD dwMillis);
#endif


// Display Options for WDisplayInfo()
//-----------------------------------
#ifndef DI_DIALOG
#define DI_DIALOG     0x0001
#define DI_DEBUG      0x0002
#define DI_BOTH       0x0003
#endif

//---------------------------------------------------------------------------
// General Window routines and structs
//---------------------------------------------------------------------------

#ifndef _MYSTRUCTS_INCLUDED
typedef struct tagWNDPOS
{
    int left;
    int top;
} WNDPOS;

typedef struct tagWNDSIZ
{
    int width;
    int height;
} WNDSIZ;

typedef struct tagWNDPOSSIZ
{
    int left;
    int top;
    int width;
    int height;
} WNDPOSSIZ;
#endif

typedef WNDPOS    FAR *LPWNDPOS;
typedef WNDSIZ    FAR *LPWNDSIZ;
typedef WNDPOSSIZ FAR *LPWNDPOSSIZ;

#ifndef CTRL_USE_DEF_WAIT
#define CTRL_WAIT_FOREVER  (DWORD)(-1)
// Use this value for timeout parameters to use the default
#define CTRL_USE_DEF_WAIT  (DWORD)(-2)
#define CTRL_ONE_SECOND             1000    // Milliseconds
#define CTRL_DEF_TIMEOUT            5       // Seconds.  Default is no waiting
#define CTRL_DEF_RETRY_INTERVAL     250     // 250 milliseconds
#define CTRL_MIN_RETRY_INTERVAL     55      // 55 milliseconds
#define DEF_SUSPENDED_TIMEOUT       1000    // One second
#define DEF_ACTIVE_TIMEOUT          55      // 55 milliseconds
#endif

HWND WINAPI   WFndWnd       (LPSTR lpszCaption, UINT uFlags, DWORD dwTimeout);
HWND WINAPI   WFndWndC      (LPSTR lpszCaption, LPSTR lpszClass, UINT uFlags, DWORD dwTimeout);
//HWND WINAPI   WFndWndWait   (LPSTR lpszCaption, UINT uFlags, UINT uSeconds);
//HWND WINAPI   WFndWndWaitC  (LPSTR lpszCaption, LPSTR lpszClass,UINT uFlags, UINT uSeconds);
void WINAPI   WMinWnd       (HWND hWnd);
void WINAPI   WMaxWnd       (HWND hWnd);
void WINAPI   WResWnd       (HWND hWnd);
void WINAPI   WSetWndPosSiz (HWND hWnd, int x,  int y, int w, int h);
void WINAPI   WSetWndPos    (HWND hWnd, int x,  int y);
void WINAPI   WSetWndSiz    (HWND hWnd, int w,  int h);
void WINAPI   WAdjWndPosSiz (HWND hWnd, int dx, int dy, int dw, int dh);
void WINAPI   WAdjWndPos    (HWND hWnd, int dx, int dy);
void WINAPI   WAdjWndSiz    (HWND hWnd, int dw, int dh);
void WINAPI   WGetWndPosSiz (HWND hWnd, LPWNDPOSSIZ lpWndPosSiz, BOOL fRelative);
void WINAPI   WGetWndPos    (HWND hWnd, LPWNDPOS    lpWndPos,    BOOL fRelative);
void WINAPI   WGetWndSiz    (HWND hWnd, LPWNDSIZ    lpWndSiz);
void WINAPI   WSetActWnd    (HWND hWnd);
HWND WINAPI   WGetActWnd    (HWND hWnd);
BOOL WINAPI   WIsMaximized  (HWND hWnd);
BOOL WINAPI   WIsMinimized  (HWND hWnd);
void WINAPI   WClkWnd       (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WCtrlClkWnd   (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WShftClkWnd   (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WDblClkWnd    (HWND hWnd, int x, int y, int nBtn); // 0 = VK_LBUTTON
void WINAPI   WMoveToWnd    (HWND hwnd, int x, int y);
void WINAPI   WDragToWnd    (HWND hwnd, int x, int y, int nBtn); // 0 = VK_LBUTTONb

//---------------------------------------------------------------------------
// Menu routines
//---------------------------------------------------------------------------
void  WINAPI     WMenuSelect        (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuExists        (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuGrayed        (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuChecked       (LPSTR lpszItem, DWORD dwTimeout);
BOOL  WINAPI     WMenuEnabled       (LPSTR lpszItem, DWORD dwTimeout);
int   WINAPI     WMenuCount         (DWORD dwTimeout);
void  WINAPI     WMenuText          (LPSTR lpszItem, LPSTR lpszBuffer, DWORD dwTimeout);
int   WINAPI     WMenuLen           (LPSTR lpszItem, DWORD dwTimeout);
void  WINAPI     WMenuFullText      (LPSTR lpszItem, LPSTR lpszBuffer, DWORD dwTimeout);
int   WINAPI     WMenuFullLen       (LPSTR lpszItem, DWORD dwTimeout);
void  WINAPI     WMenuEnd           (void);
BOOL  WINAPI     WSysMenuExists     (HWND hWnd);
void  WINAPI     WSysMenu           (HWND hWnd);
int   WINAPI     WMenuNumAltKeys    (DWORD dwTimeout);
void  WINAPI     WMenuGetAltKeys    (LPSTR lpszBuff, DWORD dwTimeout);
int   WINAPI     WMenuNumDupAltKeys (DWORD dwTimeout);
void  WINAPI     WMenuGetDupAltKeys (LPSTR lpszBuff, DWORD dwTimeout);
BOOL  WINAPI     WMenuSeparator     (int iIndex, DWORD dwTimeout);
BOOL  WINAPI     WMenuHasPopup      (LPSTR lpszItem, DWORD dwTimeout);

// Obsolete.
//-----------------------------------------------------------------------------
//void  WINAPI   WMenuX             (int iIndex);
//BOOL  WINAPI   WMenuGrayedX       (int iIndex);
//BOOL  WINAPI   WMenuCheckedX      (int iIndex);
//BOOL  WINAPI   WMenuEnabledX      (int iIndex);

//---------------------------------------------------------------------------
// Command button routines.
//---------------------------------------------------------------------------
void WINAPI   WButtonSetClass (LPSTR lpszClassName);
void WINAPI   WButtonGetClass (LPSTR lpszBuffer);
int  WINAPI   WButtonClassLen (void);
BOOL WINAPI   WButtonExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WButtonFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WButtonEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WButtonFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WButtonClick    (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonHide     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonShow     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonEnable   (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WButtonDisable  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WButtonDefault  (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WButtonDefaults (void);
void WINAPI   WButtonSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WButtonMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// CheckBox routines
//---------------------------------------------------------------------------
void WINAPI   WCheckSetClass (LPSTR lpszClassName);
void WINAPI   WCheckGetClass (LPSTR lpszBuffer);
int  WINAPI   WCheckClassLen (void);
BOOL WINAPI   WCheckExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WCheckFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCheckEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCheckFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WCheckState    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckClick    (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckHide     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckShow     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckEnable   (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WCheckDisable  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckCheck    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckUnCheck  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCheckMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Option Button routines
//---------------------------------------------------------------------------
void WINAPI   WOptionSetClass (LPSTR lpszClassName);
void WINAPI   WOptionGetClass (LPSTR lpszBuffer);
int  WINAPI   WOptionClassLen (void);
BOOL WINAPI   WOptionExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WOptionFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WOptionEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WOptionFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WOptionState    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionClick    (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionHide     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionShow     (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionEnable   (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WOptionDisable  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionSelect   (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WOptionMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Listbox routines
//---------------------------------------------------------------------------
void WINAPI   WListSetClass      (LPSTR lpszClassName);
void WINAPI   WListGetClass      (LPSTR lpszBuffer);
int  WINAPI   WListClassLen      (void);
BOOL WINAPI   WListExists        (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WListFind          (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WListCount         (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListText          (LPSTR lpszCtrl, LPSTR lpszBuffer, DWORD dwTimeout);
int  WINAPI   WListLen           (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WListIndex         (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WListTopIndex      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListItemText      (LPSTR lpszCtrl, int iIndex, LPSTR lpszBuffer, DWORD dwTimeout);
int  WINAPI   WListItemLen       (LPSTR lpszCtrl, int iIndex, DWORD dwTimeout);
int  WINAPI   WListItemExists    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemClk       (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemCtrlClk   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemShftClk   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemDblClk    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListItemClkEx     (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
void WINAPI   WListItemCtrlClkEx (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
void WINAPI   WListItemShftClkEx (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
void WINAPI   WListItemDblClkEx  (LPSTR lpszCtrl, LPSTR lpszItem, int iOffset, DWORD dwTimeout);
int  WINAPI   WListSelCount      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListSelItems      (LPSTR lpszCtrl, LPINT lpIntArray, DWORD dwTimeout);
//void WINAPI   WListClear         (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WListAddItem       (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
//void WINAPI   WListDelItem       (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
BOOL WINAPI   WListEnabled       (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WListFocus         (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListSetFocus      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WListMoveTo        (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WListItemMoveTo    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WListDragTo        (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WListItemDragTo    (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Combobox routines
//---------------------------------------------------------------------------
void WINAPI   WComboSetClass   (LPSTR lpszClass);
void WINAPI   WComboGetClass   (LPSTR lpszBuffer);
int  WINAPI   WComboClassLen   (void);
void WINAPI   WComboSetLBClass (LPSTR lpszClass);
void WINAPI   WComboGetLBClass (LPSTR lpszBuffer);
int  WINAPI   WComboLBClassLen (void);
BOOL WINAPI   WComboExists     (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WComboFind       (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WComboCount      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboText       (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WComboLen        (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WComboIndex      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboSetText    (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
void WINAPI   WComboSelText    (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WComboSelLen     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WComboSelStart   (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboSetSel     (LPSTR lpszCtrl, LONG lSelStart, LONG lSelLength, DWORD dwTimeout);
void WINAPI   WComboItemText   (LPSTR lpszCtrl, int iIndex, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WComboItemLen    (LPSTR lpszCtrl, int iIndex, DWORD dwTimeout);
int  WINAPI   WComboItemExists (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WComboItemClk    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WComboItemDblClk (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
//void WINAPI   WComboClear      (LPSTR lpszCtrl, DWORD dwTimeout);
//void WINAPI   WComboAddItem    (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
//void WINAPI   WComboDelItem    (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
BOOL WINAPI   WComboEnabled    (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WComboFocus      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboSetFocus   (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WComboMoveTo     (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WComboItemMoveTo (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WComboDragTo     (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WComboItemDragTo (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Editbox routines
//---------------------------------------------------------------------------
void WINAPI   WEditSetClass (LPSTR lpszClassName);
void WINAPI   WEditGetClass (LPSTR lpszBuffer);
int  WINAPI   WEditClassLen (void);
BOOL WINAPI   WEditExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WEditFind     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditLen      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditText     (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
void WINAPI   WEditSetText  (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
void WINAPI   WEditSelText  (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
LONG WINAPI   WEditSelLen   (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditSelStart (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditSetSel   (LPSTR lpszCtrl, LONG lSelStart, LONG lSelLength, DWORD dwTimeout);
void WINAPI   WEditLineText (LPSTR lpszCtrl, LONG lIndex, LPSTR lpszBuff, DWORD dwTimeout);
LONG WINAPI   WEditLineLen  (LPSTR lpszCtrl, LONG lIndex, DWORD dwTimeout);
LONG WINAPI   WEditPos      (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditLine     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditChar     (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditFirst    (LPSTR lpszCtrl, DWORD dwTimeout);
LONG WINAPI   WEditLines    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditClick    (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WEditEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WEditFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WEditMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WEditDragTo   (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Static Control  routines
//---------------------------------------------------------------------------
//void WINAPI   WStaticSetClass (LPSTR);
//void WINAPI   WStaticGetClass (LPSTR lpszBuffer);
//int  WINAPI   WStaticClassLen (void);
//BOOL WINAPIV  WStaticExists   (LPSTR lpszText, ...);
//HWND WINAPIV  WStaticFind     (LPSTR lpszCtrl, ...);
//int  WINAPIV  WStaticLen      (LPSTR lpszText, ...);
//void WINAPIV  WStaticText     (LPSTR lpszText, LPSTR lpszBuffer, ...);
//void WINAPIV  WStaticMoveTo   (LPSTR lpszCtrl, int x, int y, ...);
//void WINAPI   WLabelText      (HWND hwnd, LPSTR lpszBuffer);
//int  WINAPI   WLabelLen       (HWND hwnd);

//---------------------------------------------------------------------------
// Scrollbar routines.
//---------------------------------------------------------------------------
void WINAPI   WScrollSetClass (LPSTR lpszClass);
void WINAPI   WScrollGetClass (LPSTR lpszBuffer);
int  WINAPI   WScrollClassLen (void);
BOOL WINAPI   WScrollExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WScrollFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WScrollEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WScrollFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WScrollMin      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WScrollMax      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WScrollPos      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollSetPos   (LPSTR lpszCtrl, int iPos, DWORD dwTimeout);
void WINAPI   WScrollPage     (LPSTR lpszCtrl, int iPages, DWORD dwTimeout);
void WINAPI   WScrollLine     (LPSTR lpszCtrl, int iLines, DWORD dwTimeout);
void WINAPI   WScrollHome     (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollEnd      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WScrollMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Custom Control routines.
//---------------------------------------------------------------------------
void WINAPI   WCustomSetClass (LPSTR lpszClassName);
void WINAPI   WCustomGetClass (LPSTR lpszBuffer);
int  WINAPI   WCustomClassLen (void);
BOOL WINAPI   WCustomExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WCustomFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCustomEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WCustomFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCustomSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCustomSetText  (LPSTR lpszCtrl, LPSTR lpszText, DWORD dwTimeout);
void WINAPI   WCustomGetText  (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
LONG WINAPI   WCustomTextLen  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WCustomClick    (LPSTR lpszCtrl, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomDblClk   (LPSTR lpszCtrl, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomClickAt  (LPSTR lpszCtrl, int x, int y, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomDblClkAt (LPSTR lpszCtrl, int x, int y, int iBtn, DWORD dwTimeout);
void WINAPI   WCustomMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WCustomDragTo   (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

#ifdef WIN32
//*****************************************************************************
//*****************************************************************************
//                               New 3.x API
//*****************************************************************************
//*****************************************************************************
//---------------------------------------------------------------------------
// TabView Control routines.
//---------------------------------------------------------------------------
void WINAPI   WTabSetClass     (LPSTR lpszClassName);
void WINAPI   WTabGetClass     (LPSTR lpszBuffer);
int  WINAPI   WTabClassLen     (void);
BOOL WINAPI   WTabExists       (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WTabFind         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTabFocus        (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WTabSetFocus     (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WTabCount        (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTabItemExists   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTabItemClk      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTabItemText     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTabItemLen      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTabItemIndex    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
BOOL WINAPI   WTabItemSelected (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTabItemMoveTo   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);

//---------------------------------------------------------------------------
// ListView Control routines.
//---------------------------------------------------------------------------
void WINAPI   WViewSetClass     (LPSTR lpszClassName);
void WINAPI   WViewGetClass     (LPSTR lpszBuffer);
int  WINAPI   WViewClassLen     (void);
BOOL WINAPI   WViewExists       (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WViewFind         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WViewFocus        (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WViewSetFocus     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WViewEnabled      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WViewCount        (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WViewSelCount     (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WViewSelItem      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
BOOL WINAPI   WViewItemExists   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WViewItemText     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszSubItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WViewItemLen      (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszSubItem, DWORD dwTimeout);
void WINAPI   WViewItemClk      (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemDblClk   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemCtrlClk  (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemShftClk  (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemLabelClk (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
BOOL WINAPI   WViewHeaderExists (LPSTR lpszCtrl, LPSTR lpszHdr, DWORD dwTimeout);
int  WINAPI   WViewHeaderCount  (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WViewHeaderText   (LPSTR lpszCtrl, LPSTR lpszHdr, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WViewHeaderLen    (LPSTR lpszCtrl, LPSTR lpszHdr, DWORD dwTimeout);
void WINAPI   WViewHeaderClk    (LPSTR lpszCtrl, LPSTR lpszHdr, int nBtn, DWORD dwTimeout);
int  WINAPI   WViewMode         (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WViewMoveTo       (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WViewItemMoveTo   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WViewHeaderMoveTo (LPSTR lpszCtrl, LPSTR lpszHdr, DWORD dwTimeout);
void WINAPI   WViewDragTo       (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WViewItemDragTo   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
int  WINAPI   WViewItemSelected (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WViewItemIndex    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WViewClk          (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Tree Control routines.
//---------------------------------------------------------------------------
void WINAPI   WTreeSetClass     (LPSTR lpszClassName);
void WINAPI   WTreeGetClass     (LPSTR lpszBuffer);
int  WINAPI   WTreeClassLen     (void);
BOOL WINAPI   WTreeExists       (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WTreeFind         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTreeFocus        (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WTreeSetFocus     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTreeEnabled      (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WTreeItemExists   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemText     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTreeItemLen      (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemClk      (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WTreeItemDblClk   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
BOOL WINAPI   WTreeItemExpanded (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemExpand   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeItemCollapse (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeMoveTo       (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WTreeItemMoveTo   (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeDragTo       (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);
void WINAPI   WTreeItemDragTo   (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WTreeSetPathChar  (LPSTR lpszChar);
void WINAPI   WTreeGetPathChar  (LPSTR lpszBuff);
void WINAPI   WTreeItemPath     (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTreeItemPathLen  (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTreeItemIndex    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTreeItemCount    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WTreeItemSelected (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WTreeClk          (LPSTR lpszCtrl, int x, int y, int nBtn, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Header Control routines.
//---------------------------------------------------------------------------
void WINAPI   WHeaderSetClass   (LPSTR lpszClassName);
void WINAPI   WHeaderGetClass   (LPSTR lpszBuffer);
int  WINAPI   WHeaderClassLen   (void);
BOOL WINAPI   WHeaderExists     (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WHeaderFind       (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WHeaderEnabled    (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WHeaderCount      (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WHeaderItemExists (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WHeaderItemText   (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WHeaderItemLen    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WHeaderItemClk    (LPSTR lpszCtrl, LPSTR lpszItem, int nBtn, DWORD dwTimeout);
void WINAPI   WHeaderMoveTo     (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);
void WINAPI   WHeaderItemMoveTo (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Toolbar Control routines.
//---------------------------------------------------------------------------
void WINAPI   WToolbarSetClass      (LPSTR lpszClassName);
void WINAPI   WToolbarGetClass      (LPSTR lpszBuffer);
int  WINAPI   WToolbarClassLen      (void);
BOOL WINAPI   WToolbarExists        (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WToolbarFind          (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WToolbarCount         (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonExists  (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonEnabled (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonPressed (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
BOOL WINAPI   WToolbarButtonChecked (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
int  WINAPI   WToolbarButtonIndex   (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
int  WINAPI   WToolbarButtonCmdId   (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarButtonText    (LPSTR lpszCtrl, LPSTR lpszBtn, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WToolbarButtonLen     (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarButtonClk     (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarButtonMoveTo  (LPSTR lpszCtrl, LPSTR lpszBtn, DWORD dwTimeout);
void WINAPI   WToolbarMoveTo        (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Slider Control routines.
//---------------------------------------------------------------------------
void WINAPI   WSliderSetClass (LPSTR lpszClassName);
void WINAPI   WSliderGetClass (LPSTR lpszBuffer);
int  WINAPI   WSliderClassLen (void);
BOOL WINAPI   WSliderExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WSliderFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSliderFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSliderSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSliderEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderMin      (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderMax      (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderSelMin   (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderSelMax   (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderPos      (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderLine     (LPSTR pszCtrl, DWORD dwTimeout);
int  WINAPI   WSliderPage     (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToMin    (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToMax    (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToSelMin (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToSelMax (LPSTR pszCtrl, DWORD dwTimeout);
void WINAPI   WSliderToPos    (LPSTR pszCtrl, int nPos, DWORD dwTimeout);
void WINAPI   WSliderBy       (LPSTR pszCtrl, int nTicks, DWORD dwTimeout);
void WINAPI   WSliderByLine   (LPSTR pszCtrl, int nLines, DWORD dwTimeout);
void WINAPI   WSliderByPage   (LPSTR pszCtrl, int nPages, DWORD dwTimeout);
void WINAPI   WSliderMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Spin Control routines.
//---------------------------------------------------------------------------
void WINAPI   WSpinSetClass (LPSTR lpszClassName);
void WINAPI   WSpinGetClass (LPSTR lpszBuffer);
int  WINAPI   WSpinClassLen (void);
BOOL WINAPI   WSpinExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WSpinFind     (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSpinFocus    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinSetFocus (LPSTR lpszCtrl, DWORD dwTimeout);
BOOL WINAPI   WSpinEnabled  (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSpinMin      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSpinMax      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WSpinPos      (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinToMin    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinToMax    (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WSpinToPos    (LPSTR lpszCtrl, int nPos, DWORD dwTimeout);
void WINAPI   WSpinBy       (LPSTR lpszCtrl, int nTicks, DWORD dwTimeout);
void WINAPI   WSpinMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Statusbar Control routines.
//---------------------------------------------------------------------------
void WINAPI   WStatusSetClass   (LPSTR lpszClassName);
void WINAPI   WStatusGetClass   (LPSTR lpszBuffer);
int  WINAPI   WStatusClassLen   (void);
BOOL WINAPI   WStatusExists     (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WStatusFind       (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WStatusCount      (LPSTR lpszCtrl, DWORD dwTimeout);
int  WINAPI   WStatusItemExists (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WStatusItemText   (LPSTR lpszCtrl, LPSTR lpszItem, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WStatusItemLen    (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
int  WINAPI   WStatusItemIndex  (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WStatusItemMoveTo (LPSTR lpszCtrl, LPSTR lpszItem, DWORD dwTimeout);
void WINAPI   WStatusMoveTo     (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Tooltips Control routines.
//---------------------------------------------------------------------------
void WINAPI   WTipsSetClass (LPSTR lpszClassName);
void WINAPI   WTipsGetClass (LPSTR lpszBuffer);
int  WINAPI   WTipsClassLen (void);
BOOL WINAPI   WTipsExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WTipsFind     (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WTipsText     (LPSTR lpszCtrl, LPSTR lpszBuff, DWORD dwTimeout);
int  WINAPI   WTipsLen      (LPSTR lpszCtrl, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Progress Control routines.
//---------------------------------------------------------------------------
void WINAPI   WProgressSetClass (LPSTR lpszClassName);
void WINAPI   WProgressGetClass (LPSTR lpszBuffer);
int  WINAPI   WProgressClassLen (void);
BOOL WINAPI   WProgressExists   (LPSTR lpszCtrl, DWORD dwTimeout);
HWND WINAPI   WProgressFind     (LPSTR lpszCtrl, DWORD dwTimeout);
void WINAPI   WProgressMoveTo   (LPSTR lpszCtrl, int x, int y, DWORD dwTimeout);

//---------------------------------------------------------------------------
// Desktop Control routines.
//---------------------------------------------------------------------------
HWND WINAPI WDesktopFind         (void);
int  WINAPI WDesktopCount        (void);
int  WINAPI WDesktopSelCount     (void);
int  WINAPI WDesktopSelItem      (LPSTR lpszItem);
BOOL WINAPI WDesktopItemExists   (LPSTR lpszItem);
void WINAPI WDesktopItemText     (LPSTR lpszItem, LPSTR lpszBuff);
int  WINAPI WDesktopItemLen      (LPSTR lpszItem);
void WINAPI WDesktopClk          (int x, int y, int nBtn);
void WINAPI WDesktopItemClk      (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemDblClk   (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemCtrlClk  (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemShftClk  (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopItemLabelClk (LPSTR lpszItem, int nBtn);
void WINAPI WDesktopMoveTo       (int x, int y);
void WINAPI WDesktopItemMoveTo   (LPSTR lpszItem);
void WINAPI WDesktopDragTo       (int x, int y, int nBtn);
void WINAPI WDesktopItemDragTo   (LPSTR lpszItem, int nBtn);

//---------------------------------------------------------------------------
// Taskbar routines.
//---------------------------------------------------------------------------
HWND WINAPI WTaskbarFind         (void);
BOOL WINAPI WTaskbarFocus        (void);
void WINAPI WTaskbarSetFocus     (void);
int  WINAPI WTaskbarCount        (void);
BOOL WINAPI WTaskbarItemExists   (LPSTR lpszItem);
void WINAPI WTaskbarItemClk      (LPSTR lpszItem, int nBtn);
//void WINAPI WTaskbarItemText     (LPSTR lpszItem, LPSTR lpszBuff);
//int  WINAPI WTaskbarItemLen      (LPSTR lpszItem);
int  WINAPI WTaskbarItemIndex    (LPSTR lpszItem);
BOOL WINAPI WTaskbarItemSelected (LPSTR lpszItem);
void WINAPI WTaskbarItemMoveTo   (LPSTR lpszItem);
void WINAPI WTaskbarStartClk     (int nBtn);
void WINAPI WTaskbarStartMoveTo  (void);
void WINAPI WTaskbarClk          (int nBtn);
void WINAPI WTaskbarClockClk     (int nBtn);
void WINAPI WTaskbarClockDblClk  (int nBtn);
void WINAPI WTaskbarClockMoveTo  (void);
void WINAPI WTaskbarAppClk       (int nApp, int nBtn);
void WINAPI WTaskbarAppDblClk    (int nApp, int nBtn);
void WINAPI WTaskbarAppMoveTo    (int nApp);
int  WINAPI WTaskbarAppCount     (void);

//*****************************************************************************
//*****************************************************************************
//                          END of New 3.x API
//*****************************************************************************
//*****************************************************************************
#endif // WIN32

//---------------------------------------------------------------------------
// Event queueing API.
//---------------------------------------------------------------------------
int  WINAPI   QueKeys (LPSTR);
int  WINAPI   QueKeyDn (LPSTR);
int  WINAPI   QueKeyUp (LPSTR);
int  WINAPI   DoKeys (LPSTR);
int  WINAPI   DoKeyshWnd (HWND, LPSTR);

void WINAPI   QuePause (DWORD);
UINT WINAPI   QueSetSpeed (UINT);
int  WINAPI   QueSetFocus (HWND);
int  WINAPI   QueSetRelativeWindow (HWND);

int  WINAPI   QueMouseMove (UINT, UINT);
int  WINAPI   QueMouseDn (int, UINT, UINT);
int  WINAPI   QueMouseUp (int, UINT, UINT);
int  WINAPI   QueMouseClick (int, UINT, UINT);
int  WINAPI   QueMouseDblClk (int, UINT, UINT);
int  WINAPI   QueMouseDblDn (int, UINT, UINT);

int  WINAPI   QueFlush (BOOL);
void WINAPI   QueEmpty (void);

//---------------------------------------------------------------------------
// System idle time detection API.
//---------------------------------------------------------------------------
BOOL WINAPI   WaitUntilIdle (DWORD dwTimeout);
void WINAPI   SetNotIdle (void);

#endif

#ifdef __cplusplus
}
#endif

#endif // _T4CTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\target.h ===
/////////////////////////////////////////////////////////////////////////////
// target.h
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Interface of the CTarget class

#ifndef __TARGET_H__
#define __TARGET_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "settings.h"
#include "log.h"
#include "toolset.h"

#include "targxprt.h"


/////////////////////////////////////////////////////////////////////////////
// CTarget

class TARGET_CLASS CTarget
{
// ctor/dtor
public:
	CTarget();
	virtual ~CTarget();

// operations
public:
	// initialize the target
	virtual BOOL Initialize(CToolset::BUILD_TYPE, CString strKey) = 0;
	
	// get the property page that contains this target's UI
	virtual CPropertyPage* GetPage(void) { return m_ppageTarget; }

	// launch the target
	virtual BOOL Launch(void);
	virtual BOOL Attach(void);
	
	// exit the target
	virtual BOOL Exit(void);

	// apply settings in the given object to the target
	virtual BOOL ApplySettings(CSettings* pSettings);

	virtual BOOL SetEnvironmentVar(LPCSTR pszEnvVar, LPCSTR pszValue);

	// get target information
	CString GetPath(void);
	CString GetFileName(void);

	CSettings* GetSettings(void)					{ ASSERT(m_psettingsTarget); return m_psettingsTarget; }
  virtual CString GetVersion();
	CString GetFullCmdLine(void);

	// set the log the target will use
	virtual BOOL SetLog(CLog* pLog);

// attributes
public:
	// indicate whether the target is available to test
	virtual BOOL IsLaunched(void) { DWORD dwCode; GetExitCodeProcess(m_procinfoTarget.hProcess, &dwCode); return dwCode == STILL_ACTIVE;}

// operations (internal)
protected:
	// initialize the target's default environment
	BOOL InitEnv(void);

	// launch the target
	static UINT WrapLaunchTarget(LPVOID pParam);
  UINT LaunchTarget(void);

	// attach to the target
	static UINT WrapAttachTarget(LPVOID pParam);
	UINT AttachTarget(void);

	//event handlers
private:
	static BOOL CALLBACK FindMsgToHandle(HWND hwnd, CTarget *_this);
	static BOOL CALLBACK FindAssertText(HWND hAssert, CTarget *_this);
	static BOOL CALLBACK FindExceptionText(HWND hAssert, char buffer[]);

	static UINT WrapEventHandler(LPVOID pParam);
	UINT EventHandler(void);
	void HandleAssertion(BOOL bClickIgnore, BOOL bBreak);
	void HandleExceptionDlg(BOOL bIgnore, BOOL bBreak, LPCSTR msgTilte);
protected:
  // create the target's process
  virtual BOOL CreateTargetProcess(LPCSTR szCmdLine, DWORD dwCreationFlags, LPCSTR szEnvBlock, LPCSTR szWorkDir) = 0;

	// helper functions for LaunchTarget
	CString GetEnvBlock(void);

	// helper functions for Launch and Attach
	CString GetThreadResult(HANDLE hThread);

	// get a unique name per target for uniquely named system objects
	CString GetUniqueName(void);

// Debug event handlers
private:
	virtual void  HandleDebugEvents(void);
	virtual DWORD HandleException(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleCreateThread(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleCreateProcess(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleExitThread(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleExitProcess(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleLoadDLL(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleUnloadDLL(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleOutputDebugString(const DEBUG_EVENT& DebugEvent);
	virtual DWORD HandleRIP(const DEBUG_EVENT& DebugEvent);

	LPCSTR GetExceptionDescription(DWORD dwCode);
	CString& GetOutputDebugString(const DEBUG_EVENT& DebugEvent);
	LPCSTR GetRIPDescription(DWORD dwType);
protected:
	// initialize this target's settings
	virtual BOOL InitializeSettings(void);

public:
	void SetHandleMsgTitle(CString &title);
	void SetHandleMsgs(BOOL enablehandling)
	{
		m_handlemsgs=enablehandling; //don't think thread safety is important here
	};
// data
protected:
//ASSERTIONS are not set by SetHandleMsgTitle (always handled)
	CString m_AssertionMsgTitle;
	CString m_AssertionMsgText;
	BOOL m_EnableExceptionMessageHandling;

private:
	BOOL m_handlemsgs;
	HWND m_hAssert;
	int m_nWndtoHandle;
	CString m_HandleMsgTitles[5]; //arbitrary number, maybe increased
public:
	// the number of expected memory leaks (0 - no leaks, -1:turn off memleak report)
	int m_nExpectedLeaks;

// data types
protected:
	enum DebugThreadResult { dtr_success, dtr_invalidevent, dtr_exenotfound, dtr_invalidexe };

// data
protected:
	CSettings* m_psettingsTarget;
	CPropertyPage* m_ppageTarget;

public:
	PROCESS_INFORMATION m_procinfoTarget;

protected:
	HANDLE m_hTerminate;
	HANDLE m_hthreadDebug;

	// storage for unqiue ids
	static int nCount;
	DWORD m_nId;

	// storage for target's environment
	CMapStringToString m_mapEnv;

	// storage for the value of the MFC Tracer flag
	int m_nTracer;

	// store the number of memory leaks
	int m_nLeaks;

	// storage for the OutputDebugString string
	CString m_strDebugOutput;

	// storage for the flag to indicate the process has been created
	// apparently there is a breakpoint exception that is thrown when a process (just the IDE?)
	// starts up. We need to ignore this exception the first time. m_bInitProcess indicates
	// if the target app just started.
	BOOL m_bInitProcess;

	// the log the target will use
	CLog* m_pLog;

	static const LPCTSTR eventTerminate;
	static const LPCTSTR eventTargetSuccess;
	static const LPCTSTR eventTargetFail;

  CString m_strLastCmdLine;  // holds command line of last invocation

	// holds the path the target
	CString m_strPath;
	// holds the filename of the target
	CString m_strFileName;
private:
	HANDLE m_hEventThread; //event thread which handles the unexpected dialogs
	HANDLE m_hTestthread; //used for thread suspension from the event thread
};

#define TRACER_INI		"afx.ini"
#define TRACER_SECTION	"Diagnostics"
#define TRACER_KEY		"TraceEnabled"
#define TRACER_DEFAULT	0
#define TRACER_ON		"1"
#define TRACER_OFF		"0"

#endif // __TARGET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\textlog.h ===
/////////////////////////////////////////////////////////////////////////////
// textlog.h
//
// email	date		change
// cflaat	11/01/94	created
//
// copyright 1994 Microsoft

// CTextLog interface

#ifndef __TEXTLOG_H__
#define __TEXTLOG_H__

#pragma warning(disable: 4251)

#include "log.h"

/*
    CTextLog
    ========

    This file and design copyright 1993-94 by Microsoft Corp.
    Created by CFlaat, based on the CLogRecorder class by RickKr.
    
      This class is a particular implementation of the CLog interface.
    The constructor can take two strings.  The first is the name of the
    final results output file, and the second is the directory in which
    temporary files should be stored.

*/
			   
class AFX_EXT_CLASS CTextLog : public CLog
{
public:  // CLog overrides

  CTextLog(LPCSTR szResultsFile = "results.log",
           LPCSTR szSummaryFile = "summary.log",
           LPCSTR szWorkDir = 0,
           HANDLE hOutput = 0,
           BOOL bLogComments = FALSE);

  virtual ~CTextLog(void);

  virtual BOOL BeginSubSuite(LPCSTR, LPCSTR);
  virtual BOOL EndSubSuite(void);
  virtual BOOL BeginTest(LPCSTR szTestName, long cCompares = -1);
  virtual BOOL EndTest(void);      

  virtual BOOL RecordTestKeys(PRINTF_ARGS ); //Records test keystrokes.
  virtual BOOL RecordSuccess(PRINTF_ARGS);            // product passed a test
  virtual BOOL RecordFailure(PRINTF_ARGS);        // product failed a test
  virtual BOOL RecordInfo(PRINTF_ARGS);			      // recorded but ignored
  virtual BOOL RecordTextFile(LPCSTR szFile, PRINTF_ARGS);  // append a text file to the log
  virtual BOOL RecordCriticalError(PRINTF_ARGS);  // called for errors that force test termination
  virtual BOOL RecordCompare(BOOL bSuccess, PRINTF_ARGS);		// called to record based on bSuccess

  virtual BOOL Comment(PRINTF_ARGS);              // chatty trace commentary that can be ignored
                                                      // or dumped at the CAFE driver's discretion

protected:
  friend class CSuiteDoc;

  void EmitSummaryInformation( void );
  void EmitHeaderInformation( void );

  CStdioFile
	  m_sfHeader,
	  m_sfDetails,
	  m_sfSummary,
	  m_sfResults;

  enum EntryType { Header, Summary, Comments, Results, FailureDetails, InfoDetails, Separator, SuccessDetails, None };

  void EmitFieldAndValue( EntryType eType, LPCSTR szField, LPCSTR szValue );

  void EmitLine(EntryType, LPCSTR); 
  void ConcatStdioFiles(CStdioFile &dest, CStdioFile &src);
  void EmitBanner( EntryType eType, LPCSTR pszBannerTitle );
  void EmitSeparator(LPCSTR pszSeparatorTitle );

  void EmitDetails( EntryType eType, LPCSTR);

  static const int m_nIndent;  // # of spaces to indent from left

  int m_nLastDetailBanner;
};

#endif // __TEXTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\vertex.h ===
/////////////////////////////////////////////////////////////////////////////
// vertex.h
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1994 Microsoft

// Interface of the CVertex class

#ifndef __VERTEX_H__
#define __VERTEX_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CVertex class

class CVertex: public CObject
{
	DECLARE_DYNAMIC(CVertex)

// data types
public:
	enum Category { AccelEd = 0, BitmapEd, CursorEd, Debugger, DialogEd, IconEd, MenuEd, Project, ResScript, SourceEd, StringEd, ToolbarEd, VersionEd, NumCategories, Null };

	enum NullVertices		{ V_Null = 0 };
	enum AccelEdVertices	{ V_AccelBegin = 0,		V_AccelOpen };
	enum BitmapEdVertices	{ V_BmpBegin = 0,		V_BmpOpen };
	enum CursorEdVertices	{ V_CursorBegin = 0,	V_CursorOpen };
	enum DebuggerVertices	{ V_DbgBegin = 0,		V_DbgDebug };
	enum DialogEdVertices	{ V_DialogBegin = 0,	V_DialogOpen };
	enum IconEdVertices		{ V_IconBegin = 0,		V_IconOpen };
	enum MenuEdVertices		{ V_MenuBegin = 0,		V_MenuOpen };
	enum ProjectVertices	{ V_ProjBegin = 0,		V_ProjOpen,		V_ProjBuilt };
	enum ResScriptVertices	{ V_ResBegin = 0,		V_ResOpen };
	enum SourceEdVertices	{ V_SrcBegin = 0,		V_SrcOpen };
	enum StringEdVertices	{ V_StringBegin = 0,	V_StringOpen };
	enum ToolbarEdVertices	{ V_ToolbarBegin = 0,	V_ToolbarOpen };
	enum VersionEdVertices	{ V_VersionBegin = 0,	V_VersionOpen };

// constructor/destructor
public:
	CVertex(void);
	CVertex(Category category, int vertex);
	CVertex(const CVertex& vertex);
	virtual ~CVertex();

// operations
public:
	int GetVertex(void);
	Category GetCategory(void);

	CVertex& operator=(const CVertex& vertex);
	BOOL operator==(const CVertex& vertex);
	BOOL operator!=(const CVertex& vertex);

	LPCSTR GetName(void);

// data:
protected:
	int m_Vertex;
	Category m_Category;

// data
private:
	static LPCSTR NullVertexNames[];
	static LPCSTR AccelEdVertexNames[];
	static LPCSTR BitmapEdVertexNames[];
	static LPCSTR CursorEdVertexNames[];
	static LPCSTR DebuggerVertexNames[];
	static LPCSTR DialogEdVertexNames[];
	static LPCSTR IconEdVertexNames[];
	static LPCSTR MenuEdVertexNames[];
	static LPCSTR ProjectVertexNames[];
	static LPCSTR ResScriptVertexNames[];
	static LPCSTR SourceEdVertexNames[];
	static LPCSTR StringEdVertexNames[];
	static LPCSTR ToolbarEdVertexNames[];
	static LPCSTR VersionEdVertexNames[];

	static LPCSTR* VertexNames[];
};

// null vertices
extern const CVertex NullVertex;

#endif //__VERTEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\test.h ===
/////////////////////////////////////////////////////////////////////////////
// test.h
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Interface of the CTest classes

#ifndef __TEST_H__
#define __TEST_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "log.h"
#include "settings.h"
#include "target.h"
#include "idetarg.h"
#include "toolset.h"
#include "guiv1.h"
#include "platform.h"

///////////////////////////////////////////////////////////////////////////////
//useful macro for the compile time message very needed in CAFE;
//example of usage:
//#pragma message(__LOC__ "Working around C2XX codegen bug 3397 by...")
#define __STR2__(x) #x
#define __STR1__(x) __STR2__(x)
#define __LOC__ __FILE__ "("__STR1__(__LINE__)"): CAFE msg: "

///////////////////////////////////////////////////////////////////////////////
// CTest macros -- for use in derived classes

#define DECLARE_TEST(this_class, subsuite_class)	\
		DECLARE_DYNAMIC(this_class)								\
	public:														\
		this_class(subsuite_class* pSubSuite);					\
		subsuite_class* GetSubSuite(void);

#define DECLARE_LISTTEST(this_class, subsuite_class)	\
		DECLARE_DYNAMIC(this_class)								\
	public:														\
		this_class(subsuite_class* pSubSuite);					\
		subsuite_class* GetSubSuite(void);

#define IMPLEMENT_TEST(this_class, base_class, test_name, num_comparisons, subsuite_class)		\
	IMPLEMENT_DYNAMIC(this_class, base_class)													\
	this_class::this_class(subsuite_class* pSubSuite)											\
	: base_class(pSubSuite, test_name, num_comparisons)											\
	{																							\
	}																							\
	subsuite_class* this_class::GetSubSuite(void)												\
	{																							\
		ASSERT(m_pSubSuite->IsKindOf(RUNTIME_CLASS(subsuite_class)));							\
		return (subsuite_class*)m_pSubSuite;													\
	}

// A list test doesn't specify a number of comparisons because it can vary as the test is run.
#define IMPLEMENT_LISTTEST(this_class, base_class, test_name, test_list, subsuite_class)		\
	IMPLEMENT_DYNAMIC(this_class, base_class)													\
	this_class::this_class(subsuite_class* pSubSuite)											\
	: base_class(pSubSuite, test_name, -1, test_list)											\
	{																							\
	}																							\
	subsuite_class* this_class::GetSubSuite(void)												\
	{																							\
		ASSERT(m_pSubSuite->IsKindOf(RUNTIME_CLASS(subsuite_class)));							\
		return (subsuite_class*)m_pSubSuite;													\
	}

#define XSAFETY (((CIDESubSuite*)GetSubSuite())->GetIDE()->IsActive())

// forward declarations
class CRawListString;
class CSubSuite;

///////////////////////////////////////////////////////////////////////////////
//	CTest abstract base class

class CTest : public CObject
{
	DECLARE_DYNAMIC(CTest)

// data types
public:
	enum RunState { RS_NoRun = 0, RS_Run };

// constructor/destructor
public:
	CTest(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);
	virtual ~CTest();

// Operations
public:
	virtual void PreRun(void);
  	virtual void PreRun(CRawListString &);
	virtual void Run(void);
    virtual void Run(CRawListString &);
	virtual void PostRun(void);
    virtual void PostRun(CRawListString &);

	virtual BOOL RunAsDependent(void);

  BOOL CanTestPlatform(CPlatform *pPlatform);

  void AddSupportedPlatform(const CPlatform::COS &rOS, const CPlatform::CLanguage &rLang);

	CLog* GetLog(void);

	CSubSuite* GetSubSuite(void);

	CString GetCWD(void);

	BOOL SetName(LPCSTR szName);
	CString GetName(void);

	BOOL SetRunState(RunState rs);
	RunState GetRunState(void);

    BOOL SetListFilename(LPCSTR szListFilename);
    CString GetListFilename(void);

	BOOL SetDependency(CTest* pTest);
	CTest* GetDependency(void);

	virtual int GetType(void);

	// WriteLog is provided for backward compatibility only
	// GetLog()->RecordCompare should be used instead
	enum LogType { PASSED = 0, FAILED };
	void WriteLog(int LT, LPCSTR szFmt, ... );

// Data
protected:
	// storage for the log
	CLog* m_pLog;

	// storage for the subsuite
	CSubSuite* m_pSubSuite;

	// test attributes: name, run/no run, pre- and post-conditions
	CString m_strName;
	RunState m_rs;

	// storage for the test's current working directory
	CString m_strCWD;

	// the name of the list filename, if applicable
    CString m_strListFilename;

	// the number of comparisons expected when this test runs
	int m_nExpectedCompares;

	// storage for the test's dependency
	CTest* m_pDependency;

    // list of supported platforms

    typedef CList<CPlatform *, CPlatform *> CPlatformList;

	CPlatformList *m_pPlatformList;

	// storage for the type of test
	int m_nType;

	// Store the start and end times for this test.
	CTime m_timeStart;
	CTime m_timeEnd;

// don't want anyone to call these
protected:
	CTest() { }
};

// types of tests
#define TEST_TYPE_STANDARD	0x01
#define TEST_TYPE_LIST		0x02

#endif //__TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\targxprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	targxprt.h (target export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		Target DLL defines
//

#ifndef __TARGXPRT_H__
#define __TARGXPRT_H__

#ifdef EXPORT_TARGET
	#define TARGET_CLASS AFX_EXT_CLASS
	#define TARGET_API   AFX_EXT_API
	#define TARGET_DATA  AFX_EXT_DATA
#else
	#define TARGET_CLASS __declspec(dllimport)
	#define TARGET_API   __declspec(dllimport)
	#define TARGET_DATA  __declspec(dllimport)

	#ifdef _DEBUG
		#pragma comment(lib, "targetd.lib")
	#else
		#pragma comment(lib, "target.lib")
	#endif
#endif

#endif //__TARGXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\toolset.h ===
/////////////////////////////////////////////////////////////////////////////
// toolset.h
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Interface of the CToolset class

#ifndef __TOOLSET_H__
#define __TOOLSET_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#pragma warning(disable: 4251)

#include "log.h"
#include "toolxprt.h"

#include "platform.h"


class CIDE;		// Forward declarations.
class CTarget;
class CSettings;
class CCompilerDriver;
class CExecutable;

/////////////////////////////////////////////////////////////////////////////
// CToolset

typedef CTypedPtrList<CPtrList, CTarget*> CToolPtrList;


class TOOLSET_CLASS CToolset
{
// ctor/dtor
public:

	enum BUILD_TYPE {Debug, Retail};

	CToolset(BUILD_TYPE nBuildType, HANDLE hOutput);
	virtual ~CToolset();

protected:
	CToolset() { ASSERT(FALSE); }  // not to be used

// data types
public:
	enum ToolsetLangs { TL_ENGLISH, TL_GERMAN, TL_JAPANESE };

// access attributes
public:
	virtual BOOL SetLanguage(ToolsetLangs lang);
	virtual ToolsetLangs GetLanguage(void);

// operations
public:
	// initialize the toolset
	virtual BOOL Initialize(CString strBaseKey) = 0;

	// display the options tabbed dialog
	virtual BOOL ToolsetOptions(void);

	// register tools
	virtual BOOL AddTool(CTarget *pTarget);

	// apply settings in the given object to the toolset
	virtual BOOL ApplySettings(CSettings* pSettings);

	CSettings* GetToolsetSettings(void)				{ ASSERT(m_psettingsToolset); return m_psettingsToolset; }
	CSettings* GetEnvSettings(void)					{ ASSERT(m_psettingsEnv); return m_psettingsEnv; }

	// set the log the toolset will use
	virtual BOOL SetLog(CLog* pLog);
  virtual CLog* GetLog();

  const CToolPtrList& GetToolList();

// attributes
public:
	// static data about the toolset
/*	static CString m_strToolsets[];
	static CString m_strToolsetSwitches[];
	static CString m_strLanguage[];*/
	static CString m_strBuildType[];
	static CString m_strEnvvars[];

// operations (internal)
protected:
	// initialize toolset settings
	virtual BOOL InitializeSettings(void);
	virtual BOOL InitializeEnvSettings(void);
	virtual BOOL InitializeToolsetSettings(void);
	
// data
protected:
	CToolPtrList m_listTools;
	CSettings* m_psettingsEnv;
	CSettings* m_psettingsToolset;
	CString m_strBaseKey;
	CString m_strLang;
	CString m_strDebug;
	HANDLE m_hOutput;
	BUILD_TYPE m_nBuildType;
	
	// the log the toolset will use
	CLog* m_pLog;
	// toolset's language
	ToolsetLangs m_lang;
	// handle to the dll that contains the localized ide strings.
	HINSTANCE m_hStringsDll;
};


/*  toolset creation */

TOOLSET_API CToolset * CreateToolset(CPlatform::COS *pOS, CPlatform::CLanguage *pLang, CToolset::BUILD_TYPE, HANDLE hOutput);




/////////////////////////////////////////////////////////////////////////////
// CDevTools

class TOOLSET_CLASS CDevTools: public CToolset
{
// ctor/dtor
public:
	CDevTools(BUILD_TYPE nBuildType, HANDLE hOutput);
	~CDevTools();

protected:
	CDevTools();

// operations
public:
	virtual BOOL Initialize(CString strBaseKey) = 0;

// data
protected:
	CIDE* m_pIDE;
  CCompilerDriver *m_pCompilerDriver;
  CExecutable *m_pExecutable;
};


/////////////////////////////////////////////////////////////////////////////
// CVCTools

const CString settingPath = "Path";
const CString settingLib = "Lib";
const CString settingInclude = "Include";

class TOOLSET_CLASS CVCTools: public CDevTools
{
// ctor/dtor
public:
	CVCTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CDevTools(nBuildType, hOutput) {}
	virtual ~CVCTools() {}

protected:
	CVCTools() {}

// operations
public:
	virtual BOOL Initialize(CString strBaseKey) = 0;

	
	virtual CIDE* GetIDE(void)	{ return m_pIDE; } // get a pointer to the IDE
	virtual CCompilerDriver* GetCompilerDriver(void)	{ return m_pCompilerDriver; }
	virtual CExecutable* GetExecutable(LPCSTR szExeName);

// operations (internal)
protected:

// data
protected:
//	CIDE* m_pIDE;
};


/////////////////////////////////////////////////////////////////////////////
// CX86Tools

const CString strX86ToolsKey = "X86 Toolset";

class TOOLSET_CLASS CX86Tools: public CVCTools
{
// ctor/dtor
public:
	CX86Tools(BUILD_TYPE nBuildType, HANDLE hOutput) : CVCTools(nBuildType, hOutput) { m_pIDE = 0; }  // for now
	virtual ~CX86Tools() { }

protected:
  CX86Tools() {}

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};


/////////////////////////////////////////////////////////////////////////////
// CWin32sTools

const CString strWin32sToolsKey = "Win32s Toolset";

class TOOLSET_CLASS CWin32sTools: public CX86Tools
{
// ctor/dtor
public:
	CWin32sTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CX86Tools(nBuildType, hOutput) { }  
	virtual ~CWin32sTools() { }

protected:
  CWin32sTools() {}

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};

/////////////////////////////////////////////////////////////////////////////
// C68KTools

const CString str68KToolsKey = "68K Toolset";

class TOOLSET_CLASS C68KTools: public CX86Tools
{
// ctor/dtor
public:
	C68KTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CX86Tools(nBuildType, hOutput) { }
	virtual ~C68KTools() { }

protected:
	C68KTools() { }

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};

/////////////////////////////////////////////////////////////////////////////
// CPMacTools

const CString strPMacToolsKey = "PowerMac Toolset";

class TOOLSET_CLASS CPMacTools: public CX86Tools
{
// ctor/dtor
public:
	CPMacTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CX86Tools(nBuildType, hOutput)  { }
	virtual ~CPMacTools() { }

protected:
	CPMacTools() { }

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};

/////////////////////////////////////////////////////////////////////////////
// CMIPSTools

const CString strMIPSToolsKey = "MIPS Toolset";

class TOOLSET_CLASS CMIPSTools: public CVCTools
{
// ctor/dtor
public:
	CMIPSTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CVCTools(nBuildType, hOutput)  { }
	virtual ~CMIPSTools() { }

protected:
	CMIPSTools() { }

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};

/////////////////////////////////////////////////////////////////////////////
// CAlphaToolset

const CString strAlphaToolsKey = "Alpha Toolset";

class TOOLSET_CLASS CAlphaTools: public CVCTools
{
// ctor/dtor
public:
	CAlphaTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CVCTools(nBuildType, hOutput) { }
	virtual ~CAlphaTools() { }

protected:
	CAlphaTools() { }

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};

/////////////////////////////////////////////////////////////////////////////
// CPowerPCToolset

const CString strPowerPCToolsKey = "PowerPC Toolset";

class TOOLSET_CLASS CPowerPCTools: public CVCTools
{
// ctor/dtor
public:
	CPowerPCTools(BUILD_TYPE nBuildType, HANDLE hOutput) : CVCTools(nBuildType, hOutput) { }
	virtual ~CPowerPCTools() { }

protected:
	CPowerPCTools() { }

// operations
public:
	virtual BOOL Initialize(CString strBaseKey);
};


#endif // __TOOLSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\toolxprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	toolxprt.h (tools export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		Toolset DLL defines
//

#ifndef __TOOLXPRT_H__
#define __TOOLXPRT_H__

#ifdef EXPORT_TOOLSET
	#define TOOLSET_CLASS AFX_EXT_CLASS
//	#define TOOLSET_API   AFX_EXT_API

	#define TOOLSET_API   __declspec(dllexport)
  
  #define TOOLSET_DATA  AFX_EXT_DATA
#else
	#define TOOLSET_CLASS __declspec(dllimport)
	#define TOOLSET_API   __declspec(dllimport)
	#define TOOLSET_DATA  __declspec(dllimport)

#ifndef __TARGET_H__
	#ifdef _DEBUG
		#pragma comment(lib, "toolsetd.lib")
	#else
		#pragma comment(lib, "toolset.lib")
	#endif
#endif
#endif

#endif //__TOOLXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\testxcpt.h ===
///////////////////////////////////////////////////////////////////////////////
//	testxcpt.h
//
//	Created by :			Date :
//		BrianCr				11/29/94
//
//	Description :
//		Declaration of the CTestException class
//

#ifndef __TESTXCPT_H__
#define __TESTXCPT_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "targxprt.h"

#pragma warning(disable: 4251)

///////////////////////////////////////////////////////////////////////////////
// CTestException class

class TARGET_CLASS CTestException/*: public CException*/
{
/*
	DECLARE_DYNAMIC(CTestException)
*/

public:
	enum TestExceptionCause {
		causeUnknown,			// invoker didn't specify a cause
		causeGeneric,			// no current use
		causeOperationFail,		// operation failed
		causeAssumptionFail,	// assumption failed
		causeExpectFail,		// expectation failed
		causeSafetyFail,		// safety failed
		causeTargetGone,		// target app lost the focus
		causeTargetAssert,		// target app asserted
		causeTargetGPF,			// target app crashed
		NUM_CAUSES
	};

// Constructor
	CTestException(CString strMsg = "", TestExceptionCause cause = CTestException::causeUnknown, LPCSTR lpszFileName = NULL, int nLine = -1);

// operations
public:
	CString GetMessage(void)				{ return m_strMsg; }
	TestExceptionCause GetCause(void)		{ return m_cause; }

// data
protected:
	CString m_strMsg;
	TestExceptionCause m_cause;
	LPCSTR m_file;
	int m_line;

/*
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
*/
};


/*	TEST_EXCEPTION
 *		Throws a CTestException with the specified CTestException::enum cause.
 *		Also notes the file and line number, like an assert.
 *			(Note: THROW macro had a bug until MFC 2.5)
 *	SAFETY_EXCEPTION
 *		Throws a CTestException with the specified CTestException::enum cause.
 *		Used by SafetyCheck, which passes a file and line.
 */
/*
#if _MFC_VER < 0x0250		// work around for old MFC bug: THROW macro had ';'
#define TEST_EXCEPTION( cause )\
	afxExceptionContext.Throw(\
		new CTestException("", CTestException::##cause, THIS_FILE, __LINE__) )
#define SAFETY_EXCEPTION( cause, file, line )\
	afxExceptionContext.Throw( \
		new CTestException("", CTestException::##cause, file, line) )
#else			// workaround doesn't work in later MFC - use normal method again
*/
#define TEST_EXCEPTION( cause )\
	throw CTestException("", CTestException::##cause, THIS_FILE, __LINE__)
#define SAFETY_EXCEPTION( cause, file, line )\
	throw CTestException("", CTestException::##cause, file, line)
/*
#endif
*/

/*	EXPECT
 *		Like ASSERT (except it works in RETAIL), this does nothing if the
 *		condition is met, but throws an exception if it fails.
 *		This method is preferrable to an ASSERT in the following cases:
 *			The condition's failure means the target app is in a bad state
 *			You want a failure to write a log rather than bring up an ASSERT
 *		You should still use ASSERT when verifying the integrity of your own
 *		testing code.
 */
#define EXPECT( b )\
			((b) ? (void)0 : TEST_EXCEPTION(causeExpectFail))

/*	EXPECT_EXEC
 *		Like EXPECT, but caches a fail detail
 */
#define EXPECT_EXEC( b, sz )\
			((b) ? (void)0 : throw CTestException(sz, CTestException::causeExpectFail, THIS_FILE, __LINE__))

/*	CATCH_EXPECT
 *		Catches exceptions thrown by EXPECT or EXPECT_EXEC.  All others are
 *		thrown to the next handler.
 */
#define CATCH_EXPECT( e )\
			catch (CTestException e ) { \
			if ( e->m_cause != CTestException::causeExpectFail )\
				throw; \
			}

/*	CATCH_EXPECT_AND_IGNORE
 *		Like CATCH_EXPECT, except that no handler block or END_CATCH is needed.
 *		All EXPECT exceptions are ignored.
 */
#define CATCH_EXPECT_AND_IGNORE\
			CATCH_EXPECT( e )

/*	CATCH_NOEXEC
 *		Catches exceptions thrown by EXPECT and EXPECT_EXEC, then logs a
 *		FAIL NOEXEC for the current test.  If EXPECT_EXEC caused the
 *		exception, a failure detail will be logged as well.  If something
 *		other than an EXPECT caused the exception, it is thrown to the next
 *		handler.
 */
#define CATCH_NOEXEC\
			CATCH_EXPECT( e )
/*
			if ( !HaveFailInCache() )\
				CacheFailDetail( "Expected condition not met (%s %d)", e->m_file, e->m_line );\
			WriteLog( LT_NOEXEC, GetTestDesc() );\
			ClearFailCache();\
			END_CATCH
*/


#endif //__CAFEXCPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\aplogdlg.h ===
/////////////////////////////////////////////////////////////////////////////
// aplogdlg.h
//
// email	date		change
// briancr	02/06/95	created
//
// copyright 1994 Microsoft

// Interface of the CAppLogDlg class

/////////////////////////////////////////////////////////////////////////////
// CAppLogDlg dialog

#include "caferes.h"
#include "applog.h"

class CAppLogDlg : public CDialog
{
// Construction
public:
	CAppLogDlg(CAppLog* pAppLog = NULL, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCAFELogDlg)
	enum { IDD = IDD_AppLog };
	CString m_strAppLog;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCAFELogDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnInitDialog(void);
	virtual void OnCopy(void);
	virtual void OnClear(void);

// data
protected:
	CAppLog* m_pAppLog;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCAFELogDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Include\w32repl.h ===
///////////////////////////////////////////////////////////////////////////////
// File: W32Repl.h
//
// Description: This file creates strategic replacements for certain Win32 
//              API functions.  This header is a forced #include for ALL
//              CAFE source files.
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_W32REPL_H
#define _INC_W32REPL_H

#include <afxwin.h>
#include "targxprt.h"

extern TARGET_DATA UINT g_nSleepModifier;
extern TARGET_DATA BOOL g_bInfiniteIdleWaits;

TARGET_API DWORD CAFE_WaitForInputIdle(HANDLE hProcess, DWORD dwTimeout);
TARGET_API VOID CAFE_Sleep(DWORD cMilliseconds);

#define Sleep(X) CAFE_Sleep((X))
#define WaitForInputIdle(X, Y)  CAFE_WaitForInputIdle((X), (Y))

#endif // _INC_W32REPL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafebar.h ===
/////////////////////////////////////////////////////////////////////////////
// cafebar.h
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Interface of the CCAFEBar class

#ifndef __CAFEBAR_H__
#define __CAFEBAR_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "settings.h"


///////////////////////////////////////////////////////////////////////////////
// CCAFEBar class

class CPlatform;

class CCAFEBar : public CToolBar
{
// ctor/dtor
public:
	CCAFEBar(CSettings* pSettings) : m_pfont(NULL), m_pcbToolset(NULL), m_pcbBuildType(NULL), m_pcbLanguage(NULL), m_pSettings(pSettings) { }
	~CCAFEBar();

// operations
public:
	CreateBar(CWnd* pParent);

	BOOL UpdateToolset(void);
	BOOL UpdateBuildType(void);
	BOOL UpdateLanguage(void);

// operations (internal)
protected:
	BOOL SelectToolset(void);
	BOOL SelectBuildType(void);
	BOOL SelectLanguage(void);

	CFont* CreateFont(void);
	CComboBox* CreateToolsetCombo(int nPos);
	CComboBox* CreateBuildTypeCombo(int nPos);
	CComboBox* CreateLanguageCombo(int nPos);
	CComboBox* CreateCombo(UINT nId, int nPos, int nWidth);

	void SizeComboToContent(CComboBox* pCombo, int nMax = 0);

// data
protected:
	CComboBox* m_pcbToolset;
	CComboBox* m_pcbBuildType;
	CComboBox* m_pcbLanguage;
	CFont* m_pfont;

	CSettings* m_pSettings;
};

#endif // __CAFEBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\aplogdlg.cpp ===
// clogdlg.cpp : implementation file
//

#include "stdafx.h"
#include "aplogdlg.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAppLogDlg dialog


CAppLogDlg::CAppLogDlg(CAppLog* pAppLog /*= NULL*/, CWnd* pParent /*=NULL*/)
	: CDialog(CAppLogDlg::IDD, pParent),
	  m_pAppLog(pAppLog)
{
	//{{AFX_DATA_INIT(CAppLogDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAppLogDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAppLogDlg)
	DDX_Text(pDX, IDE_AppLog, m_strAppLog);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAppLogDlg, CDialog)
	//{{AFX_MSG_MAP(CAppLogDlg)
	ON_BN_CLICKED(IDB_Copy, OnCopy)
	ON_BN_CLICKED(IDB_Clear, OnClear)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CAppLogDlg::OnInitDialog(void)
{
	DWORD ccBuf;

	// call the base class
	CDialog::OnInitDialog();

	// fill in the edit box

	// get the length necessary to store the text
	ccBuf = 0;
	m_pAppLog->Read(m_strAppLog.GetBuffer(0), &ccBuf);

	// get the data from the file
	if (m_pAppLog->Read(m_strAppLog.GetBuffer(ccBuf+1), &ccBuf)) {
		m_strAppLog.ReleaseBuffer();
	}
	else {
		m_strAppLog.ReleaseBuffer(0);
	}

	// refresh the dialog
	UpdateData(FALSE);

	// get a pointer to the edit control
	CEdit* pEdit = (CEdit*)GetDlgItem(IDE_AppLog);

	// REVIEW(briancr): there should be a much better way of doing this,
	// but I don't know what it is
	// scroll the edit control to the last line (SetSel doesn't do it for some reason)
	int nLines = pEdit->GetLineCount();
	// -12 because there are 12 lines displayed in the edit control
	pEdit->LineScroll(nLines-12);
	// position the caret at the end of the text
	int nChar = pEdit->LineIndex(nLines-1);
	pEdit->SetSel(nChar-2, nChar, FALSE);

	// set focus to the edit control
	pEdit->SetFocus();

	// return FALSE (0) because we set focus to a control
	return FALSE;
}

void CAppLogDlg::OnCopy(void)
{
	// put the data in the clipboard
	((CEdit *)GetDlgItem(IDE_AppLog))->Copy();
}

void CAppLogDlg::OnClear(void)
{
	if (AfxMessageBox("Do you want to clear all data from the CAFE application log?", MB_OKCANCEL) == IDOK) {
		// clear the log
		m_pAppLog->Clear();

		m_strAppLog.Empty();

		// refresh the dialog
		UpdateData(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAppLogDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafemdi.cpp ===
// cafemdi.cpp : implementation file
//

#include "stdafx.h"
#include "cafemdi.h"
#include "logview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCafeDrvMDIChild

IMPLEMENT_DYNCREATE(CCafeDrvMDIChild, CMDIChildWnd)

CCafeDrvMDIChild::CCafeDrvMDIChild()
{
}

CCafeDrvMDIChild::~CCafeDrvMDIChild()
{
}


BEGIN_MESSAGE_MAP(CCafeDrvMDIChild, CMDIChildWnd)
	//{{AFX_MSG_MAP(CCafeDrvMDIChild)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCafeDrvMDIChild message handlers

BOOL CCafeDrvMDIChild::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext)
{
	// CG: The following block was added by the Split Bars component.
	if (!m_wndSplitter.CreateStatic(this,
		                          2, 2 ))          // TODO: adjust the number of rows, columns
	//	                          CSize(10, 10), // TODO: adjust the minimum pane size
	//	                          pContext))
		{
			TRACE0("Failed to create split bar ");
			return FALSE;    // failed to create
		}

		// Suite tree pane. 
		if(!m_wndSplitter.CreateView(0,0,pContext->m_pNewViewClass,CSize(190,150),pContext))
		{
			return FALSE ;
		}
		// ConsoleViewPort pane; Use the viewport document
		if(!m_wndSplitter.CreateView(0,1,RUNTIME_CLASS(CLogView),CSize(190,150),pContext))
		{
			return FALSE ;
		}
		//LogTreeView pane
		if(!m_wndSplitter.CreateView(1,0,RUNTIME_CLASS(CLogView) /*pContext->m_pNewViewClass */,CSize(190,150),pContext))
		{
			return FALSE ;
		}

		//Logview (Text view) pane.
		if(!m_wndSplitter.CreateView(1,1,RUNTIME_CLASS(CViewportView),CSize(190,150),pContext))
		{
			return FALSE ;
		}
		return TRUE;
}


BOOL CCafeDrvMDIChild::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	BOOL ret = CMDIChildWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, pContext);
	MDIMaximize() ;
	return ret; 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafedrv.h ===
///////////////////////////////////////////////////////////////////////////////
//  CAFEDrv.H
//
//  Created by :            Date :
//      DavidGa                 8/13/93
//
//  Description :
//      Declaration of the CCAFEDriver class
//

#ifndef __CAFEDRV_H__
#define __CAFEDRV_H__

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "settings.h"
#include "target.h"
#include "toolset.h"
#include "mainfrm.h"
#include "portview.h"
#include "hotkey.h"

#include "caferes.h"

#define theApp (*((CCAFEDriver*) AfxGetApp()))

///////////////////////////////////////////////////////////////////////////////
// CCAFEDriver class

class CSuiteDoc;

class CCAFEDriver : public CWinApp
{
// data types
public:

  enum ClientRegion { Suite, Log, Console };

public:
    CCAFEDriver();
    ~CCAFEDriver();

// CWinApp Overrides
public:
    virtual BOOL InitInstance();
    virtual int Run();
    virtual int ExitInstance();
//  virtual BOOL OnIdle(LONG lCount);

// commands
public:
    CViewportDoc* NewViewport(void);
    void ErrorMsg(UINT nIDPrompt, ...);

	void ErrorMsg(LPCSTR szMsg, ...);
	void Message(LPCSTR szMsg, ...);

// operations
public:
//  CToolset* GetToolset(void)                      { ASSERT(m_pToolset); return m_pToolset; }
    CSettings* GetSettings(void)                    { ASSERT(m_pstngCAFEDrv); return m_pstngCAFEDrv; }
    CSettings* GetLogSettings(void)                 { ASSERT(m_pstngLog); return m_pstngLog; }
    CSettings* GetCmdLine(void)                     { ASSERT(m_pstngCmdLine); return m_pstngCmdLine; }
	//in case we don't have a StepWnd (ie -hotkey_thread:false)
	CWnd* GetStepWnd(void)						{ return ((m_bHotKey) ? m_pthreadHotKey->GetHKWnd() : NULL); }

    CToolset* NewToolset(HANDLE hOutput);
    BOOL DeleteToolset(CToolset* pToolset);
	HICON  hIfail, hIpass ;

	BOOL IsOnWin95(void)							{ return m_bOnWin95; }

    LPCSTR GetDriverDir(void)                       { ASSERT(!m_strDriverDir.IsEmpty()); return m_strDriverDir; }
  BOOL DocToRegion(CDocument *pDoc, ClientRegion eRegion);
  void CallRunSuite(CSuiteDoc *pSuiteDoc);

  CPlatform *CreateCurrentPlatform(void); // NOTE: you're responsible for freeing the resulting ptr
    CSettings* ReadCmdLineSwitches(CString strCmdLine);

protected:
    BOOL GetNextSwitch(CString &strCmdLine, CString &strSwitch, CString &strValue);
    CSettings* InitCAFEDrvSettings(void);
    CSettings* InitLogSettings(void);
    BOOL InitWndSettings(void);
    CSettings* InitSingleStepSettings(void);
  BOOL MoveToRegion(CWnd *pWnd, ClientRegion eRegion);

	BOOL DeleteKey(LPCSTR pszKeyName);
	void DeleteSubKeys(HKEY hKey);

private:
    void LoadProfileSettings(void);
    void SaveProfileSettings(void);
    
// data
private:    
    CSettings* m_pstngCmdLine;
    CSettings* m_pstngCAFEDrv;
    CSettings* m_pstngLog;
    CSettings* m_pstngSingleStep;

	BOOL	m_bHotKey;

    CString m_strDriverDir;
    CString m_strWorkingDir;

    CString m_strHelpFile;

    // key name
    CString m_strKeyName;

  CSuiteDoc *m_pExecutingSuite;
  HANDLE m_hSuiteReadyEvent, m_hTerminationEvent;

	BOOL m_bOnWin95;

    // REVIEW(briancr): in order to use the old single step window, I've added this code
    CHotKeyThread* m_pthreadHotKey;
    CWinThread* m_threadSuite;

	HANDLE m_hmutexStartup; //mutex to restrict the instances of DRV, CMD, MON

    UINT m_idLagTimer;      // Lag timer ID.

    void DoOnFileNew(void) { OnFileNew(); }

// Attributes
public:
    inline CMainFrame* GetMainFrame(void) { return (CMainFrame*)m_pMainWnd; }

protected:

  unsigned long SuiteExecutionLoop(void);
  static UINT WrapSuiteExecutionLoop(void *pThis) { return ((CCAFEDriver*)pThis)->SuiteExecutionLoop(); }

// Generated message map functions
protected:
    //{{AFX_MSG(CCAFEDriver)
    afx_msg void OnAppAbout();
    afx_msg void OnOptionsSingleStep();
    afx_msg void OnUpdateOptionsSingleStep(CCmdUI* pCmdUI);
    afx_msg void OnOptionsBreakStep();
    afx_msg void OnOptionsToolset();
    afx_msg void OnViewLog();
    afx_msg void OnOptionSave(); //REVIEW(chriskoz) TEMP: hooked up the machine name. only a proof of concept
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// GetTestDriver() macro

#define GetTestDriver()     ((CCAFEDriver*)AfxGetApp())

///////////////////////////////////////////////////////////////////////////////
// this class and function are used for slowing down the suite thread

// the address of a global object of this clas is passed to the timer function (pslow_info).
// this object is declared in cafedrv.cpp and initialized in CCAFEDriver::InitInstance() after
// the suite thread is created.

class SlowSuiteInfo
    {
    public:
		HANDLE m_hthread;
//        CWinThread *m_pSuiteThread;     // the testing thread
        int m_delay;                    // how long to delay it
    };

// this is the timer function which periodically suspends the suite thread for a user-supplied
// amount of time, and then resumes it.
void CALLBACK SlowSuiteTimeProc(UINT IDEvent, UINT uRsrv, DWORD pslow_info, DWORD dwRsrv1, DWORD dwRsrv2);

/////////////////////////////////////////////////////////////////////////////
// CStepBreak dialog
class CStepBreak : public CDialog
{
// Construction
public:
	CStepBreak(int CurrentStep,CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CStepBreak)
	enum { IDD = IDD_StepBreak };
	int		m_iStepNumber;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStepBreak)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CStepBreak)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__CAFEDRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafedrv.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  CAFEDrv.CPP
//
//  Created by :            Date :
//      DavidGa                 8/13/93
//
//  Description :
//      Implementation of the CCAFEDriver class
//

#include "stdafx.h"
#include "caferes.h"
#include "cafepage.h"
#include "logpage.h"
#include "suitedoc.h"
#include "suitevw.h"
#include "aplogdlg.h"
#include "cafedrv.h"
#include "mmsystem.h"
#include "cafemdi.h"



#include "logview.h"


#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
//CViewportView * vConsole, * vTextLog ;
// REVIEW(briancr): provided only for backward compatibility
extern AFX_EXT_DATA CSettings* gpsettingsCmdLine;

// the address of this object is passed to a timer function used to slow down the suite thread
SlowSuiteInfo slow_info;

/////////////////////////////////////////////////////////////////////////////
// The one and only CCAFEDriver object

CCAFEDriver CAFEApp;

/////////////////////////////////////////////////////////////////////////////
// CCAFEDriver

BEGIN_MESSAGE_MAP(CCAFEDriver, CWinApp)
    //{{AFX_MSG_MAP(CCAFEDriver)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(IDM_OptionsSingleStep, OnOptionsSingleStep)
    ON_UPDATE_COMMAND_UI(IDM_OptionsSingleStep, OnUpdateOptionsSingleStep)
    ON_COMMAND(IDM_OptionsBreakStep, OnOptionsBreakStep)
    ON_COMMAND(IDM_OptionsToolset, OnOptionsToolset)
    ON_COMMAND(IDM_FileViewLog, OnViewLog)
	ON_COMMAND(IDM_OptionsSave,OnOptionSave) //REVIEW(chriskoz) TEMP: hooked up the machine name. only a proof of concept

    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCAFEDriver construction

CCAFEDriver::CCAFEDriver()
{
    char szDriverFileName[MAX_PATH];
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];

    m_pMainWnd = NULL;
    // store the starting directory
    ::GetModuleFileName(::GetModuleHandle(NULL), szDriverFileName, MAX_PATH);
    _splitpath(szDriverFileName, szDrive, szDir, NULL, NULL);
    m_strDriverDir = CString(szDrive) + CString(szDir);
    ::GetCurrentDirectory(MAX_PATH, m_strWorkingDir.GetBuffer(MAX_PATH));
    m_strWorkingDir.ReleaseBuffer();
    m_strWorkingDir += '\\';

    // build the help filename
    m_strHelpFile = m_strDriverDir + "cafe.hlp";

    // tell MFC the name of our help file
    m_pszHelpFilePath = (LPCTSTR)_tcsdup(m_strHelpFile);

    m_idLagTimer = 0;
	m_bHotKey = TRUE;

	// determine whether we're on Win95 or not
	DWORD dwVersion = ::GetVersion();
	m_bOnWin95 = (dwVersion & 0x80000000) && (LOBYTE(dwVersion) > 3);
}

CCAFEDriver::~CCAFEDriver()
{
    if(m_pMainWnd != NULL)
        delete m_pMainWnd;

    // delete settings objects
    if (gpsettingsCmdLine) {
        delete gpsettingsCmdLine;
		gpsettingsCmdLine=NULL;
    }
    if (m_pstngCAFEDrv) {
        delete m_pstngCAFEDrv;
    }
    if (m_pstngLog) {
        delete m_pstngLog;
    }
    if (m_pstngSingleStep) {
        delete m_pstngSingleStep;
    }

/*
    // delete toolset
    if (m_pToolset) {
        delete m_pToolset;
    }
*/
}

/////////////////////////////////////////////////////////////////////////////
// CCAFEDriver initialization
//REVIEW(this method of restricting to single instance was replaced by a mutex
//#pragma data_seg("Share")
//LONG g_CAFERunning=-1;
//#pragma data_seg()
//#pragma comment(linker, "-section:Share,RWS")
//BOOL bFirstInstance=0;

BOOL CCAFEDriver::InitInstance()
{
#if 0 //old method, not recommended
	bFirstInstance=(::InterlockedIncrement(&g_CAFERunning)==0);
	if(!bFirstInstance)
	{
		::AfxMessageBox("CAFE is running. OK to switch focus");
		HWND hTopwnd=::GetTopWindow(NULL);
		char szFound[81];
		while(hTopwnd!=NULL)
		{
			::GetWindowText(hTopwnd, szFound, 80);
			if(strstr(szFound,m_pszAppName)!=NULL) //found the window "CAFE v6"
			{
				if(::IsIconic(hTopwnd))
					::OpenIcon(hTopwnd);
				::SetForegroundWindow(hTopwnd);
				::BringWindowToTop(hTopwnd);
				break;
			}
			hTopwnd=::GetNextWindow(hTopwnd,GW_HWNDNEXT);
		}
		::InterlockedDecrement(&g_CAFERunning);
		return FALSE;
	}
#else
	m_hmutexStartup = CreateMutex(NULL, FALSE, STARTUPMUTEXNAME);
	ASSERT(m_hmutexStartup);
	// Grab the mutex without waiting.  If we fail because another copy of
	// CAFEDRV, CAFEMON, CAFECMD has the mutex, then exit.
	if (WaitForSingleObject(m_hmutexStartup, 0) != WAIT_OBJECT_0)
	{
		CloseHandle(m_hmutexStartup);
		::AfxMessageBox("Other instance of CAFE is running. Please close all types of drivers.");
		m_hmutexStartup=NULL;
		return FALSE;
	}
#endif
    LPCSTR pszBanner1 = "=========================================";
    LPCSTR pszBanner2 = "== CAFE Driver -- %s -- %s ==";
    char acTime[10];
    char acDate[10];

    // emit banner to the app log
    APPLOG(pszBanner1);
    _strtime(acTime);
    _strdate(acDate);
    APPLOG(pszBanner2, acTime, acDate);
	APPLOG("== Process ID: %x", GetCurrentProcessId());
	APPLOG("== Process Handle: %x", GetCurrentProcess());
    APPLOG(pszBanner1);

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit())
    {
	AfxMessageBox(IDP_OLE_INIT_FAILED);
	return FALSE;
    }

    Enable3dControls();
	// Load the icons for the tree view.
	hIfail = AfxGetApp() ->LoadIcon( IDI_FAILED) ;
	hIpass = AfxGetApp() ->LoadIcon( IDI_PASS) ;

    // read the command line
    m_pstngCmdLine = ReadCmdLineSwitches(m_lpCmdLine);
    // REVIEW(briancr): initialize the global cmd line settings object in the support system
    // this is for backward compatibility
    gpsettingsCmdLine = m_pstngCmdLine;

    // initialize the driver settings
    m_pstngCAFEDrv = InitCAFEDrvSettings();
    m_strKeyName = m_pstngCAFEDrv->GetTextValue(settingCAFEKey);

	// did the user specify that CAFE's key should be deleted (-newkey)?
	if (m_pstngCmdLine->GetBooleanValue(settingNewKey)) {
		// delete CAFE's key
		DeleteKey(m_strKeyName);
	}

    // tell MFC the name of the registry key
    SetRegistryKey("Microsoft");
    m_pszProfileName = (LPCSTR)_tcsdup(m_strKeyName);

    // load standard settings from the registry
    // and enable the MRU list
    LoadStdProfileSettings(16);

    // initialize the log settings
    m_pstngLog = InitLogSettings();

    // initialize the single step settings
    m_pstngSingleStep = InitSingleStepSettings();

    // add test collection doc/view to the document template
    CMultiDocTemplate* pmdtSuite = new CMultiDocTemplate(IDR_SUITETYPE, RUNTIME_CLASS(CSuiteDoc), RUNTIME_CLASS(CCafeDrvMDIChild), RUNTIME_CLASS(CSuiteView));
    AddDocTemplate(pmdtSuite);
    // add subsuite doc/view to the document template
	CMultiDocTemplate* pmdtDLL = new CMultiDocTemplate(IDR_DLLTYPE, RUNTIME_CLASS(CSuiteDoc), RUNTIME_CLASS(CCafeDrvMDIChild), RUNTIME_CLASS(CSuiteView));
	AddDocTemplate(pmdtDLL);

 // add viewport doc/view to the document template
	CMultiDocTemplate* pmdtLogDoc = new CMultiDocTemplate(IDR_PORTTYPE, RUNTIME_CLASS(CViewportDoc), RUNTIME_CLASS(CMDIChildWnd),RUNTIME_CLASS( CLogView));
	AddDocTemplate(pmdtLogDoc);	 

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;

    pMainFrame->ShowWindow(m_nCmdShow);
    m_pMainWnd = pMainFrame;

	// open .agn file or prompt user to open one
//      OnFileOpen();

    // REVIEW(briancr): in order to use the old single step window, I've added this code
	m_bHotKey = m_pstngCmdLine->GetBooleanValue("hotkey_thread", TRUE);  //disable StepWnd (ie -hotkey_thread:false)
	if (m_bHotKey) //is StepWnd disabled? (ie -hotkey_thread:false)
	{
		m_pthreadHotKey = (CHotKeyThread*)AfxBeginThread(RUNTIME_CLASS(CHotKeyThread), NULL);
		m_pthreadHotKey->m_bAutoDelete = FALSE;
	}

    m_hSuiteReadyEvent = CreateEvent(
    0, // security attributes
    TRUE, // manual reset; we have to call ResetEvent()
    FALSE, // nonsignaled initially
    0);  // make it anonymous

    m_hTerminationEvent = CreateEvent(
    0, // security attributes
    TRUE, // manual reset; we have to call ResetEvent()
    FALSE, // nonsignaled initially
    0);  // make it anonymous

	// start the thread that will run the suites
	m_threadSuite = AfxBeginThread(WrapSuiteExecutionLoop, this);
	m_threadSuite->m_bAutoDelete = FALSE;
	// verify that the thread was created
	if (m_threadSuite == NULL) {
		ErrorMsg("Unable to create the thread that runs the suite. GetLastError = %d. Terminating.", ::GetLastError());
		::PostQuitMessage(2);
	}

    // set up timer to slow down execution of suite thread
	slow_info.m_hthread = m_threadSuite->m_hThread;
    slow_info.m_delay = m_pstngCmdLine->GetIntValue("delay", 0);
    int period = m_pstngCmdLine->GetIntValue("period", 50);

    if(slow_info.m_delay)
    {
        APPLOG("Setting up lag timer.  period = %d, delay = %d", period, slow_info.m_delay);
        VERIFY(timeBeginPeriod(10)!= TIMERR_NOCANDO);
        VERIFY(m_idLagTimer = timeSetEvent(period, 0, SlowSuiteTimeProc, (DWORD)&slow_info, TIME_PERIODIC));
        if (m_idLagTimer == NULL)
            APPLOG("Couldn't create the lag timer.");
    }

    return TRUE;
}

int CCAFEDriver::Run()
{
    CSuiteDoc* pDoc = NULL;

    // open the stf file the user specified on the cmd line
    if (m_pstngCmdLine->IsDefined(settingSTFFile)) {
        pDoc = (CSuiteDoc*)OpenDocumentFile(m_pstngCmdLine->GetTextValue(settingSTFFile));
    }

    // if -run is specified, -stf must be specified as well
    if (m_pstngCmdLine->GetBooleanValue(settingRun)) {
        if (pDoc) {
            pDoc->Run();
        }
        else {
            AfxMessageBox("No STF file specified with -run.");
        }
    }

    // call the base class
    return CWinApp::Run();
}

/*  ExitInstance
 *      We want WinMain to return the number of failed tests, so that zero
 *      means "Everything Passed", >0 means "something failed", and <0 is
 *      undefined.
 *      The code below can thus return an error code in one of two senses:
 *      If CWinApp::ExitInstance != 0, then we return that.  Otherwise, we
 *      return our own number of failed tests.
 */
int CCAFEDriver::ExitInstance()
{
	if(m_hmutexStartup==NULL) //not the first instance - nothing was initialized whan failed to grab STARTUPMUTEXTNAME
	{
	    CWinApp::ExitInstance();
		return 0;
	}
	const char* const THIS_FUNCTION = "CCAFEDriver::ExitInstance";
	DWORD dwExitCode;

    // Kill the lag timer so that after we end the thread there's no
    // chance that the timer function will get called and try to
    // suspend the defunct m_pSuiteThread.
	if (m_idLagTimer != NULL)
	{
		timeKillEvent(m_idLagTimer);
		timeEndPeriod(10);
	}

    // Make sure the suite thread get's aborted if it's still running.  Originally
    // tried to do a fancier wait for the thread to end by first signalling the
    // g_hUserAbort event, but this event only triggers a test exception, and seems to
    // allow the subsuite to keep running.  I (JG) didn't have time to look into it
    // further, so I decided to just bite the bullet and terminate the thread right
    // here.  Review at some time in the future for a cleaner method of ending this
    // thread.
    
	// tell the suite thread to terminate
	SetEvent(m_hTerminationEvent);  // for our worker thread
	// wait for the suite thread to terminate
	if (m_threadSuite) //is m_threadSuite created?
	{
	if (WaitForSingleObject(m_threadSuite->m_hThread, 500) != WAIT_OBJECT_0) {
		TRACE("%s: timeout waiting for the suite thread to terminate.\n", THIS_FUNCTION);

		// if the suite thread is still running, terminate it
		GetExitCodeThread(m_threadSuite->m_hThread, &dwExitCode);
		if (dwExitCode == STILL_ACTIVE)
		{
			APPLOG("%s: Forcing termination of suite thread (%lx)...", THIS_FUNCTION, m_threadSuite->m_nThreadID);
			TerminateThread(m_threadSuite->m_hThread, DWORD(-1));
		}
	}
	delete m_threadSuite;
	}

	if (m_bHotKey) //is StepWnd disabled? (ie -hotkey_thread:false)
	{
		// close the hot key window
		m_pthreadHotKey->GetHKWnd()->SendMessage(WM_CLOSE);

		// wait for the thread to terminate
		if (WaitForSingleObject(m_pthreadHotKey->m_hThread, 500) != WAIT_OBJECT_0) {
			TRACE("%s: timeout waiting for the hot key thread to terminate.\n", THIS_FUNCTION);

			// Make sure the hotkey thread get's aborted if it's still running.
			GetExitCodeThread(m_pthreadHotKey->m_hThread, &dwExitCode);
			if (dwExitCode == STILL_ACTIVE)
			{
				APPLOG("%s: Forcing termination of hot key thread (%lx)...", THIS_FUNCTION, m_pthreadHotKey->m_nThreadID);
				TerminateThread(m_pthreadHotKey->m_hThread, DWORD(-1));
			}
		}
	
	    delete m_pthreadHotKey;

	}

    ::CloseHandle(m_hSuiteReadyEvent);
    ::CloseHandle(m_hTerminationEvent);
#if 0 //REVIEW(chriskoz) - forget about pupil.don, we've abandoned TP3 plans
    // write out pupil.don file for TP/3
    // REVIEW(briancr): for now we'll always write out a 0 (which means done)
    CStdioFile file;
    if (file.Open(m_strWorkingDir + "pupil.don", CFile::modeCreate | CFile::modeWrite | CFile::typeText)) {
        file.WriteString("0");
        file.Close();
    }
#endif
    CWinApp::ExitInstance();

	SaveStdProfileSettings();
    if (gpsettingsCmdLine) {
		delete gpsettingsCmdLine;
		gpsettingsCmdLine=NULL;
    }
	ReleaseMutex(m_hmutexStartup);
	CloseHandle(m_hmutexStartup);
	APPLOG("Exiting %s", THIS_FUNCTION);
    return 0;
}

/*
BOOL CCAFEDriver::OnIdle(LONG lCount)
{
    POSITION pos;
    CMultiDocTemplate* pTemplate;
    CViewportDoc* pDoc;
    CString strDocName;

    // call the base class
    if (!CWinApp::OnIdle(lCount)) {

        // when the base class finishes doing idle time processing,
        // we'll do ours

        // find the template for viewport doc/views
        for (pos = m_templateList.GetHeadPosition(); pos != NULL; ) {

            // get an element from the template list
            pTemplate = (CMultiDocTemplate*)m_templateList.GetNext(pos);

            // is it the viewport template
            // REVIEW(briancr): can we get "Viewport" from the string table?
            pTemplate->GetDocString(strDocName, CDocTemplate::docName);
            if (strDocName == "Viewport") {
                break;
            }
        }

        // iterate through all viewport documents and update their views
        for (pos = pTemplate->GetFirstDocPosition(); pos != NULL; ) {
            pDoc = (CViewportDoc*)pTemplate->GetNextDoc(pos);

            // update this doc's view
            pDoc->UpdateViews();
        }
    }

    return TRUE;
}
*/


///////////////////////////////////////////////////////////////////////////////
// Operations


///////////////////////////////////////////////////////////////////////////////
// CCAFEDriver commands

CViewportDoc* CCAFEDriver::NewViewport(void)
{
    CMultiDocTemplate *pTemplate;
    CString strDocName;

    // iterate through the template list until the viewport template is found
    for (POSITION pos = GetFirstDocTemplatePosition(); pos != NULL; ) {
        // get an element from the template list
        pTemplate = (CMultiDocTemplate*)GetNextDocTemplate(pos);

        // is it the viewport template
        // REVIEW(briancr): can we get "Viewport" from the string table?
        pTemplate->GetDocString(strDocName, CDocTemplate::docName);
        if (strDocName == "Viewport") {
		return (CViewportDoc*)pTemplate->CreateNewDocument( );

//		return (CViewportDoc*)pTemplate->OpenDocumentFile (NULL);
        }

    }

    // we should *always* find the viewport doc template
    ASSERT(0);
    return NULL;
}


void CCAFEDriver::ErrorMsg(UINT nIDPrompt, ...)
{
    CString strErr;
    CString strPrompt;
    va_list vaMarker;

    // load the prompt string from the resource
    strPrompt.LoadString(nIDPrompt);

    // point to the first var arg
    va_start(vaMarker, nIDPrompt);
    // printf into strErr
    _vsnprintf(strErr.GetBuffer(1023), 1023, strPrompt, vaMarker);
    strErr.ReleaseBuffer();
    // reset the var arg pointer
    va_end(vaMarker);

    // display the error
    AfxMessageBox(strErr);
}

void CCAFEDriver::ErrorMsg(LPCSTR szMsg, ...)
{
	const int cBuf = 1000;
	char aBuf[cBuf];
    va_list vaMarker;

    // point to the first var arg
    va_start(vaMarker, szMsg);
    // printf into strErr
    _vsnprintf(aBuf, cBuf, szMsg, vaMarker);
    // reset the var arg pointer
    va_end(vaMarker);

	// write the message to the app log
	APPLOG("CAFE Driver error: %s", aBuf);

	// if we're not in automated mode, display the error
    if (!m_pstngCmdLine->GetBooleanValue(settingRun, FALSE)) {
		AfxMessageBox(aBuf, MB_ICONEXCLAMATION | MB_OK);
	}
}

void CCAFEDriver::Message(LPCSTR szMsg, ...)
{
	const int cBuf = 1000;
	char aBuf[cBuf];
    va_list vaMarker;

    // point to the first var arg
    va_start(vaMarker, szMsg);
    // printf into strErr
    _vsnprintf(aBuf, cBuf, szMsg, vaMarker);
    // reset the var arg pointer
    va_end(vaMarker);

	// write the message to the app log
	APPLOG("CAFE Driver message: %s", aBuf);

	// if we're not in automated mode, display the error
    if (!m_pstngCmdLine->GetBooleanValue(settingRun, FALSE)) {
		AfxMessageBox(aBuf, MB_ICONINFORMATION | MB_OK);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCAFEDriver commands

/*
int CCAFEDriver::GetSysLangOffset(void)
{
    if( GetSystem() & SYSTEM_JAPAN )
        return LANG_JAPAN;
    else if( GetSystem() & SYSTEM_DBCS )
        return 0;   // TODO - other DBCS languages
    else
        return 0;
}
*/



void CCAFEDriver::OnAppAbout()
{
    CDialog dlg(IDD_ABOUTBOX);
    dlg.DoModal();
}


CToolset* CCAFEDriver::NewToolset(HANDLE hOutput)
{
    CString strToolset;
    CToolset* pToolset;

    strToolset = m_pstngCAFEDrv->GetTextValue(settingPlatform);

    // COMPATIBILITY(briancr): for backward compatibility, we must put the currently
    // selected toolset on the command line so that the COConnection stuff will know
    // what the currently selected toolset/platform is.
    m_pstngCmdLine->SetTextValue(settingPlatform, strToolset);

    CPlatform::COS *pOS;
    CPlatform::CLanguage *pLang;

    pOS = GetOSFromShortName(strToolset);
    pLang = GetLangFromName(m_pstngCAFEDrv->GetTextValue(settingLanguage));

    pToolset = CreateToolset(pOS, pLang, m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);

#if 0
    // figure out which toolset we want and instantiate it
    if (strToolset.CompareNoCase("mac_68k") == 0)
        pToolset = new C68KTools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
    else if (strToolset.CompareNoCase("mac_ppc") == 0) 
		pToolset = new CPMacTools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
    else if (strToolset.CompareNoCase("win32_mips") == 0) 
        pToolset = new CMIPSTools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
    else if (strToolset.CompareNoCase("win32_alpha") == 0)
        pToolset = new CAlphaTools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
    else if (strToolset.CompareNoCase("win32_ppc") == 0)
		pToolset = new CPowerPCTools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
    else if (strToolset.CompareNoCase("win32s_x86") == 0)
		pToolset = new CWin32sTools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
	else
		pToolset = new CX86Tools(m_pstngCAFEDrv->GetBooleanValue(settingDebugBuild)? CToolset::Debug : CToolset::Retail, hOutput);
#endif


    // initialize the toolset
    pToolset->Initialize(m_pstngCAFEDrv->GetTextValue(settingCAFEKey));

    // apply the command line to this toolset
    pToolset->ApplySettings(m_pstngCmdLine);

    // apply CAFEDrv settings to this toolset
    // REVIEW(briancr): actually we're only interested in the settingDebugBuild and settingLanguage settings
    // we could build a settings object that contains this subset and apply that...
    pToolset->ApplySettings(m_pstngCAFEDrv);

#if 0

    // set the language in the toolset
    if (m_pstngCAFEDrv->GetTextValue(settingLanguage) == "English")
        pToolset->SetLanguage(CToolset::TL_ENGLISH);
    else if (m_pstngCAFEDrv->GetTextValue(settingLanguage) == "German")
        pToolset->SetLanguage(CToolset::TL_GERMAN);
    else if (m_pstngCAFEDrv->GetTextValue(settingLanguage) == "Japanese")
        pToolset->SetLanguage(CToolset::TL_JAPANESE);

#endif

    return pToolset;
}

BOOL CCAFEDriver::DeleteToolset(CToolset* pToolset)
{
    // the toolset must not be NULL
    ASSERT(pToolset);
    if (!pToolset) {
        return FALSE;
    }

    delete pToolset;

    return TRUE;
}

/*
BOOL CCAFEDriver::ChangeToolset(CString strToolset)
{
    // the toolset name must not be empty
    ASSERT(!strToolset.IsEmpty());

    // if we've already instantiated a toolset, delete it
    if (m_pToolset) {
        delete m_pToolset;
    }

    // figure out which toolset we want and instantiate it
    if (strToolset.CompareNoCase("mac_68k") == 0) {
        m_pToolset = new C68KTools;
    }
    else {
        if (strToolset.CompareNoCase("mac_ppc") == 0) {
            m_pToolset = new CPMacTools;
        }
        else {
            if (strToolset.CompareNoCase("win32_mips") == 0) {
                m_pToolset = new CMIPSTools;
            }
            else {
                m_pToolset = new CX86Tools;
            }
        }
    }

    // initialize the toolset
    m_pToolset->Initialize(m_pstngCAFEDrv->GetTextValue(settingCAFEKey));

    // apply the command line to this toolset
    m_pToolset->ApplySettings(m_pstngCmdLine);

    return TRUE;
}
*/

CSettings* CCAFEDriver::InitCAFEDrvSettings(void)
{
    CSettings* pstngCAFEDrv;
    CString strToolset;

    // there must be a command line settings object
    ASSERT(m_pstngCmdLine);

    // create a settings object for the driver settings
    pstngCAFEDrv = new CSettings(m_pstngCmdLine->GetTextValue(settingCAFEKey, m_pszAppName)); //by default "CAFE v?"

    // set up driver defaults
    pstngCAFEDrv->SetTextValue(settingCAFEKey, m_pstngCmdLine->GetTextValue(settingCAFEKey, m_pszAppName)); //by default "CAFE v?"
    pstngCAFEDrv->SetTextValue(settingPlatform, "Win32_x86");
    pstngCAFEDrv->SetBooleanValue(settingDebugBuild, TRUE);
    pstngCAFEDrv->SetTextValue(settingLanguage, "English");

    // Initialize globals used by CAFE and the tests.
	g_bInfiniteIdleWaits = m_pstngCmdLine->GetBooleanValue(settingInfiniteIdleWaits, FALSE);
	g_nSleepModifier = m_pstngCmdLine->GetIntValue(settingSleep, 100);

    // REVIEW(briancr): in order to use the old single step window, I've added this code
    pstngCAFEDrv->SetBooleanValue(settingDoSingleStep, FALSE);

    // read registry settings for the driver
    pstngCAFEDrv->ReadRegistry();
    // write the settings back out to initialize registry
    pstngCAFEDrv->WriteRegistry();

    // apply command line overrides
    pstngCAFEDrv->SetTextValue(settingPlatform, m_pstngCmdLine->GetTextValue(settingPlatform, pstngCAFEDrv->GetTextValue(settingPlatform)));
    pstngCAFEDrv->SetBooleanValue(settingDebugBuild, m_pstngCmdLine->GetBooleanValue(settingDebugBuild, pstngCAFEDrv->GetBooleanValue(settingDebugBuild)));
    pstngCAFEDrv->SetTextValue(settingLanguage, m_pstngCmdLine->GetTextValue(settingLanguage, pstngCAFEDrv->GetTextValue(settingLanguage)));

    #ifdef _DEBUG
        pstngCAFEDrv->DumpSettings("CAFEDrv settings");
    #endif // _DEBUG

    return pstngCAFEDrv;
}

CSettings* CCAFEDriver::InitLogSettings(void)
{
    CSettings* pstngLog;
    int nMaxFail;
    BOOL bPost;

    // there must be a command line settings object
    ASSERT(m_pstngCmdLine);
    // there must be a CAFEDrv settings object
    ASSERT(m_pstngCAFEDrv);

    // create a settings object for the log settings
    pstngLog = new CSettings(m_pstngCAFEDrv->GetTextValue(settingCAFEKey)+"\\Logging");

    // set up driver defaults
    pstngLog->SetTextValue(settingLogResultsFile, "results.log");
    pstngLog->SetTextValue(settingLogSummaryFile, "summary.log");
    pstngLog->SetTextValue(settingLogWorkDir, ".");
    pstngLog->SetIntValue(settingLogMaxFail, 100);
    pstngLog->SetBooleanValue(settingLogUseCom, FALSE);
    pstngLog->SetTextValue(settingLogCom, "Com1");
    pstngLog->SetTextValue(settingLogBaudRate, "57600");
    pstngLog->SetBooleanValue(settingLogPost, FALSE);
    pstngLog->SetBooleanValue(settingLogComments, FALSE);

    // REVIEW(briancr): any other defaults?

    // read registry settings for the driver
    pstngLog->ReadRegistry();
    // write the settings back out to initialize registry
    pstngLog->WriteRegistry();

    // apply command line overrides

	CString logfile;
	logfile=m_pstngCmdLine->GetTextValue(settingLogResultsFile);
	if(!logfile.IsEmpty())
		pstngLog->SetTextValue(settingLogResultsFile, logfile);
	nMaxFail = m_pstngCmdLine->GetIntValue(settingLogMaxFail);
    if (nMaxFail != 0) {
        pstngLog->SetIntValue(settingLogMaxFail, nMaxFail);
    }
    bPost = m_pstngCmdLine->GetBooleanValue(settingLogPost);
    if (bPost) {
        pstngLog->SetBooleanValue(settingLogPost, bPost);
    }

    #ifdef _DEBUG
        pstngLog->DumpSettings("Log settings");
    #endif // _DEBUG

    return pstngLog;
}

CSettings* CCAFEDriver::InitSingleStepSettings(void)
{
    return NULL;
}

BOOL CCAFEDriver::DocToRegion(CDocument *pDoc, ClientRegion eRegion)
{
  // we just position the first view

  POSITION pos = pDoc->GetFirstViewPosition();

  ASSERT(pos);

  CView *pV = pDoc->GetNextView(pos);

  ASSERT(pV);
  ASSERT(pV -> GetParentFrame());

  if (!MoveToRegion(pV -> GetParentFrame(), eRegion))
    return FALSE;

//  pDoc->UpdateAllViews(NULL);

  return TRUE;
}


BOOL CCAFEDriver::MoveToRegion(CWnd *pWnd, ClientRegion eRegion)
{
  CRect rect;
  int nLeft, nTop, nWidth, nHeight, nMidX, nMidY;

  ::GetClientRect(((CMDIFrameWnd*)m_pMainWnd) -> m_hWndMDIClient, rect);

  nMidX = rect.right >> 2;   // left 1/4
  nMidY = (rect.bottom << 1) / 5;  // top 2/5

  switch(eRegion)
  {
    case Suite:
    {
      nLeft = nTop = 0;
      nWidth = nMidX;
      nHeight = nMidY;
      break;
    }
    case Console:
    {
      nTop = 0;
      nLeft = nMidX;
      nWidth = rect.right - nLeft;
      nHeight = nMidY;
      break;
    }
    case Log:
    {
      nTop = nMidY;
      nLeft = 0;
      nWidth = rect.right;
      nHeight = rect.bottom - nMidY;
      break;
   }
    default:
      return FALSE;
  }

  BOOL bResult = pWnd -> SetWindowPos(0, nLeft, nTop, nWidth, nHeight, SWP_NOZORDER);

  return bResult;
}


BOOL CCAFEDriver::DeleteKey(LPCSTR pszKeyName)
{
	const char* const THIS_FUNCTION = "CCAFEDriver::DeleteKey";
	const char* const pszBaseKey = "Software\\Microsoft\\";
	BOOL bResult = TRUE;
	HKEY hKey;

	APPLOG("Deleting key '%s'.", pszKeyName);
	// open the key, if it exists
	if (RegOpenKeyEx(HKEY_CURRENT_USER, CString(pszBaseKey) + pszKeyName, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
		// delete all the subkeys in this key
		DeleteSubKeys(hKey);
		RegCloseKey(hKey);
		// delete the key itself
		if (RegOpenKeyEx(HKEY_CURRENT_USER, pszBaseKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
			if (RegDeleteKey(hKey, pszKeyName) != ERROR_SUCCESS) {
				TRACE("%s: unable to delete key '%s'.", THIS_FUNCTION, pszKeyName);
				bResult = FALSE;
			}
			RegCloseKey(hKey);
		}
		else {
			TRACE("%s: unable to open key '%s'.", THIS_FUNCTION, pszBaseKey);
			bResult = FALSE;
		}
	}
	else {
		TRACE("%s: unable to open key '%s'.", THIS_FUNCTION, (LPCSTR)(CString(pszBaseKey) + pszKeyName));
		bResult = FALSE;
	}

	return bResult;
}

void CCAFEDriver::DeleteSubKeys(HKEY hKey)
{
	const char* const THIS_FUNCTION = "CCAFEDriver::DeleteSubKeys";

	DWORD iSubKey = 0;
	TCHAR szSubKey[MAX_PATH+1];
	CStringArray* pKeyArray = new CStringArray;

	// build an array of subkeys in this key
	while (RegEnumKey( hKey, iSubKey++, szSubKey, MAX_PATH ) == ERROR_SUCCESS) {
		pKeyArray->Add(szSubKey);
	}

	// iterate through the subkeys in this key
	for (int iCur = 0, iTop = pKeyArray->GetUpperBound(); iCur <= iTop; iCur++) {
		HKEY hSubKey;
		// open the subkey
		if (RegOpenKeyEx(hKey, (*pKeyArray)[iCur], 0, KEY_WRITE | KEY_READ, &hSubKey) == ERROR_SUCCESS) {
			// delete all its subkeys
			DeleteSubKeys(hSubKey);
			RegCloseKey(hSubKey);
		}
		else {
			TRACE("%s: unable to open key '%s'.", THIS_FUNCTION, (LPCSTR)(*pKeyArray)[iCur]);
		}
		// delete the subkey
		if (RegDeleteKey(hKey, (*pKeyArray)[iCur]) != ERROR_SUCCESS) {
			TRACE("%s: unable to delete key '%s'.", THIS_FUNCTION, (LPCSTR)(*pKeyArray)[iCur]);
		}
	}
	delete pKeyArray;
}

// ReadCmdLineSwitches
//
// Description: This function reads the command line and stores switches
// (arguments preceded by '-' or '/') in a CMapStringToString object for later
// retrieval. Switch name case sensitivity is not preserved. Switch value
// case sensitivity is preserved.
//
// Return value: --none--
// Example: sniff.exe -c="-run=false post=true" -run -post:false -logdir=h:\logs
//   This would map in the following manner:
//   C      -> "-run=false post=true"
//   RUN    -> ""
//   POST   -> "false"
//   LOGDIR -> "h:\logs"

CSettings* CCAFEDriver::ReadCmdLineSwitches(CString strCmdLine)
{
    CString strSwitch, strValue;
    CString strCmdLineCopy = strCmdLine;
    CSettings* pstngCmdLine;

    // create a new settings object for the cmd line switches
    pstngCmdLine = new CSettings;

    // just keep getting the next switch until we run out
    while (GetNextSwitch(strCmdLineCopy, strSwitch, strValue)) {
        pstngCmdLine->SetTextValue(strSwitch, strValue);
    }

    #ifdef _DEBUG
        pstngCmdLine->DumpSettings("CmdLine switches");
    #endif // _DEBUG

    return pstngCmdLine;
}

// GetNextSwitch
//
// Description: This function gets the next switch/value pair in the
// given command line
//
// Return value: TRUE if a switch/value pair is found
BOOL CCAFEDriver::GetNextSwitch(CString &strCmdLine, CString &strSwitch, CString &strValue)
{
    int iSwitchBegin;
    int iSwitchLength;
    int iValueBegin;
    int iValueLength;
    int iNextSwitch;

    strSwitch = "";
    strValue = "";

    // find the beginning of the switch
    iSwitchBegin = strCmdLine.FindOneOf("-/");
    // if there is no switch, return FALSE
    if (iSwitchBegin == -1) {
        return FALSE;
    }
    // skip the leading - or / (assume no whitespace)
    iSwitchBegin += 1;

    // get the length of the switch by finding the end relative to the beginning
    iSwitchLength = (strCmdLine.Mid(iSwitchBegin)).FindOneOf(" \t:=");
    // if there is no end of the switch, assume the length of the string
    if (iSwitchLength == -1) {
        iSwitchLength = strCmdLine.GetLength() - iSwitchBegin;
    }

    // find the next switch (length from the beginning of the first switch)
    iNextSwitch = (strCmdLine.Mid(iSwitchBegin)).FindOneOf("-/");
    // if the length to the next switch is less than the length to the end
    // of the first switch, then the switch is improperly defined
    if (iNextSwitch != -1 && iSwitchLength > iNextSwitch) {
        // bad switch, give an error
        // error processing switch "strCmdLine.Mid(0, iNextSwitch)"
        strCmdLine = strCmdLine.Mid(iSwitchBegin + iNextSwitch);
        return TRUE;
    }

    // assign switch
    strSwitch = strCmdLine.Mid(iSwitchBegin, iSwitchLength);
    // remove the switch from the command line
    strCmdLine = strCmdLine.Mid(iSwitchBegin + iSwitchLength);

    // if the length of the remaining string < 2 then there's
    // not enough string left to be a : or = plus a value
    if (strCmdLine.GetLength() < 2) {
        // exit with switch defined
        return TRUE;
    }

    // the value now begins at position 0 (if one exists)
    iValueBegin = 0;

    // is there a value associated with this switch? (value begin == : or =)
    if (strCmdLine.GetAt(iValueBegin) == ':' || strCmdLine.GetAt(iValueBegin) == '=') {

        // skip the : or = (assume no white space)
        iValueBegin += 1;

        // is this a quoted value? (beginning of value == ")
        if (strCmdLine.GetAt(iValueBegin) == '\"') {
            // skip the beginning "
            iValueBegin += 1;
            // length of quoted value is to the next "
            iValueLength = (strCmdLine.Mid(iValueBegin)).Find('\"');
            // if there is no ending quote, assume the end of the string
            if (iValueLength == -1) {
                iValueLength = strCmdLine.GetLength() - iValueBegin;
            }
        }
        // not a quoted value
        else {
            // figure length of value to next <space> or <tab>
            iValueLength = (strCmdLine.Mid(iValueBegin)).FindOneOf(" \t");
            // if there is no ending space or tab, assume the end of the string
            if (iValueLength == -1) {
                iValueLength = strCmdLine.GetLength() - iValueBegin;
            }
        }

        // assign value
        strValue = strCmdLine.Mid(iValueBegin, iValueLength);
        // remove the value from the command line
        strCmdLine = strCmdLine.Mid(iValueBegin + iValueLength);
    }

    return TRUE;
}

void CCAFEDriver::OnOptionsSingleStep()
{
    m_pstngCAFEDrv->SetBooleanValue(settingDoSingleStep, !m_pstngCAFEDrv->GetBooleanValue(settingDoSingleStep));
}

void CCAFEDriver::OnOptionsBreakStep()
{
	CStepBreak dlg(0);
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		if((g_stopStep=dlg.m_iStepNumber)>=0)
			g_hkToDo=HOTKEY_SINGLE; //to force the stepping mode when the break is hit
	}
	else if (nResponse == IDCANCEL)
	{
	}
}


void CCAFEDriver::OnUpdateOptionsSingleStep(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_pstngCAFEDrv->GetBooleanValue(settingDoSingleStep));
}

void CCAFEDriver::OnOptionsToolset()
{
    CToolset* pToolset;

    // instantiate a toolset in order to set options
    pToolset = NewToolset(0);

    // set toolset options
    pToolset->ToolsetOptions();

    DeleteToolset(pToolset);
}

void CCAFEDriver::OnViewLog()
{
    CAppLogDlg dlgAppLog(&applog);

    dlgAppLog.DoModal();
}

void CCAFEDriver::OnOptionSave()
{
	//not implemented in this version (to much work). V6x has implemented
}

void CCAFEDriver::CallRunSuite(CSuiteDoc *pSuiteDoc)
{
  m_pExecutingSuite = pSuiteDoc;
  SetEvent(m_hSuiteReadyEvent);  // notify our thread that we're ready to go
}

unsigned long CCAFEDriver::SuiteExecutionLoop(void)
{
    DWORD dwWait;
    HANDLE ahEvents[] = { m_hSuiteReadyEvent, m_hTerminationEvent };

    for (;;)
    {
        dwWait = WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);

        if (dwWait == WAIT_OBJECT_0)
        {
            // show the single step window if there
			if (m_bHotKey) m_pthreadHotKey->GetHKWnd()->ShowWindow(SW_SHOWNOACTIVATE);
            // run the suite
            m_pExecutingSuite -> RunSuite();
            // hide the single step window if there
			if (m_bHotKey) m_pthreadHotKey->GetHKWnd()->ShowWindow(SW_HIDE);

            ResetEvent(m_hSuiteReadyEvent);
        }
        else
        {
            return 0;
        }
    }
}


void CALLBACK SlowSuiteTimeProc(UINT IDEvent, UINT uRsrv, DWORD pslow_info, DWORD dwRsrv1, DWORD dwRsrv2)
{
    SlowSuiteInfo* pInfo = (SlowSuiteInfo*)pslow_info;

	// suspend the thread
	if (SuspendThread(pInfo->m_hthread) !=0 ) { 
		APPLOG("Unable to suspend the thread to delay it (i.e. suspend count != 0). GetLastError = %d.", ::GetLastError());
	}

    Sleep(pInfo->m_delay);

    // The == 1 checks to make sure the thread was actually suspended and
    // was successfully restarted.
	
	if (ResumeThread(pInfo->m_hthread) != 1) {
		APPLOG("Unable to resume the delayed thread (i.e. suspend count != 1). GetLastError = %d.", ::GetLastError());
	}
}

CPlatform *CCAFEDriver::CreateCurrentPlatform(void) // NOTE: you're responsible for freeing the resulting ptr
{
  CString strOSShortName, strLanguage;

  strOSShortName = m_pstngCAFEDrv->GetTextValue(settingPlatform);
  strLanguage = m_pstngCAFEDrv->GetTextValue(settingLanguage);

  CPlatform::COS *pOS = GetOSFromShortName(strOSShortName);
  CPlatform::CLanguage *pLang = GetLangFromName(strLanguage);

  return new CPlatform(*pOS, *pLang);
}

/////////////////////////////////////////////////////////////////////////////
// CStepBreak dialog

CStepBreak::CStepBreak(int CurrentStep,CWnd* pParent /*=NULL*/)
	: CDialog(CStepBreak::IDD, pParent)
{
	//{{AFX_DATA_INIT(CStepBreak)
	m_iStepNumber = CurrentStep;
	//}}AFX_DATA_INIT
}


void CStepBreak::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStepBreak)
	DDX_Text(pDX, IDC_STEP_NO, m_iStepNumber);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStepBreak, CDialog)
	//{{AFX_MSG_MAP(CStepBreak)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolbarsDlg message handlers

BOOL CStepBreak::OnInitDialog() 
{
	CDialog::OnInitDialog();
	return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafebar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// cafebar.cpp
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Implementation of the CCAFEBar class

#include "stdafx.h"
#include "cafebar.h"
#include "toolset.h"
#include "cafedrv.h"
#include "guiv1.h"
#include "caferes.h"
#include "platform.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAFEBar buttons
static UINT BASED_CODE btnsCAFEBar[] =
{
	ID_FILE_NEW,
	ID_FILE_OPEN,
	ID_FILE_SAVE,
		ID_SEPARATOR,			// space between button combo box
		ID_SEPARATOR,			// toolset combo box
		ID_SEPARATOR,			// space between combo boxes
		ID_SEPARATOR,			// build type combo box
		ID_SEPARATOR,			// space between combo boxes
		ID_SEPARATOR,			// language combo box
		ID_SEPARATOR,			// space between combo box and button
	IDM_OptionsSingleStep,
	IDM_OptionsBreakStep,
		ID_SEPARATOR,
	IDM_FileViewLog,
		ID_SEPARATOR,
	ID_APP_ABOUT,
};

const int ncbSpaceWidth = 12;
const int ncbToolsetWidth = 200;
const int ncbBuildTypeWidth = 100;
const int ncbLanguageWidth = 100;
//const int ncbToolsetDrop = 134;
//const int ncbBuildTypeDrop = 100;
//const int ncbLanguageDrop = 100;

/////////////////////////////////////////////////////////////////////////////
// CCAFEBar

CCAFEBar::~CCAFEBar()
{
	if (m_pfont) {
		delete m_pfont;
	}
	if (m_pcbToolset) {
		delete m_pcbToolset;
	}
	if (m_pcbBuildType) {
		delete m_pcbBuildType;
	}
	if (m_pcbLanguage) {
		delete m_pcbLanguage;
	}
}

BOOL CCAFEBar::CreateBar(CWnd* pParent)
{
	// set the font for the combo boxes
	m_pfont = CreateFont();

	// create the toolbar
	if (!Create(pParent, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_TOOLTIPS | CBRS_FLYBY, IDT_CAFEBar) ||
			!LoadBitmap(IDB_CAFEBAR) ||
			!SetButtons(btnsCAFEBar, sizeof(btnsCAFEBar)/sizeof(UINT))) {
		TRACE("CCAFEBar::CreateBar: Failed to create CAFEBar\n");
		return FALSE;       // fail to create
	}

	// create the platform combo box
	m_pcbToolset = CreateToolsetCombo(4);

	// create the target type combo box
	m_pcbBuildType = CreateBuildTypeCombo(6);

	// create the language combo box
	m_pcbLanguage = CreateLanguageCombo(8);

	// select the appropriate item in each combo box
	SelectToolset();
	SelectBuildType();
	SelectLanguage();

	// make the toolbar dockable
	EnableDocking(CBRS_ALIGN_ANY);

	// set the title
	SetWindowText("Standard");

	return TRUE;
}

// select the correct toolset in the toolset combo box
BOOL CCAFEBar::SelectToolset(void)
{
	CString strToolset;
	int i;

	// the toolset combo must be valid
	ASSERT(m_pcbToolset);

	// get the current toolset
	strToolset = m_pSettings->GetTextValue(settingPlatform);
	gplatformStr = strToolset;

	// find the toolset

  const CPlatform::COSArray *paryOS = CPlatform::GetOSArray();
  int nSize = paryOS->GetSize();

	for (i = 0; i < nSize; i++) 
  {
		if (strToolset.CompareNoCase(paryOS->GetAt(i)->GetShortName()) == 0)
    {
			// select this toolset
			m_pcbToolset->SetCurSel(i);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CCAFEBar::UpdateToolset(void)
{
	int nToolset;
	CString strToolset;
	int i;

	// the toolset combo must be valid
	ASSERT(m_pcbToolset);

	// get the currently selected string in the toolset combo box
	nToolset = m_pcbToolset->GetCurSel();

	// get the text of the currently selected combo box item
	m_pcbToolset->GetLBText(nToolset, strToolset);

	// find which string this is

  const CPlatform::COSArray *paryOS = CPlatform::GetOSArray();
  int nSize = paryOS->GetSize();

	for (i = 0; i < nSize; i++) 
  {
		if (strToolset == paryOS->GetAt(i)->GetName()) 
    {
			// change toolsets
			m_pSettings->SetTextValue(settingPlatform, paryOS->GetAt(i)->GetShortName());
			gplatformStr = paryOS->GetAt(i)->GetShortName();
			return TRUE;
		}
	}
	
	return FALSE;
}

BOOL CCAFEBar::SelectBuildType(void)
{
	// the build type combo must be valid
	ASSERT(m_pcbBuildType);

	// select the build type
	m_pcbBuildType->SetCurSel(1 - m_pSettings->GetBooleanValue(settingDebugBuild));

	return TRUE;
}

BOOL CCAFEBar::UpdateBuildType(void)
{
	int nBuildType;
	CString strBuildType;
	int i;

	// the build type combo must be valid
	ASSERT(m_pcbBuildType);

	// get the currently selected string in the toolset combo box
	nBuildType = m_pcbBuildType->GetCurSel();

	// get the text of the currently selected combo box item
	m_pcbBuildType->GetLBText(nBuildType, strBuildType);

	// find which string this is
	for (i = 0; !CToolset::m_strBuildType[i].IsEmpty(); i++) {
		if (strBuildType == CToolset::m_strBuildType[i]) {
			m_pSettings->SetBooleanValue(settingDebugBuild, 1-i);

			return TRUE;
		}
	}
	return FALSE;
}

BOOL CCAFEBar::SelectLanguage(void)
{
	CString strLanguage;
	int i;

	// the language combo must be valid
	ASSERT(m_pcbLanguage);

	// get the current language
	strLanguage = m_pSettings->GetTextValue(settingLanguage);

	// find the language

  const CPlatform::CLangArray *paryLang = CPlatform::GetLangArray();
  int nSize = paryLang->GetSize();

	for (i = 0; i < nSize; i++) 
  {
		if (strLanguage.CompareNoCase(paryLang->GetAt(i)->GetName()) == 0)
    {
			// select this language
			m_pcbLanguage->SetCurSel(i);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CCAFEBar::UpdateLanguage(void)
{
	int nLanguage;
	CString strLanguage;

	// the language combo must be valid
	ASSERT(m_pcbLanguage);

	// get the currently selected string in the toolset combo box
	nLanguage = m_pcbLanguage->GetCurSel();

	// get the text of the currently selected combo box item
	m_pcbLanguage->GetLBText(nLanguage, strLanguage);

	// store the language setting
	m_pSettings->SetTextValue(settingLanguage, strLanguage);

	return TRUE;
}


CFont* CCAFEBar::CreateFont(void)
{
	LOGFONT lf;
	CFont* pfont;
	CString strDefaultFont;

	// clear out the logfont memory
	memset(&lf, 0, sizeof(lf));

	// create a new font object
	pfont = new CFont;

	// is this a DBCS OS?
	if (!::GetSystemMetrics(SM_DBCSENABLED)) {
		// Since design guide says toolbars are fixed height so is the font.
		lf.lfHeight = -12;
		lf.lfWeight = FW_BOLD;
		lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
		strDefaultFont.LoadString(IDS_TOOLBAR_FONT);
		lstrcpy(lf.lfFaceName, strDefaultFont);
		if (!pfont->CreateFontIndirect(&lf)) {
			TRACE("CCAFEBar::GetFont: could not create font for CCAFEBar\n");
		}
	}
	else {
		pfont->Attach(::GetStockObject(SYSTEM_FONT));
	}

	return pfont;
}

CComboBox* CCAFEBar::CreateToolsetCombo(int nPos)
{
	CComboBox* pcbToolset;
	int i;

	// get a pointer to the app
	CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

	// create the combo box
	pcbToolset = CreateCombo(IDC_CAFEBarToolset, nPos, ncbToolsetWidth);

	// fill the target combo box

/* OLD:
	for (i = 0; !CToolset::m_strToolsets[i].IsEmpty(); i++) {
		pcbToolset->AddString(CToolset::m_strToolsets[i]);
	}
*/

// NEW:

    const CPlatform::COSArray *paryOS = CPlatform::GetOSArray();
    int nSize = paryOS -> GetSize();

  CPlatform::COS *pOS;

	for (i = 0; i < nSize; i++)
	{
    pOS = paryOS->GetAt(i);
    pcbToolset->AddString(pOS->GetName());
	}
 
	// size the combo box to fit the content
	SizeComboToContent(pcbToolset);

	return pcbToolset;
}

CComboBox* CCAFEBar::CreateBuildTypeCombo(int nPos)
{
	CComboBox* pcbBuildType;
	int i;

	// create the combo box
	pcbBuildType = CreateCombo(IDC_CAFEBarBuildType, nPos, ncbBuildTypeWidth);


	// fill the build type combo box
	for (i = 0; !CToolset::m_strBuildType[i].IsEmpty(); i++) {
		pcbBuildType->AddString(CToolset::m_strBuildType[i]);
	}


	// size the combo box to fit the content
	SizeComboToContent(pcbBuildType);

	return pcbBuildType;
}

CComboBox* CCAFEBar::CreateLanguageCombo(int nPos)
{
	CComboBox* pcbLanguage;
	int i;

	// get a pointer to the app
	CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

	// create the combo box
	pcbLanguage = CreateCombo(IDC_CAFEBarLanguage, nPos, ncbLanguageWidth);

/* OLD:
	// fill the language combo box
	for (i = 0; !CToolset::m_strLanguage[i].IsEmpty(); i++) {
		pcbLanguage->AddString(CToolset::m_strLanguage[i]);
	}
*/

// NEW:

    const CPlatform::CLangArray *paryLang = CPlatform::GetLangArray();
    int nSize = paryLang -> GetSize();

  CPlatform::CLanguage *pLang;

	for (i = 0; i < nSize; i++)
	{
    pLang = paryLang->GetAt(i);
    if (*pLang != CPlatform::AnyLanguage)
      pcbLanguage->AddString(pLang->GetName());
	}



	// size the combo box to fit the content
	SizeComboToContent(pcbLanguage);

	return pcbLanguage;
}

CComboBox* CCAFEBar::CreateCombo(UINT nId, int nPos, int nWidth)
{
	CComboBox* pcb;
	CRect rect;

	// the position must be at least 1
	ASSERT(nPos > 0);

	// create a combo box object
	pcb = new CComboBox;

	// create a 12 pixel gap between the previous toolbar item and this combo box
	SetButtonInfo(nPos-1, ID_SEPARATOR, TBBS_SEPARATOR, ncbSpaceWidth);

	// create space for the combo box
	SetButtonInfo(nPos, nId, TBBS_SEPARATOR, nWidth);
	
	// create a 12 pixel gap between this combo box and the next toolbar item
	SetButtonInfo(nPos+1, ID_SEPARATOR, TBBS_SEPARATOR, ncbSpaceWidth);

	// get and set rectangle information about this combo box's space
	GetItemRect(nPos, &rect);
	rect.top = theApp.IsOnWin95() ? 2 : 3;
	rect.bottom = rect.top + 10;

	// create the combo box on the toolbar
	if (!pcb->Create(CBS_DROPDOWNLIST | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP, rect, this, nId)) {
		TRACE("CCAFEBar::CreateCombo: failed to create combo box\n");
		delete pcb;
		return NULL;
	}

	// set font for the combo box
	pcb->SetFont(m_pfont);

	return pcb;
}

void CCAFEBar::SizeComboToContent(CComboBox* pCombo, int nMax /*= 0*/)
{
	ASSERT_VALID(pCombo);
	int cyEdit = (int)::SendMessage(pCombo->m_hWnd, CB_GETITEMHEIGHT, UINT(-1), 0);

	CDC* pDC = pCombo->GetDC();
	CFont* pFontOld;
	CFont* pFont = pCombo->GetFont();

	if (pFont != NULL)
		pFontOld = pDC->SelectObject(pFont);

	// FUTURE:  Need better way to get height
	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	if (pFont != NULL)
		pDC->SelectObject(pFontOld);

	pCombo->ReleaseDC(pDC);

	int cyHeight = pCombo->GetCount();
	if (nMax > 0 && cyHeight > nMax)
		cyHeight = nMax;

	cyHeight = cyEdit +	cyHeight * tm.tmHeight +
		GetSystemMetrics(SM_CYBORDER) * 3;

	CRect rectCombo;
	pCombo->GetDroppedControlRect(&rectCombo);

	if (theApp.IsOnWin95())
	{
		// Win95 does its own size to content.  Leave it alone, if we have
		// enough space, otherwise use max, and  let the system fix it.

		if (rectCombo.Height() > cyHeight)
			cyHeight = rectCombo.Height();
		else
		{
			cyHeight = cyEdit +	cyHeight * tm.tmHeight +
				GetSystemMetrics(SM_CYBORDER) * 5;
		}
	}

	cyHeight *= 2 ;
	if (rectCombo.Height() != cyHeight)
	{
		pCombo->SetWindowPos(NULL, 0, 0, rectCombo.Width(), cyHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCAFEBar message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafepage.h ===
/////////////////////////////////////////////////////////////////////////////
// cafepage.h
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Interface of the CCAFEPage class

#include "settings.h"

/////////////////////////////////////////////////////////////////////////////
// CCAFEPage dialog

class CCAFEPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CCAFEPage)

// Construction
public:
	CCAFEPage(CSettings* pSettings = NULL);
	~CCAFEPage();

// Dialog Data
	//{{AFX_DATA(CCAFEPage)
	enum { IDD = IDD_CAFETab };
	int		m_bStdToolbar;
	int		m_bSubSuiteToolbar;
	int		m_bViewportToolbar;
	int		m_bStatusBar;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCAFEPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);
	virtual void OnOK(void);

// data
protected:
	CSettings* m_pSettings;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCAFEPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafexcpt.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cafexcpt.cpp
//
//	Created by :			Date :
//		BrianCr				11/29/94
//
//	Description :
//		Implementation of the CCAFEException class
//

#include "stdafx.h"
#include "cafexcpt.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_DYNAMIC(CCAFEException, CException)

CCAFEException::CCAFEException(CString strMsg /*= ""*/, CCAFEException::CAFEExceptionCause cause /*= CCAFEException::causeUnknown*/, LPCSTR lpszFileName /*= NULL*/, int nLine /*= -1*/)
: m_strMsg(strMsg),
  m_cause(cause),
  m_file(lpszFileName),
  m_line(nLine)
{
}

//////////////////////////////////////////////////////////////////////////////
//	Debug CCAFEException functions

#ifdef _DEBUG
// character strings to use for dumping CCAFEException
static char BASED_CODE szUnknown[] = "unknown";
static char BASED_CODE szGeneric[] = "generic";

static LPCSTR BASED_CODE rgszCCAFEExceptionCause[CCAFEException::NUM_CAUSES] =
{
	szUnknown,
	szGeneric,
};
#endif //_DEBUG

#ifdef _DEBUG
void CCAFEException::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
//	AFX_DUMP0(dc, " m_cause = ");

	dc << "msg = " << m_strMsg << "; cause = " << rgszCCAFEExceptionCause[m_cause];
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
//	Other CCAFEException functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafemdi.h ===
// cafemdi.h : header file
//

#ifndef __CAFEMDI_H__
#define __CAFEMDI_H__
#include "portview.h"

/////////////////////////////////////////////////////////////////////////////
// CCafeDrvMDIChild frame

class CCafeDrvMDIChild : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CCafeDrvMDIChild)
protected:
	CSplitterWnd m_wndSplitter;
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	CCafeDrvMDIChild();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCafeDrvMDIChild)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CCafeDrvMDIChild();

	// Generated message map functions
	//{{AFX_MSG(CCafeDrvMDIChild)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__CAFEMDI_H__ 

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
// cafepage.cpp
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Implementation of the CCAFEPage class

#include "stdafx.h"
#include "cafepage.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCAFEPage property page

IMPLEMENT_DYNCREATE(CCAFEPage, CPropertyPage)

CCAFEPage::CCAFEPage(CSettings* pSettings /*= NULL*/)
: CPropertyPage(CCAFEPage::IDD),
  m_pSettings(pSettings)
{
	//{{AFX_DATA_INIT(CCAFEPage)
	m_bStdToolbar = FALSE;
	m_bSubSuiteToolbar = FALSE;
	m_bViewportToolbar = FALSE;
	m_bStatusBar = FALSE;
	//}}AFX_DATA_INIT
}

CCAFEPage::~CCAFEPage()
{
}

void CCAFEPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCAFEPage)
	DDX_Check(pDX, IDC_CAFEStdToolbar, m_bStdToolbar);
	DDX_Check(pDX, IDC_CAFESubSuiteToolbar, m_bSubSuiteToolbar);
	DDX_Check(pDX, IDC_CAFEVwprtToolbar, m_bViewportToolbar);
	DDX_Check(pDX, IDC_CAFEStatusBar, m_bStatusBar);
	//}}AFX_DATA_MAP
}

BOOL CCAFEPage::OnSetActive(void)
{
	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// the settings object must exist
	ASSERT(m_pSettings);

	// initialize the page
	m_bStdToolbar = m_pSettings->GetBooleanValue(settingStdToolbar);
	m_bSubSuiteToolbar = m_pSettings->GetBooleanValue(settingSubSuiteToolbar);
	m_bViewportToolbar = m_pSettings->GetBooleanValue(settingViewportToolbar);
	m_bStatusBar = m_pSettings->GetBooleanValue(settingStatusBar);

	// copy the settings into the appropriate variables
	UpdateData(FALSE);

	return TRUE;
}

void CCAFEPage::OnOK(void)
{
	// call the base class
	CPropertyPage::OnOK();

	// the settings object must exist
	ASSERT(m_pSettings);

	// retrieve the settings from the UI
	UpdateData(TRUE);

	m_pSettings->SetBooleanValue(settingStdToolbar, m_bStdToolbar);
	m_pSettings->SetBooleanValue(settingSubSuiteToolbar, m_bSubSuiteToolbar);
	m_pSettings->SetBooleanValue(settingViewportToolbar, m_bViewportToolbar);
	m_pSettings->SetBooleanValue(settingStatusBar, m_bStatusBar);

	// write settings to the registry
	m_pSettings->WriteRegistry();
}

BEGIN_MESSAGE_MAP(CCAFEPage, CPropertyPage)
	//{{AFX_MSG_MAP(CCAFEPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCAFEPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\graph.cpp ===
/////////////////////////////////////////////////////////////////////////////
// graph.cpp
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1995 Microsoft

// Implementation of the CGraph class

#include "stdafx.h"
#include "graph.h"
#include "caferes.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
// CGraph class

IMPLEMENT_DYNAMIC(CGraph, CObject);

CGraph::CGraph(LPCSTR pszName)
: m_strName(pszName)
{
	m_pGraph = new AdjacencyArray;
	m_pGraph->SetSize(0, 20);
}

CGraph::~CGraph(void)
{
	// delete each adjacency list and each item in the adjacency array
	for (int i = 0; i < m_pGraph->GetSize(); i++) {
		// delete each item in each adjacency list
		CAdjacencyList* pList = (*m_pGraph)[i]->m_pAdjacencyList;
		for (POSITION pos = pList->GetHeadPosition(); pos != NULL; ) {
			delete pList->GetNext(pos);
		}
		delete pList;
		delete (*m_pGraph)[i];
	}
	m_pGraph->RemoveAll();
	delete m_pGraph;
}

void CGraph::AddEdge(CEdge* pEdge, const CVertex& srcVertex, const CVertex& destVertex)
{
	int i;
	AdjacencyArrayItem* psrcAdjacencyArrayItem = NULL;
	AdjacencyArrayItem* pdestAdjacencyArrayItem = NULL;
	CAdjacencyList* pAdjacencyList;
	AdjacencyListItem* pAdjacencyListItem;

	// find the source vertex in the adjacency array
	// (or add an entry to the adjacency array if it doesn't exist)
	for (i = 0; i < m_pGraph->GetSize(); i++) {
		// does the vertex in this adjacency array item match the source vertex?
		if ((*m_pGraph)[i]->m_Vertex == srcVertex) {
			psrcAdjacencyArrayItem = (*m_pGraph)[i];
			break;
		}
	}
	// if the source vertex is not in the adjacency array, add it
	if (!psrcAdjacencyArrayItem) {
		pAdjacencyList = new CAdjacencyList;
		psrcAdjacencyArrayItem = new AdjacencyArrayItem(srcVertex, pAdjacencyList);
		m_pGraph->Add(psrcAdjacencyArrayItem);
	}

	// find the destination vertex in the adjacency array
	// (or add an entry to the adjacency array if it doesn't exist)
	for (i = 0; i < m_pGraph->GetSize(); i++) {
		// does the vertex in this adjacency array item match the destination vertex?
		if ((*m_pGraph)[i]->m_Vertex == destVertex) {
			pdestAdjacencyArrayItem = (*m_pGraph)[i];
			break;
		}
	}
	// if the destination vertex is not in the adjacency array, add it
	if (!pdestAdjacencyArrayItem) {
		pAdjacencyList = new CAdjacencyList;
		pdestAdjacencyArrayItem = new AdjacencyArrayItem(destVertex, pAdjacencyList);
		m_pGraph->Add(pdestAdjacencyArrayItem);
	}

	// add the edge from the source vertex to the destination vertex
	pAdjacencyListItem = new AdjacencyListItem(&(pdestAdjacencyArrayItem->m_Vertex), pEdge);
	psrcAdjacencyArrayItem->m_pAdjacencyList->AddTail(pAdjacencyListItem);
}

void CGraph::DeleteEdge(CEdge* pEdge)
{
	// NYI
	ASSERT(FALSE);
}

POSITION CGraph::GetFirstVertexPosition(void)
{
	// if the graph is empty, we can't iterate
	if (IsEmpty()) {
		return NULL;
	}
	return (POSITION)1;
}

CVertex* CGraph::GetNextVertex(POSITION& pos)
{
	// store the current vertex
	CVertex* pVertex = &((*m_pGraph)[(int)pos - 1]->m_Vertex);

	// increment and if the index is no longer in range, set pos to NULL
	pos = (POSITION)((int)pos + 1);
	if ((int)pos > m_pGraph->GetSize()) {
		pos = NULL;
	}
	return pVertex;
}

POSITION CGraph::GetFirstEdgePosition(CVertex* pSrcVertex)
{
	// find the source vertex
	for (int index = 0; index < m_pGraph->GetSize(); index++ ) {
		if ((*m_pGraph)[index]->m_Vertex == *pSrcVertex) {
			break;
		}
	}
	// did we find the source vertex?
	if (index >= m_pGraph->GetSize()) {
		return NULL;
	}

	// get the first position in the adjacency list
	return (*m_pGraph)[index]->m_pAdjacencyList->GetHeadPosition();
}

CEdge* CGraph::GetNextEdge(CVertex* pSrcVertex, POSITION& posEdge, CVertex** ppDestVertex)
{
	// find the source vertex
	for (int index = 0; index < m_pGraph->GetSize(); index++ ) {
		if ((*m_pGraph)[index]->m_Vertex == *pSrcVertex) {
			break;
		}
	}
	// did we find the source vertex?
	if (index >= m_pGraph->GetSize()) {
		return NULL;
	}

	// get the adjacency list item at the current position and iterate to the next position
	AdjacencyListItem* pItem = (*m_pGraph)[index]->m_pAdjacencyList->GetNext(posEdge);

	// store the destination vertex
	*ppDestVertex = pItem->m_pVertex;

	// return the edge to the destination
	return pItem->m_pEdge;
}

CAdjacencyList* CGraph::GetAdjacencyList(CVertex& vertex)
{
	// find the vertex
	for (int index = 0; index < m_pGraph->GetSize(); index++) {
		if ((*m_pGraph)[index]->m_Vertex == vertex) {
			// return the adjacency list
			return (*m_pGraph)[index]->m_pAdjacencyList;
		}
	}
	
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// CGraphForest class

IMPLEMENT_DYNAMIC(CGraphForest, CObject)

CGraphForest::CGraphForest(void)
{
	// allocate space for the graph array
	m_paGraphs = new GraphArray;
	m_paGraphs->SetSize(0, 20);

	// create all the graphs
	CString strName;
	CGraph* pGraph;
	for (int i = IDS_Graph_AccelEd; i <= IDS_Graph_VersionEd; i++) {
		// load the graph's name
		strName.LoadString(i);
		// create the graph
		pGraph = new CGraph(strName);
		// add it to the array of graphs
		m_paGraphs->Add(pGraph);
	}
}

CGraphForest::~CGraphForest()
{
	// delete each graph
	for (int i = 0; i < m_paGraphs->GetSize(); i++) {
		delete (*m_paGraphs)[i];
	}
	m_paGraphs->RemoveAll();
	delete m_paGraphs;
}

void CGraphForest::AddEdge(CEdge* pEdge, CVertex& srcVertex, CVertex& destVertex)
{
	// add the edge to the graph based on the source vertex's category
	(*m_paGraphs)[srcVertex.GetCategory()]->AddEdge(pEdge, srcVertex, destVertex);
}

void CGraphForest::DeleteEdge(CEdge* pEdge)
{
	// it may be much easier to implement if we require the source and dest
	// vertices as well as the edge when deleting an edge

	// NYI
	ASSERT(FALSE);
}

BOOL CGraphForest::IsEmpty(void)
{
	// the forest is empty if all graphs in it are empty
	for (int i = 0; i < m_paGraphs->GetSize(); i++) {
		if (!(*m_paGraphs)[i]->IsEmpty()) {
			return FALSE;
		}
	}
	return TRUE;
}

POSITION CGraphForest::GetFirstGraphPosition(void)
{
	// if the forest is empty, we can't iterate
	if (IsEmpty()) {
		return NULL;
	}
	return (POSITION)1;
}

CGraph* CGraphForest::GetNextGraph(POSITION& pos)
{
	// store the current graph
	CGraph* pGraph = (*m_paGraphs)[(int)pos - 1];

	// increment and if the index is no longer in range, set pos to NULL
	pos = (POSITION)((int)pos + 1);
	if ((int)pos > m_paGraphs->GetSize()) {
		pos = NULL;
	}
	return pGraph;
}

void CGraphForest::GetStateEdges(CState& state, CAdjacencyList* pAdjacencyList)
{
	// build the list of edges that are traversible from the given state
	// essentially this is an adjacency list that includes all graphs

	// iterate through each graph
	for (POSITION posGraph = GetFirstGraphPosition(); posGraph != NULL; ) {
		CGraph* pGraph = GetNextGraph(posGraph);
		// iterate through each vertex in the graph
		for (POSITION posVertex = pGraph->GetFirstVertexPosition(); posVertex != NULL; ) {
			CVertex* pVertex = pGraph->GetNextVertex(posVertex);
			// is this vertex in the state?
			if (state.Contains(*pVertex)) {
				// add this vertex's adjacency list to master list
				CAdjacencyList* pList = pGraph->GetAdjacencyList(*pVertex);
				pAdjacencyList->AddTail(pList);
			}
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
// CState class

IMPLEMENT_DYNAMIC(CState, CObject)
		
CState::CState(void)
{
	// allocate space for the vertex array
	m_paVertices = new VertexArray;
	m_paVertices->SetSize(0, 20);
	
	// create each vertex
	for (int i = 0; i < CVertex::NumCategories; i++) {
		// create the vertex
		CVertex* pVertex = new CVertex((CVertex::Category)i, 0);
		// add it to the array of vertices
		m_paVertices->Add(pVertex);
	}
}

CState::~CState()
{
	// delete each vertex in the vertex array
	for (int i = 0; i < m_paVertices->GetSize(); i++) {
		delete (*m_paVertices)[i];
	}
	m_paVertices->RemoveAll();
	delete m_paVertices;
}
	
void CState::Update(CVertex& vertex)
{
	// update the state to reflect the given vertex
	// that is, find the vertex of the same category
	// in the state and set it to the given vertex
	for (int i = 0; i < m_paVertices->GetSize(); i++) {
		if ((*m_paVertices)[i]->GetCategory() == vertex.GetCategory()) {
			*((*m_paVertices)[i]) = vertex;
			return;
		}
	}
	// we should always find a matching category
	ASSERT(0);
}

BOOL CState::Contains(CVertex& vertex)
{
	// determine if the current state contains the given vertex
	// by iterating through each vertex and checking equality
	for (int i = 0; i < m_paVertices->GetSize(); i++) {
		if (*((*m_paVertices)[i]) == vertex) {
			return TRUE;
		}
	}
	return FALSE;
}

void CState::Reset(void)
{
	// cannot call Reset when the size of the array
	// does not match the number of categories
	ASSERT(m_paVertices->GetSize() == CVertex::NumCategories);

	// reset each vertex
	for (int i = 0; i < CVertex::NumCategories; i++) {
		// create a temporary vertex
		CVertex* pVertex = new CVertex((CVertex::Category)i, 0);
		// assign the value of the temp vertex to the vertex in the array
		*((*m_paVertices)[i]) = *pVertex;
		// delete the temporary vertex
		delete pVertex;
	}

}

CString CState::GetName(void)
{
	CString strName;

	// iterate through each vertex and assemble the name
	for (int i = 0; i < m_paVertices->GetSize(); i++) {
		strName += CString((*m_paVertices)[i]->GetName()) + CString(", ");
	}
	strName = strName.Left(strName.GetLength()-2);

	return strName;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\cafexcpt.h ===
///////////////////////////////////////////////////////////////////////////////
//	cafexcpt.h
//
//	Created by :			Date :
//		BrianCr				11/29/94
//
//	Description :
//		Declaration of the CCAFEException class
//

#ifndef __CAFEXCPT_H__
#define __CAFEXCPT_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CTestException class

class CCAFEException: public CException
{
	DECLARE_DYNAMIC(CCAFEException)

public:
	enum CAFEExceptionCause {
		causeUnknown,			// invoker didn't specify a cause
		causeGeneric,			// no current use
		NUM_CAUSES
	};

// Constructor
	CCAFEException(CString strMsg = "", CAFEExceptionCause cause = CCAFEException::causeUnknown, LPCSTR lpszFileName = NULL, int nLine = -1);

// operations
public:
	CString GetMessage(void)				{ return m_strMsg; }
	CAFEExceptionCause GetCause(void)		{ return m_cause; }

// data
protected:
	CString m_strMsg;
	CAFEExceptionCause m_cause;
	LPCSTR m_file;
	int m_line;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

#endif //__CAFEXCPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\caferes.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cafe.rc
//
#define IDR_MAINFRAME                   2
#define IDB_CAFEBAR                     2
#define IDR_PORTTYPE                    3
#define IDR_SUITETYPE                   4
#define IDB_SUITEBAR                    4
#define IDB_SUBSUITEBAR                 4
#define IDR_DLLTYPE                     5
#define IDP_OLE_INIT_FAILED             100
#define IDD_ABOUTBOX                    100
#define IDC_CLOSE                       101
#define IDM_FileNewAssignment           101
#define IDI_CATS                        102
#define IDC_DEBUG_TARGET                102
#define IDM_FileNewViewport             102
#define IDC_DEBUG_EVENT                 103
#define IDT_CAFEBar                     103
#define IDD_SCRIPTS                     104
#define IDT_SubSuiteBar                 104
#define IDI_CAFE                        105
#define IDT_ViewportBar                 105
#define IDI_SNOUT                       109
#define IDI_UTENSIL3                    110
#define IDC_SELECT_ALL                  111
#define IDI_CHEESE                      111
#define IDI_UTENSILX                    112
#define IDI_UTENSIL                     113
#define IDC_SCRIPT_LIST                 114
#define IDI_PIG2                        114
#define IDI_PASS                        114
#define IDI_ENRIQUE                     115
#define IDD_FINDSTRING                  116
#define IDC_DESELECT_ALL                117
#define IDD_RunTests                    117
#define IDC_TOGGLE_ALL                  118
#define IDD_TestSuites                  118
#define IDD_Tests                       118
#define IDD_Suite                       118
#define IDC_NEWAPP                      119
#define IDC_CLOSEONEXIT                 120
#define IDD_TargetTab                   120
#define IDC_RUN                         121
#define IDD_LogTab                      121
#define IDC_MAXFAIL                     122
#define IDD_AssignmentProp              122
#define IDD_LogTab2                     122
#define IDC_LogMaxFail                  122
#define IDC_TEXT                        123
#define IDC_Language                    124
#define IDD_AddDirDlg                   124
#define IDL_Assignments                 125
#define IDL_SubSuites                   125
#define IDS_Assignments                 126
#define IDD_RemoteSettingsTab           126
#define IDS_SubSuites                   126
#define IDB_GlyphFolderClose            126
#define IDC_Platform                    127
#define IDB_GlyphFolderOpen             127
#define IDL_Tests                       128
#define IDB_GlyphCollapsed              128
#define IDS_Platform                    129
#define IDB_GlyphExpanded               129
#define IDS_Language                    130
#define IDB_GlyphTest                   130
#define IDB_Add                         131
#define IDB_Delete                      132
#define IDB_Run                         133
#define IDC_DebugTarget                 134
#define IDC_DebugEvents                 135
#define IDB_BITMAP1                     135
#define IDS_Tests                       136
#define IDE_BaseNameTargetApp           136
#define IDB_BITMAP2                     136
#define IDR_TimeStampNone               137
#define IDB_BITMAP3                     137
#define IDR_TimeStampMilliseconds       138
#define IDB_VIEWPORTBAR                 138
#define IDR_TimeStampTime               139
#define IDB_BITMAP5                     139
#define IDB_SUBSUITEBAR_BAK             139
#define IDR_TimeStampTimeDate           140
#define IDB_BITMAP6                     140
#define IDB_GlyphBadTest                140
#define IDD_DirectoriesTab              141
#define IDC_COMBO1                      141
#define IDC_LogConnector                141
#define IDC_GraphList                   141
#define IDC_DIRS_TOOLSETS               142
#define IDC_PlatformDir                 142
#define IDC_Target                      142
#define IDD_DriverTab                   142
#define IDD_CAFETab                     142
#define IDC_DIRS_OPTIONS                143
#define IDC_Envvar                      143
#define IDC_Target2                     143
#define IDD_AppLog                      143
#define IDC_DIRS_LIST                   144
#define IDE_TargetAppClass              144
#define IDD_Toolbars                    144
#define IDC_DIRS_ADD                    145
#define IDE_TargetAppTitle              145
#define IDD_SuiteTab                    145
#define IDC_DIRS_DELETE                 146
#define IDE_TargetAppBaseName           146
#define IDC_DIRS_MOVEUP                 147
#define IDS_AssignmentFileName          147
#define IDD_Graph                       147
#define IDC_DIRS_MOVEDOWN               148
#define IDS_AssignmentOwner             148
#define IDD_TestsRun                    148
#define IDC_CleanAfterAssignment        149
#define IDD_CurrentState                149
#define IDC_CloseAfterAssignment        150
#define IDD_StepBreak                   150
#define IDE_AddDir                      151
#define IDI_AboutIcon                   152
#define IDC_EDIT1                       154
#define IDE_LogResultsFile              154
#define IDE_AppLog                      154
#define IDC_STEP_NO                     154
#define IDC_EDIT2                       155
#define IDC_LogPost                     155
#define IDC_EDIT3                       156
#define IDC_LogToCom                    156
#define IDC_LogBaudRate                 157
#define IDC_CAFEVwprtToolbar            158
#define IDC_CAFEStdToolbar              159
#define IDC_CAFESubSuiteToolbar         160
#define IDC_CAFEStatusBar               161
#define IDC_LogConnectorText            162
#define IDC_LogBaudRateText             163
#define IDE_LogSummaryFile              164
#define IDI_FAILED                      164
#define IDE_LogWorkingDir               165
#define IDC_LogComments                 166
#define IDB_Copy                        167
#define IDB_Clear                       168
#define IDC_ShowViewportToolbar         170
#define IDC_ShowSubSuiteToolbar         171
#define IDC_ShowCAFEToolbar             172
#define IDC_ShowStatusBar               173
#define IDC_SuiteCleanUpBefore          174
#define IDC_SuiteCleanUpAfter           175
#define IDC_SuiteLoopTests              178
#define IDC_LogDebugOutput              180
#define IDP_GraphView                   183
#define IDL_GraphTests                  184
#define IDS_GraphViewHoriz              187
#define IDS_GraphViewVert               188
#define IDS_GraphTests                  189
#define IDL_TestsRun                    194
#define IDL_PreCond                     195
#define IDL_PostCond                    196
#define IDL_CurrentState                197
#define IDB_ViewCurrentState            199
#define IDE_CycleNumber                 204
#define IDI_WONDER                      605
#define LANG_JAPAN                      1000
#define IDC_SuiteRandomize              1501
#define IDS_SuiteRandomSeed             1502
#define IDE_SuiteRandomSeed             1503
#define IDS_RandomLimitsText            1504
#define IDR_RandomLimitNone             1505
#define IDR_RandomLimitNum              1506
#define IDE_RandomLimitNum              1507
#define IDS_RandomLimitNumText          1508
#define IDR_RandomLimitTime             1509
#define IDE_RandomLimitTime             1510
#define IDS_RandomLimitTimeText         1511
#define IDB_SuiteViewGraphs             1512
#define IDS_ERROR_CANT_OPEN             20000
#define IDS_ERROR_CANT_SAVE             20001
#define ID_EDIT_DELETE                  32769
#define ID_EDIT_CLEARALL                32770
#define ID_VIEW_CLEAR                   32771
#define ID_EDIT_DELETELINE              32771
#define ID_WINDOW_VIEWPORT              32777
#define ID_WINDOW_RESULTSLOG            32778
#define ID_RUN_SCRIPT                   32779
#define ID_RUN_DEFAULT                  32780
#define ID_OPTIONS_TIMESTAMP_NONE       32784
#define ID_OPTIONS_TIMESTAMP_TICK       32785
#define ID_OPTIONS_TIMESTAMP_TIME       32786
#define ID_OPTIONS_TIMESTAMP_TIMEDATE   32787
#define ID_EDIT_FINDNEXT                32794
#define IDM_OptionsDriver               32796
#define IDM_OptionsAssignment           32797
#define IDM_OptionsSingleStep           32798
#define IDM_OptionsSuite                -32737
#define IDM_OptionsCAFE                 32805
#define ID_VIEWPORT_HEADER              32806
#define ID_VIEWPORT_SUMMARY             32807
#define ID_VIEWPORT_COMMENTS            32808
#define ID_VIEWPORT_RESULTS             32809
#define ID_VIEWPORT_FAILUREDETAILS      32810
#define ID_VIEWPORT_INFODETAILS         32811
#define ID_VIEWPORT_TOOLBAR             32812
#define IDM_SubSuiteRun                 32813
#define IDM_SubSuiteAdd                 32814
#define IDM_SubSuiteDelete              32815
#define IDM_SubSuiteProperties          32816
#define IDM_ViewportHeaderFilter        32817
#define IDM_ViewportSummaryFilter       32818
#define IDM_ViewportCommentsFilter      32819
#define IDM_ViewportResultsFilter       32820
#define IDM_ViewportFailureFilter       32821
#define IDM_ViewportInfoFilter          32822
#define IDM_ViewportSeparatorFilter     32823
#define IDM_ViewportSuccessFilter       32824
#define IDM_ViewportStepFilter          32825
#define IDM_SubSuiteSelectAll           32826
#define IDM_SubSuiteDeselectAll         32827
#define IDM_SubSuiteToggleAll           32828
#define IDM_OptionsToolset              32829
#define IDM_HelpContents                32830
#define IDM_FileViewLog                 32831
#define IDM_Options_Loop                32832
#define IDM_OptionsLoop                 32833
#define IDM_OptionsToolbars             32834
#define IDM_OptionsLogDebugOutput       32835
#define IDM_OptionsBreakStep            32836
#define ID_BUTTON32833                  32837
#define ID_BUTTON32834                  32838
#define ID_BUTTON32835                  32839
#define ID_BUTTON32836                  32840
#define ID_BUTTON32837                  32841
#define ID_BUTTON32838                  32842
#define ID_BUTTON32839                  32843
#define ID_BUTTON32845                  32845
#define ID_BUTTON32846                  32846
#define ID_BUTTON32847                  32847
#define ID_BUTTON32848                  32848
#define ID_BUTTON32849                  32849
#define ID_BUTTON32850                  32850
#define ID_BUTTON32851                  32851
#define ID_BUTTON32852                  32852
#define ID_BUTTON32853                  32853
#define ID_BUTTON32854                  32854
#define ID_BUTTON32855                  32855
#define ID_BUTTON32856                  32856
#define ID_BUTTON32857                  32857
#define ID_BUTTON32858                  32858
#define ID_BUTTON32859                  32859
#define ID_BUTTON32860                  32860
#define ID_BUTTON32861                  32861
#define ID_BUTTON32862                  32862
#define ID_BUTTON32863                  32863
#define ID_EDIT_MARK                    32867
#define ID_SELECT_ALL                   32868
#define IDM_OptionsSave                 32869
#define IDS_OptionsDriver               61216
#define IDS_OptionsCAFE                 61216
#define IDS_AssignmentProperties        61217
#define IDC_TargetCombo                 61218
#define IDC_CAFEBarToolset              61218
#define IDC_LanguageCombo               61219
#define IDC_CAFEBarLanguage             61219
#define IDS_COMBO_FONT                  61220
#define IDS_TOOLBAR_FONT                61220
#define IDS_Target_x86_Retail           61224
#define IDS_Target_x86_Debug            61225
#define IDS_Target_MIPS_Retail          61226
#define IDS_Target_MIPS_Debug           61227
#define IDS_Target_Mac_Retail           61228
#define IDS_Target_Mac_Debug            61229
#define IDS_Target_Win32s_Retail        61230
#define IDS_Target_Win32s_Debug         61231
#define IDS_Language_English            61232
#define IDS_Language_Japanese           61233
#define IDS_Envvar_Path                 61234
#define IDS_Envvar_Include              61235
#define IDS_Envvar_Lib                  61236
#define IDS_ErrTargetNotFound           61237
#define IDS_ErrTargetLaunchFail         61238
#define IDS_ErrNoSubSuiteEntries        61239
#define IDS_ErrOpenSuiteFile            61240
#define IDS_ErrInvalidSubSuite          61241
#define IDS_ErrOpenSubSuite             61242
#define IDC_CAFEBarBuildType            61243
#define IDS_VCToolset_x86               61244
#define IDS_VCToolset_Mac68k            61245
#define IDS_VCToolset_PowerMac          61246
#define IDS_VCToolset_Win32s            61247
#define IDS_VCToolset_MIPS              61248
#define IDS_VCToolset_Alpha             61249
#define IDS_ErrOpenViewportFile         61250
#define IDS_ErrSubSuiteNotDebug         61251
#define IDS_ErrSubSuiteNotRetail        61252
#define IDS_VCToolset_PowerPC           61253
#define IDS_OptionsSuite                61254
#define IDS_Graph_AccelEd               61255
#define IDS_Graph_BitmapEd              61256
#define IDS_Graph_CursorEd              61257
#define IDS_Graph_Debugger              61258
#define IDS_Graph_DialogEd              61259
#define IDS_Graph_IconEd                61260
#define IDS_Graph_MenuEd                61261
#define IDS_Graph_Project               61262
#define IDS_Graph_ResScript             61263
#define IDS_Graph_SourceEd              61264
#define IDS_Graph_StringEd              61265
#define IDS_Graph_ToolbarEd             61266
#define IDS_Graph_VersionEd             61267
#define IDS_Language_German				61268

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        155
#define _APS_NEXT_COMMAND_VALUE         32870
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\graph.h ===
/////////////////////////////////////////////////////////////////////////////
// graph.h
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1994 Microsoft

// Interface of the CGraph class

#ifndef __GRAPH_H__
#define __GRAPH_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "vertex.h"
#include "edge.h"

///////////////////////////////////////////////////////////////////////////////
// CAdjacencyList class

// the type for each item in the adjacency list
struct AdjacencyListItem
{
	AdjacencyListItem(CVertex* pvertex, CEdge* pedge) : m_pVertex(pvertex), m_pEdge(pedge) { }
	CVertex* m_pVertex;
	CEdge* m_pEdge;
};

// the adjacency list type
typedef CList<AdjacencyListItem*, AdjacencyListItem*> CAdjacencyList;

///////////////////////////////////////////////////////////////////////////////
// CState class

class CState: public CObject
{
	DECLARE_DYNAMIC(CState)
		
// constructor/destructor
public:
	CState(void);
	~CState();
	
// data types
protected:
	typedef CArray<CVertex*, CVertex*> VertexArray;
	
// operations
public:
	void Update(CVertex& vertex);
	BOOL Contains(CVertex& vertex);
	void Reset(void);
	CString GetName(void);

// data
protected:
	// the order of the vertices in this array *must* match the order of
	// the enumeration CVertex::Category
	VertexArray* m_paVertices;
};

///////////////////////////////////////////////////////////////////////////////
// CGraph class

class CGraph: public CObject
{
	DECLARE_DYNAMIC(CGraph)

// ctor/dtor
public:
	CGraph(LPCSTR pszName);
	virtual ~CGraph(void);

// operations
public:
	void AddEdge(CEdge* pEdge, const CVertex& srcVertex, const CVertex& destVertex);
	void DeleteEdge(CEdge* pEdge);

	void SetName(LPCSTR pszName)	{ m_strName = pszName; }
	CString GetName(void)			{ return m_strName; }

	BOOL IsEmpty(void)				{ return (m_pGraph->GetSize() == 0); }

	// for iterating through the vertices in this graph
	POSITION GetFirstVertexPosition(void);
	CVertex* GetNextVertex(POSITION& pos);

	// for iterating through the edges for a vertex at the given position
	POSITION GetFirstEdgePosition(CVertex* pSrcVertex);
	CEdge* GetNextEdge(CVertex* pSrcVertex, POSITION& posVertex, CVertex** ppDestVertex);

	CAdjacencyList* GetAdjacencyList(CVertex& vertex);
	
// data types
protected:

	// the type for each item in the adjacency array
	struct AdjacencyArrayItem
	{
		AdjacencyArrayItem(const CVertex& vertex, CAdjacencyList* plist) : m_Vertex(vertex), m_pAdjacencyList(plist) { }
		CVertex m_Vertex;
		CAdjacencyList* m_pAdjacencyList;
	};

	// the type for the array of adjacency lists
	typedef CArray<AdjacencyArrayItem*, AdjacencyArrayItem*> AdjacencyArray;

// data
protected:
	// the graph is an adjacency array
	AdjacencyArray* m_pGraph;
	CString m_strName;

// don't want anyone to call these
protected:
	CGraph(void) { }
};

///////////////////////////////////////////////////////////////////////////////
// CGraphForest class

class CGraphForest: public CObject
{
	DECLARE_DYNAMIC(CGraphForest)

// constructor/destructor
public:
	CGraphForest(void);
	virtual ~CGraphForest();

// data types
public:
	typedef CArray<CGraph*, CGraph*> GraphArray;

// operations
public:
	void AddEdge(CEdge* pEdge, CVertex& srcVertex, CVertex& destVertex);
	void DeleteEdge(CEdge* pEdge);

	BOOL IsEmpty(void);

	// for iterating through the graphs in this forest
	POSITION GetFirstGraphPosition(void);
	CGraph* GetNextGraph(POSITION& pos);

	void GetStateEdges(CState& state, CAdjacencyList* pList);
	
// data
protected:
	// the order of the graphs in this array *must* match the order of
	// the enumeration CVertex::Category
	GraphArray* m_paGraphs;
};

#endif //__GRAPH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\graphdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	graphdlg.cpp
//
//	Created by :			Date :
//		BrianCr				06/30/95
//
//	Description :
//		Implementation of the CGraphDlg class
//

#include "stdafx.h"
#include "graphdlg.h"
#include "graphwnd.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg dialog

CGraphDlg::CGraphDlg(CWnd* pParent /*=NULL*/, CSuiteDoc* pSuiteDoc /*= NULL*/)
	: CDialog(CGraphDlg::IDD, pParent),
	  m_pSuiteDoc(pSuiteDoc),
	  m_pwndGraph(NULL)
{
	// the doc must be valid
	ASSERT(m_pSuiteDoc);

	//{{AFX_DATA_INIT(CGraphDlg)
	//}}AFX_DATA_INIT
}

CGraphDlg::~CGraphDlg()
{
	delete m_pwndGraph;
}

void CGraphDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGraphDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGraphDlg, CDialog)
	//{{AFX_MSG_MAP(CGraphDlg)
	ON_CBN_SELCHANGE(IDC_GraphList, OnSelChangeGraphList)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg message handlers

BOOL CGraphDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// fill the graph list
	FillGraphList();

	// select the first graph
	// get the graph combo box
	CComboBox* pcbGraphs = (CComboBox*)GetDlgItem(IDC_GraphList);
	pcbGraphs->SetCurSel(0);
	OnSelChangeGraphList();

	// set the tab stops in the test list box
	CListBox* plbTests = (CListBox*)GetDlgItem(IDL_GraphTests);
	// get the size of the list box
	CRect rect;
	plbTests->GetClientRect(&rect);
	// get the horizontal dialog base units
	int nXBaseUnit = LOWORD(GetDialogBaseUnits());
	// set the tab stops at half the width of the list box
	// (figure the number of dialog units horizontally in the list box)
	int nTabStop = ((rect.Width() * 4) / nXBaseUnit) * 9 / 10;
	// set the tab stops
	plbTests->SetTabStops(nTabStop);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGraphDlg::OnSelChangeGraphList()
{
	// get the graph combo box
	CComboBox* pcbGraphs = (CComboBox*)GetDlgItem(IDC_GraphList);

	// get a pointer to the graph
	CGraph*	pGraph = (CGraph*)pcbGraphs->GetItemDataPtr(pcbGraphs->GetCurSel());
	ASSERT(pGraph->IsKindOf(RUNTIME_CLASS(CGraph)));

	// get the test list box
	CListBox* plbTests = (CListBox*)GetDlgItem(IDL_GraphTests);

	// create the graph window
	delete m_pwndGraph;
	m_pwndGraph = new CGraphWnd(pGraph, plbTests);
	m_pwndGraph->Create(CRect(0,0,0,0), this, 10001);

	// show and resize the graph window
	CRect rect;
	GetDlgItem(IDP_GraphView)->GetWindowRect(rect);
	ScreenToClient(&rect);
	m_pwndGraph->SetWindowPos(NULL,
							  rect.left, rect.top,
							  rect.Width(), rect.Height(),
							  SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOACTIVATE);

	// compute the size of the scroll bars
	CalcScrollMetrics();
}

void CGraphDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	ASSERT(pScrollBar == GetDlgItem(IDS_GraphViewHoriz));
	OnScroll(MAKEWORD(nSBCode, -1), nPos);
}

void CGraphDlg::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	ASSERT(pScrollBar == GetDlgItem(IDS_GraphViewVert));
	OnScroll(MAKEWORD(-1, nSBCode), nPos);
}

void CGraphDlg::OnScroll(UINT nScrollCode, UINT nPos)
{
	// get current (x,y) scroll bar position
	int x = ((CScrollBar *)GetDlgItem(IDS_GraphViewHoriz))->GetScrollPos();
	int y = ((CScrollBar *)GetDlgItem(IDS_GraphViewVert))->GetScrollPos();

	// figure new horizontal scroll bar position
	switch (LOBYTE(nScrollCode))
	{
		case SB_TOP: x = 0; break;
		case SB_BOTTOM: x = m_sizeScroll.cx; break;
		case SB_THUMBTRACK: x = nPos; break;
		case SB_LINEUP: x -= m_sizeLine.cx; break;
		case SB_LINEDOWN: x += m_sizeLine.cx; break;
		case SB_PAGEUP: x -= m_sizePage.cx; break;
		case SB_PAGEDOWN: x += m_sizePage.cx; break;
	}

	// figure new vertical scroll bar position
	switch (HIBYTE(nScrollCode))
	{
		case SB_TOP: y = 0; break;
		case SB_BOTTOM: y = m_sizeScroll.cy; break;
		case SB_THUMBTRACK: y = nPos; break;
		case SB_LINEUP: y -= m_sizeLine.cy; break;
		case SB_LINEDOWN: y += m_sizeLine.cy; break;
		case SB_PAGEUP: y -= m_sizePage.cy; break;
		case SB_PAGEDOWN: y += m_sizePage.cy; break;
	}

	// ensure within bounds
	if (x < 0) {
		x = 0;
	}
	else if (x > m_sizeScroll.cx) {
		x = m_sizeScroll.cx;
	}

	if (y < 0) {
		y = 0;
	}
	else if (y > m_sizeScroll.cy) {
		y = m_sizeScroll.cy;
	}

	// perform scroll
	m_pwndGraph->SetOrigin(x, y);

	// set new (x,y) pos
	((CScrollBar *)GetDlgItem(IDS_GraphViewHoriz))->SetScrollPos(x);
	((CScrollBar *)GetDlgItem(IDS_GraphViewVert))->SetScrollPos(y);
}

void CGraphDlg::FillGraphList(void)
{
	int nElement;
	POSITION pos;

	// get the graph combo box
	CComboBox* pcbGraphs = (CComboBox*)GetDlgItem(IDC_GraphList);

	// empty the list
	pcbGraphs->ResetContent();

	// iterate through the list of graphs in the forest
	CGraphForest* pForest = m_pSuiteDoc->GetGraphForest();
	for (pos = pForest->GetFirstGraphPosition(); pos != NULL; ) {
		// add each graph to the list
		CGraph* pGraph = pForest->GetNextGraph(pos);
		// only add non-empty graphs to the list
		if (!pGraph->IsEmpty()) {
			// add the graph name to the list
			nElement = pcbGraphs->AddString(pGraph->GetName());
			// store a pointer to the graph along with this item
			pcbGraphs->SetItemDataPtr(nElement, (void*)pGraph);
		}
	}
}

void CGraphDlg::CalcScrollMetrics(void)
{
	// set the ranges for our scroll bars
	m_sizeScroll = m_pwndGraph->GetSize();

	// get the size of the visible frame
	CRect rect;
	GetDlgItem(IDP_GraphView)->GetWindowRect(rect);

	// set the line and page sizes for scrolling
	m_sizeLine.cx = 16;
	m_sizeLine.cy = 16;
	m_sizePage.cx = rect.Width() - m_sizeLine.cx;
	m_sizePage.cy = rect.Height() - m_sizeLine.cy;
	
	((CScrollBar *)GetDlgItem(IDS_GraphViewHoriz))->SetScrollRange(0, m_sizeScroll.cx, FALSE);
	((CScrollBar *)GetDlgItem(IDS_GraphViewVert))->SetScrollRange(0, m_sizeScroll.cy, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\graphdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//	graphdlg.h
//
//	Created by :			Date :
//		BrianCr				06/30/95
//
//	Description :
//		Definition of the CGraphDlg class
//

#ifndef __GRAPHDLG_H__
#define __GRAPHDLG_H__

#include "caferes.h"
#include "suitedoc.h"
#include "graphwnd.h"

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg dialog

class CGraphDlg: public CDialog
{
// Construction
public:
	CGraphDlg(CWnd* pParent = NULL, CSuiteDoc* pSuiteDoc = NULL);   // standard constructor
	~CGraphDlg();

// Dialog Data
	//{{AFX_DATA(CGraphDlg)
	enum { IDD = IDD_Graph };
/*
	CComboBox	m_cbGraphs;
	CListBox	m_lbTests;
*/	
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGraphDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeGraphList();
	afx_msg void OnHScroll(UINT, UINT, CScrollBar *);
	afx_msg void OnVScroll(UINT, UINT, CScrollBar *);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void FillGraphList(void);
	void CalcScrollMetrics(void);
	void OnScroll(UINT nScrollCode, UINT nPos);


protected:
	CSuiteDoc* m_pSuiteDoc;
	CGraphWnd* m_pwndGraph;
	CSize m_sizeScroll;
	CSize m_sizePage;
	CSize m_sizeLine;
};

#endif // __GRAPHDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\graphwnd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	graphwnd.cpp
//
//	Created by :			Date :
//		BrianCr				07/03/95
//
//	Description :
//		Implementation of the CGraphWnd class
//

#include "stdafx.h"
#include "graphwnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGraphWnd

const CGraphWnd::cVertexWidth = 75;
const CGraphWnd::cVertexHeight = 50;
const CGraphWnd::cXSeparator = 30;
const CGraphWnd::cYSeparator = 0;
const CGraphWnd::cXBorder = 20;
const CGraphWnd::cYBorder = 35;

CGraphWnd::CGraphWnd(CGraph* pGraph, CListBox* plb)
	: m_pGraph(pGraph),
	m_plbTests(plb),
	m_ptOrigin(0, 0),
	m_nSelVertex(-1)
{
	FillTestList();
}

CGraphWnd::~CGraphWnd()
{
	// iterate through array of vertex info and delete each one
	for (int i = 0; i < m_aVertices.GetSize(); i++) {
		delete m_aVertices[i];
	}
	m_aVertices.RemoveAll();
}


BEGIN_MESSAGE_MAP(CGraphWnd, CWnd)
	//{{AFX_MSG_MAP(CGraphWnd)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGraphWnd message handlers

void CGraphWnd::OnPaint() 
{
//	CPaintDC dc(this); // device context for painting
	CDC* pDC = GetDC();

	// set the viewport origin
	pDC->SetViewportOrg(-m_ptOrigin.x, -m_ptOrigin.y);

	// draw background over invalid rectangle
	CRect rectInvalid;
	GetUpdateRect(&rectInvalid);
	rectInvalid.OffsetRect(m_ptOrigin);
	CBrush brushBackground;
	brushBackground.CreateSolidBrush(RGB(128, 128, 128));
	pDC->FillRect(&rectInvalid, &brushBackground);

	// iterate through the vertices and draw each one
	for (int index = 0; index < m_aVertices.GetSize(); index++) {
		DrawVertex(pDC, index);
	}
	
	CWnd::OnPaint();
}

BOOL CGraphWnd::PreCreateWindow(CREATESTRUCT& cs) 
{
	// store each vertex in the array of vertex information
	for (POSITION pos = m_pGraph->GetFirstVertexPosition(); pos != NULL; ) {
		// get the vertex
		CVertex* pSrcVertex = m_pGraph->GetNextVertex(pos);
		// store vertex information
		StoreVertexInfo(pSrcVertex);
	}
	
	return CWnd::PreCreateWindow(cs);
}

BOOL CGraphWnd::Create(const RECT& rect, CWnd* pParentWnd, UINT nID) 
{
	return CWnd::Create(NULL, "GraphWnd", WS_CHILD | WS_BORDER | WS_CLIPSIBLINGS, rect, pParentWnd, nID);
}

void CGraphWnd::OnLButtonDown(UINT nFlags, CPoint point) 
{
	// invalidate the rect that was previously selected
	if (m_nSelVertex >= 0) {
		InvalidateRect(m_aVertices[m_nSelVertex]->m_rect);
	}

	// offset the clicked point based on the graph origin
	point.Offset(m_ptOrigin);

	// figure out which vertex the user clicked in
	for (int i = 0; i < m_aVertices.GetSize(); i++) {
		// is the point clicked in the vertex rect?
		if (m_aVertices[i]->m_rect.PtInRect(point)) {
			m_nSelVertex = i;
			InvalidateRect(m_aVertices[i]->m_rect);
			break;
		}
	}

	if (i >= m_aVertices.GetSize()) {
		// no vertex selected
		m_nSelVertex = -1;
	}

	// update the test list
	FillTestList();

	// call the base class
	CWnd::OnLButtonDown(nFlags, point);
}

void CGraphWnd::StoreVertexInfo(CVertex* pVertex)
{
	int x1, y1, x2, y2;

	// figure out the index of this vertex
	int nIndex = m_aVertices.GetSize();

	// create space to store the vertex information
	VertexInfo* pVertexInfo = new VertexInfo(pVertex);
	// compute the rectangle for this vertex
	x1 = cXBorder + nIndex*cXSeparator + nIndex*cVertexWidth;
	y1 = cYBorder;
	x2 = x1 + cVertexWidth;
	y2 = cYBorder + cVertexHeight;

	pVertexInfo->m_rect = CRect(x1, y1, x2, y2);

	// add the vertex info to the array
	m_aVertices.Add(pVertexInfo);
}

void CGraphWnd::DrawVertex(CDC* pDC, int index)
{
	// select the pen
	pDC->SelectStockObject(BLACK_PEN);

	// select the brush
	// select the black brush, if this is the selected vertex
	pDC->SelectStockObject((index == m_nSelVertex) ? BLACK_BRUSH : WHITE_BRUSH);

	// draw the vertex
	pDC->Rectangle(m_aVertices[index]->m_rect);

	// select the font
	CFont font;
	if (!font.CreateFont(14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FF_SWISS | DEFAULT_PITCH, "Arial")) {
		TRACE("Can't create the font");
	}
	CFont* poldfont = pDC->SelectObject(&font);

	// set the text color
	// set the text color to white, if this is the selected vertex
	if (index == m_nSelVertex) {
		pDC->SetTextColor(RGB(255, 255, 255));
		pDC->SetBkColor(RGB(0, 0, 0));
	}
	else {
		pDC->SetTextColor(RGB(0, 0, 0));
		pDC->SetBkColor(RGB(255, 255, 255));
	}

	// draw the text
	pDC->DrawText(m_aVertices[index]->m_pVertex->GetName(), -1, m_aVertices[index]->m_rect, DT_CENTER | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

	// draw the edges leaving from this vertex

	// iterate through all edges from this vertex
	CVertex* pSrcVertex = m_aVertices[index]->m_pVertex;
	CVertex* pDestVertex;
	for (POSITION pos = m_pGraph->GetFirstEdgePosition(pSrcVertex); pos != NULL; ) {
		// get the edge
		CEdge* pEdge = m_pGraph->GetNextEdge(pSrcVertex, pos, &pDestVertex);
		// figure out the index of the destination vertex
		for (int nDestIndex = 0; nDestIndex < m_aVertices.GetSize(); nDestIndex++) {
			if (*(m_aVertices[nDestIndex]->m_pVertex) == *pDestVertex) {
				// draw an edge from the source vertex to the destination vertex
				DrawEdge(pDC, index, nDestIndex);
			}
		}
	}

	pDC->SelectObject(poldfont);
}

void CGraphWnd::DrawEdge(CDC* pDC, int srcindex, int destindex)
{
	int x1, y1, x2, y2, x3, y3, x4, y4;
	int dist;
	CRect srcRect, destRect;

	// get the rects for each vertex
	srcRect = m_aVertices[srcindex]->m_rect;
	destRect = m_aVertices[destindex]->m_rect;

	// select the pen
	pDC->SelectStockObject(BLACK_PEN);

	// draw the edge
	// is the edge going left to right?
	if (srcindex < destindex) {
		dist = destindex - srcindex;
		// is the edge to an adjacent vertex?
		if (dist == 1) {
			x1 = srcRect.right;
			y1 = srcRect.top + cVertexHeight/3;
			x2 = destRect.left;
			y2 = y1;

			// draw the edge
			pDC->MoveTo(x1, y1);
			pDC->LineTo(x2, y2);
			// draw the arrow head
			pDC->LineTo(x2-5, y2-5);
			pDC->MoveTo(x2, y2);
			pDC->LineTo(x2-5, y2+5);
		}
		// not an adjacent vertex
		else {
			x1 = srcRect.right;
			y1 = srcRect.top + cVertexHeight/4;
			x2 = x1 + cXSeparator/2;
			y2 = cYBorder - 2*dist;
			x3 = destRect.left - cXSeparator/2;
			y3 = y2;
			x4 = destRect.left;
			y4 = y1;

			// draw the edge
			pDC->MoveTo(x1, y1);
			pDC->LineTo(x2, y2);
			pDC->LineTo(x3, y3);
			pDC->LineTo(x4, y4);
			// draw the arrow head
			pDC->LineTo(x4, y4-5);
			pDC->MoveTo(x4, y4);
			pDC->LineTo(x4-5, y4);
		}
	}
	// is the edge going right to left?
	else if (srcindex > destindex) {
		dist = srcindex - destindex;
		// is the edge to an adjacent vertex?
		if (dist == 1) {
			x1 = srcRect.left;
			y1 = srcRect.top + (cVertexHeight/3)*2;
			x2 = destRect.right;
			y2 = y1;

			// draw the edge
			pDC->MoveTo(x1, y1);
			pDC->LineTo(x2, y2);
			// draw the arrow head
			pDC->LineTo(x2+5, y2-5);
			pDC->MoveTo(x2, y2);
			pDC->LineTo(x2+5, y2+5);
		}
		// not an adjacent vertex
		else {
			x1 = srcRect.left;
			y1 = srcRect.top + (cVertexHeight/4)*3;
			x2 = x1 - cXSeparator/2;
			y2 = cYBorder + cVertexHeight + 2*dist;
			x3 = destRect.right + cXSeparator/2;
			y3 = y2;
			x4 = destRect.right;
			y4 = y1;

			// draw the edge
			pDC->MoveTo(x1, y1);
			pDC->LineTo(x2, y2);
			pDC->LineTo(x3, y3);
			pDC->LineTo(x4, y4);
			// draw the arrow head
			pDC->LineTo(x4, y4+5);
			pDC->MoveTo(x4, y4);
			pDC->LineTo(x4+5, y4);
		}
	}
	// the edge goes to the same vertex
	else {
		x1 = srcRect.left + srcRect.Width() / 3;
		y1 = srcRect.top;
		x2 = x1;
		y2 = y1 - 10;
		x3 = x1 + srcRect.Width() / 3;
		y3 = y2;
		x4 = x3;
		y4 = y1;
		
		// draw the edge
		pDC->MoveTo(x1, y1);
		pDC->LineTo(x2, y2);
		pDC->LineTo(x3, y3);
		pDC->LineTo(x4, y4);
		// draw the arrow head
		pDC->LineTo(x4+5, y4-5);
		pDC->MoveTo(x4, y4);
		pDC->LineTo(x4-5, y4-5);
	}
}

void CGraphWnd::FillTestList(void)
{
	// empty the test list
	m_plbTests->ResetContent();

	// fill with the tests from the currently selected vertex
	if (m_nSelVertex >= 0) {
		CVertex* pSrcVertex;
		CVertex* pDestVertex;
		CEdge* pEdge;

		// get the source vertex
		pSrcVertex = m_aVertices[m_nSelVertex]->m_pVertex;

		// iterate through all edges from the source vertex
		for (POSITION pos = m_pGraph->GetFirstEdgePosition(pSrcVertex); pos != NULL; ) {
			// get the edge
			pEdge = m_pGraph->GetNextEdge(pSrcVertex, pos, &pDestVertex);
			// build the list entry
			CString str = pEdge->GetName() + "\t--> " + pDestVertex->GetName();
			// add the edge's name to the list
			m_plbTests->AddString(str);
		}
	}
	else {
		m_plbTests->AddString("No vertex selected");
	}
}

CSize CGraphWnd::GetSize(void)
{
	CSize size(0, 0);

	// iterate through each vertex and store the max X and Y position
	for (int i = 0; i < m_aVertices.GetSize(); i++) {
		size.cx = max(size.cx, m_aVertices[i]->m_rect.right);
		size.cy = max(size.cy, m_aVertices[i]->m_rect.bottom);
	}
	// the size must include a border on the right and bottom
	size.cx += cXBorder;
	size.cy += cYBorder;

	return size;
}

void CGraphWnd::SetOrigin(int x, int y)
{
	// ensure within our size range!
	CSize sizeGraph = GetSize();
	ASSERT(0 <= x && x <= sizeGraph.cx);
	ASSERT(0 <= y && y <= sizeGraph.cy);

	// calculate our invalid screen areas

	// get our client coord.
	RECT rectInvalid;
	GetClientRect(&rectInvalid);

	int xdiff = x - m_ptOrigin.x;
	int ydiff = y - m_ptOrigin.y;

	// scroll the window
	if (xdiff || ydiff)
		ScrollWindow(-xdiff, -ydiff);

	// horiz. invalid part
	if (ydiff)
	{
		if (ydiff < 0)
			rectInvalid.bottom = rectInvalid.top - ydiff;
		else
			rectInvalid.top = rectInvalid.bottom - ydiff;

		InvalidateRect(&rectInvalid, TRUE);
	}

	// vert. invalid part
	if (xdiff)
	{
		if (xdiff < 0)
			rectInvalid.right = rectInvalid.left - xdiff;
		else
			rectInvalid.left = rectInvalid.right - xdiff;

		InvalidateRect(&rectInvalid, TRUE);
	}

	// set our origin
	m_ptOrigin = CPoint(x, y);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\hotkey.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	HOTKEY.CPP
//
//	Created by :			Date :
//		DavidGa					8/13/93
//
//	Description :
//		Implementation of the CHotKeyWnd class
//

#include "stdafx.h"
#include "hotkey.h"
#include "cafedrv.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CHotKeyThread

IMPLEMENT_DYNCREATE(CHotKeyThread, CWinThread)

CHotKeyThread::CHotKeyThread()
{
	m_pfnThreadProc = NULL;
}

BOOL CHotKeyThread::InitInstance()
{
//	CHotKeyWnd* pWnd = new CHotKeyWnd;
	m_wndHK.Create();
	// hide the window to start
	m_wndHK.ShowWindow(SW_HIDE);

	return TRUE;
}

CHotKeyThread::~CHotKeyThread()
{
}


/////////////////////////////////////////////////////////////////////////////
// CHotKeyWnd

IMPLEMENT_DYNCREATE(CHotKeyWnd, CWnd)

BEGIN_MESSAGE_MAP(CHotKeyWnd, CWnd)
	//{{AFX_MSG_MAP(CHotKeyWnd)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_CLOSE()
    ON_WM_MOVE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HOTKEY, OnHotKey)
	ON_MESSAGE(WM_SIZING, OnSizing)
	ON_MESSAGE(WM_REGISTERHOTKEYS, OnRegisterHotKeys)
	ON_MESSAGE(WM_UNREGISTERHOTKEYS, OnUnregisterHotKeys)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHotKeyWnd construction/destruction

CHotKeyWnd::CHotKeyWnd()
: m_psettingsWnd(NULL)
{
	g_hSingleStep = CreateEvent(NULL,		// security attributes
								TRUE,		// manual reset
								FALSE,		// initial state
								"HotKey_SingleStep_Event");
// REVIEW: we need to create the event anyway, always signaled, when not using this feature
	g_hUserAbort = CreateEvent(NULL,		// security attributes
								FALSE,		// manual reset
								FALSE,		// initial state
								"HotKey_UserAbort_Event");
}

CHotKeyWnd::~CHotKeyWnd()
{
	g_hwndHotKey = NULL;

	// delete the settings object
	delete m_psettingsWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CHotKeyWnd diagnostics

#ifdef _DEBUG
void CHotKeyWnd::AssertValid() const
{
	CWnd::AssertValid();
}

void CHotKeyWnd::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);
}

#endif //_DEBUG

void CHotKeyWnd::RegisterHotKeys(void)
{
    VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_SINGLE, 0, VK_F2) );
    VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_STEPOVER, MOD_SHIFT, VK_F2) );
    VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_RUN, MOD_CONTROL, VK_F2) );
    VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_ABORT, MOD_CONTROL | MOD_SHIFT | MOD_ALT, VK_END) );
    VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_STEPBREAK, MOD_SHIFT, VK_SCROLL) );

}

void CHotKeyWnd::UnregisterHotKeys(void)
{
    ::UnregisterHotKey(m_hWnd, HOTKEY_RUN);
    ::UnregisterHotKey(m_hWnd, HOTKEY_SINGLE);
    ::UnregisterHotKey(m_hWnd, HOTKEY_STEPOVER);
    ::UnregisterHotKey(m_hWnd, HOTKEY_ABORT);
    ::UnregisterHotKey(m_hWnd, HOTKEY_STEPBREAK);
}

/////////////////////////////////////////////////////////////////////////////
// CHotKeyWnd message handlers

BOOL CHotKeyWnd::Create(void)
{
	return CWnd::CreateEx(
		WS_EX_TOPMOST,	// extended style
		// AfxRegisterWndClass(WS_POPUP | WS_THICKFRAME | WS_VISIBLE),	 // Don't need this
		AfxRegisterWndClass(CS_GLOBALCLASS),
		"Comments about the next step will be here!",	// window name
		WS_POPUP | WS_CAPTION | WS_THICKFRAME | WS_VISIBLE,	// style
		0,			// window rect
		GetSystemMetrics(SM_CYSCREEN) - GetSystemMetrics(SM_CYCAPTION) - GetSystemMetrics(SM_CYBORDER) - 1,
		GetSystemMetrics(SM_CXSCREEN), //make it screen-wide
		GetSystemMetrics(SM_CYCAPTION),
		NULL,		// parent window,
		NULL,		// nlDorHMenu
		NULL		// lpPararm
	);
}

int CHotKeyWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if( CWnd::OnCreate(lpCreateStruct) == -1 )
		return -1;

	// get a pointer to the app
	CCAFEDriver *pApp = ((CCAFEDriver *)AfxGetApp());

	// register the break key (Scroll Lock)
    VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_BREAK, 0, VK_PAUSE) );

	// create a new window settings object
	m_psettingsWnd = new CSettings(pApp->GetSettings()->GetTextValue(settingCAFEKey)+"\\Step window");

	// set up window defaults (this window's current position)
    m_psettingsWnd->SetIntValue(settingWaitStepWndX, lpCreateStruct->x);
    m_psettingsWnd->SetIntValue(settingWaitStepWndY, lpCreateStruct->y);
    m_psettingsWnd->SetIntValue(settingWaitStepWndWidth, lpCreateStruct->cx);
    m_psettingsWnd->SetIntValue(settingWaitStepWndHeight, lpCreateStruct->cy);

	// read registry settings
	m_psettingsWnd->ReadRegistry();
	// write the settings back out to initialize registry
	m_psettingsWnd->WriteRegistry();

	#ifdef _DEBUG
		m_psettingsWnd->DumpSettings("Step window settings");
	#endif // _DEBUG

	// position the window in the correct position
    MoveWindow(m_psettingsWnd->GetIntValue(settingWaitStepWndX),
               m_psettingsWnd->GetIntValue(settingWaitStepWndY),
               m_psettingsWnd->GetIntValue(settingWaitStepWndWidth),
               m_psettingsWnd->GetIntValue(settingWaitStepWndHeight));

	g_hwndHotKey = m_hWnd;
	return 0;
}

void CHotKeyWnd::OnClose()
{
	// store the position of the hot key window
    SavePosition();

	// unregister all hotkeys
	UnregisterHotKeys();
    ::UnregisterHotKey(m_hWnd, HOTKEY_BREAK);

    CWnd::OnClose();

	// terminate the thread, too
	AfxEndThread(0);
}

void CHotKeyWnd::OnMove(int x, int y)
{
    CWnd::OnMove(x, y);

    SavePosition();
}

void CHotKeyWnd::OnSizing( UINT nSide, LPRECT lpRect )
{
    CWnd::OnSizing(nSide, lpRect);
	RECT orgRect;
	if(nSide & (WMSZ_BOTTOM|WMSZ_TOP))
	{ //don't allow to resize anything but left-right
		GetWindowRect(&orgRect);
		lpRect->top=orgRect.top;
		lpRect->bottom=orgRect.bottom;
	}
}

void CHotKeyWnd::SavePosition()
{
    CRect rect;
    GetWindowRect(rect);

	// the settings object must be valid
	ASSERT(m_psettingsWnd);

	// store the window's current position
    m_psettingsWnd->SetIntValue(settingWaitStepWndX, rect.left);
    m_psettingsWnd->SetIntValue(settingWaitStepWndY, rect.top);
    m_psettingsWnd->SetIntValue(settingWaitStepWndWidth, rect.Width());
    m_psettingsWnd->SetIntValue(settingWaitStepWndHeight, rect.Height());

	// write settings to the registry
	m_psettingsWnd->WriteRegistry();
}

LRESULT CHotKeyWnd::OnHotKey(WPARAM wParam, LPARAM lParam)
{
	switch( wParam )
	{
		case HOTKEY_SINGLE:		// step a single action
		case HOTKEY_STEPOVER:	// step over the rest of this test case
			g_hkToDo = (EHotKey)wParam;
			SetEvent(g_hSingleStep);	// release anything waiting
			break;
		case HOTKEY_RUN:		// no more waiting
		case HOTKEY_BREAK:		// breaks run mode
			if( g_hkToDo == HOTKEY_RUN )	// now this hotkey toggles between run and break
			{
				// register all hot keys
				RegisterHotKeys();
				g_hkToDo = HOTKEY_SINGLE;
				ResetEvent(g_hSingleStep);	// exit run mode
				SetWindowText("Applying brakes...");
			}
			else
			{
				// unregister all hot keys
				UnregisterHotKeys();
				g_hkToDo = HOTKEY_RUN;
				SetEvent(g_hSingleStep);	// release anything waiting
			}
			break;
		case HOTKEY_ABORT:
			// unregister all hot keys
			UnregisterHotKeys();
			SetEvent(g_hUserAbort);		// user abort
			g_hkToDo = HOTKEY_RUN;
			SetEvent(g_hSingleStep);    // Release anything waiting.
			SetWindowText("Aborting...");
			break;
		case HOTKEY_STEPBREAK:
			if( g_hkToDo != HOTKEY_STEPBREAK )	// now this hotkey brings the dialog
			{
				// unregister all hot keys
				UnregisterHotKeys();
			    ::UnregisterHotKey(m_hWnd, HOTKEY_BREAK);
				int gotglobalstep=g_stopStep;
				g_stopStep=-1; // cause the WaitStepInstructions to stop unconditionnally
				g_hkToDo = HOTKEY_SINGLE;
				ResetEvent(g_hSingleStep);	// exit run mode
				SetWindowText("Applying breakpoint...");
				HWND hwndTarget = ::GetForegroundWindow();	// Save active target window.
				::SetForegroundWindow(g_hwndHotKey);	
				CStepBreak dlg(gotglobalstep);
				int nResponse = dlg.DoModal();
				if (nResponse == IDOK)
				{
					gotglobalstep=dlg.m_iStepNumber;
					g_hkToDo = HOTKEY_STEPBREAK;
				}
				else if (nResponse == IDCANCEL)
				{
				}
				::SetForegroundWindow(hwndTarget);			// Restore focus to target.
		
				while(::GetForegroundWindow() != hwndTarget)	// Wait for full activation!
					;

				g_stopStep=gotglobalstep;
				// reregister all hotkey
				RegisterHotKeys();
				VERIFY( ::RegisterHotKey(m_hWnd, HOTKEY_BREAK, 0, VK_SCROLL) );
//				if (nResponse == IDOK)
//					SetEvent(g_hSingleStep);   // do not wait to resume
			}
			else // hotkay restarts the run 
			{
				g_hkToDo = HOTKEY_SINGLE;
				SetEvent(g_hSingleStep);    // Release anything waiting.
			}
			break;
		default:
			ASSERT(FALSE);	// there are no other hot keys
	}
	return 0;
}

LRESULT CHotKeyWnd::OnRegisterHotKeys(WPARAM wParam, LPARAM lParam)
{
	// register hot keys
	RegisterHotKeys();

	return 0;
}

LRESULT CHotKeyWnd::OnUnregisterHotKeys(WPARAM wParam, LPARAM lParam)
{
	// unregister hot keys
	UnregisterHotKeys();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\hotkey.h ===
///////////////////////////////////////////////////////////////////////////////
//	HOTKEY.H
//
//	Created by :			Date :
//		DavidGa					8/13/93
//
//	Description :
//		Declaration of the CHotKeyWnd class
//

#ifndef __HOTKEY_H__
#define __HOTKEY_H__
//we need a single instance of any type of CAFE driver because of hotkey clash
#define STARTUPMUTEXNAME "CAFEMutex_5371af09" //say, it's a unique name

// REVIEW(briancr): we need a better type of communication between the
// support system and the single step window. Currently, the support system
// contains code that records information in the single step window and the
// driver contains this code that manages the single step window.
#include "guiv1.h"
#include "settings.h"

///////////////////////////////////////////////////////////////////////////////
// hot key IDs

//#define HOTKEY_RUN			65123
//#define HOTKEY_SINGLE		65124
//#define HOTKEY_STEPOVER		65125
//#define HOTKEY_BREAK		65126
//#define HOTKEY_STEPBREAK		65127
#define HOTKEY_ABORT		65999

///////////////////////////////////////////////////////////////////////////////
// hot key globals
/*
extern AFX_EXT_DATA HANDLE g_hSingleStep;
extern AFX_EXT_DATA HANDLE g_hUserAbort;
extern AFX_EXT_DATA HWND g_hwndHotKey;
enum HotKeyTypes { HOTKEY_RUN, HOTKEY_SINGLE, HOTKEY_STEPOVER, HOTKEY_BREAK, HOTKEY_STEPBREAK};
extern AFX_EXT_DATA HotKeyTypes g_hkToDo;
*/ 
///////////////////////////////////////////////////////////////////////////////
// CHotKeyWnd class

#define WM_REGISTERHOTKEYS WM_USER + 10
#define WM_UNREGISTERHOTKEYS WM_USER + 11

class CHotKeyWnd : public CWnd
{
public:
	CHotKeyWnd();
	~CHotKeyWnd();
	BOOL Create(void);

	DECLARE_DYNCREATE(CHotKeyWnd)

// Implementation
public:
#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif
	void RegisterHotKeys(void);
	void UnregisterHotKeys(void);
	CSettings* GetSettings(void) { ASSERT(m_psettingsWnd); return m_psettingsWnd; };
// data
protected:
	CSettings* m_psettingsWnd;

// Generated message map functions
protected:
	//{{AFX_MSG(CHotKeyWnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnClose();
    afx_msg void OnMove(int x, int y);
	afx_msg void OnSizing( UINT nSide, LPRECT lpRect );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	LRESULT OnHotKey(WPARAM wParam, LPARAM lParam);
	LRESULT OnRegisterHotKeys(WPARAM wParam, LPARAM lParam);
	LRESULT OnUnregisterHotKeys(WPARAM wParam, LPARAM lParam);
    void SavePosition();
};

///////////////////////////////////////////////////////////////////////////////
// CHotKeyWndThread class

class CHotKeyThread : public CWinThread
{
public:
	CHotKeyThread();
	~CHotKeyThread();

	DECLARE_DYNCREATE(CHotKeyThread)

// Overridables
	// thread initialization
	virtual BOOL InitInstance();

	CWnd* GetHKWnd(void)  { ASSERT(IsWindow(m_wndHK.m_hWnd)); return &m_wndHK; }

// Data
protected:
	CHotKeyWnd m_wndHK;
};

#endif //__HOTKEY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\logpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
// logpage.cpp
//
// email	date		change
// briancr	11/10/94	created
//
// copyright 1994 Microsoft

// Implementation of the CLogPage class

#include "stdafx.h"
#include "logpage.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogPage property page

IMPLEMENT_DYNCREATE(CLogPage, CPropertyPage)

CLogPage::CLogPage()
: CPropertyPage(CLogPage::IDD)
{
	//{{AFX_DATA_INIT(CLogPage)
	m_nMaxFail = 0;
	m_bPost = FALSE;
	m_bCom = FALSE;
	m_strConnector = _T("");
	m_strBaudRate = _T("");
	m_bComments = FALSE;
	m_strResultsFile = _T("");
	m_strSummaryFile = _T("");
	m_strWorkDir = _T("");
	m_bDebugOutput = FALSE;
	//}}AFX_DATA_INIT
}

CLogPage::~CLogPage()
{
}

void CLogPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogPage)
	DDX_Text(pDX, IDC_LogMaxFail, m_nMaxFail);
	DDX_Check(pDX, IDC_LogPost, m_bPost);
	DDX_Check(pDX, IDC_LogToCom, m_bCom);
	DDX_CBString(pDX, IDC_LogConnector, m_strConnector);
	DDX_CBString(pDX, IDC_LogBaudRate, m_strBaudRate);
	DDX_Check(pDX, IDC_LogComments, m_bComments);
	DDX_Text(pDX, IDE_LogResultsFile, m_strResultsFile);
	DDX_Text(pDX, IDE_LogSummaryFile, m_strSummaryFile);
	DDX_Text(pDX, IDE_LogWorkingDir, m_strWorkDir);
	DDX_Check(pDX, IDC_LogDebugOutput, m_bDebugOutput);
	//}}AFX_DATA_MAP
}

BOOL CLogPage::OnSetActive(void)
{
	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// set up UI
	OnLogToCom();

	return TRUE;
}

BEGIN_MESSAGE_MAP(CLogPage, CPropertyPage)
	//{{AFX_MSG_MAP(CLogPage)
	ON_BN_CLICKED(IDC_LogToCom, OnLogToCom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLogPage message handlers

void CLogPage::OnLogToCom() 
{
	// retrieve the settings from the UI
	UpdateData(TRUE);

	// since we don't support the COM options yet, just gray out the check box, too
	CWnd* pCOMPort = GetDlgItem(IDC_LogToCom);
	pCOMPort->EnableWindow(FALSE);

	// get pointers to the connector and baud rate drop downs and text
	CWnd* pConnectorText = GetDlgItem(IDC_LogConnectorText);
	CWnd* pConnector = GetDlgItem(IDC_LogConnector);
	CWnd* pBaudRateText = GetDlgItem(IDC_LogBaudRateText);
	CWnd* pBaudRate = GetDlgItem(IDC_LogBaudRate);

	// enable connector and baud rate based on setting of use com port
	pConnectorText->EnableWindow(m_bCom);
	pConnector->EnableWindow(m_bCom);
	pBaudRateText->EnableWindow(m_bCom);
	pBaudRate->EnableWindow(m_bCom);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\graphwnd.h ===
///////////////////////////////////////////////////////////////////////////////
//	graphwnd.h
//
//	Created by :			Date :
//		BrianCr				07/03/95
//
//	Description :
//		Interface of the CGraphWnd class
//

#ifndef __GRAPHWND_H__
#define __GRAPHWND_H__

#include "graph.h"

/////////////////////////////////////////////////////////////////////////////
// CGraphWnd window

class CGraphWnd : public CWnd
{
// Construction
public:
	CGraphWnd(CGraph* pGraph, CListBox* plb);

// Attributes
public:
	CSize GetSize(void);

// Operations
public:
	void SetOrigin(int x, int y);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGraphWnd)
	public:
	virtual BOOL Create(const RECT& rect, CWnd* pParentWnd, UINT nID);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGraphWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CGraphWnd)
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// data types
protected:
	// data type that will store information about each vertex displayed
	struct VertexInfo {
	public:
		VertexInfo(CVertex* pvertex) : m_pVertex(pvertex) { }
		CVertex* m_pVertex;
		CRect m_rect;
	};

	// a graph is made up of a set of vertices
	typedef CArray<VertexInfo*, VertexInfo*> VertexArray;

// operations
protected:
	void StoreVertexInfo(CVertex* pVertex);
	void DrawVertex(CDC* pDC, int index);
	void DrawEdge(CDC* pDC, int srcindex, int destindex);
	void FillTestList(void);

// data
protected:
	CGraph* m_pGraph;
	CListBox* m_plbTests;
	VertexArray m_aVertices;

	CPoint m_ptOrigin;

	int m_nSelVertex;

	static const cVertexWidth;
	static const cVertexHeight;
	static const cXSeparator;
	static const cYSeparator;
	static const cXBorder;
	static const cYBorder;

};

/////////////////////////////////////////////////////////////////////////////

#endif // __GRAPHWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\logview.h ===
// logview.h : header file
//
 
#ifndef _LOGVIEW_H
#define _LOGVIEW_H

/////////////////////////////////////////////////////////////////////////////
// CLogView view
typedef enum NodeTypes {INVALID = -1, SUITE,SUBSUITE,TESTCASE,DETAILS,SUMMARY,FAILURE,OTHER}  ;

class CLogView : public CTreeView
{
protected:
	CLogView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CLogView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

	// Tree control data and methods.
	int isFirstSuite , isFirstSubSuite,isFirstTestCase, isFirstDetails,isFirstSummary ;
	TV_ITEM tv_Item, m_stNode, m_substNode,m_tstCaseNode,m_detailNode,m_sumNode,m_otherNode  ;
	TV_INSERTSTRUCT * tv_Suite, * tv_SubSuite, * tv_Case, * tv_Details, *tv_Summary, *tv_Other ;
	HTREEITEM hSuite, hParentSubSuite, hParentSuite , hParentTest; 
	CImageList pImageList ;
public:
	void AddNewNode(NodeTypes iType,int nLines, CString szText) ;
	HTREEITEM GetParentSubSuite() {return hParentSubSuite; } ;
	HTREEITEM GetParentSuite() {return hParentSuite ; } ;
	HTREEITEM GetParentTest()   {return hParentTest ; } ;
	void ReportFailToTest() ;
	void ReportFailToSubSuite() ;
	void ReportFailToSuite() ;


// Implementation
protected:
	virtual ~CLogView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CLogView)
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //_LOGVIEW_H
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\logview.cpp ===
// logview.cpp : implementation file
//

#include "stdafx.h"
#include "afxcview.h"
#include "cafedrv.h"
#include <afxtempl.h>
#include "portdoc.h"
#include "logview.h"							
#include "caferes.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CLogView * gLogView ;
/////////////////////////////////////////////////////////////////////////////
// CLogView
CViewportView * vConsole, *vTextLog ;

IMPLEMENT_DYNCREATE(CLogView, CTreeView)

CLogView::CLogView()
{
  // m_stNode = m_substNode = m_tstCaseNode = m_detailNode = m_sumNode = m_otherNode ;

   tv_Item.mask = TVIF_TEXT|TVIF_CHILDREN|TVIF_SELECTEDIMAGE|TVIF_PARAM|TVIF_STATE|TVIF_IMAGE ; //Generic item 
   //tv_Item.state = TVIS_EXPANDED ;
   tv_Item.lParam = 1 ;
   // The main nodes for the CAFE log tree.
   tv_Suite   =	new TV_INSERTSTRUCT ;
   tv_SubSuite=	new TV_INSERTSTRUCT ;
   tv_Case	  =	new TV_INSERTSTRUCT ;
   tv_Details = new TV_INSERTSTRUCT ;
   tv_Summary = new TV_INSERTSTRUCT ;
   tv_Other   =	new TV_INSERTSTRUCT ;
   isFirstSuite = 1, isFirstSubSuite=1,isFirstTestCase=1, isFirstDetails=1,isFirstSummary=1 ;
   //hSubSuite= 0 , hTestCase= 0,  hDetails = 0, hSummary = 0;
    hParentSubSuite = 0, hParentSuite =0 , hParentTest = 0 ;

}

CLogView::~CLogView()
{
	 delete tv_Suite ;
	 delete tv_SubSuite ;
	 delete tv_Case ;
	 delete tv_Details ;
	 delete tv_Summary ;
	 delete tv_Other ;
}


BEGIN_MESSAGE_MAP(CLogView, CTreeView)
	//{{AFX_MSG_MAP(CLogView)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogView drawing

void CLogView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
//	CViewportDoc* pDoc = (CViewportDoc*) GetDocument();
	ASSERT_VALID(pDoc);

	CTreeCtrl & bsCtrl = GetTreeCtrl() ;

//	bsCtrl.InsertItem(&tv_inStruct) ;
//	bsCtrl.SetItem(&tvItem) ; 
 
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CLogView diagnostics

#ifdef _DEBUG
void CLogView::AssertValid() const
{
	CTreeView::AssertValid();
}

void CLogView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLogView message handlers

BOOL CLogView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	CCAFEDriver* TheApp = (CCAFEDriver*) AfxGetApp() ;
	pImageList.Create( 16, 16, FALSE, 2, 1 );
	pImageList.Add(TheApp->hIpass) ;
	pImageList.Add(TheApp->hIfail) ;
	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

void CLogView::ReportFailToTest()
{
	GetParentTest()	;
}
void CLogView::ReportFailToSubSuite() 
{
	GetParentTest()	;
}

void CLogView::ReportFailToSuite() 
{
	GetParentTest()	;
}


void CLogView::AddNewNode(NodeTypes iType, int nLine, CString szText)
{  
   CTreeCtrl & THE_TV_CTRL= GetTreeCtrl() ;

   if(!THE_TV_CTRL)
	   return ;
	tv_Item.lParam = nLine ; // The line number of this item in the log file.
	switch(iType)
	{
	case SUITE:
		
		{
		 tv_Item.mask = TVIF_TEXT|TVIF_SELECTEDIMAGE|TVIF_PARAM|TVIF_IMAGE ; //Generic item 

			TV_INSERTSTRUCT tv_suiteCpy;
			tv_Item.pszText = szText.GetBuffer(80);
			tv_suiteCpy.hInsertAfter=TVI_LAST ;
			tv_suiteCpy.item =  tv_Item ;
			tv_suiteCpy.hParent = TVI_ROOT;
			hParentSuite = THE_TV_CTRL.InsertItem(&tv_suiteCpy) ;
			THE_TV_CTRL.Expand(hSuite,TVE_EXPAND) ;

		}
		break ;
	case SUBSUITE:
		{
			TV_INSERTSTRUCT tv_suiteCpy;
			tv_Item.pszText = szText.GetBuffer(80);
			tv_suiteCpy.hInsertAfter=TVI_LAST ;
			tv_suiteCpy.item =  tv_Item ;
			tv_suiteCpy.hParent = GetParentSuite();
			hParentSubSuite =THE_TV_CTRL.InsertItem(&tv_suiteCpy) ;
			THE_TV_CTRL.Expand(THE_TV_CTRL.GetParentItem(hParentSubSuite),TVE_EXPAND) ;

		}
		break;
	case TESTCASE:
		{
			TV_INSERTSTRUCT tv_suiteCpy;
			tv_Item.pszText = szText.GetBuffer(80);
			tv_suiteCpy.hInsertAfter=TVI_LAST ;
			tv_suiteCpy.item =  tv_Item ;
			tv_suiteCpy.hParent = GetParentSubSuite() ;
			hParentTest = THE_TV_CTRL.InsertItem(&tv_suiteCpy) ;
			THE_TV_CTRL.Expand(THE_TV_CTRL.GetParentItem(hParentTest),TVE_EXPAND) ;
		}
		break;
	case FAILURE:
		{
			
			TV_INSERTSTRUCT tv_suiteCpy;
			tv_Item.pszText = szText.GetBuffer(80);
			tv_Item.iImage =1 ;
			tv_Item.iSelectedImage =1 ;
			tv_suiteCpy.hInsertAfter=TVI_LAST ;
			tv_suiteCpy.item =  tv_Item ;
			if (GetParentTest())
				tv_suiteCpy.hParent =  GetParentTest() ;
				else
					if (GetParentSubSuite())
						tv_suiteCpy.hParent = GetParentSubSuite() ;
					else
						if (GetParentSuite())
							tv_suiteCpy.hParent = GetParentSuite() ;
						else
							tv_suiteCpy.hParent = hSuite ;
			HTREEITEM hItem = THE_TV_CTRL.InsertItem(&tv_suiteCpy) ;
			THE_TV_CTRL.Expand(THE_TV_CTRL.GetParentItem(hItem),TVE_EXPAND) ;
			// Reset the bitmaps.
			tv_Item.iImage =0 ;
			tv_Item.iSelectedImage =0 ;
		}
		break;

	case DETAILS:
		{
		}
		break;

	case SUMMARY:
		{  
			TV_INSERTSTRUCT tv_suiteCpy;
			tv_Item.pszText = szText.GetBuffer(80);
			tv_suiteCpy.hInsertAfter=TVI_LAST ;
			tv_suiteCpy.item =  tv_Item ;
			tv_suiteCpy.hParent = GetParentSuite() ;
			THE_TV_CTRL.InsertItem(&tv_suiteCpy) ;
		}
		break;

	default:
	;	
	}
	THE_TV_CTRL.Expand(GetParentSuite(),TVE_EXPAND) ;
//	tv_Suite   	tv_SubSuite 	tv_Case	  	tv_Details 	tv_Summary 	tv_Other   
}

void CLogView::OnInitialUpdate() 
{
   gLogView = this ;
   CTreeCtrl & THE_TV_CTRL= GetTreeCtrl() ;

   long ctrlStyle = GetWindowLong(THE_TV_CTRL.m_hWnd,GWL_STYLE) ;
   ctrlStyle = ctrlStyle| TVS_HASLINES|TVS_LINESATROOT ;
   SetWindowLong(THE_TV_CTRL.m_hWnd,GWL_STYLE,ctrlStyle) ; 

    THE_TV_CTRL.SetImageList( &pImageList,TVSIL_NORMAL );

   	// Add the first Suite node.
	tv_Item.pszText = "Test suite summary:" ;
	tv_Item.iImage = 0 ;		   
	tv_Item.iSelectedImage = 0 ;
	tv_Suite->item =  tv_Item ;
	tv_Suite->hParent = TVI_ROOT ;
	hSuite =THE_TV_CTRL.InsertItem(tv_Suite) ;
		
   
    CTreeView::OnInitialUpdate();
	// TODO: Add your specialized code here and/or call the base class
	
}

void CLogView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    CTreeCtrl & THE_TV_CTRL= GetTreeCtrl() ;
	HTREEITEM hItem = THE_TV_CTRL.GetSelectedItem( );
	DWORD dLine = THE_TV_CTRL.GetItemData(hItem) ;
	vConsole->SelectLine(dLine) ;
	vTextLog->SelectLine(dLine) ; 

	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\logpage.h ===
/////////////////////////////////////////////////////////////////////////////
// logpage.h
//
// email	date		change
// briancr	11/10/94	created
//
// copyright 1994 Microsoft

// Interface of the CLogPage class

#include "settings.h"

/////////////////////////////////////////////////////////////////////////////
// CLogPage dialog

class CLogPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogPage)

// Construction
public:
	CLogPage();
	~CLogPage();

// Dialog Data
	//{{AFX_DATA(CLogPage)
	enum { IDD = IDD_LogTab };
	int		m_nMaxFail;
	int		m_bPost;
	int		m_bCom;
	CString		m_strConnector;
	CString		m_strBaudRate;
	int		m_bComments;
	CString	m_strResultsFile;
	CString	m_strSummaryFile;
	CString	m_strWorkDir;
	int		m_bDebugOutput;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogPage)
	afx_msg void OnLogToCom();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\portdoc.cpp ===
/////////////////////////////////////////////////////////////////////////////
// portdoc.cpp
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Implementation of the CViewportDoc class

#include "stdafx.h"
#include "portdoc.h"
#include "portview.h"					
#include "cafedrv.h"
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

extern CLogView * gLogView ;
/////////////////////////////////////////////////////////////////////////////
// CViewportDoc

IMPLEMENT_DYNCREATE(CViewportDoc, CDocument)

BEGIN_MESSAGE_MAP(CViewportDoc, CDocument)
	//{{AFX_MSG_MAP(CViewportDoc)
	ON_COMMAND(ID_EDIT_CLEARALL, DeleteContents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewportDoc construction/destruction

CViewportDoc::LineInfoType CViewportDoc::m_LineInfo[] = { 
	{ '0',  RGB(  0,   0,   0), settingHeaderFilter },	// header
	{ '1',  RGB(  0,   0, 150), settingSummaryFilter },	// summary
	{ '2',  RGB(  0, 128,   0), settingCommentsFilter },	// comments
	{ '3',  RGB(  0, 128, 128), settingResultsFilter },	// results
	{ '4',  RGB(255,   0,   0), settingFailureFilter },	// failure
	{ '5',  RGB(128,   0, 150), settingInfoFilter },		// info
	{ '6',  RGB(128, 128, 128), settingSeparatorFilter }, // separator
	{ '7',  RGB(  0,   0, 255), settingSuccessFilter },	// success
	{ '8',  RGB(100,  32,   0), settingStepFilter },	// step
	{'\0',	RGB(192, 192, 192), settingSelectedFilter }, //selected background
};

int CViewportDoc::nCount = 0;

CViewportDoc::CViewportDoc()
: m_nWidth(0),
  m_cCurrentAttribute(0),
  m_psettingsDoc(NULL)
{
	// store this instances count value (this must be done before the pipe is created, since this value is used to create a unique pipe name)
	m_nCount = nCount++;
	// store a system-wide unique id
	m_nId = ::GetTickCount()+m_nCount;

#ifdef NAMED_PIPES
	// set system-wide unique pipe name
	m_pipeViewport = "\\\\.\\pipe\\Pipe "+GetUniqueName();
	m_hPipeRead=m_hPipeRead=NULL;
#else
  BOOL bResult;
  
  bResult = CreatePipe(
    &m_hPipeRead,
    &m_hPipeWrite,
    0,  // security attributes
    0x4000);  // buffer suggestion
#endif


	// set system-wide unique event names
#ifdef NAMED_PIPES
	m_eventTerminate = "Terminate "+GetUniqueName();
	m_eventOverlapped = "Overlapped "+GetUniqueName();
#endif

	// get a pointer to the app
	CCAFEDriver *pApp = (CCAFEDriver*)AfxGetApp();

	// create the settings object and initialize settings
	m_psettingsDoc = new CSettings(pApp->GetSettings()->GetTextValue(settingCAFEKey)+"\\Viewport");
	InitializeSettings();

#ifdef NAMED_PIPES
	// create an event for signalling the worker thread
	m_hTerminate = ::CreateEvent(NULL, TRUE, FALSE, m_eventTerminate);

	// the event handle must be valid
	ASSERT(m_hTerminate);
	if (!m_hTerminate) {
		TRACE("CViewportDoc::CViewportDoc: unable to create terminate event for pipe thread\n");
	}
	else 
#endif
	{
		// create a worker thread to handle reading from the pipe
		DWORD dwThreadId;
		m_hthreadPipe = ::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CViewportDoc::WrapReadPipe, this, 0, &dwThreadId);
	}
}

CViewportDoc::~CViewportDoc()
{
#ifdef NAMED_PIPES
	// if the thread was created...
	if (m_hTerminate && m_hthreadPipe)
	{
		// terminate the thread
		::SetEvent(m_hTerminate);

		// wait for the thread to terminate
		if (WaitForSingleObject(m_hthreadPipe, 60000) != WAIT_OBJECT_0) {
			TRACE("CViewportDoc::~CViewportDoc: unable to terminate viewport thread\n");
			::TerminateThread(m_hthreadPipe, DWORD(-1));
		}
		::CloseHandle(m_hthreadPipe);
		::CloseHandle(m_hTerminate);
	}
#else
	if(m_hthreadPipe)
	{
		::TerminateThread(m_hthreadPipe, DWORD(-1));
		::CloseHandle(m_hthreadPipe);
	}
	// we must close the write end of the pipe first so that the thread reading from the pipe will exit
	if(m_hPipeWrite)
		::CloseHandle(m_hPipeWrite);
	if(m_hPipeRead)
		::CloseHandle(m_hPipeRead);
#endif

	// delete the settings object
	if (m_psettingsDoc) {
		delete m_psettingsDoc;
	}
}

BOOL CViewportDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	return TRUE;
}

BOOL CViewportDoc::OnOpenDocument(const char* pszPathName)
{
	CStdioFile file;
	 // Initialize the logview tree.
	m_pLogViewTree = 0;

	// get a pointer to the app
	CCAFEDriver *pApp = (CCAFEDriver*)AfxGetApp();

	if (file.Open(pszPathName, CFile::modeRead | CFile::typeText)) {
		ReadFile(&file);
		file.Close();
	}
	else {
		TRACE("CViewportDoc::OnOpenDocument: unable to open the viewport file for reading\n");
		pApp->ErrorMsg(IDS_ErrOpenViewportFile, pszPathName);
		return FALSE;
	}

	// set the title to the filename
	SetTitle(pszPathName);

	return TRUE;
}

BOOL CViewportDoc::OnSaveDocument(const char* pszPathName)
{
	CStdioFile file;

	// get a pointer to the app
	CCAFEDriver *pApp = (CCAFEDriver*)AfxGetApp();

	if (file.Open(pszPathName, CFile::modeCreate | CFile::modeWrite | CFile::typeText)) {
		WriteFile(&file);
		file.Close();
	}
	else {
		TRACE("CViewportDoc::OnSaveDocument: unable to open the viewport file for saving\n");
		pApp->ErrorMsg(IDS_ErrOpenViewportFile, pszPathName);
		return FALSE;
	}

	// set the title to the filename
	SetTitle(pszPathName);

	return TRUE;
}

void CViewportDoc::DeleteContents()
{
	m_aLines.RemoveAll();
	m_nWidth = 0;
	UpdateAllViews(NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CViewportDoc operations


void CViewportDoc::SetGenericTitle(LPCSTR szTitleRoot, LPCSTR szNumber)
{
  CString str(szTitleRoot);

  str += szNumber;

  SetTitle(str);
}


CString CViewportDoc::GetLine(int nLine)
{
	CString strLine;

	// the line must be valid
	ASSERT(nLine >= 0 && nLine < m_aFilteredLines.GetSize());

	// if the given line is out of range, put it in range
	if (nLine < 0) {
		nLine = 0;
	}
	if (nLine >= m_aFilteredLines.GetSize()) {
		nLine = m_aFilteredLines.GetSize() - 1;
	}

	// get the text part of the line
	strLine = GetLineText(m_aFilteredLines.GetAt(nLine));
	
	return strLine;
}

COLORREF CViewportDoc::GetColor(int nLine)
{
	int nIndex;

	// the line must be valid
	ASSERT(nLine >= 0 && nLine < m_aFilteredLines.GetSize());
	
	// if the given line is out of range, put it in range
	if (nLine < 0) {
		nLine = 0;
	}
	if (nLine >= m_aFilteredLines.GetSize()) {
		nLine = m_aFilteredLines.GetSize() - 1;
	}

	// get the index of this line's tag
	nIndex = GetTagIndex(m_aFilteredLines.GetAt(nLine));

	// return the color
	return m_LineInfo[nIndex].color;
}

COLORREF CViewportDoc::GetSelBkColor()
{
	const ndim=sizeof(m_LineInfo)/sizeof(LineInfoType);
	return m_LineInfo[ndim-1].color;	
}

BOOL CViewportDoc::GetFilter(UINT nId)
{
	int nIndex;

	// map the id of the filter control to the line info array
	nIndex = nId - IDM_ViewportHeaderFilter;

	// the index must be in range
	ASSERT(nIndex >= 0);
	if (nIndex < 0) {
		return FALSE;
	}

	return m_psettingsDoc->GetBooleanValue(m_LineInfo[nIndex].lpszSetting);
}

BOOL CViewportDoc::SetFilter(UINT nId, BOOL bFilter)
{
	int nIndex;

	// map the id of the filter control to the line info array
	nIndex = nId - IDM_ViewportHeaderFilter;

	// the index must be in range
	ASSERT(nIndex >= 0);
	if (nIndex < 0) {
		return FALSE;
	}

	// set the filter
	m_psettingsDoc->SetBooleanValue(m_LineInfo[nIndex].lpszSetting, bFilter);

	// save it in the registry
	m_psettingsDoc->WriteRegistry();

	// update the set of filtered lines
	FilterAllLines();

	// update the UI
	//UpdateAllViews(NULL);//REVIEW(chriskoz)impossible: selection is bogus (we dont have the selection "m_rSel1" here)

	return TRUE;
}

NodeTypes CViewportDoc::LineHasKeyWord(CString strLine)
{
	if(strLine.Find("Owned by") != -1)
	{
		int i = strLine.Find("Owned") ;
		szLogTreeLine = strLine.Mid(i) ;
		i = szLogTreeLine.Find("]") ;
		szLogTreeLine = szLogTreeLine.Left(i) ;
		szLogTreeLine.TrimRight() ;
		return SUBSUITE ;
	}
	if(strLine.Find("[--------------------< Test:") != -1) 
	{
		int i = strLine.Find("Test:") ;
		szLogTreeLine = strLine.Mid(i) ;
		i = szLogTreeLine.Find(">") ;
		szLogTreeLine = szLogTreeLine.Left(i) ;
		szLogTreeLine.TrimRight() ;
		return TESTCASE ; 
	}
	if(strLine.Find("Suite Summary") != -1) 
	{
		szLogTreeLine = "Suite Summary" ;
		return SUMMARY ;
	}
	if(strLine.Find("General Information") != -1) 
	{
		szLogTreeLine = "General Info.";
		return SUITE ;
	}
	if(strLine.Find("*** CRITICAL ERROR ***")!=-1) 
	{
		szLogTreeLine = "*CRITICAL ERROR" ;
		return FAILURE ;
	}
	if (strLine.Find("***FAILED***") !=-1)
	{
		szLogTreeLine = "* FAILED *" ;
		return FAILURE ;
	}

	return INVALID ;

}

/////////////////////////////////////////////////////////////////////////////
// CViewportDoc operations (internal)

BOOL CViewportDoc::InsertLine(int nLine, CString strLine)
{
	int i;
	BOOL bInserted;

	// the line to insert at must be valid
	ASSERT(nLine >= 0 && nLine <= m_aLines.GetSize());

	// if the given line is out of range, put it in range
	if (nLine < 0) {
		nLine = 0;
	}
	if (nLine > m_aLines.GetSize()) {
		nLine = m_aLines.GetSize();
	}

	// is this line longer that the currently longest line?
	m_nWidth = max(m_nWidth, strLine.GetLength());

	// insert the line
	m_aLines.InsertAt(nLine, strLine);

	NodeTypes KeyType ;
	if((KeyType =LineHasKeyWord(strLine))!= INVALID) // Does the line have any keywords we are interested in?
	{
		m_pLogViewTree->AddNewNode(KeyType,nLine,szLogTreeLine) ;
	}

	// can this line be added to the set of filtered lines?
	if (FilterOneLine(nLine)) {
		// iterate through the filtered lines
		for (i = 0, bInserted = FALSE; i < m_aFilteredLines.GetSize() && !bInserted; i++) {
			// if there's a line stored that has an index greater
			// than this one, insert it there
			if (m_aFilteredLines.GetAt(i) > nLine) {
				m_aFilteredLines.InsertAt(i, nLine);
				bInserted = TRUE;
			}
		}
		// did the line get inserted?
		if (!bInserted) {
			// add it at the end
			m_aFilteredLines.Add(nLine);
		}
	}

	return TRUE;
}

BOOL CViewportDoc::AddLine(CString strLine)
{
	int nIndex;

	// is this line longer that the currently longest line?
	m_nWidth = max(m_nWidth, strLine.GetLength());

	// add the line to the end of the array
	nIndex = m_aLines.Add(strLine);

	// can this line be added to the set of filtered lines?
	if (FilterOneLine(nIndex)) {
		m_aFilteredLines.Add(nIndex);
	}

	return TRUE;
}

BOOL CViewportDoc::InitializeSettings(void)
{
	ASSERT(m_psettingsDoc);

	// initialize default values
	m_psettingsDoc->SetBooleanValue(settingHeaderFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingSummaryFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingCommentsFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingResultsFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingFailureFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingInfoFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingSeparatorFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingSuccessFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingStepFilter, TRUE);
	m_psettingsDoc->SetBooleanValue(settingSelectedFilter, TRUE);

	// read values from the registry
	m_psettingsDoc->ReadRegistry();

	// write updated values to the registry
	m_psettingsDoc->WriteRegistry();

	return TRUE;
}

CString CViewportDoc::GetUniqueName(void)
{
	CString strName;

	strName.Format("Viewport %d", m_nId);

	return strName;
}


/////////////////////////////////////////////////////////////////////////////
// Tag operations (internal)

int CViewportDoc::GetTagIndex(int nLine)
{
	CString strLine;
	int i;

	// the line must be valid
	ASSERT(nLine >= 0 && nLine < m_aLines.GetSize());

	// if the given line is out of range, put it in range
	if (nLine < 0) {
		nLine = 0;
	}
	if (nLine >= m_aLines.GetSize()) {
		nLine = m_aLines.GetSize() - 1;
	}

	// get the string
	strLine = m_aLines.GetAt(nLine);

	// return the default index if there is no string
	if (strLine.IsEmpty()) {
		TRACE("CViewportDoc::GetTagIndex: string without tag\n");
		return 0;
	}

	// find the tag in the array of line info
	for (i = 0; m_LineInfo[i].tag != '\0'; i++) {
		if (strLine.GetAt(0) == m_LineInfo[i].tag) {
			break;
		}
	}
	// did we not find a valid tag? return the default index
	if (m_LineInfo[i].tag == '\0') {
		TRACE("CViewportDoc::GetTagIndex: string with invalid tag\n");
		return 0;
	}
	else {
		return i;
	}
}

CString CViewportDoc::GetLineText(int nLine)
{
	CString strLine;

	// the line must be valid
	ASSERT(nLine >= 0 && nLine < m_aLines.GetSize());

	// if the given line is out of range, put it in range
	if (nLine < 0) {
		nLine = 0;
	}
	if (nLine >= m_aLines.GetSize()) {
		nLine = m_aLines.GetSize() - 1;
	}

	// get the string
	strLine = m_aLines.GetAt(nLine);

	// return the string if it's empty
	if (strLine.IsEmpty()) {
		TRACE("CViewportDoc::GetTagIndex: string without tag\n");
		return strLine;
	}

	// skip the tag and return the real text part of the string
	#ifdef _DEBUG
		return strLine;
	#else
      return strLine.Mid(1);
	#endif // _DEBUG
}


/////////////////////////////////////////////////////////////////////////////
// Filter operations (internal)

BOOL CViewportDoc::FilterOneLine(int nLine)
{
	int nIndex;

	// the line must be valid
	ASSERT(nLine >= 0 && nLine < m_aLines.GetSize());

	// if the given line is out of range, put it in range
	if (nLine < 0) {
		nLine = 0;
	}
	if (nLine >= m_aLines.GetSize()) {
		nLine = m_aLines.GetSize() - 1;
	}

	// get the tag index for this line
	nIndex = GetTagIndex(nLine);

	// return the state of the filter for this line
	return m_psettingsDoc->GetBooleanValue(m_LineInfo[nIndex].lpszSetting);
}

BOOL CViewportDoc::FilterAllLines(void)
{
	int i;

	// clear the filtered lines array
	m_aFilteredLines.RemoveAll();

	// interate through all lines
	for (i = 0; i < m_aLines.GetSize(); i++) {
		if (FilterOneLine(i)) {
			m_aFilteredLines.Add(i);
		}
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Pipe operations (internal)

UINT CViewportDoc::WrapReadPipe(LPVOID pParam)  // a static function
{
  return ((CViewportDoc*)pParam)->ReadPipe();
}

UINT CViewportDoc::ReadPipe()
{
#undef THIS_FUNCTION
#define THIS_FUNCTION "CViewportDoc::ReadPipe:"
	HANDLE hPipe;
#ifdef NAMED_PIPES
	OVERLAPPED olPipe;

	HANDLE hTerminate;

	DWORD dwWaitResult;
	HANDLE hOverlapped;
#endif


	CString strBuf;
	CString strRemain;
	DWORD dwRead;
	BOOL bDone;


#ifdef NAMED_PIPES
	// open the termination event
	hTerminate = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, m_eventTerminate);

	// the handle must be valid
	ASSERT(hTerminate);
	if (!hTerminate) {
		TRACE(THIS_FUNCTION "unable to open the terminate event\n");
		return 1;
	}

	// create a pipe for communication to the viewport
	hPipe = ::CreateNamedPipe(GetPipeName(), PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, 1, 2048, 2048, 2000, NULL);
#else
	hPipe = m_hPipeRead;
#endif

	// the pipe must be valid
	ASSERT(hPipe != INVALID_HANDLE_VALUE && hPipe != NULL);
	if (hPipe == INVALID_HANDLE_VALUE || hPipe == NULL) {
		TRACE(THIS_FUNCTION "unable to open the read end of the pipe\n");
#ifdef NAMED_PIPES
		::CloseHandle(hTerminate);
#endif
		return 2;
	}

#ifdef NAMED_PIPES
	// create an event for the overlapped functions
	hOverlapped = ::CreateEvent(NULL, TRUE, FALSE, m_eventOverlapped);

	// the event handle must be valid
	ASSERT(hOverlapped);
	if (!hOverlapped) {
		TRACE(THIS_FUNCTION "unable to create the overlapped event\n");
		::CloseHandle(hTerminate);
		::CloseHandle(hPipe);
		return 3;
	}
#endif

#ifdef NAMED_PIPES

	// loop
	while (1)
	{	
		// initialize the overlapped structure
		olPipe.Offset = 0;
		olPipe.OffsetHigh = 0;
		olPipe.hEvent = hOverlapped;

		// indicate we want to wait until there's a connection to the pipe
		::ConnectNamedPipe(hPipe, &olPipe);

		if (::GetLastError() == ERROR_IO_PENDING) 
		{

			// wait for either the connection or termination
			HANDLE hObjects[] = { hOverlapped, hTerminate };
			dwWaitResult = ::WaitForMultipleObjects(sizeof(hObjects)/sizeof(HANDLE), hObjects, FALSE, INFINITE);

			// if we got some other notification besides the overlapped, terminate
			if (dwWaitResult != WAIT_OBJECT_0) {
				::CloseHandle(hTerminate);
				::CloseHandle(hPipe);
				::CloseHandle(hOverlapped);
				return 0;
			}

			// get the results of the connection
			if (!::GetOverlappedResult(hPipe, &olPipe, &dwRead, FALSE)) {
				TRACE(THIS_FUNCTION "error waiting for pipe connection (%d)\n", ::GetLastError());
				dwRead = 0;
			}

		}
#endif

		// read from the pipe until we're done reading
		for (bDone = FALSE; !bDone; )
		{
#ifdef NAMED_PIPES
			if (!::ReadFile(hPipe, strBuf.GetBuffer(255), 255, &dwRead, &olPipe)) 
#else
			if (!::ReadFile(hPipe, strBuf.GetBuffer(8), 8, &dwRead, 0)) 
#endif
				switch (::GetLastError())
				{  //error from ::ReadFile()
					case ERROR_BROKEN_PIPE: {
						TRACE(THIS_FUNCTION "ReadFile - ERROR_BROKEN_PIPE\n");
						bDone = TRUE;
						break;
					}
#ifdef NAMED_PIPES
					case ERROR_PIPE_LISTENING: {
						TRACE(THIS_FUNCTION "ReadFile - ERROR_PIPE_LISTENING\n");
						bDone = TRUE;
						break;
					}
					case ERROR_IO_PENDING:
					{
						// wait for either the read or termination
						HANDLE hObjects[] = { hOverlapped, hTerminate };
						dwWaitResult = ::WaitForMultipleObjects(sizeof(hObjects)/sizeof(HANDLE), hObjects, FALSE, INFINITE);

						// if we got some other notification besides the overlapped, terminate
						if (dwWaitResult != WAIT_OBJECT_0) {
							TRACE(THIS_FUNCTION "ReadFile - terminate event\n");
							::CloseHandle(hTerminate);
							::CloseHandle(hPipe);
							::CloseHandle(hOverlapped);
							return 0;
						}

						// get the number of bytes read
						if (!::GetOverlappedResult(hPipe, &olPipe, &dwRead, FALSE)) {
							TRACE(THIS_FUNCTION "GetOverlappedResult error (%d)\n", ::GetLastError());
							dwRead = 0;
						}
						break;
					}
#endif
					default:
						TRACE(THIS_FUNCTION "ReadFile - unknown error (%d)\n", ::GetLastError());
						break;
				}//error from ::ReadFile()
			// if we got some bytes to read...
			if (!bDone && dwRead > 0) {
				strBuf.ReleaseBuffer(dwRead);

				// add the data to the viewport
				ReadPipeData(strBuf, strRemain);
			}
		}//read loop from the pipe
#ifdef NAMED_PIPES
		// disconnect from this pipe
		::DisconnectNamedPipe(hPipe);
	} //while(1)
#endif

	return 0;
}

BOOL CViewportDoc::ReadPipeData(CString &strBuf, CString &strRemain, int nLine /*= -1*/)
{
	int nPos, nLen;
	CString strLine;

	CView* pView;
	CWnd* pViewWnd;

	// initialize nLine if not given
	if (nLine == -1)
		nLine = GetNumLines();

	// parse the data in the buffer
	// each line ends with a \n

	while ((nPos = strBuf.Find('\n')) != -1)
  {
		// store the line in the string array
		strLine = strRemain + strBuf.Left(nPos);

    nLen = strLine.GetLength();
    if ((nLen) && (strLine[nLen-1] == '\r'))  // if terminated with \r
    {
      strLine = strLine.Left(nLen - 1);  // axe the \r
    }

    if ((!strLine.IsEmpty()) && (strLine[0] == '\xff'))
    {
      // pump out unused attributes
      
      while ((strLine.GetLength() >= 4) && (strLine[2] == '\xff'))  // while we have leading unused attributes
        strLine = strLine.Mid(2);  // axe 'em

      // use the final one

      m_cCurrentAttribute = strLine[1];  // grab the attribute
      strLine = strLine.Mid(1);  // remove the signal char
    }
    else
      strLine = (char)m_cCurrentAttribute + strLine;

		InsertLine(nLine, strLine);

		// clear the remain string
		strRemain.Empty();

		// remove the stored string from the buffer
		strBuf = strBuf.Mid(nPos+1);

		// iterate through all views associated with this document
		for (POSITION pos = GetFirstViewPosition(); pos != NULL; ) {
			pView = GetNextView(pos);

			// get the CWnd* for the view (can't just use the CView* because this
			// thread doesn't have access to the handle map in the main thread
			// (MFC asserts)
			pViewWnd = (CViewportView*)CWnd::FromHandle(pView->m_hWnd);

#ifdef MST_BUG
			// update the view
			pViewWnd->SendMessage(WM_UPDATE_FROM_PIPE, 0, nLine);

#endif // MST_BUG
		}

		// increment the line count
		nLine++;
	}

	// store the remaining string for the next buffer read
	strRemain += strBuf;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// File operations (internal)

BOOL CViewportDoc::ReadFile(CStdioFile* pfile, int nLine /*= -1*/)
{
	CString strLine;

	// the file ptr must be valid
	ASSERT(pfile);

	// initialize nLine if not given
	if (nLine == -1) {
		nLine = GetNumLines();
	}

	while (pfile->ReadString(strLine.GetBuffer(1024), 1024)) {
		InsertLine(nLine++, strLine);
	}

	UpdateAllViews(NULL);

	return TRUE;
}

BOOL CViewportDoc::WriteFile(CStdioFile* pfile, int nBegLine /*= -1*/, int nEndLine /*= -1*/)
{
	int i;
	CString strLine;

	// the file ptr must be valid
	ASSERT(pfile);

	// initialize nBegLine and nEndLine, if not given
	if (nBegLine == -1) {
		nBegLine = 0;
	}
	if (nEndLine == -1) {
		nEndLine = GetNumLines();
	}

	for (i = nBegLine; i < nEndLine; i++) {
		strLine = GetLine(i) + "\n";					// add "\r\n" if this is not a stdio file
		pfile->WriteString(strLine);
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CViewportDoc serialization

void CViewportDoc::Serialize(CArchive& ar)
{
	ASSERT(FALSE);		// REVIEW(davidga): I think OnOpenDocument and OnSaveDocument do everything I need
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}


/////////////////////////////////////////////////////////////////////////////
// CViewportDoc diagnostics

#ifdef _DEBUG
void CViewportDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CViewportDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}

#endif //_DEBUG

void CViewportDoc::OnCloseDocument()
{
  CDocument::OnCloseDocument() ;
  return ;
}
/////////////////////////////////////////////////////////////////////////////
// CViewportDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\portdoc.h ===
/////////////////////////////////////////////////////////////////////////////
// portdoc.h
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Interface of the CViewportDoc class

#ifndef __PORTDOC_H__
#define __PORTDOC_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#undef NAMED_PIPES

#include "settings.h"
#include "logview.h"

/////////////////////////////////////////////////////////////////////////////
// CViewportDoc

class CViewportDoc : public CDocument
{
protected: // create from serialization only
	CViewportDoc();
	DECLARE_DYNCREATE(CViewportDoc)

// Overrides
	virtual void OnCloseDocument();

// operations
public:

	CString GetLine(int line);
	COLORREF GetColor(int line);
	COLORREF GetSelBkColor();

	int GetNumLines() const		{ return m_aFilteredLines.GetSize(); }
	int GetWidth() const		{ return m_nWidth; }

#ifdef NAMED_PIPES
	CString GetPipeName(void)	{ return m_pipeViewport; }
#endif //#else
	HANDLE GetWriteHandle(void)	{ return m_hPipeWrite; }
//#endif

	BOOL GetFilter(UINT nId);
	BOOL SetFilter(UINT nId, BOOL bFilter);

  void SetGenericTitle(LPCSTR szTitleRoot, LPCSTR szNumber);

public:

// operations (internal)
protected:
	BOOL InsertLine(int nLine, CString strLine);
	BOOL AddLine(CString strLine);
	BOOL InitializeSettings(void);
	NodeTypes LineHasKeyWord(CString strLine) ;

	CString GetUniqueName(void);

// Tag operations (internal)
protected:
	int GetTagIndex(int nLine);
	CString GetLineText(int nLine);

// Filter operations (internal)
protected:
	BOOL FilterOneLine(int nLine);
	BOOL FilterAllLines(void);

// Pipe operations (internal)
protected:
	static UINT WrapReadPipe(LPVOID pParam);
	UINT ReadPipe(void);
	BOOL ReadPipeData(CString &strBuf, CString &strRemain, int nLine = -1);

// File operations (internal)
protected:
	BOOL ReadFile(CStdioFile* pfile, int nLine = -1);
	BOOL WriteFile(CStdioFile* pfile, int nBegLine = -1, int nEndLine = -1);


// data types (internal)
protected:
	struct LineInfoType {
		char tag;
		COLORREF color;
		LPCSTR lpszSetting;
	};

// data
protected:
	static LineInfoType m_LineInfo[];

// Implementation
public:
	virtual ~CViewportDoc();
	virtual void Serialize(CArchive& ar);	// overridden for document i/o
#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif
protected:
	virtual	BOOL OnNewDocument();
	virtual	void DeleteContents();
	virtual	BOOL OnOpenDocument(const char* pszPathName);
	virtual	BOOL OnSaveDocument(const char* pszPathName);

// data
public:

	CLogView * m_pLogViewTree;

// Data
protected:
	CStringArray m_aLines;
	CArray<int, int> m_aFilteredLines;
	HANDLE m_hthreadPipe;
	CString szLogTreeLine ;
	CSettings* m_psettingsDoc;
	int	m_nWidth;
	int m_nCount;
	int m_nId;
#ifdef NAMED_PIPES
	CString m_pipeViewport;
	CString m_eventTerminate;
	HANDLE m_hTerminate;
#endif //#else
	HANDLE m_hPipeRead, m_hPipeWrite;
//#endif
	CString m_eventOverlapped;

	static int nCount;

  char m_cCurrentAttribute;

// Generated message map functions
protected:
	//{{AFX_MSG(CViewportDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__PORTDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\mainfrm.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	MAINFRM.CPP
//
//	Created by :			Date :
//		DavidGa					8/13/93
//
//	Description :
//		Implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mainfrm.h"
#include "cafedrv.h"
#include "tbdlg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define TOOLBAR_KEY "Toolbars"

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_CLOSE()
    ON_COMMAND(IDM_OptionsToolbars, OnOptionsToolbars)
	//}}AFX_MSG_MAP
	ON_COMMAND(IDM_HelpContents, CMDIFrameWnd::OnHelpIndex)

	ON_CONTROL(CBN_SELCHANGE, IDC_CAFEBarToolset, OnToolset)
	ON_CONTROL(CBN_SELCHANGE, IDC_CAFEBarBuildType, OnBuildType)
	ON_CONTROL(CBN_SELCHANGE, IDC_CAFEBarLanguage, OnLanguage)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,			// status line indicator
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
: m_psettingsWnd(NULL)
{
	// get a pointer to the app
	CCAFEDriver *pApp = ((CCAFEDriver *)AfxGetApp());

	m_ptbCAFEBar = new CCAFEBar(pApp->GetSettings());
	m_ptbSubSuiteBar = new CSubSuiteBar;
	m_ptbViewportBar = new CViewportBar;
}

CMainFrame::~CMainFrame()
{
	// delete the toolbars
	delete m_ptbCAFEBar;
	delete m_ptbSubSuiteBar;
	delete m_ptbViewportBar;

	// delete the settings object
	if (m_psettingsWnd) {
		delete m_psettingsWnd;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame operations

/////////////////////////////////////////////////////////////////////////////
// CMainFrame initialization

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// create toolbars and status bar
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_ptbCAFEBar->CreateBar(this)) {
		return -1;
	}
	if (!m_ptbSubSuiteBar->CreateBar(this)) {
		return -1;
	}
	if (!m_ptbViewportBar->CreateBar(this)) {
		return -1;
	}

	if (!CreateStatusBar())
		return -1;

	// enable docking in this frame
	EnableDocking(CBRS_ALIGN_ANY);

	// initialize settings
	InitializeSettings();

	// position this frame
	MoveWindow(m_psettingsWnd->GetIntValue(settingCAFEWndX),
			m_psettingsWnd->GetIntValue(settingCAFEWndY),
			m_psettingsWnd->GetIntValue(settingCAFEWndWidth),
			m_psettingsWnd->GetIntValue(settingCAFEWndHeight));

	// default to docking all the toolbars
	DockControlBar(m_ptbCAFEBar);
	DockControlBar(m_ptbSubSuiteBar);
	DockControlBar(m_ptbViewportBar);

	// REVIEW(briancr): hide the viewport toolbar, since it's not supported yet
//	ShowControlBar(m_ptbViewportBar, FALSE, FALSE);

	LoadBarState(TOOLBAR_KEY);

	return 0;
}

void CMainFrame::OnClose() 
{
	// save the toolbar settings
	SaveBarState(TOOLBAR_KEY);

	// update settings based on UI
	UpdateSettings();

	// call the base class
	CMDIFrameWnd::OnClose();
}

/////////////////////////////////////////////////////////////////////////////
// Operations

/////////////////////////////////////////////////////////////////////////////
// Operations (internal)

BOOL CMainFrame::InitializeSettings(void)
{
	// get a pointer to the app
	CCAFEDriver *pApp = ((CCAFEDriver *)AfxGetApp());

	// if the window settings object already exists, delete it
	if (m_psettingsWnd) {
		delete m_psettingsWnd;
	}

	// create a new window settings object
	m_psettingsWnd = new CSettings(pApp->GetSettings()->GetTextValue(settingCAFEKey)+"\\Windows");

	// set up window defaults
	m_psettingsWnd->SetIntValue(settingCAFEWndX, 10);
	m_psettingsWnd->SetIntValue(settingCAFEWndY, 10);
	m_psettingsWnd->SetIntValue(settingCAFEWndWidth, 700);
	m_psettingsWnd->SetIntValue(settingCAFEWndHeight, 600);

	// read registry settings
	m_psettingsWnd->ReadRegistry();
	// write the settings back out to initialize registry
	m_psettingsWnd->WriteRegistry();

	#ifdef _DEBUG
		m_psettingsWnd->DumpSettings("Window settings");
	#endif // _DEBUG

	return TRUE;
}

BOOL CMainFrame::UpdateSettings(void)
{
	CRect rectWnd;

	// the settings object must be valid
	ASSERT(m_psettingsWnd);
	if (!m_psettingsWnd) {
		return FALSE;
	}

	// update frame window settings
	GetWindowRect(&rectWnd);
	m_psettingsWnd->SetIntValue(settingCAFEWndX, rectWnd.left);
	m_psettingsWnd->SetIntValue(settingCAFEWndY, rectWnd.top);
	m_psettingsWnd->SetIntValue(settingCAFEWndWidth, rectWnd.Width());
	m_psettingsWnd->SetIntValue(settingCAFEWndHeight, rectWnd.Height());

	// write settings to the registry
	m_psettingsWnd->WriteRegistry();

	return TRUE;
}

BOOL CMainFrame::CreateStatusBar(void)
{
	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE("Failed to create status bar\n");
		return FALSE;		// fail to create
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnOptionsToolbars()
{
	CToolbarsDlg dlgToolbars;

	// if the style says the toolbar is visible then it is visible.
	dlgToolbars.m_bShowCAFEToolbar = ((m_ptbCAFEBar->GetStyle() & WS_VISIBLE) != 0);
	dlgToolbars.m_bShowSubSuiteToolbar = ((m_ptbSubSuiteBar->GetStyle() & WS_VISIBLE) != 0);
	dlgToolbars.m_bShowViewportToolbar = ((m_ptbViewportBar->GetStyle() & WS_VISIBLE) != 0);
	dlgToolbars.m_bShowStatusBar = ((m_wndStatusBar.GetStyle() & WS_VISIBLE) != 0);

	if (dlgToolbars.DoModal() == IDOK) {
		ShowControlBar(m_ptbCAFEBar, dlgToolbars.m_bShowCAFEToolbar, FALSE);
		ShowControlBar(m_ptbSubSuiteBar, dlgToolbars.m_bShowSubSuiteToolbar, FALSE);
		ShowControlBar(m_ptbViewportBar, dlgToolbars.m_bShowViewportToolbar, FALSE);
		ShowControlBar(&m_wndStatusBar, dlgToolbars.m_bShowStatusBar, FALSE);
	}
}

void CMainFrame::OnToolset(void)
{
	m_ptbCAFEBar->UpdateToolset();
}

void CMainFrame::OnBuildType(void)
{
	m_ptbCAFEBar->UpdateBuildType();
}

void CMainFrame::OnLanguage(void)
{
	m_ptbCAFEBar->UpdateLanguage();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\mainfrm.h ===
///////////////////////////////////////////////////////////////////////////////
//	MAINFRM.H
//
//	Created by :			Date :
//		DavidGa					8/13/93
//
//	Description :
//		Declaration of the CMainFrame class
//

#ifndef __MAINFRM_H__
#define __MAINFRM_H__

#ifndef __AFXWIN_H__
	#error include 'cafe.h' before including this file for PCH
#endif

#include "settings.h"
#include "suitebar.h"
#include "cafebar.h"
#include "vwprtbar.h"

///////////////////////////////////////////////////////////////////////////////
// CMainFrame class

class CMainFrame : public CMDIFrameWnd
{
public:
	CMainFrame();

	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:
	CSettings* GetSettings(void)			{ ASSERT(m_psettingsWnd); return m_psettingsWnd; }

private:
	BOOL CreateStatusBar(void);
	BOOL InitializeSettings(void);
	BOOL UpdateSettings(void);

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif

// data
protected:
	CCAFEBar* m_ptbCAFEBar;
	CSubSuiteBar* m_ptbSubSuiteBar;
	CViewportBar* m_ptbViewportBar;
	CStatusBar m_wndStatusBar;
	CSettings* m_psettingsWnd;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnOptionsToolbars();
	afx_msg void OnClose();
	//}}AFX_MSG
	afx_msg void OnToolset(void);
	afx_msg void OnBuildType(void);
	afx_msg void OnLanguage(void);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif //__MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\statepg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	statepg.cpp
//
//	Created by :			Date :
//		BrianCr				08/07/95
//
//	Description :
//		Implementation of the CStatePage class
//

#include "stdafx.h"
#include "statepg.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CStatePage dialog

IMPLEMENT_DYNCREATE(CStatePage, CPropertyPage)

CStatePage::CStatePage(CSuiteDoc* pSuiteDoc /*= NULL*/)
	: CPropertyPage(CStatePage::IDD),
	  m_pSuiteDoc(pSuiteDoc)
{
	// the doc must be valid
	ASSERT(m_pSuiteDoc);

	//{{AFX_DATA_INIT(CStatePage)
	//}}AFX_DATA_INIT
}

CStatePage::~CStatePage()
{
}

void CStatePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatePage)
	//}}AFX_DATA_MAP
}

BOOL CStatePage::OnSetActive(void)
{
	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// fill the state list
	FillStateList();

	return TRUE;
}


BEGIN_MESSAGE_MAP(CStatePage, CPropertyPage)
	//{{AFX_MSG_MAP(CStatePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg message handlers

void CStatePage::OnOK() 
{
	CDialog::OnOK();
}

void CStatePage::FillStateList(void)
{
	// get the tests run list box
	CListBox* plbState = (CListBox*)GetDlgItem(IDL_CurrentState);

	// empty the list box
	plbState->ResetContent();

	// the state is only valid if we're randomizing
	if (m_pSuiteDoc->GetRandomize()) {
		// get the state
		CState* pState = m_pSuiteDoc->GetCurrentState();

		// get the name of the state
		CString strState = pState->GetName();
		strState.TrimLeft();
		strState.TrimRight();

		// add the name to the list box (each state is separated by a comma)
		while (!strState.IsEmpty()) {
			strState.TrimLeft();
			int nEndPos = strState.Find(_T(','));
			if (nEndPos == -1) {
				nEndPos = strState.GetLength();
			}
			plbState->AddString(strState.Left(nEndPos));
			strState = strState.Mid(nEndPos+1);
		}
	}
	else {
		plbState->AddString("No current state");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\portview.h ===
/////////////////////////////////////////////////////////////////////////////
// portview.h
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Interface of the CViewportView class

#ifndef __PORTVIEW_H__
#define __PORTVIEW_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#include "logview.h"
#include "portdoc.h"

///////////////////////////////////////////////////////////////////////////////
//	Syntax Coloring struct and enum

struct SyntaxColor
{
	LPCSTR szStart;
	LPCSTR szEnd;
	int scType;		// enum
	COLORREF color;
};

#define WM_UPDATE_FROM_PIPE WM_USER + 1

///////////////////////////////////////////////////////////////////////////////
//	CViewportView class

class CViewportView : public CView
{
protected: // create from serialization only
	CViewportView();
	DECLARE_DYNCREATE(CViewportView)

// Data
public:
	CFont m_font;
	int m_cxFont, m_cyFont;
	int m_cColsInView, m_cLinesInView;
	int m_rSel1, m_cSel1;	// row and column of beginning of selection
	int m_rSel2, m_cSel2;	// row and column of end of selection
#define NUM_TABS	10
	int m_aTabs[NUM_TABS];
	int m_cxTabInterval;
	int m_cxTabAdjust;
	CString m_strFind;
	CSize m_sizeFont;

private:
	BOOL selecting; //are we in selecting mode?
// Attributes
public:
	CViewportDoc* GetDocument();

/*
// Drawing Utilities
public:
	int ColorText(CDC* pDC, int x, int y, LPCSTR sz);
	int ColorTextLeft(CDC* pDC, int x, int y, CString& str, int left);
	int ColorTextColor(CDC* pDC, int x, int y, CString& str, int len, COLORREF rgb);
	int ColorTextRight(CDC* pDC, int x, int y, CString& str, int right);
	int TextOutShift(CDC* pDC, int x, int y, LPCSTR sz);
	int GetNextTab(int x);
	inline void AdjustTabs(int cx = 0)
		{	m_cxTabAdjust = cx; }

*/

// Implementation
public:
	virtual ~CViewportView();
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual void OnInitialUpdate();
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	// Need to call it from SuiteDoc.
	void SelectLine(int n);			 

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// operations (internal)
	BOOL DrawLine(CDC* pDC, int nLineX, int nLineY, COLORREF color, CString& strLine);

// Scrolling utilities
protected:
	void UpdateScrollbars(int hMax = -1, int hPos = -1, int vMax = -1, int vPos = -1);

// Printing support
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

// data structures (internal)
protected:
	struct LineType {
		COLORREF color;
		CString strSetting;
		LineType(COLORREF c, CString str) : color(c), strSetting(str) { }
	};

// data
protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CViewportView)
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnEditMark();
	afx_msg void OnUpdateEditMark(CCmdUI* pCmdUI);
	afx_msg void OnSelectAll();
	afx_msg void OnUpdateSelectAll(CCmdUI* pCmdUI);
	afx_msg void OnViewportFilter(UINT nId);
	afx_msg void OnUpdateViewportFilter(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
//	LRESULT OnAppendLine(WPARAM wParam, LPARAM lParam);
	LRESULT OnUpdateFromPipe(WPARAM wParam, LPARAM lParam);
};

#ifndef _DEBUG	// debug version in portview.cpp
inline CViewportDoc* CViewportView::GetDocument()
   { return (CViewportDoc*) m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

#endif //__PORTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\statepg.h ===
///////////////////////////////////////////////////////////////////////////////
//	statepg.h
//
//	Created by :			Date :
//		BrianCr				08/07/95
//
//	Description :
//		Definition of the CStatePage class
//

#ifndef __STATEPG_H__
#define __STATEPG_H__

#include "caferes.h"
#include "suitedoc.h"

/////////////////////////////////////////////////////////////////////////////
// CStatePage dialog

class CStatePage: public CPropertyPage
{
	DECLARE_DYNCREATE(CStatePage)
// Construction
public:
	CStatePage(CSuiteDoc* pSuiteDoc = NULL);
	~CStatePage();

// Dialog Data
	//{{AFX_DATA(CStatePage)
	enum { IDD = IDD_CurrentState };
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatePage)
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStatePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void FillStateList(void);

// data
protected:
	CSuiteDoc* m_pSuiteDoc;
};

#endif // __STATEPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\portview.cpp ===
/////////////////////////////////////////////////////////////////////////////
// portview.cpp
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Implementation of the CViewportView class

#include "stdafx.h"
#include "portdoc.h"
#include "portview.h"
#include "caferes.h"
#include "..\support\guitools\testutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CViewportView

IMPLEMENT_DYNCREATE(CViewportView, CView)

BEGIN_MESSAGE_MAP(CViewportView, CView)
	//{{AFX_MSG_MAP(CViewportView)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_WM_CREATE()
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	ON_WM_SIZE()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_COMMAND(ID_EDIT_MARK, OnEditMark)
	ON_UPDATE_COMMAND_UI(ID_EDIT_MARK, OnUpdateEditMark)
	ON_COMMAND(ID_SELECT_ALL, OnSelectAll)
	ON_UPDATE_COMMAND_UI(ID_SELECT_ALL, OnUpdateSelectAll)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
	ON_COMMAND_RANGE(IDM_ViewportHeaderFilter, IDM_ViewportStepFilter, OnViewportFilter)
	ON_UPDATE_COMMAND_UI_RANGE(IDM_ViewportHeaderFilter, IDM_ViewportStepFilter, OnUpdateViewportFilter)
	ON_MESSAGE(WM_UPDATE_FROM_PIPE, OnUpdateFromPipe)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewportView construction/destruction

CViewportView::CViewportView()
{
	m_cLinesInView = 0;
	m_cxFont = m_cyFont = 0;
	m_rSel1 = m_cSel1 = 0;		// selection starts at top-left
	m_rSel2 = m_cSel2 = 0;		// current line/col == starting line/col by default
	selecting = FALSE;

	m_cxTabInterval = 50;		// set default tab stops
	m_cxTabAdjust = 0;
	for( int iTab = 0; iTab < NUM_TABS; iTab++ )
		m_aTabs[iTab] = -1;
	m_aTabs[0] = 250;
}

CViewportView::~CViewportView()
{
}

int CViewportView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	int iFnt = 0;
	BYTE bFontType = ANSI_CHARSET;

	lpCreateStruct->style |= WS_HSCROLL | WS_VSCROLL;
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;
	// for JPN we are going to pump the font up
	if (GetSystem() & SYSTEM_JAPAN)
	{
		iFnt = 8;
		bFontType = DEFAULT_CHARSET;
	}

	m_font.CreateFont( iFnt,				// height
			0,								// width
			0,								// escapement
			0,								// orientation
			FW_NORMAL,						// weight
			FALSE,							// italic
			FALSE,							// underline
			FALSE,							// strikeout
			bFontType,						// char set
			OUT_DEFAULT_PRECIS,				// out precision
			CLIP_DEFAULT_PRECIS,			// clip precision
			DEFAULT_QUALITY,				// quality
			FIXED_PITCH | FF_DONTCARE,		// pitch and family
			"System" );						// face name
	
  

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CViewportView drawing


void CViewportView::OnInitialUpdate()
{
	CViewportDoc* pDoc = GetDocument();
	UpdateScrollbars(pDoc->GetWidth(), 0, pDoc->GetWidth(), 0);
}

void CViewportView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
	int nVScrollPos;
	int nUpdateLine;
	CRect rectInvalid;
	CRect rectClient;

	// get a pointer to the document
	CViewportDoc* pDoc = GetDocument();

	if (lHint) {
		m_rSel2 = lHint;
	}
	if(selecting == FALSE)
	{
		m_rSel1 = m_rSel2;
	}

	// put the selected line near the bottom of the window
	nVScrollPos = m_rSel2 - m_cLinesInView + 1;
	if (nVScrollPos < 0) {
		nVScrollPos = 0;
	}
	UpdateScrollbars(pDoc->GetNumLines()-1, nVScrollPos, pDoc->GetWidth(), 0);

	// scroll the window by a line
	if (pDoc->GetNumLines() > m_cLinesInView)
		ScrollWindow(0, -m_sizeFont.cy, NULL, NULL);

	// get the size of the window
	GetClientRect(rectClient);

	// figure the rectangle to invalidate
	
	// get the line we're updating
	// it's either the line passed in or the last line in the window
	// (-1 because we've already scrolled up by a line)
	nUpdateLine = (lHint >= m_cLinesInView) ? m_cLinesInView - 1 : lHint;
	// need to include the previous line (to erase the selection)
	rectInvalid.top = (nUpdateLine-1)*m_sizeFont.cy;
	if (rectInvalid.top < 0)
		rectInvalid.top = 0;
	rectInvalid.left = 0;
	rectInvalid.bottom = (nUpdateLine+1)*m_sizeFont.cy;
	rectInvalid.right = rectClient.right;
	InvalidateRect(rectInvalid, FALSE);

//	Invalidate(FALSE);
	
	UNREFERENCED_PARAMETER(pSender);
	UNREFERENCED_PARAMETER(pHint);
}

LRESULT CViewportView::OnUpdateFromPipe(WPARAM wParam, LPARAM lParam)
{
	OnUpdate(NULL, lParam, NULL);

	return TRUE;

	UNREFERENCED_PARAMETER(wParam);
}


#define LEFT	2		// left margin

void CViewportView::OnDraw(CDC* pDC)
{
	int nTopDataLine;
	int nLeftPos;
	int nTopScreenLine;
	int nBottomScreenLine;
	CRect rectClip;
	int nLine;
	CString strLine;

	CViewportDoc* pDoc = GetDocument();

	int startsel=m_rSel1,endsel=m_rSel2;
	if(m_rSel1 > m_rSel2)
	{
		startsel=m_rSel2;endsel=m_rSel1;
	}

	// determine the range of lines currently visible (scrolled position)
	
	// get the top line into the data from the vertical scroll bar position
	nTopDataLine = GetScrollPos(SB_VERT);
	ASSERT(nTopDataLine >= 0);

	// determine the left position of the lines
	nLeftPos = -GetScrollPos(SB_HORZ);

	// determine the range of lines in the clipping rectangle (zero-based)

	// get the clipping rectangle
	pDC->GetClipBox(rectClip);

	// figure the top and bottom screen lines in the clipping rectangle
	nTopScreenLine = rectClip.top / m_sizeFont.cy;
	nBottomScreenLine = rectClip.bottom / m_sizeFont.cy + 1;

	// paint the background
	// REVIEW(chriskoz): White. Do we need customization here?
	CBrush brWhite(RGB(255, 255, 255));
	pDC->FillRect(&rectClip, &brWhite);
	// selected lines backgroud is "GetSelBkColor()" (gray by default)
	rectClip.top=m_sizeFont.cy * (startsel - nTopDataLine);
	rectClip.bottom=rectClip.top + (endsel-startsel+1)*m_sizeFont.cy;
	CBrush brGray(pDoc->GetSelBkColor());
	pDC->FillRect(&rectClip, &brGray);

	COLORREF OldColor;
	// draw each line in the clipping rectangle
	for (nLine = nTopDataLine + nTopScreenLine; nLine < pDoc->GetNumLines() && (nLine - nTopDataLine) < nBottomScreenLine; nLine++)
	{
		strLine = pDoc->GetLine(nLine);
		if(startsel<=nLine && nLine <= endsel) //inside selection
			OldColor = pDC->SetBkColor(pDoc->GetSelBkColor());
		DrawLine(pDC, nLeftPos, nLine - nTopDataLine, pDoc->GetColor(nLine), strLine);
		if(startsel<=nLine && nLine <= endsel) //inside selection
			pDC->SetBkColor(OldColor);
	}
	// invert the edges of curent line
	rectClip.top = m_sizeFont.cy * (m_rSel2 - nTopDataLine);
	pDC->BitBlt(rectClip.left, rectClip.top, rectClip.Width(), 1, pDC, 0, 0, DSTINVERT);
	pDC->BitBlt(rectClip.left, rectClip.top + m_sizeFont.cy, rectClip.Width(), 1, pDC, 0, 0, DSTINVERT);

}

BOOL CViewportView::DrawLine(CDC* pDC, int nLineX, int nLineY, COLORREF color, CString& strLine)
{
	CFont* pOldFont;
	COLORREF OldColor;
	int x;
	int y;

	// convert the line's x position into window coordinates (based on the font size)
	x = nLineX * m_sizeFont.cx;

	// conver the line's y position into window coordinates (based on the font size)
	y = nLineY * m_sizeFont.cy;

	// select the font to use and the color
	pOldFont = pDC->SelectObject(&m_font);
	OldColor = pDC->SetTextColor(color);

	// draw the text
	pDC->TabbedTextOut(x, y, strLine, strLine.GetLength(), 0, NULL, 0);
//	pDC->TextOut(x, y, strLine);

	// select the old font and color
	pDC->SelectObject(pOldFont);
	pDC->SetTextColor(OldColor);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CViewportView printing

BOOL CViewportView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CViewportView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CViewportView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}




/////////////////////////////////////////////////////////////////////////////
// CViewportView diagnostics

#ifdef _DEBUG
void CViewportView::AssertValid() const
{
	CView::AssertValid();
}

void CViewportView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CViewportDoc* CViewportView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CViewportDoc)));
	return (CViewportDoc*) m_pDocument;
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CViewportView message handlers

void CViewportView::OnEditCopy()
{
	if(m_rSel1>=0 && m_rSel1 < GetDocument()->GetNumLines() &&
		m_rSel2>=0 && m_rSel2 < GetDocument()->GetNumLines() )
	{
		int startsel=m_rSel1,endsel=m_rSel2;
		CString lineset;
		if(m_rSel1 > m_rSel2)
		{
			startsel=m_rSel2;endsel=m_rSel1;
		}
		while(startsel <= endsel)
		{
			lineset=lineset + GetDocument()->GetLine(startsel) + "\r\n";
			startsel++;
		}
		SetClipText(lineset);
		if(m_rSel1 != m_rSel2)
			InvalidateRect(NULL); //REVIEW(chriskoz): do we need to invalidate whole screen?
	}
	m_rSel1=m_rSel2;
	selecting=FALSE; //leaving the selecting mode
}

void CViewportView::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	
	UNREFERENCED_PARAMETER(pCmdUI);
}

/////////////////////////////////////////////////////////////////////////////
// CViewportView scrolling

void CViewportView::UpdateScrollbars(int vMax, int vPos, int hMax, int hPos)
{
	if( hMax >= 0)
		SetScrollRange(SB_HORZ, 0, hMax < 0 ? 0 : hMax);
	if( hPos >= 0)
		SetScrollPos(SB_HORZ, hPos < 0 ? 0 : hPos);
	if( vMax >= 0)
		SetScrollRange(SB_VERT, 0, vMax < 0 ? 0 : vMax);
	if( vPos >= 0)
		SetScrollPos(SB_VERT, vPos < 0 ? 0 : vPos);
}

void CViewportView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CViewportDoc* pDoc = GetDocument();

	ASSERT( pScrollBar == NULL );
	int vPos = GetScrollPos(SB_VERT);
	int vNew = vPos;
	switch( nSBCode )
	{
		case SB_LINEDOWN:
			vNew++;
			break;
		case SB_LINEUP:
			vNew--;
			break;
		case SB_PAGEDOWN:
			vNew += m_cLinesInView / 2;
			break;
		case SB_PAGEUP:
			vNew -= m_cLinesInView / 2;
			break;
		case SB_BOTTOM:
			vNew = pDoc->GetNumLines();
			break;
		case SB_TOP:
			vNew = 0;
			break;
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			vNew = nPos;
			break;
		case SB_ENDSCROLL:	// REVIEW(davidga): not quite sure what to do with this
		default:
			return;
	}
	if( vNew > pDoc->GetNumLines() )
		vNew = pDoc->GetNumLines();
	else if( vNew < 0 )
		vNew = 0;

	ASSERT( m_cyFont != 0 );
	UpdateWindow();
	ScrollWindow(0, (vPos - vNew) * m_cyFont, NULL, NULL);
	SetScrollPos(SB_VERT, vNew);

	CView::OnVScroll(nSBCode, nPos, pScrollBar);
}

void CViewportView::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CViewportDoc* pDoc = GetDocument();

	ASSERT( pScrollBar == NULL );
	int hPos = GetScrollPos(SB_HORZ);
	int hNew = hPos;
	switch( nSBCode )
	{
		case SB_LINERIGHT:
			hNew++;
			break;
		case SB_LINELEFT:
			hNew--;
			break;
		case SB_PAGERIGHT:
			hNew += m_cColsInView / 2;
			break;
		case SB_PAGELEFT:
			hNew -= m_cColsInView / 2;
			break;
		case SB_RIGHT:
			if( (hNew = pDoc->GetWidth() - m_cColsInView + 1) < 0 )
				hNew = 0;
			break;
		case SB_LEFT:
			hNew = 0;
			break;
		case SB_THUMBPOSITION:
		case SB_THUMBTRACK:
			hNew = nPos;
			break;
		case SB_ENDSCROLL:	// REVIEW(davidga): not quite sure what to do with this
		default:
			return;
	}
	if( hNew > pDoc->GetWidth() )
		hNew = pDoc->GetWidth();
	else if( hNew < 0 )
		hNew = 0;

	ASSERT( m_cxFont != 0 );
	UpdateWindow();
	ScrollWindow((hPos - hNew) * m_cxFont, 0, NULL, NULL);
	SetScrollPos(SB_HORZ, hNew);

	CView::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CViewportView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	
// Compute font size
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(&m_font);
	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);
	dc.SelectObject(pOldFont);

	m_cyFont = tm.tmHeight;		// + tm.tmInternalLeading;
	ASSERT(m_cyFont != 0);
	m_cxFont = tm.tmMaxCharWidth;

	m_sizeFont.cx = m_cxFont;
	m_sizeFont.cy = m_cyFont;

// Recompute lines in view
	m_cLinesInView = (cy /*+ m_cyFont - 1*/) / m_cyFont;
	m_cColsInView = (cx /*+ m_cxFont - 1*/) / m_cxFont;
}

void CViewportView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	BOOL bControl = GetAsyncKeyState(VK_CONTROL) & 0x8000;
	switch( nChar )
	{
		case VK_UP:
			m_rSel2--;
			SelectLine(m_rSel2);
			break;
		case VK_DOWN:
			m_rSel2++;
			SelectLine(m_rSel2);
			break;
		case VK_PRIOR:
			if( bControl )
				OnHScroll(SB_PAGELEFT, 0, NULL);
			else
				SelectLine(m_rSel2 - (m_cLinesInView - 1));
			break;
		case VK_NEXT:
			if( bControl )
				OnHScroll(SB_PAGERIGHT, 0, NULL);
			else
				SelectLine(m_rSel2 + (m_cLinesInView - 1));
			break;
		case VK_LEFT:
			OnHScroll(SB_LINELEFT, 0, NULL);
			break;
		case VK_RIGHT:
			OnHScroll(SB_LINERIGHT, 0, NULL);
			break;
		case VK_HOME:
			if( bControl )
				SelectLine(0);
			else
				OnHScroll(SB_LEFT, 0, NULL);
			break;
		case VK_END:
			if( bControl )
				SelectLine(GetDocument()->GetNumLines());
			else
				OnHScroll(SB_RIGHT, 0, NULL);
			break;
		default:
			CView::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}

void CViewportView::OnLButtonDown(UINT /*nFlags*/, CPoint point)
{
	CViewportDoc* pDoc = GetDocument();
//	CModelessShapePropSheet* pModelessShapePropSheet
//		= GetModelessShapePropSheet();

	CRect rectClip;
	CClientDC dc(this);

	// get the top line into the data from the vertical scroll bar position
	int nTopDataLine = GetScrollPos(SB_VERT);
	ASSERT(nTopDataLine >= 0);

	// determine the range of lines in the clipping rectangle (zero-based)

	// get the clipping rectangle
	dc.GetClipBox(rectClip);

	int nClickedline = nTopDataLine + (point.y - rectClip.top) / m_sizeFont.cy;
	ASSERT(nClickedline>=0);
	if(pDoc->GetNumLines() < nClickedline)
		return;
	// figure the top and bottom screen lines in the clipping rectangle
//	nTopScreenLine = rectClip.top / m_sizeFont.cy;
//	nBottomScreenLine = rectClip.bottom / m_sizeFont.cy + 1;
	if(m_rSel2 != nClickedline)
	{
		m_rSel2 = nClickedline;
		if(selecting == FALSE)
			m_rSel1 = m_rSel2;
		InvalidateRect(NULL, FALSE);
	}
}


void CViewportView::SelectLine(int nNewLine)
{
	if( nNewLine < 0 )
		nNewLine = 0;
	else if( nNewLine > GetDocument()->GetNumLines() )
		nNewLine = GetDocument()->GetNumLines();

	int nOldLine = m_rSel2;
	m_rSel2 = nNewLine;
	int nScroll = GetScrollPos(SB_VERT);
	if( m_rSel2 < nScroll )
		OnVScroll(SB_THUMBPOSITION, m_rSel2, NULL);
	else if( m_rSel2 > nScroll + m_cLinesInView - 1 /*2*/ )
		OnVScroll(SB_THUMBPOSITION, m_rSel2 - m_cLinesInView + 1/*2*/, NULL);
	if(selecting==FALSE)
		m_rSel1 = m_rSel2;
//REVIEW(chriskoz): need to invalidate more than two lines, but not entire screen
	InvalidateRect(NULL);
//	nScroll = GetScrollPos(SB_VERT);
//	CRect rcLine(0, 0, m_cxFont * (m_cColsInView + 1), 0);
//	rcLine.top = m_cyFont * (m_rSel2 - nScroll);
//	rcLine.bottom = rcLine.top + m_cyFont;
//	InvalidateRect(&rcLine); 

//	rcLine.top = m_cyFont * (nOldLine - nScroll);
//	rcLine.bottom = rcLine.top + m_cyFont;
//	InvalidateRect(&rcLine);
}


void CViewportView::OnViewportFilter(UINT nId)
{
	// get a pointer to the doc
	CViewportDoc* pDoc = GetDocument();

	// toggle the filter setting
	pDoc->SetFilter(nId, !pDoc->GetFilter(nId));
	if(pDoc->GetNumLines() < m_rSel1)
		m_rSel1 = pDoc->GetNumLines();
	if(pDoc->GetNumLines() < m_rSel2)
		m_rSel2 = pDoc->GetNumLines();
	InvalidateRect(NULL); //repaint this view //REVIEW(chriskoz) what about all views
}

void CViewportView::OnUpdateViewportFilter(CCmdUI* pCmdUI)
{
	// get a pointer to the doc
	CViewportDoc* pDoc = GetDocument();

	// update the UI based on the filter setting
	pCmdUI->SetCheck(pDoc->GetFilter(pCmdUI->m_nID));
}

void CViewportView::OnEditMark() 
{
	selecting=TRUE;
}

void CViewportView::OnUpdateEditMark(CCmdUI* pCmdUI) 
{
	// update the UI based on the state of selection
	pCmdUI->Enable(selecting==FALSE);
	
}

void CViewportView::OnSelectAll() 
{
	// TODO: Add your command handler code here
	
}

void CViewportView::OnUpdateSelectAll(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\stepbar.h ===
#ifndef INC_STEPBAR_H
#define INC_STEPBAR_H

#define LPSZPIPENAME   "\\\\.\\pipe\\debugbar.pip"	  // cryptic, but it's \\.\.\debugbar.pip (this computer current dir)
#define PIPEWAITTIME   5000

#define MAXIMUMTEXTWIDTH    (30 * BUTTONWIDTH)
#define BUTTONWIDTH   16

#define MAXTEXTSIZE  200


class CDebugToolBar : public CToolBar
{
protected:
	CStatic *m_pcstaticText;
	HANDLE  m_hPipe;
	CRect   m_crect;  // rectangle delimiting the text area

public:

	CDebugToolBar() : CToolBar() {m_pcstaticText = NULL; m_hPipe = INVALID_HANDLE_VALUE;};
	~CDebugToolBar();

	BOOL Initialize(UINT nID);  // opens the pipe.

	BOOL SetToolBarText();
	BOOL SetStaticText(char *szBuffer);

};

#endif  // INC_STEPBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\stepbar.cpp ===
#include "stdafx.h"
#include "stepbar.h"


#define CELEM(rgfoo)  (sizeof(rgfoo) / sizeof(rgfoo[0]))

static UINT BASED_CODE DebugButtons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
	ID_FILE_NEW,
	ID_FILE_OPEN,
	ID_FILE_SAVE,
	ID_SEPARATOR,  // real separator
	ID_SEPARATOR,  // Text to be displayed
	ID_SEPARATOR   // real separator
};




BOOL CDebugToolBar::Initialize(UINT nID)
{
	int iTries;
	DWORD dwMode;

	LoadBitmap(nID);
	SetButtons(DebugButtons, CELEM(DebugButtons));
	SetButtonInfo(4, ID_SEPARATOR, TBBS_SEPARATOR, MAXIMUMTEXTWIDTH);
	GetItemRect(4, &m_crect); // get the size of the separator will be used in static text settings.
	EnableDocking(CBRS_ALIGN_TOP | CBRS_ALIGN_BOTTOM);

	for (;;)
	{
		m_hPipe = CreateFile(LPSZPIPENAME, GENERIC_READ | GENERIC_WRITE, 0 /*no sharing*/,
						NULL /*no security attr. */, OPEN_EXISTING, 0 /* default attribs */,
						NULL);				/* NO template file */


		if (m_hPipe != INVALID_HANDLE_VALUE)
			break;

		WaitNamedPipe(LPSZPIPENAME, NMPWAIT_WAIT_FOREVER);  // wait until the pipe is available 
	}

	dwMode = PIPE_READMODE_MESSAGE;
	if (!SetNamedPipeHandleState(m_hPipe, &dwMode, NULL, NULL))
	{
		CloseHandle(m_hPipe);
		m_hPipe = INVALID_HANDLE_VALUE;
		return FALSE;
	}
		
	return TRUE;
}

CDebugToolBar::~CDebugToolBar()
{
	if (m_pcstaticText != NULL)
		delete m_pcstaticText;

	if (m_hPipe != INVALID_HANDLE_VALUE)
		CloseHandle(m_hPipe);
}

BOOL CDebugToolBar::SetToolBarText()  // read the message from the pipe and display it
{
	char szBuffer[MAXTEXTSIZE];
	unsigned long lcbRead;

	if (m_hPipe == NULL)  // something is going really wrong here
		return FALSE;

	if (!ReadFile(m_hPipe, szBuffer, MAXTEXTSIZE, &lcbRead, NULL /* not overlapped */))
		return FALSE;

	SetStaticText(szBuffer);

	return TRUE;  // RecalcLayout needs to be called to make the new text visible.
}		

BOOL CDebugToolBar::SetStaticText(char *szBuffer)  // read the message from the pipe and display it
{
	if (m_pcstaticText != NULL)
		delete m_pcstaticText;

	m_pcstaticText = new CStatic();
	m_pcstaticText->Create(szBuffer, WS_VISIBLE | WS_CHILD, m_crect, this);  // create the text.

	return TRUE;  // RecalcLayout needs to be called to make the new text visible.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>		// MFC OLE automation classes
#include "afxcview.h"
#include "caferes.h"		// resources
#define MST_BUG

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitebar.h ===
/////////////////////////////////////////////////////////////////////////////
// suitebar.h
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Interface of the CSubSuiteBar class

#ifndef __SUITEBAR_H__
#define __SUITEBAR_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSuiteBar class

class CSubSuiteBar : public CToolBar
{
// ctor/dtor
public:
	CSubSuiteBar()		{ }
	~CSubSuiteBar()	{ }

// operations
public:
	CreateBar(CWnd* pParent);
};

#endif // __SUITEBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitebar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// suitebar.cpp
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Implementation of the CSuiteBar class

#include "stdafx.h"
#include "suitebar.h"
#include "caferes.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSuiteBar buttons
static UINT BASED_CODE btnsSubSuiteBar[] =
{
	IDM_SubSuiteRun,
		ID_SEPARATOR,
#ifdef CAFE_V31
	IDM_SubSuiteAdd,
	IDM_SubSuiteDelete,
		ID_SEPARATOR,
#endif
	IDM_SubSuiteSelectAll,
	IDM_SubSuiteDeselectAll,
	IDM_SubSuiteToggleAll,
#ifdef CAFE_V31
		ID_SEPARATOR,
//	IDM_SubSuiteProperties,
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSubSuiteBar

BOOL CSubSuiteBar::CreateBar(CWnd* pParent)
{
	// create the toolbar
	if (!Create(pParent, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_TOOLTIPS | CBRS_FLYBY, IDT_SubSuiteBar) ||
			!LoadBitmap(IDB_SUBSUITEBAR) ||
			!SetButtons(btnsSubSuiteBar, sizeof(btnsSubSuiteBar)/sizeof(UINT))) {
		TRACE("CSubSuiteBar::CreateBar: Failed to create SubSuiteBar\n");
		return FALSE;       // fail to create
	}

	// make the toolbar dockable
	EnableDocking(CBRS_ALIGN_ANY);

	// set the title
	SetWindowText("SubSuite");

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitevw.cpp ===
/////////////////////////////////////////////////////////////////////////////
// suitevw.cpp
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Implementation of the CSuiteView class

#include "stdafx.h"
#include "suitedoc.h"
#include "suitevw.h"
#include "cafedrv.h"
#include "caferes.h"
#include "test.h"
#include "logpage.h"
#include "suitepg.h"
#include "testspg.h"
#include "statepg.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSuiteView

IMPLEMENT_DYNCREATE(CSuiteView, CView)

CSuiteView::CSuiteView()
: m_ptreeSuite(NULL)
{
}

CSuiteView::~CSuiteView()
{
	// delete the tree control
	if (m_ptreeSuite) {
		delete m_ptreeSuite;
	}
}


BEGIN_MESSAGE_MAP(CSuiteView, CView)
	//{{AFX_MSG_MAP(CSuiteView)
	ON_WM_CREATE()
	ON_COMMAND(IDM_SubSuiteRun, OnSubSuiteRun)
	ON_COMMAND(IDM_SubSuiteAdd, OnSubSuiteAdd)
	ON_COMMAND(IDM_SubSuiteDelete, OnSubSuiteDelete)
	ON_COMMAND(IDM_SubSuiteSelectAll, OnSubSuiteSelectAll)
	ON_COMMAND(IDM_SubSuiteDeselectAll, OnSubSuiteDeselectAll)
	ON_COMMAND(IDM_SubSuiteToggleAll, OnSubSuiteToggleAll)
	ON_COMMAND(IDM_SubSuiteProperties, OnSubSuiteProperties)
	ON_COMMAND(IDM_OptionsSuite, OnOptionsSuite)
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSuiteView drawing

void CSuiteView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
	
	UNREFERENCED_PARAMETER(pDC);
}

/////////////////////////////////////////////////////////////////////////////
// CSuiteView diagnostics

#ifdef _DEBUG
void CSuiteView::AssertValid() const
{
	CView::AssertValid();
}

void CSuiteView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CSuiteDoc* CSuiteView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CSuiteDoc)));
	return (CSuiteDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// operations (internal)

void CSuiteView::FillTree(void)
{
	CSuiteDoc::SubSuiteList* plistSubSuites;
	CSuiteDoc::SubSuiteInfo* pSubSuiteInfo;
	CString strSubSuite;
	CSubSuite::TestList* plistTests;
	CTest* pTest;
	POSITION posSubSuite;
	POSITION posTest;
	CNode* pSubSuiteNode;

	// get a pointer to the document
	CSuiteDoc *pDoc = GetDocument();

	// get the list of subsuites
	plistSubSuites = pDoc->GetSubSuiteList();

	// for each subsuite in the list,
	for (posSubSuite = plistSubSuites->GetHeadPosition(); posSubSuite != NULL; ) {
		pSubSuiteInfo = plistSubSuites->GetNext(posSubSuite);

		// build the subsuite name (name + owner + dll name)
		strSubSuite = pSubSuiteInfo->m_pSubSuite->GetName(); /* + " - Owner: " + pSubSuiteInfo->m_pSubSuite->GetOwner() + " - Filename: " + pSubSuiteInfo->m_strFilename; */

		// enter the subsuite at the end of the list
		pSubSuiteNode = m_ptreeSuite->InsertNode(NULL, strSubSuite, pSubSuiteInfo->m_dwId, -1, IDB_GlyphFolderClose, IDB_GlyphFolderOpen, pSubSuiteInfo->m_bRun);

		// get the list of tests
		plistTests = pSubSuiteInfo->m_pSubSuite->GetTestList();

		// for each test in the subsuite,
		for (posTest = plistTests->GetHeadPosition(); posTest != NULL; ) {
			pTest = plistTests->GetNext(posTest);

			// enter the test in this subsuite at the end of the list
			m_ptreeSuite->InsertNode(pSubSuiteNode, pTest->GetName(), 0, -1, IDB_GlyphTest, IDB_GlyphTest, pTest->GetRunState() == CTest::RS_Run);
		}

		// collapse this node
		m_ptreeSuite->Collapse(pSubSuiteNode);
	//	UpdateSuite();
	}
}

BOOL CSuiteView::UpdateSuite(void)
{
	CSuiteDoc::SubSuiteList* plistSubSuites;
	CSuiteDoc::SubSuiteInfo* pSubSuiteInfo;
	CNode* pSubSuiteNode;
	CSubSuite::TestList* plistTests;
	CNode::CNodeList* plistChildren;
	CTest* pTest;
	CNode* pNode;
	POSITION posSubSuite;
	POSITION posChild;
	POSITION posTest;

	// get a pointer to the document
	CSuiteDoc *pDoc = GetDocument();

  CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

  CPlatform *pPlatform = pApp -> CreateCurrentPlatform();


	// get the list of subsuites
	plistSubSuites = pDoc->GetSubSuiteList();

	// for each subsuite in the list,
	for (posSubSuite = plistSubSuites->GetHeadPosition(); posSubSuite != NULL; ) {
		pSubSuiteInfo = plistSubSuites->GetNext(posSubSuite);

		// get the node for this subsuite
		pSubSuiteNode = m_ptreeSuite->FindNode(pSubSuiteInfo->m_dwId);

		// record its selection status
		pSubSuiteInfo->m_bRun = pSubSuiteNode->GetFlags() & TF_SELECTED;

		// get the list of children for this node
		plistChildren = pSubSuiteNode->GetChildren();

		// get the list of tests
		plistTests = pSubSuiteInfo->m_pSubSuite->GetTestList();

		// these lists must be same length
		ASSERT(plistChildren->GetCount() == plistTests->GetCount());

		// for each test in the subsuite,
		for (posTest = plistTests->GetHeadPosition(), posChild = plistChildren->GetHeadPosition(); posTest != NULL; ) {
			pTest = plistTests->GetNext(posTest);
			pNode = plistChildren->GetNext(posChild);

			// record its selection status


#if 0
      // use this code to use the funky "crossed-out" glyphs in the tree control

      pNode->SetGlyphIds(
        (pTest->CanTestPlatform(pPlatform)) ?
        IDB_GlyphTest :
        IDB_GlyphBadTest);
#endif

      pTest->SetRunState(
        ((pNode->GetFlags() & TF_SELECTED) && (pTest->CanTestPlatform(pPlatform))) ?
        CTest::RS_Run :
        CTest::RS_NoRun);


		}
	}

	delete pPlatform;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSuiteView message handlers

int CSuiteView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	CRect rectWnd;
	CRect rectView;

	// call the base class
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// get the size of the view
	GetParent()->GetClientRect(&rectWnd);
/*
	GetParent()->GetWindowRect(&rectWnd);
	ScreenToClient(&rectWnd);
*/
	SetWindowPos(NULL, 0, 0, rectWnd.right, rectWnd.bottom, SWP_NOMOVE | SWP_NOZORDER);
	GetClientRect(&rectView);
/*
	GetWindowRect(&rectWnd);
	ScreenToClient(&rectWnd);
*/

	// create the suite tree control
//	m_ptreeSuite = new CTreeCtl(TRUE, TRUE);
	m_ptreeSuite = new CTreeCtl(TRUE,TRUE,TRUE) ;
	if (!m_ptreeSuite->Create(NULL, NULL, WS_CHILD | WS_VISIBLE, rectView, this, 0)) {
		return -1;
	}					  

	return 0;
}

void CSuiteView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
	// TODO: Add your specialized code here and/or call the base class

  UpdateSuite();
  m_ptreeSuite->UpdateWindow();
	

	UNREFERENCED_PARAMETER(pSender);
	UNREFERENCED_PARAMETER(lHint);
	UNREFERENCED_PARAMETER(pHint);
}

void CSuiteView::OnSubSuiteRun() 
{
	// get a pointer to the document
	CSuiteDoc *pDoc = GetDocument();

	// update the data from the UI (selected, nonselected)
	UpdateSuite();

	// the document runs the suite
	pDoc->Run();
}

void CSuiteView::OnSubSuiteAdd() 
{
	
}

void CSuiteView::OnSubSuiteDelete() 
{
	
}

void CSuiteView::OnSubSuiteProperties() 
{
	
}

void CSuiteView::OnSubSuiteSelectAll() 
{
	m_ptreeSuite->SelectAll();
}

void CSuiteView::OnSubSuiteDeselectAll() 
{
	m_ptreeSuite->DeselectAll();
}

void CSuiteView::OnSubSuiteToggleAll() 
{
	m_ptreeSuite->ToggleAll();
}

void CSuiteView::OnSize(UINT nType, int cx, int cy) 
{
	// call the base class
	CView::OnSize(nType, cx, cy);

	// resize the tree control
	if (m_ptreeSuite) {
		m_ptreeSuite->MoveWindow(0, 0, cx, cy);
	}

}

void CSuiteView::OnSetFocus(CWnd* pOldWnd) 
{
	CView::OnSetFocus(pOldWnd);
	
	// set focus to the tree
	m_ptreeSuite->SetFocus();
}


void CSuiteView::OnInitialUpdate() 
{
	// fill the tree control with the subsuites and tests
	FillTree();
	m_ptreeSuite->UpdateWindow();

	CView::OnInitialUpdate();
}

void CSuiteView::OnOptionsSuite()
{
	// get a pointer to the document
	CSuiteDoc *pDoc = GetDocument();

    // create the tabbed options dialog
    CPropertySheet dlgSuiteOptions(IDS_OptionsSuite);

    // create the pages
	CSuitePage pageSuite(pDoc);
    CLogPage pageLog;
	CTestsRunPage pageTestsRun(pDoc);
	CStatePage pageCurrentState(pDoc);

	// initialize the log page with this suite's data
	pageLog.m_strResultsFile = pDoc->GetResultsFile();
	pageLog.m_strSummaryFile = pDoc->GetSummaryFile();
	pageLog.m_strWorkDir = pDoc->GetWorkingDir();
	pageLog.m_nMaxFail = pDoc->GetMaxFail();
	pageLog.m_bPost = pDoc->GetPostResults();
	pageLog.m_bComments = pDoc->GetRecordComments();
	pageLog.m_bDebugOutput = pDoc->GetLogDebugOutput();

    // add the pages to the sheet
	dlgSuiteOptions.AddPage(&pageSuite);
    dlgSuiteOptions.AddPage(&pageLog);
	dlgSuiteOptions.AddPage(&pageTestsRun);
	dlgSuiteOptions.AddPage(&pageCurrentState);

    // bring up the tabbed dialog
    if (dlgSuiteOptions.DoModal() == IDOK) {
		// store the data from the log page
		pDoc->SetResultsFile(pageLog.m_strResultsFile);
		pDoc->SetSummaryFile(pageLog.m_strSummaryFile);
		pDoc->SetWorkingDir(pageLog.m_strWorkDir);
		pDoc->SetMaxFail(pageLog.m_nMaxFail);
		pDoc->SetPostResults(pageLog.m_bPost);
		pDoc->SetRecordComments(pageLog.m_bComments);
		pDoc->SetLogDebugOutput(pageLog.m_bDebugOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitepg.h ===
/////////////////////////////////////////////////////////////////////////////
// suitepg.h
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1994 Microsoft

// Interface of the CSuitePage class

#ifndef __SUITEPG_H__
#define __SUITEPG_H__

#include "caferes.h"
#include "suitedoc.h"

/////////////////////////////////////////////////////////////////////////////
// CSuitePage dialog

class CSuitePage: public CPropertyPage
{
	DECLARE_DYNCREATE(CSuitePage)

// Construction
public:
	CSuitePage(CSuiteDoc* pSuiteDoc = NULL);
	~CSuitePage();

// Dialog Data
	//{{AFX_DATA(CSuitePage)
	enum { IDD = IDD_SuiteTab };
	CButton	m_checkLoopTests;
	int		m_bLoopTests;
	int		m_bCleanUpBefore;
	int		m_bCleanUpAfter;
	int		m_bRandomize;
	int		m_nRandomSeed;
	int		m_nLimit;
	int		m_nLimitNum;
	int		m_nCycleNumber;
	//}}AFX_DATA
	CTimeSpan m_LimitTime;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSuitePage)
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSuitePage)
	afx_msg void UpdateUI(void);
	afx_msg void OnContinuallyLoop(void);
	afx_msg void OnViewGraph();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void AFXAPI DDX_TimeSpan(CDataExchange* pDX, int nIDC, CTimeSpan& timespan);
	void GetTimeSpan(HWND hWnd, CTimeSpan& timespan);
	void SetTimeSpan(HWND hWnd, CTimeSpan& timespan);
	
protected:

protected:
	CSuiteDoc* m_pSuiteDoc;
};

#endif // __SUITEPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitepg.cpp ===
/////////////////////////////////////////////////////////////////////////////
// suitepg.cpp
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1995 Microsoft

// Implementation of the CSuitePage class

#include "stdafx.h"
#include "suitepg.h"
#include "graphdlg.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSuitePage property page

IMPLEMENT_DYNCREATE(CSuitePage, CPropertyPage)

CSuitePage::CSuitePage(CSuiteDoc* pSuiteDoc)
: CPropertyPage(CSuitePage::IDD),
  m_pSuiteDoc(pSuiteDoc)
{
	// the suite doc must be valid
	ASSERT(m_pSuiteDoc);

	//{{AFX_DATA_INIT(CSuitePage)
	m_bLoopTests = FALSE;
	m_bCleanUpBefore = TRUE;
	m_bCleanUpAfter = TRUE;
	m_bRandomize = FALSE;
	m_nRandomSeed = 0;
	m_nLimit = 1;
	m_nLimitNum = 100;
	m_LimitTime = CTimeSpan(0, 1, 0, 0);
	m_nCycleNumber = 1;
	//}}AFX_DATA_INIT

	// initialize dialog with data from the doc
	m_bCleanUpBefore = m_pSuiteDoc->GetCleanUpBefore();
	m_bCleanUpAfter = m_pSuiteDoc->GetCleanUpAfter();
	m_nCycleNumber = m_pSuiteDoc->GetCycleNumber();
	m_bLoopTests = m_pSuiteDoc->GetLoopTests();
	m_bRandomize = m_pSuiteDoc->GetRandomize();
	m_nRandomSeed = m_pSuiteDoc->GetRandomSeed();
	m_nLimit = (int)m_pSuiteDoc->GetRandomLimit();
	m_nLimitNum = m_pSuiteDoc->GetRandomLimitNum();
	m_LimitTime = m_pSuiteDoc->GetRandomLimitTime();


}

CSuitePage::~CSuitePage()
{
}

void CSuitePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSuitePage)
	DDX_Control(pDX, IDC_SuiteLoopTests, m_checkLoopTests);
	DDX_Check(pDX, IDC_SuiteLoopTests, m_bLoopTests);
	DDX_Check(pDX, IDC_SuiteCleanUpBefore, m_bCleanUpBefore);
	DDX_Check(pDX, IDC_SuiteCleanUpAfter, m_bCleanUpAfter);
	DDX_Check(pDX, IDC_SuiteRandomize, m_bRandomize);
	DDX_Text(pDX, IDE_SuiteRandomSeed, m_nRandomSeed);
	DDX_Radio(pDX, IDR_RandomLimitNone, m_nLimit);
	DDX_Text(pDX, IDE_RandomLimitNum, m_nLimitNum);
	DDX_Text(pDX, IDE_CycleNumber, m_nCycleNumber);
	DDX_TimeSpan(pDX, IDE_RandomLimitTime, m_LimitTime);
	//}}AFX_DATA_MAP
}

BOOL CSuitePage::OnSetActive(void)
{
	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// set up UI
	UpdateUI();

	return TRUE;
}

BEGIN_MESSAGE_MAP(CSuitePage, CPropertyPage)
	//{{AFX_MSG_MAP(CSuitePage)
	ON_BN_CLICKED(IDC_SuiteRandomize, UpdateUI)
	ON_BN_CLICKED(IDC_SuiteLoopTests, OnContinuallyLoop)
	ON_BN_CLICKED(IDB_SuiteViewGraphs, OnViewGraph)
	ON_BN_CLICKED(IDR_RandomLimitNone, UpdateUI)
	ON_BN_CLICKED(IDR_RandomLimitNum, UpdateUI)
	ON_BN_CLICKED(IDR_RandomLimitTime, UpdateUI)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSuitePage::UpdateUI(void)
{
	// retrieve settings from the UI
	UpdateData(TRUE);

	// gray the randomize check box and graph button based on ability to randomize
	((CButton*)GetDlgItem(IDC_SuiteRandomize))->EnableWindow(m_pSuiteDoc->CanRandomize());
	((CButton*)GetDlgItem(IDB_SuiteViewGraphs))->EnableWindow(m_pSuiteDoc->CanRandomize());

	// gray or enable the limit number edit field based on the radio button selected
	((CWnd*)GetDlgItem(IDE_RandomLimitNum))->EnableWindow(m_nLimit==1);
	
	// gray or enable the limit time edit field based on the radio button selected
	((CWnd*)GetDlgItem(IDE_RandomLimitTime))->EnableWindow(m_nLimit==2);

	// gray (or enable) all the controls related to randomizing based on the state of the randomize check box
	for (int i = IDS_SuiteRandomSeed; i < IDB_SuiteViewGraphs; i++) {
		((CWnd*)GetDlgItem(i))->EnableWindow(m_bRandomize);
	}

	// gray all the randomization controls based on the state of the continuously loop check box
	// (we can't loop and randomize)
	if (m_bLoopTests) {
		for (i = IDC_SuiteRandomize; i < IDB_SuiteViewGraphs; i++) {
			((CWnd*)GetDlgItem(i))->EnableWindow(FALSE);
		}
	}
}

void AFXAPI CSuitePage::DDX_TimeSpan(CDataExchange* pDX, int nIDC, CTimeSpan& timespan)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate) {
		GetTimeSpan(hWndCtrl, timespan);
	}
	else {
		SetTimeSpan(hWndCtrl, timespan);
	}
}

void CSuitePage::GetTimeSpan(HWND hWnd, CTimeSpan& timespan)
{
	TCHAR szWindowText[20];
	::GetWindowText(hWnd, szWindowText, 19);
	TCHAR* psz;
	int nDays = 0;
	int nHours = 0;
	int nMinutes = 0;

	// we want to parse this string backwards
	// so start at the end
	psz = szWindowText + _tcslen(szWindowText) - 1;
	
	// skip white space
	while (*psz == ' ') {
		psz--;
	}
	*(psz+1) = '\0';
	// go to the colon for minutes
	while (psz != szWindowText && *psz != ':') {
		psz--;
	}
	if (psz == szWindowText) {
		nMinutes = _ttoi(psz);
		goto FigureTime;
	}
	else {
		nMinutes = _ttoi(psz+1);
	}
	*(psz) = '\0';
	// go to the colon for hours
	while (psz != szWindowText && *psz != ':') {
		psz--;
	}
	if (psz == szWindowText) {
		nHours = _ttoi(psz);
		goto FigureTime;
	}
	else {
		nHours = _ttoi(psz+1);
	}
	*(psz) = '\0';
	nDays = _ttoi(szWindowText);
	
FigureTime:
	timespan = CTimeSpan(nDays, nHours, nMinutes, 0);
}

void CSuitePage::SetTimeSpan(HWND hWnd, CTimeSpan& timespan)
{
	CString str = timespan.Format("%D:%H:%M");
	::SetWindowText(hWnd, str);
}

/////////////////////////////////////////////////////////////////////////////
// CSuitePage message handlers

void CSuitePage::OnOK() 
{
	// store the dialog data in the doc
	m_pSuiteDoc->SetCleanUpBefore(m_bCleanUpBefore);
	m_pSuiteDoc->SetCleanUpAfter(m_bCleanUpAfter);
	m_pSuiteDoc->SetCycleNumber(m_nCycleNumber);
	m_pSuiteDoc->SetLoopTests(m_bLoopTests);
	m_pSuiteDoc->SetRandomize(m_bRandomize);
	m_pSuiteDoc->SetRandomSeed(m_nRandomSeed);
	m_pSuiteDoc->SetRandomLimit((CSuiteDoc::RandomLimit)m_nLimit);
	m_pSuiteDoc->SetRandomLimitNum(m_nLimitNum);
	m_pSuiteDoc->SetRandomLimitTime(m_LimitTime);
	
	CDialog::OnOK();
}

void CSuitePage::OnContinuallyLoop(void)
{
	UpdateData(TRUE);
	m_bRandomize = FALSE;
	//need to disable edit box if loop checkbox enabled
	//and set cyclenumber to 1.
//	if (((CButton*)GetCheck(IDC_SuiteLoopTests)) != 0)
	if(m_checkLoopTests.GetCheck() != 0) 
//	or if((CButton*)GetDlgItem(IDC_SuiteLoopTests)) ->GetCheck !=0)
	{
		m_nCycleNumber = 1;
		UpdateData(FALSE);
		//disable cyclenumber editbox if looptest checkbox is checked
		(GetDlgItem(IDE_CycleNumber))->EnableWindow(FALSE);
	}
	else
	{
		(GetDlgItem(IDE_CycleNumber))->EnableWindow(TRUE);
	}
	UpdateData(FALSE);
	UpdateUI();
}

void CSuitePage::OnViewGraph() 
{
	CGraphDlg dlgGraph(NULL, m_pSuiteDoc);
	
	dlgGraph.DoModal();
}

BOOL CSuitePage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	//if continually looping checked previously, when bring up dialog again
	//need to have cycle number editbox disabled.
	if (m_bLoopTests)
	{
		GetDlgItem(IDE_CycleNumber)->EnableWindow(FALSE);
	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitedoc.cpp ===
/////////////////////////////////////////////////////////////////////////////
// suitedoc.cpp
//
// email    date        change
// briancr  10/25/94    created
//
// copyright 1994 Microsoft

// Implementation of the CSuiteDoc class

#include "stdafx.h"
#include "cafexcpt.h"
#include "testxcpt.h"
#include "log.h"
#include "textlog.h"
#include "hotkey.h"
#include "suitedoc.h"
#include "applog.h"
#include "cafedrv.h"
#include "rawstrng.h"
#include "guiv1.h"
#include "test.h"
#include "randtest.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// REVIEW(briancr): provided only for backward compatibility
extern AFX_EXT_DATA CLog* gpLog;
extern CViewportView * vConsole, *vTextLog ;
/////////////////////////////////////////////////////////////////////////////
// CSuiteDoc

IMPLEMENT_DYNCREATE(CSuiteDoc, CDocument)

int CSuiteDoc::m_cSubSuites = 0;
unsigned CSuiteDoc::m_uDocCount = 0;

CSuiteDoc::CSuiteDoc()
: m_pLogViewport(NULL),
  m_pConsoleViewport(NULL),
  m_bCleanUpBefore(TRUE),
  m_bCleanUpAfter(TRUE),
  m_bLoopTests(FALSE),
  m_bRandomize(FALSE),
  m_nRandomSeed(0),
  m_RandomLimit(RandomLimitNum),
  m_nRandomLimitNum(100),
  m_RandomLimitTime(CTimeSpan(0, 1, 0, 0)),
  m_pGraphForest(NULL),
  m_bPostResults(FALSE),
  m_bRecordComments(FALSE),
  m_bLogDebugOutput(FALSE),
  m_plistTestsRun(NULL),
  m_nCycleNumber(1)
{
	m_bViews=TRUE;
	CSettings *appSettings=((CCAFEDriver*)AfxGetApp())->GetLogSettings();
	SetResultsFile(appSettings->GetTextValue(settingLogResultsFile) );
	SetSummaryFile(appSettings->GetTextValue(settingLogSummaryFile) );
	SetWorkingDir (appSettings->GetTextValue(settingLogWorkDir) );
	SetMaxFail    (appSettings->GetIntValue(settingLogMaxFail) );

	m_plistTestsRun = new CSubSuite::TestList;
}

BOOL CSuiteDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    CreateViewports();

    return TRUE;
}

CString TestName ;
void CSuiteDoc::OnCloseDocument( )
{	
	
	CDocument::OnCloseDocument() ;
	return ;
}

BOOL CSuiteDoc::OnOpenDocument(LPCTSTR lpszPathName)
{


    // defer to base class
    if (!CDocument::OnOpenDocument(lpszPathName)) //REVIEW(chriskoz)maybe I shouldn't do it for DLL Template
        return FALSE;
    
    CreateViewports();

    // read the suite file
    if (ReadSuite(CString(lpszPathName))) {
        // load the subsuites
    LoadSubSuites();
	return TRUE;
    }

    return FALSE;
}

extern "C" typedef BOOL (APIENTRY* DESTROYSUBSUITE)(CSubSuite *pSS);

CSuiteDoc::~CSuiteDoc()
{
    CSuiteDoc::SubSuiteInfo* pSubSuiteInfo;
    DESTROYSUBSUITE funcDestroySubSuite;

	// delete the list of tests run
	m_plistTestsRun->RemoveAll();
	delete m_plistTestsRun;

	// delete the graph forest
	delete m_pGraphForest;

    // delete each entry in the sub suite list
    for (POSITION pos = m_listSubSuites.GetHeadPosition(); pos != NULL; ) {
        pSubSuiteInfo = m_listSubSuites.GetNext(pos);

        // does a DestroySubSuite function exist?
        funcDestroySubSuite = (DESTROYSUBSUITE)::GetProcAddress(pSubSuiteInfo->m_hDLL, "DestroySubSuite");
        if (funcDestroySubSuite != NULL) {
            // call DestroySubSuite, if it exists
            funcDestroySubSuite(pSubSuiteInfo->m_pSubSuite);  // param added by CFlaat
        }

        // unload the DLL
        ::FreeLibrary(pSubSuiteInfo->m_hDLL);

        APPLOG("Unloaded subsuite (%s).", (LPCSTR)pSubSuiteInfo->m_strFilename);

        // delete the entry data
        delete pSubSuiteInfo;
    }

    // only close the write ends of the viewport pipes if the viewports exist
/*    if (m_pLogViewport) {
        ::CloseHandle(m_pLogViewport -> GetWriteHandle());
    }
    if (m_pConsoleViewport) {
        ::CloseHandle(m_pConsoleViewport -> GetWriteHandle());
    } */

    // remove all entries from the list
    m_listSubSuites.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// attributes

CSuiteDoc::SubSuiteList* CSuiteDoc::GetSubSuiteList(void)
{
    return &m_listSubSuites;
}

/////////////////////////////////////////////////////////////////////////////
// Operations

void CSuiteDoc::SetConsolePortDoc()
{
   CView  * pSpVw  ;
   int i = 0 ;
   // Find the view associated with the ConsolePort in the splitter pane, it's the last one (2nd) in the list.
   POSITION pos = GetFirstViewPosition();
   for (; i < 2; i++)
   { 
	   pSpVw =GetNextView(pos);
	   vConsole = (CViewportView *)pSpVw ;
   }
	m_pConsoleViewport->m_pLogViewTree = (CLogView *) GetNextView(pos);	//The LogTreeView .
   // Remove this view from the splitter MDIChild so that we can add it as a view fot the ConsoleLog.
   RemoveView(pSpVw) ;
    // Add the Splitter view to the log so it now logs to the splitter
   m_pConsoleViewport->AddView(pSpVw) ;

}

void CSuiteDoc::SetLogViewPortDoc() 
{
   CView * pSpVw  ;
   int i = 0 ;
   // Find the view associated with the ConsolePort in the splitter pane, it's the 3rd one after 
   // we removed the Console one in SetConsolePortDoc() above. 
   POSITION pos = GetFirstViewPosition();
   for (; i < 3; i++ )
   { 
	   pSpVw =GetNextView(pos);
	   if (i == 1)
		 m_pLogViewport->m_pLogViewTree = (CLogView *)pSpVw ;	//The LogTreeView .
	   vTextLog =(CViewportView *) pSpVw ;
   }
  // Remove this view from the splitter MDIChild so that we can add it as a view fot the ConsoleLog.
   RemoveView(pSpVw) ;
   // Add the Splitter view to the log so it now logs to the splitter
   m_pLogViewport->AddView(pSpVw) ;
}

BOOL CSuiteDoc::CreateViewports(void)
{
 
  CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

  ((CFrameWnd*)(pApp -> m_pMainWnd)) -> RecalcLayout();

  m_bViews = (CMDLINE->GetBooleanValue("views", TRUE)? TRUE:FALSE);  //disable views (ie -views:false)
  if (m_bViews) // are viewports disabled? (ie -views:false )
  {
	m_pConsoleViewport = pApp ->NewViewport();  // for console app output
	
	// Remove all views and attach the splitter view.
	SetConsolePortDoc() ;

	CString strNum;

	m_uDocCount++;
	strNum.Format("%u", m_uDocCount);

//	m_pConsoleViewport -> SetGenericTitle("Console", strNum);

    m_pLogViewport = pApp->NewViewport();  // for log output

	// Detach the default view and attach the splitter pane to this document.
	SetLogViewPortDoc();
//	m_pLogViewport -> SetGenericTitle("Log", strNum);

  }
    	
  //pApp -> DocToRegion(this, CCAFEDriver::Suite);
  if (m_bViews) // are viewports disabled? (ie -views:false )
  {
//	pApp -> DocToRegion(m_pLogViewport, CCAFEDriver::Log);
//	pApp -> DocToRegion(m_pConsoleViewport, CCAFEDriver::Console);
  }; 
  return TRUE;

}


BOOL CSuiteDoc::AddSubSuite(int Index, CString &strFilename, CString &strParams)
{
    ASSERT(0);

    // the index cannot be negative
    ASSERT(Index >= 0);

    // the filename cannot be empty
    ASSERT(!strFilename.IsEmpty());

    // TODO(briancr): complete

    return FALSE;

    UNREFERENCED_PARAMETER(strParams);
}


BOOL CSuiteDoc::RemoveSubSuite(int Index)
{
    ASSERT(0);

    // the index cannot be negative
    ASSERT(Index >= 0);

    // TODO(briancr): complete

    return FALSE;
}

BOOL CSuiteDoc::Run(void)
{
    // get a pointer to the app
    CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

    // create viewport docs/views

#ifndef MST_BUG
#error Didn't get MST_BUG!!!
    // REVIEW(briancr): to work around an MS-Test bug we run the suite in the main thread
    // the MS-Test bug: when calling into t3ctrl32.dll from multiple threads, the second
    // thread to call into the DLL never returns.
    RunSuite();
	if (m_bViews) // are viewports disabled? (ie -views:false )
    {
    m_pLogViewport->UpdateAllViews(NULL, m_pLogViewport->GetNumLines()+1);
    m_pConsoleViewport->UpdateAllViews(NULL, m_pConsoleViewport->GetNumLines()+1);
	}

#else
    // create a thread to execute the suite
//  m_pthreadSuite = AfxBeginThread(CSuiteDoc::RunSuite, this);
  DelegateSuiteExecution();
#endif // MST_BUG

    return TRUE;
}

UINT CSuiteDoc::RunSuite(void)
{
	const char* const THIS_FUNCTION = "CSuiteDoc::RunSuite";

    HANDLE hLogPipe, hConsolePipe;
    CTextLog* pLog = NULL;

    // get a pointer to the app
    CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

    // REVIEW(briancr): in order to use the old single step window, I've added this code
	if (pApp->GetStepWnd()!=NULL) //in case we don't have a StepWnd (ie -hotkey_thread:false)
	{
		if (pApp->GetSettings()->GetBooleanValue(settingDoSingleStep) ||
			g_stopStep>0){ //force single step mode when the breakpoint set
			// register hot keys
			pApp->GetStepWnd()->SendMessage(WM_REGISTERHOTKEYS);
			ResetEvent(g_hSingleStep);
			g_hkToDo = HOTKEY_SINGLE;
			APPLOG("%s: starting in single step mode; hot keys registered, event reset.", THIS_FUNCTION);
		}
		else {
			// unregister hot keys
			pApp->GetStepWnd()->SendMessage(WM_UNREGISTERHOTKEYS);
			SetEvent(g_hSingleStep);
			g_hkToDo = HOTKEY_RUN;
			APPLOG("%s: starting in run mode; hot keys unregistered, event set.", THIS_FUNCTION);
		}
	}

	if (m_bViews) // are viewports disabled? (ie -views:false )
    {
#ifdef NAMED_PIPES
		hLogPipe = INVALID_HANDLE_VALUE;
		if(::WaitNamedPipe(m_pLogViewport->GetPipeName(),
			NMPWAIT_USE_DEFAULT_WAIT)!=FALSE)
			hLogPipe = CreateFile(m_pLogViewport->GetPipeName(),
				GENERIC_WRITE, 0, NULL,
				OPEN_EXISTING,
				0, //don't overlap IO
				NULL);
#else
	    // get a handle to the pipe
	    hLogPipe = m_pLogViewport->GetWriteHandle();
#endif
	    ASSERT(hLogPipe != INVALID_HANDLE_VALUE && hLogPipe != NULL);
	    if (hLogPipe == INVALID_HANDLE_VALUE || hLogPipe == NULL) {
			pApp->ErrorMsg("Error getting the write end of the pipe to the viewport. GetLastError = %d. Test output will not be visible; view results.log instead.", ::GetLastError());
	        hLogPipe = NULL;
	    }
#ifdef NAMED_PIPES
		hConsolePipe = INVALID_HANDLE_VALUE;
		if(::WaitNamedPipe(m_pConsoleViewport->GetPipeName(),
			NMPWAIT_USE_DEFAULT_WAIT)!=FALSE)
			hConsolePipe = CreateFile(m_pConsoleViewport->GetPipeName(),
				GENERIC_WRITE, 0, NULL,
				OPEN_EXISTING,
				0, //don't overlap IO
				NULL);
#else
	    // get a handle to the pipe
	    hConsolePipe = m_pConsoleViewport->GetWriteHandle();
#endif	
	    ASSERT(hConsolePipe != INVALID_HANDLE_VALUE && hConsolePipe != NULL);
	    if (hConsolePipe == INVALID_HANDLE_VALUE || hConsolePipe == NULL) {
			pApp->ErrorMsg("Error getting the write end of the pipe to the console window. GetLastError = %d; Console output will not be visible.", ::GetLastError());
	        hConsolePipe = NULL;
	    }
	} else {
		hLogPipe=NULL;
		hConsolePipe = NULL;
	};

    // store the current directory
	char szOrigPath[MAX_PATH];
	::GetCurrentDirectory(MAX_PATH, szOrigPath);

    // create a log object
    pLog = new CTextLog(m_strResultsFile, m_strSummaryFile, m_strWorkingDir, hLogPipe);
	// UGLY_HACK(briancr): this code is here to log info to a server about who runs CAFE
	// remove it as soon as possible
	// do we disable the big brother option?
	if (!pApp->GetCmdLine()->GetBooleanValue(settingBigBro, TRUE)) {
		pLog->m_bBigBro = FALSE;
	}

    // REVIEW(briancr): just to make things work
    // set the log and cmd line in the support system
    gpLog = pLog;
	gpLog->SetLogDebugOutput(GetLogDebugOutput());

    // create a new toolset
    CToolset* pToolset = pApp->NewToolset(hConsolePipe);

    // tell the toolset the log to use
    pToolset->SetLog(pLog);

	// clear the list of tests run
	m_plistTestsRun->RemoveAll();

	// do we run tests randomly
	if (GetRandomize()) {
		RunRandom(pToolset);
	}
	else {
		RunSequential(pToolset);
	}

	// delete the toolset
	pApp->DeleteToolset(pToolset);

	// delete the log object
    delete pLog;

    // reset the current directory
    ::SetCurrentDirectory(szOrigPath);

#ifdef NAMED_PIPES
//	disconnect from named pipes
	if(hLogPipe!=NULL)
		CloseHandle(hLogPipe);
	if(hConsolePipe != NULL)
		CloseHandle(hConsolePipe);
#endif
    // was the driver launched with the -run switch?
    if (pApp->GetCmdLine()->IsDefined(settingRun)) {
        // if so, close the app
        PostMessage(pApp->m_pMainWnd->m_hWnd, WM_CLOSE, 0, 0);
    }

    return 0;
}

BOOL CSuiteDoc::RunRandom(CToolset* pToolset)
{
	const char* const THIS_FUNCTION = "CSuiteDoc::RunRandom";
	
	APPLOG("Running tests randomly.");
	if (m_RandomLimit == RandomLimitNone) {
		APPLOG("No limit set by user for random test run.");
	}
	else if (m_RandomLimit == RandomLimitNum) {
		APPLOG("Limit of %d tests set by user for random test run.", m_nRandomLimitNum);
	}
	else if (m_RandomLimit == RandomLimitTime) {
		APPLOG("Limit of %s set by user for random test run.", m_RandomLimitTime.Format("%D:%H:%M"));
	}

    // get a pointer to the app
    CCAFEDriver *pApp = ((CCAFEDriver*)AfxGetApp());

    // run the tests randomly
    try {

        WaitStepInstructions(INITIALIZE_STRING);

		// get the list of subsuites
        CSuiteDoc::SubSuiteList* plistSubSuites = GetSubSuiteList();

		// initialize all subsuites
        for (POSITION posSubSuite = plistSubSuites->GetHeadPosition(); posSubSuite != NULL; ) {
            CSuiteDoc::SubSuiteInfo* pSubSuiteInfo = plistSubSuites->GetNext(posSubSuite);
            // is this subsuite selected to run?
            if (pSubSuiteInfo->m_bRun) {
				APPLOG("Initializing subsuite '%s'.", (LPCSTR)pSubSuiteInfo->m_strFilename);
				// set the current directory to the subsuite's directory
				::SetCurrentDirectory(pSubSuiteInfo->m_pSubSuite->GetCWD());
				// initialize the subsuite
				if (!pSubSuiteInfo->m_pSubSuite->Initialize(pToolset)) {
					// if the subsuite initialization fails, we need to bail out
					throw CTestException("SubSuite initialization failed; unable to run tests.", CTestException::causeOperationFail);
				}
				// setup the subsuite
				pSubSuiteInfo->m_pSubSuite->SetUp(m_bCleanUpBefore);
			}
			else {
				APPLOG("Skipping initialization of subsuite '%s'.", (LPCSTR)pSubSuiteInfo->m_strFilename);
			}
		}

		// seed the random number generator
		int nSeed = SeedRandomNum(m_nRandomSeed);
		pToolset->GetLog()->RecordInfo("Random seed: %d", nSeed);
		
		// reset the state of the application
		m_currentState.Reset();

		// loop and randomly run tests until we get a failure
		// or meet the specified limit criterion
		int nTestCount = 0;
		CTime timeStart = CTime::GetCurrentTime();
		CAdjacencyList* pAdjacencyList = new CAdjacencyList;
		BOOL bMoreTests = TRUE;
		BOOL bUnderLimit = TRUE;
		BOOL bTestPass = TRUE;
		while (bMoreTests && bUnderLimit && bTestPass) {
			// get the list of tests that can be run from the current state
			// in the graph forest, this is the list of edges given the
			// current state
			pAdjacencyList->RemoveAll();
// (if a test has multiple post conditions, it will have been
//  added to the graph multiple times, so it will have a higher
//  chance of being randomly picked to run.)
			m_pGraphForest->GetStateEdges(m_currentState, pAdjacencyList);
			// remove duplicates from the list
			// (tests that have multiple post conditions will have been added
			// to the graph multiple times, so it will show up in the list
			// multiple times, too)
			// for each element in the list, check all subsequent elements
			// for potential duplicity. I think there's a more efficient
			// algorithm, but this will work for now
			for (POSITION posItem = pAdjacencyList->GetHeadPosition(); posItem != NULL; ) {
				// store the current position
				POSITION posCurrentItem = posItem;
				// get the the current item in the list
				AdjacencyListItem* pItem = pAdjacencyList->GetNext(posItem);
				CTest* pTest = pItem->m_pEdge;
				// iterate through the rest of the list
				for (POSITION posDupItem = posItem; posDupItem != NULL; ) {
					POSITION posCurrentDupItem = posDupItem;
					pItem = pAdjacencyList->GetNext(posDupItem);
					// delete any duplicates
					if (pTest == pItem->m_pEdge) {
						pAdjacencyList->RemoveAt(posCurrentDupItem);
					}
				}
				// get the next position (posItem may not be valid because
				// that item may have been deleted
				pAdjacencyList->GetNext(posCurrentItem);
				posItem = posCurrentItem;
			}

			// remove all tests marked as don't run
			for (posItem = pAdjacencyList->GetHeadPosition(); posItem != NULL; ) {
				POSITION posCurrentItem = posItem;
				AdjacencyListItem* pItem = pAdjacencyList->GetNext(posItem);
				CRandomTest* pTest = (CRandomTest*)pItem->m_pEdge;
				ASSERT(pTest->GetType() == TEST_TYPE_RANDOM);
				if (pTest->GetRunState() == CTest::RS_NoRun) {
					pAdjacencyList->RemoveAt(posCurrentItem);
				}
			}
			// are there any tests to run from the current state?
			if (pAdjacencyList->IsEmpty()) {
				bMoreTests = FALSE;
				continue;
			}
			
			// dump the list of tests to choose from
			APPLOG("List of tests to choose from:");
			for (posItem = pAdjacencyList->GetHeadPosition(); posItem != NULL; ) {
				AdjacencyListItem* pItem = pAdjacencyList->GetNext(posItem);
				CTest* pTest = pItem->m_pEdge;
				APPLOG("    %s", (LPCSTR)pTest->GetName());
			}

			// get a random number
			int nTest = GetRandomNum() % pAdjacencyList->GetCount();
			// get the test
			AdjacencyListItem* pItem = pAdjacencyList->GetAt(pAdjacencyList->FindIndex(nTest));
			CRandomTest* pTest = (CRandomTest*)pItem->m_pEdge;
			ASSERT(pTest->GetType() == TEST_TYPE_RANDOM);

			// run the test
			RunTest(pTest);
			nTestCount++;
			
			// update the current state
			// get the post-conditions from the test
			// iterate through the set (post-conditions) and update the
			// current state for each one
			CSet<CVertex> destSet = pTest->GetPostCond();
			for (POSITION destPos = destSet.GetStartPosition(); destPos != NULL; ) {
				// get the destination vertex (post-condition)
				CVertex destVertex = destSet.GetNext(destPos);
				// update the current state
				m_currentState.Update(destVertex);
			}
			
			// did the test pass?
			bTestPass = (pToolset->GetLog()->GetTestFailCount() == 0);
			
			// have we passed the limit set?
			switch (m_RandomLimit) {
				case RandomLimitNum: {
					if (nTestCount >= m_nRandomLimitNum) {
						bUnderLimit = FALSE;
					}
					break;
				}
				case RandomLimitTime: {
					if (CTime::GetCurrentTime() - timeStart >= m_RandomLimitTime) {
						bUnderLimit = FALSE;
					}
					break;
				}
			}
		}

		// record the reason for ended the random test run
		CString strReason;
		if (!bMoreTests) {
			strReason = "Random test run ended because there were no more tests to run.";
		}
		else if (!bUnderLimit) {
			strReason = "Random test run ended because the limit set by the user was hit.";
		}
		else if (!bTestPass) {
			strReason = "Random test run ended because the last test run failed.";
		}
		else {
			strReason = "Reason for ending random test run unknown.";
		}

		pToolset->GetLog()->RecordInfo("%s", (LPCSTR)strReason);
		APPLOG("%s", (LPCSTR)strReason);

		pAdjacencyList->RemoveAll();
		delete pAdjacencyList;

		// finalize all subsuites
        for (posSubSuite = plistSubSuites->GetHeadPosition(); posSubSuite != NULL; ) {
            CSuiteDoc::SubSuiteInfo* pSubSuiteInfo = plistSubSuites->GetNext(posSubSuite);
            // is this subsuite selected to run?
            if (pSubSuiteInfo->m_bRun) {
				APPLOG("Finalizing subsuite '%s'.", (LPCSTR)pSubSuiteInfo->m_strFilename);
				// set the current directory to the subsuite's directory
				::SetCurrentDirectory(pSubSuiteInfo->m_pSubSuite->GetCWD());
				// finalize the subsuite
				pSubSuiteInfo->m_pSubSuite->Finalize();
			}
			else {
				APPLOG("Skipping finalization of subsuite '%s'.", (LPCSTR)pSubSuiteInfo->m_strFilename);
			}
		}
    }
    
    // some critical system error occurred that prevents us from completing the test run
    catch (CCAFEException exception) {
    }

    // some critical error occurred that prevents us from completing the test run
    catch (CTestException exception) {
        CString strMsg;

        strMsg = "Critical error. " + exception.GetMessage() + " Aborting test run.";

        // is a log available?
        if (pToolset->GetLog()) {
            // report the error in the log
            pToolset->GetLog()->RecordCriticalError(strMsg);
        }
        else {
            // report the error via a message box
            AfxMessageBox(strMsg);
        }
    }

	return TRUE;
}

BOOL CSuiteDoc::RunSequential(CToolset* pToolset)
{
	const char* const THIS_FUNCTION = "CSuiteDoc::RunSequential";
	

    // run the tests in order
    try {

        WaitStepInstructions(INITIALIZE_STRING);

        // determine if we are persisting the target between subsuites.
		//REVIEW(chriskoz) we'd better use RTTI rather than rely on so ugly cast in order to get IDETarget
		gbPersistTarget = ((CVCTools*)pToolset)->GetIDE()->GetSettings()->GetBooleanValue(settingPersist, FALSE);
		// if we are persisting the target between subsuites, then we need to know when the last subsuite is
		// being executed so we will know to exit the target during that subsuite's Finalize routine. 
		if(gbPersistTarget)
			gbLastSubSuite = FALSE;
		
		// iterate through the selected subsuites...

		// get the list of subsuites
        CSuiteDoc::SubSuiteList* plistSubSuites = GetSubSuiteList();
		for (int CurrentCycle = 0; CurrentCycle < m_nCycleNumber; CurrentCycle++)
			{
			do 
			{
				// for each subsuite in the list,
				for (POSITION posSubSuite = plistSubSuites->GetHeadPosition(); posSubSuite != NULL; ) {
					CSuiteDoc::SubSuiteInfo* pSubSuiteInfo = plistSubSuites->GetNext(posSubSuite);

					// is this subsuite selected to run?
					if (pSubSuiteInfo->m_bRun) {

						APPLOG("Running subsuite '%s'.", (LPCSTR)pSubSuiteInfo->m_strFilename);
						
						// set the current directory to the subsuite's directory
						::SetCurrentDirectory(pSubSuiteInfo->m_pSubSuite->GetCWD());

						// get the list of tests
						CSubSuite::TestList* plistTests = pSubSuiteInfo->m_pSubSuite->GetTestList();

						// call the subsuite's Initialize function here
						if (!pSubSuiteInfo->m_pSubSuite->Initialize(pToolset)) {
							// if we can't initialize the subsuite, we need to bail out
							throw CTestException("Subsuite intialization failed; unable to run tests.", CTestException::causeOperationFail);
						}

						// let the subsuite set up before running tests
						// pass the users preference on whether to clean up before running the subsuite or not
						pSubSuiteInfo->m_pSubSuite->SetUp(m_bCleanUpBefore);

						// loop continuously, if specified
						// REVIEW(briancr): note that this will only loop through the tests in the first subsuite
						// this is due to the way running tests is designed
						// when we loop through tests, we want to do it in the same instance of the app,
						// but the app is shut down between each subsuite
						// NOTE: this is an infinite loop if m_bLoopTests is TRUE.
						// it is expected that the user will abort the test run by pressing Scroll Lock (or Ctrl+F2)
						// to break the test and then Ctrl+Shift+Alt+End to end the test (throw an exception)


						// for each test in the subsuite,
						for (POSITION posTest = plistTests->GetHeadPosition(); posTest != NULL; ) {
							CTest* pTest = plistTests->GetNext(posTest);
							// is this test selected to run?
							if (pTest->GetRunState() == CTest::RS_Run) {

								// run the test
								RunTest(pTest);
							}
							else {
								APPLOG("Skipping test '%s'.", pTest->GetName());
							}
						}
						// did the user specify to clean up after the subsuite?
						if (m_bCleanUpAfter) {
							// as long as there were no failures in the subsuite, let it clean up
							// otherwise, don't clean up
							if (pToolset->GetLog()->GetSubSuiteFailCount() == 0) {
								pSubSuiteInfo->m_pSubSuite->CleanUp();
							}
						}

						// if the next subsuite position is NULL, then we are currently in the last subsuite.
						// we only need to know this if we are persisting the target between subsuites.
						// for the last subsuite the Finalize() routine will exit the target.
						if((posSubSuite == NULL) && gbPersistTarget)
							gbLastSubSuite = TRUE;

						// call the subsuite's Finalize function
						pSubSuiteInfo->m_pSubSuite->Finalize();

					}
					else {
						APPLOG("Skipping subsuite '%s'.", (LPCSTR)pSubSuiteInfo->m_strFilename);
					}
				}
			}
		while (m_bLoopTests);
		}//end for
    }
    
    // some critical system error occurred that prevents us from completing the test run
    catch (CCAFEException exception) {
    }

    // some critical error occurred that prevents us from completing the test run
    catch (CTestException exception) {
        CString strMsg;

        strMsg = "Critical error. " + exception.GetMessage() + " Aborting test run.";

        // is a log available?
        if (pToolset->GetLog()) {
            // report the error in the log
            pToolset->GetLog()->RecordCriticalError(strMsg);
        }
        else {
            // report the error via a message box
            AfxMessageBox(strMsg);
        }
    }

	return TRUE;
}

BOOL CSuiteDoc::RunTest(CTest* pTest)
{
	// build the list of tests to run
	// generally this is just the single test
	// if dependencies are specified for a test, though
	// we'll build the list of tests here and then run them in order
	CSubSuite::TestList* plistTestsToRun = new CSubSuite::TestList;

	// always run the selected test
	plistTestsToRun->AddHead(pTest);

	// walk through dependencies
	pTest = pTest->GetDependency();
	while (pTest != NULL) {
		// should we run the dependency?
		if (pTest->RunAsDependent()) {
			// the test pointed to by pTest must be run
			// before any of the others in the list, so
			// put it at the beginning of the list
			plistTestsToRun->AddHead(pTest);
		}

		// get the test's dependency
		pTest = pTest->GetDependency();
	}

	// interate through the list of tests
	for (POSITION posTestsToRun = plistTestsToRun->GetHeadPosition(); posTestsToRun != NULL; ) {
		pTest = plistTestsToRun->GetNext(posTestsToRun);
		// add the test to the list of tests run
		m_plistTestsRun->AddTail(pTest);
		APPLOG("Running test '%s'.", pTest->GetName());

		// set the directory for the test
		::SetCurrentDirectory(pTest->GetSubSuite()->GetCWD());
		
		// determine whether the test is a normal test or a list test
		if (pTest->GetType() != TEST_TYPE_LIST) {
			// normal tests are run by this block
			pTest->PreRun();
			// dump the current state if we're randomizing
			if (GetRandomize()) {
				pTest->GetSubSuite()->GetLog()->RecordInfo("Current State: %s.", (LPCSTR)m_currentState.GetName());
			}
			pTest->Run();
			pTest->PostRun();
		}
		else {
			// list tests are run by this block
			try {
				CStdioFile file(pTest->GetListFilename(), CFile::modeRead);

				CRawListString strLine;
				file.ReadString(strLine);
				for(;!strLine.IsEmpty(); file.ReadString(strLine)) {
					strLine.TrimLeft();                                    
					if (strLine[0] != ';') {
						// list tests are run by this block
						pTest->PreRun(strLine);
						strLine.Reset();

						pTest->Run(strLine);
						strLine.Reset();

						pTest->PostRun(strLine);
						strLine.Reset();
					}
				}
			}
			catch(CFileException* e) {
				if(e->m_cause == CFileException::fileNotFound ) {
					APPLOG("Couldn't find list file: %s\n", (LPCSTR)pTest->GetListFilename());
					pTest->GetSubSuite()->GetLog()->RecordFailure("Couldn't find list file: %s", (LPCSTR)pTest->GetListFilename());
				}
				else {
					APPLOG("Couldn't read the list file: %s\n", (LPCSTR)pTest->GetListFilename());
					pTest->GetSubSuite()->GetLog()->RecordFailure("Couldn't read the list file: %s", (LPCSTR)pTest->GetListFilename());
				}
			}
		}
	}
	// delete the list of tests that we ran
	delete plistTestsToRun;
	
	return TRUE;
}

void CSuiteDoc::SetLogDebugOutput(BOOL bLogDebugOutput)
{
	m_bLogDebugOutput = bLogDebugOutput;

	if (gpLog)
		gpLog->SetLogDebugOutput(bLogDebugOutput);
}

/////////////////////////////////////////////////////////////////////////////
// Internal operations

BOOL CSuiteDoc::ReadSuite(CString &strFilename)
{
    // the filename must not be empty
    ASSERT(strFilename);
    ASSERT(!strFilename.IsEmpty());
	
	//here's the very obscure method of determining what template are we in
	//there is no easier way to determine it in MFC
	CString strTemplExt; //file extention opened in the current document
	if(GetDocTemplate( )->GetDocString(strTemplExt, CDocTemplate::filterExt))
	{
		CString strDLLExt;
		strDLLExt.LoadString(IDR_DLLTYPE); //contains ".dll"
		if (strDLLExt.Find(strTemplExt) >0) //we are in IDR_DLLTYPE template
		{ // open the subsuite DLL directly
			// clear the list of subsuites
			// REVIEW(briancr): do we need to unload anything here?
			m_listSubSuites.RemoveAll();
			AddSubSuiteEntry(strFilename);
			return TRUE;
		}
	}
    // get a pointer to the app
    CCAFEDriver *pApp = ((CCAFEDriver *)AfxGetApp());

    CStdioFile fileSuite;
    CString strSubSuiteEntry;
	
    // open the suite file
    if (fileSuite.Open(strFilename, CFile::modeRead))
	{
        APPLOG("Reading suite file (%s).", (LPCTSTR)strFilename);
		// Determine the abolute paths to each subsuite to be loaded.

	   	CString fname, Drive, Ext, Path, FullPath ;
		FullPath = strFilename;
		_splitpath((const char *) FullPath,Drive.GetBuffer(_MAX_DRIVE), Path.GetBuffer(_MAX_DIR),
		fname.GetBuffer(_MAX_FNAME), Ext.GetBuffer(_MAX_EXT) );

		Drive.ReleaseBuffer() ;
		Path.ReleaseBuffer() ;
		Path = Drive+Path;

        // clear the list of subsuites
        // REVIEW(briancr): do we need to unload anything here?
        m_listSubSuites.RemoveAll();

        // read each subsuite entry from the suite file
        while (fileSuite.ReadString(strSubSuiteEntry.GetBuffer(1023), 1023) != NULL) 
		{
            strSubSuiteEntry.ReleaseBuffer();

            // allow comments by placing a semi-colon (;) in the first position
            if (strSubSuiteEntry.GetAt(0) != ';') 
			{
                // remove leading white space
                EliminateLeadingChars(strSubSuiteEntry, " \t");

                // remove trailing \n
                EliminateTrailingChars(strSubSuiteEntry, "\n");
				// find if it's the subsuite entry which matches the build of CADEDRV
				
				// as long as the entry's not empty
				if (!strSubSuiteEntry.IsEmpty())
				{
					CString strOtherSign,strCurrentSign;
					#ifdef _DEBUG
					strCurrentSign="<DEBUG>";
					strOtherSign="<RETAIL>";
					#else
					strCurrentSign="<RETAIL>";
					strOtherSign="<DEBUG>";
					#endif
					if(strSubSuiteEntry.Find(strOtherSign)==0)
						continue;
					if(strSubSuiteEntry.Find(strCurrentSign)==0)
					{
						strSubSuiteEntry=strSubSuiteEntry.Mid(strCurrentSign.GetLength());
		                EliminateLeadingChars(strSubSuiteEntry, " \t");
					}
					else
					{
						TRACE("CAFE warning: Subsuite entry: '%s' build not marked",strSubSuiteEntry);
						APPLOG("CAFE warning: Subsuite entry: '%s' build not marked",strSubSuiteEntry);
					}

					AddSubSuiteEntry(strSubSuiteEntry, Path);
				}
            }
        }

        // close the suite file
        fileSuite.Close();

        // if there were no entries in the suite file, report an error
        if (m_listSubSuites.IsEmpty()) {
            pApp->ErrorMsg(IDS_ErrNoSubSuiteEntries, (LPCTSTR)strFilename);
            return FALSE;
        }

        return TRUE;
    }
    else
	{
        pApp->ErrorMsg(IDS_ErrOpenSuiteFile, (LPCTSTR)strFilename);
        return FALSE;
    }
}

void CSuiteDoc::AddSubSuiteEntry(CString const &strSubSuiteEntry, LPCSTR SuitePath /* =NULL */)
{	//REVIEW(chriskoz)
	//when SuitePath is NULL, it means the DLL is loading directly, without any params
	//so I skip the param parsing (maybe will need to review later)
    CString strSubSuiteFilename;
    CString strSubSuiteParams;
    CSuiteDoc::SubSuiteInfo *pSubSuiteInfo;
	int nPos;
	
	ASSERT(!strSubSuiteEntry.IsEmpty());
	// separate the entry into the filename and params
	if(strSubSuiteEntry[0]=='\"')
	{ // the filename ends at the matching quote
		nPos = strSubSuiteEntry.Find('\"',1); //skip the first quote
	}
	else
	{	// the filename ends at the first white space
		nPos = strSubSuiteEntry.FindOneOf(" \t");
	}
	if (nPos == -1) 
	{
		nPos = strSubSuiteEntry.GetLength();
	}
	if(SuitePath!=NULL)
	{
		strSubSuiteFilename = strSubSuiteEntry.Left(nPos);
		if(strSubSuiteEntry[0]=='\"')
		{	//name was enclosed in quotes
			strSubSuiteFilename=strSubSuiteFilename.Mid(1); //cut the first quote
			nPos++; //skip the enclosing quote while taking params
		}
		strSubSuiteParams = strSubSuiteEntry.Mid(nPos);
	}
	else
		strSubSuiteFilename=strSubSuiteEntry;
		// remove leading white space from params
		EliminateLeadingChars(strSubSuiteParams, " \t");
		// If the entry does not contain a drive letter or "\"
		// prepend to it the suite directory path.
		if((strSubSuiteFilename.Find(":") == -1) &&
			(strSubSuiteFilename.Left(1) != "\\") &&
			SuitePath!=NULL)
			strSubSuiteFilename = CString(SuitePath) + strSubSuiteFilename ;

		// store this entry in the subsuite list
		pSubSuiteInfo = new SubSuiteInfo;
		pSubSuiteInfo->m_pSubSuite = NULL;
		pSubSuiteInfo->m_hDLL = NULL;
		pSubSuiteInfo->m_strFilename = strSubSuiteFilename;
		pSubSuiteInfo->m_strParams = strSubSuiteParams;
		pSubSuiteInfo->m_bRun = TRUE;
		pSubSuiteInfo->m_dwId = 0;
	
		m_listSubSuites.AddTail(pSubSuiteInfo);
}


BOOL CSuiteDoc::WriteSuite(CString &strFilename)
{
    // the filename must not be empty
    ASSERT(strFilename);
    ASSERT(!strFilename.IsEmpty());

    // get a pointer to the app
    CCAFEDriver *pApp = ((CCAFEDriver *)AfxGetApp());

    CStdioFile fileSuite;
    CSuiteDoc::SubSuiteInfo *pSubSuiteInfo;
    CString strSubSuiteEntry;

    // open the suite file
    if (fileSuite.Open(strFilename, CFile::modeCreate | CFile::modeWrite)) {

        ::OutputDebugString("Writing suite file: "+strFilename+"\n");

        // REVIEW(briancr): note that comments are thrown away

        // write each subsuite entry to the suite file
        for (POSITION pos = m_listSubSuites.GetHeadPosition(); pos != NULL; ) {
            pSubSuiteInfo = m_listSubSuites.GetNext(pos);
            strSubSuiteEntry = pSubSuiteInfo->m_strFilename+" "+pSubSuiteInfo->m_strParams+"\n";
            fileSuite.WriteString(strSubSuiteEntry);
        }

        // close the suite file
        fileSuite.Close();
        return TRUE;
    }
    else {
        pApp->ErrorMsg(IDS_ErrOpenSuiteFile, (LPCTSTR)strFilename);
        return FALSE;
    }
}


BOOL CSuiteDoc::LoadSubSuites(void)
{
    POSITION pos;
    POSITION posCur;

    // the subsuite list cannot be empty
    ASSERT(!m_listSubSuites.IsEmpty());

    CSuiteDoc::SubSuiteInfo *pSubSuiteInfo;

    // REVIEW(briancr): should we unload any that are loaded? Will ReadSuite take care of this?

    // load each subsuite
    for (pos = m_listSubSuites.GetHeadPosition(); pos != NULL; ) {
        posCur = pos;
        pSubSuiteInfo = m_listSubSuites.GetNext(pos);

        // load the subsuite into at the given position
        if (!LoadSubSuite(pSubSuiteInfo)) {
            m_listSubSuites.RemoveAt(posCur);
        }
    }

	// build the graph forest for all randomizable tests loaded
	BuildGraphForest();

    return TRUE;
}

// typedef for IsDebugBuild and CreateSubSuite function in subsuite DLL
extern "C" typedef BOOL (*ISDEBUGBUILD)(void);
extern "C" typedef CSubSuite* (* CREATESUBSUITE)(LPCSTR);

BOOL CSuiteDoc::LoadSubSuite(CSuiteDoc::SubSuiteInfo *pSubSuiteInfo)
{
    const int cBuf = 1000;
	char aBuf[cBuf];

	// the filename cannot be empty
    ASSERT(!pSubSuiteInfo->m_strFilename.IsEmpty());

    // get a pointer to the app
    CCAFEDriver *pApp = ((CCAFEDriver *)AfxGetApp());

    BOOL bLoadSuccess = TRUE;

    HINSTANCE hSubSuiteDLL;
    ISDEBUGBUILD funcIsDebugBuild;
    CREATESUBSUITE funcCreateSubSuite;
    CSubSuite *pSubSuite;

    // load the subsuite (DLL)
    hSubSuiteDLL = ::LoadLibrary(pSubSuiteInfo->m_strFilename);
    if (hSubSuiteDLL != NULL) {
        // get the address of the IsDebugBuild function is subsuite DLL
        funcIsDebugBuild = (ISDEBUGBUILD)::GetProcAddress(hSubSuiteDLL, "IsDebugBuild");
        if (funcIsDebugBuild != NULL) {
            // if the build types don't match, report error
            #ifdef _DEBUG
            if (!funcIsDebugBuild()) {
				sprintf(aBuf, "Unable to properly load the subsuite '%s' because it is a retail build and the driver is a debug build.", (LPCTSTR)pSubSuiteInfo->m_strFilename);
                pApp->ErrorMsg(aBuf);
            #else
            if (funcIsDebugBuild()) {
                sprintf(aBuf, "Unable to properly load the subsuite '%s' because it is a debug build and the driver is a retail build.", (LPCTSTR)pSubSuiteInfo->m_strFilename);
				pApp->ErrorMsg(aBuf);
            #endif
                bLoadSuccess = FALSE;
            }
            // if the build types match, continue loading
            else {
                // get the address of the CreateSubSuite function in the subsuite
                funcCreateSubSuite = (CREATESUBSUITE)::GetProcAddress(hSubSuiteDLL, "CreateSubSuite");
                if (funcCreateSubSuite != NULL) {

                    // call the CreateSubSuite function in the subsuite
                    // get a pointer to the subsuite object in the subsuite DLL
                    pSubSuite = funcCreateSubSuite(pSubSuiteInfo->m_strParams);
					pSubSuite->m_SuiteParams=pApp->ReadCmdLineSwitches(pSubSuite->m_CmdLine);

                    // store the pointer to the subsuite and the handle to the DLL in the subsuite info
                    pSubSuiteInfo->m_pSubSuite = pSubSuite;
                    pSubSuiteInfo->m_hDLL = hSubSuiteDLL;
                    pSubSuiteInfo->m_dwId = ++m_cSubSuites;

                    // initialize the subsuite
                    pSubSuiteInfo->m_pSubSuite->LoadInitialization(pSubSuiteInfo->m_hDLL);
                    APPLOG("Loaded subsuite (%s).", (LPCSTR)pSubSuiteInfo->m_strFilename);
                }
                // CreateSubSuite entry point not found
                else {
					sprintf(aBuf, "Unable to properly load the subsuite '%s' because it does not contain a CreateSubSuite function.", (LPCTSTR)pSubSuiteInfo->m_strFilename);
                    pApp->ErrorMsg(aBuf);
                    bLoadSuccess = FALSE;
                }
            }
        }
        // IsDebugBuild entry point not found
        else {
            sprintf(aBuf, "Unable to properly load the subsuite '%s' because it does not contains an IsDebugBuild function.", (LPCTSTR)pSubSuiteInfo->m_strFilename);
			pApp->ErrorMsg(aBuf);
            bLoadSuccess = FALSE;
        }

        // was there some problem with the DLL loaded?
        if (!bLoadSuccess) {
            // unload the DLL
            ::FreeLibrary(hSubSuiteDLL);
        }
    }
    // error from LoadLibrary
    else {
		// report the error to the user
		char aBufErr[500];
		DWORD dwError = ::GetLastError();

		switch (dwError) {
			// general failure
			case ERROR_GEN_FAILURE: {
				sprintf(aBufErr, "A general failure occurred");
				break;
			}
			// DLL init failed
			case ERROR_DLL_INIT_FAILED: {
				sprintf(aBufErr, "A dynamic link library (DLL) initialization routine failed");
				break;
			}
			// invalid DLL
			case ERROR_BAD_EXE_FORMAT:
			case ERROR_INVALID_DLL: {
				sprintf(aBufErr, "The DLL file is invalid, corrupt, or damaged");
				break;
			}
			// DLL not found
			case ERROR_MOD_NOT_FOUND:
			case ERROR_DLL_NOT_FOUND: {
				sprintf(aBufErr, "The DLL file cannot be found");
				break;
			}
			default: {
				sprintf(aBufErr, "Unknown error");
				break;
			}
		}

		sprintf(aBuf, "An error occurred loading subsuite '%s': %s. GetLastError = %d.", (LPCTSTR)pSubSuiteInfo->m_strFilename, aBufErr, dwError);
		pApp->ErrorMsg(aBuf);
        bLoadSuccess = FALSE;
    }

    return bLoadSuccess;
}

void CSuiteDoc::BuildGraphForest(void)
{
	m_pGraphForest = new CGraphForest;

	// iterate through all the loaded tests and add all tests that are randomizable
    SubSuiteInfo* pSubSuiteInfo;
	CSubSuite::TestList* plistTests;
	CTest* pTest;
	POSITION posSubSuite;
	POSITION posTest;
	// iterate through each subsuite
    for (posSubSuite = m_listSubSuites.GetHeadPosition(); posSubSuite != NULL; ) {
        pSubSuiteInfo = m_listSubSuites.GetNext(posSubSuite);
		// get the list of tests
		plistTests = pSubSuiteInfo->m_pSubSuite->GetTestList();
		// iterate through each test
		for (posTest = plistTests->GetHeadPosition(); posTest != NULL; ) {
			pTest = plistTests->GetNext(posTest);

			// is this a randomizable test?
			if (pTest->GetType() == TEST_TYPE_RANDOM) {
				// add the test to the graph forest
				// get the pre- and post-condition(s)
				CSet<CVertex> srcSet = ((CRandomTest*)pTest)->GetPreCond();
				CSet<CVertex> destSet = ((CRandomTest*)pTest)->GetPostCond();
				// multiple pre-conditions are ORed together
				// multiple post-conditions are ANDed together
				// so for each pre-condition vertex, add all the post-conditions
				// vertices eminating from it
				for (POSITION srcPos = srcSet.GetStartPosition(); srcPos != NULL; ) {
					// get the source vertex (pre-condition)
					CVertex srcVertex = srcSet.GetNext(srcPos);
					for (POSITION destPos = destSet.GetStartPosition(); destPos != NULL; ) {
						// get the destination vertex (post-condition)
						CVertex destVertex = destSet.GetNext(destPos);
						// add the edge (test) to the graph
						m_pGraphForest->AddEdge(pTest, srcVertex, destVertex);
					}
				}
			}
		}
	}
}

BOOL CSuiteDoc::EliminateLeadingChars(CString &str, CString strSet)
{
    // the set string should not be empty
    ASSERT(!strSet.IsEmpty());

    while (str.FindOneOf(strSet) == 0) {
        str = str.Mid(1);
    }

    return TRUE;
}

BOOL CSuiteDoc::EliminateTrailingChars(CString &str, CString strSet)
{
    // the set string should not be empty
    ASSERT(!strSet.IsEmpty());

    if (str.IsEmpty()) {
        return TRUE;
    }
    while (!str.IsEmpty() && str.FindOneOf(strSet) == str.GetLength()-1) {
        str = str.Left(str.GetLength()-1);
    }

    return TRUE;
}

void CSuiteDoc::DelegateSuiteExecution(void)
{
  ((CCAFEDriver*)AfxGetApp())->CallRunSuite(this);
}

int CSuiteDoc::SeedRandomNum(int nSeed)
{
	// if a seed is not specified (zero), use the system time
	if (!nSeed) {
		nSeed = (int)time(NULL);
	}
	srand(nSeed);

	return nSeed;
}

int CSuiteDoc::GetRandomNum(void)
{
	return rand();
}

#ifdef _DEBUG
void CSuiteDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CSuiteDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSuiteDoc serialization

void CSuiteDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\tbdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	tbdlg.cpp
//
//	Created by :			Date :
//		BrianCr				5/24/95
//
//	Description :
//		Implementation of the CToolbarsDlg class
//

#include "stdafx.h"
#include "tbDlg.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolbarsDlg dialog


CToolbarsDlg::CToolbarsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CToolbarsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CToolbarsDlg)
	m_bShowCAFEToolbar = FALSE;
	m_bShowStatusBar = FALSE;
	m_bShowSubSuiteToolbar = FALSE;
	m_bShowViewportToolbar = FALSE;
	//}}AFX_DATA_INIT
}


void CToolbarsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CToolbarsDlg)
	DDX_Check(pDX, IDC_ShowCAFEToolbar, m_bShowCAFEToolbar);
	DDX_Check(pDX, IDC_ShowStatusBar, m_bShowStatusBar);
	DDX_Check(pDX, IDC_ShowSubSuiteToolbar, m_bShowSubSuiteToolbar);
	DDX_Check(pDX, IDC_ShowViewportToolbar, m_bShowViewportToolbar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolbarsDlg, CDialog)
	//{{AFX_MSG_MAP(CToolbarsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolbarsDlg message handlers

BOOL CToolbarsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitevw.h ===
/////////////////////////////////////////////////////////////////////////////
// suitevw.h
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Interface of the CSuiteView class

#ifndef __SUITEVW_H__
#define __SUITEVW_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "treectl.h"
#include "suitedoc.h"


/////////////////////////////////////////////////////////////////////////////
// CSuiteView view

class CSuiteView : public CView
{
protected:
	CSuiteView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CSuiteView)

// Attributes
public:

// Operations
public:

// attributes (internal)
protected:
	#ifdef _DEBUG
		CSuiteDoc* GetDocument();
	#else
		inline CSuiteDoc* CSuiteView::GetDocument() { return (CSuiteDoc*)m_pDocument; }
	#endif


// operations (internal)
protected:
	void FillTree(void);
	BOOL UpdateSuite(void);

// data
protected:
	CTreeCtl* m_ptreeSuite;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSuiteView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CSuiteView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CSuiteView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSubSuiteRun();
	afx_msg void OnSubSuiteAdd();
	afx_msg void OnSubSuiteDelete();
	afx_msg void OnSubSuiteSelectAll();
	afx_msg void OnSubSuiteDeselectAll();
	afx_msg void OnSubSuiteToggleAll();
	afx_msg void OnSubSuiteProperties();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnOptionsSuite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // __SUITEVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\suitedoc.h ===
/////////////////////////////////////////////////////////////////////////////
// suitedoc.h
//
// email        date            change
// briancr      10/25/94        created
//
// copyright 1994 Microsoft

// Interface of the CSuiteDoc class

#ifndef __SUITEDOC_H__
#define __SUITEDOC_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "subsuite.h"
#include "portdoc.h"
#include "graph.h"

/////////////////////////////////////////////////////////////////////////////
// CSuiteDoc document

class CSuiteDoc : public CDocument
{
// data types
public:
	struct SubSuiteInfo
	{
		CSubSuite *m_pSubSuite;
		HINSTANCE m_hDLL;
		CString m_strFilename;
		CString m_strParams;
		BOOL m_bRun;
		DWORD m_dwId;
	};
	typedef CTypedPtrList<CPtrList, SubSuiteInfo*> SubSuiteList;

// constructor/destructor
protected:
	CSuiteDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CSuiteDoc)

// Attributes
public:
	SubSuiteList* GetSubSuiteList(void);

// Operations
public:

// Initialize doc data members
	void SetConsolePortDoc();
	void SetLogViewPortDoc(); 

	BOOL AddSubSuite(int Index, CString &strFilename, CString &strParams);
	BOOL RemoveSubSuite(int Index);
	BOOL Run(void);
	BOOL CreateViewports(void);

	UINT RunSuite(void);

// Log data attributes
	void SetResultsFile(LPCSTR pszResultsFile)                      { m_strResultsFile = pszResultsFile; }
	void SetSummaryFile(LPCSTR pszSummaryFile)                      { m_strSummaryFile = pszSummaryFile; }
	void SetWorkingDir(LPCSTR pszWorkingDir)                        { m_strWorkingDir = pszWorkingDir; }
	void SetMaxFail(int nMaxFail)                                           { m_nMaxFail = nMaxFail; }
	void SetPostResults(BOOL bPostResults)                          { m_bPostResults = bPostResults; }
	void SetRecordComments(BOOL bRecordComments)            { m_bRecordComments = bRecordComments; }
	void SetLogDebugOutput(BOOL bLogDebugOutput);

	CString GetResultsFile(void)                                            { return m_strResultsFile; }
	CString GetSummaryFile(void)                                            { return m_strSummaryFile; }
	CString GetWorkingDir(void)                                                     { return m_strWorkingDir; }
	int GetMaxFail(void)                                                            { return m_nMaxFail; }
	BOOL GetPostResults(void)                                                       { return m_bPostResults; }
	BOOL GetRecordComments(void)                                            { return m_bRecordComments; }
	BOOL GetLogDebugOutput(void)                                            { return m_bLogDebugOutput; }

// Suite data attributes
	enum RandomLimit { RandomLimitNone, RandomLimitNum, RandomLimitTime };
	
	void SetCleanUpBefore(BOOL bCleanUpBefore)                      { m_bCleanUpBefore = bCleanUpBefore; }
	void SetCleanUpAfter(BOOL bCleanUpAfter)                        { m_bCleanUpAfter = bCleanUpAfter; }
	void SetCycleNumber(int nCycleNumber)                                      { m_nCycleNumber = nCycleNumber; }
	void SetLoopTests(BOOL bLoopTests)                                      { m_bLoopTests = bLoopTests; }
	void SetRandomize(BOOL bRandomize)                                      { m_bRandomize = bRandomize; }
	void SetRandomSeed(int nRandomSeed)                                     { m_nRandomSeed = nRandomSeed; }
	void SetRandomLimit(RandomLimit limit)                          { m_RandomLimit = limit; }
	void SetRandomLimitNum(int nLimit)                                      { m_nRandomLimitNum = nLimit; }
	void SetRandomLimitTime(CTimeSpan& time)                        { m_RandomLimitTime = time; }

	BOOL GetCleanUpBefore(void)                                                     { return m_bCleanUpBefore; }
	BOOL GetCleanUpAfter(void)                                                      { return m_bCleanUpAfter; }
	int GetCycleNumber(void)                                                         { return m_nCycleNumber; }
	BOOL GetLoopTests(void)                                                         { return m_bLoopTests; }
	BOOL GetRandomize(void)                                                         { return m_bRandomize; }
	int GetRandomSeed(void)                                                         { return m_nRandomSeed; }
	RandomLimit GetRandomLimit(void)                                        { return m_RandomLimit; }
	int GetRandomLimitNum(void)                                                     { return m_nRandomLimitNum; }
	CTimeSpan GetRandomLimitTime(void)                                      { return m_RandomLimitTime; }

	BOOL CanRandomize(void)                                                         { ASSERT(m_pGraphForest); return !m_pGraphForest->IsEmpty(); }
	CGraphForest* GetGraphForest(void)                                      { ASSERT(m_pGraphForest); return m_pGraphForest; }

	CSubSuite::TestList* GetTestsRunList(void)                      { return m_plistTestsRun; }
	CState* GetCurrentState(void)                                           { return &m_currentState; }

// Internal operations
protected:
	BOOL RunRandom(CToolset* pToolset);
	BOOL RunSequential(CToolset* pToolset);
	BOOL RunTest(CTest* pTest);

	BOOL ReadSuite(CString &strFilename);
	void AddSubSuiteEntry(CString const &strSubSuiteEntry, LPCSTR SuitePath = NULL);

	BOOL WriteSuite(CString &strFilename);
	BOOL LoadSubSuites(void);
	BOOL LoadSubSuite(SubSuiteInfo *pSubSuiteInfo);

	void BuildGraphForest(void);

	BOOL EliminateLeadingChars(CString &str, CString strSet);
	BOOL EliminateTrailingChars(CString &str, CString strSet);

	int SeedRandomNum(int nSeed);
	int GetRandomNum(void);
	
//      static UINT WrapRunSuite(LPVOID pParam) { return ((CSuiteDoc*)pParam)->RunSuite(); }

  void DelegateSuiteExecution(void);

// Data
protected:
	// data types
	SubSuiteList m_listSubSuites;

	// this suite's log viewport document
	CViewportDoc* m_pLogViewport;

	// this suite's console viewport document
	CViewportDoc* m_pConsoleViewport;

	// suite thread
	CWinThread* m_pthreadSuite;

  static int m_cSubSuites;
  static unsigned m_uDocCount;

	BOOL m_bViews;

	// store a list of the tests run
	CSubSuite::TestList* m_plistTestsRun;

	// store the current state of the app (for random tests)
	CState m_currentState;

// suite data
protected:
	BOOL m_bCleanUpBefore;
	BOOL m_bCleanUpAfter;
	int m_nCycleNumber;
	BOOL m_bLoopTests;
	BOOL m_bRandomize;
	int m_nRandomSeed;
	RandomLimit m_RandomLimit;
	int m_nRandomLimitNum;
	CTimeSpan m_RandomLimitTime;

	CGraphForest* m_pGraphForest;

// log data
protected:
	CString m_strResultsFile;
	CString m_strSummaryFile;
	CString m_strWorkingDir;
	int m_nMaxFail;
	BOOL m_bPostResults;
	BOOL m_bRecordComments;
	BOOL m_bLogDebugOutput;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSuiteDoc)
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument() ;

// Implementation
public:
	virtual ~CSuiteDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// the view is a friend of the doc
	friend class CSuiteView;

};

#endif // __TESTDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\tbDlg.h ===
///////////////////////////////////////////////////////////////////////////////
//	tbdlg.h
//
//	Created by :			Date :
//		BrianCr				5/24/95
//
//	Description :
//		Definition of the CToolbarsDlg class
//

#include "caferes.h"

/////////////////////////////////////////////////////////////////////////////
// CToolbarsDlg dialog

class CToolbarsDlg : public CDialog
{
// Construction
public:
	CToolbarsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CToolbarsDlg)
	enum { IDD = IDD_Toolbars };
	BOOL	m_bShowCAFEToolbar;
	BOOL	m_bShowStatusBar;
	BOOL	m_bShowSubSuiteToolbar;
	BOOL	m_bShowViewportToolbar;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CToolbarsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CToolbarsDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\treectl.cpp ===
/////////////////////////////////////////////////////////////////////////////
// treectl.cpp
//
// email	date		change
// briancr	11/01/94	created
//
// copyright 1994 Microsoft

// Implementation of the CTreeCtl, CTreeListBox, CNode, and CImageWell classes
// Much of this code was copied from the IDE

#include "stdafx.h"
#include "treectl.h"
#include "caferes.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl

int CTreeCtl::c_cyBorder = GetSystemMetrics(SM_CYBORDER);
int CTreeCtl::c_cyBorderX2 = c_cyBorder * 2;

CImageWell CTreeCtl::m_Glyphs;

// NOTE: We invert the standard MFC GetHalftoneBrush since this code was
// written to line up dots based on our old GetHalftoneBrush which was
// one off from MFC's...
#define NOTPATCOPY 0x000F0001	// Pn

IMPLEMENT_DYNAMIC(CTreeListBox, CWnd)

BEGIN_MESSAGE_MAP(CTreeListBox, CWnd)
	//{{AFX_MSG_MAP(CTreeListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_CHAR()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CTreeCtl, CWnd)

BEGIN_MESSAGE_MAP(CTreeCtl, CWnd)
	//{{AFX_MSG_MAP(CTreeCtl)
	ON_WM_CHARTOITEM()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_WM_VKEYTOITEM()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_SETFONT, OnSetFont)
	ON_MESSAGE(WM_GETFONT, OnGetFont)
	ON_LBN_DBLCLK(IDCW_TREELISTBOX, OnLbDblClk)
	ON_LBN_SELCHANGE(IDCW_TREELISTBOX, OnLbSelChange)
	ON_LBN_SETFOCUS(IDCW_TREELISTBOX, InvalSelection)
	ON_LBN_KILLFOCUS(IDCW_TREELISTBOX, InvalSelection)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl ctor/dtor

CTreeCtl::CTreeCtl(BOOL bIsMultiSelection /*= FALSE*/, BOOL bStickySelection /*= FALSE*/, BOOL bKeepSelectionRect /*=FALSE*/)
{
	m_Glyphs.Add(IDB_GlyphExpanded);
	m_Glyphs.Add(IDB_GlyphCollapsed);
	m_Glyphs.Add(IDB_GlyphTest);
	m_Glyphs.Add(IDB_GlyphBadTest);

	m_bIsMultiSelection = bIsMultiSelection;
	m_bKeepSelectionRect= bKeepSelectionRect;
	// sticky selection overrides multiselection
	m_bStickySelection = bStickySelection;
	if (m_bStickySelection) {
		m_bIsMultiSelection = !m_bStickySelection;
	};
	m_EnableUpdates = 0;
	m_bEnableDragDrop = FALSE;
	m_bShowContextPopup = FALSE;
	m_bShowProperties = FALSE;
	m_timeLastKey = 0;
	m_pTree = new CNode("Tree root");
	m_pTree->SetFlags(TF_HIDDEN);
}

CTreeCtl::~CTreeCtl()
{
	m_Glyphs.Remove(IDB_GlyphExpanded);
	m_Glyphs.Remove(IDB_GlyphCollapsed);
	m_Glyphs.Remove(IDB_GlyphTest);
	m_Glyphs.Remove(IDB_GlyphBadTest);

	if (m_hWnd != NULL)
		DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl Window operations

BOOL CTreeCtl::PreCreateWindow(CREATESTRUCT& cs)
{
	if (cs.lpszClass == NULL)
		cs.lpszClass = AfxRegisterWndClass(0);
			
	return TRUE;
}

void CTreeCtl::KeySetSel(int nIndex, BOOL bClearSearchBuffer)
{
	// called when user selects a specific item with the keyboard
	if (bClearSearchBuffer)
		ClearSearchBuffer();

	if (m_bIsMultiSelection)
		SetSel(-1, FALSE);

	SetSel(nIndex, TRUE);
	OnLbSelChange();
}

int CTreeCtl::SetSel(int nIndex, BOOL bSelect /*= TRUE*/)
{
	CNode* pNode;

	// this function only works with multiple selection list boxes
	ASSERT((m_pListBox->GetStyle() & LBS_EXTENDEDSEL) || (m_pListBox->GetStyle() & LBS_MULTIPLESEL));

	// if we're selecting a single item, mark its node as selected, too
	if (nIndex >= 0) {
		pNode = GetLBNode(nIndex);
		if (bSelect) {
			pNode->SetFlags(TF_SELECTED);
		}
		else {
			pNode->ClearFlags(TF_SELECTED);
		}
	}

	return m_pListBox->SetSel(nIndex, bSelect);
}

void CTreeCtl::SelectAll(void)
{
	// this function only works with multiple selection list boxes
	ASSERT((m_pListBox->GetStyle() & LBS_EXTENDEDSEL) || (m_pListBox->GetStyle() & LBS_MULTIPLESEL));

	// mark each node as selected, starting with the root
	ForEach(m_pTree, &CTreeCtl::SetSelOne);

	// select all items in the list
	SetSel(-1, TRUE);
}

void CTreeCtl::DeselectAll(void)
{
	// this function only works with multiple selection list boxes
	ASSERT((m_pListBox->GetStyle() & LBS_EXTENDEDSEL) || (m_pListBox->GetStyle() & LBS_MULTIPLESEL));

	// mark each node as deselected, starting with the root
	ForEach(m_pTree, &CTreeCtl::SetDeselOne);

	// deselect all items in the list
	SetSel(-1, FALSE);
}

void CTreeCtl::ToggleAll(void)
{
	// this function only works with multiple selection list boxes
	ASSERT((m_pListBox->GetStyle() & LBS_EXTENDEDSEL) || (m_pListBox->GetStyle() & LBS_MULTIPLESEL));

	// toggle each node, starting with the root
	ForEach(m_pTree, &CTreeCtl::ToggleSelOne);

	// invalidate the window to repaint everything
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTreeCtl Node operations

CNode* CTreeCtl::InsertNode(CNode *pParent, CString strText, DWORD dwData /*= 0*/, int nIndex /*= -1*/, UINT idGlyphClose /*= IDB_GlyphFolderClose*/, UINT idGlyphOpen /*= IDB_GlyphFolderOpen*/, BOOL bSelected /*= TRUE*/)
{
	CNode *pNode;
	CNode *pRetNode;

	// the text must not be empty
	ASSERT(!strText.IsEmpty());

	// create a new node
	pNode = new CNode(strText, dwData, pParent, idGlyphClose, idGlyphOpen);

	// set selected flag
	pNode->SetFlags(bSelected ? TF_SELECTED : 0);

	// insert this node
	pRetNode = InsertNode(pParent, pNode, nIndex);
	if (!pRetNode) {
		// delete the node
		delete pNode;
	}
	return pRetNode;
}

CNode* CTreeCtl::InsertNode(CNode *pParent, CNode *pNode, int nIndex /*= -1*/)
{
	CNode::CNodeList *plistChildren;
	POSITION pos;

	// if the parent node is NULL, insert the new node at the root
	if (!pParent) {
		pParent = m_pTree;
	}

	// get the list of children for this node
	plistChildren = pParent->GetChildren();

	// if there are any children, clear the LASTLEVELENTRY flag from the last child
	if (!plistChildren->IsEmpty()) {
		plistChildren->GetTail()->ClearFlags(TF_LASTLEVELENTRY);
	}

	// if index < 0 or >= number of children, insert the new node at the end of the child list
	if (nIndex < 0 || nIndex >= plistChildren->GetCount()) {
		plistChildren->AddTail(pNode);
	}
	// otherwise, insert at the given index
	else {
		pos = plistChildren->FindIndex(nIndex);
		// this should never be NULL
		ASSERT(pos);
		plistChildren->InsertAfter(pos, pNode);
	}

	// set the LASTLEVELENTRY flag for the last child
	plistChildren->GetTail()->SetFlags(TF_LASTLEVELENTRY);

	// expand the parent when a new child is added
	Expand(pParent, FALSE);

	return pNode;
}

BOOL CTreeCtl::RemoveNode(CNode *pParent, int nIndex /*= -1*/)
{
	CNode::CNodeList *plistChildren;
	CNode *pNode;
	POSITION pos;

	// if the parent node is NULL, remove the node from the root
	if (!pParent) {
		pParent = m_pTree;
	}

	// get the list of children for this node
	plistChildren = pParent->GetChildren();

	// if there are no children, don't remove any
	if (plistChildren->IsEmpty()) {
		return FALSE;
	}

	// clear the LASTLEVELENTRY flag from the last child
	plistChildren->GetTail()->ClearFlags(TF_LASTLEVELENTRY);

	// if index < 0 or >= number of children, remove the last node in the list
	if (nIndex < 0 || nIndex >= plistChildren->GetCount()) {
		pNode = plistChildren->RemoveTail();
	}
	// otherwise, remove the node at the given index
	else {
		pos = plistChildren->FindIndex(nIndex);
		// this should never be NULL
		ASSERT(pos);
		pNode = plistChildren->GetAt(pos);
		plistChildren->RemoveAt(pos);
	}
	
	// as long as there are more children, set the LASTLEVELENTRY flag for the last child
	if (!plistChildren->IsEmpty()) {
		plistChildren->GetTail()->SetFlags(TF_LASTLEVELENTRY);
	}

	// delete the node
	delete pNode;

	return TRUE;
}

CNode *CTreeCtl::GetNode(CNode *pParent, int nIndex /*= -1*/)
{
	CNode::CNodeList *plistChildren;
	CNode *pNode;
	POSITION pos;

	// if the parent node is NULL, get the node from the root
	if (!pParent) {
		pParent = m_pTree;
	}

	// get the list of children for this node
	plistChildren = pParent->GetChildren();

	// if there are no children, don't get any
	if (plistChildren->IsEmpty()) {
		return NULL;
	}

	// if index < 0 or >= number of children, get the last node in the list
	if (nIndex < 0 || nIndex >= plistChildren->GetCount()) {
		pNode = plistChildren->GetTail();
	}
	// otherwise, remove the node at the given index
	else {
		pos = plistChildren->FindIndex(nIndex);
		// this should never be NULL
		ASSERT(pos);
		pNode = plistChildren->GetAt(pos);
	}
	
	return pNode;
}

CNode *CTreeCtl::FindNode(CString strText, BOOL bMatchCase /*= FALSE*/)
{
	// perform a preorder traversal, looking for a node with strText
	return FindNode(m_pTree, strText, bMatchCase);
}

CNode *CTreeCtl::FindNode(DWORD dwData)
{
	// perform a preorder traversal, looking for a node with dwData
	return FindNode(m_pTree, dwData);
}

CNode *CTreeCtl::FindNode(CNode *pNode, CString strText, BOOL bMatchCase /*= FALSE*/)
{
	ASSERT(0);
	// TODO(briancr): preorder traversal of node, looking for strText
	return NULL;

	DBG_UNREFERENCED_PARAMETER(pNode);
	DBG_UNREFERENCED_PARAMETER(strText);
	DBG_UNREFERENCED_PARAMETER(bMatchCase);
}

CNode* CTreeCtl::FindNode(CNode* pNode, DWORD dwData)
{
	// is this the node?
	if (pNode->GetData() == dwData) {
		return pNode;
	}

	// search children

	// get the list of children
	CNode::CNodeList* plistChildren = pNode->GetChildren();

	// call FindNode for each child
	for (POSITION pos = plistChildren->GetHeadPosition(); pos != NULL; ) {
		CNode* pChild = plistChildren->GetNext(pos);
		CNode* pRetNode = FindNode(pChild, dwData);
		if (pRetNode != NULL) {
			return pRetNode;
		}
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl tree operations

void CTreeCtl::Expand(CNode *pNode, BOOL bAllDescendants /*= FALSE*/)
{
	// mark this node as expanded
	pNode->SetFlags(TF_EXPANDED);

	// do we need to expand all descendants?
	if (bAllDescendants) {
		// expand all descendants
		ForEach(pNode, &CTreeCtl::ExpandOne);
	}
}

void CTreeCtl::Collapse(CNode *pNode)
{
	// mark this node as not expanded
	pNode->ClearFlags(TF_EXPANDED);
}

void CTreeCtl::ExpandAll()
{
	// mark all descendants of m_pTree as expanded
	ForEach(m_pTree, &CTreeCtl::ExpandOne);
}


/////////////////////////////////////////////////////////////////////////////
// CTreeCtl Window operations (internal)


void CTreeCtl::ResetSizes(CDC* pDC)
{
	m_sizeM = pDC->GetTextExtent("M", 1);
	// Make sure this is even so our brush lines up when we scroll:
	m_cyNode = (max(m_sizeM.cy, 0 /*cyFolder*/) + 2) & ~1;
		
	m_cxExtent = 0; // not calculated yet...
}

void CTreeCtl::RecalcHorizontalExtent ()
{
	CClientDC dc(this);
	CFont* pOldFont;
	int nIndex;
	CNode *pNode;
	int nExtent;

	m_cxExtent = 0;

	// select the tree font in this DC
	pOldFont = dc.SelectObject(GetTreeFont());
	// find the longest string currently displayed in the list box
	for (nIndex = m_pListBox->GetCount() - 1; nIndex >= 0; nIndex--) {
		pNode = GetLBNode(nIndex);
		// get the extent of this string, plus the glyph, plus the level of indentation
		nExtent = dc.GetTextExtent(pNode->GetText(), pNode->GetText().GetLength()).cx + 
				(2 * (pNode->GetLevel() + 1)) * m_sizeM.cx +
				pNode->GetGlyphExtent(pNode->GetFlags() & TF_EXPANDED ? CNode::GT_Open : CNode::GT_Close).cx +
				c_cyBorderX2 * 5;
		if (nExtent > m_cxExtent) {
			m_cxExtent = nExtent;
		}
	}
	dc.SelectObject(pOldFont);

	// If the listbox fits, set the scroll position to 0 to make sure
	// the scroll bar goes away:
	CRect rcWindow;
	m_pListBox->GetClientRect(rcWindow);
	if (m_cxExtent <= rcWindow.right && m_pListBox->GetScrollPos(SB_HORZ))
		m_pListBox->SendMessage(WM_HSCROLL, SB_TOP);

	m_pListBox->SetHorizontalExtent(m_cxExtent);
}
	
void CTreeCtl::InvalItem(int nItem)
{
	CRect rect;
	m_pListBox->GetItemRect(nItem, rect);
	m_pListBox->InvalidateRect(rect);
}

void CTreeCtl::InvalSelection()
{
	if (m_bIsMultiSelection)
	{
		CRect client;
		m_pListBox->GetClientRect(client);
		for (int nItem = m_pListBox->GetTopIndex(); nItem != -1; nItem += 1)
		{
			CRect rect;
			if (m_pListBox->GetItemRect(nItem, &rect) == LB_ERR || rect.top >= client.bottom)
				break;
			
			if (m_pListBox->GetSel(nItem))
				m_pListBox->InvalidateRect(rect);
		}
	}
	else
	{
		InvalItem(GetCurSel());
	}
}

BOOL CTreeCtl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN || GetParentFrame()->IsIconic())
		return FALSE;
		
	switch (pMsg->wParam)
	{
	case VK_UP:
	case VK_DOWN:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_PRIOR:
	case VK_NEXT:
	case VK_BACK:
	case VK_RETURN:
	case VK_ADD:
	case VK_SUBTRACT:
	case VK_MULTIPLY:
		// Make sure we get the keys we handle in OnKeyDown!
		::TranslateMessage(pMsg);
		::DispatchMessage(pMsg);
		return TRUE;
	}
	
	return FALSE;
}

CTreeCtl::HIT_ZONE CTreeCtl::HitTest(int nItem, int x)
{
	CNode* pNode = GetLBNode(nItem);
	ASSERT(pNode != NULL);
	
	CString strText;
	CRect client;
	GetClientRect(client);
	
	if (m_cxExtent > client.right)
		x += m_pListBox->GetScrollPos(SB_HORZ) * (m_cxExtent - client.right) / 100;
	
	int xLeft = c_cyBorderX2 + pNode->GetLevel() * m_sizeM.cx * 2;
	// if this node has children
	if (!(pNode->GetChildren()->IsEmpty()))
	{
		if (x < xLeft)
			return left;
		if (x < xLeft + 2 * m_sizeM.cx)
			return expand;
	}
	
	xLeft += 2 * m_sizeM.cx;
	if (x < xLeft)
		return left;
	
	xLeft += pNode->GetGlyphExtent(pNode->GetFlags() & TF_EXPANDED ? CNode::GT_Open : CNode::GT_Close).cx + c_cyBorderX2;
	if (x < xLeft)
		return glyph;
	
	CClientDC dc(this);
	dc.SelectObject(GetTreeFont());

	// Extra area between primary glyph and text is in the text zone...
//	xLeft += cxFolder - cxFolder;
//	xLeft += pNode->GetGlyphWidth() - cxFolder;
	
	strText = pNode->GetText();
	xLeft += dc.GetTextExtent(strText, strText.GetLength()).cx + 4 * c_cyBorderX2;
	if (x < xLeft)
		return text;
	
	return right;
}




/////////////////////////////////////////////////////////////////////////////
// CTreeCtl tree operations (internal)

BOOL CTreeCtl::ExpandOne(CNode* pNode)
{
	pNode->SetFlags(TF_EXPANDED);

	return TRUE;
}

BOOL CTreeCtl::SetSelOne(CNode* pNode)
{
	// mark the node as selected
	pNode->SetFlags(TF_SELECTED);

	return TRUE;
}

BOOL CTreeCtl::SetDeselOne(CNode* pNode)
{
	// mark the node as deselected
	pNode->ClearFlags(TF_SELECTED);

	return TRUE;
}

BOOL CTreeCtl::ToggleSelOne(CNode* pNode)
{
	// if it's selected, clear the selected flag
	if (pNode->GetFlags() & TF_SELECTED) {
		pNode->ClearFlags(TF_SELECTED);
	}
	else {
		pNode->SetFlags(TF_SELECTED);
	}
	return TRUE;
}

CNode* CTreeCtl::ForEach(CNode* pNode, BOOL (CTreeCtl::*pfn)(CNode *pNode), CTreeCtl::TraversalOrder order /*=TO_PREORDER*/)
{
	// perform a preorder traversal of the given node,
	// calling pfn for each node until pNode is NULL or pfn returns FALSE
	// return a pointer to the node where pfn returned FALSE

	CNode::CNodeList* plistChildren;
	CNode* pChild;
	CNode* pRetNode;
	POSITION pos;

	// is pNode NULL?
	if (pNode == NULL) {
		return NULL;
	}

	// if this is a preorder traversal, call pfn on the current node before child nodes
	if (order == TO_PREORDER) {
		if (!(this->*pfn)(pNode)) {
			return pNode;
		}
	}

	// get the list of children
	plistChildren = pNode->GetChildren();

	// call ForEach for each child
	for (pos = plistChildren->GetHeadPosition(); pos != NULL; ) {
		pChild = plistChildren->GetNext(pos);
		pRetNode = ForEach(pChild, pfn, order);
		if (pRetNode != NULL) {
			return pRetNode;
		}
	}

	// if this is a postorder traversal, call pfn on the current node after the child nodes
	if (order == TO_POSTORDER) {
		if (!(this->*pfn)(pNode)) {
			return pNode;
		}
	}

	return NULL;
}

BOOL CTreeCtl::Refresh(CNode *pNode)
{
	// is this node dirty?
	if (pNode->GetFlags() & TF_DIRTY_CONTENT)
	{
		// reset this node's dirty bit
		pNode->ClearFlags(TF_DIRTY_CONTENT);

		// is it expanded? then collapse it
		if (pNode->GetFlags() & TF_EXPANDED)
			Collapse(pNode);

		// is this node potentially expandable?
		if (!pNode->GetChildren()->IsEmpty()) {
			Expand(pNode, FALSE);
		}
	}

	if (pNode->GetFlags() & TF_DIRTY_ITEM) {
		// reset this node's dirty bit
		pNode->ClearFlags(TF_DIRTY_ITEM);
	}

	return TRUE;
}

void CTreeCtl::FreeAllTreeData()
{
	// delete all the nodes in the tree
	ForEach(m_pTree, &CTreeCtl::DeleteNode, TO_POSTORDER);

	m_pListBox->ResetContent();
}

void CTreeCtl::RefreshAll(void)
{
	// refresh each node in the tree
	ForEach(m_pTree, &CTreeCtl::Refresh);

	// clear and fill the list box
	m_pListBox->ResetContent();

	FillListBox(m_pTree);
}

void CTreeCtl::FillListBox(CNode* pNode)
{
	CNode::CNodeList* plistChildren;
	int nIndex;
	POSITION pos;

	if (!pNode) {
		return;
	}

	// is this node hidden?
	if (!(pNode->GetFlags() & TF_HIDDEN)) {
		// add this node's string to the list box
		nIndex = m_pListBox->AddString((LPSTR)pNode);
		// set its selection
		m_pListBox->SetSel(nIndex, pNode->GetFlags() & TF_SELECTED? TRUE: FALSE);
	}

	// is this node expanded
	if (pNode->GetFlags() & TF_EXPANDED) {
		// get the list of children
		plistChildren = pNode->GetChildren();

		ASSERT(!plistChildren->IsEmpty());

		// fill the list box for each child
		for (pos = plistChildren->GetHeadPosition(); pos != NULL; ) {
			FillListBox(plistChildren->GetNext(pos));
		}
	}
}

CFont* CTreeCtl::GetTreeFont(void)
{
	static CFont font;
	static LOGFONT lf;
	
	if (font.m_hObject == NULL) {
		lf.lfHeight = 14;
		lf.lfWidth = 0;
		lf.lfEscapement = 0;
		lf.lfOrientation = 0;
		lf.lfWeight = FW_NORMAL;
		lf.lfItalic = FALSE;
		lf.lfUnderline = FALSE;
		lf.lfStrikeOut = FALSE;
		lf.lfCharSet = ANSI_CHARSET;
		lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FW_DONTCARE;
		lstrcpy(lf.lfFaceName, "Arial");

		font.CreateFontIndirect(&lf);
	}

	return &font;
}

void  CTreeCtl::HoldUpdates ()
{
	if (m_EnableUpdates == 0) m_pListBox->SetRedraw (FALSE);
	m_EnableUpdates++;
}

void  CTreeCtl::EnableUpdates ()
{
	m_EnableUpdates--;
	if (m_EnableUpdates == 0)
	{
		m_pListBox->SetRedraw (TRUE);
		m_pListBox->Invalidate();
	}

	ASSERT (m_EnableUpdates >= 0);
}

void CTreeCtl::BeginDragDrop()
{
	TRACE("Must override CTreeCtl::BeginDragDrop for drag/drop functionality!\n");
}

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl Node operations (internal)

int CTreeCtl::CompareData(const CNode* pNode1, const CNode* pNode2)
{
	if (pNode1 == pNode2)
		return 0;
	
	if (pNode1->GetData() < pNode2->GetData()) {
		return -1;
	}
	else {
		if (pNode1->GetData() > pNode2->GetData()) {
			return 1;
		}
		else {
			return 0;
		}
	}
}

int CTreeCtl::CompareNodes(const CNode* pNode1, const CNode* pNode2)
{
	if (pNode1 == pNode2) {
		return 0;
	}
	else {
		return 1;
	}
}

void CTreeCtl::DirtyNode(CNode *pNode, WORD tf)
{
	ASSERT(pNode != NULL);
	pNode->SetFlags(tf);

	Invalidate();
}

CNode* CTreeCtl::GetLBNode(int nIndex)
{
	// get the currently selected node if the given index is -1
	if (nIndex == -1 && (nIndex = GetCurSel()) == LB_ERR)
		return NULL;
	
	// we store a pointer to the node in the listbox
	CNode* pNode = (CNode*)m_pListBox->GetItemData(nIndex);
	if (pNode == (CNode*)LB_ERR)
		return NULL;
	
	return pNode;
}

BOOL CTreeCtl::DeleteNode(CNode* pNode)
{
	delete pNode;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl message handlers

int CTreeCtl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	CreateListBox();

	CClientDC dc(this);
	ResetSizes(&dc);
	
	m_pListBox->m_pTree = this;
	if (!m_pListBox->Create(WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER |
		LBS_NOTIFY | LBS_OWNERDRAWFIXED | LBS_NOINTEGRALHEIGHT |
		LBS_WANTKEYBOARDINPUT | ( (m_bIsMultiSelection) ? LBS_EXTENDEDSEL : 0) |
		(m_bStickySelection ? LBS_MULTIPLESEL : 0),
		CRect(0, 0, 0, 0), this, IDCW_TREELISTBOX))
	{
		return -1;
	}
	
	SetFont(GetTreeFont());
	
	return 0;

	UNREFERENCED_PARAMETER(lpCreateStruct);
}

void CTreeCtl::OnDestroy()
{
	FreeAllTreeData();

	delete m_pListBox;
}

void CTreeCtl::OnPaint()
{
	// we want to search through the tree control
	// for any dirty nodes, if we find one of these
	// we want to update its contents
	RefreshAll();		// refresh from our roots down

	RecalcHorizontalExtent();

	CWnd::OnPaint();	// pass on to our base instance
}

LPARAM CTreeCtl::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	CFont* pFont = CFont::FromHandle((HFONT)wParam);

	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(pFont);
	ResetSizes(&dc);
	dc.SelectObject(pOldFont);

	m_pListBox->SetFont(pFont);
	m_pListBox->SetItemHeight(0, m_cyNode);
	
	return 0;

	UNREFERENCED_PARAMETER(lParam);
}

LPARAM CTreeCtl::OnGetFont(WPARAM wParam, LPARAM lParam)
{
	return m_pListBox->SendMessage(WM_GETFONT, wParam, lParam);
}

void CTreeCtl::OnSetFocus(CWnd* pOldWnd)
{
	m_pListBox->SetFocus();

	UNREFERENCED_PARAMETER(pOldWnd);
}

void CTreeCtl::OnSize(UINT nType, int cx, int cy)
{
	if (GetParent()->IsIconic())
		return;

	// Put the client area of the listbox in the client area of the tree.
	CRect rectNew, rectCurrent;
	GetClientRect(rectNew);
	::AdjustWindowRect(rectNew, m_pListBox->GetStyle(), FALSE);

	m_pListBox->GetWindowRect(rectCurrent);
	ScreenToClient(rectCurrent);

	if (rectNew == rectCurrent)
		return;
		
	m_pListBox->MoveWindow(rectNew.left, rectNew.top,
		rectNew.Width(), rectNew.Height());
		
	int iMax = GetCurSel();
	if (iMax >= 0)
	{
		int top, bottom;
			
		m_pListBox->GetClientRect(rectCurrent);
		top = m_pListBox->GetTopIndex();
		bottom = top + rectCurrent.bottom / m_cyNode;
		if (iMax < top || iMax > bottom)
			m_pListBox->SetTopIndex(iMax - (bottom - top) / 2);
	}
	RecalcHorizontalExtent();

	UNREFERENCED_PARAMETER(nType);
	UNREFERENCED_PARAMETER(cx);
	UNREFERENCED_PARAMETER(cy);
}

int CTreeCtl::OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex)
{
	// On 6/15/94, I deleted a bunch of code in this function which appears
	// to be obsolete.  If the assertion below ever fires, please send an
	// exact repro case to me (ALANE) and I'll put it back.
	//
	ASSERT((GetCurSel() < 0) || (nChar <= ' '));
	return -2;

	UNREFERENCED_PARAMETER(pListBox);
	UNREFERENCED_PARAMETER(nIndex);
}

// OnKeyDown and OnChar
//
// These two functions are called as the listbox receives keyboard input,
// and give you a chance to add specific keyboard processing for your
// tree.
//
// Note that you will receive both an OnKeyDown AND an OnChar for character
// input.
//
// Return TRUE if you handle this message, FALSE if you want default listbox
// handling to occur.
//
BOOL CTreeCtl::OnKeyDown(UINT nChar)
{
	int i = GetCurSel();
	if (i < 0)
		return TRUE;

	int j = 1;
	CNode* pNode = GetLBNode(i);
	CNode* pNodeT;

	switch (nChar)
	{
	case VK_LEFT:
		while ((pNodeT = GetLBNode(--i)) != NULL)
		{
			if (pNodeT == pNode->GetParent())
			{
				KeySetSel(i);
				return TRUE;
			}
		}
		goto LSameSelection;
		
	case VK_RIGHT:
		if ((pNodeT = GetLBNode(i + 1)) == NULL || pNodeT->GetParent() != pNode)
		{
			goto LSameSelection;
		}
		KeySetSel(i + 1);
		return TRUE;
		
	case VK_UP:
		j = -1;
		// FALL THROUGH
		
	case VK_DOWN:
		if (GetKeyState(VK_CONTROL) >= 0)
		{
			ClearSearchBuffer();
			return FALSE;
		}
		
		while ((i += j) >= 0 && (pNodeT = GetLBNode(i)) != NULL)
		{
			if (pNodeT->GetParent() == pNode->GetParent())
			{
				KeySetSel(i);
				return TRUE;
			}
		}
LSameSelection:
		MessageBeep(0);
		return TRUE;
		
	case VK_BACK:
		{
			if (i <= 0)
				return TRUE;
			
			// go to the parent
			/*
			int nStartLevel = pNode->m_nLevels;
			do
			{
				pNodeT = GetNode(--i);
			}
			while (i > 0 && pNodeT->m_nLevels >= nStartLevel);
			*/
			
			KeySetSel(i);
			return TRUE;
		}
		
	case VK_RETURN:
		OnPrimary();
		return TRUE;

	case VK_ADD:
		OnExpand();
		return TRUE;
		
	case VK_SUBTRACT:
		OnCollapse();
		return TRUE;
		
	case VK_MULTIPLY:
		if (GetKeyState(VK_CONTROL) < 0)
			OnExpandAll();
		else
			OnExpandBranch();
		return TRUE;
	}

	return FALSE;
}

BOOL CTreeCtl::OnChar(UINT nChar)
{
	switch (nChar)
	{
	case '+':
		OnExpand();
		return TRUE;
		
	case '-':
		OnCollapse();
		return TRUE;
		
	case '*':
		OnExpandBranch();
		return TRUE;
	}
	
	// if enough time has elapsed, or the user hits a control key (e.g.
	// backspace) zero the string.
	time_t timeNow = time(NULL);
	
	// need a place to store the lead byte of a DBC
	static TCHAR cLead;

	if (iscntrl(nChar) || (timeNow - m_timeLastKey > LIST_SEARCH_DELAY))
		ClearSearchBuffer();

	// process the key
	if ((m_pListBox->GetCount() == 0) || iscntrl(nChar))
		return FALSE;

	if (cLead)
	{
		TCHAR szTmp[3];
		szTmp[0] = cLead;
		szTmp[1] = (TCHAR) nChar;
		szTmp[2] = _T('\0');
		
		cLead = 0;
		m_strSearch += CString( szTmp );
	}
	else
	{
		if (IsDBCSLeadByte( (char) nChar ))
		{
			cLead = (TCHAR) nChar;
			return TRUE;
		}

		m_strSearch += CString((char)nChar);
	}
	
	m_timeLastKey = timeNow;

	// look for a match
	CString str;
	int index, indexStart;
	index = indexStart = max(GetCurSel(), 0);

	do
	{
		str = GetLBNode(index)->GetText();
		if (m_strSearch.CompareNoCase(str.Left(m_strSearch.GetLength())) == 0)
		{
			// found a match
			KeySetSel(index, FALSE);
			return TRUE;
		}

		if (++index >= m_pListBox->GetCount())
			index = 0;
	} while (index != indexStart);

	// no match found, but we did handle the key
	return TRUE;
}

void CTreeCtl::ClearSearchBuffer()
{
	m_strSearch.Empty();
}



////////////////////////////////////////////////////////////////////////////
// Outline "command" handlers...

void CTreeCtl::OnPrimary()
{
	if (m_pListBox->GetCaretIndex() != -1)
		OnOpen(m_pListBox->GetCaretIndex());
	ClearSearchBuffer();
}

void CTreeCtl::OnExpand()
{
	// get the node that's currently selected in the list box
	CNode* pNode = GetLBNode();
	// if there's a node currently selected, it has children, and it's not expanded, expand it
	if (pNode != NULL && (!(pNode->GetChildren()->IsEmpty())) && !(pNode->GetFlags() & TF_EXPANDED))
		Expand(pNode);
	ClearSearchBuffer();
}

void CTreeCtl::OnCollapse()
{
	// get the node that's currently selected in the list box
	CNode* pNode = GetLBNode();
	int nItem = m_pListBox->GetCurSel();
	
	// if the node doesn't have children
	if (!(pNode->GetChildren()->IsEmpty()))
	{
		if (nItem <= 0)
			return;

		// collapse the parent node
		pNode = pNode->GetParent();
	}
	
	// if the node is valid and expanded, collapse it
	if (pNode != NULL && (pNode->GetFlags() & TF_EXPANDED)) {
		Collapse(pNode);
	}
		
	ClearSearchBuffer();
}

void CTreeCtl::OnExpandBranch()
{
	// get the currently selected node
	CNode *pNode = GetLBNode();

	// if the node is valid, expand it and all its children
	if (pNode) {
		Expand(pNode, TRUE);
	}
	ClearSearchBuffer();
}

void CTreeCtl::OnExpandAll()
{
	// UNDONE: these cases could be consolidated
//	SetCurSel(0);	// work-around for #2909
	ExpandAll();
	ClearSearchBuffer();
}

void CTreeCtl::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	lpMeasureItemStruct->itemHeight = m_cyNode;

	UNREFERENCED_PARAMETER(nIDCtl);
}

void CTreeCtl::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	UINT idGlyph;
	CSize sizeGlyph;
	CNode::GlyphType glyphNode;
	CString strText;
	
	// [patbr] tree control faults with empty list box
	if (lpDrawItemStruct->itemData == NULL || lpDrawItemStruct->itemData == (UINT)-1)
	{
		// list box is empty, so indicate that list box has focus.
		// DrawFocusRect(lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem));
		return;								 
	}

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CNode* pNode = (CNode*)lpDrawItemStruct->itemData;
	CFont* pOldFont = pDC->SelectObject(GetTreeFont());

	strText = pNode->GetText();
	int cchText = strText.GetLength();
	
	CSize sizeText = pDC->GetTextExtent(strText, cchText);

	// our drawing starting point for this node from left and top
	CPoint	pt(c_cyBorderX2 + pNode->GetLevel() * m_sizeM.cx * 2, lpDrawItemStruct->rcItem.top);

	// our focus/highlight rectangle for the text
	CRect rect;
	rect.top = lpDrawItemStruct->rcItem.top;
	rect.left = pt.x + 2 * m_sizeM.cx + pNode->GetGlyphExtent(pNode->GetFlags() & TF_EXPANDED ? CNode::GT_Open : CNode::GT_Close).cx + c_cyBorderX2;
	rect.bottom = lpDrawItemStruct->rcItem.bottom;
	rect.right = rect.left + sizeText.cx + 4 * c_cyBorderX2;
	
	if (lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT))
	{
		int x = pt.x + m_sizeM.cx;	// initial drawing starting position
		x &= ~1;	// Make even;
		int y = pt.y + m_cyNode / 2; 
		int yp = y | 1; 

		BOOL bDrawSelected = (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 || (pNode->GetFlags() & TF_DROPTARGET) != 0;
		BOOL bHasFocus = ::GetFocus() == lpDrawItemStruct->hwndItem || (pNode->GetFlags() & TF_DROPTARGET) != 0;
		COLORREF rgbText, rgbBackground;

		// Draw the dotted lines...
		
		CBrush* pOldBrush = pDC->SelectObject(CDC::GetHalftoneBrush());

		// if this node has a parent and children,
		if (pNode->GetParent() != NULL || (!pNode->GetChildren()->IsEmpty()) != 0)
		{
			// Draw the horizontal line over the (possible) folder
			// Draw on an odd lines so our hatch brush looks nice.
			pDC->PatBlt (x, yp, m_sizeM.cx, 1, NOTPATCOPY);
		}
		
		if (pNode->GetParent() != NULL)
		{
			// Draw the top part of the vertical line
			pDC->PatBlt (x, rect.top, 1, m_cyNode / 2, NOTPATCOPY); 
			
			// If not the end of a node, draw the bottom part
			if ((pNode->GetFlags() & TF_LASTLEVELENTRY) == 0) {
				pDC->PatBlt (x, y + c_cyBorder, 1, m_cyNode / 2, NOTPATCOPY); 
			}

			// Draw the verticals on the left connecting other nodes
			int nLevel = pNode->GetLevel();
			for (CNode* pNodeT = pNode->GetParent(); pNodeT != NULL; pNodeT = pNodeT->GetParent())
			{
				nLevel -= 1;

				if (!(pNodeT->GetFlags() & TF_LASTLEVELENTRY) && (pNodeT->GetParent() != NULL))
				{
					int	x = (nLevel + 1) * m_sizeM.cx * 2 + c_cyBorderX2 - m_sizeM.cx;
					x &= ~1;	// Make even;
					pDC->PatBlt(x, rect.top, 1, m_cyNode, NOTPATCOPY); 
				}
			}
		}
		
		pDC->SelectObject(pOldBrush);
		
		
		// Draw the boxed plus/minus sign if appropriate...

		// if this node has childeren,
		if (!(pNode->GetChildren()->IsEmpty()))
		{
			// calculate the id of the glyph
			idGlyph = pNode->GetFlags() & TF_EXPANDED ? IDB_GlyphExpanded : IDB_GlyphCollapsed;

			// get the size of the glyph
			sizeGlyph = m_Glyphs.GetBitmapExtent(idGlyph);

			// Draw the box	[+] or [-]
			m_Glyphs.Draw(idGlyph, pDC, CPoint(x - sizeGlyph.cx / 2, yp - sizeGlyph.cy / 2));
		}

		// Draw the glyph...
		
		glyphNode = pNode->GetFlags() & TF_EXPANDED ? CNode::GT_Open : CNode::GT_Close;
		pNode->DrawGlyph(glyphNode, pDC, CPoint(x + m_sizeM.cx + c_cyBorder, y - (pNode->GetGlyphExtent(glyphNode).cy / 2)));
		
		// Draw the text...
		
		if ((bHasFocus || m_bKeepSelectionRect) && bDrawSelected)
		{
			rgbText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			rgbBackground = pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}
		
		pDC->ExtTextOut(rect.right - sizeText.cx - c_cyBorderX2 * 2, y - (m_sizeM.cy / 2), ETO_OPAQUE, &rect, strText, cchText, NULL);
		
		// draw the selection...
		if (bDrawSelected)
		{
			if (bHasFocus || m_bKeepSelectionRect)
			{
				pDC->SetTextColor(rgbText);
				pDC->SetBkColor(rgbBackground);
			}
			else
			{
				// Highlight is a frame when we don't have the focus...
				CBrush brush;
				if (brush.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)))
					pDC->FrameRect(&rect, &brush);
			}
		}
	}
	
	if (lpDrawItemStruct->itemAction == ODA_FOCUS)
		pDC->DrawFocusRect(&rect);
	
	pDC->SelectObject(pOldFont);

	UNREFERENCED_PARAMETER(nIDCtl);
}

void CTreeCtl::OnRightButtonUp(UINT, CPoint)
{
	// do nothing .. derived class implementation is more useful
}

void CTreeCtl::OnRightButtonDown(UINT, CPoint)
{
	// do nothing .. derived class implementation is more useful
}

void CTreeCtl::OnLbDblClk()
{	
/*
	// CHICAGO: Move property activation to rbutton.
	if (m_bShowProperties && (GetKeyState(VK_MENU) & ~1) != 0)
	{
		ActivatePropertyBrowser();
		return;
	}

	OnPrimary();
*/
}

void CTreeCtl::OnLbSelChange()
{
	// a line in the list box has been clicked
	OnSelect(GetCurSel());
}

void CTreeCtl::OnOpen(int nIndex)
{
	CNode* pNode = GetLBNode(nIndex);
	if (pNode != NULL) {
		if (pNode->GetFlags() & TF_EXPANDED) {
			Collapse(pNode);
		}
		else {
			if (!(pNode->GetChildren()->IsEmpty())) {
				Expand(pNode);
			}
		}
		Invalidate();
	}
}

void CTreeCtl::OnSelect(int nIndex)
{
	CNode* pNode;

	// mark the node's selection flag appropriately

	// get the node
	pNode = GetLBNode(nIndex);

	// REVIEW(briancr): this doesn't unselect the previous
	// selection in a nonsticky selection list box

	// is the node selected
	if (GetSel(nIndex)) {
		pNode->SetFlags(TF_SELECTED);
	}
	else {
		pNode->ClearFlags(TF_SELECTED);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTreeListBox -- the actual list box inside a tree control

int CTreeListBox::iSlobPixels = 5;
CPoint CTreeListBox::mouseDownPt;

CTreeListBox::CTreeListBox()
{
	m_pTree = NULL;
    m_bGotMouseDown = FALSE;
    m_bDeferedDeselection = FALSE;
	m_bStdMouse = TRUE;
}

int CTreeListBox::ItemFromPoint(const CPoint& point)
{
    CRect client;
    GetClientRect(&client);

    if (!client.PtInRect(point))
        return LB_ERR;

    CRect itemRect;
    GetItemRect(0, &itemRect);

	int nItem = (GetTopIndex() + (point.y / itemRect.Height()));
	return nItem < GetCount() ? nItem : LB_ERR;
}

void CTreeListBox::OnLButtonDown(UINT nFlags, CPoint pt)
{
	BOOL bPassOn = TRUE;

	SetFocus();
	SetCapture();

	m_bStdMouse = TRUE;
	
	int nItem = ItemFromPoint(pt);
	if (nItem != LB_ERR)
	{
		int nCurSel = GetCurSel();
		int nCount = GetCount();

		CTreeCtl::HIT_ZONE hitZone = m_pTree->HitTest(nItem, pt.x);
		
		if (hitZone == CTreeCtl::expand)
		{
			// Inside the expand/collapse box...
		
			m_pTree->OnOpen(nItem);

			if (nItem < nCurSel)
			{
				if (GetCount() > nCount)
				{
					// did expand, change selection accordingly
					SetCurSel(nCurSel + GetCount() - nCount);
				}
				else if (GetCount() < nCount)
				{
					// did collapse, change selection accordingly
					if (nCurSel > (nItem + (nCount - GetCount())))
					{
						// previous selection not in collapsed area, reset selection
						SetCurSel(nCurSel + GetCount() - nCount);
					}
					else
					{
						// previous selection in collapsed area, set selection to collapsed node
						SetCurSel(nItem);
					}
				}
			}

			// don't change selection unless we just cleared in
			// by collapsing the tree...
			if (GetSelCount() != 0)
				return;
		}
	
		if (m_pTree->m_bEnableDragDrop && 
			(hitZone == CTreeCtl::glyph || hitZone == CTreeCtl::text))
		{
			// Inside glyph or text and D&D is enabled...
		
			m_bStdMouse = FALSE;
		    m_bGotMouseDown = TRUE;
		    mouseDownPt = pt;

		    if ((nFlags & MK_SHIFT) == 0 && GetSel(nItem))
			{
		        // don't deselect yet, wait for either a mouse up or a drag and drop
		        m_bDeferedDeselection = TRUE;
		        m_nDeferedItem = nItem;
				return;
			}
			else
			{
				if ((nFlags & MK_SHIFT) != 0)
				{
					// Shift held down - so select a range, but do not pass on.
					int nCurrentSel;

					SetSel(-1, FALSE);
					nCurrentSel = GetCaretIndex();
					if (nCurrentSel > nItem)
						SelItemRange(TRUE, nItem, nCurrentSel);
					else
						SelItemRange(TRUE, nCurrentSel, nItem);
 				}
				else
				{
 					// Only clear selection if CONTROL key not pressed
					if ((nFlags & MK_CONTROL) == 0)
						SetSel(-1, FALSE);
			    	SetSel(nItem, TRUE);
				}
				bPassOn = FALSE;
			}
		}
	}

	if (bPassOn)
		CListBox::OnLButtonDown(nFlags, pt);	// pass on

	if (m_pTree->m_bEnableDragDrop)
	{
#ifdef _WIN32
	    GetParent()->SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());
#else
	    GetParent()->SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	        MAKELPARAM(GetSafeHwnd(), LBN_SELCHANGE));
#endif
	}
}

void CTreeListBox::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int nItem = ItemFromPoint(point);
	if (nItem != LB_ERR)
	{
		switch (m_pTree->HitTest(nItem, point.x))
		{
		case CTreeCtl::expand:
			// Treat as single click...
			m_pTree->OnOpen(nItem);
			return;
			
		case CTreeCtl::left:
		case CTreeCtl::right:
			// Ignore the double click...
			return;
		
		case CTreeCtl::glyph:
		case CTreeCtl::text:
			break;
		}
	}

	CListBox::OnLButtonDblClk(nFlags, point);
}

void CTreeListBox::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bStdMouse || !m_pTree->m_bEnableDragDrop)
	{
		CListBox::OnMouseMove(nFlags, point);
		return;
	}

    // Nasty hack here because Windows sends a continuous stream of
    // WM_MOUSEMOVE messages when a button is held down...
    static CPoint NEAR lastPoint;
    if ((point == lastPoint) || (GetCount() == 0))
        return;

    lastPoint = point;

    CPoint offsetPoint (abs(mouseDownPt.x - point.x),
                        abs(mouseDownPt.y - point.y));

    if (m_bGotMouseDown && offsetPoint.x + offsetPoint.y > iSlobPixels && GetSelCount() > 0)
    {
		// Begin a drag...
		m_pTree->BeginDragDrop();

        m_bGotMouseDown = FALSE;
        m_bDeferedDeselection = FALSE;
    }
}

void CTreeListBox::OnLButtonUp(UINT nFlags, CPoint pt)
{
	if (!m_bStdMouse && m_pTree->m_bEnableDragDrop)
	{
		m_bGotMouseDown = FALSE;

		if (m_bDeferedDeselection)
		{
		    if (nFlags & MK_CONTROL)
		    {
		        SetSel(m_nDeferedItem, FALSE);
		    }
		    else
		    {
		        SetSel(-1, FALSE);
		        SetSel(m_nDeferedItem, TRUE);
		    }
		    m_bDeferedDeselection = FALSE;
#ifdef _WIN32
	        GetParent()->SendMessage(WM_COMMAND, 
				MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());
#else
	        GetParent()->SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	            MAKELPARAM(GetSafeHwnd(), LBN_SELCHANGE));
#endif
		}
    }

    // need to call Windows so notifications get sent
    CListBox::OnLButtonUp(nFlags, pt);
	ReleaseCapture();
}

void CTreeListBox::OnRButtonUp(UINT nFlags, CPoint pt)
{
	CListBox::OnRButtonUp(nFlags, pt);	// pass on

	CWnd *	pwnd = GetParent();

	ASSERT(pwnd->IsKindOf(RUNTIME_CLASS(CTreeCtl)));

	// inform the tree control of this
	((CTreeCtl *)pwnd)->OnRightButtonUp(nFlags, pt);
}

void CTreeListBox::OnRButtonDown(UINT nFlags, CPoint pt)
{
/*
	SetFocus();

	CSlobWnd* pWnd = GetActiveSlobWnd();
	if (!(m_pTree->m_bShowContextPopup && pWnd->IsChild(this)))
		return;
	
    int nItem = ItemFromPoint(pt);
	if (nItem != LB_ERR)
	{
		if (!GetSel(nItem))
		{
	        if (SetSel(-1, FALSE) == LB_ERR || SetSel(nItem, TRUE) == LB_ERR)
				SetCurSel(nItem);
		}
		else
		{
			SetCaretIndex(nItem);
		}

	    GetParent()->SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());

		UpdateWindow();	// So we don't blow save bits.
	}

	ClientToScreen(&pt);
	pWnd->ShowContextPopupMenu(pt);
*/

	DBG_UNREFERENCED_PARAMETER(nFlags);
	DBG_UNREFERENCED_PARAMETER(pt);
}

void CTreeListBox::OnKeyDown(UINT nChar, UINT nRepCount, UINT nFlags)
{
	if (m_pTree->OnKeyDown(nChar))
		return;

	CListBox::OnKeyDown(nChar, nRepCount, nFlags);
}

void CTreeListBox::OnChar(UINT nChar, UINT nRepCount, UINT nFlags)
{
	if (m_pTree->OnChar(nChar))
		return;

	CListBox::OnChar(nChar, nRepCount, nFlags);
}

/////////////////////////////////////////////////////////////////////////////
// CNode

CImageWell CNode::m_Glyphs;

CNode::CNode(CString strText /*= ""*/, DWORD dwData /*= 0*/, CNode *pParent /*= NULL*/, UINT idGlyphClose /*= IDB_GlyphFolderClose*/, UINT idGlyphOpen /*= IDB_GlyphFolderOpen*/)
: m_strText(strText),
  m_dwData(dwData),
  m_pParent(pParent),
  m_nFlags(0),
  m_idGlyphClose(idGlyphClose),
  m_idGlyphOpen(idGlyphOpen)
{
	ASSERT(m_listChildren.IsEmpty());

	// add the glyphs
	m_Glyphs.Add(m_idGlyphClose);
	m_Glyphs.Add(m_idGlyphOpen);

  // this is to ensure that both test glyps are available

	m_Glyphs.Add(IDB_GlyphTest);
	m_Glyphs.Add(IDB_GlyphBadTest);
}

CNode::~CNode()
{
	// REVIEW(briancr): remove all items from the children list
	// I think FreeAllTreeData() does this
	m_Glyphs.Remove(m_idGlyphClose);
	m_Glyphs.Remove(m_idGlyphOpen);
	m_Glyphs.Remove(IDB_GlyphTest);
	m_Glyphs.Remove(IDB_GlyphBadTest);
}

/////////////////////////////////////////////////////////////////////////////
// CImageWell

#define DSx		0x00660046L
#define DSna	0x00220326L

CImageWell::~CImageWell()
{
	// delete all entries in the map
}

BOOL CImageWell::Add(UINT idImage)
{
	ImageType image;
	CBitmap* pbitmap;
	CBitmap* pmask;
	HINSTANCE hInst;
	HINSTANCE hOldInst;

	// if it's already in the map, bump the reference count
	if (m_mapImages.Lookup(idImage, image)) {
		image.m_count++;
		m_mapImages.SetAt(idImage, image);
		return TRUE;
	}
	// otherwise, load the bitmap, calculate the mask, and store it
	else {
		pbitmap = new CBitmap;
		pmask = new CBitmap;

		// set the instance handle to the current instance
		hInst = AfxFindResourceHandle(MAKEINTRESOURCE(idImage), RT_BITMAP); 
		hOldInst = AfxGetResourceHandle();

		AfxSetResourceHandle(hInst);

		// load the bitmap
		if (!pbitmap->LoadBitmap(idImage)) {
			TRACE("CImageWell::Add: could not load image (id=%d)\n", idImage);
			return FALSE;
		}
		
		// reset the instance handle
		AfxSetResourceHandle(hOldInst);
	
		// calculate the mask
		CalculateMask(pbitmap, pmask);

		// insert the bitmap and mask into the map
		image.m_pbitmap = pbitmap;
		image.m_pmask = pmask;
		image.m_count = 1;
		m_mapImages.SetAt(idImage, image);

		return TRUE;
	}
}

BOOL CImageWell::Remove(UINT idImage)
{
	ImageType image;

	// the image should be in the map
	ASSERT(m_mapImages.Lookup(idImage, image));

	if (m_mapImages.Lookup(idImage, image)) {
		// decrement the reference count
		image.m_count--;
		m_mapImages.SetAt(idImage, image);
		// if the reference count < 1 then delete the bitmaps
		if (image.m_count <= 0) {
			m_mapImages.RemoveKey(idImage);
			delete image.m_pbitmap;
			delete image.m_pmask;
		}
		return TRUE;
	}
	else {
		TRACE("CImageWell::Remove: no image found (id=%d)\n", idImage);
		return FALSE;
	}
}

CSize CImageWell::GetBitmapExtent(UINT idImage)
{
	ImageType image;
	BITMAP bm;
	CSize size;

	// the image should be in the map
	ASSERT(m_mapImages.Lookup(idImage, image));

	if (m_mapImages.Lookup(idImage, image)) {
		// get information on this bitmap
		image.m_pbitmap->GetObject(sizeof(bm), &bm);
		// fill in the size
		size.cx = bm.bmWidth;
		size.cy = bm.bmHeight;
	}
	else {
		TRACE("CImageWell::GetBitmapExtent: no image found (id=%d)\n", idImage);
	}
	return size;
}

BOOL CImageWell::Draw(UINT idImage, CDC *pDC, CPoint pt, DWORD rop /*= 0*/)
{
	ImageType image;
	BITMAP bmp;
	CDC dc;
	CDC maskdc;
	COLORREF oldBkColor;
	COLORREF oldTextColor;

	// the image should be in the map
	ASSERT(m_mapImages.Lookup(idImage, image));

	if (m_mapImages.Lookup(idImage, image)) {

		// get the size of the glyph
		image.m_pbitmap->GetObject(sizeof(bmp), &bmp);

		// create DCs for the bitmap and mask
		dc.CreateCompatibleDC(pDC);
		maskdc.CreateCompatibleDC(pDC);

		// set the bitmap and mask in their respective DCs
		dc.SelectObject(image.m_pbitmap);
		maskdc.SelectObject(image.m_pmask);

		// is there a user-supplied raster operation (rop)?
		if (rop == 0) {		
			// set colors	
			oldBkColor = pDC->SetBkColor(RGB(255, 255, 255));
			oldTextColor = pDC->SetTextColor(RGB(0, 0, 0));

			// draw the glyph
			pDC->BitBlt(pt.x, pt.y, bmp.bmWidth, bmp.bmHeight, &dc, 0, 0, DSx);
			pDC->BitBlt(pt.x, pt.y, bmp.bmWidth, bmp.bmHeight, &maskdc, 0, 0, DSna);
			pDC->BitBlt(pt.x, pt.y, bmp.bmWidth, bmp.bmHeight, &dc, 0, 0, DSx);

			// reset colors
			pDC->SetBkColor(oldBkColor);
			pDC->SetTextColor(oldTextColor);

			return TRUE;
		}
		else {
			pDC->BitBlt(pt.x, pt.y, bmp.bmWidth, bmp.bmHeight, &dc, 0, 0, rop);
			return TRUE;
		}
	}
	else {
		TRACE("CImageWell::Draw: no image found (id=%d)\n", idImage);
		return FALSE;
	}
}

BOOL CImageWell::CalculateMask(CBitmap* pbitmap, CBitmap* pmask)
{
	CDC dc;
	CDC maskdc;
	BITMAP bmp;

	// get the size of the bitmap
	pbitmap->GetObject(sizeof(bmp), &bmp);
	
	// create DCs for the bitmap and mask
	dc.CreateCompatibleDC(NULL);
	maskdc.CreateCompatibleDC(NULL);

	// create the mask's bitmap
	if (!pmask->CreateBitmap(bmp.bmWidth, bmp.bmHeight, 1, 1, NULL)) {
		TRACE("CImageWell::CalculateMask: unable to create mask\n");
		return FALSE;
	}

	// select the bitmaps in the DCs
	VERIFY(dc.SelectObject(pbitmap) != NULL);
	VERIFY(maskdc.SelectObject(pmask) != NULL);

	dc.SetBkColor(dc.GetPixel(0, 0));
	maskdc.BitBlt(0, 0, bmp.bmWidth, bmp.bmHeight, &dc, 0, 0, NOTSRCCOPY);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\treectl.h ===
/////////////////////////////////////////////////////////////////////////////
// treectl.h
//
// email	date		change
// briancr	11/01/94	created
//
// copyright 1994 Microsoft

// Interfaces of the CTreeCtl, CTreeListBox, CNode, and CImageWell classes
// Much of this code was copied from the IDE

#ifndef __TREECTL_H__
#define __TREECTL_H__

#define LIST_SEARCH_DELAY (2)

// forward declarations
class CNode;
class CImageWell;

/////////////////////////////////////////////////////////////////////////////
// CTreeListBox

class CTreeListBox : public CListBox
{
	DECLARE_DYNCREATE(CTreeListBox)

	CTreeListBox();

private:
	int ItemFromPoint(const CPoint& point);

	class CTreeCtl* m_pTree;
	BOOL m_bGotMouseDown : 1;
	BOOL m_bDeferedDeselection : 1;
	BOOL m_bStdMouse : 1;
	int m_nDeferedItem;
	int m_nLastItem;

	static int iSlobPixels;
	static CPoint mouseDownPt;

	friend class CTreeCtl;

	// Generated message map functions
protected:
	//{{AFX_MSG(CTreeListBox)
	afx_msg void OnLButtonDown(UINT, CPoint);
	afx_msg void OnLButtonUp(UINT, CPoint);
	afx_msg void OnLButtonDblClk(UINT, CPoint);
	afx_msg void OnRButtonUp(UINT, CPoint);
	afx_msg void OnRButtonDown(UINT, CPoint);
	afx_msg void OnMouseMove(UINT, CPoint);
	afx_msg void OnChar(UINT nChar, UINT nRepCount, UINT nFlags);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl window

class CTreeCtl : public CWnd
{
	DECLARE_DYNCREATE(CTreeCtl)
	DECLARE_MESSAGE_MAP()

// ctor/dtor
public:
	CTreeCtl(BOOL bIsMultiSelection = FALSE, BOOL bStickySelection = FALSE, BOOL bKeepSelectionRect = FALSE);
	virtual ~CTreeCtl();
	
// list box operations
public:
	BOOL PreCreateWindow(CREATESTRUCT& cs);

	// get/set the current selection
	int GetCurSel()									{ return m_pListBox->GetCurSel(); }
	void SetCurSel(int nIndex)						{ m_pListBox->SetCurSel(nIndex); }
	void KeySetSel(int nIndex, BOOL bClearSearchBuffer = TRUE);

	// get/set the current selection if multi-select is on
	int GetSelCount()								{ return m_pListBox->GetSelCount(); }
	int GetSelItems(int nMaxItems, LPINT rgItems)	{ return m_pListBox->GetSelItems(nMaxItems, rgItems); }
	int GetSel(int nIndex)							{ return m_pListBox->GetSel(nIndex); }
	int SetSel(int nIndex, BOOL bSelect = TRUE);
	void SelectAll(void);
	void DeselectAll(void);
	void ToggleAll(void);

// Node operations
public:
	CNode* InsertNode(CNode *pParent, CString strText, DWORD dwData = 0, int nIndex = -1, UINT idGlyphClose = IDB_GlyphFolderClose, UINT idGlyphOpen = IDB_GlyphFolderOpen, BOOL bSelected = TRUE);
	CNode* InsertNode(CNode *pParent, CNode *pNode, int nIndex = -1);

	BOOL RemoveNode(CNode *pParent, int nIndex = -1);

	CNode *GetNode(CNode *pParent, int nIndex = -1);

	CNode *FindNode(CString strText, BOOL bMatchCase = FALSE);
	CNode *FindNode(DWORD dwData);

// Tree operations
public:
	void Expand(CNode *pNode, BOOL bAllDescendants = FALSE);
	void Collapse(CNode *pNode);
	void ExpandAll();

// data types (internal)
protected:
	enum HIT_ZONE { left, expand, glyph, text, right };

// Window operations (internal)
protected:
	void RecalcHorizontalExtent ();
	void ClearSearchBuffer();
	int ItemFromPoint(const CPoint& point)		{ return m_pListBox->ItemFromPoint(point); }
	int GetItemRect(int nItem, LPRECT lpRect)	{ return m_pListBox->GetItemRect(nItem, lpRect); }
	virtual void CreateListBox()				{ m_pListBox = new CTreeListBox; }
	virtual CListBox* GetListBox()				{ return m_pListBox; }
	HIT_ZONE HitTest(int nItem, int x);
	virtual void OnOpen(int nIndex);				// called on Enter key or double-click
	virtual void OnSelect(int nIndex);				// called on selection change

	virtual BOOL OnKeyDown(UINT nChar);				// called on any Keydown msg
	virtual BOOL OnChar(UINT nChar);					// called on any Char msg
	virtual void OnRightButtonUp(UINT, CPoint);		// called on right mouse button up
	virtual void OnRightButtonDown(UINT, CPoint);	// called on right mouse button down
	virtual BOOL PreTranslateMessage(MSG* pMsg);
    void ResetSizes(CDC* pDC);
    void InvalSelection();
    void InvalItem(int nItem);
    
	int  GetMaxItemExent () { return m_cxExtent; };

// Tree operations (internal)
protected:
	enum TraversalOrder { TO_PREORDER, TO_POSTORDER };

	CNode* ForEach(CNode* pNode, BOOL (CTreeCtl::*pfn)(CNode *pNode), TraversalOrder order = TO_PREORDER);

	BOOL ExpandOne(CNode* pNode);
	BOOL SetSelOne(CNode* pNode);
	BOOL SetDeselOne(CNode* pNode);
	BOOL ToggleSelOne(CNode* pNode);

	CNode* FindNode(CNode *pNode, CString strText, BOOL bMatchCase = FALSE);
	CNode* FindNode(CNode *pNode, DWORD dwData);

	CFont* GetTreeFont(void);

	BOOL Refresh(CNode *pNode);
	void RefreshAll(void);
	void FillListBox(CNode *pNode);

	void DirtyNode(CNode *pNode, WORD);

	void FreeAllTreeData();

	// specific key handlers
	void OnPrimary();
	void OnExpand();
	void OnExpandBranch();
	void OnExpandAll();
	void OnCollapse();

	// For save/loading expanded state:

	void HoldUpdates ();
	void EnableUpdates ();

	virtual void BeginDragDrop();

// Node operations (internal)
protected:
	CNode* GetLBNode(int nIndex = -1);
	virtual int CompareData(const CNode* pNode1, const CNode* pNode2);
	int CompareNodes(const CNode* pNode1, const CNode* pNode2);
	virtual BOOL DeleteNode(CNode* pNode);

// data
protected:
	BOOL m_bIsMultiSelection : 1;	// Allow multiple selections;
	BOOL m_bStickySelection : 1;	// allows for mulitple sticky selections (LBS_MULTIPLESEL)
	BOOL m_bKeepSelectionRect : 1;	// keep the selecton rect when not focus
	BOOL m_bEnableDragDrop : 1;
	BOOL m_bShowContextPopup : 1;
	BOOL m_bShowProperties : 1;

	CTreeListBox *m_pListBox;	// our only child

	CSize m_sizeM;				// size of an "M" in the current font
								// used to determine horiz/vert tree bar dimensions

	int m_cyNode;				// height of one node in the list
	int m_cxExtent;				// approximate width of the whole list
	
	int m_EnableUpdates;		// Reference count of update holding;

	CString m_strSearch;		// typomatic search string
	time_t	m_timeLastKey;		// time since last typomatic key stroke

	CNode *m_pTree;

	static CImageWell m_Glyphs;
	static int c_cyBorder;		// SM_CYBORDER
	static int c_cyBorderX2;	// SM_CYBORDER * 2
	
	// Generated message map functions

protected:
	//{{AFX_MSG(CTreeCtl)
	afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	afx_msg void OnLbDblClk();
	afx_msg void OnLbSelChange();
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	
	friend class CTreeListBox;
};

#define IDCW_TREELISTBOX	1 // child id for listbox

/////////////////////////////////////////////////////////////////////////////
// CImageWell
// Container for bitmap images

class CImageWell
{
// ctor/dtor
public:
	CImageWell(void) {}
	~CImageWell();

// operations
public:
	BOOL Add(UINT idImage);
	BOOL Remove(UINT idImage);
	BOOL Draw(UINT idImage, CDC *pDC, CPoint pt, DWORD rop = 0);

// attributes
public:
	CSize GetBitmapExtent(UINT idImage);

// operations (internal)
protected:
	BOOL CalculateMask(CBitmap *pbitmap, CBitmap *pmask);

// data types
protected:
	struct ImageType {
		CBitmap* m_pbitmap;
		CBitmap* m_pmask;
		int m_count;
	};

// data
protected:
	CMap<UINT, UINT, ImageType, ImageType&> m_mapImages;
};

/////////////////////////////////////////////////////////////////////////////
// CNode
// Each entry in a CTreeCtl is a CNode

// CNode flags

#define TF_LASTLEVELENTRY		0x0001
#define TF_EXPANDED				0x0004
#define TF_DISABLED				0x0008
#define TF_DIRTY_CONTENT		0x0080
#define TF_DIRTY_ITEM			0x0010
#define TF_DROPTARGET           0x0100
#define TF_DRAGSOURCE           0x0200
#define TF_HIDDEN				0x0400
#define TF_SELECTED				0x0800

class CNode
{
// data types
public:
	typedef CTypedPtrList<CPtrList, CNode *> CNodeList;
	enum GlyphType { GT_Close = 0, GT_Open };

// ctor/dtor
public:
	CNode(CString strText = "", DWORD dwData = 0, CNode *pParent = NULL, UINT idGlyphClose = IDB_GlyphFolderClose, UINT idGlyphOpen = IDB_GlyphFolderOpen);
	virtual ~CNode();

// operations
	virtual BOOL SetText(CString strText)							{ ASSERT(!strText.IsEmpty()); m_strText = strText; return TRUE; }
	virtual BOOL SetData(DWORD dwData)								{ m_dwData = dwData; return TRUE; }
	virtual BOOL SetParent(CNode *pParent)							{ ASSERT(pParent); m_pParent = pParent; return TRUE; }
	virtual BOOL SetFlags(int nFlags)								{ m_nFlags |= nFlags; return TRUE; }
	virtual BOOL ClearFlags(int nFlags)								{ m_nFlags &= ~nFlags; return TRUE; }
	virtual BOOL DrawGlyph(GlyphType glyph, CDC *pDC, CPoint pt)	{ return m_Glyphs.Draw(glyph == GT_Close ? m_idGlyphClose : m_idGlyphOpen, pDC, pt); }

// attributes
	virtual CString GetText(void)					{ ASSERT(!m_strText.IsEmpty()); return m_strText; }
	virtual DWORD GetData(void) const				{ return m_dwData; }
	virtual CNode *GetParent(void)					{ return m_pParent; }
	virtual CNodeList *GetChildren(void)			{ return &m_listChildren; }
	virtual int GetFlags(void)						{ return m_nFlags; }
	virtual int GetLevel(void)						{ if (m_pParent == NULL) return 0; return 1 + m_pParent->GetLevel(); }
	virtual UINT GetGlyphId(GlyphType glyph)		{ return glyph == GT_Close ? m_idGlyphClose : m_idGlyphOpen; }

// REVIEW(CFlaat)

	virtual void SetGlyphIds(UINT idGlyph)
  	{ m_idGlyphClose = m_idGlyphOpen = idGlyph; }


	virtual CSize GetGlyphExtent(GlyphType glyph)	{ return m_Glyphs.GetBitmapExtent(glyph == GT_Close ? m_idGlyphClose : m_idGlyphOpen); }

// data
protected:
	CString m_strText;
	DWORD m_dwData;
	CNode *m_pParent;
	CTypedPtrList<CPtrList, CNode *> m_listChildren;
	int m_nFlags;
	UINT m_idGlyphClose;
	UINT m_idGlyphOpen;

	static CImageWell m_Glyphs;
};

#endif // __TREECTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\testspg.h ===
///////////////////////////////////////////////////////////////////////////////
//	testspg.h
//
//	Created by :			Date :
//		BrianCr				08/04/95
//
//	Description :
//		Definition of the CTestsRunDlg class
//

#ifndef __TESTSPG_H__
#define __TESTSPG_H__

#include "caferes.h"
#include "suitedoc.h"

/////////////////////////////////////////////////////////////////////////////
// CTestsRunDlg dialog

class CTestsRunPage: public CPropertyPage
{
	DECLARE_DYNCREATE(CTestsRunPage)
// Construction
public:
	CTestsRunPage(CSuiteDoc* pSuiteDoc = NULL);
	~CTestsRunPage();

// Dialog Data
	//{{AFX_DATA(CTestsRunPage)
	enum { IDD = IDD_TestsRun };
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestsRunPage)
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTestsRunPage)
	afx_msg void OnSelChangeTestsRunList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void FillTestsRunList(void);
	void FillPreCondList(CTest* pTest);
	void FillPostCondList(CTest* pTest);

// data
protected:
	CSuiteDoc* m_pSuiteDoc;
};

#endif // __TESTSPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\testspg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	testspg.cpp
//
//	Created by :			Date :
//		BrianCr				08/04/95
//
//	Description :
//		Implementation of the CTestsRunPage class
//

#include "stdafx.h"
#include "testspg.h"
#include "randtest.h"
#include "set.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CTestsRunPage dialog

IMPLEMENT_DYNCREATE(CTestsRunPage, CPropertyPage)

CTestsRunPage::CTestsRunPage(CSuiteDoc* pSuiteDoc /*= NULL*/)
	: CPropertyPage(CTestsRunPage::IDD),
	  m_pSuiteDoc(pSuiteDoc)
{
	// the doc must be valid
	ASSERT(m_pSuiteDoc);

	//{{AFX_DATA_INIT(CTestsRunPage)
	//}}AFX_DATA_INIT
}

CTestsRunPage::~CTestsRunPage()
{
}

void CTestsRunPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTestsRunPage)
	//}}AFX_DATA_MAP
}

BOOL CTestsRunPage::OnSetActive(void)
{
	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// fill the tests run list
	FillTestsRunList();

	// select the last test

	OnSelChangeTestsRunList();

	return TRUE;
}


BEGIN_MESSAGE_MAP(CTestsRunPage, CPropertyPage)
	//{{AFX_MSG_MAP(CTestsRunPage)
	ON_CBN_SELCHANGE(IDL_TestsRun, OnSelChangeTestsRunList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGraphDlg message handlers

void CTestsRunPage::OnOK() 
{
	CDialog::OnOK();
}

void CTestsRunPage::OnSelChangeTestsRunList()
{
	// get the tests run list box
	CListBox* plbTestsRun = (CListBox*)GetDlgItem(IDL_TestsRun);

	// get the current selection
	CTest* pTest = NULL;
	int nSel = plbTestsRun->GetCurSel();
	if (nSel != LB_ERR) {
		// get a pointer to the test
		pTest = (CTest*)plbTestsRun->GetItemDataPtr(nSel);
	}

	// update the pre- and post- conditions list boxes
	FillPreCondList(pTest);
	FillPostCondList(pTest);
}

void CTestsRunPage::FillTestsRunList(void)
{
	// get the tests run list box
	CListBox* plbTestsRun = (CListBox*)GetDlgItem(IDL_TestsRun);

	// empty the list box
	plbTestsRun->ResetContent();

	// get the list of tests from the suite
	CSubSuite::TestList* plistTests = m_pSuiteDoc->GetTestsRunList();

	// iterate through the list of tests run
	for (POSITION pos = plistTests->GetHeadPosition(); pos != NULL; ) {
		// get the test
		CTest* pTest = plistTests->GetNext(pos);
		// add each test to the list
		int nElement = plbTestsRun->AddString(pTest->GetName());
		// store a pointer to the test in the list
		plbTestsRun->SetItemDataPtr(nElement, (void*)pTest);
	}
}

void CTestsRunPage::FillPreCondList(CTest* pTest)
{
	// get the pre-cond list box
	CListBox* plbPreCond = (CListBox*)GetDlgItem(IDL_PreCond);

	// empty the list box
	plbPreCond->ResetContent();

	// leave the list box empty if no test is selected
	if (pTest) {
		// determine whether this test is randomizable or not
		if (pTest->GetType() == TEST_TYPE_RANDOM) {
			// get the set of pre-conditions
			CSet<CVertex> Set = ((CRandomTest*)pTest)->GetPreCond();

			// iterate through the set and show them in the list
			for (POSITION pos = Set.GetStartPosition(); pos != NULL; ) {
				// get the pre-condition
				CVertex precond = Set.GetNext(pos);
				// add the pre-condition to the list
				plbPreCond->AddString(precond.GetName());
			}
		}
		else {
			plbPreCond->AddString("No pre-conditions");
		}
	}
}

void CTestsRunPage::FillPostCondList(CTest* pTest)
{
	// get the post-cond list box
	CListBox* plbPostCond = (CListBox*)GetDlgItem(IDL_PostCond);

	// empty the list box
	plbPostCond->ResetContent();

	// leave the list box empty if no test is selected
	if (pTest) {
		// determine whether this test is randomizable or not
		if (pTest->GetType() == TEST_TYPE_RANDOM) {

			// get the set of post-conditions
			CSet<CVertex> Set = ((CRandomTest*)pTest)->GetPostCond();

			// iterate through the set and show them in the list
			for (POSITION pos = Set.GetStartPosition(); pos != NULL; ) {
				// get the post-condition
				CVertex postcond = Set.GetNext(pos);
				// add the post-condition to the list
				plbPostCond->AddString(postcond.GetName());
			}
		}
		else {
			plbPostCond->AddString("No post-conditions");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\vwprtbar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// vwprtbar.cpp
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Implementation of the CSuiteBar class

#include "stdafx.h"
#include "vwprtbar.h"
#include "caferes.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CViewportBar buttons
static UINT BASED_CODE btnsViewportBar[] =
{
	IDM_ViewportHeaderFilter,
	IDM_ViewportSummaryFilter,
	IDM_ViewportCommentsFilter,
	IDM_ViewportResultsFilter,
	IDM_ViewportFailureFilter,
	IDM_ViewportInfoFilter,
		ID_SEPARATOR,
	IDM_ViewportSeparatorFilter,
	IDM_ViewportSuccessFilter,
	IDM_ViewportStepFilter
};

/////////////////////////////////////////////////////////////////////////////
// CViewportBar

BOOL CViewportBar::CreateBar(CWnd* pParent)
{
	// create the toolbar
	if (!Create(pParent, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_TOOLTIPS | CBRS_FLYBY, IDT_ViewportBar) ||
			!LoadBitmap(IDB_VIEWPORTBAR) ||
			!SetButtons(btnsViewportBar, sizeof(btnsViewportBar)/sizeof(UINT))) {
		TRACE("CViewportBar::CreateBar: Failed to create ViewportBar\n");
		return FALSE;       // fail to create
	}

	// make the toolbar dockable
	EnableDocking(CBRS_ALIGN_ANY);

	// set the title
	SetWindowText("Viewport");

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Log\loguser.cpp ===
#include "stdafx.h"
#include "log.h"


int main(void)
{
  CLog *pLog;
  CString strLogName("test.log");

  CFile *pfOutput = new CFile("output.txt", CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::typeBinary);


  pLog = new CTextLog(     // this will be done by the driver
    "Suite 7",  // suite name
    "This is a sample suite for CTextLog.",  // suite description
    strLogName,  // name of final output file
    "summary.log",  // name of summary file for TP3
    ".",  // work directory
    (HANDLE)pfOutput->m_hFile,    // output handle
    TRUE);  // record comments in log

  if (!pLog)
    return 1;


// first test

  pLog -> BeginTest("Dialog Box Check", "Debugger Sniff", "WaltCr");   // done by each subsuite

  pLog -> RecordFailure("My quickwatch dialog didn't appear!");
  pLog -> Comment("I was looking for caption 'QuickWatch'...");
  pLog -> RecordInfo("Our build took 32 seconds.");
  pLog -> RecordFailure("My breakpoints dialog didn't appear!");
  pLog -> Comment("BTW, the hWnd of the IDE was 0x000004f6");

  pLog -> EndTest();  // done by each subsuite




// second test

  pLog -> BeginTest("Build System Check", "System Sniff");   // done by each subsuite

  pLog -> Comment("We appear to have less than 10MB free, which is risky for this test.");

  pLog -> EndTest();  // done by each subsuite
  
  delete pLog;

  pfOutput->Flush();
  delete pfOutput;

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Cafedrv\vwprtbar.h ===
/////////////////////////////////////////////////////////////////////////////
// vwprtbar.h
//
// email	date		change
// briancr	11/03/94	created
//
// copyright 1994 Microsoft

// Interface of the CViewportBar class

#ifndef __VWPRTBAR_H__
#define __VWPRTBAR_H__

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CSuiteBar class

class CViewportBar : public CToolBar
{
// ctor/dtor
public:
	CViewportBar()		{ }
	~CViewportBar()	{ }

// operations
public:
	CreateBar(CWnd* pParent);
};

#endif // __VWPRTBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Log\log.cpp ===
/////////////////////////////////////////////////////////////////////////////
// log.cpp
//
// email        date            change
// cflaat       11/01/94        created
//
// copyright 1994 Microsoft

// CLog member functions

#include "stdafx.h"
#include "afxdllx.h"
#include <tchar.h>

#define EXPORT_LOG      // Make sure implicit lib linkage doesn't occur.
#include "log.h"

#define new DEBUG_NEW

// NOTE: when you override any virtual member functions, be sure to call the base class's 
// implementation at the beginning of your override

CLog::CLog(HANDLE hOutput /* =0*/,      // output handle for tagged log entries & comments
	   BOOL bRecordComments)
// UGLY_HACK(briancr): this code is here to log info to a server about who runs CAFE
// remove it as soon as possible
: m_bBigBro(TRUE)
{
  m_acArgBuf = new char[m_cchArgBuf] ;
  m_bRecordComments = bRecordComments;

  m_cTestsFinished = 0;
  m_bTestRunning = FALSE;
  m_cSuiteFailures = 0;

  m_cTotalFailures = 0;
  m_cTotalTestFailures = 0;

  // note that while CFile stores its handle as an int, it casts it to a HANDLE and
  // uses WriteFile for output

  m_pfOutput = hOutput ? new CFile((int)hOutput) : 0;

  m_bLogDebugOutput = FALSE;

}

CLog::~CLog()
{
  if (m_pfOutput)
    delete m_pfOutput;
  if (m_acArgBuf)
    delete m_acArgBuf;
}

// BeginSubSuite
//
// Description: This function is called on starting a new subsuite.
//              The szOwner parameter is the e-mail name of the 
//              person who "owns" this subsuite.
//
// Return value: TRUE
BOOL CLog::BeginSubSuite(LPCSTR szSubSuiteName, LPCSTR szOwner/* =0 */)
{
  m_strSubSuiteName = szSubSuiteName;
  m_strSubSuiteOwner = (szOwner ? szOwner : "Nobody");

  m_cSubSuiteFailures = 0;

  return TRUE;
}

// EndSubSuite
//
// Description: This function is called on ending a subsuite.
//
// Return value: TRUE
BOOL CLog::EndSubSuite(void)
{
#ifdef BIG_BRO
	// UGLY_HACK(briancr): this code is here to log info to a server about who runs CAFE
	// remove it as soon as possible
	if (m_bBigBro) {
		// log information to a server, ala Big Brother
		// Just use a hard-coded file name as this is completely internal.
		static TCHAR szLogFileName[] = _T("\\\\dtqalogs\\db\\cafe\\bigbro.dat");
		const int maxRetries = 2;
		HANDLE hFile;

		for (int i = 0; i < maxRetries ; i++ ) {
			if ((hFile = CreateFile(szLogFileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL)) != INVALID_HANDLE_VALUE) {
				break;
			}
			Sleep(300); // wait 0.3 seconds if it failed.
		}
		if ( i >= maxRetries )
			return TRUE; // No luck couldn't open the file.

		// Start writing at the end of the file.
		SetFilePointer(hFile, 0, NULL, FILE_END);

		// Write out the relevant information to the file in the following format:
		// machine name, date, time, subsuite, fail count
		const DWORD MAX_SIZE = 1024;
		TCHAR buffer[MAX_SIZE]; // Buffer to hold intermediate values.
		TCHAR logString[MAX_SIZE]; // Complete string.
		DWORD cBytesWritten;

		_tcscpy(logString, _T("\0"));

		// get computer name
		BOOL bMsg = FALSE;
		GetComputerName(buffer, (LPDWORD)&MAX_SIZE);
		if (_tcsstr(buffer, _T("BRIANCR")) != NULL) {
			bMsg = TRUE;
		}
		_tcscat(logString, buffer);
		_tcscat(logString, _T(","));

		// get the date
		_tstrdate(buffer);
		_tcscat(logString, buffer);
		_tcscat(logString, _T(","));

		// get the time
		_tstrtime(buffer);
		_tcscat(logString, buffer);
		_tcscat(logString, _T(","));

		// get the subsuite name
		_tcscat(logString, m_strSubSuiteName);
		_tcscat(logString, _T(","));

		// get the fail count
		_itot(m_cSubSuiteFailures, buffer, 10);
		_tcscat(logString, buffer);

		if (bMsg) {
			_tcscat(logString, _T(" <-- Great job Brian!!"));
		}

		_tcscat(logString, "\r\n");

		// write the line to the file
		WriteFile(hFile, logString, _tcslen(logString), &cBytesWritten, NULL);

		// close the file.
		CloseHandle(hFile);
	}
#endif

	return TRUE;
}

// BeginTest
//
// Description: This function is called on starting a new test.
//
// Return value: TRUE
BOOL CLog::BeginTest(LPCSTR szTestName, long cCompares /*= -1*/)
{
  ASSERT(!m_bTestRunning);

  if (m_bTestRunning)
    return FALSE;

  m_bTestRunning = TRUE;
  
  m_cTestSuccesses = 0;
  m_cTestFailures = 0;

  m_strTestName = szTestName;

  m_cExpectedCompares = cCompares;

  return TRUE;
}


BOOL CLog::EndTest(void)                     // this is called by derived classes
{
  // the test must be running in order to end it
  ASSERT(m_bTestRunning);
  if (!m_bTestRunning)
    return FALSE;

  // do we check the expected comparison count? (-1 is a special value that indicates ignore the comparison count)
  if (m_cExpectedCompares != -1) {
	int cActualCompares = m_cTestSuccesses + m_cTestFailures;
	// did we log more comparisons than expected?
	if (cActualCompares > m_cExpectedCompares) {
	  RecordInfo("The number of comparisons made during this test (%d) is greater than the expected number of comparisons (%d).", cActualCompares, m_cExpectedCompares);
	  RecordInfo("If no failures were reported, the test passed. Please contact the sniff owner to fix this test problem.");
	}
	// did we log fewer comparisons than expected?
	else if (cActualCompares < m_cExpectedCompares) {
      RecordFailure("This test did not fully complete because the number of successes + failures reported is less than expected.");
	  RecordInfo("The number of comparisons made during this test (%d) is less than the expected number of comparisons (%d).", cActualCompares, m_cExpectedCompares);
	}
  }

  // increment the count of finished tests
  m_cTestsFinished++;

  // if there were any failures during this test, increment the count of suite and subsuite failures
  if (m_cTestFailures) {
    m_cSuiteFailures++;
    m_cSubSuiteFailures++;
  }

  // keep track of the total number of test failures
  m_cTotalTestFailures += m_cTestFailures;

  // no test is running, now
  m_bTestRunning = FALSE;

  return TRUE;
}

BOOL CLog::RecordSuccess(PRINTF_ARGS)            // product passed a test
{
	m_cTestSuccesses++;

	return TRUE;
}

BOOL CLog::RecordFailure(PRINTF_ARGS)            // product failed a test
{
  // keep track of the total number of failures
  m_cTotalFailures++;

  // is a test running?
  if (m_bTestRunning) {
    m_cTestFailures++;
  }

  return TRUE;
}


CString CLog::GetOSDescription(void)  // e.g. "Windows NT 3.5, build 807"
{
  static LPCSTR szErr = "[Error calling GetVersionEx()]";

  OSVERSIONINFO osvi;

  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);  // required before calling GetVersionEx()

  if (!GetVersionEx(&osvi))
    return szErr;

  CString strD;

  switch (osvi.dwPlatformId)  // find the name of the OS
  {
    case VER_PLATFORM_WIN32_NT:
    {
      strD = "Windows NT";
      break;
    }
    case VER_PLATFORM_WIN32_WINDOWS:
    {
      strD = "Windows ";
	  if(osvi.dwMinorVersion==0)
		strD+="95";
	  else
		strD+="98";	//currently, we run on Win95,Win98 only (add new WIN32_WINDOWS versions here, if applicable)
		osvi.dwBuildNumber&=0x0000FFFF; //clean the HIWORD which duplicates the Version number (no idea why GetVersionEx API was designed so bogusly)
      break;
    }
    case VER_PLATFORM_WIN32s:
    {
      strD = "Win32s";
      break;
    }
    default:
    {
      return szErr;
    }
  }

  strD += ' ';  // add a space after the name

  CString strV;

  strV.Format("version %u.%u, build %u. %s", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber, osvi.szCSDVersion);

  return strD + strV;
}

BOOL CLog::SetLogDebugOutput(BOOL bValue)
{
	m_bLogDebugOutput = bValue;

	return !bValue;
}

BOOL CLog::GetLogDebugOutput(void)
{
	return m_bLogDebugOutput;
}

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Log DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Log Terminating!\n"); 
	
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Log\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
// stdafx.h
//
// email	date		change
// cflaat	11/01/94	created
//
// copyright 1994 Microsoft

// Common AFX include files

#include <afxwin.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Log\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
// stdafx.cpp
//
// email	date		change
// cflaat	11/01/94	created
//
// copyright 1994 Microsoft

// Stdafx includes

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\randtest.cpp ===
/////////////////////////////////////////////////////////////////////////////
// randtest.cpp
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1995 Microsoft

// Implementation of the CRandTest classes

#include "stdafx.h"
#include "randtest.h"
#include "subsuite.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	CTest class

IMPLEMENT_DYNAMIC(CRandomTest, CTest);

CRandomTest::CRandomTest(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/, CSet<CVertex> setPreCond /*= EmptySet*/, CSet<CVertex> setPostCond /*= EmptySet*/)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename),
  m_setPreCond(setPreCond),
  m_setPostCond(setPostCond)
{
	m_nType = TEST_TYPE_RANDOM;
}

CRandomTest::~CRandomTest()
{
}

///////////////////////////////////////////////////////////////////////////////
//	Operations

void CRandomTest::PreRun(void)
{
    CTest::PreRun();

	// dump pre-conditions to the log
	CString strCond;
	for (POSITION pos = m_setPreCond.GetStartPosition(); pos != NULL; ) {
		CVertex vertex = m_setPreCond.GetNext(pos);
		strCond += CString(vertex.GetName()) + CString(" | ");
	}
	strCond = strCond.Left(strCond.GetLength()-3);
	GetLog()->RecordInfo("Pre-conditions: %s.", (LPCSTR)strCond);
	// dump post-conditions to the log
	strCond.Empty();
	for (pos = m_setPostCond.GetStartPosition(); pos != NULL; ) {
		CVertex vertex = m_setPostCond.GetNext(pos);
		strCond += CString(vertex.GetName()) + CString(" & ");
	}
	strCond = strCond.Left(strCond.GetLength()-3);
	GetLog()->RecordInfo("Post-conditions: %s.", (LPCSTR)strCond);
}

BOOL CRandomTest::SetPreCond(CSet<CVertex>& setPreCond)
{
	m_setPreCond = setPreCond;

	return TRUE;
}

CSet<CVertex>& CRandomTest::GetPreCond(void)
{
	return m_setPreCond;
}

BOOL CRandomTest::SetPostCond(CSet<CVertex>& setPostCond)
{
	m_setPostCond = setPostCond;

	return TRUE;
}

CSet<CVertex>& CRandomTest::GetPostCond(void)
{
	return m_setPostCond;
}

CSet<CVertex> operator+(const CVertex& lhsVertex, const CVertex& rhsVertex)
{
	return CSet<CVertex>(lhsVertex) + CSet<CVertex>(rhsVertex);
}


///////////////////////////////////////////////////////////////////////////////
// Pre- and post-conditions

// accel ed vertices
extern const CVertex AccelBegin(CVertex::AccelEd, CVertex::V_AccelBegin);
extern const CVertex AccelOpen(CVertex::AccelEd, CVertex::V_AccelOpen);
// bitmap ed vertices
extern const CVertex BmpBegin(CVertex::BitmapEd, CVertex::V_BmpBegin);
extern const CVertex BmpOpen(CVertex::BitmapEd, CVertex::V_BmpOpen);
// cursor ed vertices
extern const CVertex CursorBegin(CVertex::CursorEd, CVertex::V_CursorBegin);
extern const CVertex CursorOpen(CVertex::CursorEd, CVertex::V_CursorOpen);
// debugger vertices
extern const CVertex DbgBegin(CVertex::Debugger, CVertex::V_DbgBegin);
extern const CVertex DbgDebug(CVertex::Debugger, CVertex::V_DbgDebug);
// dialog ed vertices
extern const CVertex DialogBegin(CVertex::DialogEd, CVertex::V_DialogBegin);
extern const CVertex DialogOpen(CVertex::DialogEd, CVertex::V_DialogOpen);
// icon ed vertices
extern const CVertex IconBegin(CVertex::IconEd, CVertex::V_IconBegin);
extern const CVertex IconOpen(CVertex::IconEd, CVertex::V_IconOpen);
// menu ed vertices
extern const CVertex MenuBegin(CVertex::MenuEd, CVertex::V_MenuBegin);
extern const CVertex MenuOpen(CVertex::MenuEd, CVertex::V_MenuOpen);
// project vertices
extern const CVertex ProjBegin(CVertex::Project, CVertex::V_ProjBegin);
extern const CVertex ProjOpen(CVertex::Project, CVertex::V_ProjOpen);
extern const CVertex ProjBuilt(CVertex::Project, CVertex::V_ProjBuilt);
// res script vertices
extern const CVertex ResBegin(CVertex::ResScript, CVertex::V_ResBegin);
extern const CVertex ResOpen(CVertex::ResScript, CVertex::V_ResOpen);
// source ed vertices
extern const CVertex SrcBegin(CVertex::SourceEd, CVertex::V_SrcBegin);
extern const CVertex SrcOpen(CVertex::SourceEd, CVertex::V_SrcOpen);
// string ed vertices
extern const CVertex StringBegin(CVertex::StringEd, CVertex::V_StringBegin);
extern const CVertex StringOpen(CVertex::StringEd, CVertex::V_StringOpen);
// toolbar ed vertices
extern const CVertex ToolbarBegin(CVertex::ToolbarEd, CVertex::V_ToolbarBegin);
extern const CVertex ToolbarOpen(CVertex::ToolbarEd, CVertex::V_ToolbarOpen);
// version ed vertices
extern const CVertex VersionBegin(CVertex::VersionEd, CVertex::V_VersionBegin);
extern const CVertex VersionOpen(CVertex::VersionEd, CVertex::V_VersionOpen);

// empty set
const CSet<CVertex> EmptySet;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\rawstrng.cpp ===
///////////////////////////////////////////////////////////////////////////////                                                                  /////////////////////////////////////////////////////////////////////////////
// rawstrng.cpp
//
// email	date		change
// jimgries	3/30/95     created
//
// copyright 1995 Microsoft

// Implementation of the CRawListString class.
#include "stdafx.h"
#include "rawstrng.h"

#define new DEBUG_NEW

CRawListString::CRawListString() : CString()
{
    m_nLen = 0;
    m_pStartPos = 0;
    m_bParsed = FALSE;
}

CRawListString::CRawListString(const CString &str) : CString(str)
{
    m_nLen = GetLength();
    m_pStartPos = GetBuffer(m_nLen);
    m_bParsed = FALSE;
}

CRawListString::~CRawListString()
{
    if (m_bParsed)
    {
        // Convert all null's back into spaces.
        for (int i = 0; i < m_nLen; i++)
            if (m_pStartPos[i] == '\0')
                m_pStartPos[i] = ' ';
    }

    ReleaseBuffer();
}

void CRawListString::Reset()
{
    if (m_bParsed)
    {
        // Convert all null's back into spaces.
        for (int i = 0; i < m_nLen; i++)
            if (m_pStartPos[i] == '\0')
                m_pStartPos[i] = ' ';

        ReleaseBuffer();
        m_pStartPos = GetBuffer(m_nLen);

        m_bParsed = FALSE;
    }
}

CRawListString::operator LPCSTR() const
{
    return m_pchData;
}

CRawListString& operator>>(CRawListString& rls, int& x)
{
    if (rls.m_bParsed == FALSE)
    {
        rls.m_nLen = rls.GetLength();
        rls.m_pStartPos = rls.GetBuffer(rls.m_nLen);
    }

    x =  atoi(strtok(rls.m_bParsed? NULL: rls.m_pStartPos, " \t"));
    rls.m_bParsed = TRUE;
    return rls;
}

CRawListString& operator>>(CRawListString& rls, CString& str)
{
    if (rls.m_bParsed == FALSE)
    {
        rls.m_nLen = rls.GetLength();
        rls.m_pStartPos = rls.GetBuffer(rls.m_nLen);
    }

    str = strtok(rls.m_bParsed? NULL: rls.m_pStartPos, " \t");
    rls.m_bParsed = TRUE;
    return rls;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Log\textlog.cpp ===
/////////////////////////////////////////////////////////////////////////////
// textlog.cpp
//
// email	date		change
// cflaat	11/01/94	created
//
// copyright 1994 Microsoft

// CTextLog member functions


#include "stdafx.h"

#define EXPORT_LOG	// Make sure implicit lib linkage doesn't occur.
#include "textlog.h"

#define new DEBUG_NEW

#undef __USE_RTTI  // to accommodate the MIPS folks

const int CTextLog::m_nIndent = 22;
                                    
CTextLog::CTextLog(LPCSTR szResultsFile /* = "results.log" */,
                   LPCSTR szSummaryFile /* = "summary.log" */,
                   LPCSTR szWorkDir /* = 0*/, 
                   HANDLE hOutput /* = 0*/,
                   BOOL bLogComments /* = FALSE*/ )
  : CLog(hOutput, bLogComments)
{
  ASSERT(szResultsFile && *szResultsFile && szSummaryFile && *szSummaryFile);

  m_nLastDetailBanner = -1;

  CString strLogDir(szWorkDir ? szWorkDir : ".");

  strLogDir += "\\";

  // The summary & results log names are configurable because TP3 is
  // dependent upon their exact name and form.

  VERIFY(m_sfHeader.  Open(strLogDir + "header.txt",  CFile::typeText | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyWrite));
  VERIFY(m_sfDetails. Open(strLogDir + "details.txt", CFile::typeText | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyWrite));
  VERIFY(m_sfSummary. Open(strLogDir + szSummaryFile, CFile::typeText | CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyWrite));
  VERIFY(m_sfResults. Open(strLogDir + szResultsFile, CFile::typeText | CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite));


  EmitHeaderInformation();
}


CTextLog::~CTextLog(void)
{
  //REVIEW(CFlaat): should the m_bTestRunning check be encapsulated up in CLog?
  if (m_bTestRunning)  // abnormal termination
  {
    EndTest();
    TRACE("Hey!  CTextLog destructed before EndTest was called!!!");
  }

  EmitSummaryInformation();
}

BOOL CTextLog::BeginSubSuite(LPCSTR szSubSuiteName, LPCSTR szOwner)
{
  // call the base class
  BOOL bRet = CLog::BeginSubSuite(szSubSuiteName, szOwner);

  if (bRet)
  {
    CString str;
    str.Format("SubSuite: %s - Owned by %s", (LPCSTR)m_strSubSuiteName, (LPCSTR)m_strSubSuiteOwner);
    EmitBanner(Header, str);

  }

  return bRet;
}

BOOL CTextLog::EndSubSuite(void)
{
  // call the base class
  return CLog::EndSubSuite();
}

BOOL CTextLog::BeginTest(LPCSTR szTestName, long cCompares /*= -1*/)
{
  // call the base class
  BOOL bRet = CLog::BeginTest(szTestName, cCompares);

  if (bRet)
  {
    CString str;
    str.Format("Test: %s", (LPCSTR)m_strTestName);
    EmitSeparator(str);  
  }

  return bRet;
}

BOOL CTextLog::EndTest(void)                         // this is called after each test case
{
  // call the base class
  CLog::EndTest();

  CString strV;

  strV.Format("%s - %s", m_cTestFailures? "FAIL": "PASS", (LPCSTR)m_strTestName);

  EmitDetails(Summary, strV);
  EmitLine(Summary, "");

	// this is so the step window doesn't display the name of a test after it is finished.
	m_strTestName.Empty();
  return TRUE;
}

BOOL CTextLog::RecordSuccess(PRINTF_ARGS)            // product passed a test
{
  // call the base class
  CLog::RecordSuccess(0);

  ParseArguments();

  EmitDetails(SuccessDetails, m_acArgBuf);

  return TRUE;
}


BOOL CTextLog::RecordFailure(PRINTF_ARGS)        // product failed a test
{
  // call the base class
  CLog::RecordFailure(0);

  ParseArguments();

  EmitDetails(FailureDetails, m_acArgBuf);

  return TRUE;
}

BOOL CTextLog::RecordTestKeys(PRINTF_ARGS)
{
  ParseArguments();
  
  EmitDetails(None, m_acArgBuf);

  return TRUE;
}

BOOL CTextLog::RecordInfo(PRINTF_ARGS)			      // recorded but ignored
{
  ParseArguments();
  
  EmitDetails(InfoDetails, m_acArgBuf);

  return TRUE;
}

BOOL CTextLog::RecordCompare(BOOL bSuccess, PRINTF_ARGS)		// called to record based on bSuccess
{
	ParseArguments();

	if (bSuccess) {
		RecordSuccess(m_acArgBuf);
	}
	else {
		RecordFailure(m_acArgBuf);
	}

	return bSuccess;
}


BOOL CTextLog::Comment(PRINTF_ARGS)              // chatty trace commentary that can be ignored
{
  ParseArguments();
  
  EmitDetails(Comments, m_acArgBuf);

  return TRUE;
}


BOOL CTextLog::RecordTextFile(LPCSTR szFile, PRINTF_ARGS)  // append a text file to the log
{
  CString str;
  
  ParseArguments();
  
  str.Format("Inserting file '%s': %s", szFile, m_acArgBuf);
  EmitLine(InfoDetails, str);

  try
  {
	CStdioFile *pTextFile = new CStdioFile(szFile, CFile::typeText | CFile::modeRead | CFile::shareDenyWrite);

	ConcatStdioFiles(m_sfDetails, *pTextFile);

	delete pTextFile;
  }
  catch (CFileException* fe)
  {
    RecordInfo("CTextLog::RecordTextFile(): Exception generated trying to read text file");
    fe->Delete();
  }

  return TRUE;
}


BOOL CTextLog::RecordCriticalError(PRINTF_ARGS)  // called for errors that force test termination
{
  EmitLine(FailureDetails, "*** CRITICAL ERROR ***");
  CString str;

  ParseArguments();

  str.Format("==>> %s", m_acArgBuf);
  EmitLine(FailureDetails, str);

  // TODO: find out if we need to throw an exception or some such thing

  // for now, just note that it's a failure

  CLog::RecordFailure(0);

  return TRUE;
}

// protected members

void CTextLog::EmitBanner( EntryType eType, LPCSTR pszBannerTitle)
{
  const LPCSTR BANNER_SEPARATOR = "[=============================================================================]";

  CString str;
  str.Format("[  %-73s  ]", pszBannerTitle);
  EmitLine(eType, BANNER_SEPARATOR);

  // Ignore all banner lines in the LogTree View .
 /* if (str == "Suite Summary")
	EmitLine(eType, str,SUMMARY);
		else
			if (str == "General Information")
				EmitLine(eType, str,HEADER);
				else 
					if (str.Find("Owned by") != -1)
						EmitLine(eType, str,HEADER);
					else 	  */
  EmitLine(eType, str);
  EmitLine(eType, BANNER_SEPARATOR);
  EmitLine(eType, "");
}

void CTextLog::EmitSeparator(LPCSTR pszSeparatorTitle)
{
  CString str;
  str.Format("[--------------------< %-33s >--------------------]", pszSeparatorTitle);

  EmitLine(Separator, str);
  EmitLine(Separator, "");
}

void CTextLog::EmitSummaryInformation( void )
{
  LPCSTR szValueFmt = "%4u";
  LPCSTR szFmt = "%4u  (%u%%)";
  CString str;
  unsigned uPctFailed, uPctPassed;
  double dPctFailed;

  ASSERT(m_cTestsFinished >= m_cSuiteFailures);

  if (m_cTestsFinished)
  {
#ifdef __USE_RTTI
    dPctFailed = 100.0 * static_cast<double>(m_cSuiteFailures) / static_cast<double>(m_cTestsFinished);
#else
    dPctFailed = 100.0 * (double)(m_cSuiteFailures) / (double)(m_cTestsFinished);
#endif

    // the following line rounds to the nearest integer
    //   (I couldn't find any obvious CRT function that rounds to the nearest integer)

#ifdef __USE_RTTI
    uPctFailed = static_cast<unsigned>((0.5) + (dPctFailed));
#else
    uPctFailed = (unsigned)((0.5) + (dPctFailed));
#endif
  
    if (m_cSuiteFailures && (!uPctFailed))  // if failing %age rounded away
      uPctFailed = 1;  // force it to a 1% minimum

    uPctPassed = 100 - uPctFailed;  // this will definitely make 'em add up to 100
  }
  else
  {
    uPctFailed = uPctPassed = 0;
  }

  EmitBanner(Results, "Suite Summary");
  // write total failure info
  str.Format(szValueFmt, m_cTotalFailures);
  EmitFieldAndValue(Results, "Total Failures", str);
  str.Format(szValueFmt, m_cTotalTestFailures);
  EmitFieldAndValue(Results, "Test Failures", str);
  str.Format(szValueFmt, m_cTotalFailures - m_cTotalTestFailures);
  EmitFieldAndValue(Results, "Non-test Failures", str);
  EmitLine(Results, "");
  // write test info
  str.Format("%4u", m_cTestsFinished);
  EmitFieldAndValue( Results, "Tests Run", str);
  str.Format(szFmt, m_cTestsFinished - m_cSuiteFailures, uPctPassed);
  EmitFieldAndValue( Results, "Tests PASSED", str);
  str.Format(szFmt, m_cSuiteFailures, uPctFailed);
  EmitFieldAndValue( Results, "Tests FAILED", str);
  m_sfResults.Flush();
  ConcatStdioFiles(m_sfResults, m_sfHeader);
  ConcatStdioFiles(m_sfResults, m_sfSummary);
  ConcatStdioFiles(m_sfResults, m_sfDetails);
}


void CTextLog::EmitHeaderInformation( void )
{
  CString str;

  EmitBanner(Header, "General Information");
	EmitFieldAndValue( Header, "Command Line", GetCommandLine() );
	EmitFieldAndValue( Header, "Date", CTime::GetCurrentTime().Format( "%A, %b %d %Y") );

  str = CTime::GetCurrentTime().Format("%#I:%M %p"); // get "AM/PM"
  str.MakeLower();   // make it "am/pm"
	EmitFieldAndValue( Header, "Time", str );

	EmitFieldAndValue( Header, "Operating System", GetOSDescription() );

	// Find and emit the computer name.
	DWORD len = MAX_COMPUTERNAME_LENGTH+1;
	LPTSTR lpszNetName = new char[len];
	if (!GetComputerName(lpszNetName, &len))
		strcpy(lpszNetName, "[Error calling GetComputerName()]");
	EmitFieldAndValue( Header, "Computer Name", lpszNetName);
	delete [] lpszNetName;

  CString strProcessor;

  SYSTEM_INFO si;
  GetSystemInfo(&si);
  switch(si.dwProcessorType)
  {
  case PROCESSOR_INTEL_386:
    strProcessor = "Intel 386"; 
    break;
  case PROCESSOR_INTEL_486:
    strProcessor = "Intel 486";
    break;
  case PROCESSOR_INTEL_PENTIUM:
    strProcessor = "Intel Pentium";
    break;


// WARNING:PROCESSOR_INTEL_860, PROCESSOR_MIPS_R2000, PROCESSOR_MIPS_R3000, PROCESSOR_PPC_601, 603, 604, 620
// no longer defined in WINNT.h

  case PROCESSOR_MIPS_R4000:
    strProcessor = "MIPS R4000";
    break;
  case PROCESSOR_ALPHA_21064:
    strProcessor = "Alpha 21064";
    break;

  default:
    strProcessor = "Undefined";
    break;
  }

	EmitFieldAndValue( Header, "Processor", strProcessor );

  const int ccBuf = 400;
  char acBuf[ccBuf];
  LPCSTR pcDrive = acBuf;
  DWORD dw;

  dw = GetLogicalDriveStrings(ccBuf, acBuf);

  BOOL bResult;
  DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters;
  unsigned uFree;
  double dFree;
  UINT uDriveType;

  CString strDrv, strSpc;

  while (pcDrive[0])
  {
    // see if it's a local hard drive

    uDriveType = GetDriveType(pcDrive);

    if (uDriveType == DRIVE_FIXED)  // if it's a local hard drive
    {
      bResult = GetDiskFreeSpace(
        pcDrive,
        &dwSectorsPerCluster,
        &dwBytesPerSector,
        &dwFreeClusters,
        &dw);

      uFree = dwBytesPerSector * dwSectorsPerCluster * dwFreeClusters;
      dFree = uFree / 1048576.0;  // express as megabytes
#ifdef __USE_RTTI
      uFree = static_cast<unsigned>(dFree + 0.5); // round to nearest MB
#else
      uFree = (unsigned)(dFree + 0.5); // round to nearest MB
#endif

      strDrv.Format("Space on Drive '%c'", toupper(pcDrive[0]));
      strSpc.Format("%uMB", uFree);

  	  EmitFieldAndValue( Header, strDrv, strSpc);
    }

    pcDrive += 1 + strlen(pcDrive);
  }


	// physical memory?
	// free memory?

  EmitLine(Header, "");
}


//	Header Text
//


//  EntryType definition from textlog.h:
//
//    enum EntryType { Header, Summary, Comments, Results, FailureDetails, InfoDetails, Separator };
//


void CTextLog::EmitFieldAndValue( EntryType eType, LPCSTR szField, LPCSTR szValue )
{
  CString str;

  str.Format("%*s: %s", m_nIndent, szField, szValue);  // -> CRASHES!  Olympus bug 2412.

  EmitLine(eType, str);

}


void CTextLog::EmitLine(EntryType eType, LPCSTR szEntry)
{
  ASSERT(szEntry);  // no null pointers
  CStdioFile *pSF;
   switch (eType)
  {
   case Header:
     pSF = &m_sfHeader;
     break;
   case Summary:
     pSF = &m_sfSummary;
     break;
  case InfoDetails:
  case FailureDetails:
  case Separator:
  case SuccessDetails:
  case  None:
     pSF = &m_sfDetails;
     break;
  case Results:
     pSF = &m_sfResults;
     break;
  case Comments:
     pSF = (m_bRecordComments ? &m_sfDetails : 0);
     break;
   default:
     ASSERT(FALSE); // a bad eType param
     pSF = 0;
     break;
  }

  CString str(szEntry);

  str += '\n';

  char acBuf[3] = {"\xff\0"};

  if (pSF)
  {
    pSF->WriteString(str);
    pSF->Flush();
  }

  if (m_pfOutput /* && (eType != Results)*/)
  {
#ifdef __USE_RTTI
    acBuf[1] = static_cast<char>(static_cast<char>(eType) + '0');  // just to make it printable
#else
    acBuf[1] = (char)((char)(eType) + '0');  // just to make it printable
#endif
    ASSERT(2 <= 1 + strlen(acBuf));
    m_pfOutput->Write(acBuf, 2);
    m_pfOutput->Write((LPCSTR)str, str.GetLength());
  }
}

void CTextLog::ConcatStdioFiles(CStdioFile &sfDest, CStdioFile &sfSrc)
{
  DWORD dwSrcLength;
  static const DWORD dwBufLen = 4096;  // 4KB

  static char acBuf[dwBufLen];

  dwSrcLength = sfSrc.GetLength();

  if (!dwSrcLength)
    return;

  sfSrc.SeekToBegin();

  UINT cbRead;

  do
  {
    cbRead = sfSrc.Read(acBuf, dwBufLen);
    sfDest.Write(acBuf, cbRead);
  }
  while ((sfSrc.GetPosition() < dwSrcLength) && (cbRead == dwBufLen));
}

void CTextLog::EmitDetails( EntryType eType, LPCSTR szText)
{
  CString str;

  LPCSTR pc;

  switch (eType)
  {
    case Comments:
      pc = "[Comment]";
      break;
    case InfoDetails:
      pc = "[Information]";
      break;
    case FailureDetails:
      pc = "[***FAILED***]";
      break;
    case Summary:
      pc = "[Result]";
      break;
    case SuccessDetails:
	  pc = "[Success]";
	  break;
	case None:
	  pc =" " ;
	  break;
    default:
      ASSERT(FALSE);  // shouldn't ever get here
      break;
  }

  str.Format("%-16s%s",pc, szText);
  EmitLine(eType, str);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		RickKr					8/30/93
//
//	Description :
//		Precompiled header for the Sniff Test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\set.cpp ===
/////////////////////////////////////////////////////////////////////////////
// set.cpp
//
// email	date		change
// briancr	08/02/95	created
//
// copyright 1995 Microsoft

// Implementation of the CSet class

#include "stdafx.h"
#include "set.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
// CSet class

template <class T> CSet<T>::CSet()
: m_pSet(NULL)
{
	m_pSet = new SetArray;
}

template <class T> CSet<T>::CSet(const T item)
: m_pSet(NULL)
{
	m_pSet = new SetArray;
	Add(item);
}

template <class T> CSet<T>::CSet(const CSet<T>& set)
: m_pSet(NULL)
{
	m_pSet = new SetArray;
	Copy(set);
}

template <class T> CSet<T>::~CSet()
{
	// delete the array
	// if the user wants items in the array
	// to be deleted, he/she should write an
	// appropriate DestructElements function
	RemoveAll();
	delete m_pSet;
}

template <class T> void CSet<T>::Add(const T item)
{
#pragma warning (disable: 4239)
	// a set cannot have duplicates, so only add the item, if
	// it's not already in the set
	if (!Contains(item)) {
		m_pSet->Add((T)item);
	}
#pragma warning (default: 4239)
}

template <class T> void CSet<T>::Add(const CSet<T>& set)
{
	// a set cannot have duplicates, so add each item from the
	// given set individually (Add(T) checks for duplicates
	for (POSITION pos = set.GetStartPosition(); pos != NULL; ) {
		T item = set.GetNext(pos);
		Add(item);
	}
}

template <class T> void CSet<T>::Copy(const CSet<T>& set)
{
	// clear out this set
	RemoveAll();
	// add the given set to this set
	Add(set);
}

template <class T> void CSet<T>::RemoveAll(void)
{
	// just remove all items from the array
	m_pSet->RemoveAll();
}

template <class T> POSITION CSet<T>::GetStartPosition(void) const
{
	// if the set is empty, we can't iterate
	if (GetSize() <= 0) {
		return NULL;
	}
	return (POSITION)1;
}

template <class T> T CSet<T>::GetNext(POSITION& pos) const
{
	// the position cannot be NULL
	ASSERT(pos);

	// store the current item
	T item = (*m_pSet)[(int)pos - 1];

	// increment and if the index is no longer in range, set pos to NULL
	pos = (POSITION)((int)pos + 1);
	if ((int)pos > GetSize()) {
		pos = NULL;
	}
	return item;
}

template <class T> BOOL CSet<T>::Contains(const T& item) const
{
	// look for the item in the set
	for (POSITION pos = GetStartPosition(); pos != NULL; ) {
		T setitem = GetNext(pos);
		if (setitem == item) {
			return TRUE;
		}
	}
	return FALSE;
}

template <class T> BOOL CSet<T>::IsEmpty(void) const
{
	return (GetSize() <= 0);
}

template <class T> CSet<T>& CSet<T>::operator=(const CSet<T>& set)
{
	// copy the set
	Copy(set);

	return *this;
}

template <class T> BOOL CSet<T>::operator==(const CSet<T>& set)
{
	// two sets are equal if they have the same number of items
	// and all the items are in both sets
	if (GetSize() != set.GetSize()) {
		return FALSE;
	}
	for (POSITION pos = GetStartPosition(); pos != NULL; ) {
		T item = GetNext(pos);
		if (!set.Contains(item)) {
			return FALSE;
		}
	}
	return TRUE;
}

template <class T> BOOL CSet<T>::operator!=(const CSet<T>& set)
{
	return !(operator==(set));
}

template <class T> CSet<T> CSet<T>::operator+(const CSet<T>& set)
{
	CSet<T> result;
	// the union of both sets may not be a valid set,
	// i.e., there may be duplicate items
	// we can simply copy the first set, since it's valid
	result.Copy(*this);
	// and add in the second set, which will check for duplicates
	result.Add(set);

	return result;
}

template <class T> int CSet<T>::GetSize(void) const
{
	return m_pSet->GetSize();
}

// specialize for CVertex
#include "vertex.h"

template CSet<CVertex>;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		DavidGa					8/24/93
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\subsuite.cpp ===
/////////////////////////////////////////////////////////////////////////////
// subsuite.cpp
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Implementation of the CSubSuite class

#include "stdafx.h"
#include "subsuite.h"
#include "toolset.h"
#include "test.h"
#include "..\support\guitools\imewrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

IMPLEMENT_DYNAMIC(CSubSuite, CObject);

CSubSuite::CSubSuite(LPCSTR pszName, LPCSTR pszOwner)
: m_strName(pszName),
  m_strOwner(pszOwner),
  m_pToolset(NULL),
  m_pLog(NULL)
{
}

CSubSuite::~CSubSuite()
{
	CTest* pTest;

	// REVIEW(briancr): clean up the test list
	for (POSITION pos = m_listTests.GetHeadPosition(); pos != NULL; ) {
		pTest = m_listTests.GetNext(pos);

		// delete the test data
		delete pTest;
	}

	// remove all entries from the list
	m_listTests.RemoveAll();
	// delete the parameters allocated in CCAafeDrv::ReadCmdLineSwitches()
	if (m_SuiteParams) {
		delete m_SuiteParams;
		m_SuiteParams=NULL;
    }

}

///////////////////////////////////////////////////////////////////////////////
//	Attributes

CString CSubSuite::GetName(void)
{
	// the subsuite name cannot be empty
	ASSERT(!m_strName.IsEmpty());

	return m_strName;
}

CString CSubSuite::GetOwner(void)
{
	// the owner name cannot be empty
	ASSERT(!m_strOwner.IsEmpty());

	return m_strOwner;
}

CSubSuite::TestList* CSubSuite::GetTestList(void)
{
	// the list of tests cannot be empty
	ASSERT(!m_listTests.IsEmpty());

	return &m_listTests;
}

CToolset* CSubSuite::GetToolset(void)
{
	// the toolset cannot be NULL
	ASSERT(m_pToolset);

	return m_pToolset;
}

CLog* CSubSuite::GetLog(void)
{
	// the log cannot be NULL
	ASSERT(m_pLog);

	return m_pLog;
}

CString CSubSuite::GetCWD(void)
{
	// the CWD must be set
	ASSERT(!m_strCWD.IsEmpty());
	
	return m_strCWD;
}

///////////////////////////////////////////////////////////////////////////////
//	Operations

void CSubSuite::SetUp(BOOL bCleanUp)
{
	if (bCleanUp) {
		CleanUp();
	}
}

void CSubSuite::CleanUp(void)
{
}

///////////////////////////////////////////////////////////////////////////////
// supporting operations

void CSubSuite::LoadInitialization(HINSTANCE hDLL)
{
	m_hDLL = hDLL;
	InitializeTestList();

	// get the current working directory for this test and store it
	// get the path name of the subsuite
	char szPathName[MAX_PATH];
	::GetModuleFileName(m_hDLL, szPathName, MAX_PATH);
    // split the full path/filename apart
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];
	_splitpath(szPathName, szDrive, szDir, NULL, NULL);
	// store the CWD
	m_strCWD = CString(szDrive) + CString(szDir);
}

BOOL CSubSuite::Initialize(CToolset* pToolset)
{
	// the toolset and log must be valid
	ASSERT(pToolset);
	ASSERT(pToolset->GetLog());
	if (!pToolset || !pToolset->GetLog()) {
		return FALSE;
	}

	// store the toolset and log
	m_pToolset = pToolset;
	m_pLog = pToolset->GetLog();

	// start the subsuite
	m_timeStart = CTime::GetCurrentTime();

	if (GetLog()->BeginSubSuite(GetName(), GetOwner())) {

		// Log all version and command line information for all tools.
		const CToolPtrList& list = m_pToolset->GetToolList();

		CTarget* pTool;
  
		for (POSITION pos = list.GetHeadPosition(); pos != NULL;)
		{
			pTool = list.GetNext(pos);
			// skip tools that have no filename
			if (!(pTool->GetSettings()->GetTextValue(settingFilename)).IsEmpty()) {
				GetLog()->RecordInfo("Tool: %s", (LPCSTR)pTool->GetSettings()->GetTextValue(settingFilename));
				GetLog()->RecordInfo("  Cmd Line: %s", (LPCSTR)pTool->GetFullCmdLine());
				GetLog()->RecordInfo("  Version: %s", (LPCSTR)pTool->GetVersion());
			}
		}
  
		GetLog()->RecordInfo("");
	}
	else {
		// if the subsuite doesn't start correctly, indicate this
		return FALSE;
	}

	return TRUE;
}

BOOL CSubSuite::Finalize(void)
{
	// end the subsuite
	m_timeEnd = CTime::GetCurrentTime();
	CTimeSpan elapsed_time(m_timeEnd - m_timeStart);
	m_pToolset->GetLog()->RecordInfo("Subsuite elapsed time %s", elapsed_time.Format("%H:%M:%S"));

	return m_pToolset->GetLog()->EndSubSuite();
}


///////////////////////////////////////////////////////////////////////////////
// CGUISubSuite

IMPLEMENT_DYNAMIC(CGUISubSuite, CSubSuite);

CGUISubSuite::CGUISubSuite(LPCSTR pszName, LPCSTR pszOwner)
: CSubSuite(pszName, pszOwner)
{
}

CGUISubSuite::~CGUISubSuite()
{
}

BOOL CGUISubSuite::Initialize(CToolset* pToolset)
{
	// call the base class
	return CSubSuite::Initialize(pToolset);
}

BOOL CGUISubSuite::Finalize(void)
{
	// call the base class
	return CSubSuite::Finalize();
}


///////////////////////////////////////////////////////////////////////////////
// CIDESubSuite

IMPLEMENT_DYNAMIC(CIDESubSuite, CGUISubSuite);

CIDESubSuite::CIDESubSuite(LPCSTR pszName, LPCSTR pszOwner)
: CGUISubSuite(pszName, pszOwner)
{
}

CIDESubSuite::~CIDESubSuite()
{
}

CIDE* CIDESubSuite::GetIDE(void)
{
	// the IDE object must be valid
	ASSERT(m_pIDE);

	return m_pIDE;
}

BOOL CIDESubSuite::Initialize(CToolset* pToolset)
{
	const char* const THIS_FUNCTION = "CIDESubSuite::Initialize";

	// call the base class
	if (!CGUISubSuite::Initialize(pToolset)) {
		return FALSE;
	}

	// REVIEW(briancr): use RTTI for this cast, or at least to validate it
	// initialize the IDE object
	m_pIDE = ((CVCTools*)GetToolset())->GetIDE();

	// launch the IDE (if it's not already launched)
	if (!GetIDE()->IsLaunched()) {
		GetIDE()->Launch();
	}

	// the IDE must be launched at this point
	ASSERT(GetIDE()->IsLaunched());
	if (!m_pIDE->IsLaunched()) {
		GetLog()->RecordFailure("%s: cannot launch the IDE; unable to continue.", THIS_FUNCTION);
		// throw exception
	}

	// set focus to the IDE
	::SetForegroundWindow(GetIDE()->m_hWnd);

	return TRUE;
}

BOOL CIDESubSuite::Finalize(void)
{
	// only go through the ide exit sequence if it is launched and the user chose to do so.
	if(GetIDE()->IsLaunched() && GetIDE()->GetSettings()->GetBooleanValue(settingClose))
	{
		// if we are persisting the target between subsuites, then we only want to exit the ide after the last subsuite.
		if(!gbPersistTarget || gbLastSubSuite)
		{	// close the IDE
			GetIDE()->Exit();
		}
	}

	// Turn off IMEInUse flag for the next test.
	IME.IMEInUse(FALSE);
	// call the base class
	return CGUISubSuite::Finalize();
}

void CIDESubSuite::ExpectedMemLeaks(int nExpectedLeaks)
{
	GetIDE()->m_nExpectedLeaks = nExpectedLeaks;
}

void CIDESubSuite::CleanUp(void)
{
	GetIDE()->RecordHeapUse();
	CGUISubSuite::CleanUp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\test.cpp ===
/////////////////////////////////////////////////////////////////////////////
// test.cpp
//
// email	date		change
// briancr	10/25/94	created
//
// copyright 1994 Microsoft

// Implementation of the CTest classes

#include "stdafx.h"
#include "test.h"
#include "rawstrng.h"
#include "subsuite.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	CTest class

IMPLEMENT_DYNAMIC(CTest, CObject);

CTest::CTest(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: m_pSubSuite(pSubSuite),
  m_strName(szName),
  m_nExpectedCompares(nExpectedCompares),
  m_strListFilename(szListFilename),
  m_rs(CTest::RS_NoRun),
  m_pLog(NULL),
  m_pDependency(NULL)
{
  m_pPlatformList = new CPlatformList; // create it as an empty list
	// determine the type of test
	m_nType = m_strListFilename.IsEmpty() ? TEST_TYPE_STANDARD : TEST_TYPE_LIST;
}

CTest::~CTest()
{
  if (m_pPlatformList)
  {

    while (!m_pPlatformList->IsEmpty())
    {
      delete m_pPlatformList -> RemoveHead();
    }

    delete m_pPlatformList;
  }
}

///////////////////////////////////////////////////////////////////////////////
//	Operations

void CTest::AddSupportedPlatform(const CPlatform::COS &rOS, const CPlatform::CLanguage &rLang)
{
  CPlatform *pP = new CPlatform(rOS, rLang);

  m_pPlatformList->AddTail(pP);
}


void CTest::PreRun(void)
{
	m_timeStart = CTime::GetCurrentTime();

	// store the log
	m_pLog = GetSubSuite()->GetLog();

	// get the current working directory for this test and store it
	m_strCWD = GetSubSuite()->GetCWD();

	// start the test
    GetLog()->BeginTest(m_strName, m_nExpectedCompares);
}

void CTest::PreRun(CRawListString& strRaw)
{
    CTest::PreRun();

    GetLog()->RecordInfo("--------------------------------------------------------------");
    GetLog()->RecordInfo("Input for this iteration of List Based Test");
    GetLog()->RecordInfo("%s", (LPCSTR)strRaw);
    GetLog()->RecordInfo("--------------------------------------------------------------");
}

void CTest::Run(void)
{
}

void CTest::Run(CRawListString &)
{
    CTest::Run();
}

void CTest::PostRun(void)
{
	m_timeEnd = CTime::GetCurrentTime();
	CTimeSpan elapsed_time(m_timeEnd - m_timeStart);
	GetLog()->RecordInfo("Test elapsed time %s", elapsed_time.Format("%H:%M:%S"));

	// notify the log that a test ended
	GetLog()->EndTest();

}

void CTest::PostRun(CRawListString&)
{
    CTest::PostRun();
}

BOOL CTest::RunAsDependent(void)
{
	// always run this test as a dependency, if asked
	// override this function, if needed
	return TRUE;
}

CLog* CTest::GetLog(void)
{
	// the log cannot be NULL
	ASSERT(m_pLog);

	return m_pLog;
}

CSubSuite* CTest::GetSubSuite(void)
{
	// the subsuite cannot be NULL
	ASSERT(m_pSubSuite);

	return m_pSubSuite;
}

CString CTest::GetCWD(void)
{
	// the current working directory cannot be empty
	ASSERT(!m_strCWD.IsEmpty());

	return m_strCWD;
}

BOOL CTest::SetName(LPCSTR szName)
{
	// the name should not be empty
	ASSERT(szName);

	// once the name is set, it can't be set again
	// (to prevent other clients from changing the name)
	ASSERT(m_strName.IsEmpty());

	if (!m_strName.IsEmpty()) {
		return FALSE;
	}

	m_strName = szName;

	return TRUE;
}

CString CTest::GetName(void)
{
	// this can't be called unless the name has been set
	ASSERT(!m_strName.IsEmpty());

	return m_strName;
}

BOOL CTest::SetRunState(RunState rs)
{
	m_rs = rs;

	return TRUE;
}

CTest::RunState CTest::GetRunState(void)
{
	return m_rs;
}

BOOL CTest::SetListFilename(LPCSTR szListFilename)
{
	// the filename should not be empty
	ASSERT(szListFilename);

	// once the name is set, it can't be set again
	// (to prevent other clients from changing the name)
	ASSERT(m_strListFilename.IsEmpty());

	if (!m_strListFilename.IsEmpty()) {
		return FALSE;
	}

	m_strListFilename = szListFilename;

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: CString CListTest::GetListFilename()
// Return: A CString containing the name of the file containing
//         a list of items.  The name returned is identical to what is
//         specified at list creation.
// END_HELP_COMMENT
CString CTest::GetListFilename()
{
    return m_strListFilename;
}

BOOL CTest::SetDependency(CTest* pTest)
{
	// the dependency must be valid
	ASSERT(pTest);

	m_pDependency = pTest;

	return TRUE;
}

CTest* CTest::GetDependency(void)
{
	return m_pDependency;
}

BOOL CTest::CanTestPlatform(CPlatform *pPlatform)
{
    // In this function we iterate through the list of supported platforms, and
	//   declare success if we find any match at all in the list.

#if 0
  // use this to test the enabling/disabling functionality
  CPlatform p(CPlatform::Win32Intel, CPlatform::AnyLanguage);

  return (p.Includes(*pPlatform));
#endif

// real implementation:

    POSITION pos;
  	CPlatform *pNext;

	pos = m_pPlatformList -> GetHeadPosition();

  if (!pos)  // if list is empty
    return TRUE;  // then default to running against any platform

  do
	{
      pNext = m_pPlatformList->GetNext(pos);

	    // does this platform support the