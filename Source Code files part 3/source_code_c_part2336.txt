urrent states
    //
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_IMAGE_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_IMAGE_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_IMAGE_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_IMAGE_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING))
            GetAudioEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
    }

#ifdef NOTYET
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }
#endif

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_VID_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_VID_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_VID_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_VID_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
            stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_AUD_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(1):
            stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_AUD_RM_STATE, stateRM);
            break;
#ifdef NOTYET
        case CLASS04E_IMAGE_EVENT(0):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        case CLASS04E_IMAGE_EVENT(1):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
#endif
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mp\nv\mp.c ===
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <mp.h>
#include "nvhw.h"

//
// Forwards.
//
V032 mpService(PHWINFO);

//
// mpService
//
// Field MediaPort exceptions by invoking class-dependent handlers.
//
V032 mpService
(
    PHWINFO pDev
)
{
    V032 intrStatus = 0;

    //
    // Decompressor.
    //
    (void) class04EService(pDev);

    //
    // Decoder.
    //
    (void) class04DService(pDev);

    //
    // Parallel bus.
    // This is the interrupt status value we'll return.
    //
    intrStatus = class04FService(pDev);

    return intrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c63nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class63Method_NV04(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV04(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV04(PHALHWINFO, U032);
RM_STATUS class63GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000);
RM_STATUS class63Service_NV04(PVIDEOSERVICEEVENTARG_000);

//
// Statics
//
static RM_STATUS class63StartXfer_NV04(PHALHWINFO, VOID *, U032);
static VOID class63KickoffBuffer_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63DualSurface_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

static VOID class63ColorKey_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV04;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV04(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV04(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)
{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, scale, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //
        
    // calculate scaling factors

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;

    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        step_x = ((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1);
        step_y = ((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1);
        scale = ((step_y & 0xfff) << 16) | (step_x & 0xfff);
    }
    else
        return;

    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START ,vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END   ,vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START ,hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END   ,hbe);    
        
    // Video scalar
    REG_WR32(NV_PVIDEO_STEP_SIZE  ,scale);        // scale factor 1:1
    REG_WR32(NV_PVIDEO_BUFF0_PITCH,pitch0);     // pitch buffer 0
    REG_WR32(NV_PVIDEO_BUFF1_PITCH,pitch1);     // pitch buffer 1
    REG_WR32(NV_PVIDEO_WINDOW_SIZE,hw);         // h (26:16), w (10:0)
}

//
// Program the video scalar to scan out the framebuffer (desktop) to the
// TV encoder.
// Or, turn off the video scalar for TV only or monitor.
//
VOID class63DualSurfaceDesktop_NV04(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff, setup, vbs, vbe, hbs, hbe, scale, start_buf0, start_buf1, pitch0, pitch1, xy_pos, hw, fifo0, fifo1, reg32;
    int dualSurface = 0;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;
        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                scale = 0x08000800;     // 1:1
            }            
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // put video scalar in idle state, pointing at buffer 1            
        REG_WR32(NV_PVIDEO_OE_STATE, 0x01000000);             
        REG_WR32(NV_PVIDEO_OE_STATE, 0x01000000);             
        //WritePriv32(0x00110000, NV_PVIDEO_SU_STATE);             
        //WritePriv32(0x00110000, NV_PVIDEO_SU_STATE);             
#if 0 // we can get stuck if we are in VGA mode; we'll never reach HalInfo.VertDisplayWidth
        // wait end of screen
        reg32 = 0;
        while (reg32 < pHalHwInfo->pFbHalInfo->VertDisplayWidth)
        {
            reg32 = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
        }
#endif
        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    
            
        ////WritePriv32(coeff, NV_PRAMDAC_PLL_COEFF_SELECT);   
        ////WritePriv32(setup, NV_PRAMDAC_TV_SETUP);          
        ////WritePriv32(vbs, NV_PRAMDAC_TV_VBLANK_START);   
        ////WritePriv32(vbe, NV_PRAMDAC_TV_VBLANK_END);    
        ////WritePriv32(hbs, NV_PRAMDAC_TV_HBLANK_START);     
        ////WritePriv32(hbe, NV_PRAMDAC_TV_HBLANK_END);    

        // Video scalar
        REG_WR32(NV_PVIDEO_STEP_SIZE   , scale);        // scale factor 1:1
        REG_WR32(NV_PVIDEO_BUFF0_PITCH , pitch0);     // pitch buffer 0
        REG_WR32(NV_PVIDEO_BUFF1_PITCH , pitch1);     // pitch buffer 1
        REG_WR32(NV_PVIDEO_WINDOW_SIZE , hw);         // h (26:16), w (10:0)
        REG_WR32(NV_PVIDEO_FIFO_THRES  , fifo0);       // fifo fill threshold
        REG_WR32(NV_PVIDEO_FIFO_BURST  , fifo1);       // fifo burst length
        REG_WR32(NV_PVIDEO_WINDOW_START, xy_pos);    // x,y position within buffer (start display here)
        REG_WR32(NV_PVIDEO_BUFF0_START , start_buf0); // start address buffer 0
        REG_WR32(NV_PVIDEO_BUFF1_START , start_buf1); // start address buffer 1
            
        ////WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1
        ////WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0
        ////WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1
        ////WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
        ////WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        ////WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
        ////WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)
        ////WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0
        ////WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1

        // 
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        ////WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE

    }    
    else    // need to set up for either TV only or Monitor only
    {
        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        ////WritePriv32(setup, 0x680700);   // TV SETUP
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }            
}

static VOID class63ColorKey_NV04
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_KEY, color);
                break; 
        }
            
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _ON);
    } 
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _OFF);
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV04
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    V032            stateSU;
    V032            stateOE;
    V032            stateOESU;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV04(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _YUY2);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);
        
    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
    if (buffNum == (stateOE >> 24))
    {
        // The current buffer in stateOE is same as the one we want to start.
        // If both buffers are idle in this state, we have to toggle the current
        // buffer to make the overlay engine look at the buffer we are about to
        // setup.
        stateOESU = stateOE ^ stateSU;
        if ((stateOESU & 0x00100000) &&  //buffer 1 is idle
            (stateOESU & 0x00010000))    //buffer 0 is idle
        {
            stateOE ^= 0x01000000;
            REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
        }
    }
        
    status = class63StartXfer_NV04(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
    if (status == RM_OK)
    {
    	// Actually kickoff the buffer that was just marked busy by writing the registers.
        // After this, buffers are actually kicked off after we get the completion interrupt.

        if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
        {
            class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0);
        }
        else
        {
            class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1);
        }
        
        // Set the enable bit in VBLANK. This is to prevent enabling the video in the middle of
        // the video window. That may cause only the "end window" processing to be done without
        // having done the "start window" processing.
        // FLD_WR_DRF_NUM(_PVIDEO, _OVERLAY, _VIDEO, pDev->Video.Enabled);
        pHalHwInfo->pVideoHalInfo->UpdateFlags |= UPDATE_HWINFO_VIDEO_ENABLE;

        //
        // This instance has been initialized.  Call StartXfer for the next
        // buffer updates.
        //
        pVidFromMemHalObj->KickOffProc = class63StartXfer_NV04;
    }
    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV04
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS       status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv04.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;
#ifdef DEBUG_TIMING
    vmmOutDebugString("\n0B");
#endif

    return (status);
}

static VOID class63KickoffBuffer_NV04
(
    PHALHWINFO                  pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT      pVidFromMemHalObj,
    U032                        buffNum
)
{
    V032 stateSU;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);

    if (buffNum == 0) {
        REG_WR32(NV_PVIDEO_BUFF0_START, pVidFromMemHalObj->Buffer[buffNum].Start);
        REG_WR32(NV_PVIDEO_BUFF0_PITCH, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x00007FF0));
        FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 3));
    } else {
        REG_WR32(NV_PVIDEO_BUFF1_START, pVidFromMemHalObj->Buffer[buffNum].Start);
        REG_WR32(NV_PVIDEO_BUFF1_PITCH, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x00007FF0));
        FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 3));
    }
            
    FLD_WR_DRF_DEF(_PVIDEO, _CONTROL_Y, _LINE, _HALF);
        
    if (IsNV4_NV04(pHalHwInfo->pMcHalInfo) && 
        (pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_NTSC ||
         pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_PAL))
    {
        // NV4 HW bug, shift position on TV
        pVidFromMemHalObj->Buffer[buffNum].VideoStart += NV4_TV_DAC_SHIFT;
    }

    REG_WR32(NV_PVIDEO_WINDOW_START, pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    REG_WR32(NV_PVIDEO_WINDOW_SIZE, pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_STEP_SIZE, pVidFromMemHalObj->Buffer[buffNum].VideoScale);
 
    class63ColorKey_NV04(pHalHwInfo, pVidFromMemHalObj, buffNum);
        
    // Mark buffer 1 as NOTIFY_PENDING.
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    if (buffNum == 0)
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
    else
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);

    REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
}

//---------------------------------------------------------------------------
//
//  Exception handling routines.
//
//---------------------------------------------------------------------------

//
// class63 exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
RM_STATUS class63GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PHALHWINFO pHalHwInfo;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoService handler.
    //    
    pVideoGetEventStatusArg->events = 0;

    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoGetEventStatusArg->intrStatus = intr0;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {

        // Reset the pending bit right away. This way, if another buffer completion becomes pending
        // while we are servicing the current buffer completion, it will not be lost. 
        // This is the best we can do to close this window.
        // We will return intr_notify_pending state so if another interrupt happened, 
        // we will be called again.
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 0 pending if notify has been setup.
                if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 0);
            }
        }
        
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 1 pending if notify has been setup.
                if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 1);
            }
        }
    }

    return RM_OK;
}

//
// class63 exception handler
//
// This interface relies on values setup by the nvHalVideoGetEventStatus
// interface (i.e. the PVIDEO_INTR_0 register contents).  We go to the
// hardware to get the rest of it.
//
RM_STATUS class63ServiceEvent_NV04(PVIDEOSERVICEEVENTARG_000 pVideoServiceArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoServiceArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoServiceArg->pHalObjInfo;

    //
    // The pending interrupt register value was saved off by the
    // GetEventStatus entry point.
    //
    intr0 = pVideoServiceArg->intrStatus;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        //
        // Buffer 0.
        //
        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
                if (pVideoServiceArg->events & (1 << 0))
                    pVidFromMemHalObj->Buffer[0].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 1 is ready. Kick it off.
                    class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1 /* buffNum */);
                }
                else
                {
                    // Software buffer 1 is not ready.
                    // Program OE and SU so that the hardware flips to 0 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (0 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 0 itself is busy again. Load the new values.
                    if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
                    {
                        class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0 /* buffNum */);
                    } // buffer 0 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 0 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("0R");
#endif
                    } // redisplay buffer 0 values
                } // Buffer 1 is not busy    
                        
                // Return the current interrupt pending state.
                // intr0 = REG_RD32(NV_PVIDEO_INTR_0);
                // return(intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING));
            } // Hardware says buffer 0 completed.
        }

        //
        // Buffer 1.
        //
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {
                if (pVideoServiceArg->events & (1 << 1))
                    pVidFromMemHalObj->Buffer[1].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 0 is ready. Kick it off.
                    class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0 /* buffNum */);
                }
                else
                {
                    // Software buffer 0 is not ready.
                    // Program OE and SU so that the hardware flips to 1 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (1 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 1 itself is busy again. Load the new values.
                    if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_BUSY)
                    {
                        class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1 /* buffNum */);
                    } // Buffer 1 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 1 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("1R");
#endif
                    } // Redisplay buffer 1 values
                } // Buffer 0 is not busy    
            } // Hardware says buffer 1 completed.
        }

#ifdef DEBUG_TIMING
        // Grab the current states again and print it.
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);

        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif
    }  // Notify was pending
    
    // Return the current interrupt pending state.
    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoServiceArg->intrStatus = intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c04fnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: C04FNV04.C                                                        *
*   This module implements the nv4-specific portions of the                 *
*   NV_EXTERNAL_PARALLEL_BUS class (methods, etc.).                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04FMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV04
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data, data32;
    S032 saddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
            pPBusHalObj->Write.Data = data;

            //
            // XXX allow for negative addresses to be passed in so we
            // can access the MPC (temporary)
            //
            saddr = (S032)(pPBusHalObj->Write.Address) + 0x200;

            //
            // PME_EXTERNAL_BUS is an 8bit bus, so we must break
            // up larger transfers
            //
            switch (pPBusHalObj->Write.DataSize)
            {
                // 8bit access
                case 0x0001:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data);
                    break;

                    // 16bit access
                case 0x0002:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    break;

                    // 24bit access
                case 0x0003:
                    /* ???
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address)+0x200, pBus->Write.Data & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address+1)+0x200, (pBus->Write.Data >> 8) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address+2)+0x200, (pBus->Write.Data >> 16) & 0xFF);
                       */
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+2), (pPBusHalObj->Write.Data >> 16) & 0xFF);
                    break;

                    // 32bit access
                case 0x0004:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+2), (pPBusHalObj->Write.Data >> 16) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+3), (pPBusHalObj->Write.Data >> 24) & 0xFF);

                    /* stuff specific to CCube
                       REG_WR32(NV_PME_EXTERNAL(0x06)+0x200, (pBus->Write.Address >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x05)+0x200, (pBus->Write.Address >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x04)+0x200, (pBus->Write.Address)       & 0xFF);
                    
                       REG_WR32(NV_PME_EXTERNAL(0x03)+0x200, (pBus->Write.Data >> 24) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x02)+0x200, (pBus->Write.Data >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x01)+0x200, (pBus->Write.Data >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x00)+0x200, (pBus->Write.Data)       & 0xFF);
                       */
                    
                    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ClassNV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY04F Write (index): ", pBus->Write.Address);
                    break;
            }
            
            //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "w");
            
            // Impose a bit of a break
            //tmrDelay(100000);         // 500ns delay    
            break;
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
            pPBusHalObj->Read.Notify = data;

            //
            // XXX allow for negative addresses to be passed in so
            // we can access the MPC (temporary)
            //
            saddr = (S032)(pPBusHalObj->Read.Address) + 0x200;

            //
            // PME_EXTERNAL_BUS is an 8bit bus, so we must break
            // up larger transfers
            //
            switch (pPBusHalObj->Read.DataSize)
            {
                // 8bit access
                case 0x0001:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 16bit access
                case 0x0002:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 24bit access
                case 0x0003:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+2));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 32bit access
                case 0x0004:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+3));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+2));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    
                    /* stuff specific to CCube
                       REG_WR32(NV_PME_EXTERNAL(0x06)+0x200, (pBus->Read.Address >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x05)+0x200, (pBus->Read.Address >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x04)+0x200, (pBus->Read.Address)       & 0xFF);
                    
                       data32 = REG_RD32(NV_PME_EXTERNAL(0x03)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x02)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x01)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x00)+0x200);
                       */

                    break;
            }

            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VMI, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    intr0 = REG_RD32(NV_PME_INTR_0);

    //
    // If there's a VMI interrupt pending, then we need
    // to let the RM know so it can post notifies.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _VMI, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VMI, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VMI, _DISABLED);

    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c65nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class65Method_NV04(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class65
// methods.
//
RM_STATUS class65Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv\nvkernel.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mp\nv20\mpnv20.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV20.C                                                          *
*   The NV20 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV20(VOID *);
RM_STATUS nvHalMpAlloc_NV20(VOID *);
RM_STATUS nvHalMpFree_NV20(VOID *);
RM_STATUS nvHalMpMethod_NV20(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV20(VOID *);
RM_STATUS nvHalMpServiceEvent_NV20(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV20(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO_NV20 pMpHalPvtInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalPvtInfo = (PMPHALINFO_NV20)pHalHwInfo->pMpHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U032 hostConfig;

#ifdef IKOS
            //
            // Don't check for VIP slave (IKOS Temporary)
            //
            return (RM_OK);
#endif

            pMpHalPvtInfo->VIPSlavePresent = 0;
            hostConfig = REG_RD32(NV_PME_HOST_CONFIG);
            if ((hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_DETECTED, _TRUE)) &&
                (hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_NOTDETECTED, _FALSE)) ) {
                pMpHalPvtInfo->VIPSlavePresent = 1;
            }

            //
            // Initialize media engine's config
            //

            REG_WR32(NV_PME_INTR_EN_0, 0);      // make sure all the media engine interrupts are disabled

            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _FIFOMAXTX, 32);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _CLOCK_SELECT, _PCI);
            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _TIMEOUT, 7);	// just in case

            //
            // Initialize media engine's various DMA engines
            //

            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);

            //
            // Clear 656_CONFIG
            //

            REG_WR32(NV_PME_656_CONFIG, 0);

            //
            // initialize FOUT_ADDR and FIN_ADDR to something on our VIP test card
            //
            // XXX need a method to set these addresses though!  (class04E has no address method)
            //
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _FIFO, 4);		// FIFO A
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _DEVICE, 0);

            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _FIFO, 5);		// FIFO B
            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _DEVICE, 0);

            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV20(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;

            pDecoderHalObj->lastWidthIn     = 0;
            pDecoderHalObj->lastWidthOut    = 0;
            pDecoderHalObj->lastHeightIn    = 0;
            pDecoderHalObj->lastHeightOut   = 0;

            pDecoderHalObj->lastImageConfig = 0xFFFFFFFF;
            //
            // To force initialization of the registers
            // this is used to indicate the first time around... 99
            // will likely never be used at a startline value since it
            // should be something like 0 - 21.
            //
            pDecoderHalObj->lastImageStartLine  = 99;     

            //
            // Clear the various DMA controls 
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);

            //
            // Initialize 656 config
            // (For now we only handle TASKA streams.)
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);

            //
            // initialize maximum line length
            //
            REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0xfffff0);
            REG_WR32(NV_PME_TASKB_LINE_LENGTH, 0xfffff0);

            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FIN_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_CURRENT, 0);

            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV20(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpFreeArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Let's be forceful and stop either read/write if any in progress.
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV20(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV20(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV20(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV20(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV20(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV20(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV20(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV20(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV20(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c64nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class64Method_NV04(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScale =
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDuDx)) |
                DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDvDy));
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScale =
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDuDx)) |
                DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDvDy));
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, pVidScalerHalObj->xStart)
                | DRF_NUM(_PVIDEO, _WINDOW_START, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mp\nv10\mpnv10.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV10.C                                                          *
*   The NV10 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV10(VOID *);
RM_STATUS nvHalMpAlloc_NV10(VOID *);
RM_STATUS nvHalMpFree_NV10(VOID *);
RM_STATUS nvHalMpMethod_NV10(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV10(VOID *);
RM_STATUS nvHalMpServiceEvent_NV10(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV10(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO_NV10 pMpHalPvtInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalPvtInfo = (PMPHALINFO_NV10)pHalHwInfo->pMpHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U032 hostConfig;

#ifdef IKOS
            //
            // Don't check for VIP slave (IKOS Temporary)
            //
            if (IsNV10orBetter_NV10(pHalHwInfo->pMcHalInfo)) {
                return (RM_OK);
            }
#endif

            pMpHalPvtInfo->VIPSlavePresent = 0;
            hostConfig = REG_RD32(NV_PME_HOST_CONFIG);
            if ((hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_DETECTED, _TRUE)) &&
                (hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_NOTDETECTED, _FALSE)) ) {
                pMpHalPvtInfo->VIPSlavePresent = 1;
            }

            //
            // Initialize media engine's config
            //

            REG_WR32(NV_PME_INTR_EN_0, 0);      // make sure all the media engine interrupts are disabled

            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _FIFOMAXTX, 32);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _CLOCK_SELECT, _PCI);
            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _TIMEOUT, 7);	// just in case

            //
            // Initialize media engine's various DMA engines
            //

            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);

            //
            // Clear 656_CONFIG
            //

            REG_WR32(NV_PME_656_CONFIG, 0);

            //
            // initialize FOUT_ADDR and FIN_ADDR to something on our VIP test card
            //
            // XXX need a method to set these addresses though!  (class04E has no address method)
            //
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _FIFO, 4);		// FIFO A
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _DEVICE, 0);

            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _FIFO, 5);		// FIFO B
            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _DEVICE, 0);

            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV10(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;

            pDecoderHalObj->lastWidthIn     = 0;
            pDecoderHalObj->lastWidthOut    = 0;
            pDecoderHalObj->lastHeightIn    = 0;
            pDecoderHalObj->lastHeightOut   = 0;

            pDecoderHalObj->lastImageConfig = 0xFFFFFFFF;
            //
            // To force initialization of the registers
            // this is used to indicate the first time around... 99
            // will likely never be used at a startline value since it
            // should be something like 0 - 21.
            //
            pDecoderHalObj->lastImageStartLine  = 99;     

            //
            // Clear the various DMA controls 
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);

            //
            // Initialize 656 config
            // (For now we only handle TASKA streams.)
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);

            //
            // initialize maximum line length
            //
            REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0xfffff0);
            REG_WR32(NV_PME_TASKB_LINE_LENGTH, 0xfffff0);

            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FIN_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_CURRENT, 0);

            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV10(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpFreeArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Let's be forceful and stop either read/write if any in progress.
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV10(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV10(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV10(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV10(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV10(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV10(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV10(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV10(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV10(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mp\nv\mpstate.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/******************************** MP Manager ********************************\
*                                                                           *
* Module: MPSTATE.C                                                         *
*   The MediaPort state is changed in this module.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <modular.h>
#include <mp.h>
#include <os.h>
#include "nvhw.h"

//
// Registry data.
//
extern char strDevNodeRM[];
char strDisableMPC[] = "DisableMPCDetect";

//
// Change MediaPort hardware state.
//
RM_STATUS stateMp
(
    PHWINFO pDev,
    U032    msg
)
{
    switch (msg)
    {
        case STATE_UPDATE:
            nvHalMpControl(pDev, MP_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalMpControl(pDev, MP_CONTROL_LOAD);
            break;
        case STATE_UNLOAD:
            nvHalMpControl(pDev, MP_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
        {
            U032 data32;

            //
            // Check if MPC Detection has been disabled.
            // It would be nice if this were made into a chip-independent
            // registry setting.
            //
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strDisableMPC, &data32) == RM_OK)
            {
                pDev->MediaPort.HalInfo.DetectEnable = 1;
            }
            else
            {
                pDev->MediaPort.HalInfo.DetectEnable = 0;
            }

            //
            // Set initial state to unused.
            //
            pDev->MediaPort.CurrentDecoder = NULL;
            pDev->MediaPort.CurrentDecompressor = NULL;
            pDev->MediaPort.CurrentParallelBusObj = NULL;
            nvHalMpControl(pDev, MP_CONTROL_INIT);
            break;
        }
        case STATE_DESTROY:
            nvHalMpControl(pDev, MP_CONTROL_DESTROY);
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mp\nv\mpobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** MP Engine Manager *****************************\
*                                                                           *
* Module: mpobj.c                                                           *
*   Media port engine objects are managed here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <mp.h>
#include <i2c.h>
#include <smp.h>
#include "nvhw.h"

//
// Forwards.
//

// NV03_EXTERNAL_VIDEO_DECODER (class04d)
static RM_STATUS mpCreateDecoderObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyDecoderObj(PHWINFO, POBJECT);

// NV03_EXTERNAL_VIDEO_DECOMPRESSOR (class04e)
static RM_STATUS mpCreateDecompressorObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyDecompressorObj(PHWINFO, POBJECT);

// NV01_EXTERNAL_PARALLEL_BUS
static RM_STATUS mpCreateParallelBusObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyParallelBusObj(PHWINFO, POBJECT);

//
// Class lock macros (MediaPort class allocations are per-device).
//
#define MPCLASSLOCK_ISSET(pdev,bit)    (pDev->MediaPort.ClassLocks & (1 << bit))
#define MPCLASSLOCK_SET(pdev,bit)      (pDev->MediaPort.ClassLocks |= (1 << bit))
#define MPCLASSLOCK_CLEAR(pdev,bit)    (pDev->MediaPort.ClassLocks &= ~(1 << bit))

//
// mpCreateObj
//
// Top-level create routine for mediaport classes.
//
RM_STATUS mpCreateObj
(
    VOID*   pDevHandle,
    PCLASSOBJECT ClassObject,
    U032    Name,
    POBJECT *Object,
    VOID*   pCreateParms
)
{
    PHWINFO         pDev = (PHWINFO) pDevHandle;
    RM_STATUS       status = RM_OK;
    PCLASS          pClass = ClassObject->Base.ThisClass;
    U032            lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateObj\r\n");

    //
    // Check allocation restrictions.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        if (MPCLASSLOCK_ISSET(pDev, lockBit))
            return (RM_ERR_ILLEGAL_OBJECT);
        MPCLASSLOCK_SET(pDev, lockBit);
    }

    //
    // Invoke class-specific create routine.    
    //
    switch (pClass->Type)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = mpCreateDecoderObj(pDev, ClassObject, Name, Object);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = mpCreateDecompressorObj(pDev, ClassObject, Name, Object);
            break;
        case NV01_EXTERNAL_PARALLEL_BUS:
            status = mpCreateParallelBusObj(pDev, ClassObject, Name, Object);
            break;
        case NV03_EXTERNAL_MONITOR_BUS:
            status = class050Create(pDev, ClassObject, Name, Object);
            break;
        case NV04_EXTERNAL_SERIAL_BUS:
            status = class051Create(pDev, ClassObject, Name, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }

    if (status != RM_OK)
    {
        if (lockBit != NO_LOCK)
            MPCLASSLOCK_CLEAR(pDev, lockBit);
        return (status);
    }

    return (RM_OK);
}

RM_STATUS mpDestroyObj
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    PHWINFO             pDev = (PHWINFO) pDevHandle;
    RM_STATUS           status = RM_OK;
    PCOMMONOBJECT       pCommonObject;
    PCLASS              pClass;
    U032                lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Clear per-device allocation lock bit if applicable.
    //
    pClass = Object->ThisClass;
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        // ASSERT(MPCLASSLOCK_ISSET(pDev, lockBit));
        MPCLASSLOCK_CLEAR(pDev, lockBit);
    }

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // And finally delete the object itself    
    //
    switch (pClass->Type)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = mpDestroyDecoderObj(pDev, Object);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = mpDestroyDecompressorObj(pDev, Object);
            break;
        case NV01_EXTERNAL_PARALLEL_BUS:
            status = mpDestroyParallelBusObj(pDev, Object);
            break;
        case NV03_EXTERNAL_MONITOR_BUS:
            status = class050Destroy(pDev, Object);
            break;
        case NV04_EXTERNAL_SERIAL_BUS:
            status = class051Destroy(pDev, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }
    return (status);
}

//----------------------------------------------------------------------
// Video decoder create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateDecoderObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEODECODEROBJECT         pDecoderObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateDecoderObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEODECODEROBJECT));
    if (status)
        return (status);
        
    pDecoderObject = (PVIDEODECODEROBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pDecoderObject;
    for (i = 0; i < sizeof (VIDEODECODEROBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, pClass->Type, &pDecoderObject->HalObject);
    if (status)
        return (status);

    //
    // Initialize the event processing order.
    // We always start with VBI and buffer number 0. 
    // So assume the last event processed was an image and the
    // last buffer processed was 1.
    //
    pDecoderObject->LastEventProcessed = EVENT_PROCESSED_IMAGE;
    pDecoderObject->LastImageBufferProcessed = 1;
    pDecoderObject->LastVbiBufferProcessed = 1;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pDecoderObject->CBase, 
                                      pDecoderObject->CBase.ChID, 
                                      pDecoderObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, pClass->Type, (VOID *)&pDecoderObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentDecoder = (VOID_PTR)pDecoderObject;

    return (status);
}

static RM_STATUS mpDestroyDecoderObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PVIDEODECODEROBJECT         pDecoderObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyDecoderObj\r\n");

    pDecoderObject = (PVIDEODECODEROBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, Object->ThisClass->Type, &pDecoderObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pDecoderObject->CBase, pDecoderObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentDecoder = NULL;

    return (osFreeMem(Object));
}


//----------------------------------------------------------------------
// Video decompressor create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateDecompressorObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEODECOMPRESSOROBJECT    pDecompressorObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateDecompressorObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEODECOMPRESSOROBJECT));
    if (status)
        return (status);
        
    pDecompressorObject = (PVIDEODECOMPRESSOROBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pDecompressorObject;
    for (i = 0; i < sizeof (VIDEODECOMPRESSOROBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, pClass->Type, &pDecompressorObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pDecompressorObject->CBase, 
                                      pDecompressorObject->CBase.ChID, 
                                      pDecompressorObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, pClass->Type, (VOID *)&pDecompressorObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentDecompressor = (VOID_PTR)pDecompressorObject;

    return (status);
}

static RM_STATUS mpDestroyDecompressorObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PVIDEODECOMPRESSOROBJECT    pDecompressorObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyDecompressorObj\r\n");

    pDecompressorObject = (PVIDEODECOMPRESSOROBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, Object->ThisClass->Type, &pDecompressorObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pDecompressorObject->CBase, pDecompressorObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentDecompressor = NULL;

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Parallel bus create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateParallelBusObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PPARALLELBUSOBJECT          pParallelBusObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateParallelBusObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (PARALLELBUSOBJECT));
    if (status)
        return (status);
        
    pParallelBusObject = (PPARALLELBUSOBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pParallelBusObject;
    for (i = 0; i < sizeof (PARALLELBUSOBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, pClass->Type, &pParallelBusObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pParallelBusObject->CBase, 
                                      pParallelBusObject->CBase.ChID, 
                                      pParallelBusObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, pClass->Type, (VOID *)&pParallelBusObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentParallelBusObj = (VOID_PTR)pParallelBusObject;

    return (status);
}

static RM_STATUS mpDestroyParallelBusObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PPARALLELBUSOBJECT          pParallelBusObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyParallelBusObj\r\n");

    pParallelBusObject = (PPARALLELBUSOBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, Object->ThisClass->Type, &pParallelBusObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pParallelBusObject->CBase, pParallelBusObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentParallelBusObj = NULL;


    return (osFreeMem(Object));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv10\nv10kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv20\nv20kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv4\nv04kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\tmr\nv\tmrinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** Time Manager *****************************\
*                                                                           *
* Module: TMRINIT.C                                                         *
*   Time state is initialized here.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <state.h>
#include <dma.h>
#include <tmr.h>
#include <os.h>
#include "nvhw.h"


//
//  Initialize timer.
//
RM_STATUS  initTmr
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    S032      num;
    S032      den;
    U032      i;

    //
    // Save previous values.
    //
    pDev->Timer.tmrSave[0] = REG_RD32(NV_PTIMER_NUMERATOR);
    pDev->Timer.tmrSave[1] = REG_RD32(NV_PTIMER_DENOMINATOR);
    //
    // Init timer callback list.
    //
    pDev->DBtmrCallbackList = NULL;
    status = osAllocMem((VOID **)&pDev->DBtmrCallbackTable, sizeof(TIMERCALLBACK) * NUM_TIMERCALLBACKS);
    if (status)
        return (status);
    pDev->DBtmrCallbackFreeList = pDev->DBtmrCallbackTable;
    for (i = 0; i < NUM_TIMERCALLBACKS - 1; i++)
    {
        pDev->DBtmrCallbackFreeList[i].Next = &(pDev->DBtmrCallbackFreeList[i + 1]);
    }
    pDev->DBtmrCallbackFreeList[i].Next = NULL;
    //
    // Calc numerator and denomenator from DAC NVCLK parameters.
    // From Curtis.
    //
    // num = pDev->Dac.MClk; // The manual says MClk. That is wrong.
    num = pDev->Dac.HalInfo.NVClk;
    den = 31250000;
    while ((num % 2 == 0) && (den % 2 == 0))
    {
        num /= 2;
        den /= 2;
    }
    while ((num % 5 == 0) && (den % 5 == 0))
    {
        num /= 5;
        den /= 5;
    }
    while ((num > 2 * DRF_MASK(NV_PTIMER_NUMERATOR_VALUE))
        || (den > 2 * DRF_MASK(NV_PTIMER_DENOMINATOR_VALUE)))
    {
        num /= 2;
        den /= 2;
    }
    num = (num + 1) / 2;
    den = (den + 1) / 2;
    pDev->Timer.Numerator   = num;
    pDev->Timer.Denominator = den;
    
    REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
    REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);
    REG_WR32(NV_PTIMER_ALARM_0,     0xFFFFFFFF);
#ifdef RM_STATS
    //
    // Init performance timer to come in every second.
    //
    pDev->Statistics.UpdateLo = 1000000000;
    pDev->Statistics.UpdateHi = 0;
    
    //
    // Zero exception and service counts.
    //
    pDev->Statistics.FifoExceptionCount        = 0;
    pDev->Statistics.FramebufferExceptionCount = 0;
    pDev->Statistics.GraphicsExceptionCount    = 0;
    pDev->Statistics.TotalExceptionCount       = 0;
    pDev->Fifo.ServiceCount                    = 0;
    pDev->Framebuffer.ServiceCount             = 0;
    pDev->Graphics.ServiceCount                = 0;
    pDev->Chip.ServiceCount                    = 0;
    pDev->MediaPort.ServiceCount               = 0;
    pDev->Video.ServiceCount                   = 0;
#endif
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nvkernel.lib:           \
        $(RMLIBDIR)\btree.lib       \
        $(RMLIBDIR)\class.lib       \
        $(RMLIBDIR)\dac.lib         \
        $(RMLIBDIR)\devinit.lib     \
        $(RMLIBDIR)\dma.lib         \
        $(RMLIBDIR)\fb.lib          \
        $(RMLIBDIR)\fifo.lib        \
        $(RMLIBDIR)\gr.lib          \
        $(RMLIBDIR)\hal.lib         \
        $(RMLIBDIR)\heap.lib        \
        $(RMLIBDIR)\mc.lib          \
        $(RMLIBDIR)\modular.lib     \
        $(RMLIBDIR)\mp.lib          \
        $(RMLIBDIR)\state.lib       \
        $(RMLIBDIR)\tmr.lib         \
        $(RMLIBDIR)\vblank.lib      \
        $(RMLIBDIR)\vid.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv10\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nv10kern.lib:           \
        $(RMLIBDIR)\dacnv10.lib     \
        $(RMLIBDIR)\dmanv10.lib     \
        $(RMLIBDIR)\fbnv10.lib      \
        $(RMLIBDIR)\fifonv10.lib    \
        $(RMLIBDIR)\grnv10.lib      \
        $(RMLIBDIR)\halnv10.lib     \
        $(RMLIBDIR)\mcnv10.lib      \
        $(RMLIBDIR)\modnv10.lib     \
        $(RMLIBDIR)\mpnv10.lib      \
        $(RMLIBDIR)\vidnv10.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mp\nv4\mpnv04.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV04.C                                                          *
*   The NV04 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include <i2c.h>
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV04(VOID *);
RM_STATUS nvHalMpAlloc_NV04(VOID *);
RM_STATUS nvHalMpFree_NV04(VOID *);
RM_STATUS nvHalMpMethod_NV04(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV04(VOID *);
RM_STATUS nvHalMpServiceEvent_NV04(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV04(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO pMpHalInfo;
    PDACHALINFO pDacHalInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U008 daddr, subaddr, data;
            U008 lock;

            pMpHalInfo->MPCPresent = 0;
            pMpHalInfo->MPCDeviceAddr = 0;

#ifdef IKOS
            return RM_OK;
#endif

            //
            // Allow registry setting to bypass MPC detection.
            //
            if (pMpHalInfo->DetectEnable == 0)
                return RM_OK;

            //
            // Attempt to detect the presence of the external MP ASIC.  If it is not present, don't
            // enable decompressor functionality or attempt to initialize the mediaport
            // registers.  If there's no external clock, we could lock the system.

            // Unlock CRTC extended regs
            CRTC_READ(NV_CIO_SR_LOCK_INDEX, lock);
            CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);
    
            // wayne's MPC detection algorithm
            // (for now only go up to chip addr 0x25, eventhough 0x26/0x27
            // should also be reserved for our use)
            for (daddr = 0x24; daddr <= 0x25; daddr++)
            {
                subaddr = 0x1;
                data = 0x8F;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
        
                subaddr = 0x0;
                data = 0x80;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
        
                if (HALRMI2CREAD(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
                if ((data & 0xc0) != 0xc0)
                    continue;

                subaddr = 0x0;
                data = 0x40;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;

                if (HALRMI2CREAD(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
                if ((data & 0xc0) == 0x0)
                {
                    // Found the MediaPort (save addr for use in class51)
                    pMpHalInfo->MPCPresent = 1;
                    pMpHalInfo->MPCDeviceAddr = daddr;
                    break;
                }
            }
    
            //
            // Initialize the mp registers to a known state.  Only do this
            // if we know someone is out there.
            //
            if (pMpHalInfo->MPCPresent)
            {    
    
                //
                // Reset the MPC.
                //
                // MPC Enabled, Video Decoder Disable, TV Encoder Disable
                // Toggle the MPC Reset and DVD Reset low then high
                //
        
                //
                // Internal MPC I2C
                //
                subaddr = 1;    // index
                data = 0xFF;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
                subaddr = 0;    // data
                data = 0;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
                subaddr = 0;    // data
                data = 0x07;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
    
                //
                // Init the mediaport registers
                //
                // Initialize BUS_MODE to be disabled.  It will be initialized by either 
                // class04d (external decoder) or class04e (external decompressor) - JSUN
                //
                REG_WR32(NV_PME_CONFIG_0, DRF_DEF( _PME, _CONFIG_0, _BUS_MODE, _VMI));
                REG_WR32(NV_PME_VID_ME_STATE, 0);
                REG_WR32(NV_PME_VID_SU_STATE, 0);
                REG_WR32(NV_PME_VID_RM_STATE, 0);
                REG_WR32(NV_PME_AUD_ME_STATE, 0);
                REG_WR32(NV_PME_AUD_SU_STATE, 0);
                REG_WR32(NV_PME_AUD_RM_STATE, 0);
                REG_WR32(NV_PME_VBI_ME_STATE, 0);
                REG_WR32(NV_PME_VBI_SU_STATE, 0);
                REG_WR32(NV_PME_VBI_RM_STATE, 0);
                REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
                REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
                REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
        
                REG_WR_DRF_DEF(_PME, _DEBUG_0, _DET_FIELD_SWITCH, _DISABLED);
                REG_WR32(NV_PME_DEBUG_1, DRF_DEF(_PME, _DEBUG_1, _SEL, _VIPCLK)
                         | DRF_DEF(_PME, _DEBUG_1, _VIPCLK_SEL, _DEFAULT)
                         | DRF_DEF(_PME, _DEBUG_1, _MCLK_SEL, _DEFAULT));
                                       
                //
                // enable MPC display data delivery
                //
                REG_WR32(NV_PME_EXTERNAL(2), 2);
    	
            }                               
            else
            {
                //
                // Default legacy state.  This is currently set manually when the old class66.c
                // is initialized and started.  When that class is retired and replaced with the
                // newer ExternalDecoder class, put this back in.
                //
                //REG_WR32(NV_PME_CONFIG_0, DRF_DEF( _PME, _CONFIG_0, _BUS_MODE, _CCIR656));
            }
            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV04(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo =  pMpAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;
            PMPHALINFO_NV04 pMpHalPvtInfo;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;
            pMpHalPvtInfo = (PMPHALINFO_NV04)pMpAllocArg->pHalHwInfo->pMpHalPvtInfo;
#ifdef COMMENT
            //
            // Disable the MPC if there are no decompressor objects
            // using the MPC.
            //
            if ( pMpHalInfo->CurrentDecompressor == NULL ) {
                if ( pMpHalInfo->MPCPresent ) {
                    subaddr = 1;
                    data = 0x0f;
                    HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
                    subaddr = 0;
                    data = 0x08;
                    HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
                }
            }
#endif
            //
            // Make sure to clear the h/w state
            //
            REG_WR32(NV_PME_VBI_ME_STATE, 0);
            REG_WR32(NV_PME_VBI_SU_STATE, 0);
            REG_WR32(NV_PME_VBI_RM_STATE, 0);
            REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
            REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
            REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
        {
            PMPHALINFO_NV04 pMpHalPvtInfo;

            pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

            //
            // MPC initialization
            //
            REG_WR32(NV_PME_EXTERNAL(3), 0x60);		// set wait states to 3
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_VID_ME_STATE, 0);
            REG_WR32(NV_PME_VID_SU_STATE, 0);
            REG_WR32(NV_PME_VID_RM_STATE, 0);
            REG_WR32(NV_PME_VID_CURRENT, 0);
    
            //
            // we also need to make sure Audio is not enabled (NV4 only)
            //
            if (IsNV4_NV04(pMpAllocArg->pHalHwInfo->pMcHalInfo))
            {
                REG_WR32(NV_PME_AUD_SU_STATE, 0);
                REG_WR32(NV_PME_AUD_ME_STATE, 0);
            }

            pMpHalPvtInfo->CurrentDecompressor = pMpAllocArg->pHalObjInfo;
            break;
        }
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV04(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PMPHALINFO_NV04 pMpHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pMpHalPvtInfo = (PMPHALINFO_NV04)pMpFreeArg->pHalHwInfo->pMpHalPvtInfo;
    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
        {
#ifdef DISABLE_FOR_NOW
            //
            // disable the MPC 
            //
            subaddr = 1;
            data = 0x0f;
            HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalPvtInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
            subaddr = 0;
            data = 0x08;
            HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalPvtInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
#endif
            pMpHalPvtInfo = 0;
            break;
        }
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV04(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV04(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV04(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV04(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV04(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV04(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV04(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV04(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV04(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv20\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nv20kern.lib:           \
        $(RMLIBDIR)\dacnv20.lib     \
        $(RMLIBDIR)\dmanv20.lib     \
        $(RMLIBDIR)\fbnv20.lib      \
        $(RMLIBDIR)\fifonv20.lib    \
        $(RMLIBDIR)\grnv20.lib      \
        $(RMLIBDIR)\halnv20.lib     \
        $(RMLIBDIR)\mcnv20.lib      \
        $(RMLIBDIR)\modnv20.lib     \
        $(RMLIBDIR)\mpnv20.lib      \
        $(RMLIBDIR)\vidnv20.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\nvkernel\nv4\makefile.inc ===
RMLIBDIR=$(NV_BASE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386

$(RMLIBDIR)\nv04kern.lib:           \
        $(RMLIBDIR)\dacnv04.lib     \
        $(RMLIBDIR)\dmanv04.lib     \
        $(RMLIBDIR)\fbnv04.lib      \
        $(RMLIBDIR)\fifonv04.lib    \
        $(RMLIBDIR)\grnv04.lib      \
        $(RMLIBDIR)\halnv04.lib     \
        $(RMLIBDIR)\mcnv04.lib      \
        $(RMLIBDIR)\modnv04.lib     \
        $(RMLIBDIR)\mpnv04.lib      \
        $(RMLIBDIR)\vidnv04.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\tmr\nv\time.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** Time Manager *****************************\
*                                                                           *
* Module: TIME.C                                                            *
*   Time objects are managed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <state.h>
#include <dma.h>
#include <tmr.h>
#include <os.h>
#include <nv32.h>
#include <smp.h>
#include "nvhw.h"

//
// Object creation/deletion.
//
RM_STATUS tmrCreateTimer
(
    VOID*      pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *TimeObject,
    VOID*        pCreateParms
)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS status;
    
    RM_ASSERT(ClassObject->Base.Name == NV1_TIMER);

    status = osAllocMem((VOID **)TimeObject, sizeof(TIMEROBJECT));
    if (status)
        return (status);

//    ((PTIMEROBJECT)*TimeObject)->NotifyXlate  = NULL;
//    ((PTIMEROBJECT)*TimeObject)->NotifyAction = 0;
    ((PTIMEROBJECT)*TimeObject)->State        = BUFFER_IDLE;
    ((PTIMEROBJECT)*TimeObject)->AlarmLo      = 0;
    ((PTIMEROBJECT)*TimeObject)->AlarmHi      = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*TimeObject, ClassObject, UserName);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PTIMEROBJECT)*TimeObject)->CBase, 
                                      ((PTIMEROBJECT)*TimeObject)->CBase.ChID, 
                                      ((PTIMEROBJECT)*TimeObject)->CInstance);
    if (status != RM_OK)
        osFreeMem(*TimeObject);

    return (RM_OK);
}

RM_STATUS tmrDeleteContextTime
(
    POBJECT TimeObject
)
{
    return (osFreeMem(TimeObject));
}

RM_STATUS tmrDeleteTimer
(
	VOID*   pDevHandle,
    POBJECT TimeObject
)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;

    //
    // Just in case...
    //
    if (TimeObject == NULL)
        return (RM_OK);

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, TimeObject);
	osExitCriticalCode(pDev);

    //
    // Cancel any outstanding callbacks before deleting object.
    //
    tmrCancelCallback(pDev, TimeObject);
    return (osFreeMem(TimeObject));
}

//
// Methods.
//
RM_STATUS mthdSetTime
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    U032      TimeCheck;
    U032      TimeLo;
    U032      TimeHi;
    
    status = RM_OK;
    if (Offset == Method->Low)
    {
        ((PTIMEOBJECT)Object)->TimeLo = Data;
    }
    else
    {
        //
        // Treat time values less than 4.29 sec as relative.
        //
        if (!Data)
        {
            do
            {
                TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
                TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
                TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
            } while (TimeCheck != TimeHi);
            ((PTIMEOBJECT)Object)->TimeLo += TimeLo;
            //
            // Handle carry.
            //
            if (((PTIMEOBJECT)Object)->TimeLo < TimeLo)
                Data = 1;
            Data += TimeHi;    
        }
        ((PTIMEOBJECT)Object)->TimeHi = Data;
        //
        // Reflect new time to all attached objects.
        //
        if (((PTIMEOBJECT)Object)->TimeProc)
            status = ((PTIMEOBJECT)Object)->TimeProc(pDev, ((PTIMEOBJECT)Object)->TimeChange);
    }
    return (status);
}

RM_STATUS mthdSetAlarmNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;

    //
    // Check for busy buffer.
    //
    if (((PTIMEROBJECT)Object)->State == BUFFER_BUSY)
    {
        osError(Object, Offset, Data, RM_ERROR);
        return (RM_ERR_DMA_IN_USE);
    }

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &((Object)->NotifyXlate));
    if (status)
    {
        (Object)->NotifyXlate = NULL;
        return (status);
    }

    //
    // Make sure the context dma is large enough (2 notifiers)
    //    
    status = dmaValidateXlate(Object->NotifyXlate, 0, (2 * 0x0010));
    if (status)
    {
        (Object)->NotifyXlate = NULL;
        return (status);
    }

    return (status);
}

RM_STATUS mthdSetAlarmNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS     status;

    //
    // Check for busy buffer.
    //
    if (((PTIMEROBJECT)Object)->State == BUFFER_BUSY)
    {
        osError(Object, Offset, Data, RM_ERROR);
        return (RM_ERR_DMA_IN_USE);
    }
    (Object)->NotifyAction = Data;
    //
    // Validate notification parameters.
    //    
    status = dmaValidateXlate((Object)->NotifyXlate, 0, 0x000F);
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(((PTIMEROBJECT)Object)->NotifyXlate, NULL);
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	*/
    //
    // Schedule the alarm.
    //
    ((PTIMEROBJECT)Object)->State = BUFFER_BUSY;
    return (tmrScheduleCallbackAbs(pDev,
                                   tmrAlarmNotify,
                                   Object,
                                   ((PTIMEROBJECT)Object)->AlarmHi,
                                   ((PTIMEROBJECT)Object)->AlarmLo));
}

RM_STATUS mthdSetAlarmTime
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    TimeCheck;
    U032    CurrentTimeHi;

    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if (Offset == Method->Low) {
        // set AlarmHigh, in case AlarmLo is the only method sent
        ((PTIMEROBJECT)Object)->AlarmLo = Data;
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi;
    } else
        ((PTIMEROBJECT)Object)->AlarmHi = Data;

    return RM_OK;
}

RM_STATUS mthdSetAlarmTimeRelative
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    TimeCheck;
    U032    CurrentTimeLo;
    U032    CurrentTimeHi;

    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if (Offset == Method->Low) {
        // set AlarmHigh, in case AlarmLo is the only method sent
        ((PTIMEROBJECT)Object)->AlarmLo = CurrentTimeLo + Data;
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi;

         // if AlarmLo rolled over, increment AlarmHi
         if (((PTIMEROBJECT)Object)->AlarmLo < CurrentTimeLo)
            ((PTIMEROBJECT)Object)->AlarmHi++;
    } else
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi + Data;

    return RM_OK;
}

//
// Alarm callback.
//
RM_STATUS tmrAlarmNotify
(
	PHWINFO pDev,
    POBJECT Object
)
{
    notifyFillNotifierArray(pDev, (Object)->NotifyXlate, 0, 0, RM_OK,
                            NV004_NOTIFIERS_SET_ALARM_NOTIFY);

    if ((Object)->NotifyAction)
    {
        //
        // Do any OS specified action related to this notification.
        //
        osNotifyEvent(pDev, Object, 
                      1,	  // NV004_NOTIFIERS_SET_ALARM_NOTIFY
                      0, 
                      1, 
                      RM_OK, 
                      (Object)->NotifyAction);
    }

    ((PTIMEROBJECT)Object)->State = BUFFER_IDLE;

    return (RM_OK);
}

RM_STATUS tmrStopTransfer
(
	PHWINFO pDev,
	POBJECT Object, 
	PMETHOD Method, 
	U032    Offset,
	V032	Data
)
{

	return (RM_OK);

}

//
// NV_PTIMER_TIME_0 rolls over approx every 4 secs. For delays
// less than 1/4 of that time just compare against TIME_0
//
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

//
// Timer related functions.
//
RM_STATUS tmrDelay
(
    PHWINFO pDev,
    U032 nsec
)
{
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    U032 IsPllSlowed = 0;  // some compilers think its uninitialized otherwise
    static U032 TimeStart;
    //
    // Check to see if NVCLK is currently being dynamically slowed
    // If so, temporarily disable so we can get a true time delay
    //
    // KJK: I wonder if this should be halified?
    //
    if (IsNV11(pDev))
    {
        IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);
    }

    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
	TimeStart = REG_RD32(NV_PTIMER_TIME_0);
	while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
	    ;

    //
    // Restore PLL slowdown setting
    //
    if (IsNV11(pDev))
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

	return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);
    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
	    ;
#if 0
    //
    // There's a potential hang event (or extremely long delay) that can
    // occur here under special circumstances.
    //
    while (TimeLo > (volatile U032)REG_RD32(NV_PTIMER_TIME_0));
#else
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
		       ;
#endif

    //
    // Restore PLL slowdown setting
    //
    if (IsNV11(pDev))
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

    return (RM_OK);
}
RM_STATUS tmrGetCurrentTime
(
	PHWINFO pDev,
    U032 *TimeHi,
    U032 *TimeLo
)
{
    U032 TimeCheck;
    
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        *TimeLo   = REG_RD32(NV_PTIMER_TIME_0);
        *TimeHi   = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != *TimeHi);
    return (RM_OK);
}

RM_STATUS tmrScheduleCallbackRel
(
	PHWINFO pDev,
    TIMEPROC Proc,
    POBJECT  Object,
    U032     RelTimeHi,
    U032     RelTimeLo
)
{
    U032 TimeCheck;
    U032 AbsTimeHi;
    U032 AbsTimeLo;
    
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        AbsTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        AbsTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != AbsTimeHi);

    AbsTimeLo += RelTimeLo;
    if (AbsTimeLo < RelTimeLo)
        AbsTimeHi++;
    AbsTimeHi += RelTimeHi;

    return (tmrScheduleCallbackAbs(pDev, Proc, Object, AbsTimeHi, AbsTimeLo));
}

RM_STATUS tmrScheduleCallbackAbs
(
	PHWINFO  pDev,
    TIMEPROC Proc,
    POBJECT  Object,
    U032     TimeHi,
    U032     TimeLo
)
{
    U032           TimeCheck;
    U032           CurrentTimeLo;
    U032           CurrentTimeHi;
    PTIMERCALLBACK tmrInsert;
    PTIMERCALLBACK tmrScan;
    
    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if ((TimeHi <  CurrentTimeHi)
    || ((TimeHi == CurrentTimeHi) && (TimeLo <= CurrentTimeLo)))
    {
        //
        // Call immediately if time passed.
        //
        Proc(pDev, Object);
    }
    else
    {
        //
        // Schedule callback at appropriate time.
        //
        tmrInsert = pDev->DBtmrCallbackFreeList;
        if (tmrInsert == NULL)
        {
            //
            // Uh-ho.  Out of callback headers.  Call the proc anyway.
            //
            Proc(pDev, Object);
            return (RM_ERR_OUT_OF_TIMER_CALLBACKS);
        }
        pDev->DBtmrCallbackFreeList = pDev->DBtmrCallbackFreeList->Next;
        tmrInsert->Callback = Proc;
        tmrInsert->Object   = Object;
        tmrInsert->TimeLo   = TimeLo;
        tmrInsert->TimeHi   = TimeHi;
        tmrInsert->Next     = NULL;
        if (pDev->DBtmrCallbackList == NULL)
        {
            //
            // Insert this immediatelly.
            //
            pDev->DBtmrCallbackList = tmrInsert;
            REG_WR32(NV_PTIMER_ALARM_0, TimeLo);
        }
        else
        {
            //
            // Scan looking for insert place.
            //
            if ((TimeHi <  pDev->DBtmrCallbackList->TimeHi)
            || ((TimeHi == pDev->DBtmrCallbackList->TimeHi) && (TimeLo <= pDev->DBtmrCallbackList->TimeLo)))
            {
                tmrInsert->Next = pDev->DBtmrCallbackList;
                pDev->DBtmrCallbackList = tmrInsert;
                REG_WR32(NV_PTIMER_ALARM_0, TimeLo);
            }
            else
            {
                tmrScan = pDev->DBtmrCallbackList;
                while (tmrScan->Next)
                {
                    if ((TimeHi <  tmrScan->Next->TimeHi)
                    || ((TimeHi == tmrScan->Next->TimeHi) && (TimeLo <= tmrScan->Next->TimeLo)))
                    {
                        tmrInsert->Next = tmrScan->Next;
                        tmrScan->Next   = tmrInsert;
                        return (RM_OK);
                    }
                    tmrScan = tmrScan->Next;
                }
                tmrScan->Next = tmrInsert;
            }
        }
    }

    //
    // Call service routine to catch any timing window.
    //
    tmrService(pDev);
    return (RM_OK);
}

RM_STATUS tmrCancelCallback
(
	PHWINFO  pDev,
    POBJECT  Object
)
{
    PTIMERCALLBACK tmrDelete;
    PTIMERCALLBACK tmrScan;
    
    if (pDev->DBtmrCallbackList)
    {
        while (pDev->DBtmrCallbackList->Object == Object)
        {
            //
            // Pull from head of list.
            //
            tmrDelete           = pDev->DBtmrCallbackList;
            pDev->DBtmrCallbackList     = pDev->DBtmrCallbackList->Next;
            tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
            pDev->DBtmrCallbackFreeList = tmrDelete;
            if (pDev->DBtmrCallbackList)
                REG_WR32(NV_PTIMER_ALARM_0, pDev->DBtmrCallbackList->TimeLo);
            else
                return (RM_OK);
        }
        tmrScan = pDev->DBtmrCallbackList;
        while (tmrScan->Next)
        {
            //
            // Scan list looking for matchs.
            //
            if (tmrScan->Next->Object == Object)
            {
                tmrDelete           = tmrScan->Next;
                tmrScan->Next       = tmrScan->Next->Next;
                tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
                pDev->DBtmrCallbackFreeList = tmrDelete;
            }
            else
            {
                tmrScan = tmrScan->Next;
            }
        }
    }
    //
    // Call service routine to catch any timing window.
    //
    tmrService(pDev);
    return (RM_OK);
}

#ifdef RM_STATS
RM_STATUS tmrStatTimer
(
    PHWINFO pDev,
    POBJECT dummy
)
{
    //
    // Move current service counts to exception counts .
    //
    pDev->Statistics.FifoExceptionCount        = pDev->Fifo.ServiceCount;
    pDev->Statistics.FramebufferExceptionCount = pDev->Framebuffer.ServiceCount;
    pDev->Statistics.GraphicsExceptionCount    = pDev->Graphics.ServiceCount;
    pDev->Statistics.TimerExceptionCount       = pDev->Timer.ServiceCount;
    pDev->Statistics.TotalExceptionCount       = pDev->Chip.ServiceCount;
    pDev->Statistics.ExecTimeLo                = pDev->Chip.ServiceTimeLo;
    pDev->Statistics.ExecTimeHi                = pDev->Chip.ServiceTimeHi;
    pDev->Statistics.IntTimeLo                 = pDev->Chip.ExceptionTimeLo;
    pDev->Statistics.IntTimeHi                 = pDev->Chip.ExceptionTimeHi;
    //
    // Zero service counts.
    //
    pDev->Fifo.ServiceCount        = 0;
    pDev->Framebuffer.ServiceCount = 0;
    pDev->Graphics.ServiceCount    = 0;
    pDev->Timer.ServiceCount       = 0;
    pDev->Video.ServiceCount       = 0;
    pDev->MediaPort.ServiceCount   = 0;
    pDev->Chip.ServiceCount        = 0;
    pDev->Chip.ServiceTimeLo       = 0;
    pDev->Chip.ServiceTimeHi       = 0;
    pDev->Chip.ExceptionTimeLo     = 0;
    pDev->Chip.ExceptionTimeHi     = 0;
    //
    // Schedule next interval.
    //
    tmrScheduleCallbackRel(pDev,
                           tmrStatTimer,
                           (POBJECT)0x69,
                           pDev->Statistics.UpdateHi,
                           pDev->Statistics.UpdateLo);
    return (RM_OK);
}
#endif

//
// Timer alarm service.
//
V032 tmrService
(
    PHWINFO pDev
)
{
    U032           TimeCheck;
    U032           CurrentTimeLo;
    U032           CurrentTimeHi;
    PTIMERCALLBACK tmrDelete;
    
    REG_WR_DRF_DEF(_PTIMER, _INTR_0, _ALARM, _RESET);
    //
    // Call all callbacks that have expired.
    //
    if (pDev->DBtmrCallbackList)
    {
        do
        {
            TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
            CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
            CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
        } while (TimeCheck != CurrentTimeHi);

        //
        // Check for expired time.
        //
        while ((pDev->DBtmrCallbackList->TimeHi <  CurrentTimeHi)
           || ((pDev->DBtmrCallbackList->TimeHi == CurrentTimeHi) && (pDev->DBtmrCallbackList->TimeLo <= CurrentTimeLo)))
        {
            //
            // Pull from head of list.
            //
            tmrDelete           = pDev->DBtmrCallbackList;
            pDev->DBtmrCallbackList     = pDev->DBtmrCallbackList->Next;
            tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
            pDev->DBtmrCallbackFreeList = tmrDelete;
            //
            // Call callback.  This could insert a new callback into the list.
            //
            tmrDelete->Callback(pDev, tmrDelete->Object);
            if (!pDev->DBtmrCallbackList)
                break;
            REG_WR32(NV_PTIMER_ALARM_0, pDev->DBtmrCallbackList->TimeLo);
            do
            {
                TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
                CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
                CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
            } while (TimeCheck != CurrentTimeHi);
        }
    }    
    return (REG_RD32(NV_PTIMER_INTR_0));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\state\nv\state.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
 
/***************************** HW State Rotuines ***************************\
*                                                                           *
* Module: STATE.C                                                           *
*       Hardware State is managed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vga.h>
#include <os.h>
#include "nvhw.h"
#include "nvcm.h"
#include "nvcmrsvd.h"
#include "dac.h"
#include "edid.h"
#include "mvision.h"

// this is defined in nvarch.h, but I'm not sure its ok to include that here 
// on all platforms
#ifndef RM_SUCCESS
#define RM_SUCCESS(status)  ((status) == RM_OK)
#endif

#define IsAGPCapable(pdev)  (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)

//
// Master state structure.
//
// HWINFO  nvInfo;
//
// State functions. Notice that LOAD/UNLOAD are treated as a pair.
// When an UNLOAD request arrives, the semaphore won't be released
// until a matching LOAD arrives.
//
RM_STATUS stateNv
(
    PHWINFO pDev, // Pointer to an nv device
    U032    msg
)
{
    RM_STATUS status;
//  U032      SemaState;

    status = RM_OK;
    switch (msg)
    {
        case STATE_INIT:
            if (!status) status = stateMc(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);  // init timer before fb so we can do I2C
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateMp(pDev, msg);
            break;
        case STATE_UPDATE:
            //
            // This is an API routine.  Aquire semaphore.
            //
            //osWaitSemaphore(&SemaState);
        case STATE_LOAD:
            if (!status) status = stateMc(pDev, msg);
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateMp(pDev, msg);
            if (msg != STATE_INIT)
            {
                //
                // Don't release semaphore for INIT, wait until
                // LOAD to give up semaphore.
                //
                //osSignalSemaphore(&SemaState);
            }
            break;
        case STATE_UNLOAD:
            //
            // This is an API routine.  Aquire semaphore.
            //
            //osWaitSemaphore(&SemaState);
        case STATE_DESTROY:
            if (!status) status = stateMp(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateMc(pDev, msg);
            if (msg == STATE_DESTROY)
            {
                //
                // Release semaphore for DESTROY, otherwise wait until
                // LOAD to give up semaphore.
                //
                //osSignalSemaphore(&SemaState);
            }
            break;
    }
    return (status);
}

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetMode_DacClassStyle
(
    PHWINFO pDev
)
{
    // Tell the driver to unload state if necessary.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    stateMc(pDev, STATE_UNLOAD);
    stateFb(pDev, STATE_UNLOAD);
    stateVideo(pDev,STATE_UNLOAD);
    stateDac(pDev,STATE_UNLOAD);
    stateTmr(pDev,STATE_UNLOAD);
    stateDma(pDev,STATE_UNLOAD);
    stateGr(pDev, STATE_UNLOAD);
    stateMp(pDev, STATE_UNLOAD);
    
    stateMp(pDev, STATE_LOAD);
    stateGr(pDev, STATE_LOAD);
    stateDma(pDev,STATE_LOAD);
    stateFb(pDev, STATE_LOAD);
    stateTmr(pDev,STATE_LOAD);
    stateDac(pDev,STATE_LOAD);
    stateVideo(pDev,STATE_LOAD);
    stateMc(pDev, STATE_LOAD);

    osDisplayModeHook(pDev, STATE_UNLOAD);

    return RM_OK;
} // end of stateSetMode

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetMode
(
    PHWINFO pDev
)
{
    // Tell the driver to unload state if necessary.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    // Unload the current state.
    stateNv(pDev, STATE_UNLOAD);

    // Load the new state.
    stateNv(pDev, STATE_LOAD);

    // tell the driver to load state.
    // We should really be calling the callback function with STATE_LOAD at this time. However,
    // the display driver has worked around this bug. So don't change it till the display
    // driver can deal with us calling it with STATE_LOAD.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    return RM_OK;
} // end of stateSetMode

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetModeMultiHead
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pDac
)
{
    // no state changes are necessary
    dacSetModeMulti(pDev, pDac);

    return RM_OK;
} // end of stateSetMode

//---------------------------------------------------------------------------
//
//  Nv device state information.
//
//---------------------------------------------------------------------------

//
// DDK Entries to get/set system parameters
//
RM_STATUS stateConfigGet(
    PHWINFO pDev,
    U032    index,
    U032*   pValue
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS rmStatus = RM_OK;
    U032 result;
   
    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to view
    //
    if ((index & 0xF00) == NV_CFG_CRTC)
    {
        U008 lock, crtc_index;
        
        //
        // Save the current CRTC index
        //
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, 0);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);

        //
        // Get the register value.
        //
        CRTC_RD((index & 0xFF), result, 0);
        
        // Relock extended regs
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 0);

        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index
    }
    else
    {
        switch (index)
        {
            //
            // These values actually look at hardware, not NvInfo.
            //
            case NV_CFG_VBLANK_STATUS:
                {
                static U032 VblankDummy;
                U032 Value, monitorType, FlatPanelIsDisabled=1, FlatPanelState;
                //
                // Microsoft requested that we twiddle the state of the returned vblank status
                // because if the monitor is off, some DX apps might lockup, waiting for the
                // vblank status to change.  Instead of changing it in the HAL, they asked
                // us to make the driver handle this case.  So if the monitor is off, we
                // twiddle the vblank status bit. Do this ONLY for Win2k.  For any other OS,
                // just behave as if the monitor is always on, since this only seems
                // to be an issue for Win2k.                   
                //

                Value = 0;                                      // Default monitor to always being on
                
#if (_WIN32_WINNT >= 0x0500)
                // Minor Hack - Call back to the miniport to get the 
                // last DPMS state of the monitor
                Value = GetCurrentDPMSState(pDev->DBmpDeviceExtension);
                Value &= 0xC0;
#endif

                // Check for Flat Panel power state
                monitorType = GETMONITORTYPE(pDev, 0);
                if (monitorType==MONITOR_TYPE_FLAT_PANEL)
                {
                    FlatPanelState= REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _DISPEN);     
                    if (FlatPanelState == NV_PRAMDAC_FP_TG_CONTROL_DISPEN_DISABLE)
                        FlatPanelIsDisabled = 1;                // Flat panel is off/disabled
                    else
                        FlatPanelIsDisabled = 0;                // Flat panel is on/active                                           
                }
                
                if ( ((monitorType!=MONITOR_TYPE_FLAT_PANEL) && (Value)) || 
                     ((monitorType==MONITOR_TYPE_FLAT_PANEL) && (FlatPanelIsDisabled)) ) // In power saving mode if either is set
                    Value = (VblankDummy ^= 1);                 // just toggle, so we are sure to get both states
                else
                {
                    Value = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                    if (Value == 0) // make sure we don't have false count. NV3 seems to have glitch during display period.
                    {
                        Value = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                    }

                    if (Value == 0)
                        Value = 1;                              // In VBLANK
                    else
                        { // raster count is nonzero

                        if (Value >= (pDev->Framebuffer.HalInfo.VertDisplayWidth-1))
                            Value = 1;                          // In VBLANK
                        else    
                            Value = 0;                          // NOT in VBLANK
                        }
                

                    } // if in power saving mode            

                result = Value;                                // Return state of vblank

                }
                
                break;

            case NV_CFG_GE_STATUS:
                result = REG_RD32(NV_PGRAPH_STATUS);
                break;

            case NV_CFG_CURRENT_SCANLINE:
                result = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                break;

            case NV_CFG_BIOS_DEFAULT_TV_TYPE:
                {
                  U032 biostvdefault;
                  dacGetBiosDefaultTVType(pDev,&biostvdefault);
                  result = biostvdefault;
                }
                break;

            //
            // Fields in NvInfo.
            //
            case NV_CFG_MANUFACTURER:
                result = pDev->Chip.HalInfo.Manufacturer;
                break;
            case NV_CFG_ARCHITECTURE:
                result = pDev->Chip.HalInfo.Architecture;
                break;
            case NV_CFG_REVISION:
                result = pDev->Chip.HalInfo.MaskRevision;
                break;
            case NV_CFG_BIOS_REVISION:
                result = pDev->Chip.BiosRevision;
                break;
            case NV_CFG_IMPLEMENTATION:
                result = pDev->Chip.HalInfo.Implementation;
                break;
            case NV_CFG_BUS_TYPE:
                result = pDev->Chip.Bus;
                break;
            case NV_CFG_CRYSTAL_FREQ:
                result = pDev->Chip.HalInfo.CrystalFreq;
                break;
            case NV_CFG_BIOS_OEM_REVISION:
                result = pDev->Chip.BiosOEMRevision;
                break;
#ifndef _WIN64
            case NV_CFG_ADDRESS_NVADDR:
                result = (U032) nvAddr;
                break;
#endif
            case NV_CFG_ADDRESS:
                result = pDev->Mapping.PhysAddr;
                break;
            case NV_CFG_IRQ:
                result = pDev->Mapping.IntLine;
                break;
            case NV_CFG_IO_NEEDED:
                result = pDev->Mapping.doIOToFlushCache;
                break;
            case NV_CFG_DEVICE_INSTANCE:
                result = devInstance;
                break;
#if defined(WIN32) && !defined(NTRM)
            case NV_CFG_DEVICE_HANDLE:
                {   
                    PWIN9XHWINFO    pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                    result = pOsHwInfo->osDeviceHandle;
                }
                break;
#endif
            case NV_CFG_PCI_ID:
                result = pDev->Chip.HalInfo.PCIDeviceID;
                break;            
            case NV_CFG_PCI_SUB_ID:
                result = pDev->Chip.HalInfo.PCISubDeviceID;
                break;            
            case NV_CFG_PROCESSOR_TYPE:
                result = pRmInfo->Processor.Type;
                break;
            case NV_CFG_PROCESSOR_SPEED:
                result = pRmInfo->Processor.Clock;
                break;
            case NV_CFG_GRAPHICS_CAPS:
                result = pDev->Graphics.Capabilities;
                break;
            case NV_CFG_INSTANCE_TOTAL:
                result = pDev->Pram.HalInfo.TotalInstSize;
                break;
            case NV_CFG_INSTANCE_SIZE:
                result = pDev->Pram.FreeInstSize;
                break;
            case NV_CFG_FIFO_COUNT:
                result = pDev->Fifo.HalInfo.Count;
                break;
            case NV_CFG_FIFO_USE_COUNT:
                result = pDev->Fifo.HalInfo.AllocateCount;
                break;
            case NV_CFG_RAM_SIZE_MB:
                result = pDev->Framebuffer.HalInfo.RamSizeMb;
                break;
            case NV_CFG_RAM_SIZE:
                result = pDev->Framebuffer.HalInfo.RamSize;
                break;
            case NV_CFG_RAM_TYPE:
                result = pDev->Framebuffer.HalInfo.RamType;
                break;
            case NV_CFG_AGP_PHYS_BASE:
            {
                if (IsAGPCapable(pDev))        
                    result = pRmInfo->AGP.AGPPhysStart;
                else
                    result = 0;
                break;
            }
#ifndef IA64
            case NV_CFG_AGP_LINEAR_BASE:
            {
                if (IsAGPCapable(pDev))    
                    result = pRmInfo->AGP.AGPLinearStart;
                else
                    result = 0;
                break;
            }
#endif
            case NV_CFG_AGP_LIMIT:
            {
                // Before returning the AGP limit, update our boot time value
                osUpdateAGPLimit(pDev);

                if (IsAGPCapable(pDev))    
                    result = pRmInfo->AGP.AGPLimit;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_HEAP_FREE:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPHeapFree;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_FW_ENABLE:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPFWEnable;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_FULLSPEED_FW:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPFullSpeedFW;
                else
                    result = 0;
                break;
            }
            case NV_CFG_SCREEN_WIDTH:
                result = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                break;
            case NV_CFG_SCREEN_HEIGHT:
                result = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                break;
            case NV_CFG_PIXEL_DEPTH:
                result = pDev->Dac.HalInfo.Depth;
                break;
            case NV_CFG_PRIMARY_SURFACE_PITCH:
                result = pDev->Dac.DisplayPitch;
                break;
            case NV_CFG_SCREEN_MAX_WIDTH:
                {
                    // This value depends on the display type.
                    // We really should read the EDID of the display device to get the max.
                    // For now hard code the values.
                    switch (GETMONITORTYPE(pDev, 0))
                    {
                        case MONITOR_TYPE_VGA:
                            result = 1920;
                            break;
                        case MONITOR_TYPE_NTSC:
                            result = 800;
                            break;
                        case MONITOR_TYPE_PAL:
                            result = 800;
                            break;
                        case MONITOR_TYPE_FLAT_PANEL:
                            {
                                U032 fpMode, fpMaxX, fpMaxY;
                                BOOL fpConnect;
                                BOOL fpNativeSupported;
                                dacGetFlatPanelInfo(pDev,
                                                    0,
                                                    &fpMode, &fpMaxX, &fpMaxY,
                                                    &fpConnect,
                                                    &fpNativeSupported, 
                                                    FALSE /* not from registry */);
                                result = fpMaxX;
                            }
                            break;
                        default:
                            result = 0;
                            rmStatus = RM_ERROR;
                            break;
                    } // switch on MonitorType
                }
                break;
            case NV_CFG_SCREEN_MAX_HEIGHT:
                {
                    // This value depends on the display type.
                    // We really should read the EDID of the display device to get the max.
                    // For now hard code the values.
                    switch (GETMONITORTYPE(pDev, 0))
                    {
                        case MONITOR_TYPE_VGA:
                            result = 1200;
                            break;
                        case MONITOR_TYPE_NTSC:
                            result = 600;
                            break;
                        case MONITOR_TYPE_PAL:
                            result = 600;
                            break;
                        case MONITOR_TYPE_FLAT_PANEL:
                            {
                                U032 fpMode, fpMaxX, fpMaxY;
                                BOOL fpConnect;
                                BOOL fpNativeSupported;
                                dacGetFlatPanelInfo(pDev,
                                                    0,
                                                    &fpMode, &fpMaxX, &fpMaxY,
                                                    &fpConnect,
                                                    &fpNativeSupported, 
                                                    FALSE /* not from registry */);
                                result = fpMaxY;
                            }
                            break;
                        default:
                            result = 0;
                            rmStatus = RM_ERROR;
                            break;
                    } // switch on MonitorType
                }
                break;
            case NV_CFG_VIDEO_ENCODER_TYPE:
                result = pDev->Dac.EncoderType;
                break;
            case NV_CFG_VIDEO_ENCODER_ID:
                result = pDev->Dac.EncoderID;
                break;
            case NV_CFG_VIDEO_DISPLAY_TYPE:
                result = GETDISPLAYTYPE(pDev, 0);
                break;
            case NV_CFG_VIDEO_MONITOR_TYPE:
                result = GETMONITORTYPE(pDev, 0);
                break;
            case NV_CFG_VIDEO_TV_FORMAT:
                result = pDev->Dac.TVStandard;
                break;
            case NV_CFG_VIDEO_REFRESH_RATE:
                result = pDev->Framebuffer.HalInfo.RefreshRate;
                break;
            case NV_CFG_VIDEO_OVERLAY_ALLOWED:
                result = pDev->Video.OverlayAllowed;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_768:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_768;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_1280:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_1280;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_1920:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_1920;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
                result = pDev->Framebuffer.Underscan_x;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
                result = pDev->Framebuffer.Underscan_y;
                break;
            case NV_CFG_VBLANK_TOGGLE:
                // Assume head 0 for now...
                result = pDev->Dac.CrtcInfo[0].VBlankToggle;
                break;
            case NV_CFG_VBLANK_COUNTER:
                // Assume head 0 for now...
                result = pDev->Dac.CrtcInfo[0].VBlankCounter;
                break;
            case NV_CFG_PRAM_CURRENT_SIZE:
                result = pDev->Pram.HalInfo.CurrentSize;
                break;
            case NV_CFG_DAC_INPUT_WIDTH:
                result = pDev->Dac.HalInfo.InputWidth;
                break;
            case NV_CFG_DAC_PIXEL_CLOCK:
                result = pDev->Dac.HalInfo.VClk;
                break;
            case NV_CFG_DAC_MEMORY_CLOCK:
                result = pDev->Dac.HalInfo.MClk;
                break;
            case NV_CFG_DAC_GRAPHICS_CLOCK:
                result = pDev->Dac.HalInfo.NVClk;
                break;
            case NV_CFG_DAC_VPLL_M:
                result = pDev->Dac.HalInfo.VPllM;
                break;
            case NV_CFG_DAC_VPLL_N:
                result = pDev->Dac.HalInfo.VPllN;
                break;
            case NV_CFG_DAC_VPLL_O:
                result = pDev->Dac.HalInfo.VPllO;
                break;
            case NV_CFG_DAC_VPLL_P:
                result = pDev->Dac.HalInfo.VPllP;
                break;
            case NV_CFG_DAC_MPLL_M:
                result = pDev->Dac.HalInfo.MPllM;
                break;
            case NV_CFG_DAC_MPLL_N:
                result = pDev->Dac.HalInfo.MPllN;
                break;
            case NV_CFG_DAC_MPLL_O:
                result = pDev->Dac.HalInfo.MPllO;
                break;
            case NV_CFG_DAC_MPLL_P:
                result = pDev->Dac.HalInfo.MPllP;
                break;
            case NV_CFG_DAC_PCLK_LIMIT_8BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit8bpp);
                break;            
            case NV_CFG_DAC_PCLK_LIMIT_16BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit16bpp);
                break;            
            case NV_CFG_DAC_PCLK_LIMIT_32BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit32bpp);
                break;            
#ifdef _WIN32
            case NV_CFG_MAPPING_BUSDEVICEFUNC:
                result = (pDev->Mapping.nvBusDeviceFunc << 8) | REG_RD32(NV_PBUS_PCI_NV_0);
                break;
#endif
            case NV_CFG_VIDEO_OUTPUT_FORMAT:
            {
                U032 Head = 0;
                rmStatus = dacReadTVOutFromRegistry(pDev, Head, &result);
                break;
            }
            case NV_CFG_NUMBER_OF_HEADS:
                result = pDev->Dac.HalInfo.NumCrtcs;
                break;

            case NV_CFG_NUMBER_OF_ACTIVE_HEADS:
            {
                U032 i;
                for (i = 0, result = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                    if (pDev->Dac.CrtcInfo[i].pVidLutCurDac)
                        result++;
                break;
            }
            case NV_CFG_INITIAL_BOOT_HEAD:
                result = pDev->Dac.HalInfo.InitialBootHead;
                break;
#ifdef LINUX
            case NV_CFG_INTERRUPTS_ENABLED_STATE:
                *pValue = pDev->Chip.IntrEn0;
                break;
#endif
#ifdef RM_STATS
            case NV_STAT_INTERVAL_NSEC_LO:
                result = pDev->Statistics.UpdateLo;
                break;
            case NV_STAT_INTERVAL_NSEC_HI:
                result = pDev->Statistics.UpdateHi;
                break;
            case NV_STAT_FIFO_EXCEPTIONS:
                result = pDev->Statistics.FifoExceptionCount;
                break;
            case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
                result = pDev->Statistics.FramebufferExceptionCount;
                break;
            case NV_STAT_GRAPHICS_EXCEPTIONS:
                result = pDev->Statistics.GraphicsExceptionCount;
                break;
            case NV_STAT_TIMER_EXCEPTIONS:
                result = pDev->Statistics.TimerExceptionCount;
                break;
            case NV_STAT_CHIP_EXCEPTIONS:
                result = pDev->Statistics.TotalExceptionCount;
                break;
            case NV_STAT_MEM_ALLOCATED:
                result = pDev->Statistics.MemAlloced;
                break;
            case NV_STAT_MEM_LOCKED:
                result = pDev->Statistics.MemLocked;
                break;
            case NV_STAT_EXEC_NSEC_LO:
                result = pDev->Statistics.ExecTimeLo;
                break;
            case NV_STAT_EXEC_NSEC_HI:
                result = pDev->Statistics.ExecTimeHi;
                break;
            case NV_STAT_INT_NSEC_LO:
                result = pDev->Statistics.IntTimeLo;
                break;
            case NV_STAT_INT_NSEC_HI:
                result = pDev->Statistics.IntTimeHi;
                break;
#endif

#if defined(DEBUG) && ( defined(UNIX) || defined(MACOS) )
            // debug only hack to read current debug
            case NV_CFG_DEBUG_LEVEL:
            {
                extern int cur_debuglevel;
                result = cur_debuglevel;
                break;
            }
#endif

            case NV_CFG_GET_ALL_DEVICES:
                result = pDev->Dac.DevicesBitMap;
                break;

            case NV_CFG_GET_BOOT_DEVICES:
                result = pDev->Dac.BootDevicesBitMap;
                break;

            default:
                result = 0;
                rmStatus = RM_ERROR;
                break;
        }
    }

    // save the result
    *pValue = result;

    return rmStatus;
}

//
// Returns the original value
//
RM_STATUS stateConfigSet(
    PHWINFO pDev, // Pointer to an nv device
    U032    index,
    U032    newvalue,
    U032*   pOldvalue
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS rmStatus = RM_OK;
    U032 result = 0;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to modify
    //
    if ((index & 0xF00) == NV_CFG_CRTC)
    {
        U008 lock, crtc_index;
        
        //
        // Save the current CRTC index
        //
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, 0);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);

        //
        // Get the register value.
        //
        CRTC_RD((index & 0xFF), result, 0);

        //
        // Update the new value
        //
        CRTC_WR((index & 0xFF), newvalue, 0);
        
        // Relock extended regs
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, 0);

        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index
    }
    else
    {
        switch (index)
        {
            //
            // Fields in NvInfo.
            //
            case NV_CFG_AGP_PHYS_BASE:
                result = pRmInfo->AGP.AGPPhysStart;
                pRmInfo->AGP.AGPPhysStart = newvalue;
                break;
#ifndef IA64
            case NV_CFG_AGP_LINEAR_BASE:
                result = pRmInfo->AGP.AGPLinearStart;
                pRmInfo->AGP.AGPLinearStart = newvalue;
                break;
#endif
            case NV_CFG_AGP_LIMIT:
                result = pRmInfo->AGP.AGPLimit;
                pRmInfo->AGP.AGPLimit = newvalue;
                break;
            case NV_CFG_SCREEN_WIDTH:
                result = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                pDev->Framebuffer.HalInfo.HorizDisplayWidth = newvalue;
                break;
            case NV_CFG_SCREEN_HEIGHT:
                result = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                pDev->Framebuffer.HalInfo.VertDisplayWidth = newvalue;
                break;
            case NV_CFG_PIXEL_DEPTH:
                result = pDev->Dac.HalInfo.Depth;
                pDev->Dac.HalInfo.Depth = newvalue;
                break;
            case NV_CFG_VIDEO_DISPLAY_TYPE:
                result = GETDISPLAYTYPE(pDev, 0);
                SETDISPLAYTYPE(pDev, 0, newvalue);
                break;
            case NV_CFG_VIDEO_MONITOR_TYPE:
                result = GETMONITORTYPE(pDev, 0);
                SETMONITORTYPE(pDev, 0, newvalue);
                break;
            case NV_CFG_VIDEO_REFRESH_RATE:
                result = pDev->Framebuffer.HalInfo.RefreshRate;
                pDev->Framebuffer.HalInfo.RefreshRate = newvalue;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
                result = pDev->Framebuffer.Underscan_x;
                pDev->Framebuffer.Underscan_x = newvalue;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
                result = pDev->Framebuffer.Underscan_y;
                pDev->Framebuffer.Underscan_y = newvalue;
                break;
            case NV_CFG_VBLANK_TOGGLE:
                result = pDev->Dac.CrtcInfo[0].VBlankToggle;
                pDev->Dac.CrtcInfo[0].VBlankToggle = newvalue;
                break;
            case NV_CFG_VBLANK_COUNTER:
                result = pDev->Dac.CrtcInfo[0].VBlankCounter;
                pDev->Dac.CrtcInfo[0].VBlankCounter = newvalue;
                break;
            case NV_CFG_DAC_PIXEL_CLOCK:
                result = pDev->Dac.HalInfo.PixelClock;
                pDev->Dac.HalInfo.PixelClock = newvalue;
                break;
            case NV_CFG_DAC_MEMORY_CLOCK:
                result = pDev->Dac.HalInfo.MClk;
                pDev->Dac.HalInfo.MClk = newvalue;
                pDev->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_MPLL;
                break;
            case NV_CFG_DAC_GRAPHICS_CLOCK:
                result = pDev->Dac.HalInfo.NVClk;
                pDev->Dac.HalInfo.NVClk = newvalue;
                pDev->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_NVPLL;
                break;
            case NV_CFG_VIDEO_OUTPUT_FORMAT:
            {
                U032 Head = 0;
                dacWriteTVOutToRegistry(pDev, Head, newvalue);
                break;
            }
            case NV_CFG_IRQ:
                result = pDev->Mapping.IntLine;
                pDev->Mapping.IntLine = newvalue; 
                break;
#ifdef  STEREO_SUPPORT
            case NV_CFG_STEREO_CONFIG:
                if (result = (U032)pDev->pStereoParams &&
                    pDev->pStereoParams->FlipOffsets[3][0] != 0xFFFFFFFF)
                {
                    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
                    //Stereo was previously activated. We want to make
                    //sure we are flipped to the primary left eye.
                    //pDev->pStereoParams->FlipOffsets[3][0] is supposed
                    //to point us to the primary surface offset.
                    vidLutCurDacHalObj.Head = 0;
                    nvHalDacSetStartAddr(pDev, pDev->pStereoParams->FlipOffsets[3][0], &vidLutCurDacHalObj);
                }
                pDev->pStereoParams = (LPNV_CFG_STEREO_PARAMS)newvalue;
                break;
#endif  //STEREO_SUPPORT

#ifdef LINUX
            case NV_CFG_INTERRUPTS_ENABLED_STATE:
                result = pDev->Chip.IntrEn0;
                pDev->Chip.IntrEn0 = newvalue;
                RmEnableInterrupts(pDev);           // will just slam in IntrEn0
                break;
#endif

#ifdef RM_STATS
            case NV_STAT_INTERVAL_NSEC_LO:
                result = pDev->Statistics.UpdateLo;
                pDev->Statistics.UpdateLo = newvalue;
                break;
            case NV_STAT_INTERVAL_NSEC_HI:
                result = pDev->Statistics.UpdateHi;
                pDev->Statistics.UpdateHi = newvalue;
                break;
            case NV_STAT_FIFO_EXCEPTIONS:
                result = pDev->Statistics.FifoExceptionCount;
                pDev->Statistics.FifoExceptionCount = newvalue;
                break;
            case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
                result = pDev->Statistics.FramebufferExceptionCount;
                pDev->Statistics.FramebufferExceptionCount = newvalue;
                break;
            case NV_STAT_GRAPHICS_EXCEPTIONS:
                result = pDev->Statistics.GraphicsExceptionCount;
                pDev->Statistics.GraphicsExceptionCount = newvalue;
                break;
            case NV_STAT_TIMER_EXCEPTIONS:
                result = pDev->Statistics.TimerExceptionCount;
                pDev->Statistics.TimerExceptionCount = newvalue;
                break;
            case NV_STAT_CHIP_EXCEPTIONS:
                result = pDev->Statistics.TotalExceptionCount;
                pDev->Statistics.TotalExceptionCount = newvalue;
                break;
            case NV_STAT_MEM_ALLOCATED:
                result = pDev->Statistics.MemAlloced;
                pDev->Statistics.MemAlloced = newvalue;
                break;
            case NV_STAT_MEM_LOCKED:
                result = pDev->Statistics.MemLocked;
                pDev->Statistics.MemLocked = newvalue;
                break;
            case NV_STAT_EXEC_NSEC_LO:
                result = pDev->Statistics.ExecTimeLo;
                pDev->Statistics.ExecTimeLo = newvalue;
                break;
            case NV_STAT_EXEC_NSEC_HI:
                result = pDev->Statistics.ExecTimeHi;
                pDev->Statistics.ExecTimeHi = newvalue;
                break;
            case NV_STAT_INT_NSEC_LO:
                result = pDev->Statistics.IntTimeLo;
                pDev->Statistics.IntTimeLo = newvalue;
                break;
            case NV_STAT_INT_NSEC_HI:
                result = pDev->Statistics.IntTimeHi;
                pDev->Statistics.IntTimeHi = newvalue;
                break;
#endif

#if defined(DEBUG) && ( defined(UNIX) || defined(MACOS) )
            // debug only hack to set current debug level
            case NV_CFG_DEBUG_LEVEL:
            {
                extern int cur_debuglevel;
                result = cur_debuglevel;
                cur_debuglevel = newvalue;
                break;
            }
#endif

            default:
                result = 0;
                rmStatus = RM_ERROR;
                break;
        }
    }

    *pOldvalue = result;

    return rmStatus; 
}

RM_STATUS stateConfigGetEx(
    PHWINFO pDev,
    U032    index,
    VOID    *paramStructPtr,
    U032    paramSize
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: getEx index ", index);

    switch (index)
    {
        case NV_CFGEX_GET_DESKTOP_POSITION_MONITOR:
        {
            U032 Head = 0;  // for legacy compatibility, there is no parameter passed 
            NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS *Params;
            Params = (NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                if (Params->GetDefault)
                {
                    dacGetMonitorDefaultPosition(pDev, 
                                                 Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    status = RM_OK;
                }
                else
                {
                    U032 cbLen;
                    // Get the H & V Blank start and end. These values do not change after
                    // modeset. The H & V retrace start and end may have been changed.
                    // But get the default values first.
                    dacGetMonitorDefaultPosition(pDev,
                                                 Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    // Read the registry to get any updates to the default H & V retrace
                    // start and end.
                    cbLen = 4 * sizeof(U032);
                    status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                                TRUE,  // isMonitor
                                                                (U008 *) &(Params->HRetraceStart),
                                                                &cbLen);
                    // If there is an error, we don't have to do anything. The default values have already been 
                    // saved in Params.
                }
            }
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_TV:
        {
            U032 Head = 0;
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *Params;
            Params = (NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                U032 cbLen;
                
                // if default, get position from tables, else get from registry
                if (Params->Default)
                {
                    dacGetDefaultTVPosition(pDev, Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                }
                else
                {
                    NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS MultiParams;

                    //
                    // For dacSetTVPosition to work, we need to standardize on one POSITION_TV
                    // params struct format that lives in the registry (currently, you can have a
                    // MULTI or a non-MULTI version, which is a problem).
                    //
                    // Until we remove the non-MULTI versions of these calls, independent of how
                    // we're called we'll read/write the registry with the MULTI version of struct.
                    // Which means (temporarily), we need to perform a cast in the non-MULTI case.

                    // Read the registry to get any updates to the default H & V offset
                    cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
                    status = dacReadTVDesktopPositionFromRegistry(pDev, Head,
                                                            (U008 *) &MultiParams,
                                                            &cbLen);

                    // Make sure data is valid for the current encoder.
                    if (MultiParams.Encoder_ID != pDev->Dac.EncoderType)
                        status = RM_ERROR;                  
                    if (status) // if reg read failed, return defaults
                        dacGetDefaultTVPosition(pDev, Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                    else {
                        // succeeded, convert MULTI to non-MULTI version
                        osMemCopy((U008*)Params, (U008*)&MultiParams.Encoder_ID, paramSize);
                    }

                    status = RM_OK;
                }
            }
        }
        break;

        case NV_CFGEX_GET_TV_ENCODER_INFO:
        {
            NV_CFGEX_TV_ENCODER_PARAMS *Params;
            Params = (NV_CFGEX_TV_ENCODER_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_TV_ENCODER_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                Params->EncoderType = pDev->Dac.EncoderType;
                Params->EncoderID = pDev->Dac.EncoderID;
                if (dacTVConnectStatus(pDev, 0))
                    Params->TVConnected = TV_CONNECTED;
                else
                    Params->TVConnected = TV_NOT_CONNECTED;
                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_GET_FLAT_PANEL_INFO:
        {
            NV_CFGEX_GET_FLATPANEL_INFO_PARAMS *Params;

            Params = (NV_CFGEX_GET_FLATPANEL_INFO_PARAMS *)paramStructPtr;
            if(!IsNV5orBetter(pDev))
                    Params->FlatPanelConnected = FALSE;
            else
                if (paramSize < sizeof(NV_CFGEX_GET_FLATPANEL_INFO_PARAMS))
                    // Wrong param size.
                    status = CONFIG_GETEX_BAD_PARAM;
                else
                    status = dacGetFlatPanelInfo(pDev, 0, &Params->FlatPanelMode,
                                             &Params->FlatPanelSizeX, &Params->FlatPanelSizeY,
                                             &Params->FlatPanelConnected,
                                             &Params->FlatPanelNativeSupported,
                                             FALSE /* not from registry */);
        }
        break;
        
        case NV_CFGEX_FLAT_PANEL_BRIGHTNESS:
        {
        	NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS * Params;
        	Params=(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS *)paramStructPtr;
        	if(paramSize!=sizeof(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS))
        	{
        		status=CONFIG_GETEX_BAD_PARAM;
        	}
        	else
        	{
        		status = dacGetFlatPanelBrightness(pDev, Params->Head, &(Params->PercentRelativeBrightness),&(Params->PWMControllerEnable));
        	}
        }
        break;

        case NV_CFGEX_GET_MONITOR_INFO:
        {
                NV_CFGEX_GET_MONITOR_INFO_PARAMS *Params;
                Params = (NV_CFGEX_GET_MONITOR_INFO_PARAMS *)paramStructPtr;
                status = dacGetMonitorInfo(pDev, (U032) 0, &Params->MonitorConnected);
        }
        break;

        case NV_CFGEX_GET_EDID:
        {
#ifndef IKOS
            NV_CFGEX_GET_EDID_PARAMS *Params;
            VOID  *edidBuffer = (VOID *) 0;
            U032 bufferLength;
            Params = (NV_CFGEX_GET_EDID_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_EDID_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
                ////OEMEnableExtensions();          // Unlock the registers before DDC
                status = EDIDRead(pDev,0,Params->displayType);
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
                ////OEMDisableExtensions();         // Lock the registers
                if ( status == RM_OK ) {
                    // status = EDIDCopy(pDev, Params->edidBuffer, Params->bufferLength, (U032) 0);
                    if (RM_SUCCESS(status = osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032))) &&
                        RM_SUCCESS(status = osAllocMem((VOID **) &edidBuffer, (U032) bufferLength)) &&
                        RM_SUCCESS(status = EDIDCopy(pDev, edidBuffer, &bufferLength, (U032) 0)) &&
                        RM_SUCCESS(status = osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032))) &&
                        RM_SUCCESS(status = osCopyOut((U008*) edidBuffer, (U008*) Params->edidBuffer, (U032) bufferLength)))
                    {
                        // all done 
                    }
                    if (edidBuffer)
                        osFreeMem(edidBuffer);
                }
                else {
                    status = CONFIG_GETEX_BAD_READ;
                }
            }
#else
            // just for IKOS builds return quickly
            status = CONFIG_GETEX_BAD_READ;
#endif
        }
        break;

        case NV_CFGEX_GET_BIOS:
        {
            NV_CFGEX_GET_BIOS_PARAMS *Params;
           	U008  *biosBuffer = (U008 *)NULL;
			U032 bufferLength;
			Params = (NV_CFGEX_GET_BIOS_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_BIOS_PARAMS)) 
            {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else 
            {
                // Get the size we need to recover
                osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032));
                status = osAllocMem((VOID **)&biosBuffer, (U032)bufferLength);
                if (RM_SUCCESS(status))
                {
                    U032 i;
                    // Pull the image byte-by-byte from the ghosted instance copy
                    for (i=0; i<bufferLength;i++)
                        biosBuffer[i] = (U008)BIOS_RD08(i);

                    // Copy the buffers back into the param structures (user buffer)
                    osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032));
                    osCopyOut((U008*) biosBuffer, (U008*) Params->biosBuffer, (U032) bufferLength);
                }

                if (biosBuffer)
                    osFreeMem(biosBuffer);

                if (RM_SUCCESS(status))
                    status = CONFIG_GETEX_OK;
                else
                    status = CONFIG_GETEX_BAD_READ;

            }
        }
        break;

        case NV_CFGEX_GET_SURFACE_PITCH:
        {
            NV_CFGEX_GET_SURFACE_PITCH_PARAMS *Params;
            Params = (NV_CFGEX_GET_SURFACE_PITCH_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SURFACE_PITCH_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                nvHalFbGetSurfacePitch(pDev, Params->Width, Params->Depth, &Params->Pitch);
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_SURFACE_DIMENSIONS:
        {
            NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS *Params;
            Params = (NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                nvHalFbGetSurfaceDimensions(pDev, Params->Width, Params->Height, Params->Depth,
                                            &Params->Pitch, &Params->Size);
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_SUPPORTED_CLASSES:
        {
            NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS *Params;
            Params = (NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                //
                // Return numClasses, if the classBuffer pointer is NULL. Otherwise, fill in
                // the classBuffer if it's big enough to hold all the values.
                //
                if (Params->classBuffer == NULL) {
                    Params->numClasses = pDev->classDB.numClasses;
                    status = CONFIG_GETEX_OK;
                } else {
                    if (Params->numClasses != pDev->classDB.numClasses)
                        status = CONFIG_GETEX_BAD_PARAM;
                    else {
                        U032 i;
                        PCLASS classDB = (PCLASS)pDev->classDB.pClasses;
                        //
                        // Fill in classBuffer with the supported (common/chip specific) classes.
                        //
                        //for (i = 0; i < pDev->numClasses; i++)
                        //    Params->classBuffer[i] = classDB[i].Type;

                        for (i = 0; i < pDev->classDB.numClasses; i++)
                            osCopyOut((U008*) &classDB[i].Type, (U008*) &Params->classBuffer[i], sizeof(U032));

                        status = CONFIG_GETEX_OK;
                    }
                }
            }
        }
        break;

        case NV_CFGEX_GET_DISPLAY_TYPE:
        {
            U032 Head = 0;
            NV_CFGEX_GET_DISPLAY_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_GET_DISPLAY_TYPE_PARAMS *)paramStructPtr;
            
            if (paramSize < sizeof(NV_CFGEX_GET_DISPLAY_TYPE_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->Type = GETDISPLAYTYPE(pDev, Head);
                if (Params->Type == DISPLAY_TYPE_TV)
                    Params->TVType = pDev->Dac.TVStandard;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_DISPLAY_TYPE_MULTI:
        {
            NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS *)paramStructPtr;
            
            if (paramSize < sizeof(NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->Type = GETDISPLAYTYPE(pDev, Params->Head);
                if (Params->Type == DISPLAY_TYPE_TV)
                    Params->TVType = pDev->Dac.TVStandard;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_GET_REFRESH_INFO:
        {
            NV_CFGEX_GET_REFRESH_INFO_PARAMS *Params;
            Params = (NV_CFGEX_GET_REFRESH_INFO_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_REFRESH_INFO_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            } else if (Params->Head > pDev->Dac.HalInfo.NumCrtcs) {
                // Wrong param head.
                status = CONFIG_GETEX_BAD_PARAM;
            } else if (pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac == NULL) {
                Params->ulRefreshRate = 0;
                status = RM_OK;
            } else {
                PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
                pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac;
                Params->ulRefreshRate = pVidLutCurDac->RefreshRate;
                status = RM_OK;
            }

            // Params->ulState = pDev->Framebuffer.RefreshRateType;
        }
        break;

        case NV_CFGEX_GET_AGP_OFFSET:
        {
            NV_CFGEX_GET_AGP_OFFSET_PARAMS *Params;
            Params = (NV_CFGEX_GET_AGP_OFFSET_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_AGP_OFFSET_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->offset = 0xFFFFFFFF;        // init to unsigned -1

                status = osVirtualToPhysicalAddr(Params->linaddr, &Params->physaddr);
                if (status == RM_OK)
                {
                    // check if it's in the AGP aperture, if so, return the offset
                    if (
                        Params->physaddr >= (VOID*)pRmInfo->AGP.AGPPhysStart &&
                        (U008*)Params->physaddr <= (U008*)pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit
                    )
                    {
                        Params->offset = (U032)((U008*)Params->physaddr - (U008*)pRmInfo->AGP.AGPPhysStart);
                        status = RM_OK;
                    }
                    else
                        status = CONFIG_GETEX_BAD_PARAM;        // not an AGP aperture address
                }
            }
        }
        break;

        case NV_CFGEX_AGP_LINEAR_BASE:
        {
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS *Params;
            Params = (NV_CFGEX_AGP_LINEAR_BASE_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->linaddr = (void *)pRmInfo->AGP.AGPLinearStart;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_ADDRESS_NVADDR:
        {
            NV_CFGEX_ADDRESS_NVADDR_PARAMS *Params;
            Params = (NV_CFGEX_ADDRESS_NVADDR_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_ADDRESS_NVADDR_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                Params->nvaddr = nvAddr;
                status = CONFIG_GETEX_OK;
            }
        }
        break;

        case NV_CFGEX_RESERVED:
        {
            // Refer to nvcmrsvd.h for supported properties.
            NV_CFGEX_RESERVED_PROPERTY * pParams = (NV_CFGEX_RESERVED_PROPERTY*)paramStructPtr;
            U032                         In[1]   = {0};
            U032                         Out[1]  = {0};

            // Copy the data in (1 parameter).
            osCopyIn((U008*)pParams->In, (U008*)In, 1*sizeof(U032));

            // Get the data.
            status = CONFIG_GETEX_BAD_PARAM;
            if (paramSize == sizeof(NV_CFGEX_RESERVED_PROPERTY))
            {
                status = RM_OK;
                switch (pParams->Property)
                {
                    case PROPERTY_REG_RD08:
                        Out[0] = REG_RD08(In[0]);
                        break;

                    case PROPERTY_REG_RD16:
                        Out[0] = REG_RD16(In[0]);
                        break;

                    case PROPERTY_REG_RD32:
                        Out[0] = REG_RD32(In[0]);
                        break;

                    case PROPERTY_FB_RD08:
                        Out[0] = FB_RD08(In[0]);
                        break;

                    case PROPERTY_FB_RD16:
                        Out[0] = FB_RD16(In[0]);
                        break;

                    case PROPERTY_FB_RD32:
                        Out[0] = FB_RD32(In[0]);
                        break;

                    default:
                        status = CONFIG_GETEX_BAD_PARAM;
                        break;
                }
            }

            // Copy the data out (1 parameter).
            osCopyOut((U008*)Out, (U008*)pParams->Out, 1*sizeof(U032));
        }
        break;

#if 1 
        case NV_CFGEX_GET_LOGICAL_DEV_EDID:
        {
            U008 lock;        
            NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS *Params;
            U032 Head, edidversion, edidrevision;
            VOID  *edidBuffer = (VOID *) 0;
            //U032 bufferLength, i;
            Params = (NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else 
            {
                status = dacGetDisplayInfo(pDev, Params->displayMap, &Head, 0, 0, 0);
                if (status != RM_OK)
                {
                    status = CONFIG_GETEX_BAD_READ;
                    break;
                }

                lock = UnlockCRTC(pDev, Head);
                status = edidReadDevEDID(pDev, Params->displayMap, Params->edidBuffer);
                RestoreLock(pDev, Head, lock);

                if (status != RM_OK)
                {
                    status = CONFIG_GETEX_BAD_READ;
                    break;
                }

                status = edidLogicalEDIDIsValid(&Params->edidBuffer, &edidversion, &edidrevision);

                if (status != TRUE)
                {
                    status = CONFIG_GETEX_BAD_READ;
                    break;
                }

                if (edidversion == 1)
                {
                    *Params->bufferLength = EDID_V1_SIZE;
                }
                else if (edidversion == 2)
                {
                    *Params->bufferLength = EDID_V2_SIZE;
                }
            }
            break;
        }

        //
        // Multi-Head Info. These take logical Head number as a parameter
        //
        case NV_CFGEX_GET_EDID_MULTI:
        {
            U008 lock;        
            NV_CFGEX_GET_EDID_MULTI_PARAMS *Params;
            VOID  *edidBuffer = (VOID *) 0;
            U032 bufferLength;
            Params = (NV_CFGEX_GET_EDID_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_EDID_MULTI_PARAMS)) {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                if (Params->Head > pDev->Dac.HalInfo.NumCrtcs) {    // Bad Head number will cause our nvInfo to get trashed
                    status = CONFIG_GETEX_BAD_PARAM;
                }
                else {
                    lock = UnlockCRTC(pDev, Params->Head);
                    status = EDIDRead(pDev, Params->Head, Params->displayType);
                    RestoreLock(pDev, Params->Head, lock);
                    if ( status == RM_OK ) {
                        //status = EDIDCopy(pDev, Params->edidBuffer, Params->bufferLength, Params->Head);
                        if (RM_SUCCESS(status = osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032))) &&
                            RM_SUCCESS(status = osAllocMem((VOID **) &edidBuffer, (U032) bufferLength)) &&
                            RM_SUCCESS(status = EDIDCopy(pDev, edidBuffer, &bufferLength, (U032) Params->Head)) &&
                            RM_SUCCESS(status = osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032))) &&
                            RM_SUCCESS(status = osCopyOut((U008*) edidBuffer, (U008*) Params->edidBuffer, (U032) bufferLength)))
                        {
                            // all done 
                        }
                        if (edidBuffer)
                            osFreeMem(edidBuffer);
                    }
                    else {
                        status = CONFIG_GETEX_BAD_READ;
                    }
                }
            }
        }
        break;
        
        case NV_CFGEX_VIDEO_ENCODER_TYPE:
        {
            NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS *)paramStructPtr;
            
            Params->EncoderType = pDev->Dac.EncoderType;
        }
        break;
        case NV_CFGEX_VIDEO_ENCODER_ID:
        {
            NV_CFGEX_VIDEO_ENCODER_ID_PARAMS *Params;
            Params = (NV_CFGEX_VIDEO_ENCODER_ID_PARAMS *)paramStructPtr;

            Params->EncoderID = pDev->Dac.EncoderID;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_8BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            if(Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit8bpp);    
            else    
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_16BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            if(Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit16bpp);   
            else    
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_32BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            if(Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit32bpp);   
            else    
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI:
        {
            NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                if (Params->GetDefault)
                {
                    dacGetMonitorDefaultPosition(pDev, 
                                                 Params->Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    status = RM_OK;
                }
                else
                {
                    U032 cbLen;
                    // Get the H & V Blank start and end. These values do not change after
                    // modeset. The H & V retrace start and end may have been changed.
                    // But get the default values first.
                    dacGetMonitorDefaultPosition(pDev,
                                                 Params->Head,
                                                 &Params->HBlankStart, &Params->HBlankEnd,
                                                 &Params->VBlankStart, &Params->VBlankEnd,
                                                 &Params->HRetraceStart, &Params->HRetraceEnd,
                                                 &Params->VRetraceStart, &Params->VRetraceEnd);
                    // Read the registry to get any updates to the default H & V retrace
                    // start and end.
                    cbLen = 4 * sizeof(U032);
                    status = dacReadDesktopPositionFromRegistry(pDev, Params->Head,
                                                                TRUE,  // isMonitor
                                                                (U008 *) &(Params->HRetraceStart),
                                                                &cbLen);
                    // If there is an error, we don't have to do anything. The default values have already been 
                    // saved in Params.
                }
            }
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_TV_MULTI:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                U032 cbLen;
                
                // if default, get position from tables, else get from registry
                if (Params->Default)
                {
                    dacGetDefaultTVPosition(pDev, Params->Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                }
                else
                {
                    // Read the registry to get any updates to the default H & V offset
                    cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
                    status = dacReadTVDesktopPositionFromRegistry(pDev, Params->Head,
                                                            (U008 *) Params,
                                                            &cbLen);
                    // Make sure data is valid for the current encoder.
                    if (Params->Encoder_ID != pDev->Dac.EncoderType)
                        status = RM_ERROR;                  
                    if (status) // if reg read failed, return defaults
                        dacGetDefaultTVPosition(pDev, Params->Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                    status = RM_OK;
                }
            }
        }
        break;

        case NV_CFGEX_GET_TV_ENCODER_INFO_MULTI:
        {
            NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else
            {
                Params->EncoderType = pDev->Dac.EncoderType;
                Params->EncoderID = pDev->Dac.EncoderID;
                if (dacTVConnectStatus(pDev, Params->Head))
                    Params->TVConnected = TV_CONNECTED;
                else
                    Params->TVConnected = TV_NOT_CONNECTED;
                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI:
        {
            NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;
            if(!IsNV5orBetter(pDev))
                Params->FlatPanelConnected = FALSE;
            else
                if (paramSize < sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS))
                    // Wrong param size.
                    status = CONFIG_GETEX_BAD_PARAM;
                else
                {
                    //
                    // CONTROL PANEL WORKAROUND FOR MOBILE
                    //
                    // On mobile the control panel will be expecting the DFP to be on the
                    // virtual primary head (0), yet in reality the physical head is always 1.
                    // He might call in asking about head0, so route it to head1.
                    //
                    if (pDev->Power.MobileOperation)
                        Params->Head = 1;
                    status = dacGetFlatPanelInfo(pDev, Params->Head, &Params->FlatPanelMode,
                                         &Params->FlatPanelSizeX, &Params->FlatPanelSizeY,
                                         &Params->FlatPanelConnected,
                                         &Params->FlatPanelNativeSupported,
                                         FALSE /* not from registry */);
                }
        }
        break;

        case NV_CFGEX_GET_MONITOR_INFO_MULTI:
        {
            NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS *)paramStructPtr;
            status = dacGetMonitorInfo(pDev, Params->Head, &Params->MonitorConnected);
        }
        break;

        case NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST:
        {
            NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *Params;
            Params = (NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *)paramStructPtr;
            status = dacGetColorSaturationBoost(pDev, Params->Head, &Params->boostValue);
        }
        break;


#endif  // multi-head      

        case NV_CFGEX_CURRENT_SCANLINE_MULTI:
        {
            NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS *)paramStructPtr;
            if (Params->Head < DACHALINFO(pDev, NumCrtcs))
                Params->RasterPosition = DAC_REG_RD_DRF(_PCRTC, _RASTER, _POSITION, Params->Head);
            else
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;

        case NV_CFGEX_SYNC_STATE:
        {
            NV_CFGEX_SYNC_STATE_PARAMS *Params;
            Params = (NV_CFGEX_SYNC_STATE_PARAMS *) paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SYNC_STATE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                dacGetSyncState(pDev, Params->Head, &Params->Hsync, &Params->Vsync);
                // paper over a bit of ambiguity :-)
                Params->oldHsync = Params->Hsync;
                Params->oldVsync = Params->Vsync;
            }
        }
        break;

        case NV_CFGEX_PRIMARY_INFO:
        {
            NV_CFGEX_PRIMARY_INFO_PARAMS *Params;
            Params = (NV_CFGEX_PRIMARY_INFO_PARAMS *) paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_PRIMARY_INFO_PARAMS))
            {
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            // TODO is there a 'max heads' #define ?
            if (Params->Head > 1)
            {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }
            
            /// TODO 'primarySurfaceAlloced' should probably be per-head
            //  TODO 'Dac.DisplayPitch'         ""
            if ( ! pDev->Framebuffer.PrimarySurfaceAlloced)
            {
                status = CONFIG_GETEX_BAD_READ;
                break;
            }
                
            Params->Pitch = pDev->Dac.DisplayPitch;
            Params->Offset = pDev->Framebuffer.HalInfo.Start[Params->Head];
        }
        break;

        //Interface for control panel to read pending mobile hotkey (Fn+x) events.
        case NV_CFGEX_GET_HOTKEY_EVENT:
        {
            NV_CFGEX_GET_HOTKEY_EVENT_PARAMS *Params;
            Params = (NV_CFGEX_GET_HOTKEY_EVENT_PARAMS *) paramStructPtr;

            if (paramSize < sizeof(NV_CFGEX_GET_HOTKEY_EVENT_PARAMS)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }
            if (!pDev->Power.MobileOperation) {
                //If there are no hotkeys to support...
                Params->event = NV_HOTKEY_EVENT_NOT_SUPPORTED;
                Params->status = 0;
            } else if (pDev->HotKeys.queueHead == pDev->HotKeys.queueTail) {
                //If no hotkey events are pending...
                Params->event = NV_HOTKEY_EVENT_NONE_PENDING;
                Params->status = 0;
            } else {
                //If there are events in the queue, report the next one...
                Params->event = pDev->HotKeys.Queue[pDev->HotKeys.queueTail].event;
                Params->status = pDev->HotKeys.Queue[pDev->HotKeys.queueTail].status;
                pDev->HotKeys.queueTail = (pDev->HotKeys.queueTail + 1) % NV_HOTKEY_EVENT_QUEUE_SIZE;
            }
        }
        break;

        case NV_CFGEX_GET_DEVICE_MAPPINGS:
        {
            NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS *Params;

            //
            // This call is for use by the NVDE debugger.
            //
            if (paramSize < sizeof(NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                Params = (NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS *) paramStructPtr;
                Params->nvVirtAddr = (void *)pDev->DBnvAddr;
                Params->fbVirtAddr = (void *)pDev->DBfbAddr;
                Params->nvPhysAddr = (void *)pDev->Mapping.PhysAddr;
                Params->fbPhysAddr = (void *)pDev->Mapping.PhysFbAddr;

                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_CHECK_CONNECTED_DEVICES:
        {
            U032        *pDevBitMap = (U032 *)paramStructPtr;

            // make sure it's a subset of all available devices.
            if (!*pDevBitMap ||
                ((*pDevBitMap ^ pDev->Dac.DevicesBitMap) & *pDevBitMap)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            dacDevicesConnectStatus(pDev, pDevBitMap);

            break;
        }

        case NV_CFGEX_GET_DEVICES_CONFIGURATION:
        {
            NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS   *param;

            param = (NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS *)paramStructPtr;

            // make sure it's a subset of all available devices.
            if (!param->DevicesConfig ||
                ((param->DevicesConfig ^ pDev->Dac.DevicesBitMap) & param->DevicesConfig)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            if (dacFindDevicesConfiguration(pDev,
                                            param->DevicesConfig,
                                            &param->DevicesAllocationMap,
                                            param->OldDevicesConfig,
                                            param->OldDevicesAllocationMap) != RM_OK)
                status = CONFIG_GETEX_BAD_PARAM;

            break;
        }

        default:
            status = CONFIG_GETEX_BAD_INDEX;
            break;
    } // switch on index

    return status;

} // end of stateConfigGetEx

RM_STATUS stateConfigSetEx(
    PHWINFO pDev,
    U032    index,
    VOID    *paramStructPtr,
    U032    paramSize
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS status = RM_OK;
    switch (index)
    {
        case NV_CFGEX_SET_DESKTOP_POSITION_MONITOR:
        {
            U032 Head = 0;
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS *Params;
            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                status = dacSetMonitorPosition(pDev, 
                                               Head,
                                               Params->HRetraceStart, Params->HRetraceEnd,
                                               Params->VRetraceStart, Params->VRetraceEnd);
                if (!status && Params->CommitChanges)
                {
                    // Write the the passed values into the registry.
                    status = dacWriteDesktopPositionToRegistry(pDev,
                                                               Head,
                                                               TRUE, // isMonitor
                                                               (U008 *) &(Params->HRetraceStart),
                                                               4 * sizeof(U032));
                }
            }
        }
        break;

        case NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI:
        {
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                status = dacSetMonitorPosition(pDev, 
                                               Params->Head,
                                               Params->HRetraceStart, Params->HRetraceEnd,
                                               Params->VRetraceStart, Params->VRetraceEnd);
                if (!status && Params->CommitChanges)
                {
                    // Write the the passed values into the registry.
                    status = dacWriteDesktopPositionToRegistry(pDev,
                                                               Params->Head,
                                                               TRUE, // isMonitor
                                                               (U008 *) &(Params->HRetraceStart),
                                                               4 * sizeof(U032));
                }
            }
        }
        break;

        case NV_CFGEX_COMMIT_DESKTOP_POSITION_TV:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *Params;
            U032 Head = 0;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS MultiParams;

                //
                // For dacSetTVPosition to work, we need to standardize on one POSITION_TV
                // params struct format that lives in the registry (currently, you can have a
                // MULTI or a non-MULTI version, which is a problem).
                //
                // Until we remove the non-MULTI versions of these calls, independent of how
                // we're called we'll read/write the registry with the MULTI version of struct.
                // Which means (temporarily), we need to perform a cast in the non-MULTI case.

                MultiParams.Head = Head;
                osMemCopy((U008*)&MultiParams.Encoder_ID, (U008*)Params, paramSize);

                // Write the passed values into the registry.
                status = dacWriteDesktopPositionToRegistry(pDev,
                                                           Head,
                                                           FALSE, // not Monitor
                                                           (U008 *) &MultiParams,
                                                           sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS));
            }
        }
        break;

        case NV_CFGEX_COMMIT_DESKTOP_POSITION_TV_MULTI:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                // Write the the passed values into the registry.
                status = dacWriteDesktopPositionToRegistry(pDev,
                                                           Params->Head,
                                                           FALSE, // not Monitor
                                                           (U008 *) Params,
                                                           sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS));
            }
        }
        break;

        case NV_CFGEX_ENABLE_TETRIS_TILING:
        {
            // Automatic tiling will be enabled at the next modeset.
            // The tiling mode will be selected based on the new mode.
            status = nvHalFbControl(pDev, FB_CONTROL_TILING_ENABLE);
        }
        break;

        case NV_CFGEX_DISABLE_TETRIS_TILING:
        {
            // Automatic tiling will be disabled at the next modeset. It will remain disabled till
            // it is enabled by calling ConfigSetEx with NV_CFGEX_ENABLE_TETRIS_TILING.
            status = nvHalFbControl(pDev, FB_CONTROL_TILING_DISABLE);
        }
        break;

        case NV_CFGEX_SET_FLAT_PANEL_INFO:
        {
            NV_CFGEX_SET_FLATPANEL_INFO_PARAMS *Params;
            Params = (NV_CFGEX_SET_FLATPANEL_INFO_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_FLATPANEL_INFO_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                RM_ASSERT(pDev->Dac.CrtcInfo[0].pVidLutCurDac);
                status = dacSetFlatPanelMode(pDev, 0,
                                             (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac,
                                             Params->FlatPanelMode, Params->CommitChanges);
            }
        }
        break;

        case NV_CFGEX_SET_FLAT_PANEL_INFO_MULTI:
        {
            NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                RM_ASSERT(pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac);
                status = dacSetFlatPanelMode(pDev, Params->Head,
                                             (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac,
                                             Params->FlatPanelMode, Params->CommitChanges);
            }
        }
        break;
        
        case NV_CFGEX_FLAT_PANEL_BRIGHTNESS:
        {
        	NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS * Params;
        	Params=(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS *)paramStructPtr;
        	
        	if(paramSize<sizeof(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS))
        	{
        		//wrong parameter size
        		status=CONFIG_SETEX_BAD_PARAM;
        	}
        	else
        	{
        		status=dacSetFlatPanelBrightness(pDev, Params->Head,
        									Params->PercentRelativeBrightness,
                							Params->FlatPanelBrightnessControlFrequency,
                							Params->PercentMaximumPWMDutyCycle,
                							Params->PercentMinimumPWMDutyCycle,
                							Params->PWMControllerEnable);
            }
         }
         break;

        case NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST:
        {
            NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *Params;
            Params = (NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *)paramStructPtr;
            status = dacSetColorSaturationBoost(pDev, Params->Head, Params->boostValue);
        }
        break;

        //
        // XXXscottl
        //
        // These SET_DISPLAY_TYPE calls need to be removed.
        // All programming of the display/monitor/tv types
        // should be done via the dac classes from now on.
        //

        case NV_CFGEX_SET_DISPLAY_TYPE:
        {
            U032 Head = 0;

            NV_CFGEX_SET_DISPLAY_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_SET_DISPLAY_TYPE_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DISPLAY_TYPE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                SETDISPLAYTYPE(pDev, Head, Params->Type);
                if ((Params->Type == DISPLAY_TYPE_TV) && 
                    (Params->TVType <= KNOWN_TV_FORMATS))
                    pDev->Dac.TVStandard = Params->TVType;
                status = CONFIG_SETEX_OK;
            }
        }
        break;

        case NV_CFGEX_SET_DISPLAY_TYPE_MULTI:
        {
            NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                SETDISPLAYTYPE(pDev, Params->Head, Params->Type);
                if ((Params->Type == DISPLAY_TYPE_TV) && 
                    (Params->TVType <= KNOWN_TV_FORMATS))
                    pDev->Dac.TVStandard = Params->TVType;
                status = CONFIG_SETEX_OK;
            }
        }
        break;

        case NV_CFGEX_AGP_LINEAR_BASE:
        {
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS *Params;
            VOID_PTR oldValue;

            Params = (NV_CFGEX_AGP_LINEAR_BASE_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else {
                oldValue = pRmInfo->AGP.AGPLinearStart;
                pRmInfo->AGP.AGPLinearStart = (VOID_PTR)Params->linaddr;
                Params->linaddr = (void *)oldValue;
                status = CONFIG_SETEX_OK;
            }
        }
        break;

        case NV_CFGEX_SYNC_STATE:
        {
            NV_CFGEX_SYNC_STATE_PARAMS *Params;
            Params = (NV_CFGEX_SYNC_STATE_PARAMS *) paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_SYNC_STATE_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                dacGetSyncState(pDev, Params->Head, &Params->oldHsync, &Params->oldVsync);
                dacSetSyncState(pDev, Params->Head, Params->Hsync, Params->Vsync);
            }
        }
        break;

        case NV_CFGEX_RESERVED:
        {
            // Refer to nvcmrsvd.h for supported properties.
            NV_CFGEX_RESERVED_PROPERTY * pParams = (NV_CFGEX_RESERVED_PROPERTY*)paramStructPtr;
            U032                         In[2]   = {0};

            // Copy the data in (2 parameter).
            osCopyIn((U008*)pParams->In, (U008*)In, 2*sizeof(U032));

            // Set the data.
            status = CONFIG_SETEX_BAD_PARAM;
            if (paramSize == sizeof(NV_CFGEX_RESERVED_PROPERTY))
            {
                status = RM_OK;
                switch (pParams->Property)
                {
                    case PROPERTY_REG_WR08:
                        REG_WR08(In[0], In[1]);
                        break;

                    case PROPERTY_REG_WR16:
                        REG_WR16(In[0], In[1]);
                        break;

                    case PROPERTY_REG_WR32:
                        REG_WR32(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR08:
                        FB_WR08(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR16:
                        FB_WR16(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR32:
                        FB_WR32(In[0], In[1]);
                        break;

                    case PROPERTY_SET_GRAPHICS_CLOCK:
                        pDev->Dac.HalInfo.NVClk = In[0];
                        if (dacProgramNVClk(pDev) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;

                    case PROPERTY_SET_MEMORY_CLOCK:
                        pDev->Dac.HalInfo.MClk = In[0];
                        if (dacProgramMClk(pDev) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;

                    case PROPERTY_SET_PIXEL_CLOCK:
                    {
                        // dacProgramPClk takes frequency in MHz * 100.
                        U032 Head      = In[0];
                        U032 Frequency = In[1] / 10000;
                        if (dacProgramPClk(pDev, Head, Frequency) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;
                    }

                    default:
                        status = CONFIG_SETEX_BAD_PARAM;
                        break;
                }
            }
        }
        break;

        case NV_CFGEX_SET_MACROVISION_MODE:
        {
            NV_CFGEX_SET_MACROVISION_MODE_PARAMS *Params;
            RM_MACROVISION_CONTROL mvCtrl;

            // extract parameters from the command struct
            Params = (NV_CFGEX_SET_MACROVISION_MODE_PARAMS *) paramStructPtr;
            mvCtrl.mode = Params->mode;
            mvCtrl.resx = Params->resx;
            mvCtrl.resy = Params->resy;

            // extract parameters that the RM maintains
            mvCtrl.devAddr = pDev->Dac.EncoderID;
            mvCtrl.encoderType = pDev->Dac.EncoderType;
            mvCtrl.tvStandard = pDev->Dac.TVStandard;
            mvCtrl.port = pDev->Dac.TVOutPortID;

            if ( SetMacrovisionMode(pDev, Params->head, &mvCtrl) ) {
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                status = RM_OK;
            }
        }
        break;

        default:
            status = CONFIG_SETEX_BAD_INDEX;
            break;
    }

    return status;
} // end of stateConfigSetEx
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\video\nv\video.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: video.c                                                           *
*   The video engine is managed here.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"

#define DEBUGLEVEL_TRACEINFO_SCOTTL DEBUGLEVEL_ERRORS

//
// Change Video hardware state.
//
RM_STATUS stateVideo
(
    PHWINFO pDev,
    U032    msg
)
{
    switch (msg)
    {
        case STATE_UPDATE:
            nvHalVideoControl(pDev, VIDEO_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalVideoControl(pDev, VIDEO_CONTROL_LOAD);
            break;
        case STATE_UNLOAD:
            nvHalVideoControl(pDev, VIDEO_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
        {
            extern char strDevNodeRM[];
            U032 data32;

            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FlipOnHsync", &data32) == RM_OK)
                pDev->Video.FlipOnHsync = data32;
            else
                pDev->Video.FlipOnHsync = 0x0;
            nvHalVideoControl(pDev, VIDEO_CONTROL_INIT);
            pDev->Video.HalInfo.Enabled = 0;
            break;
        }
        case STATE_DESTROY:
            nvHalVideoControl(pDev, VIDEO_CONTROL_DESTROY);
            break;
    }
    return (RM_OK);
}

//
// Top-level video engine service handler.
V032 videoService
(
    PHWINFO pDev
)
{
    //
    // Even when pDev->ActiveVideoOverlayObject is NULL, don't opt out early, still
    // give the underlying chip specific ISR a chance to quiesce the video HW.
    //
    return pDev->pOverlayServiceHandler(pDev, (POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\tmr\nv\tmrstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Timer Module ********************************\
*                                                                           *
* Module: TMRSTATE.C                                                        *
*   The Timer cntrol state is maintained in this module.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <tmr.h>
#include <os.h>
#include "nvhw.h"


//
// Month to days conversion.
//
U032 tmrMonthDays[12] =
{
    31, 28, 31, 30,
    31, 30, 31, 31,
    30, 31, 30, 31
};

//
// Change Master Control hardware state.
//
RM_STATUS stateTmr
(
    PHWINFO pDev,
    U032    msg
)
{
    RM_STATUS status;
#if defined(UNIX) || defined(MACOS)
    U032      seconds;
    U032      useconds;
    long long mseconds;			// U064 is a struct, not long long
#else    
    U032      year;
    U032      month;
    U032      day;
    U032      hour;
    U032      min;
    U032      sec;
    U032      msec;
    U032      days;
#endif
    U032      sec5;
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Set timer values.
            //
            REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
            REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);
            REG_WR32(NV_PTIMER_ALARM_0,     0xFFFFFFFF);
            //
            // Get current time from operating system.
            //
            
#if defined(UNIX) || defined(MACOS)
            // On UNIX, we get the time in seconds since 1970.
            // From within the unix kernel it is actually hard to get
            //   real time of day.  We don't really need it anyway.
            osGetCurrentTime(&seconds, &useconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "NVRM: Time = ");
			DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, seconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " seconds, ");
			DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, useconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " useconds.\n");
            mseconds = seconds * 1000 + (useconds / 1000);
            sec5 = mseconds / 4295;
#else
            osGetCurrentTime(&year, &month, &day, &hour, &min, &sec, &msec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "NVRM: Date = ");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, month);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "/");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, day);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "/");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, year);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " ");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, hour);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, min);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, sec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, msec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "\n");

            //
            // Perform a quick error check of the time
            //
            if (month > 12)
                    month = 12;
            if (day > 31)
                    day = 20;
            if (hour > 24)
                    hour = 12;
            if (min > 59)
                    min = 59;
            if (sec > 59)
                    sec = 59;

            //
            // Get days so far.
            //
            if (year > 1990)
                year -= 1990;
            days = year * 365 + (year + 1) / 4;
            //
            // If this is a current leap year, check the month.
            //
            if (!((year + 2) & 3) && (month > 2))
                days++;
            while (--month)
                days += tmrMonthDays[month];
            days += day;
            sec5 = days * 20117 + hour * 838 + (min * 257698 + sec * 4295) / 1000;

            //
            // Add number of 4.295 sec increments between 1970 and 1990 to the 
            // accumulated time.
            //
            sec5 += 146951526;
#endif

            //
            // Since the internal timer is only accurate to about 5 sec/day,
            // that is about the accuracy of the upper 32 bits of the nsec timer.
            // To initialize, just calculate the current time to the nearest 4.295 sec.
            //
            REG_WR32(NV_PTIMER_TIME_0, 0);
            REG_WR32(NV_PTIMER_TIME_1, sec5);
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TIMER = ");
            DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO, sec5);
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ":0x00000000\n");

            if (!pDev->Vga.Enabled) // interrupts wake up from standby on some motherboards
            {
                //
                // Enable Timer interrupt.
                //
                REG_WR32(NV_PTIMER_INTR_0,    0xFFFFFFFF);
                REG_WR32(NV_PTIMER_INTR_EN_0, 0xFFFFFFFF);
            }            
#ifdef RM_STATS
            /*
            For now, no perf timer needed!!
            
            //
            // Schedule performance timer.
            //
            tmrScheduleCallbackRel(tmrStatTimer,
                                   (POBJECT)0x69,
                                   pDev->Statistics.UpdateHi,
                                   pDev->Statistics.UpdateLo);
            */
#endif
            break;
        case STATE_UNLOAD:
            //
            // Disable Timer interrupt.
            //
            REG_WR32(NV_PTIMER_INTR_EN_0, 0);
            //
            // Cancel performance timer.
            //
            tmrCancelCallback(pDev, (POBJECT)0x69);
            break;
        case STATE_INIT:
            status = initTmr(pDev);
            break;
        case STATE_DESTROY:
            //
            // Restore previous values.
            //
            REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.tmrSave[0]);
            REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.tmrSave[1]);
            osFreeMem((VOID *)pDev->DBtmrCallbackTable);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\video\nv\videoobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: videoobj.c                                                        *
*   Video engine objects are managed here.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <smp.h>
#include "nvhw.h"

//
// Forwards.
//

// NV_PATCHCORD_VIDEO (class60)
static RM_STATUS videoCreatePatchcordObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyPatchcordObj(PHWINFO, POBJECT);

// NV_VIDEO_SINK (class61)
static RM_STATUS videoCreateSinkObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroySinkObj(PHWINFO, POBJECT);

// NV_VIDEO_COLORMAP (class62)
static RM_STATUS videoCreateColormapObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyColormapObj(PHWINFO, POBJECT);

// NV_VIDEO_FROM_MEMORY (class63)
static RM_STATUS videoCreateFromMemoryObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyFromMemoryObj(PHWINFO, POBJECT);

// NV_VIDEO_SCALER (class64)
static RM_STATUS videoCreateScalerObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyScalerObj(PHWINFO, POBJECT);

// NV_VIDEO_COLOR_KEY (class65)
static RM_STATUS videoCreateColorKeyObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyColorKeyObj(PHWINFO, POBJECT);

// NVXX_VIDEO_OVERLAY
static RM_STATUS videoCreateOverlayObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *, VOID *);
static RM_STATUS videoDestroyOverlayObj(PHWINFO, POBJECT);

//
// Class lock macros (video engine allocations are per-device).
//
#define VIDEOCLASSLOCK_ISSET(pdev,bit)  (pDev->Video.ClassLocks & (1 << bit))
#define VIDEOCLASSLOCK_SET(pdev,bit)    (pDev->Video.ClassLocks |= (1 << bit))
#define VIDEOCLASSLOCK_CLEAR(pdev,bit)  (pDev->Video.ClassLocks &= ~(1 << bit))

//
// videoCreateObj
//
// Top-level create routine for video engine classes.
//
RM_STATUS videoCreateObj
(
    VOID*   pDevHandle,
    PCLASSOBJECT ClassObject,
    U032    Name,
    POBJECT *Object,
    VOID*   pCreateParms
)
{
    PHWINFO         pDev = (PHWINFO) pDevHandle;
    RM_STATUS       status = RM_OK;
    PCLASS          pClass = ClassObject->Base.ThisClass;
    U032            lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateObj\r\n");

    //
    // Check allocation restrictions.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        if (VIDEOCLASSLOCK_ISSET(pDev, lockBit))
            return (RM_ERR_ILLEGAL_OBJECT);
        VIDEOCLASSLOCK_SET(pDev, lockBit);
    }

    //
    // Invoke class-specific create routine.    
    //
    switch (pClass->Type)
    {
        case NV_PATCHCORD_VIDEO:
            status = videoCreatePatchcordObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_SINK:
            status = videoCreateSinkObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_COLORMAP:
            status = videoCreateColormapObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = videoCreateFromMemoryObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_SCALER:
            status = videoCreateScalerObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_COLOR_KEY:
            status = videoCreateColorKeyObj(pDev, ClassObject, Name, Object);
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoCreateOverlayObj(pDev, ClassObject, Name, Object, pCreateParms);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    if (status != RM_OK)
    {
        if (lockBit != NO_LOCK)
            VIDEOCLASSLOCK_CLEAR(pDev, lockBit);
        return (status); 
    }

    return (RM_OK);
}

RM_STATUS videoDestroyObj
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    PHWINFO             pDev = (PHWINFO) pDevHandle;
    RM_STATUS           status = RM_OK;
    PCOMMONOBJECT       pCommonObject;
    PCLASS              pClass;
    U032                lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Clear per-device allocation lock bit if applicable.
    //
    pClass = Object->ThisClass;
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        // ASSERT(VIDEOCLASSLOCK_ISSET(pDev, lockBit));
        VIDEOCLASSLOCK_CLEAR(pDev, lockBit);
    }

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // And finally delete the object itself    
    //
    switch (pClass->Type)
    {
        case NV_PATCHCORD_VIDEO:
            status = videoDestroyPatchcordObj(pDev, Object);
            break;
        case NV_VIDEO_SINK:
            status = videoDestroySinkObj(pDev, Object);
            break;
        case NV_VIDEO_COLORMAP:
            status = videoDestroyColormapObj(pDev, Object);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = videoDestroyFromMemoryObj(pDev, Object);
            break;
        case NV_VIDEO_SCALER:
            status = videoDestroyScalerObj(pDev, Object);
            break;
        case NV_VIDEO_COLOR_KEY:
            status = videoDestroyColorKeyObj(pDev, Object);
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoDestroyOverlayObj(pDev, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }
    return (status);
}

//----------------------------------------------------------------------
// Video patchcord create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreatePatchcordObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS status;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreatePatchcordObj\r\n");

    //
    // NV_PATCHCORD_VIDEO requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOPATCHCORD));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    ((PVIDEOPATCHCORD)*Object)->FanOut      = 0;
    ((PVIDEOPATCHCORD)*Object)->Source      = NULL;
    for (i = 0; i < MAX_GRPATCH_FANOUT; i++)
        ((PVIDEOPATCHCORD)*Object)->Destination[i] = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOPATCHCORD)*Object)->CBase, 
                                      ((PVIDEOPATCHCORD)*Object)->CBase.ChID, 
                                      ((PVIDEOPATCHCORD)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroyPatchcordObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyPatchcordObj\r\n");

    //
    // NV_PATCHCORD_VIDEO requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video sink create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateSinkObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    U032 i;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateSinkObj\r\n");

    //
    // NV_VIDEO_SINK requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOSINKOBJECT));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    for (i = 0; i < MAX_GRPATCH_INPUT; i++)
        ((PVIDEOSINKOBJECT)*Object)->VideoInput[i] = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOSINKOBJECT)*Object)->CBase, 
                                      ((PVIDEOSINKOBJECT)*Object)->CBase.ChID, 
                                      ((PVIDEOSINKOBJECT)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroySinkObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroySinkObj\r\n");

    //
    // NV_VIDEO_SINK requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video colormap create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateColormapObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    U032 i;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateColormapObj\r\n");

    //
    // NV_VIDEO_COLORMAP requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOCOLORMAPOBJECT));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    ((PVIDEOCOLORMAPOBJECT)*Object)->VideoInput  = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->VideoOutput = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->ColorFormat = INVALID_COLOR_FORMAT;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Xlate       = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Start       = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Length      = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->DirtyStart  = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->DirtyLength = 0;
    for (i = 0; i < 256; i++)
        ((PVIDEOCOLORMAPOBJECT)*Object)->ColorMap[i] = (i << 16) | (i << 8) | i;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOCOLORMAPOBJECT)*Object)->CBase, 
                                      ((PVIDEOCOLORMAPOBJECT)*Object)->CBase.ChID, 
                                      ((PVIDEOCOLORMAPOBJECT)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroyColormapObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyColormapObj\r\n");

    //
    // NV_VIDEO_COLORMAP requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);
    
    // null out the color map object cached in pDev upon destruction
    if ((POBJECT)pDev->colormapObjectToNotify == Object)
    {
        pDev->colormapObjectToNotify = NULL;
    }

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video from memory create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateFromMemoryObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PCLASS              pClass = ClassObject->Base.ThisClass;
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U008                *bytePtr;
    U032                i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateFromMemoryObj\r\n");

    //
    // Create the NV_VIDEO_FROM_MEMORY object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOFROMMEMOBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidFromMem;
    for (i = 0; i < sizeof (VIDEOFROMMEMOBJECT); i++)
       *bytePtr++ = 0;

    //
    // Setup any specific initialization values.
    //
    pVidFromMem->InitState               = 0;
    pVidFromMem->BBuffer[0].State        = BUFFER_IDLE;
    pVidFromMem->BBuffer[1].State        = BUFFER_IDLE;
    pVidFromMem->VBlankNotify[0].Pending = FALSE;
    pVidFromMem->VBlankNotify[1].Pending = FALSE;

    //
    // Be sure to clear pending vblank notifies
    //
    for (i=0;i<2;i++)
    {
        pDev->Video.class63VBlankCount[i] = 0;
        pDev->DBclass63VBlankList[i] = NULL;
    }

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidFromMem->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidFromMem->CBase.ChID, pVidFromMem->CInstance, pClass->Type, &pVidFromMem->HalObject);
    if (status)
        return (status);

    //
    // HACK (scottl): There are several places in the RM that assume
    // the struct _def_common_object is at the head of class-specific
    // data structures like struct _def_video_from_memory_object
    // (most notably the call to fifoAddObject after we return from
    // here).  In order to allow these to continue to work, we do
    // the following completely bogus initialization.
    //
    (*Object)->Name          = UserName;
    (*Object)->Class         = ClassObject->Base.ThisClass;
    (*Object)->ThisClass     = ClassObject->Base.ThisClass;
    (*Object)->ChID          = ClassObject->Base.ChID;
    (*Object)->NotifyXlate   = NULL;
    (*Object)->NotifyAction  = 0;
    (*Object)->NotifyTrigger = FALSE;
    (*Object)->NotifyEvent   = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidFromMem->CBase, 
                                      pVidFromMem->CBase.ChID, 
                                      pVidFromMem->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyFromMemoryObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U032                i;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyFromMemoryObj\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_FROM_MEMORY object.
    //

    //
    // Halt transfers.
    //
    class63StopTransfer(pDev, Object, 0, 0, 0);

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidFromMem->CBase.ChID, pVidFromMem->CInstance, Object->ThisClass->Type, &pVidFromMem->HalObject);

    //
    // Be sure to clear pending vblank notifies
    //
    for (i=0;i<2;i++)
    {
        pDev->Video.class63VBlankCount[i] = 0;
        pDev->DBclass63VBlankList[i] = NULL;
    }

    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pVidFromMem)
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidFromMem->CBase, pVidFromMem->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video scaler create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateScalerObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    PCLASS              pClass = ClassObject->Base.ThisClass;
    RM_STATUS           status;
    PVIDEOSCALEROBJECT  pVidScaler;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateScalerObj\r\n");

    //
    // Create the NV_VIDEO_SCALER object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOSCALEROBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidScaler->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidScaler->CBase.ChID, pVidScaler->CInstance, pClass->Type, &pVidScaler->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidScaler->CBase, 
                                      pVidScaler->CBase.ChID, 
                                      pVidScaler->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyScalerObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyScalerObj\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_SCALER object.
    //

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidScaler->CBase.ChID, pVidScaler->CInstance, Object->ThisClass->Type, &pVidScaler->HalObject);

    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidScaler->CBase, pVidScaler->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}


//----------------------------------------------------------------------
// Video colorkey create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateColorKeyObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    PCLASS                  pClass = ClassObject->Base.ThisClass;
    RM_STATUS               status;
    PVIDEOCOLORKEYOBJECT    pVidColorKey;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateColorKeyObj\r\n");

    //
    // Create the NV_VIDEO_COLOR_KEY object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOCOLORKEYOBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidColorKey->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidColorKey->CBase.ChID, pVidColorKey->CInstance, pClass->Type, &pVidColorKey->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidColorKey->CBase, 
                                      pVidColorKey->CBase.ChID, 
                                      pVidColorKey->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyColorKeyObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyColorKeyObj\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_COLOR_KEY object.
    //

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidColorKey->CBase.ChID, pVidColorKey->CInstance, Object->ThisClass->Type, &pVidColorKey->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidColorKey->CBase, pVidColorKey->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video overlay create/destroy routines.
//----------------------------------------------------------------------

//
// Return head number specified in alloc request.
//
static U032 videoGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
	RM_STATUS	status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;
        
    switch (pClass->Type)
    {
        case NV10_VIDEO_OVERLAY:
        {
			NV07C_ALLOCATION_PARAMETERS Class07cParams;
			status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
			if (status != RM_OK)
				return 0;

			Head = Class07cParams.logicalHeadId;
            break;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

static RM_STATUS videoCreateOverlayObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object,
    VOID* pCreateParms
)
{
    RM_STATUS                   status;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoCreateOverlayObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_OVERLAY_OBJECT));
    if (status)
        return (status);
        
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)*Object;

    //
    // Associate the head for the Video Scalar
    //
    pDev->Video.HalInfo.Head = videoGetHead(pClass, pCreateParms);
    if (pDev->Video.HalInfo.Head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: videoCreateOverlayObj: invalid logical head number ", pDev->Video.HalInfo.Head);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }


    if (IsNV11(pDev)) {
        AssocVideoScalar(pDev, pDev->Video.HalInfo.Head);
    }

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pOverlayObject;
    for (i = 0; i < sizeof (VIDEO_OVERLAY_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, pClass->Type, &pOverlayObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pOverlayObject->CBase, 
                                      pOverlayObject->CBase.ChID, 
                                      pOverlayObject->CInstance);
    if (status != RM_OK)
    {
        nvHalVideoFree(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, pClass->Type, (VOID *)&pOverlayObject->HalObject);
        osFreeMem(*Object);
    }

    return (status);
}

static RM_STATUS videoDestroyOverlayObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         Head = 0;  // TO DO: add parameter or extract from object

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: videoDestroyOverlayObj\r\n");

    VidLutCurDac.Head = Head;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, Object->ThisClass->Type, &pOverlayObject->HalObject);

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    //
    // Clear active overlay object field is applicable.
    //
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pOverlayObject)
    {
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;
        pDev->Video.HalInfo.Enabled = 0;
    }

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pOverlayObject->CBase, pOverlayObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks if chip requires it.
    //
    if (!IsNV10orBetter(pDev)) {
        VBlankDeleteCallback(pDev, 0, &(pOverlayObject->Overlay[0].OverlayCallback));
        VBlankDeleteCallback(pDev, 0, &(pOverlayObject->Overlay[1].OverlayCallback));
    }

    return (osFreeMem(Object));
}

//-----------------------------------------------------------------------
// Video exception handling.
//-----------------------------------------------------------------------

//
// Service exception on class63 (NV_VIDEO_FROM_MEMORY) object transfer.
//
V032 videoFromMemService
(
    PHWINFO pDev,
    POBJECT pObject
)
{
    PVIDEOFROMMEMOBJECT pVidFromMemObj;
    VOID *pVidHalObj;
    U032 buffsPending;
    V032 intrStatus = 0;
    U032 i;

    //
    // Allow HAL chance to quiesce the video HW even if we don't
    // have an active overlay object.
    //
    pVidFromMemObj = (PVIDEOFROMMEMOBJECT)pObject;
    if (pVidFromMemObj)
        pVidHalObj = (VOID *)&pVidFromMemObj->HalObject;
    else
        pVidHalObj = NULL;

    //
    // Get buffer status first.
    //
    (void) nvHalVideoGetEventStatus(pDev, NV_VIDEO_FROM_MEMORY, pVidHalObj, &buffsPending, &intrStatus);

    //
    // If video isn't enabled, then this interrupt was spurious.
    //
    if (!pDev->Video.HalInfo.Enabled)
        return intrStatus;

    //
    // Handle notify requests if a buffer needs servicing.
    //
    for (i = 0; i < MAX_OVERLAY_BUFFERS; i++)
    {
        if (buffsPending & (1 << i))
        {
            // Hardware buffer 0 completed. 
            notifyFillNotifierArray( pDev, pVidFromMemObj->BufferObj.Base.NotifyXlate, 
                                     0, 
                                     0, 
                                     0, 
                                     NVFF8_NOTIFIERS_IMAGE_SCAN(i) );
                    
#ifdef DEBUG_TIMING            
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "Buffer 0 Completed. \n");
            vmmOutDebugString("0N");
#endif // DEBUG_TIMING                
                    
            //
            // Do any OS specified action related to this notification.
            //
            if (pVidFromMemObj->BBuffer[i].NotifyAction)
            {
                osNotifyEvent(pDev, (POBJECT)pVidFromMemObj,
                              NVFF8_NOTIFIERS_IMAGE_SCAN(i),
                              0, 
                              1, 
                              RM_OK, 
                              pVidFromMemObj->BBuffer[i].NotifyAction);
            }
        }
    }

    //
    // Now call into HAL to finish processing exception (in this case,
    // queue up next buffer for processing).
    //
    (void) nvHalVideoServiceEvent(pDev, NV_VIDEO_FROM_MEMORY, pVidHalObj, buffsPending, &intrStatus);

    return intrStatus;
}

//
// Service exceptions on class0XX (NVXX_VIDEO_OVERLAY) object transfers.
//
V032 videoOverlayService
(
    PHWINFO pDev,
    POBJECT pObject
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    VOID *pVidHalObj;
    U032 buffsPending, class;
    V032 intrStatus = 0;
    U032 i;

    //
    // Allow HAL chance to quiesce the video HW even if we don't
    // have an active overlay object.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)pObject;
    if (pOverlayObject)
    {
        class = pObject->ThisClass->Type;
        pVidHalObj = (VOID *)&pOverlayObject->HalObject;
    }
    else
    {
        //
        // If there is no active video object, the class will
        // be ignored anyway.   
        //
        class = 0;
        pVidHalObj = NULL;
    }

    //
    // Get buffer status first.
    //
    (void) nvHalVideoGetEventStatus(pDev, class, pVidHalObj, &buffsPending, &intrStatus);

    //
    // If video isn't enabled, then this interrupt was spurious.
    //
    if (!pDev->Video.HalInfo.Enabled)
        return intrStatus;

    //
    // Handle notify requests if a buffer needs servicing.
    //
    for (i = 0; i < MAX_OVERLAY_BUFFERS; i++)
    {
        if (buffsPending & (1 << i))
        {
            // Hardware buffer completed. 
            notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                    0, // info32
                                    0, // info16
                                    RM_OK, 
                                    NV047_NOTIFIERS_SET_OVERLAY(i));

#ifdef DEBUG_TIMING            
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Buffer Completed. \n");
            vmmOutDebugString("1N");
#endif // DEBUG_TIMING

            //
            // Do any OS specified action related to this notification.
            //
            if (pOverlayObject->Overlay[i].NotifyAction)
            {
                osNotifyEvent(pDev, (POBJECT)pOverlayObject,
                              NV047_NOTIFIERS_SET_OVERLAY(i),
                              0, // Method
                              0, // Data
                              RM_OK, 
                              pOverlayObject->Overlay[i].NotifyAction);
            }
        }
    }

    //
    // Now call into HAL to finish processing exception (in this case,
    // queue up next buffer for processing).
    //
    (void) nvHalVideoServiceEvent(pDev, class, pVidHalObj, buffsPending, &intrStatus);

    return intrStatus;
}

//
// Update the POINT_OUT on behalf DDraw when panning the desktop
//
VOID videoUpdateWindowStart
(
    PHWINFO pDev,
    S016 deltaX,
    S016 deltaY
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    U016 pointoutX, pointoutY;
    U032 Data;
    RM_STATUS status;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject;

    if (pOverlayObject->CBase.ThisClass->Type != NV10_VIDEO_OVERLAY)
        return;    // only applicable to class07a

    if (!deltaX && !deltaY)
        return;    // no delta to apply

    // We assume buffer0 and buffer1 are using the same POINT_OUT values
    RM_ASSERT(pOverlayObject->HalObject.Overlay[0].PointOut_x == 
              pOverlayObject->HalObject.Overlay[1].PointOut_x);
    RM_ASSERT(pOverlayObject->HalObject.Overlay[0].PointOut_y == 
              pOverlayObject->HalObject.Overlay[1].PointOut_y);

    // Apply delta x,y to class07a's current point out x,y
    pointoutX = (S016)pOverlayObject->HalObject.Overlay[0].PointOut_x + deltaX;
    pointoutY = (S016)pOverlayObject->HalObject.Overlay[0].PointOut_y + deltaY;

    Data = DRF_NUM(07A, _SET_OVERLAY_POINT_OUT, _X, pointoutX) |
           DRF_NUM(07A, _SET_OVERLAY_POINT_OUT, _Y, pointoutY);
    //
    // This method doesn't wait for the buffer to be released by the HW
    // and updates both POINT_OUT(0) and POINT_OUT(1) to the same value.
    //
    (VOID) nvHalVideoMethod(pDev,
                            NV10_VIDEO_OVERLAY,
                            (VOID *)&pOverlayObject->HalObject,
                            NV07A_SET_OVERLAY_POINT_OUT_A,
                            Data,
                            &status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\vblank\nv\vblank.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Interrupt Routine ****************************\
*                                                                           *
* Module: VBLANK.C                                                          *
*   Vertibal blank interrupt servicing is handled here.  This is a true     *
*   interrupt time call so no os services are available.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <vblank.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h


// external interfaces
VOID VBlankAddCallback(PHWINFO, U032, PVBLANKCALLBACK);
VOID VBlankDeleteCallback(PHWINFO, U032, PVBLANKCALLBACK);
U032 VBlankPending(PHWINFO);


RM_STATUS mthdColormapDirtyNotify(PHWINFO, RM_STATUS);

static VOID VBlankProcessCallbacks
(
    PHWINFO pDev,
    U032 Head
)
{
    PVBLANKCALLBACK Callback;
    PVBLANKCALLBACK NextCallback;
    PVBLANKCALLBACK *PrevCallback;
    PDACCRTCINFO pDacCrtcInfo;


    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];
    Callback     = (PVBLANKCALLBACK)pDacCrtcInfo->VBlankCallbackList;
    PrevCallback = (PVBLANKCALLBACK *)&pDacCrtcInfo->VBlankCallbackList;

    while (Callback) {
        NextCallback   = Callback->Next;
        Callback->Next = NULL;

        // Execute this on a particular VBlankCount?
        if ((Callback->Flags & CALLBACK_FLAG_SPECIFIED_VBLANK_COUNT) &&
            (Callback->VBlankCount != pDacCrtcInfo->VBlankCounter)) {
            PrevCallback = &Callback->Next;     // skip it
        } else {
            // Call the function now
            if (Callback->Proc) {
                Callback->Proc(pDev,
                               Callback->Object,
                               Callback->Param1,
                               Callback->Param2,
                               Callback->Status);
            }
            *PrevCallback = NextCallback;       // unlink it
        }
        Callback = NextCallback;
    }
}


VOID VBlankAddCallback
(
    PHWINFO         pDev, 
    U032            Head,
    PVBLANKCALLBACK Callback
)
{

    RM_ASSERT(Head <= MAX_CRTCS);

    // Make sure VBlank is enabled on this head.
    if ((pDev->Dac.CrtcInfo[Head].StateFlags & DAC_CRTCINFO_VBLANK_ENABLED) == 0)
    {
        DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, Head);
        DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, Head);
        pDev->Dac.CrtcInfo[Head].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    }

    Callback->Next = (PVBLANKCALLBACK)pDev->Dac.CrtcInfo[Head].VBlankCallbackList;
    pDev->Dac.CrtcInfo[Head].VBlankCallbackList = (VOID_PTR)Callback;
}


//
// This routine can be called from an API entry point.
//
// For winnt4/win2k the necessary locking is already preventing a conflict
// with the VBlank handler running concurrently. For win9x, make sure the
// interrupt is disable before pulling callbacks off the list.
//
VOID VBlankDeleteCallback
(
    PHWINFO         pDev,
    U032            Head,
    PVBLANKCALLBACK Callback
)
{
    PDACCRTCINFO pDacCrtcInfo;
    U032 enable;


    RM_ASSERT(Head <= MAX_CRTCS);
    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];

    // Disable VBlank while we scan/process the callback list

    enable = DAC_REG_RD_DRF(_PCRTC, _INTR_EN_0, _VBLANK, Head);
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _DISABLED, Head);

    // Search the list and remove this Callback entry
    if (pDacCrtcInfo->VBlankCallbackList == (VOID_PTR)Callback) {
        //
        // Found it.
        // Should the callback be executed as part of the object destroy
        // (safe to do, since we already hold the necessary lock).
        //
        if (Callback->Proc && 
            (Callback->Flags & CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP)) {
            // Force it to appear to be on the correct VBlankCount
            Callback->VBlankCount = pDacCrtcInfo->VBlankCounter;
            Callback->Proc(pDev,
                           Callback->Object,
                           Callback->Param1,
                           Callback->Param2,
                           Callback->Status);
        }
        pDacCrtcInfo->VBlankCallbackList = (VOID_PTR)Callback->Next;
    } else {
        PVBLANKCALLBACK PrevCallback = (PVBLANKCALLBACK)pDacCrtcInfo->VBlankCallbackList;

        while (PrevCallback) {
            if (PrevCallback->Next == Callback) {
                //
                // Found it.
                // Should the callback be executed as part of the object destroy
                // (safe to do, since we already hold the necessary lock).
                //
                if (Callback->Proc && 
                    (Callback->Flags & CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP)) {
                    // Force it to appear to be on the correct VBlankCount
                    Callback->VBlankCount = pDacCrtcInfo->VBlankCounter;
                    Callback->Proc(pDev,
                                   Callback->Object,
                                   Callback->Param1,
                                   Callback->Param2,
                                   Callback->Status);
                }
                PrevCallback->Next = Callback->Next;
                break;
            }
            PrevCallback = PrevCallback->Next;
        }
    }
    Callback->Next = NULL;

    // Restore VBlank enable
    DAC_FLD_WR_DRF_NUM(_PCRTC, _INTR_EN_0, _VBLANK, enable, Head);
}


//
// VBlankUpdateFlip
//
static U032 VBlankUpdateFlip
(
    PHWINFO         pDev,
    U032            Head
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U008 Cr07, Cr25;
    U008 lock;
    U016 DisplayEnd, Scanline;
    U032 rmFinish = FALSE;
#ifdef NTRM
    U008 crtc_color, crtc_index;
#endif

    //
    // Initialize logical head so that the HAL will know which
    // crtc to program up.
    //
    vidLutCurDacHalObj.Head = Head;

#ifdef NTRM
    // XXX temporarily NT only (this needs to be made common)
    crtc_color = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01);    // color or mono?
    if (crtc_color)
        crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);
    else
        crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);
#endif

    // Unlock CRTC extended regs
    lock = UnlockCRTC(pDev, Head);

	//
    // Update framebuffer address?
    //
	if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_FLIP)
	{
        pDev->Framebuffer.FlipFrom = pDev->Framebuffer.Current;
        pDev->Framebuffer.Current  = pDev->Framebuffer.FlipTo;
        if (!pDev->Vga.Enabled)
        {
            //
            // Make sure we're really in blank
            //
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
                    ;
            else // !? Easy way isn't working with flat panel. Use scanline counter instead.
            {
                // Compare scanline count to display end
                CRTC_RD(NV_CIO_CR_VDE_INDEX, DisplayEnd, Head);
                CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
                CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
                if (Cr07 & 2) DisplayEnd |= 0x100;
                if (Cr07 & 0x40) DisplayEnd |= 0x200;
                if (Cr25 & 2) DisplayEnd |= 0x400;                    

                nvHalDacGetRasterPosition(pDev, &Scanline, (VOID*) &vidLutCurDacHalObj);
                while (Scanline < DisplayEnd)
                {
                    nvHalDacGetRasterPosition(pDev, &Scanline, (VOID*) &vidLutCurDacHalObj);
                }
            }

            //
            // Program the new start address; this will latch at the end of blank
            //
#ifdef	STEREO_SUPPORT
            if (!pDev->pStereoParams || !(pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED))
#endif	//STEREO_SUPPORT
                nvHalDacSetStartAddr(pDev, pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current], &vidLutCurDacHalObj);
#ifdef  STEREO_SUPPORT
            else
                __asm int 3
#endif	//STEREO_SUPPORT

        }
        pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_BUFFER_FLIP;       
        pDev->Framebuffer.FinishFlags |=  FINISH_HWINFO_BUFFER_FLIP;
        rmFinish = TRUE;
	}

#ifdef	STEREO_SUPPORT
    if (pDev->pStereoParams &&
        pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED &&
        pDev->pStereoParams->FlipOffsets[3][0] != 0xFFFFFFFF)
    {
        unsigned long *pBufferOffset;
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[0][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[0][0];
        else
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[1][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[1][0];
        else
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[2][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[2][0];
        else
        {
            pDev->pStereoParams->FlipOffsets[3][1] = pDev->pStereoParams->FlipOffsets[3][0];
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[3][0];
            //The only explanation that the last flip offset doesn't match one of ours is
            //that it happened upon someone else request. This is most likely a video mode
            //restore taking place when an application ends. The safest strategy here would
            //be to force stereo off.
            pDev->pStereoParams->Flags = 0;
        }
        pDev->pStereoParams->EyeDisplayed ^= 1;
        nvHalDacSetStartAddr(pDev, pBufferOffset[pDev->pStereoParams->EyeDisplayed], &vidLutCurDacHalObj);
		if (pDev->pStereoParams->Flags & STEREOCFG_ELSADDC)
		{
			U008 DDCVal;
			DDCVal = pDev->pStereoParams->EyeDisplayed ? 0x1 : 0x11;
			CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, DDCVal, Head);
		}
    }
#endif  //STEREO_SUPPORT

    // Relock CRTC extended regs
    RestoreLock(pDev, Head, lock);

#ifdef NTRM
    //
	// Restore crtc index register
    //
	if (crtc_color)
		REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);
	else
		REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);
#endif

    return rmFinish;
}

//
// VBlankUpdatePalette
//
static VOID VBlankUpdatePalette
(
    PHWINFO         pDev,
    U032            Head
)
{
    U032 i, j, k;
    U016 Width, Height;
    U016  color;
    U008  test, mask;
    U032  color32;
    U008  color8;
    U008  *lpColorMask;

#define   COLOR_OFFSET    32*4    // offset of XOR mask from start of buffer (= size of and mask)

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_COLORMAP)
    {
        if (!pDev->Vga.Enabled)
        {
            if (pDev->Dac.HalInfo.Depth == 8)
                dacProgramLUT(pDev, Head, &pDev->Dac.Palette[0], 256);
            else
                dacProgramLUT(pDev, Head, &pDev->Dac.Gamma[0], 256);

            // JJV- Update the cursor to the new DAC values.
            // Read the saved DAC indices from nvinfo ... the cursor
            // indices are saved after each update.
            // Generate a cursor image update to force a restore on
            // the cursor palette. 
            if ( (pDev->Dac.HalInfo.Depth == 8)  && 
                 (pDev->Dac.CursorBitDepth == 8) &&
                 (pDev->Dac.CrtcInfo[Head].CursorType == DAC_CURSOR_FULL_COLOR_XOR) )
            {
                lpColorMask = pDev->Dac.SavedCursor + COLOR_OFFSET;
                Width=Height=32;
                for (i = 0; i < Height; i++)
                {
                    for (j = 0; j < (U032)Width/8; j++)
                    {
                        mask = pDev->Dac.SavedCursor[i * sizeof(U032) + j]; // get 8 AND bits                                
                        test = 0x80;
                        for (k = 0; k < 8; k++, test >>=1)  // get 8 pixels and write 8 words
                        {
                            color8 = lpColorMask[i*32+j*8+k];   // get 8 bits of color
                            color32 = pDev->Dac.Palette[color8];     // look up color (24 bits)
                            // pack 8-8-8 into 5-5-5, using most sig bits 
                            color =  (U016)((color32 >> 9) & 0x7c00);   // red
                            color |= (color32 >> 6) & 0x03e0;           // green
                            color |= (color32 >> 3) & 0x001f;           // blue
                            if (!(test & mask))
                                color |= 0x8000;                            
                            pDev->Dac.CursorColorImage[i][j*8+k] = color;
                        }
                    }
                }    
                pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;
            }
                
            // We have just updated the colormap. Notify the object.
            mthdColormapDirtyNotify(pDev, RM_OK);
            pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_COLORMAP;
        }
    }
}

//
// VBlankUpdateVideoScaler
//
static U032 VBlankUpdateVideoScaler
(
    PHWINFO         pDev,
    U032            Head
)
{
    U032 rmFinish = FALSE;

    //
    // Update the video scaler settings
    //
    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_DUALSURFACE)   // if we are using the scalar for dual surface, don't change it
    {
    	if (pDev->Video.HalInfo.UpdateFlags & UPDATE_HWINFO_VIDEO_ENABLE)
    	{
            if (pDev->Video.HalInfo.Enabled)
                nvHalVideoControl(pDev, VIDEO_CONTROL_ENABLE);
            else
                nvHalVideoControl(pDev, VIDEO_CONTROL_DISABLE);
            pDev->Video.HalInfo.UpdateFlags &= ~UPDATE_HWINFO_VIDEO_ENABLE;
            pDev->Video.HalInfo.FinishFlags |=  FINISH_HWINFO_VIDEO_ENABLE;
            rmFinish = TRUE;
    	}
    } // dualsurface    
    else
    {
    	if (pDev->Video.HalInfo.UpdateFlags & UPDATE_HWINFO_VIDEO_ENABLE)   // if dual surf, set TV for YUV
    	{
            if (pDev->Video.HalInfo.Enabled)
                FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _VS_PIXFMT, _YUV);
            else
                FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _VS_PIXFMT, _565);
            pDev->Video.HalInfo.UpdateFlags &= ~UPDATE_HWINFO_VIDEO_ENABLE;
            pDev->Video.HalInfo.FinishFlags |=  FINISH_HWINFO_VIDEO_ENABLE;
            rmFinish = TRUE;
        }                
    }

    return rmFinish;
}

//
// VBlankUpdateCursor
//
// Handle win9x cursor updates.
//
static VOID VBlankUpdateCursor
(
    PHWINFO         pDev,
    U032            Head
)
{
    U008 crtc_color, crtc_index;
    PDACCRTCINFO pDacCrtcInfo;
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;

    VidLutCurDac.Head = Head;

    //
    // Save away the current CRTC index values.
    //
    // This should be in VBlank common to all callbacks, but placing it there
    // caused problems at boot time (which are still a mystery). For now, make
    // the save/restore local to the cursor update callback.
    //
    crtc_color = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01);    // color or mono?
    if (crtc_color)
        crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);
    else
        crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);

    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];

    // position cursor?
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_POS)
    {
        dacProgramCursorPosition(pDev, Head,
                                 pDacCrtcInfo->CursorPosX,
                                 pDacCrtcInfo->CursorPosY);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_POS;
    }

#ifdef WIN31	// This is the old way of updating the cursor image

    // update glyph?
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_IMAGE)
    {
        U032 i, j;

        // The image was copied into the pDev->structure in the API call.
        // We need to copy into the Instance memory, where the DAC can find it.

        // The 2k image has been formatted by the OS module NVSYS.C, 
        // The buffer is a 32x32 array of words. Each word represents a pixel.
        for (i = 0; i < 32; i++)	
            for (j = 0; j < 32; j+=2)
            {
                U032 data;
                // grab two words at a time and stuff them in instance mem
                data = pDacCrtcInfo->CursorColorImage[i][j+1];
                data = (data << 16) | pDacCrtcInfo->CursorColorImage[i][j];
                INST_WR32(pDacCrtcInfo->CursorImageInstance, i*64+j*2, data);
            }
	}
#else
    // The display driver massages the image and hands us a pointer (to image in framebuffer).
    // This is the new way of manipulating the cursor image. 
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW)
    {
        nvHalDacProgramCursorImage(pDev,
                              pDacCrtcInfo->CursorOffset, 
                              DAC_ASI_FRAMEBUFFER, 
                              pDacCrtcInfo->CursorWidth, pDacCrtcInfo->CursorHeight,
                              pDacCrtcInfo->CursorColorFormat,
                              (VOID*) &VidLutCurDac);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    }
#endif
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_ENABLE)
    {
        // Enable the cursor.
        dacEnableCursor(pDev, Head);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
    }

    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_DISABLE)
    {
        // Disable the cursor.
        dacDisableCursor(pDev, Head);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
    }

    //
	// Restore crtc index register
    //
	if (crtc_color)
		REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);
	else
		REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);
}

//
// VBlankUpdateImageOffsetFormat
//
// Handle win9x panning start address updates. This could be made to be
// a generalized backdoor taking method offsets and data.
//
static VOID VBlankUpdateImageOffsetFormat
(
    PHWINFO         pDev,
    U032            Head
)
{
    PDACCRTCINFO pDacCrtcInfo;
    RM_STATUS status;

    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT)
    {
        POBJECT Object;

        // Given the object handle, find the POBJECT pointer
        status = fifoSearchObject(pDev,
                                  pDacCrtcInfo->ObjectHandle,
                                  pDacCrtcInfo->ChID,
                                  &Object);
        if (status != RM_OK) {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,
                                   "NVRM: VBlankUpdateImageOffsetFormat: bad object handle ",
                                    pDacCrtcInfo->ObjectHandle);
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }
#if 0
        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_PAN_OFFSET == NV049_SET_PAN_OFFSET) &&
                  (NV049_SET_PAN_OFFSET == NV067_SET_PAN_OFFSET) &&
                  (NV067_SET_PAN_OFFSET == NV07C_SET_PAN_OFFSET));

        // Call the SET_IMAGE_OFFSET method
        status = classSoftwareMethod(pDev, Object,
                                     NV07C_SET_PAN_OFFSET, 
                                     pDacCrtcInfo->ImageOffset);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }
#else
        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_IMAGE_OFFSET(0) == NV049_SET_IMAGE_OFFSET(0)) &&
                  (NV049_SET_IMAGE_OFFSET(0) == NV067_SET_IMAGE_OFFSET(0)) &&
                  (NV067_SET_IMAGE_OFFSET(0) == NV07C_SET_IMAGE_OFFSET(0)));

        // Call the SET_IMAGE_OFFSET method
        status = classSoftwareMethod(pDev, Object,
                                     NV046_SET_IMAGE_OFFSET(0),    
                                     pDacCrtcInfo->ImageOffset);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }
#endif
        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_IMAGE_FORMAT(0) == NV049_SET_IMAGE_FORMAT(0)) &&
                  (NV049_SET_IMAGE_FORMAT(0) == NV067_SET_IMAGE_FORMAT(0)) &&
                  (NV067_SET_IMAGE_FORMAT(0) == NV07C_SET_IMAGE_FORMAT(0)));

        // Call the SET_IMAGE_FORMAT method
        status = classSoftwareMethod(pDev, Object,
                                     NV046_SET_IMAGE_FORMAT(0),    
                                     pDacCrtcInfo->ImageFormat);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }

        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
    }
}


VOID hotkeyAddEvent(PHWINFO pDev, U032 event, U032 status)
{
    U032 temp;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Adding event:", event);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent:       status:", status);

    temp = (pDev->HotKeys.queueHead + 1) % NV_HOTKEY_EVENT_QUEUE_SIZE;

    //Don't wrap past tail if there's a backlog.  It may actually
    // be better to keep the newer events rather than the older ones,
    // but that raises queue access coherency issues.  This is a
    // safe way to handle an event that should never happen anyway.
    if (temp == pDev->HotKeys.queueTail) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Queue is full.\n\r");
        return;
    }

    pDev->HotKeys.Queue[pDev->HotKeys.queueHead].event = event;
    pDev->HotKeys.Queue[pDev->HotKeys.queueHead].status = status;
    pDev->HotKeys.queueHead = temp;
}


//Mobile system feature: look for bits in our CR registers that indicate
// a keyboard Fn + key event has occured.  If so, we queue up the event
// so it can be serviced later.
VOID VBlankCheckHotKeys(PHWINFO pDev)
{
    U008 temp, newEvents, stateReg; //, stateChanges;
    U008 lock, head;
    U032 centering;

    //Workaround: loop over both heads.
    for (head = 0; head <= 1; head++) {

    lock = ReadCRTCLock(pDev, head);           //Back up lock state
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, head);    //Unlock CRTC extended regs

    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
    newEvents = temp & (NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);    //Only handle events we know about.

    CRTC_RD(NV_CIO_CRE_SCRATCH7__INDEX, stateReg, head);

    //DEBUG
    if (newEvents) {
        //Leave this printf for current debug purposes -- hotkeys are young yet.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Head:", head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4A register is now:", temp);
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, temp, head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4B register is now:", temp);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4C register is now:", stateReg);
        CRTC_RD(0x3B, temp, head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B register is now:", temp);
//        CRTC_RD(0x3B, temp, 1);
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register is now:", temp);
    }
    //DEBUG

    //Check if anything has changed:
    //Pressing a key may generate more than one event (e.g., disabling one display and enabling another)

    if (newEvents & NV_MOBILE_FLAG_DISPLAY_MASK) {

        temp = 0;
        if (stateReg & NV_MOBILE_DISPLAY_LCD_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD;
        }
        if (stateReg & NV_MOBILE_DISPLAY_CRT_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT;
        }
        if (stateReg & NV_MOBILE_DISPLAY_TV_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV;
        }
        if (stateReg & NV_MOBILE_DISPLAY_DFP_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP;
        }

//            if (stateChanges & (NV_MOBILE_DISPLAY_LCD_MASK | NV_MOBILE_DISPLAY_CRT_MASK
//                | NV_MOBILE_DISPLAY_TV_MASK | NV_MOBILE_DISPLAY_DFP_MASK )) {
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_ENABLE, temp);
//            }
    }

    if (newEvents & NV_MOBILE_FLAG_SCALE_MASK) {
//            if (stateChanges & NV_MOBILE_DISPLAY_SCALE_MASK) {
            centering = REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _MODE);
            if (centering == NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE) temp = NV_HOTKEY_STATUS_DISPLAY_SCALED;
            else if (centering == NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER) temp = NV_HOTKEY_STATUS_DISPLAY_CENTERED;
            else temp = NV_HOTKEY_STATUS_DISPLAY_NATIVE;
//                hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_CENTERING, (stateReg & NV_MOBILE_DISPLAY_SCALE_MASK)?1:0);
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_CENTERING, temp);
//            }
    }

        //Now reset the event flags we've handled.  We do this after we've actually handled
        // the events (not explicitly required at this point, but seems cleanest) and in the
        // smallest possible amount of time between re-reading the register and writing it.
    if (newEvents) {
//            pDev->HotKeys.reg4CShadow = (U032)stateReg;            //Update our shadow register

        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
        temp &= ~newEvents;    //Reset the events we will handle.
            // LPL: possible race here -- another SSF bit gets set during our read-mod-write window,
            // and is cleared by us unintentionally (that's why this window is made intentionally
            // as small as possible by re-reading the register)
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
    }

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, head); // Restore lock state

    }   //workaround: loop over both heads

}

//
// Service vertical blank interrupt.
//
VOID VBlank
(
    PHWINFO pDev
)
{
    PDACCRTCINFO pDacCrtcInfo;
    U032 pmc, pending;
    U032 head;
    U032 rmFinish;
    U032 i;
    U008 CrtcIndex;

#ifdef RM_STATS                    
    pDev->Framebuffer.ServiceCount++;
#endif
    rmFinish = FALSE;

    // Save the CRTC index reg, since we may have interrupted someone doing an access.
    CrtcIndex = REG_RD08(NV_PRMCIO_CRX__COLOR);
    //
    // We're here because at least one of the PCRTC bits is pending.
    // Read the NV_PMC_INTR_0 register to figure out which one(s).
    //
	pending = 0;
    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    for (head = 0; head < MAX_CRTCS; head++)
    {
        // Move on if this crtc's interrupt isn't pending...
        if ((pending & (1 <<  head)) == 0)
            continue;

        // Scanout address updates...
        //
        // Since class07c's SET_IMAGE_FORMAT queues a VBlank callback (which we'll
        // handle "immediately" in VBlankProcessCallbacks below) and has an ASSERT
        // on the VBlankCounter value, we'll handle this update before the counter
        // is incremented.
        //
        VBlankUpdateImageOffsetFormat(pDev, head);

        // This head needs servicing...
        pDacCrtcInfo = &pDev->Dac.CrtcInfo[head];

        pDacCrtcInfo->VBlankToggle = 0;
        pDacCrtcInfo->VBlankCounter++;
        pDacCrtcInfo->IsVBlank = TRUE;

        //
        // Head 0 still gets unique treatment for things driven
        // by the older NV_VIDE0_FROM_MEMORY class and family.
        //
        if (head == 0)
        {
            rmFinish |= VBlankUpdateFlip(pDev, head);
            class63VBlank(pDev);
            VBlankUpdatePalette(pDev, head);
            rmFinish |= VBlankUpdateVideoScaler(pDev, head);
        }

        // Cursor updates...
        VBlankUpdateCursor(pDev, head);

        // Callback list...
        VBlankProcessCallbacks(pDev, head);

        pDacCrtcInfo->IsVBlank = FALSE;
    }

    if (pDev->Power.MobileOperation && pDev->HotKeys.enabled)
        VBlankCheckHotKeys(pDev);

    //
    // Update service count if no RM processing required (RM will increment this in mcService).
    //
    if (!rmFinish)
    {
#ifdef RM_STATS                    
        pDev->Chip.ServiceCount++;
#endif
        //
        // If RM doesn't need to service VBLANK, clear VBLANK interrupt. It is possible to see more
        // than one VBLANK interrupt before the RM has a chance to service the first one. Make sure
        // to recalc the rmFinish result properly.
        //
        rmFinish = pDev->Framebuffer.FinishFlags;
        if (!rmFinish)
        {
            //
            // On really fast machines, VBlank may not get cleared before returning.
            //

            // Head 0 serviced...
            if (pending & 0x1)
            {
                do
                {
                    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);
                    i = REG_RD32(NV_PMC_INTR_0);
                } while (i & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)));
            }

            // Head 1 serviced...
            if (pending & 0x2)
            {
                do
                {
                    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 1);
                    i = REG_RD32(NV_PMC_INTR_0);
                } while (i & (DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)));
            }
        }
    }
    REG_WR08(NV_PRMCIO_CRX__COLOR, CrtcIndex);	// restore crtc index
}

//
// Return bitmask representing heads with pending
// vblank interrupts.
//
U032
VBlankPending
(
    PHWINFO pDev
)
{
    U032 pending = 0;

    //
    // TODO: call into HAL to get these.
    //
    if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)))
        pending |= 0x1;
    if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
        pending |= 0x2;

    return pending;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\video\nv4\vidnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV04.c                                                         *
*   The NV4 specific HAL VIDEO routines reside in this file.                *
*   Class specific routines are contained in the corresponding modular      *
*   directory file.
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV04(VOID *);
RM_STATUS nvHalVideoAlloc_NV04(VOID *);
RM_STATUS nvHalVideoFree_NV04(VOID *);
RM_STATUS nvHalVideoMethod_NV04(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV04(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV04(VOID *);

// Exports needed by class-dependent files in modular/nv4.
RM_STATUS videoInit_NV04(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV04(S012d020);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV04(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision ", pVideoControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            //
            // For NV4 overlay, we need to be absolutely certain we start the pipeline
            // outside of active display, otherwise we can hang it during the kickoff.
            // Eventhough called from vblank, spin to guarantee we kickoff in blank.
            //
            while ((REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x8) == 0x8)
                // while in vertical blank, wait for active display
                ;
            while ((REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x8) == 0x0)
                // while in active display, wait for vertical blank
                ;

            // Now, we should definitely be in vertical blank
            FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV04(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision ", pVideoAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;

    //
    // Connect class-dependent kick off routine.
    //
    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV04;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoAllocArg->pHalObjInfo;
            pOverlayHalObj->KickOffProc = class047InitXfer_NV04;
            break;
        }
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV04(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision ", pVideoFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)   // if the desktop is using the scalar, don't shut off
                    REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV04(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision ", pVideoMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV04(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV04(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV04(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV04(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision ", pVideoGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
    {
        //
        // Ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        //
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        pVideoGetEventStatusArg->intrStatus = 0;
        return RM_OK;
    }

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV04_VIDEO_OVERLAY:
            status = class047GetEventStatus_NV04(pVideoGetEventStatusArg);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = class63GetEventStatus_NV04(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision ", pVideoServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV04_VIDEO_OVERLAY:
            status = class047ServiceEvent_NV04(pVideoServiceEventArg);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = class63ServiceEvent_NV04(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV04
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV04
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    // Force the hardware to be reset if this routine is called at all.
    // We need to revisit this fix for our modeset problems to see if there is
    // a better solution (JSUN).
    // 

    if (classNum == NV_VIDEO_FROM_MEMORY)
        if (pHalHwInfo->pVideoHalInfo->Enabled)
            return (RM_OK);
        
    REG_WR32(NV_PVIDEO_CONTROL_Y, DRF_DEF(_PVIDEO, _CONTROL_Y, _BLUR, _ON));
    REG_WR32(NV_PVIDEO_CONTROL_X, DRF_DEF(_PVIDEO, _CONTROL_X, _SMOOTHING, _ON)
                                | DRF_DEF(_PVIDEO, _CONTROL_X, _SHARPENING, _ON));

    REG_WR32(NV_PVIDEO_BUFF0_OFFSET, 0);
    REG_WR32(NV_PVIDEO_BUFF1_OFFSET, 0);

    REG_WR32(NV_PVIDEO_OE_STATE, 0);
    REG_WR_DRF_DEF(_PVIDEO, _OE_STATE, _CURRENT_BUFFER, _1);
    REG_WR32(NV_PVIDEO_SU_STATE, DRF_NUM(_PVIDEO, _SU_STATE, _BUFF0_IN_USE, 1)
                               | DRF_NUM(_PVIDEO, _SU_STATE, _BUFF1_IN_USE, 1));
    REG_WR32(NV_PVIDEO_RM_STATE, 0);

    REG_WR_DRF_DEF(_PVIDEO, _INTR_EN_0, _NOTIFY, _ENABLED);

    //
    // Initialize default conversion values
    // These value are per the NV3/4 manual as the default
    // offsets for YUV conversion
    //
    REG_WR32(NV_PVIDEO_CSC_ADJUST, 0x10000);
    REG_WR32(NV_PVIDEO_RED_CSC, 105);
    REG_WR32(NV_PVIDEO_GREEN_CSC, 62);
    REG_WR32(NV_PVIDEO_BLUE_CSC, 137);

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\dderror.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

#define NO_ERROR 0L                                                 
#define ERROR_INVALID_FUNCTION           1L    
#define ERROR_NOT_ENOUGH_MEMORY          8L    
#define ERROR_DEV_NOT_EXIST              55L    
#define ERROR_INVALID_PARAMETER          87L    
#define ERROR_INSUFFICIENT_BUFFER        122L    
#define ERROR_INVALID_NAME               123L    
#define ERROR_MORE_DATA                  234L    
#define ERROR_IO_PENDING                 997L    
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    
#define ERROR_CONTINUE                   1246L    
#define ERROR_NO_MORE_DEVICES            1248L    

#endif /* _DDERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\video\nv10\vidnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV10.c                                                         *
*   The NV10 specific HAL VIDEO routines reside in this file.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV10(VOID *);
RM_STATUS nvHalVideoAlloc_NV10(VOID *);
RM_STATUS nvHalVideoFree_NV10(VOID *);
RM_STATUS nvHalVideoMethod_NV10(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV10(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV10(VOID *);

// Exports needed by class-dependent files in modular/nv10.
RM_STATUS videoInit_NV10(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV10(S012d020);
BOOL videoHwOwnsBuffer_NV10(PHALHWINFO, U032, PVIDEO_OVERLAY_HAL_OBJECT);
VOID videoAdjustScalarForTV_NV10(PHALHWINFO, U032);
VOID videoKickOffOverlay_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
VOID videoStopOverlay_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

// Exception handling routines.
static RM_STATUS videoGetEventStatus_NV10(PVIDEOGETEVENTSTATUSARG_000);
static RM_STATUS videoServiceEvent_NV10(PVIDEOSERVICEEVENTARG_000);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV10(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision ", pVideoControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
        {
            U032 i;

            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;

            //
            // Establish default register settings since we
            // don't use the videoInit_NV10 routine when doing
            // buffer kickoffs for these classes.
            //
            for (i = 0; i < 2; i++)
            {
                REG_WR32(NV_PVIDEO_LUMINANCE(i),
                         DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
                         DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
                REG_WR32(NV_PVIDEO_CHROMINANCE(i),
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
                REG_WR32(NV_PVIDEO_DS_DX(i),
                         DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_DT_DY(i),
                         DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_POINT_IN(i), 0);
                REG_WR32(NV_PVIDEO_SIZE_IN(i), 0xFFFFFFFF);
            }
            break;
        }
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            //
            // make the NV10 overlay window disappear by setting the
            // SIZE_OUT register to zero ... to reenable, the old/new
            // overlay classes will need to come in again and hit the methods
            //
            REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
            REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV10(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision ", pVideoAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV10;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV10(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision ", pVideoFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PHALHWINFO pHalHwInfo;
            PHWREG nvAddr;
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pHalHwInfo = pVideoFreeArg->pHalHwInfo;
            nvAddr = pHalHwInfo->nvBaseAddr;
            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                // if the desktop is using the scalar, don't shut off
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE) {
                    // activate a PVIDEO_STOP and disappear the window by
                    // setting SIZE_OUT to 0
                    REG_WR32(NV_PVIDEO_STOP,
                             DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                             DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                    
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
                }
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV10(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoFreeArg->pHalObjInfo;
            videoStopOverlay_NV10(pVideoFreeArg->pHalHwInfo, pOverlayHalObj, 0);
            pVideoFreeArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        }
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    
    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision ", pVideoMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV10(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV10(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV10(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV10(pVideoMethodArg);
            break;
        case NV10_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class07aMethod_NV10(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision ", pVideoGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
	{
        // ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);

#if 0
        //
        // XXX (scottl):
        //
        // I'm going to ignore the NV_VIDEO_FROM_MEMORY class in 
        // this case because it makes things easier.
        //

        //
        // We deviate here between classes.  This is probably unnecessary,
        // but I don't want to mess around.
        //
        if (pVideoGetEventStatusArg->classNum == NV_VIDEO_FROM_MEMORY)
        {
            // Return the current interrupt pending state. We could be here because of a
            // STOP_ACTIVE ... reading NV_PVIDEO_INTR one more time ensures the writes
            // were flushed (seen on IKOS, but in general shouldn't hurt.

            intr0 = REG_RD32(NV_PVIDEO_INTR);
            pVideoGetEventStatusArg->intrStatus =
                (intr0 & (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
                          (DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING))));
        }
        else
        {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
#endif

        //
        // If we're here, it means a video's classDestroy has come in before this STOP
        // or buffer completion intr ... this means 2 things:
        //
        //      - we can't use the pOverlayObject state, since it's already been freed
        //      - based on register state only we need to allow a STOP to still reclaim
        //          all buffers, otherwise we may leave the last buffer visible
        //
        if (REG_RD32(NV_PVIDEO_BUFFER) == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                           DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING))) {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
        pVideoGetEventStatusArg->intrStatus = 0;
        pVideoGetEventStatusArg->events = 0;
        return RM_OK;
	}

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoGetEventStatus_NV10(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision ", pVideoServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoServiceEvent_NV10(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//--------------------------------------------------------------------
// NV10_VIDEO_OVERLAY implementation (class07a)
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// Utility routines
//--------------------------------------------------------------------
BOOL videoHwOwnsBuffer_NV10(PHALHWINFO pHalHwInfo, U032 buffer_number, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj)
{
    // Check if stop is active.
    if (pOverlayHalObj->PvideoStopActive)
        return TRUE;

    switch (buffer_number){
        case 0:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_PENDING))
            return TRUE;
          break;
        case 1:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_PENDING))
            return TRUE;
          break;
    }
    return FALSE;
}

VOID videoKickOffOverlay_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PHWREG nvAddr;
    U032 data;

    nvAddr = pHalHwInfo->nvBaseAddr;

    // Enable the overlay
    pHalHwInfo->pVideoHalInfo->Enabled = 1;

    // Enable the interrupt for the overlay. 
    data = REG_RD32(NV_PVIDEO_INTR_EN);
    if (buffNum == 0)
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_0, NV_PVIDEO_INTR_EN_BUFFER_0_ENABLED));
    else
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_1, NV_PVIDEO_INTR_EN_BUFFER_1_ENABLED));

    // BufferBase is an offset value here
    data = (U032)((size_t)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase);
    REG_WR32(NV_PVIDEO_BASE(buffNum), data);
    
    data = pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferSize;
    REG_WR32(NV_PVIDEO_LIMIT(buffNum), data-1);

    if (pOverlayHalObj->PvideoStopActive == 0) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }

    // Kick Off the buffer to Hardware.
    REG_WR32(NV_PVIDEO_BUFFER, pOverlayHalObj->PvideoBufferCopy);
}

//
// videoStopOverlay
//
// Handle StopOverlay method for both classes.
//
VOID videoStopOverlay_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 data)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // We can't rely on our PvideoBufferCopy to tell us if the
    // hardware is still using a given buffer because we're getting
    // out of sync (somehow).
    // Go to the hardware directly to make sure we reclaim buffer
    // via stop when we need to.
#if 0
    if ((videoHwOwnsBuffer_NV10(pHalHwInfo, 0, pOverlayHalObj)) ||
        (videoHwOwnsBuffer_NV10(pHalHwInfo, 1, pOverlayHalObj))) {
#endif
    if (REG_RD32(NV_PVIDEO_BUFFER))
    {
        pOverlayHalObj->PvideoStopActive = 1;
        if (data) { //NV_PVIDEO_STOP_METHOD_NORMALLY 
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _NORMALLY));
        } else {
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        }
    }
    else {
        pOverlayHalObj->PvideoStopActive = FALSE;
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }
}

//
// Exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
static RM_STATUS videoGetEventStatus_NV10(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    U032 intr0;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;
    
    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    pVideoGetEventStatusArg->intrStatus = 0;

    //
    // Find out which buffer(s) are pending.
    //
    intr0 = REG_RD32(NV_PVIDEO_INTR);
    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 0);
    }

    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 1);
    }

    return RM_OK;
}

//
// video exception handler
//
static RM_STATUS videoServiceEvent_NV10(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // We shouldn't be in here if we don't have a valid overlay
    // object, but make sure it's non-null just the same...
    //
    if (pOverlayHalObj && pOverlayHalObj->PvideoStopActive &&
        (pOverlayHalObj->PvideoBufferCopy == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                              DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING)))) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        pOverlayHalObj->PvideoStopActive = 0;
    }

    //
    // On NV10 it doesn't look like we return our current NV_PVDEO_INTR
    // value for the overlay classes.
    //
    if (pVideoServiceEventArg->classNum == NV_VIDEO_FROM_MEMORY)
        pVideoServiceEventArg->intrStatus =
            (REG_RD32(NV_PVIDEO_INTR) &
             (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
              DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING)));
    else
        pVideoServiceEventArg->intrStatus = 0;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Adjust the video overlay position if running on TV.
//
//---------------------------------------------------------------------------

//	Because of the way the video scalar syncs with the CRTC, we need to adjust both CRTC timing
//  and make overlay adjustments differently for different devices. NV4 had this problem, NV5
//	was "fixed", and in NV10 the problem is back. NV12 and later device may or may not need
//	special adjustments.
VOID videoAdjustScalarForTV_NV10(PHALHWINFO pHalHwInfo, U032 buffNum)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 data;

    if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_TV)
    {
        data = REG_RD32(NV_PVIDEO_POINT_OUT(buffNum));
        REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data + NV10_VSCALAR_TV_ADJUST);
    }
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV10
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV10
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    if (pHalHwInfo->pVideoHalInfo->Enabled)
        return (RM_OK);
        
    REG_WR32(NV_PVIDEO_OFFSET(0), 0);
    REG_WR32(NV_PVIDEO_OFFSET(1), 0);

    // Make sure we're in a known idle state.
    // Wait for any HW owned buffers to complete (IN_USE bits go to 0).
    while (REG_RD32(NV_PVIDEO_BUFFER))
        ;

    // Next, complete an active StopOverlay and reset PGRAPH_INTR
    REG_WR32(NV_PVIDEO_STOP, DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE));
    REG_WR32(NV_PVIDEO_INTR, DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _RESET) |
                               DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _RESET));

    REG_WR32(NV_PVIDEO_INTR_EN, DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_0, _ENABLED) |
                                DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_1, _ENABLED));

    // set SIZE_IN to infinite values (ImageScan.size isn't correct for NV10 HW)
    REG_WR32(NV_PVIDEO_SIZE_IN(0), 0xFFFFFFFF);
    REG_WR32(NV_PVIDEO_SIZE_IN(1), 0xFFFFFFFF);

    // cleanup any previous values
    REG_WR32(NV_PVIDEO_POINT_IN(0), 0);
    REG_WR32(NV_PVIDEO_POINT_IN(1), 0);

    REG_WR32(NV_PVIDEO_BASE(0), 0);
    REG_WR32(NV_PVIDEO_BASE(1), 0);

    REG_WR32(NV_PVIDEO_LIMIT(0), pHalHwInfo->pFbHalInfo->Limit[0]);
    REG_WR32(NV_PVIDEO_LIMIT(1), pHalHwInfo->pFbHalInfo->Limit[0]);

    REG_WR32(NV_PVIDEO_LUMINANCE(0), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
    REG_WR32(NV_PVIDEO_LUMINANCE(1), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));

    REG_WR32(NV_PVIDEO_CHROMINANCE(0), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
    REG_WR32(NV_PVIDEO_CHROMINANCE(1), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvmisc.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvmisc.h
 */
#ifndef __NV_MISC_H
#define __NV_MISC_H

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

// 
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long	token;
    unsigned long	cmd;
    unsigned long	port;
    unsigned long	flags;
    unsigned long	data;
    unsigned long	status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define	NVRM_I2C_ACCESS_CMD_ACQUIRE     1
#define	NVRM_I2C_ACCESS_CMD_RELEASE     2
#define	NVRM_I2C_ACCESS_CMD_WRITE_BYTE  3
#define	NVRM_I2C_ACCESS_CMD_READ_BYTE   4
#define	NVRM_I2C_ACCESS_CMD_NULL        5
#define	NVRM_I2C_ACCESS_CMD_RESET       6
#define NVRM_I2C_ACCESS_CMD_READ_SDA    7
#define NVRM_I2C_ACCESS_CMD_READ_SCL    8
#define NVRM_I2C_ACCESS_CMD_WRITE_SDA   9
#define NVRM_I2C_ACCESS_CMD_WRITE_SCL   10

// flags
#define NVRM_I2C_ACCESS_FLAG_START	    0x1
#define	NVRM_I2C_ACCESS_FLAG_STOP	    0x2
#define	NVRM_I2C_ACCESS_FLAG_ACK	    0x4

// port
#define	NVRM_I2C_ACCESS_PORT_PRIMARY    1
#define	NVRM_I2C_ACCESS_PORT_SECONDARY  2

// status
#define	NVRM_I2C_ACCESS_STATUS_SUCCESS         0
#define	NVRM_I2C_ACCESS_STATUS_ERROR           1
#define	NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR  2
#define	NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY     3

//
// misc string definitions for registry manipulation
//
#define STR_NVIDIA                  "NVidia"
#define STR_DEV_NODE_RM             "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System"
#define STR_DEV_NODE_DISPLAY        "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display";
#define STR_DEV_NODE_DISPLAY_NUMBER "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
#define STR_RM_CORE_NAME            "RmCoreName"

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // __NV_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\ioaccess.h ===
/*++

Copyright (c) 1989-1995   Microsoft Corporation

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/

//
// Note: IA64 is for 64 bits Merced. Under Merced compiler option, we don't have
// _X86_, instead, we use _IA64_. Same thing, _AXP64_ is for 64 bits compiler
// option for ALPHA
//
#if defined(_MIPS_) || defined(_X86_) || defined(_IA64_)

//
// Memory barriers on X86 and MIPS are not required since the Io
// Operations are always garanteed to be executed in order
//

#define MEMORY_BARRIER()    0


#elif defined(_PPC_)

//
// A memory barrier function is provided by the PowerPC Enforce
// In-order Execution of I/O instruction (eieio).
//

#if defined(_M_PPC) && defined(_MSC_VER) && (_MSC_VER>=1000)
void __emit( unsigned const __int32 );
#define __builtin_eieio() __emit( 0x7C0006AC )
#else
void __builtin_eieio(void);
#endif

#define MEMORY_BARRIER()        __builtin_eieio()


#elif defined(_ALPHA_) || (_AXP64_)

//
// ALPHA requires memory barriers
//

#define MEMORY_BARRIER()  __MB()



#endif

#ifndef NO_PORT_MACROS



//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate MEMORY registers.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O ports.
//  (Use x86 in/out instructions.)
//


//
// inp(),inpw(), inpd(), outp(), outpw(), outpd() are X86 specific intrinsic
// inline functions. So for IA64, we have to put READ_PORT_USHORT() etc. back
// to it's supposed to be, defined in sdk\inc\wdm.h
//
#if defined(_IA64_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_X86_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  inp (Port)
#define READ_PORT_USHORT(Port)                 inpw (Port)
#define READ_PORT_ULONG(Port)                  inpd (Port)
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#elif defined(_PPC_) || defined(_MIPS_)

#define READ_REGISTER_UCHAR(x)      (*(volatile UCHAR * const)(x))
#define READ_REGISTER_USHORT(x)     (*(volatile USHORT * const)(x))
#define READ_REGISTER_ULONG(x)      (*(volatile ULONG * const)(x))
#define WRITE_REGISTER_UCHAR(x, y)  (*(volatile UCHAR * const)(x) = (y))
#define WRITE_REGISTER_USHORT(x, y) (*(volatile USHORT * const)(x) = (y))
#define WRITE_REGISTER_ULONG(x, y)  (*(volatile ULONG * const)(x) = (y))
#define READ_PORT_UCHAR(x)          READ_REGISTER_UCHAR(x)
#define READ_PORT_USHORT(x)         READ_REGISTER_USHORT(x)
#define READ_PORT_ULONG(x)          READ_REGISTER_ULONG(x)

//
// All these macros take a ULONG as a parameter so that we don't
// force an extra typecast in the code (which will cause the X86 to
// generate bad code).
//

#define WRITE_PORT_UCHAR(x, y)      WRITE_REGISTER_UCHAR(x, (UCHAR) (y))
#define WRITE_PORT_USHORT(x, y)     WRITE_REGISTER_USHORT(x, (USHORT) (y))
#define WRITE_PORT_ULONG(x, y)      WRITE_REGISTER_ULONG(x, (ULONG) (y))


#elif defined(_ALPHA_) || (_AXP64_)

//
// READ/WRITE_PORT/REGISTER_UCHAR_USHORT_ULONG are all functions that
// go to the HAL on ALPHA
//
// So we only put the prototypes here
//

__declspec(dllimport)
UCHAR
READ_REGISTER_UCHAR(
    PVOID Register
    );

__declspec(dllimport)
USHORT
READ_REGISTER_USHORT(
    PVOID Register
    );

__declspec(dllimport)
ULONG
READ_REGISTER_ULONG(
    PVOID Register
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_UCHAR(
    PVOID Register,
    UCHAR Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_USHORT(
    PVOID  Register,
    USHORT Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_ULONG(
    PVOID Register,
    ULONG Value
    );

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#endif      // NO_PORT_MACROS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\video\nv20\vidnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV20.c                                                         *
*   The NV20 specific HAL VIDEO routines reside in this file.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV20(VOID *);
RM_STATUS nvHalVideoAlloc_NV20(VOID *);
RM_STATUS nvHalVideoFree_NV20(VOID *);
RM_STATUS nvHalVideoMethod_NV20(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV20(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV20(VOID *);

// Exports needed by class-dependent files in modular/nv10.
RM_STATUS videoInit_NV20(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV20(S012d020);
BOOL videoHwOwnsBuffer_NV20(PHALHWINFO, U032, PVIDEO_OVERLAY_HAL_OBJECT);
VOID videoAdjustScalarForTV_NV20(PHALHWINFO, U032);
VOID videoKickOffOverlay_NV20(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
VOID videoStopOverlay_NV20(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

// Exception handling routines.
static RM_STATUS videoGetEventStatus_NV20(PVIDEOGETEVENTSTATUSARG_000);
static RM_STATUS videoServiceEvent_NV20(PVIDEOSERVICEEVENTARG_000);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV20(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision ", pVideoControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
        {
            U032 i;

            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;

            //
            // Establish default register settings since we
            // don't use the videoInit_NV10 routine when doing
            // buffer kickoffs for these classes.
            //
            for (i = 0; i < 2; i++)
            {
                REG_WR32(NV_PVIDEO_LUMINANCE(i),
                         DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
                         DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
                REG_WR32(NV_PVIDEO_CHROMINANCE(i),
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
                REG_WR32(NV_PVIDEO_DS_DX(i),
                         DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_DT_DY(i),
                         DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_POINT_IN(i), 0);
                REG_WR32(NV_PVIDEO_SIZE_IN(i), 0xFFFFFFFF);
            }
            break;
        }
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            //
            // make the NV20 overlay window disappear by setting the
            // SIZE_OUT register to zero ... to reenable, the old/new
            // overlay classes will need to come in again and hit the methods
            //
            REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
            REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV20(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    PHWREG nvAddr;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision ", pVideoAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV20;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV20(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision ", pVideoFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PHALHWINFO pHalHwInfo;
            PHWREG nvAddr;
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pHalHwInfo = pVideoFreeArg->pHalHwInfo;
            nvAddr = pHalHwInfo->nvBaseAddr;
            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                // if the desktop is using the scalar, don't shut off
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE) {
                    // activate a PVIDEO_STOP and disappear the window by
                    // setting SIZE_OUT to 0
                    REG_WR32(NV_PVIDEO_STOP,
                             DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                             DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                    
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
                }
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV20(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoFreeArg->pHalObjInfo;
            videoStopOverlay_NV20(pVideoFreeArg->pHalHwInfo, pOverlayHalObj, 0);
            pVideoFreeArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        }
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    
    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision ", pVideoMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV20(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV20(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV20(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV20(pVideoMethodArg);
            break;
        case NV10_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class07aMethod_NV20(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision ", pVideoGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
	{
        // ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);

#if 0
        //
        // XXX (scottl):
        //
        // I'm going to ignore the NV_VIDEO_FROM_MEMORY class in 
        // this case because it makes things easier.
        //

        //
        // We deviate here between classes.  This is probably unnecessary,
        // but I don't want to mess around.
        //
        if (pVideoGetEventStatusArg->classNum == NV_VIDEO_FROM_MEMORY)
        {
            // Return the current interrupt pending state. We could be here because of a
            // STOP_ACTIVE ... reading NV_PVIDEO_INTR one more time ensures the writes
            // were flushed (seen on IKOS, but in general shouldn't hurt.

            intr0 = REG_RD32(NV_PVIDEO_INTR);
            pVideoGetEventStatusArg->intrStatus =
                (intr0 & (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
                          (DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING))));
        }
        else
        {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
#endif

        //
        // If we're here, it means a video's classDestroy has come in before this STOP
        // or buffer completion intr ... this means 2 things:
        //
        //      - we can't use the pOverlayObject state, since it's already been freed
        //      - based on register state only we need to allow a STOP to still reclaim
        //          all buffers, otherwise we may leave the last buffer visible
        //
        if (REG_RD32(NV_PVIDEO_BUFFER) == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                           DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING))) {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
        pVideoGetEventStatusArg->intrStatus = 0;
        pVideoGetEventStatusArg->events = 0;
        return RM_OK;
	}

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoGetEventStatus_NV20(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision ", pVideoServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoServiceEvent_NV20(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//--------------------------------------------------------------------
// NV20_VIDEO_OVERLAY implementation (class07a)
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// Utility routines
//--------------------------------------------------------------------
BOOL videoHwOwnsBuffer_NV20(PHALHWINFO pHalHwInfo, U032 buffer_number, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj)
{
    // Check if stop is active.
    if (pOverlayHalObj->PvideoStopActive)
        return TRUE;

    switch (buffer_number){
        case 0:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_PENDING))
            return TRUE;
          break;
        case 1:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_PENDING))
            return TRUE;
          break;
    }
    return FALSE;
}

VOID videoKickOffOverlay_NV20(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PHWREG nvAddr;
    U032 data;

    nvAddr = pHalHwInfo->nvBaseAddr;

    // Enable the overlay
    pHalHwInfo->pVideoHalInfo->Enabled = 1;

    // Enable the interrupt for the overlay. 
    data = REG_RD32(NV_PVIDEO_INTR_EN);
    if (buffNum == 0)
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_0, NV_PVIDEO_INTR_EN_BUFFER_0_ENABLED));
    else
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_1, NV_PVIDEO_INTR_EN_BUFFER_1_ENABLED));

    // BufferBase is an offset value here
    data = (U032)((size_t)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase);
    REG_WR32(NV_PVIDEO_BASE(buffNum), data);
    
    data = (U032)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferSize;
    REG_WR32(NV_PVIDEO_LIMIT(buffNum), data-1);

    if (pOverlayHalObj->PvideoStopActive == 0) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }

    // Kick Off the buffer to Hardware.
    REG_WR32(NV_PVIDEO_BUFFER, pOverlayHalObj->PvideoBufferCopy);
}

//
// videoStopOverlay
//
// Handle StopOverlay method for both classes.
//
VOID videoStopOverlay_NV20(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 data)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    if ((videoHwOwnsBuffer_NV20(pHalHwInfo, 0, pOverlayHalObj)) ||
        (videoHwOwnsBuffer_NV20(pHalHwInfo, 1, pOverlayHalObj))) {
        pOverlayHalObj->PvideoStopActive = 1;
        if (data) { //NV_PVIDEO_STOP_METHOD_NORMALLY 
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _NORMALLY));
        } else {
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        }
    }
    else {
        pOverlayHalObj->PvideoStopActive = FALSE;
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }
}

//
// Exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
static RM_STATUS videoGetEventStatus_NV20(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    U032 intr0;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;
    
    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    pVideoGetEventStatusArg->intrStatus = 0;

    //
    // Find out which buffer(s) are pending.
    //
    intr0 = REG_RD32(NV_PVIDEO_INTR);
    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 0);
    }

    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 1);
    }

    return RM_OK;
}

//
// video exception handler
//
static RM_STATUS videoServiceEvent_NV20(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // We shouldn't be in here if we don't have a valid overlay
    // object, but make sure it's non-null just the same...
    //
    if (pOverlayHalObj && pOverlayHalObj->PvideoStopActive &&
        (pOverlayHalObj->PvideoBufferCopy == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                              DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING)))) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        pOverlayHalObj->PvideoStopActive = 0;
    }

    //
    // On NV20 it doesn't look like we return our current NV_PVDEO_INTR
    // value for the overlay classes.
    //
    if (pVideoServiceEventArg->classNum == NV_VIDEO_FROM_MEMORY)
        pVideoServiceEventArg->intrStatus =
            (REG_RD32(NV_PVIDEO_INTR) &
             (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
              DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING)));
    else
        pVideoServiceEventArg->intrStatus = 0;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Adjust the video overlay position if running on TV.
//
//---------------------------------------------------------------------------

//	Because of the way the video scalar syncs with the CRTC, we need to adjust both CRTC timing
//  and make overlay adjustments differently for different devices. NV4 had this problem, NV5
//	was "fixed", and in NV10 the problem is back. NV12 and later device may or may not need
//	special adjustments.
VOID videoAdjustScalarForTV_NV20(PHALHWINFO pHalHwInfo, U032 buffNum)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 data;

    if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_TV)
    {
        data = REG_RD32(NV_PVIDEO_POINT_OUT(buffNum));
        REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data + NV10_VSCALAR_TV_ADJUST);
    }
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV20
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    if (pHalHwInfo->pVideoHalInfo->Enabled)
        return (RM_OK);
        
    REG_WR32(NV_PVIDEO_OFFSET(0), 0);
    REG_WR32(NV_PVIDEO_OFFSET(1), 0);

    // Make sure we're in a known idle state.
    // Wait for any HW owned buffers to complete (IN_USE bits go to 0).
    while (REG_RD32(NV_PVIDEO_BUFFER))
        ;

    // Next, complete an active StopOverlay and reset PGRAPH_INTR
    REG_WR32(NV_PVIDEO_STOP, DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE));
    REG_WR32(NV_PVIDEO_INTR, DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _RESET) |
                               DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _RESET));

    REG_WR32(NV_PVIDEO_INTR_EN, DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_0, _ENABLED) |
                                DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_1, _ENABLED));

    // set SIZE_IN to infinite values (ImageScan.size isn't correct for NV20 HW)
    REG_WR32(NV_PVIDEO_SIZE_IN(0), 0xFFFFFFFF);
    REG_WR32(NV_PVIDEO_SIZE_IN(1), 0xFFFFFFFF);

    // cleanup any previous values
    REG_WR32(NV_PVIDEO_POINT_IN(0), 0);
    REG_WR32(NV_PVIDEO_POINT_IN(1), 0);

    REG_WR32(NV_PVIDEO_BASE(0), 0);
    REG_WR32(NV_PVIDEO_BASE(1), 0);

    REG_WR32(NV_PVIDEO_LIMIT(0), pHalHwInfo->pFbHalInfo->Limit[0]);
    REG_WR32(NV_PVIDEO_LIMIT(1), pHalHwInfo->pFbHalInfo->Limit[0]);

    REG_WR32(NV_PVIDEO_LUMINANCE(0), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
    REG_WR32(NV_PVIDEO_LUMINANCE(1), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));

    REG_WR32(NV_PVIDEO_CHROMINANCE(0), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
    REG_WR32(NV_PVIDEO_CHROMINANCE(1), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvARMApi.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* nvARmApi.h
*
* NVidia resource manager API header file exported to drivers. (as of now, only
* the audio drivers use it.
*
*/

#if !defined _NVARMAPIH_
#define _NVARMAPIH_

#if defined __cplusplus
extern "C" {
#endif //__cplusplus
    
#include <nvos.h>


// exported functions - OS independent to get to the core

// to be called before anything can be done with the RM
NvU32	NVARM_LoadCore(NvU32 *pDeviceHandle);
void	NVARM_UnloadCore(NvU32 uDeviceHandle);

NvU32	NVARM_Alloc(NvU32 uDeviceHandle, NVOS21_PARAMETERS *pIn);
NvU32	NVARM_Free(NvU32 uDeviceHandle, NV_UNIFIED_FREE *pIn);
    
    
#if defined WIN9XVXD		// change this to whatever the macro is
    
// some imports from resman files... wonder why it's not in common

// this structure is exactly the same as NV_IOCTL_ARCH_STRUCT,
// name's changed to prevent redfinition.
typedef struct
{
    NvU32 nvarchFunction;
    NvU32 nvarchParameters;
} NVA_IOCTL_ARCH_STRUCT;
    
#if !defined NVRM_IOCTL_NV_ARCH
#define NVRM_IOCTL_NV_ARCH				21
#endif
    
#define AVxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (service & 0xff) \
    _asm _emit (service >> 8) & 0xff \
    _asm _emit (service >> 16) & 0xff \
    _asm _emit (service >> 24) & 0xff \
    
NvU32 static __inline
IOCTLCall(NvU32 pDevInfoParam, DIOCPARAMETERS *pParams)
{
    NvU32 dw;
    struct DeviceInfo  *pDevInfo;
    struct VxD_Desc_Block *pDDB;
    
    pDevInfo = (struct DeviceInfo *)pDevInfoParam;
    pDDB = (struct VxD_Desc_Block *)pDevInfo->DI_DDB;
    
    // W32_DEVICEIOCONTROL = 0x23
    _asm mov eax, 0x23
    _asm mov ecx, pDDB
    _asm mov esi, pParams
    AVxDCall(0x00010147);		// Directed_Sys_Control
    _asm mov dw, eax
    return(dw);
}
    
inline NvU32
NVARM_LoadCore(NvU32 *ppDevInfo)
{
    NvU32	dlResult;
    NvU8	*pName = (NvU8*)VXDLDR_NVA_RESMAN_VXD_NAME;
    struct DeviceInfo  *pDevInfo;
    
    _asm	mov	edx, pName
    _asm	mov	eax, 1
    AVxDCall(0x00270001);		// VXDLDR_LoadDevice
    _asm	mov	dlResult, eax
    _asm	jc	LoadDeviceError
    // DDB returned in eax
    _asm	mov	pDevInfo, edx
    
    *ppDevInfo = (NvU32)pDevInfo;
    dlResult = 0;
    
LoadDeviceError:
    return	(dlResult);
}
    
inline VOID
NVARM_UnloadCore(NvU32 pDevInfoParam)
{	
    struct DeviceInfo *pDevInfo;
    
    pDevInfo = (struct DeviceInfo *)pDevInfoParam;
    
    NvU8	*pName = (NvU8 *)pDevInfo->DI_ModuleName;
    NvU32	deviceID = pDevInfo->DI_DeviceID;
    
    _asm	mov	ebx, deviceID
    _asm	mov	edx, pName
    AVxDCall(0x00270002);	// VXDLDR_UnloadDevice
}

inline NvU32
NVARM_Alloc(NvU32 pDevInfo, NVOS21_PARAMETERS *pIn)
{
    DIOCPARAMETERS ioctlParams;
    NVA_IOCTL_ARCH_STRUCT	params;
    
    params.nvarchFunction = NV04_ALLOC;
    params.nvarchParameters = (NvU32)pIn;
    
    ioctlParams.dwIoControlCode = NVRM_IOCTL_NV_ARCH;
    ioctlParams.lpvInBuffer = (NvU32)&params;
    ioctlParams.cbInBuffer = sizeof(NVA_IOCTL_ARCH_STRUCT);
    ioctlParams.lpvOutBuffer = NULL;
    ioctlParams.cbOutBuffer = 0;
    
    return IOCTLCall(pDevInfo, &ioctlParams);
}

inline NvU32
NVARM_Free(NvU32 pDevInfo, NV_UNIFIED_FREE *pIn)
{
    DIOCPARAMETERS ioctlParams;
    NVA_IOCTL_ARCH_STRUCT	params;
    
    params.nvarchFunction = NV04_UNIFIED_FREE;
    params.nvarchParameters = (NvU32)pIn;
    
    ioctlParams.dwIoControlCode = NVRM_IOCTL_NV_ARCH;
    ioctlParams.lpvInBuffer = (NvU32)&params;
    ioctlParams.cbInBuffer = sizeof(NVA_IOCTL_ARCH_STRUCT);
    ioctlParams.lpvOutBuffer = NULL;
    ioctlParams.cbOutBuffer = 0;
    
    return IOCTLCall(pDevInfo, &ioctlParams);
    
}
    
#endif
    
#if defined WDM

// list of imported functions from the resource manager
// the user still needs to link to the .lib

__declspec(dllimport) NvU32 rmAuDispatch(U032 uFunction, PVOID pIn);

inline NvU32
NVARM_LoadCore(NvU32 *ppDevInfo)
{
    // nothing to do really - except maybe load the driver??

    // I was returning '0', but the client thinks '0' is an invalid value
    *ppDevInfo = 0xF;
    return 0;
}

inline VOID
NVARM_UnloadCore(NvU32 pDevInfoParam)
{
    return;
}

inline NvU32
NVARM_Alloc(NvU32 pDevInfo, NVOS21_PARAMETERS *pIn)
{
    return rmAuDispatch(NV04_ALLOC, (VOID *)pIn);
}

inline NvU32
NVARM_Free(NvU32 pDevInfo, NV_UNIFIED_FREE *pIn)
{
    return rmAuDispatch(NV04_UNIFIED_FREE, (VOID *)pIn);
}

#endif		// WDM

#if defined __cplusplus
}
#endif //__cplusplus

#endif // _NVARMAPIH_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nv32.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/



 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nv32.h> defines a 32-bit wide naming convention  for the functionality  *|
|*  of NVIDIA's Unified Media Architecture (TM).                             *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NV32_INCLUDED
#define NV32_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>


 /***************************************************************************\
|*                                NV Classes                                 *|
 \***************************************************************************/

/*
 * These structures indicate the offsets of hardware registers corresponding to
 * the methods of each class.  Since the first 256 bytes of each subchannel is
 * the NvControlPio registers, the hexadecimal offsets in comments start at
 * 0x100.
 */

/* class NV01_ROOT */
#define  NV01_ROOT                                                 (0x00000000)
/* NvNotification[] fields and values */
#define NV000_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv000Typedef, Nv01Root;
#define NV000_TYPEDEF                                              Nv01Root
/* obsolete stuff */
#define Nv1Root                                                    Nv01Root
#define nv1Root                                                    Nv01Root
#define nv01Root                                                   Nv01Root


/* class NV01_CLASS */
#define  NV01_CLASS                                                (0x00000001)
/* NvNotification[] fields and values */
#define NV001_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv001Typedef, Nv01Class;
#define NV001_TYPEDEF                                              Nv01Class
/* obsolete stuff */
#define  NV1_CLASS                                                 (0x00000001)
#define Nv1Class                                                   Nv01Class
#define nv1Class                                                   Nv01Class
#define nv01Class                                                  Nv01Class


/* class NV01_CONTEXT_DMA_FROM_MEMORY */
#define  NV01_CONTEXT_DMA_FROM_MEMORY                              (0x00000002)
/* NvNotification[] fields and values */
#define NV002_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv002Typedef, Nv01ContextDmaFromMemory;
#define  NV002_TYPEDEF                                 Nv01ContextDmaFromMemory
/* obsolete stuff */
#define  NV1_CONTEXT_DMA_FROM_MEMORY                               (0x00000002)
#define  NV01_CONTEXT_DMA                                          (0x00000002)
#define  Nv1ContextDmaFromMemory                       Nv01ContextDmaFromMemory
#define  nv1ContextDmaFromMemory                       Nv01ContextDmaFromMemory
#define  nv01ContextDmaFromMemory                      Nv01ContextDmaFromMemory


/* class NV01_CONTEXT_DMA_TO_MEMORY */
#define  NV01_CONTEXT_DMA_TO_MEMORY                                (0x00000003)
/* NvNotification[] fields and values */
#define NV003_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv003Typedef, Nv01ContextDmaToMemory;
#define  NV003_TYPEDEF                                   Nv01ContextDmaToMemory
/* obsolete stuff */
#define  NV1_CONTEXT_DMA_TO_MEMORY                                 (0x00000003)
#define  Nv1ContextDmaToMemory                           Nv01ContextDmaToMemory
#define  nv1ContextDmaToMemory                           Nv01ContextDmaToMemory
#define  nv01ContextDmaToMemory                          Nv01ContextDmaToMemory


/* class NV01_TIMER */
#define  NV01_TIMER                                                (0x00000004)
/* NvNotification[] elements */
#define NV004_NOTIFIERS_NOTIFY                                     (0)
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
/* NvNotification[] fields and values */
#define NV004_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV004_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV004_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV004_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV004_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV004_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;            /* ignored                           0100-0103*/
 NvV32 Notify;                 /* NV004_NOTIFY_*                    0104-0107*/
 NvV32 StopTransfer;           /* NV004_STOP_TRANSFER_VALUE         0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;  /* NV01_CONTEXT_DMA                  0180-0183*/
 NvV32 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  NvU32 nanoseconds[2];        /* nsec since 1970-01-01 0=immediate    0-   7*/
 } SetAlarmTime;               /* end of method                         -0307*/
 struct {                      /* start of method                   0308-    */
  NvU32 nanoseconds[2];        /* nsec relative to current time        8-   f*/
 } SetAlarmTimeRelative;       /* end of method                         -030f*/
 NvV32 Reserved02[0x004];
 NvV32 SetAlarmNotify;         /* NV004_SET_ALARM_NOTIFY_*          0320-0323*/
 NvV32 Reserved03[0x737];
} Nv004Typedef, Nv01Timer;
#define NV004_TYPEDEF                                              Nv01Timer
/* dma method offsets, fields, and values */
#define NV004_SET_OBJECT                                           (0x00000000)
#define NV004_NO_OPERATION                                         (0x00000100)
#define NV004_NOTIFY                                               (0x00000104)
#define NV004_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV004_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV004_STOP_TRANSFER                                        (0x00000108)
#define NV004_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV004_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV004_SET_ALARM_TIME                                       (0x00000300)
#define NV004_SET_ALARM_TIME_RELATIVE                              (0x00000308)
#define NV004_SET_ALARM_NOTIFY                                     (0x00000320)
#define NV004_SET_ALARM_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
/* obsolete stuff */
#define Nv1Timer                                                   Nv01Timer
#define nv1Timer                                                   Nv01Timer
#define nv01Timer                                                  Nv01Timer


/* class NV01_EVENT */
#define  NV01_EVENT                                                (0x00000005)
/* NvNotification[] fields and values */
#define NV003_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct _Nv005Typedef{
 NvV32 Reserved00[0x7c0];
} Nv005Typedef, Nv01Event;
#define NV005_TYPEDEF                                              Nv01Event
/* obsolete stuff */
#define NV1_TIMER                                                  (0x00000004)
#define Nv1Event                                                   Nv01Event
#define nv1Event                                                   Nv01Event
#define nv01Event                                                  Nv01Event


typedef NvV32 Nv006Typedef;

typedef NvV32 Nv007Typedef;

typedef NvV32 Nv008Typedef;

typedef NvV32 Nv009Typedef;

typedef NvV32 Nv00aTypedef;

typedef NvV32 Nv00bTypedef;

typedef NvV32 Nv00cTypedef;

typedef NvV32 Nv00dTypedef;

typedef NvV32 Nv00eTypedef;

typedef NvV32 Nv00fTypedef;

typedef NvV32 Nv010Typedef;

typedef NvV32 Nv011Typedef;


/* class NV01_CONTEXT_BETA */
#define  NV01_CONTEXT_BETA                                         (0x00000012)
/* NvNotification[] elements */
#define NV012_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV012_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV012_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV012_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV012_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV012_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV012_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV012_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetBeta1d31;             /* S1d31 beta value                 0300-0303*/
 NvV32 Reserved02[0x73f];
} Nv012Typedef, Nv01ContextBeta;
#define NV012_TYPEDEF                                           Nv01ContextBeta
/* dma method offsets, fields, and values */
#define NV012_SET_OBJECT                                           (0x00000000)
#define NV012_NO_OPERATION                                         (0x00000100)
#define NV012_NOTIFY                                               (0x00000104)
#define NV012_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV012_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV012_SET_BETA_1D31                                        (0x00000300)
/* obsolete stuff */
#define NV01_BETA_SOLID                                            (0x00000012)
#define NV1_BETA_SOLID                                             (0x00000012)
#define Nv01BetaSolid                                           Nv01ContextBeta
#define nv01BetaSolid                                           Nv01ContextBeta
#define Nv1BetaSolid                                            Nv01ContextBeta
#define nv1BetaSolid                                            Nv01ContextBeta

typedef NvV32 Nv013Typedef;

typedef NvV32 Nv014Typedef;

typedef NvV32 Nv015Typedef;

typedef NvV32 Nv016Typedef;


/* class NV01_CONTEXT_COLOR_KEY */
#define  NV01_CONTEXT_COLOR_KEY                                    (0x00000017)
/* NvNotification[] elements */
#define NV017_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV017_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV017_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV017_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV017_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV017_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV017_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV017_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV017_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetColor;                /* color key value                  0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv017Typedef, Nv01ContextColorKey;
#define NV017_TYPEDEF                                       Nv01ContextColorKey
/* dma method offsets, fields, and values */
#define NV017_SET_OBJECT                                           (0x00000000)
#define NV017_NO_OPERATION                                         (0x00000100)
#define NV017_NOTIFY                                               (0x00000104)
#define NV017_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV017_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV017_SET_COLOR_FORMAT                                     (0x00000300)
#define NV017_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV017_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV017_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV017_SET_COLOR                                            (0x00000304)
/* obsolete stuff */
#define NV01_IMAGE_SOLID                                           (0x00000017)
#define NV1_IMAGE_SOLID                                            (0x00000017)
#define Nv01ImageSolid                                      Nv01ContextColorKey
#define nv01ImageSolid                                      Nv01ContextColorKey
#define Nv1ImageSolid                                       Nv01ContextColorKey
#define nv1ImageSolid                                       Nv01ContextColorKey
#define nv01ContextColorKey                                 Nv01ContextColorKey


/* class NV01_CONTEXT_PATTERN */
#define  NV01_CONTEXT_PATTERN                                      (0x00000018)
/* NvNotification[] elements */
#define NV018_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV018_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV018_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV018_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV018_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV018_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV018_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV018_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV018_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV018_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 SetMonochromeShape;      /* NV018_SET_MONOCHROME_SHAPE_*     0308-030b*/
 NvV32 Reserved02[0x001];
 NvV32 SetMonochromeColor0;     /* color of 0 pixels                0310-0313*/
 NvV32 SetMonochromeColor1;     /* color of 1 pixels                0314-0317*/
 NvV32 SetMonochromePattern0;   /* first  32 bits of pattern data   0318-031b*/
 NvV32 SetMonochromePattern1;   /* second 32 bits of pattern data   031c-031f*/
 NvV32 Reserved03[0x738];
} Nv018Typedef, Nv01ContextPattern;
#define NV018_TYPEDEF                                        Nv01ContextPattern
/* dma method offsets, fields, and values */
#define NV018_SET_OBJECT                                           (0x00000000)
#define NV018_NO_OPERATION                                         (0x00000100)
#define NV018_NOTIFY                                               (0x00000104)
#define NV018_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV018_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV018_SET_COLOR_FORMAT                                     (0x00000300)
#define NV018_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV018_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV018_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV018_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV018_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV018_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV018_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV018_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV018_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV018_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV018_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV018_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV018_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV018_SET_MONOCHORME_PATTERN1                              (0x0000031C)
/* obsolete stuff */
#define NV01_IMAGE_PATTERN                                         (0x00000018)
#define NV1_IMAGE_PATTERN                                          (0x00000018)
#define Nv01ImagePattern                                     Nv01ContextPattern
#define nv01ImagePattern                                     Nv01ContextPattern
#define Nv1ImagePattern                                      Nv01ContextPattern
#define nv1ImagePattern                                      Nv01ContextPattern
#define nv01ContextPattern                                   Nv01ContextPattern


/* class NV01_CONTEXT_CLIP_RECTANGLE */
#define  NV01_CONTEXT_CLIP_RECTANGLE                               (0x00000019)
/* NvNotification[] elements */
#define NV019_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV019_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV019_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV019_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV019_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV019_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV019_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV019_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetPoint;                /* y_x S16_S16                      0300-0303*/
 NvV32 SetSize;                 /* height_width U16_U16             0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv019Typedef, Nv01ContextClipRectangle;
#define NV019_TYPEDEF                                  Nv01ContextClipRectangle
/* dma method offsets, fields, and values */
#define NV019_SET_OBJECT                                           (0x00000000)
#define NV019_NO_OPERATION                                         (0x00000100)
#define NV019_NOTIFY                                               (0x00000104)
#define NV019_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV019_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV019_SET_POINT                                            (0x00000300)
#define NV019_SET_POINT_X                                          15:0
#define NV019_SET_POINT_Y                                          31:16
#define NV019_SET_SIZE                                             (0x00000304)
#define NV019_SET_SIZE_WIDTH                                       15:0
#define NV019_SET_SIZE_HEIGHT                                      31:16
/* obsolete stuff */
#define NV01_IMAGE_BLACK_RECTANGLE                                 (0x00000019)
#define NV1_IMAGE_BLACK_RECTANGLE                                  (0x00000019)
#define Nv01ImageBlackRectangle                        Nv01ContextClipRectangle
#define nv01ImageBlackRectangle                        Nv01ContextClipRectangle
#define Nv1ImageBlackRectangle                         Nv01ContextClipRectangle
#define nv1ImageBlackRectangle                         Nv01ContextClipRectangle
#define nv01ContextClipRectangle                       Nv01ContextClipRectangle

typedef NvV32 Nv01aTypedef;

typedef NvV32 Nv01bTypedef;


/* class NV01_RENDER_SOLID_LIN */
#define  NV01_RENDER_SOLID_LIN                                     (0x0000001C)
/* NvNotification[] elements */
#define NV01C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01C_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV01C_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV01C_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point0;                 /* y_x S16_S16 in pixels               0-   3*/
  NvV32 point1;                 /* y_x S16_S16 in pixels               4-   7*/
 } Lin[16];                     /* end of aliased methods in array      -047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 point0X;                /* in pixels, 0 at left                0-   3*/
  NvS32 point0Y;                /* in pixels, 0 at top                 4-   7*/
  NvS32 point1X;                /* in pixels, 0 at left                8-   b*/
  NvS32 point1Y;                /* in pixels, 0 at top                 c-   f*/
 } Lin32[8];                    /* end of aliased methods in array      -04ff*/
 NvV32 PolyLin[32];             /* y_x S16_S16 in pixels            0500-057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } PolyLin32[16];               /* end of aliased methods in array      -05ff*/
 struct {                       /* start aliased methods in array   0600-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorPolyLin[16];            /* end of aliased methods in array      -067f*/
 NvV32 Reserved03[0x660];
} Nv01cTypedef, Nv01RenderSolidLin;
#define NV01C_TYPEDEF                                        Nv01RenderSolidLin
/* dma method offsets, fields, and values */
#define NV01C_SET_OBJECT                                           (0x00000000)
#define NV01C_NO_OPERATION                                         (0x00000100)
#define NV01C_NOTIFY                                               (0x00000104)
#define NV01C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01C_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01C_SET_OPERATION                                        (0x000002FC)
#define NV01C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01C_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01C_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01C_COLOR                                                (0x00000304)
#define NV01C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0(a)                                        (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0_X                                         15:0
#define NV01C_LIN_POINT0_Y                                         31:16
#define NV01C_LIN_POINT1(a)                                        (0x00000404\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT1_X                                         15:0
#define NV01C_LIN_POINT1_Y                                         31:16
#define NV01C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_X(a)                                    (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_Y(a)                                    (0x00000484\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_X(a)                                    (0x00000488\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_Y(a)                                    (0x0000048C\
                                                                   +(a)*0x0010)
#define NV01C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV01C_POLY_LIN_X                                           15:0
#define NV01C_POLY_LIN_Y                                           31:16
#define NV01C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_X(a)                                      (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_Y(a)                                      (0x00000584\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_COLOR(a)                              (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT(a)                              (0x00000604\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV01C_COLOR_POLY_LIN_POINT_Y                               31:16
/* obsolete stuff */
#define NV1_RENDER_SOLID_LIN                                       (0x0000001C)
#define Nv1RenderSolidLin                                    Nv01RenderSolidLin
#define nv1RenderSolidLin                                    Nv01RenderSolidLin
#define nv01RenderSolidLin                                   Nv01RenderSolidLin


/* class NV01_RENDER_SOLID_TRIANGLE */
#define  NV01_RENDER_SOLID_TRIANGLE                                (0x0000001D)
/* NvNotification[] elements */
#define NV01D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01D_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV01D_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV01D_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x002];
 NvV32 TrianglePoint0;          /* y_x S16_S16 in pixels            0310-0313*/
 NvV32 TrianglePoint1;          /* y_x S16_S16 in pixels            0314-0317*/
 NvV32 TrianglePoint2;          /* y_x S16_S16 in pixels            0318-031b*/
 NvV32 Reserved03[0x001];
 NvS32 Triangle32Point0X;       /* in pixels, 0 at left             0320-0323*/
 NvS32 Triangle32Point0Y;       /* in pixels, 0 at top              0324-0327*/
 NvS32 Triangle32Point1X;       /* in pixels, 0 at left             0328-032b*/
 NvS32 Triangle32Point1Y;       /* in pixels, 0 at top              032c-032f*/
 NvS32 Triangle32Point2X;       /* in pixels, 0 at left             0330-0333*/
 NvS32 Triangle32Point2Y;       /* in pixels, 0 at top              0334-0337*/
 NvV32 Reserved04[0x032];
 NvV32 Trimesh[32];             /* y_x S16_S16 in pixels            0400-047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } Trimesh32[16];               /* end of aliased methods in array      -04ff*/
 struct {                       /* start aliased methods in array   0500-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point0;                 /* y_x S16_S16 in pixels               4-   7*/
  NvV32 point1;                 /* y_x S16_S16 in pixels               8-   b*/
  NvV32 point2;                 /* y_x S16_S16 in pixels               c-   f*/
 } ColorTriangle[8];            /* end of aliased methods in array      -057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorTrimesh[16];            /* end of aliased methods in array      -05ff*/
 NvV32 Reserved05[0x680];
} Nv01dTypedef, Nv01RenderSolidTriangle;
#define NV01D_TYPEDEF                                   Nv01RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV01D_SET_OBJECT                                           (0x00000000)
#define NV01D_NO_OPERATION                                         (0x00000100)
#define NV01D_NOTIFY                                               (0x00000104)
#define NV01D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01D_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01D_SET_OPERATION                                        (0x000002FC)
#define NV01D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01D_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01D_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01D_COLOR                                                (0x00000304)
#define NV01D_TRIANGLE_POINT0                                      (0x00000310)
#define NV01D_TRIANGLE_POINT0_X                                    15:0
#define NV01D_TRIANGLE_POINT0_Y                                    31:16
#define NV01D_TRIANGLE_POINT1                                      (0x00000314)
#define NV01D_TRIANGLE_POINT1_X                                    15:0
#define NV01D_TRIANGLE_POINT1_Y                                    31:16
#define NV01D_TRIANGLE_POINT2                                      (0x00000318)
#define NV01D_TRIANGLE_POINT2_X                                    15:0
#define NV01D_TRIANGLE_POINT2_Y                                    31:16
#define NV01D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV01D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV01D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV01D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV01D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV01D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV01D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV01D_TRIMESH_X                                            15:0
#define NV01D_TRIMESH_Y                                            31:16
#define NV01D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV01D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT_X                                15:0
#define NV01D_COLOR_TRIMESH_POINT_Y                                31:16
/* obsolete stuff */
#define NV1_RENDER_SOLID_TRIANGLE                                  (0x0000001D)
#define Nv1RenderSolidTriangle                          Nv01RenderSolidTriangle
#define nv1RenderSolidTriangle                          Nv01RenderSolidTriangle
#define nv01RenderSolidTriangle                         Nv01RenderSolidTriangle


/* class NV01_RENDER_SOLID_RECTANGLE */
#define  NV01_RENDER_SOLID_RECTANGLE                               (0x0000001E)
/* NvNotification[] elements */
#define NV01E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV01E_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV01E_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* y_x S16_S16                         0-   3*/
  NvV32 size;                   /* height_width U16_U16                4-   7*/
 } Rectangle[16];               /* end of method in array in array      -047f*/
 NvV32 Reserved03[0x6e0];
} Nv01eTypedef, Nv01RenderSolidRectangle;
#define NV01E_TYPEDEF                                  Nv01RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV01E_SET_OBJECT                                           (0x00000000)
#define NV01E_NO_OPERATION                                         (0x00000100)
#define NV01E_NOTIFY                                               (0x00000104)
#define NV01E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01E_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01E_SET_OPERATION                                        (0x000002FC)
#define NV01E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01E_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01E_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01E_COLOR                                                (0x00000304)
#define NV01E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT_X                                    15:0
#define NV01E_RECTANGLE_POINT_Y                                    31:16
#define NV01E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV01E_RECTANGLE_SIZE_HEIGHT                                31:16
/* obsolete stuff */
#define NV1_RENDER_SOLID_RECTANGLE                                 (0x0000001E)
#define Nv1RenderSolidRectangle                        Nv01RenderSolidRectangle
#define nv1RenderSolidRectangle                        Nv01RenderSolidRectangle
#define nv01RenderSolidRectangle                       Nv01RenderSolidRectangle


/* class NV01_IMAGE_BLIT */
#define  NV01_IMAGE_BLIT                                           (0x0000001F)
/* NvNotification[] elements */
#define NV01F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV01F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV01_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurfaceSource; /* NV03_CONTEXT_SURFACE_2D_SOURCE   0198-019b*/
 NvV32 SetContextSurfaceDestin; /* NV03_CONTEXT_SURFACE_2D_DESTINAT 019c-019f*/
 NvV32 Reserved01[0x057];
 NvV32 SetOperation;            /* NV01F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved02[0x73d];
} Nv01fTypedef, Nv01ImageBlit;
#define NV01F_TYPEDEF                                             Nv01ImageBlit
/* dma method offsets, fields, and values */
#define NV01F_SET_OBJECT                                           (0x00000000)
#define NV01F_NO_OPERATION                                         (0x00000100)
#define NV01F_NOTIFY                                               (0x00000104)
#define NV01F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV01F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV01F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV01F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV01F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV01F_SET_CONTEXT_SURFACE_SOURCE                           (0x00000198)
#define NV01F_SET_CONTEXT_SURFACE_DESTIN                           (0x0000019C)
#define NV01F_SET_OPERATION                                        (0x000002FC)
#define NV01F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01F_CONTROL_POINT_IN                                     (0x00000300)
#define NV01F_CONTROL_POINT_IN_X                                   15:0
#define NV01F_CONTROL_POINT_IN_Y                                   31:16
#define NV01F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV01F_CONTROL_POINT_OUT_X                                  15:0
#define NV01F_CONTROL_POINT_OUT_Y                                  31:16
#define NV01F_SIZE                                                 (0x00000308)
#define NV01F_SIZE_WIDTH                                           15:0
#define NV01F_SIZE_HEIGHT                                          31:16
/* obsolete stuff */
#define NV1_IMAGE_BLIT                                             (0x0000001F)
#define Nv1ImageBlit                                              Nv01ImageBlit
#define nv1ImageBlit                                              Nv01ImageBlit
#define nv01ImageBlit                                             Nv01ImageBlit

typedef NvV32 Nv020Typedef;


/* class NV01_IMAGE_FROM_CPU */
#define  NV01_IMAGE_FROM_CPU                                       (0x00000021)
/* NvNotification[] elements */
#define NV021_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV021_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV021_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV021_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV021_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV021_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV021_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV01_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV021_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV021_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, in pixels  0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, in pixels  030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[32];               /* packed pixel(s) to add to image  0400-047f*/
 NvV32 Reserved03[0x6e0];
} Nv021Typedef, Nv01ImageFromCpu;
#define NV021_TYPEDEF                                          Nv01ImageFromCpu
/* dma method offsets, fields, and values */
#define NV021_SET_OBJECT                                           (0x00000000)
#define NV021_NO_OPERATION                                         (0x00000100)
#define NV021_NOTIFY                                               (0x00000104)
#define NV021_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV021_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV021_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV021_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV021_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV021_SET_CONTEXT_ROP                                      (0x00000190)
#define NV021_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV021_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV021_SET_OPERATION                                        (0x000002FC)
#define NV021_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV021_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV021_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV021_SET_COLOR_FORMAT                                     (0x00000300)
#define NV021_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV021_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV021_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV021_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV021_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV021_POINT                                                (0x00000304)
#define NV021_POINT_X                                              15:0
#define NV021_POINT_Y                                              31:16
#define NV021_SIZE_OUT                                             (0x00000308)
#define NV021_SIZE_OUT_WIDTH                                       15:0
#define NV021_SIZE_OUT_HEIGHT                                      31:16
#define NV021_SIZE_IN                                              (0x0000030C)
#define NV021_SIZE_IN_WIDTH                                        15:0
#define NV021_SIZE_IN_HEIGHT                                       31:16
#define NV021_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV1_IMAGE_FROM_CPU                                         (0x00000021)
#define Nv1ImageFromCpu                                        Nv01ImageFromCpu
#define nv1ImageFromCpu                                        Nv01ImageFromCpu
#define nv01ImageFromCpu                                       Nv01ImageFromCpu

typedef NvV32 Nv022Typedef;

typedef NvV32 Nv023Typedef;

typedef NvV32 Nv024Typedef;

typedef NvV32 Nv025Typedef;

typedef NvV32 Nv026Typedef;

typedef NvV32 Nv027Typedef;

typedef NvV32 Nv028Typedef;

typedef NvV32 Nv029Typedef;

typedef NvV32 Nv02aTypedef;

typedef NvV32 Nv02bTypedef;

typedef NvV32 Nv02cTypedef;

typedef NvV32 Nv02dTypedef;

typedef NvV32 Nv02eTypedef;

typedef NvV32 Nv02fTypedef;


/* class NV01_NULL */
#define  NV01_NULL                                                 (0x00000030)
/* NvNotification[] fields and values */
#define NV030_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv030Typedef, Nv01Null;
#define NV030_TYPEDEF                                              Nv01Null
/* obsolete stuff */
#define NV1_NULL                                                   (0x00000030)
#define Nv1Null                                                    Nv01Null
#define nv1Null                                                    Nv01Null
#define nv01Null                                                   Nv01Null

typedef NvV32 Nv031Typedef;

typedef NvV32 Nv032Typedef;

typedef NvV32 Nv033Typedef;

typedef NvV32 Nv034Typedef;

typedef NvV32 Nv035Typedef;



/* class NV03_STRETCHED_IMAGE_FROM_CPU */
#define  NV03_STRETCHED_IMAGE_FROM_CPU                             (0x00000036)
/* NvNotification[] elements */
#define NV036_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV036_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV036_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV036_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV036_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV036_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV036_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV01_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x059];
 NvV32 SetOperation;            /* NV036_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV036_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DeltaDxDu;               /* S12d20 ratio dx/du               0308-030b*/
 NvV32 DeltaDyDv;               /* S12d20 ratio dy/dv               030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv036Typedef, Nv03StretchedImageFromCpu;
#define NV036_TYPEDEF                                 Nv03StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV036_SET_OBJECT                                           (0x00000000)
#define NV036_NO_OPERATION                                         (0x00000100)
#define NV036_NOTIFY                                               (0x00000104)
#define NV036_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV036_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV036_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV036_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV036_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV036_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV036_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV036_SET_OPERATION                                        (0x000002FC)
#define NV036_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV036_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV036_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV036_SET_COLOR_FORMAT                                     (0x00000300)
#define NV036_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV036_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV036_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV036_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV036_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV036_SIZE_IN                                              (0x00000304)
#define NV036_SIZE_IN_WIDTH                                        15:0
#define NV036_SIZE_IN_HEIGHT                                       31:16
#define NV036_DELTA_DX_DU                                          (0x00000308)
#define NV036_DELTA_DY_DV                                          (0x0000030C)
#define NV036_CLIP_POINT                                           (0x00000310)
#define NV036_CLIP_POINT_X                                         15:0
#define NV036_CLIP_POINT_Y                                         31:16
#define NV036_CLIP_SIZE                                            (0x00000314)
#define NV036_CLIP_SIZE_WIDTH                                      15:0
#define NV036_CLIP_SIZE_HEIGHT                                     31:16
#define NV036_POINT_12D4                                           (0x00000318)
#define NV036_POINT_12D4_X                                         15:0
#define NV036_POINT_12D4_Y                                         31:16
#define NV036_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV3_STRETCHED_IMAGE_FROM_CPU                               (0x00000036)
#define Nv3StretchedImageFromCpu                      Nv03StretchedImageFromCpu
#define nv3StretchedImageFromCpu                      Nv03StretchedImageFromCpu
#define nv03StretchedImageFromCpu                     Nv03StretchedImageFromCpu


/* class NV03_SCALED_IMAGE_FROM_MEMORY */
#define  NV03_SCALED_IMAGE_FROM_MEMORY                             (0x00000037)
/* NvNotification[] elements */
#define NV037_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV037_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV037_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV037_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV037_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV037_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV037_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0194-0197*/
 NvV32 Reserved01[0x05A];
 NvV32 SetColorFormat;          /* NV037_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV037_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DeltaDuDx;               /* S12d20 ratio du/dx               0318-031b*/
 NvV32 DeltaDvDy;               /* S12d20 ratio dv/dy               031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvU32 ImageInPitch;            /* bytes, vertical pixel delta      0404-0407*/
 NvU32 ImageInOffset;           /* byte offset of top-left texel    0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv037Typedef, Nv03ScaledImageFromMemory;
#define NV037_TYPEDEF                                 Nv03ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV037_SET_OBJECT                                           (0x00000000)
#define NV037_NO_OPERATION                                         (0x00000100)
#define NV037_NOTIFY                                               (0x00000104)
#define NV037_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV037_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV037_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV037_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV037_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV037_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV037_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV037_SET_COLOR_FORMAT                                     (0x00000300)
#define NV037_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV037_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV037_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV037_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV037_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV037_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV037_SET_OPERATION                                        (0x00000304)
#define NV037_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV037_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV037_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV037_CLIP_POINT                                           (0x00000308)
#define NV037_CLIP_POINT_X                                         15:0
#define NV037_CLIP_POINT_Y                                         31:16
#define NV037_CLIP_SIZE                                            (0x0000030C)
#define NV037_CLIP_SIZE_WIDTH                                      15:0
#define NV037_CLIP_SIZE_HEIGHT                                     31:16
#define NV037_IMAGE_OUT_POINT                                      (0x00000310)
#define NV037_IMAGE_OUT_POINT_X                                    15:0
#define NV037_IMAGE_OUT_POINT_Y                                    31:16
#define NV037_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV037_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV037_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV037_DELTA_DU_DX                                          (0x00000318)
#define NV037_DELTA_DV_DY                                          (0x0000031C)
#define NV037_IMAGE_IN_SIZE                                        (0x00000400)
#define NV037_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV037_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV037_IMAGE_IN_PITCH                                       (0x00000404)
#define NV037_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV037_IMAGE_IN_POINT                                       (0x0000040C)
#define NV037_IMAGE_IN_POINT_U                                     15:0
#define NV037_IMAGE_IN_POINT_V                                     31:16
/* obsolete stuff */
#define NV3_SCALED_IMAGE_FROM_MEMORY                               (0x00000037)
#define Nv3ScaledImageFromMemory                      Nv03ScaledImageFromMemory
#define nv3ScaledImageFromMemory                      Nv03ScaledImageFromMemory
#define nv03ScaledImageFromMemory                     Nv03ScaledImageFromMemory


/* class NV04_DVD_SUBPICTURE */
#define  NV04_DVD_SUBPICTURE                                       (0x00000038)
/* NvNotification[] elements */
#define NV038_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV038_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV038_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV038_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV038_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV038_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV038_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV038_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaOverlay;    /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageIn;    /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextDmaImageOut;   /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0300-0303*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0304-0307*/
 NvU32 ImageOutFormat;          /* color_pitch V16_U16              0308-030b*/
 NvU32 ImageOutOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 ImageInDeltaDuDx;        /* S12d20 ratio du/dx               0310-0313*/
 NvV32 ImageInDeltaDvDy;        /* S12d20 ratio dv/dy               0314-0317*/
 NvV32 ImageInSize;             /* height_width U16_U16 in texels   0318-031b*/
 NvV32 ImageInFormat;           /* color_pitch V16_U16              031c-031f*/
 NvU32 ImageInOffset;           /* byte offset of top-left texel    0320-0323*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4 in texels        0324-0317*/
 NvV32 OverlayDeltaDuDx;        /* S12d20 ratio du/dx               0328-032b*/
 NvV32 OverlayDeltaDvDy;        /* S12d20 ratio dv/dy               032c-032f*/
 NvV32 OverlaySize;             /* height_width U16_U16 in texels   0330-0333*/
 NvV32 OverlayFormat;           /* color_pitch V16_U16              0334-0337*/
 NvU32 OverlayOffset;           /* byte offset of top-left texel    0338-033b*/
 NvV32 OverlayPoint;            /* v_u U12d4_U12d4 in texels        033c-033f*/
 NvV32 Reserved02[0x730];
} Nv038Typedef, Nv04DvdSubpicture;
#define NV038_TYPEDEF                                         Nv04DvdSubpicture
/* dma method offsets, fields, and values */
#define NV038_SET_OBJECT                                           (0x00000000)
#define NV038_NO_OPERATION                                         (0x00000100)
#define NV038_NOTIFY                                               (0x00000104)
#define NV038_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV038_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV038_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV038_SET_CONTEXT_DMA_OVERLAY                              (0x00000184)
#define NV038_SET_CONTEXT_DMA_IMAGE_IN                             (0x00000188)
#define NV038_SET_CONTEXT_DMA_IMAGE_OUT                            (0x0000018C)
#define NV038_IMAGE_OUT_POINT                                      (0x00000300)
#define NV038_IMAGE_OUT_POINT_X                                    15:0
#define NV038_IMAGE_OUT_POINT_Y                                    31:16
#define NV038_IMAGE_OUT_SIZE                                       (0x00000304)
#define NV038_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV038_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV038_IMAGE_OUT_FORMAT                                     (0x00000308)
#define NV038_IMAGE_OUT_FORMAT_PITCH                               15:0
#define NV038_IMAGE_OUT_FORMAT_COLOR                               31:16
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8                 (0x00000001)
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8                 (0x00000002)
#define NV038_IMAGE_OUT_OFFSET                                     (0x0000030C)
#define NV038_IMAGE_IN_DELTA_DU_DX                                 (0x00000310)
#define NV038_IMAGE_IN_DELTA_DV_DY                                 (0x00000314)
#define NV038_IMAGE_IN_SIZE                                        (0x00000318)
#define NV038_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV038_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV038_IMAGE_IN_FORMAT                                      (0x0000031C)
#define NV038_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV038_IMAGE_IN_FORMAT_COLOR                                31:16
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8                  (0x00000001)
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8                  (0x00000002)
#define NV038_IMAGE_IN_OFFSET                                      (0x00000320)
#define NV038_IMAGE_IN_POINT                                       (0x00000324)
#define NV038_IMAGE_IN_POINT_U                                     15:0
#define NV038_IMAGE_IN_POINT_V                                     31:16
#define NV038_OVERLAY_DELTA_DU_DX                                  (0x00000328)
#define NV038_OVERLAY_DELTA_DV_DY                                  (0x0000032C)
#define NV038_OVERLAY_SIZE                                         (0x00000330)
#define NV038_OVERLAY_SIZE_WIDTH                                   15:0
#define NV038_OVERLAY_SIZE_HEIGHT                                  31:16
#define NV038_OVERLAY_FORMAT                                       (0x00000334)
#define NV038_OVERLAY_FORMAT_PITCH                                 15:0
#define NV038_OVERLAY_FORMAT_COLOR                                 31:16
#define NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8                     (0x00000001)
#define NV038_OVERLAY_FORMAT_COLOR_LE_A4V6YB6A4U6YA6               (0x00000002)
#define NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT                  (0x00000003)
#define NV038_OVERLAY_OFFSET                                       (0x00000338)
#define NV038_OVERLAY_POINT                                        (0x0000033C)
#define NV038_OVERLAY_POINT_U                                      15:0
#define NV038_OVERLAY_POINT_V                                      31:16
/* obsolete stuff */
#define NV4_DVD_SUBPICTURE                                         (0x00000038)
#define Nv4DvdSubpicture                                      Nv04DvdSubpicture
#define nv4DvdSubpicture                                      Nv04DvdSubpicture
#define nv04DvdSubpicture                                     Nv04DvdSubpicture


/* class NV03_MEMORY_TO_MEMORY_FORMAT */
#define  NV03_MEMORY_TO_MEMORY_FORMAT                              (0x00000039)
/* NvNotification[] elements */
#define NV039_NOTIFIERS_NOTIFY                                     (0)
#define NV039_NOTIFIERS_BUFFER_NOTIFY                              (1)
/* NvNotification[] fields and values */
#define NV039_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV039_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV039_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV039_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV039_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV039_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV039_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaBufferIn;   /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaBufferOut;  /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x060];
 NvU32 OffsetIn;                /* src offset in bytes              030c-030f*/
 NvU32 OffsetOut;               /* dst offset in bytes              0310-0313*/
 NvS32 PitchIn;                 /* delta in bytes, vert pixel delta 0314-0317*/
 NvS32 PitchOut;                /* delta in bytes, vert pixel delta 0318-031b*/
 NvU32 LineLengthIn;            /* in bytes                         031c-031f*/
 NvU32 LineCount;               /* in lines                         0320-0323*/
 NvV32 Format;                  /* out_in U24_U8                    0324-0327*/
 NvV32 BufferNotify;            /* NV039_BUFFER_NOTIFY_*            0328-032b*/
 NvV32 Reserved02[0x735];
} Nv039Typedef, Nv03MemoryToMemoryFormat;
#define NV039_TYPEDEF                                  Nv03MemoryToMemoryFormat
/* dma method offsets, fields, and values */
#define NV039_SET_OBJECT                                           (0x00000000)
#define NV039_NO_OPERATION                                         (0x00000100)
#define NV039_NOTIFY                                               (0x00000104)
#define NV039_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV039_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV039_SET_CONTEXT_DMA_BUFFER_IN                            (0x00000184)
#define NV039_SET_CONTEXT_DMA_BUFFER_OUT                           (0x00000188)
#define NV039_OFFSET_IN                                            (0x0000030C)
#define NV039_OFFSET_OUT                                           (0x00000310)
#define NV039_PITCH_IN                                             (0x00000314)
#define NV039_PITCH_OUT                                            (0x00000318)
#define NV039_LINE_LENGTH_IN                                       (0x0000031C)
#define NV039_LINE_COUNT                                           (0x00000320)
#define NV039_FORMAT                                               (0x00000324)
#define NV039_FORMAT_IN                                            7:0
#define NV039_FORMAT_OUT                                           31:8
#define NV039_BUFFER_NOTIFY                                        (0x00000328)
#define NV039_BUFFER_NOTIFY_WRITE_ONLY                             (0x00000000)
#define NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN                      (0x00000001)
/* obsolete stuff */
#define NV3_MEMORY_TO_MEMORY_FORMAT                                (0x00000039)
#define Nv3MemoryToMemoryFormat                        Nv03MemoryToMemoryFormat
#define nv3MemoryToMemoryFormat                        Nv03MemoryToMemoryFormat
#define nv03MemoryToMemoryFormat                       Nv03MemoryToMemoryFormat

typedef NvV32 Nv03aTypedef;

typedef NvV32 Nv03bTypedef;

typedef NvV32 Nv03cTypedef;

/* class NV01_CONTEXT_DMA_IN_MEMORY */
#define  NV01_CONTEXT_DMA_IN_MEMORY                                (0x0000003D)
/* NvNotification[] fields and values */
#define NV03D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv03dTypedef, Nv01ContextDmaInMemory;
#define  NV03D_TYPEDEF                                   Nv01ContextDmaInMemory
/* obsolete stuff */
#define  NV1_CONTEXT_DMA_IN_MEMORY                                 (0x0000003D)
#define  Nv1ContextDmaInMemory                           Nv01ContextDmaInMemory
#define  nv1ContextDmaInMemory                           Nv01ContextDmaInMemory
#define  nv01ContextDmaInMemory                          Nv01ContextDmaInMemory


#define  NV01_MEMORY_SYSTEM                                        (0x0000003E)
/* obsolete stuff */
/* class NV01_CONTEXT_ERROR_TO_MEMORY */
#define   NV01_CONTEXT_ERROR_TO_MEMORY                             (0x0000003E)
/* NvNotification[] fields and values */
#define NV03E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv03eTypedef, Nv01ContextErrorToMemory;
#define  NV03E_TYPEDEF                                 Nv01ContextErrorToMemory
#define  NV1_CONTEXT_ERROR_TO_MEMORY                               (0x0000003E)
#define  Nv1ContextErrorToMemory                       Nv01ContextErrorToMemory
#define  nv1ContextErrorToMemory                       Nv01ContextErrorToMemory
#define  nv01ContextErrorToMemory                      Nv01ContextErrorToMemory


/* class NV01_MEMORY_LOCAL_PRIVILEGED */
#define  NV01_MEMORY_LOCAL_PRIVILEGED                              (0x0000003F)
/* NvNotification[] fields and values */
#define NV03F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv03fTypedef, Nv01MemoryLocalPrivileged;
#define NV03F_TYPEDEF                                 Nv01MemoryLocalPrivileged
/* obsolete stuff */
#define NV01_MEMORY_PRIVILEGED                                     (0x0000003F)
#define NV1_MEMORY_PRIVILEGED                                      (0x0000003F)
#define Nv01MemoryPrivileged                          Nv01MemoryLocalPrivileged
#define nv01MemoryPrivileged                          Nv01MemoryLocalPrivileged
#define Nv1MemoryPrivileged                           Nv01MemoryLocalPrivileged
#define nv1MemoryPrivileged                           Nv01MemoryLocalPrivileged
#define nv01MemoryLocalPrivileged                     Nv01MemoryLocalPrivileged


/* class NV01_MEMORY_LOCAL_USER */

/* Class MEMORY_LOCAL_USER refers to framebuffer heap memory that is local to our device
   and accessable to every client.  This is in contrast to MEMORY_SYSTEM, that is 
   considered local to the system CPU, and MEMORY_LOCAL_PRIVILEGED, that refers to
   local instance memory and the local priveledge register space. - Chuck Moidel*/

/* Please note that RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) 
   do VERY different things.  The older RmAllocMemory(NV01_MEMORY_LOCAL_USER) function does 
   not allocate ANY framebuffer memory.  It only allocates and returns a dumb linear mapping
   to the entire framebuffer. RmAlloc(NV01_MEMORY_LOCAL USER) on the other hand allocates blocks
   from the framebuffer heap.  - Chuck Moidel*/

#define  NV01_MEMORY_LOCAL_USER                                    (0x00000040)
/* NvNotification[] fields and values */
#define NV040_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv040Typedef, Nv01MemoryLocalUser;
#define NV040_TYPEDEF                                       Nv01MemoryLocalUser
/* obsolete stuff */
#define NV01_MEMORY_USER                                           (0x00000040)
#define NV1_MEMORY_USER                                            (0x00000040)
#define Nv01MemoryUser                                      Nv01MemoryLocalUser
#define nv01MemoryUser                                      Nv01MemoryLocalUser
#define Nv1MemoryUser                                       Nv01MemoryLocalUser
#define nv1MemoryUser                                       Nv01MemoryLocalUser
#define nv01MemoryLocalUser                                 Nv01MemoryLocalUser


/* class NV03_VIDEO_LUT_CURSOR_PAL */
#define  NV03_VIDEO_LUT_CURSOR_PAL                                 (0x00000041)
/* NvNotification[] elements */
#define NV041_NOTIFIERS_NOTIFY                                     (0)
#define NV041_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV041_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (3+(b))
#define NV041_NOTIFIERS_SET_LUT(b)                                 (5+(b))
#define NV041_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (7+(b))
#define NV041_NOTIFIERS_SET_CURSOR_POINT(b)                        (9+(b))
#define NV041_NOTIFIERS_SET_ENCODER(b)                             (11+(b))
/* NvNotification[] fields and values */
#define NV041_NOTIFICATION_INFO16_OFFSET_VALID                     (0x0001)
#define NV041_NOTIFICATION_INFO16_OFFSET_INVALID                   (0x0002)
#define NV041_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV041_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV041_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV041_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV041_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV041_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV041_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV041_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV041_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01D];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 SetContextDmaCursor;     /* NV01_CONTEXT_DMA                 0190-0193*/
 NvV32 Reserved01[0x05B];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvU32 size;                   /* height_width U16_U16 in pixels      4-   7*/
  NvV32 format;                 /* pitch_color_field_notify            8-   b*/
 } SetImage[2];                 /* end of methods in array              -0317*/
 NvV32 GetImageOffsetNotify[2]; /* NV041_GET_IMAGE_OFFSET_NOTIFY_*  0318-031f*/
 NvV32 SetLut[2];               /* notify_offset V02_U30            0320-0327*/
 NvV32 SetCursorImage[2];       /* notify_offset V02_U30            0328-032f*/
 NvV32 SetCursorPoint[2];       /* notify_y_x V02_S14_S16           0330-0337*/
 NvV32 SetEncoder[2];           /* see text                         0338-033f*/
 NvV32 Reserved02[0x730];
} Nv041Typedef, Nv03VideoLutCursorPal;
#define NV041_TYPEDEF                                     Nv03VideoLutCursorPal
/* dma method offsets, fields, and values */
#define NV041_SET_OBJECT                                           (0x00000000)
#define NV041_NO_OPERATION                                         (0x00000100)
#define NV041_NOTIFY                                               (0x00000104)
#define NV041_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV041_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV041_STOP_TRANSFER                                        (0x00000108)
#define NV041_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV041_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV041_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV041_SET_CONTEXT_DMA_LUT                                  (0x0000018C)
#define NV041_SET_CONTEXT_DMA_CURSOR                               (0x00000190)
#define NV041_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_SIZE(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV041_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV041_SET_IMAGE_FORMAT(b)                                  (0x00000308\
                                                                   +(b)*0x000C)
#define NV041_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV041_SET_IMAGE_FORMAT_COLOR                               23:16
#define NV041_SET_IMAGE_FORMAT_COLOR_LUT_LE_Y8                     (0x00000000)
#define NV041_SET_IMAGE_FORMAT_COLOR_BYPASS_LE_R5G6B5              (0x00000001)
#define NV041_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1R5G5B5              (0x00000002)
#define NV041_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1X7R8G8B8            (0x00000003)
#define NV041_SET_IMAGE_FORMAT_FIELD                               29:24
#define NV041_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV041_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV041_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV041_SET_IMAGE_FORMAT_NOTIFY                              31:30
#define NV041_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000318\
                                                                   +(b)*0x0004)
#define NV041_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_SET_LUT(b)                                           (0x00000320\
                                                                   +(b)*0x0004)
#define NV041_SET_LUT_OFFSET                                       29:0
#define NV041_SET_LUT_NOTIFY                                       31:30
#define NV041_SET_LUT_NOTIFY_WRITE_ONLY                            (0x00000000)
#define NV041_SET_LUT_NOTIFY_WRITE_THEN_AWAKEN                     (0x00000001)
#define NV041_SET_CURSOR_IMAGE(b)                                  (0x00000328\
                                                                   +(b)*0x0004)
#define NV041_SET_CURSOR_IMAGE_OFFSET                              29:0
#define NV041_SET_CURSOR_IMAGE_NOTIFY                              31:30
#define NV041_SET_CURSOR_IMAGE_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_SET_CURSOR_IMAGE_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_SET_CURSOR_POINT(b)                                  (0x00000330\
                                                                   +(b)*0x0004)
#define NV041_SET_CURSOR_POINT_X                                   15:0
#define NV041_SET_CURSOR_POINT_Y                                   29:16
#define NV041_SET_CURSOR_POINT_NOTIFY                              31:30
#define NV041_SET_CURSOR_POINT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV041_SET_CURSOR_POINT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV041_SET_ENCODER(b)                                       (0x00000338\
                                                                   +(b)*0x0004)
#define NV041_SET_ENCODER_UNDERSCAN_LEFT                           4:0
#define NV041_SET_ENCODER_UNDERSCAN_RIGHT                          9:5
#define NV041_SET_ENCODER_UNDERSCAN_TOP                            14:10
#define NV041_SET_ENCODER_UNDERSCAN_BOTTOM                         19:15
#define NV041_SET_ENCODER_FILTER_HORIZONTAL                        21:20
#define NV041_SET_ENCODER_FILTER_HORIZONTAL_ZOH                    (0x00000000)
#define NV041_SET_ENCODER_FILTER_HORIZONTAL_FOH                    (0x00000001)
#define NV041_SET_ENCODER_FILTER_HORIZONTAL_SOH                    (0x00000002)
#define NV041_SET_ENCODER_FILTER_VERTICAL                          23:22
#define NV041_SET_ENCODER_FILTER_VERTICAL_ZOH                      (0x00000000)
#define NV041_SET_ENCODER_FILTER_VERTICAL_FOH                      (0x00000001)
#define NV041_SET_ENCODER_FILTER_VERTICAL_SOH                      (0x00000002)
#define NV041_SET_ENCODER_VERTICAL_FRONT_PORCH_ADJUST              29:24
#define NV041_SET_ENCODER_REFRESH                                  30:30
#define NV041_SET_ENCODER_REFRESH_INTERLACED                       (0x00000000)
#define NV041_SET_ENCODER_REFRESH_NONINTERLACED                    (0x00000001)
#define NV041_SET_ENCODER_NOTIFY                                   31:31
#define NV041_SET_ENCODER_NOTIFY_WRITE_ONLY                        (0x00000000)
#define NV041_SET_ENCODER_NOTIFY_WRITE_THEN_AWAKEN                 (0x00000001)


/* class NV04_CONTEXT_SURFACES_2D */
#define  NV04_CONTEXT_SURFACES_2D                                  (0x00000042)
/* NvNotification[] elements */
#define NV042_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV042_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV042_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV042_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV042_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV042_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV042_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV042_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImageSource;/* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageDestin;/* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05d];
 NvV32 SetColorFormat;          /* NV042_SET_COLOR_FORMAT_*         0300-0303*/
 NvU32 SetPitch;                /* destin_source U16_U16            0304-0307*/
 NvU32 SetOffsetSource;         /* byte offset of top-left pixel    0308-030b*/
 NvU32 SetOffsetDestin;         /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved02[0x73c];
} Nv042Typedef, Nv04ContextSurfaces2d;
#define NV042_TYPEDEF                                     Nv04ContextSurfaces2d
/* dma method offsets, fields, and values */
#define NV042_SET_OBJECT                                           (0x00000000)
#define NV042_NO_OPERATION                                         (0x00000100)
#define NV042_NOTIFY                                               (0x00000104)
#define NV042_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV042_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV042_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV042_SET_CONTEXT_DMA_IMAGE_SOURCE                         (0x00000184)
#define NV042_SET_CONTEXT_DMA_IMAGE_DESTIN                         (0x00000188)
#define NV042_SET_COLOR_FORMAT                                     (0x00000300)
#define NV042_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV042_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000004)
#define NV042_SET_COLOR_FORMAT_LE_Y16                              (0x00000005)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV042_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x0000000A)
#define NV042_SET_COLOR_FORMAT_LE_Y32                              (0x0000000B)
#define NV042_SET_PITCH                                            (0x00000304)
#define NV042_SET_PITCH_SOURCE                                     15:0
#define NV042_SET_PITCH_DESTIN                                     31:16
#define NV042_SET_OFFSET_SOURCE                                    (0x00000308)
#define NV042_SET_OFFSET_DESTIN                                    (0x0000030C)
/* obsolete stuff */
#define NV4_CONTEXT_SURFACES_2D                                    (0x00000042)
#define Nv4ContextSurfaces2d                              Nv04ContextSurfaces2d
#define nv4ContextSurfaces2d                              Nv04ContextSurfaces2d
#define nv4ContextSurfaces2D                              Nv04ContextSurfaces2d
#define nv04ContextSurfaces2d                             Nv04ContextSurfaces2d


/* class NV03_CONTEXT_ROP */
#define  NV03_CONTEXT_ROP                                          (0x00000043)
/* NvNotification[] elements */
#define NV043_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV043_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV043_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV043_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV043_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV043_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV043_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV043_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetRop5;                 /* 32-bit ROP5                      0300-0303*/
 NvV32 Reserved02[0x73f];
} Nv043Typedef, Nv03ContextRop;
#define NV043_TYPEDEF                                            Nv03ContextRop
/* dma method offsets, fields, and values */
#define NV043_SET_OBJECT                                           (0x00000000)
#define NV043_NO_OPERATION                                         (0x00000100)
#define NV043_NOTIFY                                               (0x00000104)
#define NV043_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV043_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV043_SET_ROP5                                             (0x00000300)
/* obsolete stuff */
#define NV3_CONTEXT_ROP                                            (0x00000043)
#define Nv3ContextRop                                            Nv03ContextRop
#define nv3ContextRop                                            Nv03ContextRop
#define nv03ContextRop                                           Nv03ContextRop


/* class NV04_CONTEXT_PATTERN */
#define  NV04_CONTEXT_PATTERN                                      (0x00000044)
/* NvNotification[] elements */
#define NV044_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV044_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV044_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV044_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV044_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV044_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV044_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV044_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV044_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV044_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 SetMonochromeShape;      /* NV044_SET_MONOCHROME_SHAPE_*     0308-030b*/
 NvV32 SetPatternSelect;        /* NV044_SET_PATTERN_SELECT_*       030c-030f*/
 NvV32 SetMonochromeColor0;     /* color of 0 pixels                0310-0313*/
 NvV32 SetMonochromeColor1;     /* color of 1 pixels                0314-0317*/
 NvV32 SetMonochromePattern0;   /* first  32 bits of pattern data   0318-031b*/
 NvV32 SetMonochromePattern1;   /* second 32 bits of pattern data   031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 SetPatternY8[16];        /* y3_y2_y1_y0 U8_U8_U8_U8          0400-043f*/
 NvV32 Reserved03[0x030];
 NvV32 SetPatternR5G6B5[32];    /* see text                         0500-057f*/
 NvV32 Reserved04[0x020];
 NvV32 SetPatternX1R5G5B5[32];  /* see text                         0600-067f*/
 NvV32 Reserved05[0x020];
 NvV32 SetPatternX8R8G8B8[64];  /* ignore_red_green_blu U8_U8_U8_U8 0700-07ff*/
 NvV32 Reserved06[0x600];
} Nv044Typedef, Nv04ContextPattern;
#define NV044_TYPEDEF                                          Nv04ContextPattern
/* dma method offsets, fields, and values */
#define NV044_SET_OBJECT                                           (0x00000000)
#define NV044_NO_OPERATION                                         (0x00000100)
#define NV044_NOTIFY                                               (0x00000104)
#define NV044_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV044_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV044_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV044_SET_COLOR_FORMAT                                     (0x00000300)
#define NV044_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV044_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV044_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV044_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV044_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV044_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV044_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV044_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV044_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV044_SET_PATTERN_SELECT                                   (0x0000030C)
#define NV044_SET_PATTERN_SELECT_MONOCHROME                        (0x00000001)
#define NV044_SET_PATTERN_SELECT_COLOR                             (0x00000002)
#define NV044_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV044_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV044_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV044_SET_MONOCHORME_PATTERN1                              (0x0000031C)

#define NV044_SET_MONOCHROME_COLOR0                                (0x00000310)
#define NV044_SET_MONOCHROME_COLOR1                                (0x00000314)
#define NV044_SET_MONOCHROME_PATTERN0                              (0x00000318)
#define NV044_SET_MONOCHROME_PATTERN1                              (0x0000031C)

#define NV044_SET_PATTERN_Y8(i)                                    (0x00000400\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_Y8_Y0                                    7:0
#define NV044_SET_PATTERN_Y8_Y1                                    15:8
#define NV044_SET_PATTERN_Y8_Y2                                    23:16
#define NV044_SET_PATTERN_Y8_Y3                                    31:24
#define NV044_SET_PATTERN_R5G6B5(i)                                (0x00000500\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_R5G6B5_BLUE0                             4:0
#define NV044_SET_PATTERN_R5G6B5_GREEN0                            10:5
#define NV044_SET_PATTERN_R5G6B5_RED0                              15:11
#define NV044_SET_PATTERN_R5G6B5_BLUE1                             20:16
#define NV044_SET_PATTERN_R5G6B5_GREEN1                            26:21
#define NV044_SET_PATTERN_R5G6B5_RED1                              31:27
#define NV044_SET_PATTERN_X1R5G5B5(i)                              (0x00000600\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X1R5G5B5_BLUE0                           4:0
#define NV044_SET_PATTERN_X1R5G5B5_GREEN0                          9:5
#define NV044_SET_PATTERN_X1R5G5B5_RED0                            14:10
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE0                         15:15
#define NV044_SET_PATTERN_X1R5G5B5_BLUE1                           20:16
#define NV044_SET_PATTERN_X1R5G5B5_GREEN1                          25:21
#define NV044_SET_PATTERN_X1R5G5B5_RED1                            30:26
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE1                         31:31
#define NV044_SET_PATTERN_X8R8G8B8(i)                              (0x00000700\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X8R8G8B8_BLUE                            7:0
#define NV044_SET_PATTERN_X8R8G8B8_GREEN                           15:8
#define NV044_SET_PATTERN_X8R8G8B8_RED                             23:16
#define NV044_SET_PATTERN_X8R8G8B8_IGNORE                          31:24
/* obsolete stuff */
#define NV4_CONTEXT_PATTERN                                        (0x00000044)
#define Nv04ImagePattern                                     Nv04ContextPattern
#define Nv4ImagePattern                                      Nv04ContextPattern
#define nv4ImagePattern                                      Nv04ContextPattern
#define Nv4ContextPattern                                    Nv04ContextPattern
#define nv4ContextPattern                                    Nv04ContextPattern
#define nv04ContextPattern                                   Nv04ContextPattern


/* class NV03_VIDEO_LUT_CURSOR_NTSC */
#define  NV03_VIDEO_LUT_CURSOR_NTSC                                (0x00000045)
/* NvNotification[] elements */
#define NV045_NOTIFIERS_NOTIFY                                     (0)
#define NV045_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV045_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (3+(b))
#define NV045_NOTIFIERS_SET_LUT(b)                                 (5+(b))
#define NV045_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (7+(b))
#define NV045_NOTIFIERS_SET_CURSOR_POINT(b)                        (9+(b))
#define NV045_NOTIFIERS_SET_ENCODER(b)                             (11+(b))
/* NvNotification[] fields and values */
#define NV045_NOTIFICATION_INFO16_OFFSET_VALID                     (0x0001)
#define NV045_NOTIFICATION_INFO16_OFFSET_INVALID                   (0x0002)
#define NV045_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV045_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV045_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV045_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV045_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV045_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV045_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV045_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV045_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01D];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 SetContextDmaCursor;     /* NV01_CONTEXT_DMA                 0190-0193*/
 NvV32 Reserved01[0x05B];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvU32 size;                   /* height_width U16_U16 in pixels      4-   7*/
  NvV32 format;                 /* pitch_color_field_notify            8-   b*/
 } SetImage[2];                 /* end of methods in array              -0317*/
 NvV32 GetImageOffsetNotify[2]; /* NV045_GET_IMAGE_OFFSET_NOTIFY_*  0318-031f*/
 NvV32 SetLut[2];               /* notify_offset V02_U30            0320-0327*/
 NvV32 SetCursorImage[2];       /* notify_offset V02_U30            0328-032f*/
 NvV32 SetCursorPoint[2];       /* notify_y_x V02_S14_S16           0330-0337*/
 NvV32 SetEncoder[2];           /* see text                         0338-033f*/
 NvV32 Reserved02[0x730];
} Nv045Typedef, Nv03VideoLutCursorNtsc;
#define NV045_TYPEDEF                                    Nv03VideoLutCursorNtsc
/* dma method offsets, fields, and values */
#define NV045_SET_OBJECT                                           (0x00000000)
#define NV045_NO_OPERATION                                         (0x00000100)
#define NV045_NOTIFY                                               (0x00000104)
#define NV045_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV045_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV045_STOP_TRANSFER                                        (0x00000108)
#define NV045_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV045_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV045_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV045_SET_CONTEXT_DMA_LUT                                  (0x0000018C)
#define NV045_SET_CONTEXT_DMA_CURSOR                               (0x00000190)
#define NV045_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_SIZE(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV045_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV045_SET_IMAGE_FORMAT(b)                                  (0x00000308\
                                                                   +(b)*0x000C)
#define NV045_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV045_SET_IMAGE_FORMAT_COLOR                               23:16
#define NV045_SET_IMAGE_FORMAT_COLOR_LUT_LE_Y8                     (0x00000000)
#define NV045_SET_IMAGE_FORMAT_COLOR_BYPASS_LE_R5G6B5              (0x00000001)
#define NV045_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1R5G5B5              (0x00000002)
#define NV045_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1X7R8G8B8            (0x00000003)
#define NV045_SET_IMAGE_FORMAT_FIELD                               29:24
#define NV045_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV045_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV045_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV045_SET_IMAGE_FORMAT_NOTIFY                              31:30
#define NV045_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000318\
                                                                   +(b)*0x0004)
#define NV045_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_SET_LUT(b)                                           (0x00000320\
                                                                   +(b)*0x0004)
#define NV045_SET_LUT_OFFSET                                       29:0
#define NV045_SET_LUT_NOTIFY                                       31:30
#define NV045_SET_LUT_NOTIFY_WRITE_ONLY                            (0x00000000)
#define NV045_SET_LUT_NOTIFY_WRITE_THEN_AWAKEN                     (0x00000001)
#define NV045_SET_CURSOR_IMAGE(b)                                  (0x00000328\
                                                                   +(b)*0x0004)
#define NV045_SET_CURSOR_IMAGE_OFFSET                              29:0
#define NV045_SET_CURSOR_IMAGE_NOTIFY                              31:30
#define NV045_SET_CURSOR_IMAGE_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_SET_CURSOR_IMAGE_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_SET_CURSOR_POINT(b)                                  (0x00000330\
                                                                   +(b)*0x0004)
#define NV045_SET_CURSOR_POINT_X                                   15:0
#define NV045_SET_CURSOR_POINT_Y                                   29:16
#define NV045_SET_CURSOR_POINT_NOTIFY                              31:30
#define NV045_SET_CURSOR_POINT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV045_SET_CURSOR_POINT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV045_SET_ENCODER(b)                                       (0x00000338\
                                                                   +(b)*0x0004)
#define NV045_SET_ENCODER_UNDERSCAN_LEFT                           4:0
#define NV045_SET_ENCODER_UNDERSCAN_RIGHT                          9:5
#define NV045_SET_ENCODER_UNDERSCAN_TOP                            14:10
#define NV045_SET_ENCODER_UNDERSCAN_BOTTOM                         19:15
#define NV045_SET_ENCODER_FILTER_HORIZONTAL                        21:20
#define NV045_SET_ENCODER_FILTER_HORIZONTAL_ZOH                    (0x00000000)
#define NV045_SET_ENCODER_FILTER_HORIZONTAL_FOH                    (0x00000001)
#define NV045_SET_ENCODER_FILTER_HORIZONTAL_SOH                    (0x00000002)
#define NV045_SET_ENCODER_FILTER_VERTICAL                          23:22
#define NV045_SET_ENCODER_VERTICAL_FRONT_PORCH_ADJUST              29:24
#define NV045_SET_ENCODER_FILTER_VERTICAL_ZOH                      (0x00000000)
#define NV045_SET_ENCODER_FILTER_VERTICAL_FOH                      (0x00000001)
#define NV045_SET_ENCODER_FILTER_VERTICAL_SOH                      (0x00000002)
#define NV045_SET_ENCODER_REFRESH                                  30:30
#define NV045_SET_ENCODER_REFRESH_INTERLACED                       (0x00000000)
#define NV045_SET_ENCODER_REFRESH_NONINTERLACED                    (0x00000001)
#define NV045_SET_ENCODER_NOTIFY                                   31:31
#define NV045_SET_ENCODER_NOTIFY_WRITE_ONLY                        (0x00000000)
#define NV045_SET_ENCODER_NOTIFY_WRITE_THEN_AWAKEN                 (0x00000001)


/* class NV04_VIDEO_LUT_CURSOR_DAC */
#define  NV04_VIDEO_LUT_CURSOR_DAC                                 (0x00000046)
/* NvNotification[] elements */
#define NV046_NOTIFIERS_NOTIFY                                     (0)
#define NV046_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV046_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV046_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV046_NOTIFIERS_SET_DAC(b)                                 (7+(b))
/* NvNotification[] fields and values */
#define NV046_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV046_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV046_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV046_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV046_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV046_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV046_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV046_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV046_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV046_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV046_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 GetOffset;               /* NV046_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify_pitch V1_U16_U16             4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalBlank;        /* width_start U16_U16 in pixels       4-   7*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       8-   b*/
  NvV32 verticalBlank;          /* width_start U16_U16 in pixels       c-   f*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels      10-  13*/
  NvV32 totalSize;              /* height_width U16_U16               14-  17*/
  NvV32 pixelClock;             /* in Hertz                           18-  1b*/
  NvV32 format;                 /* see text                           1c-  1f*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x720];
} Nv046Typedef, Nv04VideoLutCursorDac;
#define NV046_TYPEDEF                                     Nv04VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV046_SET_OBJECT                                           (0x00000000)
#define NV046_NO_OPERATION                                         (0x00000100)
#define NV046_NOTIFY                                               (0x00000104)
#define NV046_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV046_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV046_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV046_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV046_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV046_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV046_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV046_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV046_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV046_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV046_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV046_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV046_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV046_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV046_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV046_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV046_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV046_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV046_SET_PAN_OFFSET                                       (0x00000220)
#define NV046_GET_OFFSET                                           (0x000002FC)
#define NV046_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV046_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV046_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV046_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV046_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV046_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV046_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV046_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV046_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV046_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV046_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV046_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV046_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV046_SET_CURSOR_POINT                                     (0x00000330)
#define NV046_SET_CURSOR_POINT_X                                   15:0
#define NV046_SET_CURSOR_POINT_Y                                   31:16
#define NV046_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_HORIZONTAL_BLANK(b)                          (0x00000344\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_HORIZONTAL_BLANK_START                       15:0
#define NV046_SET_DAC_HORIZONTAL_BLANK_WIDTH                       31:16
#define NV046_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000348\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV046_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV046_SET_DAC_VERTICAL_BLANK(b)                            (0x0000034c\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_VERTICAL_BLANK_START                         15:0
#define NV046_SET_DAC_VERTICAL_BLANK_WIDTH                         31:16
#define NV046_SET_DAC_VERTICAL_SYNC(b)                             (0x00000350\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV046_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV046_SET_DAC_TOTAL_SIZE(b)                                (0x00000354\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_PIXEL_CLOCK(b)                               (0x00000358\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_FORMAT(b)                                    (0x0000035c\
                                                                   +(b)*0x0020)
#define NV046_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV046_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV046_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV046_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV046_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV046_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV046_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV046_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV046_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV046_SET_DAC_FORMAT_COLOR                                 19:16
#define NV046_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV046_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV046_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV046_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV046_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV046_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV046_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV046_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV046_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)


/* class NV04_VIDEO_OVERLAY */
#define  NV04_VIDEO_OVERLAY                                        (0x00000047)
/* NvNotification[] elements */
#define NV047_NOTIFIERS_NOTIFY                                     (0)
#define NV047_NOTIFIERS_SET_OVERLAY(b)                             (1+(b))
/* NvNotification[] fields and values */
#define NV047_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV047_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV047_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV047_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV047_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV047_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV047_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV047_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 StopOverlay[2];          /* NV047_STOP_OVERLAY_*             0120-0127*/
 NvV32 Reserved01[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved02[0x006];
 NvV32 SetContextDmaOverlay[2]; /* NV01_CONTEXT_DMA                 019c-01a3*/
 NvV32 Reserved03[0x056];
 NvV32 GetOffset;               /* NV047_GET_OFFSET_*               02FC-02FF*/
 NvV32 Reserved04[0x040];
 struct {                       /* start of methods in array        0400-    */
  NvV32 reserved05[0x017];      /* see text                           00-  5b*/
  NvV32 colorKey;               /* see text                           5c-  5f*/
  NvU32 offset;                 /* byte offset of top-left texel      60-  63*/
  NvV32 sizeIn;                 /* height_width U16_U16               64-  67*/
  NvV32 pointIn;                /* t_s U12d4_U12d4                    68-  6b*/
  NvV32 dsDx;                   /* U12d20 ds/dx                       6c-  6f*/
  NvV32 dtDy;                   /* U12d20 dt/dy                       70-  73*/
  NvV32 pointOut;               /* y_x U16_U16                        74-  77*/
  NvV32 sizeOut;                /* height_width U16_U16               78-  7b*/
  NvV32 format;                 /* format_display_color_pitch         7c-  7f*/
 } SetOverlay[2];               /* end of methods in array              -04ff*/
 NvV32 SetOverlayPointOutA;     /* y_x U16_U16                      0500-0503*/
 NvV32 Reserved06[0x6bf];
} Nv047Typedef, Nv04VideoOverlay;
#define NV047_TYPEDEF                                          Nv04VideoOverlay
/* dma method offsets, fields, and values */
#define NV047_SET_OBJECT                                           (0x00000000)
#define NV047_NO_OPERATION                                         (0x00000100)
#define NV047_NOTIFY                                               (0x00000104)
#define NV047_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV047_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV047_STOP_OVERLAY(b)                                      (0x00000120\
                                                                   +(b)*0x0004)
#define NV047_STOP_OVERLAY_AS_SOON_AS_POSSIBLE                     (0x00000000)
#define NV047_STOP_OVERLAY_BETWEEN_BUFFERS                         (0x00000001)
#define NV047_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV047_SET_CONTEXT_DMA_OVERLAY(b)                           (0x0000019C\
                                                                   +(b)*0x0004)
#define NV047_SET_OVERLAY(b)                                       (0x00000400\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_COLORKEY(b)                              (0x0000045C\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_OFFSET(b)                                (0x00000460\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_SIZE_IN(b)                               (0x00000464\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_SIZE_IN_WIDTH                            15:0
#define NV047_SET_OVERLAY_SIZE_IN_HEIGHT                           31:16
#define NV047_SET_OVERLAY_POINT_IN(b)                              (0x00000468\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_POINT_IN_S                               15:0
#define NV047_SET_OVERLAY_POINT_IN_T                               31:16
#define NV047_SET_OVERLAY_DS_DX(b)                                 (0x0000046C\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_DT_DY(b)                                 (0x00000470\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_POINT_OUT(b)                             (0x00000474\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_POINT_OUT_X                              15:0
#define NV047_SET_OVERLAY_POINT_OUT_Y                              31:16
#define NV047_SET_OVERLAY_SIZE_OUT(b)                              (0x00000478\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_SIZE_OUT_WIDTH                           15:0
#define NV047_SET_OVERLAY_SIZE_OUT_HEIGHT                          31:16
#define NV047_SET_OVERLAY_FORMAT(b)                                (0x0000047C\
                                                                   +(b)*0x0080)
#define NV047_SET_OVERLAY_FORMAT_PITCH                             15:0
#define NV047_SET_OVERLAY_FORMAT_COLOR                             19:16
#define NV047_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8             (0x00000000)
#define NV047_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8             (0x00000001)
#define NV047_SET_OVERLAY_FORMAT_DISPLAY                           30:20
#define NV047_SET_OVERLAY_FORMAT_DISPLAY_ALWAYS                    (0x00000000)
#define NV047_SET_OVERLAY_FORMAT_DISPLAY_COLOR_KEY_EQUAL           (0x00000001)
#define NV047_SET_OVERLAY_FORMAT_NOTIFY                            31:31
#define NV047_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY                 (0x00000000)
#define NV047_SET_OVERLAY_FORMAT_NOTIFY_WRITE_THEN_AWAKEN          (0x00000001)
#define NV047_SET_OVERLAY_POINT_OUT_A                              (0x00000500)
#define NV047_SET_OVERLAY_POINT_OUT_A_X                            15:0
#define NV047_SET_OVERLAY_POINT_OUT_A_Y                            31:16

/* class NV03_DX3_TEXTURED_TRIANGLE */
#define  NV03_DX3_TEXTURED_TRIANGLE                                (0x00000048)
/* NvNotification[] elements */
#define NV048_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV048_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV048_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV048_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV048_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV048_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV048_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaTexture;    /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextSurfaceColor;  /* NV03_CONTEXT_SURFACE_3D_COLOR    018c-018f*/
 NvV32 SetContextSurfaceZeta;   /* NV03_CONTEXT_SURFACE_3D_DEPTH    0190-0193*/
 NvV32 Reserved01[0x05c];
 NvU32 TextureOffset;           /* offset in bytes                  0304-0307*/
 NvV32 TextureFormat;           /* see text                         0308-030b*/
 NvV32 TextureFilter;           /* ignre_sizeAdjust_spreadY_spreadX 030c-030f*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0310-0313*/
 NvV32 Control0;                /* see text                         0314-0317*/
 NvV32 Control1;                /* alphafunc_alpharef V24_U8        0318-031b*/
 NvV32 Reserved02[0x339];
 struct {                       /* start of method in array         1000-    */
  NvV32 specular;               /* fog_i5-i0 U0d8_U4_U4_U4_U4_U4_U4   00-  03*/
  NvV32 color;                  /* X8R8G8B8 or A8R8G8B8               04-  07*/
  NvF32 sx;                     /* screen x coordinate                08-  0b*/
  NvF32 sy;                     /* screen y coordinate                0c-  0f*/
  NvF32 sz;                     /* screen z coordinate                10-  13*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     14-  17*/
  NvF32 tu;                     /* texture u coordinate               18-  1b*/
  NvF32 tv;                     /* texture v coordinate               1c-  1f*/
 } Tlvertex[128];               /* end of method in array               -1fff*/
} Nv048Typedef, Nv03Dx3TexturedTriangle;
#define NV048_TYPEDEF                                   Nv03Dx3TexturedTriangle
/* dma method offsets, fields, and values */
#define NV048_SET_OBJECT                                           (0x00000000)
#define NV048_NO_OPERATION                                         (0x00000100)
#define NV048_NOTIFY                                               (0x00000104)
#define NV048_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV048_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV048_SET_CONTEXT_DMA_TEXTURE                              (0x00000184)
#define NV048_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV048_SET_CONTEXT_SURFACE_COLOR                            (0x0000018C)
#define NV048_SET_CONTEXT_SURFACE_ZETA                             (0x00000190)
#define NV048_TEXTURE_OFFSET                                       (0x00000304)
#define NV048_TEXTURE_FORMAT                                       (0x00000308)
#define NV048_TEXTURE_FORMAT_VALUE                                 15:0
#define NV048_TEXTURE_FORMAT_KEY                                   19:16
#define NV048_TEXTURE_FORMAT_KEY_DISABLED                          (0x00000000)
#define NV048_TEXTURE_FORMAT_KEY_ENABLED                           (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR                                 23:20
#define NV048_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                     (0x00000000)
#define NV048_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                     (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                     (0x00000002)
#define NV048_TEXTURE_FORMAT_COLOR_LE_R5G6B5                       (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN                              27:24
#define NV048_TEXTURE_FORMAT_SIZE_MIN_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FORMAT_SIZE_MAX                              31:28
#define NV048_TEXTURE_FORMAT_SIZE_MAX_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FILTER                                       (0x0000030C)
#define NV048_TEXTURE_FILTER_SPREAD_X                              4:0
#define NV048_TEXTURE_FILTER_IGNORE0                               7:5
#define NV048_TEXTURE_FILTER_SPREAD_Y                              12:8
#define NV048_TEXTURE_FILTER_IGNORE1                               15:13
#define NV048_TEXTURE_FILTER_SIZE_ADJUST                           23:16
#define NV048_TEXTURE_FILTER_IGNORE2                               31:24
#define NV048_FOG_COLOR                                            (0x00000310)
#define NV048_CONTROL0                                             (0x00000314)
#define NV048_CONTROL0_INTERPOLATOR                                3:0
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CORNER                     (0x00000000)
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CENTER                     (0x00000001)
#define NV048_CONTROL0_INTERPOLATOR_FOH_CENTER                     (0x00000002)
#define NV048_CONTROL0_WRAP_U                                      5:4
#define NV048_CONTROL0_WRAP_U_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_U_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_U_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_U_CLAMP                                (0x00000003)
#define NV048_CONTROL0_WRAP_V                                      7:6
#define NV048_CONTROL0_WRAP_V_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_V_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_V_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_V_CLAMP                                (0x00000003)
#define NV048_CONTROL0_COLOR_FORMAT                                9:8
#define NV048_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8                    (0x00000000)
#define NV048_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8                    (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR                                11:10
#define NV048_CONTROL0_SOURCE_COLOR_NORMAL                         (0x00000000)
#define NV048_CONTROL0_SOURCE_COLOR_COLOR_INVERSE                  (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_INVERSE                  (0x00000002)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_ONE                      (0x00000003)
#define NV048_CONTROL0_CULLING                                     14:12
#define NV048_CONTROL0_CULLING_NONE                                (0x00000001)
#define NV048_CONTROL0_CULLING_COUNTERCLOCKWISE                    (0x00000002)
#define NV048_CONTROL0_CULLING_CLOCKWISE                           (0x00000003)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE                        15:15
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV048_CONTROL0_ZFUNC                                       19:16
#define NV048_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV048_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV048_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV048_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV048_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV048_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV048_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV048_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV048_CONTROL0_ZETA_WRITE                                  23:20
#define NV048_CONTROL0_ZETA_WRITE_NEVER                            (0x00000000)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA                            (0x00000001)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA_ZETA                       (0x00000002)
#define NV048_CONTROL0_ZETA_WRITE_ZETA                             (0x00000003)
#define NV048_CONTROL0_ZETA_WRITE_ALWAYS                           (0x00000004)
#define NV048_CONTROL0_COLOR_WRITE                                 27:24
#define NV048_CONTROL0_COLOR_WRITE_NEVER                           (0x00000000)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA                           (0x00000001)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA_ZETA                      (0x00000002)
#define NV048_CONTROL0_COLOR_WRITE_ZETA                            (0x00000003)
#define NV048_CONTROL0_COLOR_WRITE_ALWAYS                          (0x00000004)
#define NV048_CONTROL0_ROP                                         28:28
#define NV048_CONTROL0_ROP_BLEND_AND                               (0x00000000)
#define NV048_CONTROL0_ROP_ADD_WITH_SATURATION                     (0x00000001)
#define NV048_CONTROL0_BLEND_BETA                                  29:29
#define NV048_CONTROL0_BLEND_BETA_SRCALPHA                         (0x00000000)
#define NV048_CONTROL0_BLEND_BETA_DESTCOLOR                        (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT0                                30:30
#define NV048_CONTROL0_BLEND_INPUT0_DESTCOLOR                      (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT0_ZERO                           (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT1                                31:31
#define NV048_CONTROL0_BLEND_INPUT1_SRCCOLOR                       (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT1_ZERO                           (0x00000001)
#define NV048_CONTROL1                                             (0x00000318)
#define NV048_CONTROL1_ALPHAREF                                    7:0
#define NV048_CONTROL1_ALPHAFUNC                                   31:8
#define NV048_CONTROL1_ALPHAFUNC_NEVER                             (0x00000001)
#define NV048_CONTROL1_ALPHAFUNC_LESS                              (0x00000002)
#define NV048_CONTROL1_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV048_CONTROL1_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV048_CONTROL1_ALPHAFUNC_GREATER                           (0x00000005)
#define NV048_CONTROL1_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV048_CONTROL1_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV048_CONTROL1_ALPHAFUNC_ALWAYS                            (0x00000008)

#define NV048_TLVERTEX(a)                                          (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR(a)                                 (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR_I0                                 3:0
#define NV048_TLVERTEX_SPECULAR_I1                                 7:4
#define NV048_TLVERTEX_SPECULAR_I2                                 11:8
#define NV048_TLVERTEX_SPECULAR_I3                                 15:12
#define NV048_TLVERTEX_SPECULAR_I4                                 19:16
#define NV048_TLVERTEX_SPECULAR_I5                                 23:20
#define NV048_TLVERTEX_SPECULAR_FOG                                31:24
#define NV048_TLVERTEX_COLOR(a)                                    (0x00001004\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SX(a)                                       (0x00001008\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SY(a)                                       (0x0000100C\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SZ(a)                                       (0x00001010\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_RHW(a)                                      (0x00001014\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TU(a)                                       (0x00001018\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TV(a)                                       (0x0000101C\
                                                                   +(a)*0x0020)
/* obsolete stuff */
#define NV3_DX3_TEXTURED_TRIANGLE                                  (0x00000048)
#define Nv3Dx3TexturedTriangle                          Nv03Dx3TexturedTriangle
#define nv3Dx3TexturedTriangle                          Nv03Dx3TexturedTriangle
#define nv03Dx3TexturedTriangle                         Nv03Dx3TexturedTriangle

/* class NV05_VIDEO_LUT_CURSOR_DAC */
#define  NV05_VIDEO_LUT_CURSOR_DAC                                 (0x00000049)
#define NV049_NOTIFIERS_NOTIFY                                     (0)
#define NV049_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV049_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV049_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV049_NOTIFIERS_SET_DAC(b)                                 (7+(b))
#define NV049_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV049_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV049_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV049_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV049_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV049_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV049_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV049_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV049_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV049_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV049_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV049_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 GetOffset;               /* NV049_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* see text                            4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       4-   7*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels       8-   b*/
  NvV32 totalSize;              /* height_width U16_U16                c-   f*/
  NvV32 pixelClock;             /* in Hertz                           10-  13*/
  NvV32 format;                 /* see text                           14-  17*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x724];
} Nv049Typedef, NV05VideoLutCursorDac;
#define NV049_TYPEDEF                                     NV05VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV049_SET_OBJECT                                           (0x00000000)
#define NV049_NO_OPERATION                                         (0x00000100)
#define NV049_NOTIFY                                               (0x00000104)
#define NV049_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV049_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV049_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV049_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV049_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV049_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV049_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV049_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV049_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV049_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV049_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV049_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV049_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV049_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV049_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV049_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV049_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV049_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV049_SET_PAN_OFFSET                                       (0x00000220)
#define NV049_GET_OFFSET                                           (0x000002FC)
#define NV049_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV049_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV049_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV049_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV049_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV049_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV049_SET_IMAGE_FORMAT_WHEN                                30:20
#define NV049_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER              (0x00000000)
#define NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY                    (0x00000001)
#define NV049_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV049_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV049_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV049_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV049_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV049_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV049_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV049_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV049_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV049_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV049_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV049_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV049_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV049_SET_CURSOR_POINT                                     (0x00000330)
#define NV049_SET_CURSOR_POINT_X                                   15:0
#define NV049_SET_CURSOR_POINT_Y                                   31:16
#define NV049_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV049_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV049_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000344\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV049_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV049_SET_DAC_VERTICAL_SYNC(b)                             (0x00000348\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV049_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV049_SET_DAC_TOTAL_SIZE(b)                                (0x0000034C\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV049_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV049_SET_DAC_PIXEL_CLOCK(b)                               (0x00000350\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_FORMAT(b)                                    (0x00000354\
                                                                   +(b)*0x0018)
#define NV049_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV049_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV049_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV049_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV049_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV049_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV049_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV049_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV049_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV049_SET_DAC_FORMAT_COLOR                                 19:16
#define NV049_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV049_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV049_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV049_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV049_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV049_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV049_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV049_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV049_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV049_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV049_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)


/* class NV04_GDI_RECTANGLE_TEXT */
#define  NV04_GDI_RECTANGLE_TEXT                                   (0x0000004A)
/* NvNotification[] elements */
#define NV04A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* memory data structures */
typedef struct {                /* start of data structure          0000-    */
   NvV32 size;                  /* height_width U16_U16 in pixels      0-   3*/
   NvV32 monochrome[1];         /* 32 monochrome pixels per write      4-   7*/
} Nv04aCharacter8[];            /* end of data structure                -0007*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels      0-   3*/
  NvV32 monochrome[3];          /* 32 monochrome pixels per write      4-   f*/
} Nv04aCharacter16[];           /* end of data structure                -000f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[7];          /* 32 monochrome pixels per write     04-  1f*/
} Nv04aCharacter32[];           /* end of data structure                -001f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[15];         /* 32 monochrome pixels per write     04-  3f*/
} Nv04aCharacter64[];           /* end of data structure                -003f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[31];         /* 32 monochrome pixels per write     04-  7f*/
} Nv04aCharacter128[];          /* end of data structure                -007f*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels     00-  03*/
  NvV32 monochrome[63];         /* 32 monochrome pixels per write     04-  ff*/
} Nv04aCharacter256[];          /* end of data structure                -00ff*/
typedef struct {                /* start of data structure          0000-    */
  NvV32 size;                   /* height_width U16_U16 in pixels    000- 003*/
  NvV32 monochrome[127];        /* 32 monochrome pixels per write    004- 1ff*/
} Nv04aCharacter512[];          /* end of data structure                -01ff*/
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaFonts;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV04A_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV04A_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV04A_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 Reserved02[0x03D];
 NvV32 Color1A;                 /* rectangle color                  03fc-03ff*/
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* x_y S16_S16 in pixels               0-   3*/
  NvV32 size;                   /* width_height U16_U16 in pixels      4-   7*/
 } UnclippedRectangle[32];      /* end of aliased methods in array      -04ff*/
 NvV32 Reserved03[0x03D];
 NvV32 ClipPoint0B;             /* top_left S16_S16 in pixels       05f4-05f7*/
 NvV32 ClipPoint1B;             /* bottom_right S16_S16 in pixels   05f8-05fb*/
 NvV32 Color1B;                 /* rectangle color                  05fc-05ff*/
 struct {                       /* start aliased methods in array   0600-    */
  NvV32 point0;                 /* top_left S16_S16 in pixels          0-   3*/
  NvV32 point1;                 /* bottom_right S16_S16 in pixels      4-   7*/
 } ClippedRectangle[32];        /* end of aliased methods in array      -06ff*/
 NvV32 Reserved04[0x03B];
 NvV32 ClipPoint0C;             /* top_left S16_S16 in pixels       07ec-07ef*/
 NvV32 ClipPoint1C;             /* bottom_right S16_S16 in pixe     07f0-07f3*/
 NvV32 Color1C;                 /* color of 1 pixels                07f4-07f7*/
 NvV32 SizeC;                   /* height_width U16_U16 in pixels   07f8-07fb*/
 NvV32 PointC;                  /* y_x S16_S16 in pixels            07fc-07ff*/
 NvV32 MonochromeColor1C[128];  /* 32 monochrome pixels per write   0800-09ff*/
 NvV32 Reserved05[0x079];
 NvV32 ClipPoint0E;             /* top_left S16_S16 in pixels       0be4-0be7*/
 NvV32 ClipPoint1E;             /* bottom_right S16_S16 in pixels   0be8-0beb*/
 NvV32 Color0E;                 /* color of 0 pixels                0bec-0bef*/
 NvV32 Color1E;                 /* color of 1 pixels                0bf0-0bf3*/
 NvV32 SizeInE;                 /* height_width U16_U16 in pixels   0bf4-0bf7*/
 NvV32 SizeOutE;                /* height_width U16_U16 in pixels   0bf8-0bfb*/
 NvV32 PointE;                  /* y_x S16_S16 in pixels            0bfc-0bff*/
 NvV32 MonochromeColor01E[128]; /* 32 monochrome pixels per write   0c00-0dff*/
 NvV32 Reserved06[0x07C];
 NvV32 FontF;                   /* pitch_offset V4_U28              0ff0-0ff3*/
 NvV32 ClipPoint0F;             /* top_left S16_S16 in pixels       0ff4-0ff7*/
 NvV32 ClipPoint1F;             /* bottom_right S16_S16 in pixels   0ff8-0ffb*/
 NvV32 Color1F;                 /* color of 1 pixels                0ffc-0fff*/
 NvV32 CharacterColor1F[256];   /* y_x_index S12_S12_U8             1000-13ff*/
 NvV32 Reserved07[0x0FC];
 NvV32 FontG;                   /* pitch_offset V4_U28              17f0-17f3*/
 NvV32 ClipPoint0G;             /* top_left S16_S16 in pixels       17f4-17f7*/
 NvV32 ClipPoint1G;             /* bottom_right S16_S16 in pixels   17f8-17fb*/
 NvV32 Color1G;                 /* color of 1 pixels                17fc-17ff*/
 struct {                       /* start aliased methods in array   1800-    */
  NvV32 point;                  /* y_x S16_S16 in pixels               0-   3*/
  NvU32 index;                  /* 0<=index<=65525                     4-   7*/
 } CharacterColor1G[256];       /* end of aliased methods in array      -1fff*/
} Nv04aTypedef, Nv04GdiRectangleText;
#define NV04A_TYPEDEF                                      Nv04GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04A_SET_OBJECT                                           (0x00000000)
#define NV04A_NO_OPERATION                                         (0x00000100)
#define NV04A_NOTIFY                                               (0x00000104)
#define NV04A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04A_SET_CONTEXT_DMA_FONTS                                (0x00000184)
#define NV04A_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV04A_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV04A_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV04A_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV04A_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV04A_SET_OPERATION                                        (0x000002FC)
#define NV04A_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04A_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04A_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04A_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV04A_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV04A_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV04A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV04A_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04A_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04A_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04A_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04A_COLOR1_A                                             (0x000003FC)
#define NV04A_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT_Y                          15:0
#define NV04A_UNCLIPPED_RECTANGLE_POINT_X                          31:16
#define NV04A_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      15:0
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       31:16
#define NV04A_CLIP_POINT0_B                                        (0x000005F4)
#define NV04A_CLIP_POINT0_B_LEFT                                   15:0
#define NV04A_CLIP_POINT0_B_TOP                                    31:16
#define NV04A_CLIP_POINT1_B                                        (0x000005F8)
#define NV04A_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04A_COLOR1_B                                             (0x000005FC)
#define NV04A_CLIPPED_RECTANGLE(a)                                 (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0(a)                         (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0_LEFT                       15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_0_TOP                        31:16
#define NV04A_CLIPPED_RECTANGLE_POINT_1(a)                         (0x00000604\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_1_RIGHT                      15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM                     31:16
#define NV04A_CLIP_POINT0_C                                        (0x000007EC)
#define NV04A_CLIP_POINT0_C_LEFT                                   15:0
#define NV04A_CLIP_POINT0_C_TOP                                    31:16
#define NV04A_CLIP_POINT1_C                                        (0x000007F0)
#define NV04A_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04A_COLOR1_C                                             (0x000007F4)
#define NV04A_SIZE_C                                               (0x000007F8)
#define NV04A_SIZE_C_WIDTH                                         15:0
#define NV04A_SIZE_C_HEIGHT                                        31:16
#define NV04A_POINT_C                                              (0x000007FC)
#define NV04A_POINT_C_X                                            15:0
#define NV04A_POINT_C_Y                                            31:16
#define NV04A_MONOCHROME_COLOR1_C(a)                               (0x00000800\
                                                                   +(a)*0x0004)
#define NV04A_CLIP_POINT0_E                                        (0x00000BE4)
#define NV04A_CLIP_POINT0_E_LEFT                                   15:0
#define NV04A_CLIP_POINT0_E_TOP                                    31:16
#define NV04A_CLIP_POINT1_E                                        (0x00000BE8)
#define NV04A_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04A_COLOR0_E                                             (0x00000BEC)
#define NV04A_COLOR1_E                                             (0x00000BF0)
#define NV04A_SIZE_IN_E                                            (0x00000BF4)
#define NV04A_SIZE_IN_E_WIDTH                                      15:0
#define NV04A_SIZE_IN_E_HEIGHT                                     31:16
#define NV04A_SIZE_OUT_E                                           (0x00000BF8)
#define NV04A_SIZE_OUT_E_WIDTH                                     15:0
#define NV04A_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04A_POINT_E                                              (0x00000BFC)
#define NV04A_POINT_E_X                                            15:0
#define NV04A_POINT_E_Y                                            31:16
#define NV04A_MONOCHROME_COLOR01_E(a)                              (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04A_FONT_F                                               (0x00000FF0)
#define NV04A_FONT_F_OFFSET                                        27:0
#define NV04A_FONT_F_PITCH                                         31:28
#define NV04A_FONT_F_PITCH_8                                       (0x00000003)
#define NV04A_FONT_F_PITCH_16                                      (0x00000004)
#define NV04A_FONT_F_PITCH_32                                      (0x00000005)
#define NV04A_FONT_F_PITCH_64                                      (0x00000006)
#define NV04A_FONT_F_PITCH_128                                     (0x00000007)
#define NV04A_FONT_F_PITCH_256                                     (0x00000008)
#define NV04A_FONT_F_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_F                                        (0x00000FF4)
#define NV04A_CLIP_POINT0_F_LEFT                                   15:0
#define NV04A_CLIP_POINT0_F_TOP                                    31:16
#define NV04A_CLIP_POINT1_F                                        (0x00000FF8)
#define NV04A_CLIP_POINT1_F_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_F_BOTTOM                                 31:16
#define NV04A_COLOR1_F                                             (0x00000FFC)
#define NV04A_CHARACTER_COLOR1_F(a)                                (0x00001000\
                                                                   +(a)*0x0004)
#define NV04A_CHARACTER_COLOR1_F_INDEX                             7:0
#define NV04A_CHARACTER_COLOR1_F_X                                 19:8
#define NV04A_CHARACTER_COLOR1_F_Y                                 31:20
#define NV04A_FONT_G                                               (0x000017F0)
#define NV04A_FONT_G_OFFSET                                        27:0
#define NV04A_FONT_G_PITCH                                         31:28
#define NV04A_FONT_G_PITCH_8                                       (0x00000003)
#define NV04A_FONT_G_PITCH_16                                      (0x00000004)
#define NV04A_FONT_G_PITCH_32                                      (0x00000005)
#define NV04A_FONT_G_PITCH_64                                      (0x00000006)
#define NV04A_FONT_G_PITCH_128                                     (0x00000007)
#define NV04A_FONT_G_PITCH_256                                     (0x00000008)
#define NV04A_FONT_G_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_G                                        (0x000017F4)
#define NV04A_CLIP_POINT0_G_LEFT                                   15:0
#define NV04A_CLIP_POINT0_G_TOP                                    31:16
#define NV04A_CLIP_POINT1_G                                        (0x000017F8)
#define NV04A_CLIP_POINT1_G_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_G_BOTTOM                                 31:16
#define NV04A_COLOR1_G                                             (0x000017FC)
#define NV04A_CHARACTER_COLOR1_G(a)                                (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT(a)                          (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT_X                           15:0
#define NV04A_CHARACTER_COLOR1_G_POINT_Y                           31:16
#define NV04A_CHARACTER_COLOR1_G_INDEX(a)                          (0x00001804\
                                                                   +(a)*0x0008)
/* obsolete stuff */
#define NV4_GDI_RECTANGLE_TEXT                                     (0x0000004A)
#define Nv4GdiRectangleText                                Nv04GdiRectangleText
#define nv4GdiRectangleText                                Nv04GdiRectangleText
#define nv04GdiRectangleText                               Nv04GdiRectangleText


/* class NV03_GDI_RECTANGLE_TEXT */
#define  NV03_GDI_RECTANGLE_TEXT                                   (0x0000004B)
/* NvNotification[] elements */
#define NV04B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04B_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextPattern;       /* NV01_CONTEXT_PATTERN             0184-0187*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0188-018b*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                018c-018f*/
 NvV32 SetContextSurface;       /* NV03_CONTEXT_SURFACE_2D_DESTINAT 0190-0193*/
 NvV32 Reserved01[0x05a];
 NvV32 SetOperation;            /* NV04B_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV04B_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetMonochromeFormat;     /* NV04B_SET_MONOCHROME_FORMAT_*    0304-0307*/
 NvV32 Reserved02[0x03d];
 NvV32 Color1A;                 /* rectangle color                  03fc-03ff*/
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* x_y S16_S16 in pixels               0-   3*/
  NvV32 size;                   /* width_height U16_U16 in pixels      4-   7*/
 } UnclippedRectangle[64];      /* end of aliased methods in array      -05ff*/
 NvV32 Reserved03[0x07D];
 NvV32 ClipPoint0B;             /* top_left S16_S16 in pixels       07f4-07f7*/
 NvV32 ClipPoint1B;             /* bottom_right S16_S16 in pixels   07f8-07fb*/
 NvV32 Color1B;                 /* rectangle color                  07fc-07ff*/
 struct {                       /* start aliased methods in array   0800-    */
  NvV32 point0;                 /* top_left S16_S16 in pixels          0-   3*/
  NvV32 point1;                 /* bottom_right S16_S16 in pixels      4-   7*/
 } ClippedRectangle[64];        /* end of aliased methods in array      -09ff*/
 NvV32 Reserved04[0x07B];
 NvV32 ClipPoint0C;             /* top_left S16_S16 in pixels       0bec-0bef*/
 NvV32 ClipPoint1C;             /* bottom_right S16_S16 in pixels   0bf0-0bf3*/
 NvV32 Color1C;                 /* color of 1 pixels                0bf4-0bf7*/
 NvV32 SizeC;                   /* height_width U16_U16 in pixels   0bf8-0bfb*/
 NvV32 PointC;                  /* y_x S16_S16 in pixels            0bfc-0bff*/
 NvV32 MonochromeColor1C[128];  /* 32 monochrome pixels per write   0c00-0dff*/
 NvV32 Reserved05[0x07A];
 NvV32 ClipPoint0D;             /* top_left S16_S16 in pixels       0fe8-0feb*/
 NvV32 ClipPoint1D;             /* bottom_right S16_S16 in pixels   0fec-0fef*/
 NvV32 Color1D;                 /* color of 1 pixels                0ff0-0ff3*/
 NvV32 SizeInD;                 /* height_width U16_U16 in pixels   0ff4-0ff7*/
 NvV32 SizeOutD;                /* height_width U16_U16 in pixels   0ff8-0ffb*/
 NvV32 PointD;                  /* y_x S16_S16 in pixels            0ffc-0fff*/
 NvV32 MonochromeColor1D[128];  /* 32 monochrome pixels per write   1000-11ff*/
 NvV32 Reserved06[0x079];
 NvV32 ClipPoint0E;             /* top_left S16_S16 in pixels       13e4-13e7*/
 NvV32 ClipPoint1E;             /* bottom_right S16_S16 in pixels   13e8-13eb*/
 NvV32 Color0E;                 /* color of 0 pixels                13ec-13ef*/
 NvV32 Color1E;                 /* color of 1 pixels                13f0-13f3*/
 NvV32 SizeInE;                 /* height_width U16_U16 in pixels   13f4-13f7*/
 NvV32 SizeOutE;                /* height_width U16_U16 in pixels   13f8-13fb*/
 NvV32 PointE;                  /* y_x S16_S16 in pixels            13fc-13ff*/
 NvV32 MonochromeColor01E[128]; /* 32 monochrome pixels per write   1400-15ff*/
 NvV32 Reserved07[0x280];
} Nv04bTypedef, Nv03GdiRectangleText;
#define NV04B_TYPEDEF                                      Nv03GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04B_SET_OBJECT                                           (0x00000000)
#define NV04B_NO_OPERATION                                         (0x00000100)
#define NV04B_NOTIFY                                               (0x00000104)
#define NV04B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV04B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04B_SET_CONTEXT_PATTERN                                  (0x00000184)
#define NV04B_SET_CONTEXT_ROP                                      (0x00000188)
#define NV04B_SET_CONTEXT_BETA1                                    (0x0000018C)
#define NV04B_SET_CONTEXT_SURFACE                                  (0x00000190)
#define NV04B_SET_OPERATION                                        (0x000002FC)
#define NV04B_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04B_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04B_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04B_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV04B_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04B_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04B_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04B_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04B_COLOR1_A                                             (0x000003FC)
#define NV04B_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04B_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04B_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04B_CLIP_POINT0_B                                        (0x000007F4)
#define NV04B_CLIP_POINT0_B_LEFT                                   15:0
#define NV04B_CLIP_POINT0_B_TOP                                    31:16
#define NV04B_CLIP_POINT1_B                                        (0x000007F8)
#define NV04B_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04B_COLOR1_B                                             (0x000007FC)
#define NV04B_CLIPPED_RECTANGLE(a)                                 (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0(a)                          (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0_LEFT                        15:0
#define NV04B_CLIPPED_RECTANGLE_POINT0_TOP                         31:16
#define NV04B_CLIPPED_RECTANGLE_POINT1(a)                          (0x00000804\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT1_RIGHT                       15:0
#define NV04B_CLIPPED_RECTANGLE_POINT1_BOTTOM                      31:16
#define NV04B_CLIP_POINT0_C                                        (0x00000BEC)
#define NV04B_CLIP_POINT0_C_LEFT                                   15:0
#define NV04B_CLIP_POINT0_C_TOP                                    31:16
#define NV04B_CLIP_POINT1_C                                        (0x00000BF0)
#define NV04B_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04B_COLOR1_C                                             (0x00000BF4)
#define NV04B_SIZE_C                                               (0x00000BF8)
#define NV04B_SIZE_C_WIDTH                                         15:0
#define NV04B_SIZE_C_HEIGHT                                        31:16
#define NV04B_POINT_C                                              (0x00000BFC)
#define NV04B_POINT_C_X                                            15:0
#define NV04B_POINT_C_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_C(a)                               (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_D                                        (0x00000FE8)
#define NV04B_CLIP_POINT0_D_LEFT                                   15:0
#define NV04B_CLIP_POINT0_D_TOP                                    31:16
#define NV04B_CLIP_POINT1_D                                        (0x00000FEC)
#define NV04B_CLIP_POINT1_D_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_D_BOTTOM                                 31:16
#define NV04B_COLOR1_D                                             (0x00000FF0)
#define NV04B_SIZE_IN_D                                            (0x00000FF4)
#define NV04B_SIZE_IN_D_WIDTH                                      15:0
#define NV04B_SIZE_IN_D_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_D                                           (0x00000FF8)
#define NV04B_SIZE_OUT_D_WIDTH                                     15:0
#define NV04B_SIZE_OUT_D_HEIGHT                                    31:16
#define NV04B_POINT_D                                              (0x00000FFC)
#define NV04B_POINT_D_X                                            15:0
#define NV04B_POINT_D_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_D(a)                               (0x00001000\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_E                                        (0x000013E4)
#define NV04B_CLIP_POINT0_E_LEFT                                   15:0
#define NV04B_CLIP_POINT0_E_TOP                                    31:16
#define NV04B_CLIP_POINT1_E                                        (0x000013E8)
#define NV04B_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04B_COLOR0_E                                             (0x000013EC)
#define NV04B_COLOR1_E                                             (0x000013F0)
#define NV04B_SIZE_IN_E                                            (0x000013F4)
#define NV04B_SIZE_IN_E_WIDTH                                      15:0
#define NV04B_SIZE_IN_E_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_E                                           (0x000013F8)
#define NV04B_SIZE_OUT_E_WIDTH                                     15:0
#define NV04B_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04B_POINT_E                                              (0x000013FC)
#define NV04B_POINT_E_X                                            15:0
#define NV04B_POINT_E_Y                                            31:16
#define NV04B_MONOCHROME_COLOR01_E(a)                              (0x00001400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV3_GDI_RECTANGLE_TEXT                                     (0x0000004B)
#define Nv3GdiRectangleText                                Nv03GdiRectangleText
#define nv3GdiRectangleText                                Nv03GdiRectangleText
#define nv03GdiRectangleText                               Nv03GdiRectangleText

typedef NvV32 Nv04cTypedef;


/* class NV03_EXTERNAL_VIDEO_DECODER */
#define  NV03_EXTERNAL_VIDEO_DECODER                               (0x0000004D)
/* NvNotification[] elements */
#define NV04D_NOTIFIERS_NOTIFY                                     (0)
#define NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(b)                   (1+(b))
#define NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(b)                   (3+(b))
#define NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(b)                 (5+(b))
#define NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (7+(b))
/* NvNotification[] fields and values */
#define NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED                (0x0000)
#define NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET               (0x0001)
#define NV04D_NOTIFICATION_INFO16_FIELD_DONE                       (0x0002)
#define NV04D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04D_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04D_NOTIFY_*                   0104-0107*/
 NvV32 StopTransferVbi;         /* NV04D_STOP_TRANSFER_VBI_VALUE    0108-010b*/
 NvV32 StopTransferImage;       /* NV04D_STOP_TRANSFER_IMAGE_VALUE  010c-010f*/
 NvV32 Reserved00[0x01c];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaVbi[2];     /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x059];
 NvU32 SetImageConfig;          /* data width, task bit, null data  02f8-02fb*/
 NvU32 SetImageStartLine;       /* lines                            02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvV32 size;                   /* height_firstLine U16_U16            0-   3*/
  NvU32 offset;                 /* byte offset of top-left pixel       4-   7*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        8-   b*/
 } SetVbi[2];                   /* end of methods in array              -0317*/
 NvV32 GetVbiOffsetNotify[2];   /* NV04D_GET_VBI_OFFSET_NOTIFY_*    0318-031f*/
 struct {                       /* start of methods in array        0320-    */
  NvV32 sizeIn;                 /* height_width U16_U16 in pixels      0-   3*/
  NvV32 sizeOut;                /* height_width U16_U16 in pixels      4-   7*/
  NvU32 offset;                 /* byte offset of top-left pixel       8-   b*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        c-   f*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 GetImageOffsetNotify[2]; /* NV04D_GET_IMAGE_OFFSET_NOTIFY_*  0340-0347*/
 NvV32 Reserved02[0x72e];
} Nv04dTypedef, Nv03ExternalVideoDecoder;
#define NV04D_TYPEDEF                                  Nv03ExternalVideoDecoder
/* dma method offsets, fields, and values */
#define NV04D_SET_OBJECT                                           (0x00000000)
#define NV04D_NO_OPERATION                                         (0x00000100)
#define NV04D_NOTIFY                                               (0x00000104)
#define NV04D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04D_STOP_TRANSFER_VBI                                    (0x00000108)
#define NV04D_STOP_TRANSFER_VBI_VALUE                              (0x00000000)
#define NV04D_STOP_TRANSFER_IMAGE                                  (0x0000010C)
#define NV04D_STOP_TRANSFER_IMAGE_VALUE                            (0x00000000)
#define NV04D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04D_SET_CONTEXT_DMA_VBI(b)                               (0x00000184\
                                                                   +(b)*0x0004)
#define NV04D_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04D_SET_IMAGE_CONFIG                                     (0x000002f8)
#define NV04D_SET_IMAGE_CONFIG_DATA_WIDTH                          7:0
#define NV04D_SET_IMAGE_CONFIG_TASK                                8:8
#define NV04D_SET_IMAGE_CONFIG_TASK_A                              (0x00000000)
#define NV04D_SET_IMAGE_CONFIG_TASK_B                              (0x00000001)
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA                           13:12
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED                  (0x00000000)
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED              (0x00000001)
#define NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED              (0x00000002)
#define NV04D_SET_IMAGE_CONFIG_NULL_VALUE                          31:16
#define NV04D_SET_IMAGE_START_LINE                                 (0x000002FC)
#define NV04D_SET_VBI(b)                                           (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE(b)                                      (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE_FIRST_LINE                              15:0
#define NV04D_SET_VBI_SIZE_HEIGHT                                  31:16
#define NV04D_SET_VBI_OFFSET(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT(b)                                    (0x00000308\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT_PITCH                                 15:0
#define NV04D_SET_VBI_FORMAT_FIELD                                 23:16
#define NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD                      (0x00000001)
#define NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD                       (0x00000002)
#define NV04D_SET_VBI_FORMAT_NOTIFY                                31:24
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_GET_VBI_OFFSET_NOTIFY(b)                             (0x00000318\
                                                                   +(b)*0x0004)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_SET_IMAGE(b)                                         (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN(b)                                 (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN_WIDTH                              15:0
#define NV04D_SET_IMAGE_SIZE_IN_HEIGHT                             31:16
#define NV04D_SET_IMAGE_SIZE_OUT(b)                                (0x00000324\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_OUT_WIDTH                             15:0
#define NV04D_SET_IMAGE_SIZE_OUT_HEIGHT                            31:16
#define NV04D_SET_IMAGE_OFFSET(b)                                  (0x00000328\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT(b)                                  (0x0000032C\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV04D_SET_IMAGE_FORMAT_FIELD                               23:16
#define NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY                              31:24
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000340\
                                                                   +(b)*0x0004)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_VIDEO_DECOMPRESSOR                            (0x0000004E)
#define Nv3ExternalVideoDecoder                        Nv03ExternalVideoDecoder
#define nv3ExternalVideoDecoder                        Nv03ExternalVideoDecoder
#define nv03ExternalVideoDecoder                       Nv03ExternalVideoDecoder


/* class NV03_EXTERNAL_VIDEO_DECOMPRESSOR */
#define  NV03_EXTERNAL_VIDEO_DECOMPRESSOR                          (0x0000004E)
/* NvNotification[] elements */
#define NV04E_NOTIFIERS_NOTIFY                                     (0)
#define NV04E_NOTIFIERS_SET_DATA_NOTIFY(b)                         (1+(b))
#define NV04E_NOTIFIERS_SET_IMAGE_NOTIFY(b)                        (3+(b))
/* NvNotification[] fields and values */
#define NV04E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04E_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04E_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV04E_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaData[2];    /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x05b];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* in bytes                            0-   3*/
  NvU32 length;                 /* in bytes                            4-   7*/
  NvV32 notify;                 /* NV04E_SET_DATA_NOTIFY_*             8-   b*/
 } SetData[2];                  /* end of methods in array              -0317*/
 struct {                       /* start of methods in array        0318-    */
  NvV32 formatIn;               /* zero_field V16_V16                 00-  03*/
  NvV32 size;                   /* height_width U16_U16 in pixels     04-  07*/
  NvU32 offsetOut;              /* byte offset of top-left pixel      08-  0b*/
  NvV32 formatOut;              /* ignore_pitch V16_U16               0c-  0f*/
  NvV32 notify;                 /* NV04E_SET_IMAGE_NOTIFY_*           10-  13*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 Reserved02[0x730];
} Nv04eTypedef, Nv03ExternalVideoDecompressor;
#define NV04E_TYPEDEF                             Nv03ExternalVideoDecompressor
/* dma method offsets, fields, and values */
#define NV04E_SET_OBJECT                                           (0x00000000)
#define NV04E_NO_OPERATION                                         (0x00000100)
#define NV04E_NOTIFY                                               (0x00000104)
#define NV04E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04E_STOP_TRANSFER                                        (0x00000108)
#define NV04E_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04E_SET_CONTEXT_DMA_DATA(b)                              (0x00000184\
                                                                   +(b)*0x0004)
#define NV04E_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04E_SET_DATA(b)                                          (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_OFFSET(b)                                   (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_LENGTH(b)                                   (0x00000304\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY(b)                                   (0x00000308\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY_WRITE_ONLY                           (0x00000000)
#define NV04E_SET_DATA_NOTIFY_WRITE_THEN_AWAKEN                    (0x00000001)
#define NV04E_SET_IMAGE(b)                                         (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN(b)                               (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD                            15:0
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_PROGRESSIVE                (0x00000001)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_EVEN_FIELD                 (0x00000002)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_ODD_FIELD                  (0x00000003)
#define NV04E_SET_IMAGE_FORMAT_IN_ZERO                             31:16
#define NV04E_SET_IMAGE_SIZE(b)                                    (0x0000031C\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV04E_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV04E_SET_IMAGE_OFFSET_OUT(b)                              (0x00000320\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT(b)                              (0x00000324\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT_PITCH                           15:0
#define NV04E_SET_IMAGE_FORMAT_OUT_IGNORE                          31:16
#define NV04E_SET_IMAGE_NOTIFY(b)                                  (0x00000328\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_VIDEO_DECOMPRESSOR                            (0x0000004E)
#define Nv3ExternalVideoDecompressor              Nv03ExternalVideoDecompressor
#define nv3ExternalVideoDecompressor              Nv03ExternalVideoDecompressor
#define nv03ExternalVideoDecompressor             Nv03ExternalVideoDecompressor


/* class NV01_EXTERNAL_PARALLEL_BUS */
#define  NV01_EXTERNAL_PARALLEL_BUS                                (0x0000004F)
/* NvNotification[] elements */
#define NV04F_NOTIFIERS_NOTIFY                                     (0)
#define NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV04F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04F_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04F_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV04F_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 WriteSize;               /* address_data U16_U16             0300-0303*/
 NvU32 WriteAddress;            /* in bytes                         0304-0307*/
 NvV32 WriteData;               /* data                             0308-030b*/
 NvV32 ReadSize;                /* address_data U16_U16             030c-030f*/
 NvU32 ReadAddress;             /* in bytes                         0310-0313*/
 NvV32 ReadGetDataNotify;       /* NV04F_READ_GET_DATA_NOTIFY_*     0314-0317*/
 NvV32 SetInterruptNotify;      /* NV04F_SET_INTERRUPT_NOTIFY_*     0318-031b*/
 NvV32 Reserved02[0x739];
} Nv04fTypedef, Nv01ExternalParallelBus;
#define NV04F_TYPEDEF                                   Nv01ExternalParallelBus
/* dma method offsets, fields, and values */
#define NV04F_SET_OBJECT                                           (0x00000000)
#define NV04F_NO_OPERATION                                         (0x00000100)
#define NV04F_NOTIFY                                               (0x00000104)
#define NV04F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04F_STOP_TRANSFER                                        (0x00000108)
#define NV04F_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04F_WRITE                                                (0x00000300)
#define NV04F_WRITE_SIZE                                           (0x00000300)
#define NV04F_WRITE_SIZE_DATA                                      15:0
#define NV04F_WRITE_SIZE_ADDRESS                                   31:16
#define NV04F_WRITE_ADDRESS                                        (0x00000304)
#define NV04F_WRITE_DATA                                           (0x00000308)
#define NV04F_READ                                                 (0x0000030C)
#define NV04F_READ_SIZE                                            (0x0000030C)
#define NV04F_READ_SIZE_DATA                                       15:0
#define NV04F_READ_SIZE_ADDRESS                                    31:16
#define NV04F_READ_ADDRESS                                         (0x00000310)
#define NV04F_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV04F_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
/* obsolete stuff */
#define NV1_EXTERNAL_PARALLEL_BUS                                  (0x0000004F)
#define Nv1ExternalParallelBus                          Nv01ExternalParallelBus
#define nv1ExternalParallelBus                          Nv01ExternalParallelBus
#define nv01ExternalParallelBus                         Nv01ExternalParallelBus


/* class NV03_EXTERNAL_MONITOR_BUS */
#define  NV03_EXTERNAL_MONITOR_BUS                                 (0x00000050)
/* NvNotification[] elements */
#define NV050_NOTIFIERS_NOTIFY                                     (0)
#define NV050_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV050_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV050_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV050_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV050_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV050_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV050_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV050_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV050_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV050_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV050_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 WriteSize;               /* address_data U16_U16             0300-0303*/
 NvU32 WriteAddress;            /* in bytes                         0304-0307*/
 NvV32 WriteData;               /* data                             0308-030b*/
 NvV32 ReadSize;                /* address_data U16_U16             030c-030f*/
 NvU32 ReadAddress;             /* in bytes                         0310-0313*/
 NvV32 ReadGetDataNotify;       /* NV050_READ_GET_DATA_NOTIFY_*     0314-0317*/
 NvV32 SetInterruptNotify;      /* NV050_SET_INTERRUPT_NOTIFY_*     0318-031b*/
 NvV32 Reserved02[0x739];
} Nv050Typedef, Nv03ExternalMonitorBus;
#define NV050_TYPEDEF                                    Nv03ExternalMonitorBus
/* dma method offsets, fields, and values */
#define NV050_SET_OBJECT                                           (0x00000000)
#define NV050_NO_OPERATION                                         (0x00000100)
#define NV050_NOTIFY                                               (0x00000104)
#define NV050_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV050_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV050_STOP_TRANSFER                                        (0x00000108)
#define NV050_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV050_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV050_WRITE                                                (0x00000300)
#define NV050_WRITE_SIZE                                           (0x00000300)
#define NV050_WRITE_SIZE_DATA                                      15:0
#define NV050_WRITE_SIZE_ADDRESS                                   31:16
#define NV050_WRITE_ADDRESS                                        (0x00000304)
#define NV050_WRITE_DATA                                           (0x00000308)
#define NV050_READ                                                 (0x0000030C)
#define NV050_READ_SIZE                                            (0x0000030C)
#define NV050_READ_SIZE_DATA                                       15:0
#define NV050_READ_SIZE_ADDRESS                                    31:16
#define NV050_READ_ADDRESS                                         (0x00000310)
#define NV050_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV050_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_MONITOR_BUS                                   (0x00000050)
#define Nv3ExternalMonitorBus                            Nv03ExternalMonitorBus
#define nv3ExternalMonitorBus                            Nv03ExternalMonitorBus
#define nv03ExternalMonitorBus                           Nv03ExternalMonitorBus


/* class NV04_EXTERNAL_SERIAL_BUS */
#define  NV04_EXTERNAL_SERIAL_BUS                                  (0x00000051)
/* NvNotification[] elements */
#define NV051_NOTIFIERS_NOTIFY                                     (0)
#define NV051_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV051_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV051_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV051_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV051_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV051_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV051_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV051_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV051_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV051_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV051_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 WriteSize;               /* address_data U16_U16             0300-0303*/
 NvU32 WriteAddress;            /* in bytes                         0304-0307*/
 NvV32 WriteData;               /* data                             0308-030b*/
 NvV32 ReadSize;                /* address_data U16_U16             030c-030f*/
 NvU32 ReadAddress;             /* in bytes                         0310-0313*/
 NvV32 ReadGetDataNotify;       /* NV051_READ_GET_DATA_NOTIFY_*     0314-0317*/
 NvV32 SetInterruptNotify;      /* NV051_SET_INTERRUPT_NOTIFY_*     0318-031b*/
 NvV32 Reserved02[0x739];
} Nv051Typedef, Nv04ExternalSerialBus;
#define NV051_TYPEDEF                                     Nv04ExternalSerialBus
/* dma method offsets, fields, and values */
#define NV051_SET_OBJECT                                           (0x00000000)
#define NV051_NO_OPERATION                                         (0x00000100)
#define NV051_NOTIFY                                               (0x00000104)
#define NV051_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV051_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV051_STOP_TRANSFER                                        (0x00000108)
#define NV051_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV051_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV051_WRITE                                                (0x00000300)
#define NV051_WRITE_SIZE                                           (0x00000300)
#define NV051_WRITE_SIZE_DATA                                      15:0
#define NV051_WRITE_SIZE_ADDRESS                                   31:16
#define NV051_WRITE_ADDRESS                                        (0x00000304)
#define NV051_WRITE_DATA                                           (0x00000308)
#define NV051_READ                                                 (0x0000030C)
#define NV051_READ_SIZE                                            (0x0000030C)
#define NV051_READ_SIZE_DATA                                       15:0
#define NV051_READ_SIZE_ADDRESS                                    31:16
#define NV051_READ_ADDRESS                                         (0x00000310)
#define NV051_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV051_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
/* obsolete stuff */
#define NV03_EXTERNAL_SERIAL_BUS                                   (0x00000051)
#define NV3_EXTERNAL_SERIAL_BUS                                    (0x00000051)
#define Nv03ExternalSerialBus                             Nv04ExternalSerialBus
#define nv03ExternalSerialBus                             Nv04ExternalSerialBus
#define Nv3ExternalSerialBus                              Nv04ExternalSerialBus
#define nv3ExternalSerialBus                              Nv04ExternalSerialBus
#define nv04ExternalSerialBus                             Nv04ExternalSerialBus


/* class NV04_CONTEXT_SURFACE_SWIZZLED */
#define  NV04_CONTEXT_SURFACE_SWIZZLED                             (0x00000052)
/* NvNotification[] elements */
#define NV052_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV052_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV052_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV052_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV052_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV052_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV052_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV052_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetFormat;               /* height_width_color V8_V8_V16     0300-0303*/
 NvU32 SetOffset;               /* byte offset of top-left pixel    0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv052Typedef, Nv04ContextSurfaceSwizzled;
#define NV052_TYPEDEF                                Nv04ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV052_SET_OBJECT                                           (0x00000000)
#define NV052_NO_OPERATION                                         (0x00000100)
#define NV052_NOTIFY                                               (0x00000104)
#define NV052_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV052_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV052_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV052_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV052_SET_FORMAT                                           (0x00000300)
#define NV052_SET_FORMAT_COLOR                                     15:0
#define NV052_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV052_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV052_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV052_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV052_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV052_SET_FORMAT_WIDTH                                     23:16
#define NV052_SET_FORMAT_WIDTH_1                                   (0x00000000)
#define NV052_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV052_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV052_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV052_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV052_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV052_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV052_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV052_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV052_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV052_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV052_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV052_SET_FORMAT_HEIGHT                                    31:24
#define NV052_SET_FORMAT_HEIGHT_1                                  (0x00000000)
#define NV052_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV052_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV052_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV052_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV052_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV052_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV052_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV052_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV052_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV052_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV052_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV052_SET_OFFSET                                           (0x00000304)
/* obsolete stuff */
#define NV4_CONTEXT_SURFACE_SWIZZLED                               (0x00000052)
#define Nv4ContextSurfaceSwizzled                    Nv04ContextSurfaceSwizzled
#define nv4ContextSurfaceSwizzled                    Nv04ContextSurfaceSwizzled
#define nv04ContextSurfaceSwizzled                   Nv04ContextSurfaceSwizzled


/* class NV04_CONTEXT_SURFACES_3D */
#define  NV04_CONTEXT_SURFACES_3D                                  (0x00000053)
/* NvNotification[] elements */
#define NV053_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV053_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV053_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV053_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV053_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV053_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV053_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV053_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaColor;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaZeta;       /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05b];
 NvV32 SetClipHorizontal;       /* width_x U16_U16                  02F8-02FB*/
 NvV32 SetClipVertical;         /* height_y U16_U16                 02FC-02FF*/
 NvV32 SetFormat;               /* height_width_type_color all V8   0300-0303*/
 NvV32 SetClipSize;             /* height_width U16_U16             0304-0307*/
 NvU32 SetPitch;                /* zeta_color U16_U16               0308-030b*/
 NvU32 SetOffsetColor;          /* byte offset of top-left pixel    030c-030f*/
 NvU32 SetOffsetZeta;           /* byte offset of top-left pixel    0310-0313*/
 NvV32 Reserved02[0x73b];
} Nv053Typedef, Nv04ContextSurfaces3d;
#define NV053_TYPEDEF                                     Nv04ContextSurfaces3d
/* dma method offsets, fields, and values */
#define NV053_SET_OBJECT                                           (0x00000000)
#define NV053_NO_OPERATION                                         (0x00000100)
#define NV053_NOTIFY                                               (0x00000104)
#define NV053_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV053_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV053_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV053_SET_CONTEXT_DMA_COLOR                                (0x00000184)
#define NV053_SET_CONTEXT_DMA_ZETA                                 (0x00000188)
#define NV053_SET_FORMAT                                           (0x00000300)
#define NV053_SET_FORMAT_COLOR                                     7:0
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000001)
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000002)
#define NV053_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000003)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000004)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000005)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000006)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000007)
#define NV053_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x00000008)
#define NV053_SET_FORMAT_TYPE                                      15:8
#define NV053_SET_FORMAT_TYPE_PITCH                                (0x00000001)
#define NV053_SET_FORMAT_TYPE_SWIZZLE                              (0x00000002)
#define NV053_SET_FORMAT_WIDTH                                     23:16
#define NV053_SET_FORMAT_HEIGHT                                    31:24
#define NV053_SET_CLIP_HORIZONTAL                                  (0x000002F8)
#define NV053_SET_CLIP_HORIZONTAL_X                                15:0
#define NV053_SET_CLIP_HORIZONTAL_WIDTH                            31:16
#define NV053_SET_CLIP_VERTICAL                                    (0x000002FC)
#define NV053_SET_CLIP_VERTICAL_Y                                  15:0
#define NV053_SET_CLIP_VERTICAL_HEIGHT                             31:16
#define NV053_SET_CLIP_SIZE                                        (0x00000304)
#define NV053_SET_CLIP_SIZE_WIDTH                                  15:0
#define NV053_SET_CLIP_SIZE_HEIGHT                                 31:16
#define NV053_SET_PITCH                                            (0x00000308)
#define NV053_SET_PITCH_COLOR                                      15:0
#define NV053_SET_PITCH_ZETA                                       31:16
#define NV053_SET_OFFSET_COLOR                                     (0x0000030C)
#define NV053_SET_OFFSET_ZETA                                      (0x00000310)
/* obsolete stuff */
#define NV04_CONTEXT_SURFACES_ARGB_ZS                              (0x00000053)
#define NV4_CONTEXT_SURFACES_ARGB_ZS                               (0x00000053)
#define Nv04ContextSurfacesArgbZs                         Nv04ContextSurfaces3d
#define nv04ContextSurfacesArgbZs                         Nv04ContextSurfaces3d
#define Nv4ContextSurfacesArgbZs                          Nv04ContextSurfaces3d
#define nv4ContextSurfacesArgbZs                          Nv04ContextSurfaces3d
#define nv04ContextSurfaces3d                             Nv04ContextSurfaces3d


/* class NV04_DX5_TEXTURED_TRIANGLE */
#define  NV04_DX5_TEXTURED_TRIANGLE                                (0x00000054)
/* NvNotification[] elements */
#define NV054_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV054_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV054_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV054_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV054_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV054_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV054_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV054_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ColorKey;                /* texture color key value          0300-0303*/
 NvU32 Offset;                  /* texture offset in bytes          0304-0307*/
 NvV32 Format;                  /* see text                         0308-030b*/
 NvV32 Filter;                  /* see text                         030c-030f*/
 NvV32 Blend;                   /* see text                         0310-0313*/
 NvV32 Control;                 /* see text                         0314-0317*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0318-031b*/
 NvV32 Reserved02[0x039];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu;                     /* texture u coordinate               18-  1b*/
  NvF32 tv;                     /* texture v coordinate               1c-  1f*/
 } Tlvertex[16];                /* end of methods in array              -05ff*/
 NvV32 DrawPrimitive[64];       /* see text                         0600-06ff*/
 NvV32 Reserved03[0x640];
} Nv054Typedef, Nv04Dx5TexturedTriangle;
#define NV054_TYPEDEF                                   Nv04Dx5TexturedTriangle
/* dma method offsets, fields, and values */
#define NV054_SET_OBJECT                                           (0x00000000)
#define NV054_NO_OPERATION                                         (0x00000100)
#define NV054_NOTIFY                                               (0x00000104)
#define NV054_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV054_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV054_STALL_PIPE                                           (0x00000108)
#define NV054_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV054_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV054_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV054_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV054_COLOR_KEY                                            (0x00000300)
#define NV054_OFFSET                                               (0x00000304)
#define NV054_FORMAT                                               (0x00000308)
#define NV054_FORMAT_CONTEXT_DMA                                   1:0
#define NV054_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV054_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV054_FORMAT_COLORKEYENABLE                                3:2
#define NV054_FORMAT_COLORKEYENABLE_FALSE                          (0x00000000)
#define NV054_FORMAT_COLORKEYENABLE_TRUE                           (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH                                    5:4
#define NV054_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV054_FORMAT_ORIGIN_FOH                                    7:6
#define NV054_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV054_FORMAT_COLOR                                         11:8
#define NV054_FORMAT_COLOR_LE_Y8                                   (0x00000001)
#define NV054_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV054_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV054_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV054_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV054_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV054_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV054_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV054_FORMAT_BASE_SIZE_U                                   19:16
#define NV054_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV054_FORMAT_BASE_SIZE_V                                   23:20
#define NV054_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV054_FORMAT_TEXTUREADDRESSU                               26:24
#define NV054_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPU                                         27:27
#define NV054_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV                               30:28
#define NV054_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPV                                         31:31
#define NV054_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV054_FILTER                                               (0x0000030C)
#define NV054_FILTER_KERNEL_SIZE_X                                 7:0
#define NV054_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV054_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV054_FILTER_MIPMAPLODBIAS                                 23:16
#define NV054_FILTER_TEXTUREMIN                                    26:24
#define NV054_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV054_FILTER_TEXTUREMAG                                    30:28
#define NV054_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV054_BLEND                                                (0x00000310)
#define NV054_BLEND_TEXTUREMAPBLEND                                3:0
#define NV054_BLEND_TEXTUREMAPBLEND_DECAL                          (0x00000001)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATE                       (0x00000002)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA                     (0x00000003)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA                  (0x00000004)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALMASK                      (0x00000005)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK                   (0x00000006)
#define NV054_BLEND_TEXTUREMAPBLEND_COPY                           (0x00000007)
#define NV054_BLEND_TEXTUREMAPBLEND_ADD                            (0x00000008)
#define NV054_BLEND_MASK_BIT                                       5:4
#define NV054_BLEND_MASK_BIT_LSB                                   (0x00000001)
#define NV054_BLEND_MASK_BIT_MSB                                   (0x00000002)
#define NV054_BLEND_SHADEMODE                                      7:6
#define NV054_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV054_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV054_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV054_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV054_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV054_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV054_BLEND_SPECULARENABLE                                 15:12
#define NV054_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV054_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV054_BLEND_FOGENABLE                                      19:16
#define NV054_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV054_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV054_BLEND_ALPHABLENDENABLE                               23:20
#define NV054_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV054_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV054_BLEND_SRCBLEND                                       27:24
#define NV054_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV054_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV054_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV054_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV054_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV054_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV054_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV054_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV054_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV054_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV054_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV054_BLEND_DESTBLEND                                      31:28
#define NV054_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV054_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV054_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV054_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV054_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV054_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV054_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV054_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV054_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV054_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV054_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV054_CONTROL                                              (0x00000314)
#define NV054_CONTROL_ALPHAREF                                     7:0
#define NV054_CONTROL_ALPHAFUNC                                    11:8
#define NV054_CONTROL_ALPHAFUNC_NEVER                              (0x00000001)
#define NV054_CONTROL_ALPHAFUNC_LESS                               (0x00000002)
#define NV054_CONTROL_ALPHAFUNC_EQUAL                              (0x00000003)
#define NV054_CONTROL_ALPHAFUNC_LESSEQUAL                          (0x00000004)
#define NV054_CONTROL_ALPHAFUNC_GREATER                            (0x00000005)
#define NV054_CONTROL_ALPHAFUNC_NOTEQUAL                           (0x00000006)
#define NV054_CONTROL_ALPHAFUNC_GREATEREQUAL                       (0x00000007)
#define NV054_CONTROL_ALPHAFUNC_ALWAYS                             (0x00000008)
#define NV054_CONTROL_ALPHATESTENABLE                              12:12
#define NV054_CONTROL_ALPHATESTENABLE_FALSE                        (0x00000000)
#define NV054_CONTROL_ALPHATESTENABLE_TRUE                         (0x00000001)
#define NV054_CONTROL_ORIGIN                                       13:13
#define NV054_CONTROL_ORIGIN_CENTER                                (0x00000000)
#define NV054_CONTROL_ORIGIN_CORNER                                (0x00000001)
#define NV054_CONTROL_ZENABLE                                      15:14
#define NV054_CONTROL_ZENABLE_FALSE                                (0x00000000)
#define NV054_CONTROL_ZENABLE_TRUE                                 (0x00000001)
#define NV054_CONTROL_ZFUNC                                        19:16
#define NV054_CONTROL_ZFUNC_NEVER                                  (0x00000001)
#define NV054_CONTROL_ZFUNC_LESS                                   (0x00000002)
#define NV054_CONTROL_ZFUNC_EQUAL                                  (0x00000003)
#define NV054_CONTROL_ZFUNC_LESSEQUAL                              (0x00000004)
#define NV054_CONTROL_ZFUNC_GREATER                                (0x00000005)
#define NV054_CONTROL_ZFUNC_NOTEQUAL                               (0x00000006)
#define NV054_CONTROL_ZFUNC_GREATEREQUAL                           (0x00000007)
#define NV054_CONTROL_ZFUNC_ALWAYS                                 (0x00000008)
#define NV054_CONTROL_CULLMODE                                     21:20
#define NV054_CONTROL_CULLMODE_NONE                                (0x00000001)
#define NV054_CONTROL_CULLMODE_CW                                  (0x00000002)
#define NV054_CONTROL_CULLMODE_CCW                                 (0x00000003)
#define NV054_CONTROL_DITHERENABLE                                 22:22
#define NV054_CONTROL_DITHERENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_DITHERENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE                         23:23
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE                   (0x00000000)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE                    (0x00000001)
#define NV054_CONTROL_ZWRITEENABLE                                 29:24
#define NV054_CONTROL_ZWRITEENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_ZWRITEENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_FORMAT                                     31:30
#define NV054_CONTROL_Z_FORMAT_FIXED                               (0x00000001)
#define NV054_CONTROL_Z_FORMAT_FLOAT                               (0x00000002)
#define NV054_FOG_COLOR                                            (0x00000318)
#define NV054_TLVERTEX(i)                                          (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SX(i)                                       (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SY(i)                                       (0x00000404\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SZ(i)                                       (0x00000408\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_RHW(i)                                      (0x0000040C\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR(i)                                    (0x00000410\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR_BLUE                                  7:0
#define NV054_TLVERTEX_COLOR_GREEN                                 15:8
#define NV054_TLVERTEX_COLOR_RED                                   23:16
#define NV054_TLVERTEX_COLOR_ALPHA                                 31:24
#define NV054_TLVERTEX_SPECULAR(i)                                 (0x00000414\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SPECULAR_BLUE                               7:0
#define NV054_TLVERTEX_SPECULAR_GREEN                              15:8
#define NV054_TLVERTEX_SPECULAR_RED                                23:16
#define NV054_TLVERTEX_SPECULAR_FOG                                31:24
#define NV054_TLVERTEX_TU(i)                                       (0x00000418\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_TV(i)                                       (0x0000041C\
                                                                   +(i)*0x0020)
#define NV054_DRAW_PRIMITIVE(a)                                    (0x00000600\
                                                                   +(a)*0x0004)
#define NV054_DRAW_PRIMITIVE_I0                                    3:0
#define NV054_DRAW_PRIMITIVE_I1                                    7:4
#define NV054_DRAW_PRIMITIVE_I2                                    11:8
#define NV054_DRAW_PRIMITIVE_I3                                    15:12
#define NV054_DRAW_PRIMITIVE_I4                                    19:16
#define NV054_DRAW_PRIMITIVE_I5                                    31:20
/* obsolete stuff */
#define NV4_DX5_TEXTURED_TRIANGLE                                  (0x00000054)
#define Nv4Dx5TexturedTriangle                          Nv04Dx5TexturedTriangle
#define nv4Dx5TexturedTriangle                          Nv04Dx5TexturedTriangle
#define nv04Dx5TexturedTriangle                         Nv04Dx5TexturedTriangle


/* class NV04_DX6_MULTI_TEXTURE_TRIANGLE */
#define  NV04_DX6_MULTI_TEXTURE_TRIANGLE                           (0x00000055)
/* NvNotification[] elements */
#define NV055_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV055_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV055_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV055_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV055_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV055_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV055_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV055_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05e];
 NvU32 Offset[2];               /* offset in bytes                  0308-030f*/
 NvV32 Format[2];               /* see text                         0310-0317*/
 NvV32 Filter[2];               /* see text                         0318-031f*/
 NvV32 Combine0Alpha;           /* see text                         0320-0323*/
 NvV32 Combine0Color;           /* see text                         0324-0327*/
 NvV32 Reserved02[0x001];
 NvV32 Combine1Alpha;           /* see text                         032c-032f*/
 NvV32 Combine1Color;           /* see text                         0330-0333*/
 NvV32 CombineFactor;           /* A8R8G8B8                         0334-0337*/
 NvV32 Blend;                   /* see text                         0338-033b*/
 NvV32 Control0;                /* see text                         033c-033f*/
 NvV32 Control1;                /* see text                         0340-0343*/
 NvV32 Control2;                /* see text                         0344-0347*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0348-034b*/
 NvV32 Reserved03[0x02D];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu0;                    /* texture 0 u coordinate             18-  1b*/
  NvF32 tv0;                    /* texture 0 v coordinate             1c-  1f*/
  NvF32 tu1;                    /* texture 1 u coordinate             20-  23*/
  NvF32 tv1;                    /* texture 1 v coordinate             24-  27*/
 } Tlmtvertex[8];               /* end of methods in array              -053f*/
 NvV32 DrawPrimitive[48];       /* see text                         0540-05ff*/
 NvV32 Reserved04[0x680];
} Nv055Typedef, Nv04Dx6MultiTextureTriangle;
#define NV055_TYPEDEF                               Nv04Dx6MultiTextureTriangle
/* dma method offsets, fields, and values */
#define NV055_SET_OBJECT                                           (0x00000000)
#define NV055_NO_OPERATION                                         (0x00000100)
#define NV055_NOTIFY                                               (0x00000104)
#define NV055_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV055_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV055_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV055_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV055_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV055_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV055_OFFSET(b)                                            (0x00000308\
                                                                   +(b)*0x0004)
#define NV055_FORMAT(b)                                            (0x00000310\
                                                                   +(b)*0x0004)
#define NV055_FORMAT_CONTEXT_DMA                                   3:0
#define NV055_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV055_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV055_FORMAT_ORIGIN_ZOH                                    5:4
#define NV055_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV055_FORMAT_ORIGIN_FOH                                    7:6
#define NV055_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV055_FORMAT_COLOR                                         11:8
#define NV055_FORMAT_COLOR_LE_AY8                                  (0x00000001)
#define NV055_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV055_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV055_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV055_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV055_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV055_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV055_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV055_FORMAT_BASE_SIZE_U                                   19:16
#define NV055_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV055_FORMAT_BASE_SIZE_V                                   23:20
#define NV055_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV055_FORMAT_TEXTUREADDRESSU                               26:24
#define NV055_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPU                                         27:27
#define NV055_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV                               30:28
#define NV055_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPV                                         31:31
#define NV055_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV055_FILTER(b)                                            (0x00000318\
                                                                   +(b)*0x0004)
#define NV055_FILTER_KERNEL_SIZE_X                                 7:0
#define NV055_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV055_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV055_FILTER_MIPMAPLODBIAS                                 23:16
#define NV055_FILTER_TEXTUREMIN                                    26:24
#define NV055_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV055_FILTER_TEXTUREMAG                                    30:28
#define NV055_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV055_COMBINE_0_ALPHA                                      (0x00000320)
#define NV055_COMBINE_0_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_0_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_0_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_0_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_0_COLOR                                      (0x00000324)
#define NV055_COMBINE_0_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_0_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_0_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_0_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_0_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_0_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_0_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_0_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_OPERATION                            31:29
#define NV055_COMBINE_0_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_ALPHA                                      (0x0000032C)
#define NV055_COMBINE_1_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_1_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_1_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_1_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_1_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_COLOR                                      (0x00000330)
#define NV055_COMBINE_1_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_1_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_1_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_1_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_1_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_1_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_1_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_1_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_1_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_OPERATION                            31:29
#define NV055_COMBINE_1_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
/* The following NV055_COMBINE_*** defines can be used without regard to the combiner number */
#define NV055_COMBINE_ALPHA_INVERSE_0                              0:0
#define NV055_COMBINE_ALPHA_INVERSE_0_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_0_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_0                                1:1
#define NV055_COMBINE_ALPHA_ARGUMENT_0                             7:2
#define NV055_COMBINE_ALPHA_ARGUMENT_0_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_INVERSE_1                              8:8
#define NV055_COMBINE_ALPHA_INVERSE_1_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_1_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_1                                9:9
#define NV055_COMBINE_ALPHA_ARGUMENT_1                             15:10
#define NV055_COMBINE_ALPHA_ARGUMENT_1_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_INVERSE_2                              16:16
#define NV055_COMBINE_ALPHA_INVERSE_2_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_2_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_2                                17:17
#define NV055_COMBINE_ALPHA_ARGUMENT_2                             23:18
#define NV055_COMBINE_ALPHA_ARGUMENT_2_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_INVERSE_3                              24:24
#define NV055_COMBINE_ALPHA_INVERSE_3_NORMAL                       (0x00000000)
#define NV055_COMBINE_ALPHA_INVERSE_3_INVERSE                      (0x00000001)
#define NV055_COMBINE_ALPHA_ALPHA_3                                25:25
#define NV055_COMBINE_ALPHA_ARGUMENT_3                             28:26
#define NV055_COMBINE_ALPHA_ARGUMENT_3_ZERO                        (0x00000001)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_INPUT                       (0x00000004)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_ALPHA_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_ALPHA_OPERATION                              31:29
#define NV055_COMBINE_ALPHA_OPERATION_ADD                          (0x00000001)
#define NV055_COMBINE_ALPHA_OPERATION_ADD2                         (0x00000002)
#define NV055_COMBINE_ALPHA_OPERATION_ADD4                         (0x00000003)
#define NV055_COMBINE_ALPHA_OPERATION_ADDSIGNED                    (0x00000004)
#define NV055_COMBINE_ALPHA_OPERATION_MUX                          (0x00000005)
#define NV055_COMBINE_ALPHA_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV055_COMBINE_ALPHA_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_0                              0:0
#define NV055_COMBINE_COLOR_INVERSE_0_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_0_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_0                                1:1
#define NV055_COMBINE_COLOR_ALPHA_0_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_0_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_0                             7:2
#define NV055_COMBINE_COLOR_ARGUMENT_0_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_0_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_1                              8:8
#define NV055_COMBINE_COLOR_INVERSE_1_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_1_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_1                                9:9
#define NV055_COMBINE_COLOR_ALPHA_1_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_1_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_1                             15:10
#define NV055_COMBINE_COLOR_ARGUMENT_1_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_1_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_2                              16:16
#define NV055_COMBINE_COLOR_INVERSE_2_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_2_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_2                                17:17
#define NV055_COMBINE_COLOR_ALPHA_2_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_2_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_2                             23:18
#define NV055_COMBINE_COLOR_ARGUMENT_2_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_2_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_INVERSE_3                              24:24
#define NV055_COMBINE_COLOR_INVERSE_3_NORMAL                       (0x00000000)
#define NV055_COMBINE_COLOR_INVERSE_3_INVERSE                      (0x00000001)
#define NV055_COMBINE_COLOR_ALPHA_3                                25:25
#define NV055_COMBINE_COLOR_ALPHA_3_COLOR                          (0x00000000)
#define NV055_COMBINE_COLOR_ALPHA_3_ALPHA                          (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_3                             28:26
#define NV055_COMBINE_COLOR_ARGUMENT_3_ZERO                        (0x00000001)
#define NV055_COMBINE_COLOR_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV055_COMBINE_COLOR_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV055_COMBINE_COLOR_ARGUMENT_3_INPUT                       (0x00000004)
#define NV055_COMBINE_COLOR_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV055_COMBINE_COLOR_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV055_COMBINE_COLOR_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV055_COMBINE_COLOR_OPERATION                              31:29
#define NV055_COMBINE_COLOR_OPERATION_ADD                          (0x00000001)
#define NV055_COMBINE_COLOR_OPERATION_ADD2                         (0x00000002)
#define NV055_COMBINE_COLOR_OPERATION_ADD4                         (0x00000003)
#define NV055_COMBINE_COLOR_OPERATION_ADDSIGNED                    (0x00000004)
#define NV055_COMBINE_COLOR_OPERATION_MUX                          (0x00000005)
#define NV055_COMBINE_COLOR_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV055_COMBINE_COLOR_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV055_COMBINE_FACTOR                                       (0x00000334)
#define NV055_COMBINE_FACTOR_BLUE                                  7:0
#define NV055_COMBINE_FACTOR_GREEN                                 15:8
#define NV055_COMBINE_FACTOR_RED                                   23:16
#define NV055_COMBINE_FACTOR_ALPHA                                 31:24
#define NV055_BLEND                                                (0x00000338)
#define NV055_BLEND_MASK_BIT                                       5:0
#define NV055_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV055_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV055_BLEND_SHADEMODE                                      7:6
#define NV055_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV055_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV055_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV055_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV055_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV055_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV055_BLEND_SPECULARENABLE                                 15:12
#define NV055_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV055_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV055_BLEND_FOGENABLE                                      19:16
#define NV055_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV055_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV055_BLEND_ALPHABLENDENABLE                               23:20
#define NV055_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV055_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV055_BLEND_SRCBLEND                                       27:24
#define NV055_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV055_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV055_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV055_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV055_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV055_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV055_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV055_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV055_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV055_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV055_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV055_BLEND_DESTBLEND                                      31:28
#define NV055_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV055_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV055_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV055_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV055_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV055_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV055_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV055_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV055_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV055_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV055_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV055_CONTROL0                                             (0x0000033C)
#define NV055_CONTROL0_ALPHAREF                                    7:0
#define NV055_CONTROL0_ALPHAFUNC                                   11:8
#define NV055_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV055_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV055_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV055_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV055_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV055_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV055_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV055_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV055_CONTROL0_ALPHATESTENABLE                             12:12
#define NV055_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV055_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV055_CONTROL0_ORIGIN                                      13:13
#define NV055_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV055_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV055_CONTROL0_ZENABLE                                     15:14
#define NV055_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV055_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV055_CONTROL0_ZFUNC                                       19:16
#define NV055_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV055_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV055_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV055_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV055_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV055_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV055_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV055_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV055_CONTROL0_CULLMODE                                    21:20
#define NV055_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV055_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV055_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV055_CONTROL0_DITHERENABLE                                22:22
#define NV055_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ZWRITEENABLE                                24:24
#define NV055_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV055_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV055_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV055_CONTROL0_Z_FORMAT                                    31:30
#define NV055_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV055_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV055_CONTROL1                                             (0x00000340)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC                                7:4
#define NV055_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV055_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV055_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV055_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV055_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV055_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV055_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV055_CONTROL1_STENCIL_REF                                 15:8
#define NV055_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV055_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV055_CONTROL2                                             (0x00000344)
#define NV055_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV055_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV055_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV055_FOG_COLOR                                            (0x00000348)
#define NV055_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV055_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV055_TLMTVERTEX_COLOR_RED                                 23:16
#define NV055_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV055_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV055_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV055_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV055_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV055_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV055_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV055_DRAW_PRIMITIVE_I0                                    3:0
#define NV055_DRAW_PRIMITIVE_I1                                    7:4
#define NV055_DRAW_PRIMITIVE_I2                                    11:8
#define NV055_DRAW_PRIMITIVE_I3                                    15:12
#define NV055_DRAW_PRIMITIVE_I4                                    19:16
#define NV055_DRAW_PRIMITIVE_I5                                    31:20
/* obsolete stuff */
#define NV4_DX6_MULTI_TEXTURE_TRIANGLE                             (0x00000055)
#define Nv4Dx6MultiTextureTriangle                  Nv04Dx6MultiTextureTriangle
#define nv4Dx6MultiTextureTriangle                  Nv04Dx6MultiTextureTriangle
#define nv04Dx6MultiTextureTriangle                 Nv04Dx6MultiTextureTriangle


// This typedef really should be the same as Nv10CelsiusPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.


typedef NvV32 Nv056Typedef;


/* class NV10_CELSIUS_PRIMITIVE */
#define  NV10_CELSIUS_PRIMITIVE                                    (0x00000056)
/* NvNotification[] elements */
#define NV056_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV056_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV056_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV056_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV056_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV056_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV056_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved00[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved01[0x2c/4];
    NvV32 PmTrigger;
    NvV32 Reserved02[0x3c/4];
    NvV32 SetContextDmaNotifies;
    NvV32 SetContextDmaA;
    NvV32 SetContextDmaB;
    NvV32 SetContextDmaVertex;
    NvV32 SetContextDmaState;
    NvV32 SetContextDmaColor;
    NvV32 SetContextDmaZeta;
    NvV32 Reserved03[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved04[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved05[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvV32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvV32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvV32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvV32 SetStencilFuncRef;
    NvV32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvV32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvV32 SetMaterialEmission[3];
    NvV32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
        NvV32 S;
        NvV32 T;
        NvV32 R;
        NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvV32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved06[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved07[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved08[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved09[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0b[0xc8/4];
    struct {
        NvF32 AmbientColor[3];
        NvF32 DiffuseColor[3];
        NvF32 SpecularColor[3];
        NvF32 LocalRange;
        NvF32 InfiniteHalfVector[3];
        NvF32 InfiniteDirection[3];
        NvF32 SpotFalloff[3];
        NvF32 SpotDirection[4];
        NvF32 LocalPosition[3];
        NvF32 LocalAttenuation[3];
        NvV32 Reserved0c[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0d[0xc/4];
    NvF32 SetVertex4f[4];
    NvS16 SetVertex4s[4];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0e[0x4/4];
    NvS16 SetNormal3s[3];
    NvV16 Reserved0f[0xa/2];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvV32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvV32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS16 SetTexcoord0_2s[2];
    NvV32 Reserved10[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS16 SetTexcoord0_4s[4];
    NvF32 SetTexcoord1_2f[2];
    NvS16 SetTexcoord1_2s[2];
    NvV32 Reserved11[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS16 SetTexcoord1_4s[4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved12[0x4/4];
    NvV32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 Reserved13[0xbc/4];
    NvV32 SetBeginEnd;
    NvV16 ArrayElement16[256];
    NvV32 Reserved14[0xfc/4];
    NvV32 SetBeginEnd2;
    NvV32 ArrayElement32[64];
    NvV32 Reserved15[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 SetMaterialEmissionSW[3];
    NvV32 Reserved16[0x1c8/4];
    NvV32 SetBeginEnd4;
    NvV32 InlineArray[512];
} Nv10CelsiusPrimitive;


#define NV056_TYPEDEF                                      Nv10CelsiusPrimitive
#define NV056_SET_OBJECT                                           (0x00000000)


#define NV056_DEBUG_INIT(i)                                        (0x00001600+(i)*4)


#define NV056_FLUSH                                                        0x00000728


#define NV056_NO_OPERATION                                                 0x00000100


#define NV056_NOTIFY                                                       0x00000104
#define NV056_NOTIFY_TYPE                                                        23:0
#define NV056_NOTIFY_TYPE_WRITE_ONLY                                       0x00000000
#define NV056_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                0x00000001


#define NV056_SET_WARNING_ENABLE                                           0x00000108
#define NV056_SET_WARNING_ENABLE_V                                               23:0
#define NV056_SET_WARNING_ENABLE_V_FALSE                                   0x00000000
#define NV056_SET_WARNING_ENABLE_V_TRUE                                    0x00000001


#define NV056_GET_STATE                                                    0x0000010c
#define NV056_GET_STATE_GETSTATE                                                 31:0
#define NV056_GET_STATE_GETSTATE_ALL_STATE                                 0x00000001
#define NV056_GET_STATE_PUTSTATE_ALL_STATE                                 0x00000002
#define NV056_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                   0x00000003
#define NV056_GET_STATE_GETSTATE_RENDERING_STATE                           0x00000004
#define NV056_GET_STATE_GETSTATE_GEOMETRY_STATE                            0x00000005
#define NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM                        0x00000006
#define NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM                          0x00000007

#define NV056_WAIT_FOR_IDLE                                                0x00000110


#define NV056_PM_TRIGGER                                                   0x00000140


#define NV056_SET_CONTEXT_DMA_NOTIFIES                                     0x00000180


#define NV056_SET_CONTEXT_DMA_A                                            0x00000184


#define NV056_SET_CONTEXT_DMA_B                                            0x00000188


#define NV056_SET_CONTEXT_DMA_VERTEX                                       0x0000018c


#define NV056_SET_CONTEXT_DMA_STATE                                        0x00000190


#define NV056_SET_CONTEXT_DMA_COLOR                                        0x00000194


#define NV056_SET_CONTEXT_DMA_ZETA                                         0x00000198


#define NV056_SET_SURFACE_CLIP_HORIZONTAL                                  0x00000200
#define NV056_SET_SURFACE_CLIP_HORIZONTAL_X                                      15:0
#define NV056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                 31:16


#define NV056_SET_SURFACE_CLIP_VERTICAL                                    0x00000204
#define NV056_SET_SURFACE_CLIP_VERTICAL_Y                                        15:0
#define NV056_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                  31:16


#define NV056_SET_SURFACE_FORMAT                                           0x00000208
#define NV056_SET_SURFACE_FORMAT_COLOR                                            7:0
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                0x00000001
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                0x00000002
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                           0x00000003
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                0x00000004
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                0x00000005
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            0x00000006
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            0x00000007
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000008
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_B8                               0x00000009
#define NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8                             0x0000000A
#define NV056_SET_SURFACE_FORMAT_TYPE                                            15:8
#define NV056_SET_SURFACE_FORMAT_TYPE_PITCH                                0x00000001
#define NV056_SET_SURFACE_FORMAT_TYPE_SWIZZLE                              0x00000002
#define NV056_SET_SURFACE_FORMAT_WIDTH                                          23:16
#define NV056_SET_SURFACE_FORMAT_WIDTH_1                                   0x00000000
#define NV056_SET_SURFACE_FORMAT_WIDTH_2                                   0x00000001
#define NV056_SET_SURFACE_FORMAT_WIDTH_4                                   0x00000002
#define NV056_SET_SURFACE_FORMAT_WIDTH_8                                   0x00000003
#define NV056_SET_SURFACE_FORMAT_WIDTH_16                                  0x00000004
#define NV056_SET_SURFACE_FORMAT_WIDTH_32                                  0x00000005
#define NV056_SET_SURFACE_FORMAT_WIDTH_64                                  0x00000006
#define NV056_SET_SURFACE_FORMAT_WIDTH_128                                 0x00000007
#define NV056_SET_SURFACE_FORMAT_WIDTH_256                                 0x00000008
#define NV056_SET_SURFACE_FORMAT_WIDTH_512                                 0x00000009
#define NV056_SET_SURFACE_FORMAT_WIDTH_1024                                0x0000000A
#define NV056_SET_SURFACE_FORMAT_WIDTH_2048                                0x0000000B
#define NV056_SET_SURFACE_FORMAT_HEIGHT                                         31:24
#define NV056_SET_SURFACE_FORMAT_HEIGHT_1                                  0x00000000
#define NV056_SET_SURFACE_FORMAT_HEIGHT_2                                  0x00000001
#define NV056_SET_SURFACE_FORMAT_HEIGHT_4                                  0x00000002
#define NV056_SET_SURFACE_FORMAT_HEIGHT_8                                  0x00000003
#define NV056_SET_SURFACE_FORMAT_HEIGHT_16                                 0x00000004
#define NV056_SET_SURFACE_FORMAT_HEIGHT_32                                 0x00000005
#define NV056_SET_SURFACE_FORMAT_HEIGHT_64                                 0x00000006
#define NV056_SET_SURFACE_FORMAT_HEIGHT_128                                0x00000007
#define NV056_SET_SURFACE_FORMAT_HEIGHT_256                                0x00000008
#define NV056_SET_SURFACE_FORMAT_HEIGHT_512                                0x00000009
#define NV056_SET_SURFACE_FORMAT_HEIGHT_1024                               0x0000000A
#define NV056_SET_SURFACE_FORMAT_HEIGHT_2048                               0x0000000B


#define NV056_SET_SURFACE_PITCH                                            0x0000020c
#define NV056_SET_SURFACE_PITCH_COLOR                                            15:0
#define NV056_SET_SURFACE_PITCH_ZETA                                            31:16


#define NV056_SET_SURFACE_COLOR_OFFSET                                     0x00000210
#define NV056_SET_SURFACE_COLOR_OFFSET_V                                         31:0


#define NV056_SET_SURFACE_ZETA_OFFSET                                      0x00000214
#define NV056_SET_SURFACE_ZETA_OFFSET_V                                          31:0


#define NV056_SET_TEXTURE_OFFSET(i)                                (0x00000218+(i)*4)
#define NV056_SET_TEXTURE_OFFSET_V                                               31:0


#define NV056_SET_TEXTURE_FORMAT(i)                                (0x00000220+(i)*4)
#define NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA                                      1:0
#define NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                             0x00000001
#define NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                             0x00000002
#define NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                   2:2
#define NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                      0x00000000
#define NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                       0x00000001
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                       4:3
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                         0x00000001
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                         0x00000002
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH                                       6:5
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                         0x00000001
#define NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                         0x00000002
#define NV056_SET_TEXTURE_FORMAT_COLOR                                           11:7
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_Y8                               0x00000000
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_AY8                              0x00000001
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                         0x00000002
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                         0x00000003
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                         0x00000004
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                           0x00000005
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000006
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                         0x00000007
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                      0x00000008
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                        0x00000009
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                      0x0000000A
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                      0x0000000B
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                    0x0000000C
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                   0x0000000E
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                   0x0000000F
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                   0x00000010
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                     0x00000011
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                   0x00000012
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                         0x00000013
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                        0x00000014
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                      0x00000015
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                       0x00000016
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                       0x00000017
#define NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                     0x00000018
#define NV056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                  15:12
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U                                    19:16
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                             0x00000000
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                             0x00000001
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                             0x00000002
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                             0x00000003
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                            0x00000004
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                            0x00000005
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                            0x00000006
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                           0x00000007
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                           0x00000008
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                           0x00000009
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                          0x0000000A
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                          0x0000000B
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V                                    23:20
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                             0x00000000
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                             0x00000001
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                             0x00000002
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                             0x00000003
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                            0x00000004
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                            0x00000005
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                            0x00000006
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                           0x00000007
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                           0x00000008
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                           0x00000009
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                          0x0000000A
#define NV056_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                          0x0000000B
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                                26:24
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                      0x00000001
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                    0x00000002
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                     0x00000003
#define NV056_SET_TEXTURE_FORMAT_WRAPU                                          27:27
#define NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE                               0x00000000
#define NV056_SET_TEXTURE_FORMAT_WRAPU_TRUE                                0x00000001
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                                30:28
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                      0x00000001
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                    0x00000002
#define NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                     0x00000003
#define NV056_SET_TEXTURE_FORMAT_WRAPV                                          31:31
#define NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE                               0x00000000
#define NV056_SET_TEXTURE_FORMAT_WRAPV_TRUE                                0x00000001


#define NV056_SET_TEXTURE_CONTROL0(i)                              (0x00000228+(i)*4)
#define NV056_SET_TEXTURE_CONTROL0_ENABLE                                       30:30
#define NV056_SET_TEXTURE_CONTROL0_ENABLE_FALSE                            0x00000000
#define NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE                             0x00000001
#define NV056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                29:18
#define NV056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                 17:6
#define NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                  5:4
#define NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                         0x00000000
#define NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                         0x00000001
#define NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                             3:3
#define NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                0x00000000
#define NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                 0x00000001
#define NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                              2:2
#define NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                 0x00000000
#define NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                  0x00000001
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                            1:0
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE               0x00000000
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA               0x00000001
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                0x00000002
#define NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                0x00000003


#define NV056_SET_TEXTURE_CONTROL1(i)                              (0x00000230+(i)*4)
#define NV056_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                  31:16
#define NV056_SET_TEXTURE_CONTROL1_ZERO                                          15:0


#define NV056_SET_TEXTURE_CONTROL2(i)                              (0x00000238+(i)*4)
#define NV056_SET_TEXTURE_CONTROL2_PERTURB_DU                                    11:0
#define NV056_SET_TEXTURE_CONTROL2_PERTURB_DV                                   23:12
#define NV056_SET_TEXTURE_CONTROL2_IMAGE_LODF                                   31:24


#define NV056_SET_TEXTURE_IMAGE_RECT(i)                            (0x00000240+(i)*4)
#define NV056_SET_TEXTURE_IMAGE_RECT_WIDTH                                      31:16
#define NV056_SET_TEXTURE_IMAGE_RECT_HEIGHT                                      15:0


#define NV056_SET_TEXTURE_FILTER(i)                                (0x00000248+(i)*4)
#define NV056_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                   23:0
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN                                     27:24
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                        0x00000001
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                         0x00000002
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                     0x00000003
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                      0x00000004
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST               0x00000005
#define NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR                0x00000006
#define NV056_SET_TEXTURE_FILTER_TEXTUREMAG                                     31:28
#define NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                        0x00000001
#define NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                         0x00000002


#define NV056_SET_TEXTURE_PALETTE(i)                               (0x00000250+(i)*4)
#define NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA                                     5:0
#define NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                            0x00000000
#define NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                            0x00000001
#define NV056_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                 31:6


#define NV056_SET_COMBINER_ALPHA_ICW(i)                            (0x00000260+(i)*4)
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP                                      31:29
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA                                    28:28
#define NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE                                   27:24
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP                                      23:21
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA                                    20:20
#define NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE                                   19:16
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP                                      15:13
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA                                    12:12
#define NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE                                    11:8
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP                                        7:5
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA                                      4:4
#define NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE                                     3:0
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV056_SET_COMBINER_COLOR_ICW(i)                            (0x00000268+(i)*4)
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP                                      31:29
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_A_ALPHA                                    28:28
#define NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE                                   27:24
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP                                      23:21
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_B_ALPHA                                    20:20
#define NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE                                   19:16
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP                                      15:13
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_C_ALPHA                                    12:12
#define NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE                                    11:8
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP                                        7:5
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV056_SET_COMBINER_COLOR_ICW_D_ALPHA                                      4:4
#define NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                         0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                          0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE                                     3:0
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                        0x00000000
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                        0x00000001
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                        0x00000002
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                        0x00000003
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                        0x00000004
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                        0x00000005
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                        0x00000008
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                        0x00000009
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV056_SET_COMBINE_FACTOR(i)                                (0x00000270+(i)*4)
#define NV056_SET_COMBINE_FACTOR_BLUE                                             7:0
#define NV056_SET_COMBINE_FACTOR_GREEN                                           15:8
#define NV056_SET_COMBINE_FACTOR_RED                                            23:16
#define NV056_SET_COMBINE_FACTOR_ALPHA                                          31:24


#define NV056_SET_COMBINER_ALPHA_OCW(i)                            (0x00000278+(i)*4)
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION                                  31:15
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                     0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                0x00000001
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                0x00000002
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS           0x00000003
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1               0x00000006
#define NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                 14:14
#define NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                      0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                       0x00000001
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST                                     11:8
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                         0x0000000D
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST                                       7:4
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                          0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                          0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                          0x00000005
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                          0x00000008
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                          0x00000009
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                          0x0000000C
#define NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                          0x0000000D
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST                                       3:0
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                          0x00000000
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                          0x00000004
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                          0x00000005
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                          0x00000008
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                          0x00000009
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                          0x0000000C
#define NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                          0x0000000D


#define NV056_SET_COMBINER0_COLOR_OCW                                      0x00000280
#define NV056_SET_COMBINER0_COLOR_OCW_ZERO                                      31:27
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION                                 26:15
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                                14:14
#define NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST                                    11:8
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST                                      7:4
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST                                      3:0
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV056_SET_COMBINER1_COLOR_OCW                                      0x00000284
#define NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                           31:28
#define NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                  0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                  0x00000002
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT                                27:27
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                       0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                       0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION                                 26:15
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                                14:14
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST                                    11:8
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST                                      7:4
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST                                      3:0
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV056_SET_COMBINER_SPECULAR_FOG_CW0                                0x00000288
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                           31:29
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                             28:28
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                            27:24
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD           0x0000000F
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                           23:21
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                             20:20
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                            19:16
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD           0x0000000F
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                           15:13
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                             12:12
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                             11:8
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD           0x0000000F
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                             7:5
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                               4:4
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                              3:0
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT           0x0000000E
#define NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD           0x0000000F


#define NV056_SET_COMBINER_SPECULAR_FOG_CW1                                0x0000028c
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                           31:29
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                             28:28
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                            27:24
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                           23:21
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                             20:20
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                            19:16
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                           15:13
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                             12:12
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                   0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                             11:8
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                 0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                 0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                 0x00000002
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                 0x00000003
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                 0x00000004
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                 0x00000005
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                 0x00000008
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                 0x00000009
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                 0x0000000C
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                 0x0000000D
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                        7:7
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE           0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE            0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                6:6
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE   0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE    0x00000001
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12               5:0
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE  0x00000000
#define NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE   0x00000020


#define NV056_SET_CONTROL0                                                 0x00000290
#define NV056_SET_CONTROL0_PREMULTIPLIEDALPHA                                   31:24
#define NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                        0x00000000
#define NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                         0x00000001
#define NV056_SET_CONTROL0_TEXTUREPERSPECTIVE                                   23:20
#define NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                        0x00000000
#define NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                         0x00000001
#define NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                 19:16
#define NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                      0x00000000
#define NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                       0x00000001
#define NV056_SET_CONTROL0_Z_FORMAT                                             15:12
#define NV056_SET_CONTROL0_Z_FORMAT_FIXED                                  0x00000000
#define NV056_SET_CONTROL0_Z_FORMAT_FLOAT                                  0x00000001
#define NV056_SET_CONTROL0_WBUFFER_SELECT                                        11:8
#define NV056_SET_CONTROL0_WBUFFER_SELECT_0                                0x00000000
#define NV056_SET_CONTROL0_WBUFFER_SELECT_1                                0x00000001
#define NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE                                   7:0
#define NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                      0x00000000
#define NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                       0x00000001


#define NV056_SET_LIGHT_CONTROL                                            0x00000294
#define NV056_SET_LIGHT_CONTROL_LOCALEYE                                        31:16
#define NV056_SET_LIGHT_CONTROL_LOCALEYE_FALSE                             0x00000000
#define NV056_SET_LIGHT_CONTROL_LOCALEYE_TRUE                              0x00000001
#define NV056_SET_LIGHT_CONTROL_ATTENUATION_MODE                                 15:2
#define NV056_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                    0x00000000
#define NV056_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT                0x00000001
#define NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                              1:1
#define NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                 0x00000000
#define NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                  0x00000001
#define NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                                0:0
#define NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                   0x00000000
#define NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                    0x00000001


#define NV056_SET_COLOR_MATERIAL                                           0x00000298
#define NV056_SET_COLOR_MATERIAL_V                                               31:0
#define NV056_SET_COLOR_MATERIAL_V_DISABLED                                0x00000000
#define NV056_SET_COLOR_MATERIAL_V_EMISSION                                0x00000001
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT                                 0x00000002
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                        0x00000003
#define NV056_SET_COLOR_MATERIAL_V_DIFFUSE                                 0x00000004
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                        0x00000005
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                         0x00000006
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE                0x00000007
#define NV056_SET_COLOR_MATERIAL_V_SPECULAR                                0x00000008
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                       0x00000009
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                        0x0000000A
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR               0x0000000B
#define NV056_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                        0x0000000C
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR               0x0000000D
#define NV056_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR                0x0000000E
#define NV056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR       0x0000000F


#define NV056_SET_FOG_MODE                                                 0x0000029c
#define NV056_SET_FOG_MODE_FOG_MODE                                              31:0
#define NV056_SET_FOG_MODE_FOG_MODE_LINEAR                                 0x00002601
#define NV056_SET_FOG_MODE_FOG_MODE_EXP                                    0x00000800
#define NV056_SET_FOG_MODE_FOG_MODE_EXP2                                   0x00000801
#define NV056_SET_FOG_MODE_FOG_MODE_EXP_ABS                                0x00000802
#define NV056_SET_FOG_MODE_FOG_MODE_EXP2_ABS                               0x00000803


#define NV056_SET_FOG_GEN_MODE                                             0x000002a0
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE                                      31:0
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                      0x00000000
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                         0x00000001
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                         0x00000002
#define NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                     0x00000003


#define NV056_SET_FOG_ENABLE                                               0x000002a4
#define NV056_SET_FOG_ENABLE_V                                                   31:0
#define NV056_SET_FOG_ENABLE_V_FALSE                                       0x00000000
#define NV056_SET_FOG_ENABLE_V_TRUE                                        0x00000001


#define NV056_SET_FOG_COLOR                                               0x000002a8
#define NV056_SET_FOG_COLOR_FOG_COLOR_RED                                        7:0
#define NV056_SET_FOG_COLOR_FOG_COLOR_GREEN                                     15:8
#define NV056_SET_FOG_COLOR_FOG_COLOR_BLUE                                     23:16
#define NV056_SET_FOG_COLOR_FOG_COLOR_ALPHA                                    31:24


#define NV056_SET_COLOR_KEY_COLOR(i)                               (0x000002ac+(i)*4)
#define NV056_SET_COLOR_KEY_COLOR_V                                              31:0


#define NV056_SET_WINDOW_CLIP_TYPE                                         0x000002b4
#define NV056_SET_WINDOW_CLIP_TYPE_V                                             31:0
#define NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                             0x00000000
#define NV056_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                             0x00000001


#define NV056_SET_WINDOW_CLIP_HORIZONTAL(i)                        (0x000002c0+(i)*4)
#define NV056_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                    15:0
#define NV056_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                   31:16


#define NV056_SET_WINDOW_CLIP_VERTICAL(i)                          (0x000002e0+(i)*4)
#define NV056_SET_WINDOW_CLIP_VERTICAL_YMIN                                      15:0
#define NV056_SET_WINDOW_CLIP_VERTICAL_YMAX                                     31:16


#define NV056_SET_ALPHA_TEST_ENABLE                                        0x00000300
#define NV056_SET_ALPHA_TEST_ENABLE_V                                            31:0
#define NV056_SET_ALPHA_TEST_ENABLE_V_FALSE                                0x00000000
#define NV056_SET_ALPHA_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV056_SET_BLEND_ENABLE                                             0x00000304
#define NV056_SET_BLEND_ENABLE_V                                                 31:0
#define NV056_SET_BLEND_ENABLE_V_FALSE                                     0x00000000
#define NV056_SET_BLEND_ENABLE_V_TRUE                                      0x00000001


#define NV056_SET_CULL_FACE_ENABLE                                         0x00000308
#define NV056_SET_CULL_FACE_ENABLE_V                                             31:0
#define NV056_SET_CULL_FACE_ENABLE_V_FALSE                                 0x00000000
#define NV056_SET_CULL_FACE_ENABLE_V_TRUE                                  0x00000001


#define NV056_SET_DEPTH_TEST_ENABLE                                        0x0000030c
#define NV056_SET_DEPTH_TEST_ENABLE_V                                            31:0
#define NV056_SET_DEPTH_TEST_ENABLE_V_FALSE                                0x00000000
#define NV056_SET_DEPTH_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV056_SET_DITHER_ENABLE                                            0x00000310
#define NV056_SET_DITHER_ENABLE_V                                                31:0
#define NV056_SET_DITHER_ENABLE_V_FALSE                                    0x00000000
#define NV056_SET_DITHER_ENABLE_V_TRUE                                     0x00000001


#define NV056_SET_LIGHTING_ENABLE                                          0x00000314
#define NV056_SET_LIGHTING_ENABLE_V                                              31:0
#define NV056_SET_LIGHTING_ENABLE_V_FALSE                                  0x00000000
#define NV056_SET_LIGHTING_ENABLE_V_TRUE                                   0x00000001


#define NV056_SET_POINT_PARAMS_ENABLE                                      0x00000318
#define NV056_SET_POINT_PARAMS_ENABLE_V                                          31:0
#define NV056_SET_POINT_PARAMS_ENABLE_V_FALSE                              0x00000000
#define NV056_SET_POINT_PARAMS_ENABLE_V_TRUE                               0x00000001


#define NV056_SET_POINT_SMOOTH_ENABLE                                      0x0000031c
#define NV056_SET_POINT_SMOOTH_ENABLE_V                                          31:0
#define NV056_SET_POINT_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV056_SET_POINT_SMOOTH_ENABLE_V_TRUE                               0x00000001


#define NV056_SET_LINE_SMOOTH_ENABLE                                       0x00000320
#define NV056_SET_LINE_SMOOTH_ENABLE_V                                           31:0
#define NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV056_SET_LINE_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV056_SET_POLY_SMOOTH_ENABLE                                       0x00000324
#define NV056_SET_POLY_SMOOTH_ENABLE_V                                           31:0
#define NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV056_SET_POLY_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV056_SET_SKIN_ENABLE                                              0x00000328
#define NV056_SET_SKIN_ENABLE_V                                                  31:0
#define NV056_SET_SKIN_ENABLE_V_FALSE                                      0x00000000
#define NV056_SET_SKIN_ENABLE_V_TRUE                                       0x00000001


#define NV056_SET_STENCIL_TEST_ENABLE                                      0x0000032c
#define NV056_SET_STENCIL_TEST_ENABLE_V                                          31:0
#define NV056_SET_STENCIL_TEST_ENABLE_V_FALSE                              0x00000000
#define NV056_SET_STENCIL_TEST_ENABLE_V_TRUE                               0x00000001


#define NV056_SET_POLY_OFFSET_POINT_ENABLE                                 0x00000330
#define NV056_SET_POLY_OFFSET_POINT_ENABLE_V                                     31:0
#define NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                         0x00000000
#define NV056_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                          0x00000001


#define NV056_SET_POLY_OFFSET_LINE_ENABLE                                  0x00000334
#define NV056_SET_POLY_OFFSET_LINE_ENABLE_V                                      31:0
#define NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                          0x00000000
#define NV056_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                           0x00000001


#define NV056_SET_POLY_OFFSET_FILL_ENABLE                                  0x00000338
#define NV056_SET_POLY_OFFSET_FILL_ENABLE_V                                      31:0
#define NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                          0x00000000
#define NV056_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                           0x00000001


#define NV056_SET_ALPHA_FUNC                                               0x0000033c
#define NV056_SET_ALPHA_FUNC_V                                                   31:0
#define NV056_SET_ALPHA_FUNC_V_NEVER                                       0x00000200
#define NV056_SET_ALPHA_FUNC_V_LESS                                        0x00000201
#define NV056_SET_ALPHA_FUNC_V_EQUAL                                       0x00000202
#define NV056_SET_ALPHA_FUNC_V_LEQUAL                                      0x00000203
#define NV056_SET_ALPHA_FUNC_V_GREATER                                     0x00000204
#define NV056_SET_ALPHA_FUNC_V_NOTEQUAL                                    0x00000205
#define NV056_SET_ALPHA_FUNC_V_GEQUAL                                      0x00000206
#define NV056_SET_ALPHA_FUNC_V_ALWAYS                                      0x00000207


#define NV056_SET_ALPHA_REF                                                0x00000340


#define NV056_SET_BLEND_FUNC_SFACTOR                                       0x00000344
#define NV056_SET_BLEND_FUNC_SFACTOR_V                                           31:0
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ZERO                                0x00000000
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE                                 0x00000001
#define NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                           0x00000300
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                           0x00000302
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV056_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                           0x00000304
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV056_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                           0x00000306
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                  0x00000308
#define NV056_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV056_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV056_SET_BLEND_FUNC_DFACTOR                                       0x00000348
#define NV056_SET_BLEND_FUNC_DFACTOR_V                                           31:0
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ZERO                                0x00000000
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE                                 0x00000001
#define NV056_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                           0x00000300
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV056_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                           0x00000302
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV056_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                           0x00000304
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV056_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                           0x00000306
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV056_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV056_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV056_SET_BLEND_COLOR                                              0x0000034c
#define NV056_SET_BLEND_COLOR_V                                                  31:0


#define NV056_SET_BLEND_EQUATION                                           0x00000350
#define NV056_SET_BLEND_EQUATION_V                                               31:0
#define NV056_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                           0x0000800A
#define NV056_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                   0x0000800B
#define NV056_SET_BLEND_EQUATION_V_FUNC_ADD                                0x00008006
#define NV056_SET_BLEND_EQUATION_V_MIN                                     0x00008007
#define NV056_SET_BLEND_EQUATION_V_MAX                                     0x00008008


#define NV056_SET_DEPTH_FUNC                                               0x00000354
#define NV056_SET_DEPTH_FUNC_V                                                   31:0
#define NV056_SET_DEPTH_FUNC_V_NEVER                                       0x00000200
#define NV056_SET_DEPTH_FUNC_V_LESS                                        0x00000201
#define NV056_SET_DEPTH_FUNC_V_EQUAL                                       0x00000202
#define NV056_SET_DEPTH_FUNC_V_LEQUAL                                      0x00000203
#define NV056_SET_DEPTH_FUNC_V_GREATER                                     0x00000204
#define NV056_SET_DEPTH_FUNC_V_NOTEQUAL                                    0x00000205
#define NV056_SET_DEPTH_FUNC_V_GEQUAL                                      0x00000206
#define NV056_SET_DEPTH_FUNC_V_ALWAYS                                      0x00000207


#define NV056_SET_COLOR_MASK                                               0x00000358
#define NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                 31:24
#define NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                      0x00000000
#define NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                       0x00000001
#define NV056_SET_COLOR_MASK_RED_WRITE_ENABLE                                   23:16
#define NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                        0x00000000
#define NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                         0x00000001
#define NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                  15:8
#define NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                      0x00000000
#define NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                       0x00000001
#define NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                    7:0
#define NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                       0x00000000
#define NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                        0x00000001


#define NV056_SET_DEPTH_MASK                                               0x0000035c
#define NV056_SET_DEPTH_MASK_V                                                   31:0
#define NV056_SET_DEPTH_MASK_V_FALSE                                       0x00000000
#define NV056_SET_DEPTH_MASK_V_TRUE                                        0x00000001


#define NV056_SET_STENCIL_MASK                                             0x00000360
#define NV056_SET_STENCIL_MASK_V                                                 31:0


#define NV056_SET_STENCIL_FUNC                                             0x00000364
#define NV056_SET_STENCIL_FUNC_V                                                 31:0
#define NV056_SET_STENCIL_FUNC_V_NEVER                                     0x00000200
#define NV056_SET_STENCIL_FUNC_V_LESS                                      0x00000201
#define NV056_SET_STENCIL_FUNC_V_EQUAL                                     0x00000202
#define NV056_SET_STENCIL_FUNC_V_LEQUAL                                    0x00000203
#define NV056_SET_STENCIL_FUNC_V_GREATER                                   0x00000204
#define NV056_SET_STENCIL_FUNC_V_NOTEQUAL                                  0x00000205
#define NV056_SET_STENCIL_FUNC_V_GEQUAL                                    0x00000206
#define NV056_SET_STENCIL_FUNC_V_ALWAYS                                    0x00000207


#define NV056_SET_STENCIL_FUNC_REF                                         0x00000368
#define NV056_SET_STENCIL_FUNC_REF_V                                             31:0


#define NV056_SET_STENCIL_FUNC_MASK                                        0x0000036c
#define NV056_SET_STENCIL_FUNC_MASK_V                                            31:0


#define NV056_SET_STENCIL_OP_FAIL                                          0x00000370
#define NV056_SET_STENCIL_OP_FAIL_V                                              31:0
#define NV056_SET_STENCIL_OP_FAIL_V_KEEP                                   0x00001E00
#define NV056_SET_STENCIL_OP_FAIL_V_ZERO                                   0x00000000
#define NV056_SET_STENCIL_OP_FAIL_V_REPLACE                                0x00001E01
#define NV056_SET_STENCIL_OP_FAIL_V_INCRSAT                                0x00001E02
#define NV056_SET_STENCIL_OP_FAIL_V_DECRSAT                                0x00001E03
#define NV056_SET_STENCIL_OP_FAIL_V_INVERT                                 0x0000150A
#define NV056_SET_STENCIL_OP_FAIL_V_INCR                                   0x00008507
#define NV056_SET_STENCIL_OP_FAIL_V_DECR                                   0x00008508


#define NV056_SET_STENCIL_OP_ZFAIL                                         0x00000374
#define NV056_SET_STENCIL_OP_ZFAIL_V                                             31:0
#define NV056_SET_STENCIL_OP_ZFAIL_V_KEEP                                  0x00001E00
#define NV056_SET_STENCIL_OP_ZFAIL_V_ZERO                                  0x00000000
#define NV056_SET_STENCIL_OP_ZFAIL_V_REPLACE                               0x00001E01
#define NV056_SET_STENCIL_OP_ZFAIL_V_INCRSAT                               0x00001E02
#define NV056_SET_STENCIL_OP_ZFAIL_V_DECRSAT                               0x00001E03
#define NV056_SET_STENCIL_OP_ZFAIL_V_INVERT                                0x0000150A
#define NV056_SET_STENCIL_OP_ZFAIL_V_INCR                                  0x00008507
#define NV056_SET_STENCIL_OP_ZFAIL_V_DECR                                  0x00008508


#define NV056_SET_STENCIL_OP_ZPASS                                         0x00000378
#define NV056_SET_STENCIL_OP_ZPASS_V                                             31:0
#define NV056_SET_STENCIL_OP_ZPASS_V_KEEP                                  0x00001E00
#define NV056_SET_STENCIL_OP_ZPASS_V_ZERO                                  0x00000000
#define NV056_SET_STENCIL_OP_ZPASS_V_REPLACE                               0x00001E01
#define NV056_SET_STENCIL_OP_ZPASS_V_INCRSAT                               0x00001E02
#define NV056_SET_STENCIL_OP_ZPASS_V_DECRSAT                               0x00001E03
#define NV056_SET_STENCIL_OP_ZPASS_V_INVERT                                0x0000150A
#define NV056_SET_STENCIL_OP_ZPASS_V_INCR                                  0x00008507
#define NV056_SET_STENCIL_OP_ZPASS_V_DECR                                  0x00008508


#define NV056_SET_SHADE_MODE                                               0x0000037c
#define NV056_SET_SHADE_MODE_V                                                   31:0
#define NV056_SET_SHADE_MODE_V_FLAT                                        0x00001D00
#define NV056_SET_SHADE_MODE_V_SMOOTH                                      0x00001D01


#define NV056_SET_LINE_WIDTH                                               0x00000380
#define NV056_SET_LINE_WIDTH_V                                                   31:0


#define NV056_SET_POLYGON_OFFSET_SCALE_FACTOR                              0x00000384
#define NV056_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                  31:0


#define NV056_SET_POLYGON_OFFSET_BIAS                                      0x00000388
#define NV056_SET_POLYGON_OFFSET_BIAS_V                                          31:0


#define NV056_SET_FRONT_POLYGON_MODE                                       0x0000038c
#define NV056_SET_FRONT_POLYGON_MODE_V                                           31:0
#define NV056_SET_FRONT_POLYGON_MODE_V_POINT                               0x00001B00
#define NV056_SET_FRONT_POLYGON_MODE_V_LINE                                0x00001B01
#define NV056_SET_FRONT_POLYGON_MODE_V_FILL                                0x00001B02


#define NV056_SET_BACK_POLYGON_MODE                                        0x00000390
#define NV056_SET_BACK_POLYGON_MODE_V                                            31:0
#define NV056_SET_BACK_POLYGON_MODE_V_POINT                                0x00001B00
#define NV056_SET_BACK_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV056_SET_BACK_POLYGON_MODE_V_FILL                                 0x00001B02


#define NV056_SET_CLIP_MIN                                                 0x00000394
#define NV056_SET_CLIP_MIN_V                                                     31:0


#define NV056_SET_CLIP_MAX                                                 0x00000398
#define NV056_SET_CLIP_MAX_V                                                     31:0


#define NV056_SET_CULL_FACE                                                0x0000039c
#define NV056_SET_CULL_FACE_V                                                    31:0
#define NV056_SET_CULL_FACE_V_FRONT                                        0x00000404
#define NV056_SET_CULL_FACE_V_BACK                                         0x00000405
#define NV056_SET_CULL_FACE_V_FRONT_AND_BACK                               0x00000408


#define NV056_SET_FRONT_FACE                                               0x000003a0
#define NV056_SET_FRONT_FACE_V                                                   31:0
#define NV056_SET_FRONT_FACE_V_CW                                          0x00000900
#define NV056_SET_FRONT_FACE_V_CCW                                         0x00000901


#define NV056_SET_NORMALIZATION_ENABLE                                     0x000003a4
#define NV056_SET_NORMALIZATION_ENABLE_V                                         31:0
#define NV056_SET_NORMALIZATION_ENABLE_V_FALSE                             0x00000000
#define NV056_SET_NORMALIZATION_ENABLE_V_TRUE                              0x00000001


#define NV056_SET_MATERIAL_EMISSION(i)                             (0x000003a8+(i)*4)


#define NV056_SET_MATERIAL_ALPHA                                           0x000003b4


#define NV056_SET_SPECULAR_ENABLE                                          0x000003b8
#define NV056_SET_SPECULAR_ENABLE_V                                              31:0
#define NV056_SET_SPECULAR_ENABLE_V_FALSE                                  0x00000000
#define NV056_SET_SPECULAR_ENABLE_V_TRUE                                   0x00000001


#define NV056_SET_LIGHT_ENABLE_MASK                                        0x000003bc
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0                                        1:0
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1                                        3:2
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2                                        5:4
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3                                        7:6
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4                                        9:8
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5                                      11:10
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6                                      13:12
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                            0x00000003
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7                                      15:14
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                             0x00000000
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                        0x00000001
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                           0x00000002
#define NV056_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                            0x00000003


#define NV056_SET_TEXGEN_S(i)                                     (0x000003c0+(i)*16)
#define NV056_SET_TEXGEN_S_V                                                     31:0
#define NV056_SET_TEXGEN_S_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_S_V_NORMAL_MAP                                    0x00008511
#define NV056_SET_TEXGEN_S_V_REFLECTION_MAP                                0x00008512
#define NV056_SET_TEXGEN_S_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_S_V_OBJECT_LINEAR                                 0x00002401
#define NV056_SET_TEXGEN_S_V_SPHERE_MAP                                    0x00002402
#define NV056_SET_TEXGEN_S_V_EMBOSS                                        0x0000855F


#define NV056_SET_TEXGEN_T(i)                                     (0x000003c4+(i)*16)
#define NV056_SET_TEXGEN_T_V                                                     31:0
#define NV056_SET_TEXGEN_T_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_T_V_NORMAL_MAP                                    0x00008511
#define NV056_SET_TEXGEN_T_V_REFLECTION_MAP                                0x00008512
#define NV056_SET_TEXGEN_T_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_T_V_OBJECT_LINEAR                                 0x00002401
#define NV056_SET_TEXGEN_T_V_SPHERE_MAP                                    0x00002402
#define NV056_SET_TEXGEN_T_V_EMBOSS                                        0x0000855F


#define NV056_SET_TEXGEN_R(i)                                     (0x000003c8+(i)*16)
#define NV056_SET_TEXGEN_R_V                                                     31:0
#define NV056_SET_TEXGEN_R_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_R_V_NORMAL_MAP                                    0x00008511
#define NV056_SET_TEXGEN_R_V_REFLECTION_MAP                                0x00008512
#define NV056_SET_TEXGEN_R_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_R_V_OBJECT_LINEAR                                 0x00002401
#define NV056_SET_TEXGEN_R_V_EMBOSS                                        0x0000855F


#define NV056_SET_TEXGEN_Q(i)                                     (0x000003cc+(i)*16)
#define NV056_SET_TEXGEN_Q_V                                                     31:0
#define NV056_SET_TEXGEN_Q_V_DISABLE                                       0x00000000
#define NV056_SET_TEXGEN_Q_V_EYE_LINEAR                                    0x00002400
#define NV056_SET_TEXGEN_Q_V_OBJECT_LINEAR                                 0x00002401


#define NV056_SET_TEXTURE_MATRIX0_ENABLE                                   0x000003e0
#define NV056_SET_TEXTURE_MATRIX0_ENABLE_V                                       31:0
#define NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                           0x00000000
#define NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                            0x00000001


#define NV056_SET_TEXTURE_MATRIX1_ENABLE                                   0x000003e4
#define NV056_SET_TEXTURE_MATRIX1_ENABLE_V                                       31:0
#define NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                           0x00000000
#define NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                            0x00000001


#define NV056_SET_TLMODE                                                   0x000003e8
#define NV056_SET_TLMODE_PASSTHROUGH                                              0:0
#define NV056_SET_TLMODE_PASSTHROUGH_TRUE                                  0x00000001
#define NV056_SET_TLMODE_PASSTHROUGH_FALSE                                 0x00000000
#define NV056_SET_TLMODE_W_DIVIDE_0                                               1:1
#define NV056_SET_TLMODE_W_DIVIDE_0_DISABLE                                0x00000000
#define NV056_SET_TLMODE_W_DIVIDE_0_ENABLE                                 0x00000001
#define NV056_SET_TLMODE_W_DIVIDE_1                                               2:2
#define NV056_SET_TLMODE_W_DIVIDE_1_DISABLE                                0x00000000
#define NV056_SET_TLMODE_W_DIVIDE_1_ENABLE                                 0x00000001


#define NV056_SET_POINT_SIZE                                               0x000003ec
#define NV056_SET_POINT_SIZE_V                                                   31:0


#define NV056_SET_SWATH_WIDTH                                              0x000003f0
#define NV056_SET_SWATH_WIDTH_V                                                  31:0
#define NV056_SET_SWATH_WIDTH_V_8                                          0x00000000
#define NV056_SET_SWATH_WIDTH_V_16                                         0x00000001
#define NV056_SET_SWATH_WIDTH_V_32                                         0x00000002
#define NV056_SET_SWATH_WIDTH_V_64                                         0x00000003


#define NV056_SET_FLAT_SHADE_OP                                            0x000003f4
#define NV056_SET_FLAT_SHADE_OP_V                                                31:0
#define NV056_SET_FLAT_SHADE_OP_V_LAST_VTX                                 0x00000000
#define NV056_SET_FLAT_SHADE_OP_V_FIRST_VTX                                0x00000001


#define NV056_SET_MODEL_VIEW_MATRIX0(i)                            (0x00000400+(i)*4)


#define NV056_SET_MODEL_VIEW_MATRIX1(i)                            (0x00000440+(i)*4)


#define NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                    (0x00000480+(i)*4)


#define NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                    (0x000004c0+(i)*4)


#define NV056_SET_COMPOSITE_MATRIX(i)                              (0x00000500+(i)*4)


#define NV056_SET_TEXTURE_MATRIX0(i)                               (0x00000540+(i)*4)


#define NV056_SET_TEXTURE_MATRIX1(i)                               (0x00000580+(i)*4)


#define NV056_SET_TEXGEN_SPLANE0(i)                                (0x00000600+(i)*4)


#define NV056_SET_TEXGEN_TPLANE0(i)                                (0x00000610+(i)*4)


#define NV056_SET_TEXGEN_RPLANE0(i)                                (0x00000620+(i)*4)


#define NV056_SET_TEXGEN_QPLANE0(i)                                (0x00000630+(i)*4)


#define NV056_SET_TEXGEN_SPLANE1(i)                                (0x00000640+(i)*4)


#define NV056_SET_TEXGEN_TPLANE1(i)                                (0x00000650+(i)*4)


#define NV056_SET_TEXGEN_RPLANE1(i)                                (0x00000660+(i)*4)


#define NV056_SET_TEXGEN_QPLANE1(i)                                (0x00000670+(i)*4)


#define NV056_SET_FOG_PARAMS(i)                                    (0x00000680+(i)*4)


#define NV056_SET_FOG_PLANE(i)                                     (0x0000068c+(i)*4)


#define NV056_SET_SPECULAR_PARAMS(i)                               (0x000006a0+(i)*4)


#define NV056_SET_SCENE_AMBIENT_COLOR(i)                           (0x000006c4+(i)*4)


#define NV056_SET_VIEWPORT_OFFSET(i)                               (0x000006e8+(i)*4)


#define NV056_SET_POINT_PARAMS(i)                                  (0x000006f8+(i)*4)


#define NV056_SET_EYE_POSITION(i)                                  (0x00000718+(i)*4)

#define NV056_SET_EYE_DIRECTION_SW(i)                              (0x0000072c+(i)*4)


#define NV056_SET_LIGHT_AMBIENT_COLOR(i,j)                 (0x00000800+(i)*128+(j)*4)


#define NV056_SET_LIGHT_DIFFUSE_COLOR(i,j)                 (0x0000080c+(i)*128+(j)*4)


#define NV056_SET_LIGHT_SPECULAR_COLOR(i,j)                (0x00000818+(i)*128+(j)*4)


#define NV056_SET_LIGHT_LOCAL_RANGE(i)                           (0x00000824+(i)*128)


#define NV056_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)          (0x00000828+(i)*128+(j)*4)


#define NV056_SET_LIGHT_INFINITE_DIRECTION(i,j)            (0x00000834+(i)*128+(j)*4)


#define NV056_SET_LIGHT_SPOT_FALLOFF(i,j)                  (0x00000840+(i)*128+(j)*4)


#define NV056_SET_LIGHT_SPOT_DIRECTION(i,j)                (0x0000084c+(i)*128+(j)*4)


#define NV056_SET_LIGHT_LOCAL_POSITION(i,j)                (0x0000085c+(i)*128+(j)*4)


#define NV056_SET_LIGHT_LOCAL_ATTENUATION(i,j)             (0x00000868+(i)*128+(j)*4)


#define NV056_SET_VERTEX3F(i)                                      (0x00000c00+(i)*4)


#define NV056_SET_VERTEX4F(i)                                      (0x00000c18+(i)*4)


#define NV056_SET_VERTEX4S(i)                                      (0x00000c28+(i)*4)


#define NV056_SET_NORMAL3F(i)                                      (0x00000c30+(i)*4)


#define NV056_SET_NORMAL3S(i)                                      (0x00000c40+(i)*2)


#define NV056_SET_DIFFUSE_COLOR4F(i)                               (0x00000c50+(i)*4)


#define NV056_SET_DIFFUSE_COLOR3F(i)                               (0x00000c60+(i)*4)


#define NV056_SET_DIFFUSE_COLOR4UB                                         0x00000c6c


#define NV056_SET_SPECULAR_COLOR4F(i)                              (0x00000c70+(i)*4)


#define NV056_SET_SPECULAR_COLOR3F(i)                              (0x00000c80+(i)*4)


#define NV056_SET_SPECULAR_COLOR4UB                                        0x00000c8c


#define NV056_SET_TEXCOORD0_2F(i)                                  (0x00000c90+(i)*4)


#define NV056_SET_TEXCOORD0_2S(i)                                  (0x00000c98+(i)*2)


#define NV056_SET_TEXCOORD0_4F(i)                                  (0x00000ca0+(i)*4)


#define NV056_SET_TEXCOORD0_4S(i)                                  (0x00000cb0+(i)*2)


#define NV056_SET_TEXCOORD1_2F(i)                                  (0x00000cb8+(i)*4)


#define NV056_SET_TEXCOORD1_2S(i)                                  (0x00000cc0+(i)*2)


#define NV056_SET_TEXCOORD1_4F(i)                                  (0x00000cc8+(i)*4)


#define NV056_SET_TEXCOORD1_4S(i)                                  (0x00000cd8+(i)*2)


#define NV056_SET_FOG1F                                                    0x00000ce0


#define NV056_SET_WEIGHT1F                                                 0x00000ce4


#define NV056_SET_EDGE_FLAG                                                0x00000cec


#define NV056_INVALIDATE_VERTEX_CACHE_FILE                                 0x00000cf0


#define NV056_INVALIDATE_VERTEX_FILE                                       0x00000cf4


#define NV056_TL_NOP                                                       0x00000cf8


#define NV056_TL_SYNC                                                      0x00000cfc


#define NV056_SET_VERTEX_ARRAY_OFFSET                                      0x00000d00
#define NV056_SET_VERTEX_ARRAY_OFFSET_OFFSET                                     27:0


#define NV056_SET_VERTEX_ARRAY_FORMAT                                      0x00000d04
#define NV056_SET_VERTEX_ARRAY_FORMAT_W                                         31:24
#define NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE                               0x00000000
#define NV056_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                            0x00000001
#define NV056_SET_VERTEX_ARRAY_FORMAT_STRIDE                                     23:8
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE                                        7:4
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2                               0x00000002
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_4                               0x00000004
#define NV056_SET_VERTEX_ARRAY_FORMAT_TYPE                                        3:0
#define NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV056_SET_DIFFUSE_ARRAY_OFFSET                                     0x00000d08
#define NV056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                    27:0


#define NV056_SET_DIFFUSE_ARRAY_FORMAT                                     0x00000d0c
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                    31:8
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                       7:4
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                       3:0
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA             0x00000000
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002
#define NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA             0x00000004


#define NV056_SET_SPECULAR_ARRAY_OFFSET                                    0x00000d10
#define NV056_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                   27:0


#define NV056_SET_SPECULAR_ARRAY_FORMAT                                    0x00000d14
#define NV056_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                   31:8
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE                                      7:4
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE                                      3:0
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004


#define NV056_SET_TEX_COORD0_ARRAY_OFFSET                                  0x00000d18
#define NV056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                 27:0


#define NV056_SET_TEX_COORD0_ARRAY_FORMAT                                  0x00000d1c
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                 31:8
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                    7:4
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                    3:0
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV056_SET_TEX_COORD1_ARRAY_OFFSET                                  0x00000d20
#define NV056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                 27:0


#define NV056_SET_TEX_COORD1_ARRAY_FORMAT                                  0x00000d24
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                 31:8
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                    7:4
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                    3:0
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV056_SET_NORMAL_ARRAY_OFFSET                                      0x00000d28
#define NV056_SET_NORMAL_ARRAY_OFFSET_OFFSET                                     27:0


#define NV056_SET_NORMAL_ARRAY_FORMAT                                      0x00000d2c
#define NV056_SET_NORMAL_ARRAY_FORMAT_STRIDE                                     31:8
#define NV056_SET_NORMAL_ARRAY_FORMAT_SIZE                                        7:4
#define NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV056_SET_NORMAL_ARRAY_FORMAT_TYPE                                        3:0
#define NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV056_SET_WEIGHT_ARRAY_OFFSET                                      0x00000d30
#define NV056_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                     27:0


#define NV056_SET_WEIGHT_ARRAY_FORMAT                                      0x00000d34
#define NV056_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                     31:8
#define NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE                                        7:4
#define NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                               0x00000001
#define NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE                                        3:0
#define NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV056_SET_FOG_ARRAY_OFFSET                                         0x00000d38
#define NV056_SET_FOG_ARRAY_OFFSET_OFFSET                                        27:0


#define NV056_SET_FOG_ARRAY_FORMAT                                         0x00000d3c
#define NV056_SET_FOG_ARRAY_FORMAT_STRIDE                                        31:8
#define NV056_SET_FOG_ARRAY_FORMAT_SIZE                                           7:4
#define NV056_SET_FOG_ARRAY_FORMAT_SIZE_0                                  0x00000000
#define NV056_SET_FOG_ARRAY_FORMAT_SIZE_1                                  0x00000001
#define NV056_SET_FOG_ARRAY_FORMAT_TYPE                                           3:0
#define NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                              0x00000001
#define NV056_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                              0x00000002


#define NV056_SET_BEGIN_END                                                0x00000dfc
#define NV056_SET_BEGIN_END_OP                                                   31:0
#define NV056_SET_BEGIN_END_OP_END                                         0x00000000
#define NV056_SET_BEGIN_END_OP_POINTS                                      0x00000001
#define NV056_SET_BEGIN_END_OP_LINES                                       0x00000002
#define NV056_SET_BEGIN_END_OP_LINE_LOOP                                   0x00000003
#define NV056_SET_BEGIN_END_OP_LINE_STRIP                                  0x00000004
#define NV056_SET_BEGIN_END_OP_TRIANGLES                                   0x00000005
#define NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP                              0x00000006
#define NV056_SET_BEGIN_END_OP_TRIANGLE_FAN                                0x00000007
#define NV056_SET_BEGIN_END_OP_QUADS                                       0x00000008
#define NV056_SET_BEGIN_END_OP_QUAD_STRIP                                  0x00000009
#define NV056_SET_BEGIN_END_OP_POLYGON                                     0x0000000A


#define NV056_ARRAY_ELEMENT16(i)                                   (0x00000e00+(i)*2)


#define NV056_SET_BEGIN_END2                                               0x000010fc
#define NV056_SET_BEGIN_END2_OP                                                  31:0
#define NV056_SET_BEGIN_END2_OP_END                                        0x00000000
#define NV056_SET_BEGIN_END2_OP_POINTS                                     0x00000001
#define NV056_SET_BEGIN_END2_OP_LINES                                      0x00000002
#define NV056_SET_BEGIN_END2_OP_LINE_LOOP                                  0x00000003
#define NV056_SET_BEGIN_END2_OP_LINE_STRIP                                 0x00000004
#define NV056_SET_BEGIN_END2_OP_TRIANGLES                                  0x00000005
#define NV056_SET_BEGIN_END2_OP_TRIANGLE_STRIP                             0x00000006
#define NV056_SET_BEGIN_END2_OP_TRIANGLE_FAN                               0x00000007
#define NV056_SET_BEGIN_END2_OP_QUADS                                      0x00000008
#define NV056_SET_BEGIN_END2_OP_QUAD_STRIP                                 0x00000009
#define NV056_SET_BEGIN_END2_OP_POLYGON                                    0x0000000A


#define NV056_ARRAY_ELEMENT32(i)                                   (0x00001100+(i)*4)


#define NV056_SET_BEGIN_END3                                               0x000013fc
#define NV056_SET_BEGIN_END3_OP                                                  31:0
#define NV056_SET_BEGIN_END3_OP_END                                        0x00000000
#define NV056_SET_BEGIN_END3_OP_POINTS                                     0x00000001
#define NV056_SET_BEGIN_END3_OP_LINES                                      0x00000002
#define NV056_SET_BEGIN_END3_OP_LINE_LOOP                                  0x00000003
#define NV056_SET_BEGIN_END3_OP_LINE_STRIP                                 0x00000004
#define NV056_SET_BEGIN_END3_OP_TRIANGLES                                  0x00000005
#define NV056_SET_BEGIN_END3_OP_TRIANGLE_STRIP                             0x00000006
#define NV056_SET_BEGIN_END3_OP_TRIANGLE_FAN                               0x00000007
#define NV056_SET_BEGIN_END3_OP_QUADS                                      0x00000008
#define NV056_SET_BEGIN_END3_OP_QUAD_STRIP                                 0x00000009
#define NV056_SET_BEGIN_END3_OP_POLYGON                                    0x0000000A


#define NV056_DRAW_ARRAYS(i)                                       (0x00001400+(i)*4)
#define NV056_DRAW_ARRAYS_COUNT                                                 31:24
#define NV056_DRAW_ARRAYS_START_INDEX                                            23:0


#define NV056_SET_MATERIAL_EMISSION_SW(i)                          (0x00001628+(i)*4)

#define NV056_SET_BEGIN_END4                                               0x000017fc
#define NV056_SET_BEGIN_END4_OP                                                  31:0
#define NV056_SET_BEGIN_END4_OP_END                                        0x00000000
#define NV056_SET_BEGIN_END4_OP_POINTS                                     0x00000001
#define NV056_SET_BEGIN_END4_OP_LINES                                      0x00000002
#define NV056_SET_BEGIN_END4_OP_LINE_LOOP                                  0x00000003
#define NV056_SET_BEGIN_END4_OP_LINE_STRIP                                 0x00000004
#define NV056_SET_BEGIN_END4_OP_TRIANGLES                                  0x00000005
#define NV056_SET_BEGIN_END4_OP_TRIANGLE_STRIP                             0x00000006
#define NV056_SET_BEGIN_END4_OP_TRIANGLE_FAN                               0x00000007
#define NV056_SET_BEGIN_END4_OP_QUADS                                      0x00000008
#define NV056_SET_BEGIN_END4_OP_QUAD_STRIP                                 0x00000009
#define NV056_SET_BEGIN_END4_OP_POLYGON                                    0x0000000A


#define NV056_INLINE_ARRAY(i)                                      (0x00001800+(i)*4)


/* class NV04_CONTEXT_COLOR_KEY */
#define  NV04_CONTEXT_COLOR_KEY                                    (0x00000057)
/* NvNotification[] elements */
#define NV057_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV057_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV057_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV057_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV057_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV057_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV057_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV057_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetColorFormat;          /* NV057_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetColor;                /* color key value                  0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv057Typedef, Nv04ContextColorKey;
#define NV057_TYPEDEF                                       Nv04ContextColorKey
/* dma method offsets, fields, and values */
#define NV057_SET_OBJECT                                           (0x00000000)
#define NV057_NO_OPERATION                                         (0x00000100)
#define NV057_NOTIFY                                               (0x00000104)
#define NV057_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV057_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV057_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV057_SET_COLOR_FORMAT                                     (0x00000300)
#define NV057_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV057_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV057_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV057_SET_COLOR                                            (0x00000304)
/* obsolete stuff */
#define NV4_CONTEXT_COLOR_KEY                                      (0x00000057)
#define Nv4ContextColorKey                                  Nv04ContextColorKey
#define nv4ContextColorKey                                  Nv04ContextColorKey
#define nv04ContextColorKey                                 Nv04ContextColorKey


/* class NV03_CONTEXT_SURFACE_2D_DESTINATION */
#define  NV03_CONTEXT_SURFACE_2D_DESTINATION                       (0x00000058)
/* NvNotification[] elements */
#define NV058_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV058_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV058_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV058_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV058_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV058_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV058_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV058_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV058_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 SetImagePitch;           /* bytes, vertical pixel delta      0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv058Typedef, Nv03ContextSurface2dDestination;
#define NV058_TYPEDEF                           Nv03ContextSurface2dDestination
/* dma method offsets, fields, and values */
#define NV058_SET_OBJECT                                           (0x00000000)
#define NV058_NO_OPERATION                                         (0x00000100)
#define NV058_NOTIFY                                               (0x00000104)
#define NV058_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV058_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV058_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV058_SET_COLOR_FORMAT                                     (0x00000300)
#define NV058_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV058_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV058_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV058_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV058_SET_IMAGE_PITCH                                      (0x00000308)
#define NV058_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_0                                     (0x00000058)
#define NV3_CONTEXT_SURFACE_0                                      (0x00000058)
#define Nv03ContextSurface0                     Nv03ContextSurface2dDestination
#define nv03ContextSurface0                     Nv03ContextSurface2dDestination
#define Nv3ContextSurface0                      Nv03ContextSurface2dDestination
#define nv3ContextSurface0                      Nv03ContextSurface2dDestination
#define nv03ContextSurface2dDestination         Nv03ContextSurface2dDestination


/* class NV03_CONTEXT_SURFACE_2D_SOURCE */
#define  NV03_CONTEXT_SURFACE_2D_SOURCE                            (0x00000059)
/* NvNotification[] elements */
#define NV059_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV059_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV059_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV059_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV059_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV059_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV059_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV059_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV059_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 SetImagePitch;           /* bytes, vertical pixel delta      0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv059Typedef, Nv03ContextSurface2dSource;
#define NV059_TYPEDEF                                Nv03ContextSurface2dSource
/* dma method offsets, fields, and values */
#define NV059_SET_OBJECT                                           (0x00000000)
#define NV059_NO_OPERATION                                         (0x00000100)
#define NV059_NOTIFY                                               (0x00000104)
#define NV059_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV059_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV059_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV059_SET_COLOR_FORMAT                                     (0x00000300)
#define NV059_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV059_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV059_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV059_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV059_SET_IMAGE_PITCH                                      (0x00000308)
#define NV059_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_1                                     (0x00000059)
#define NV3_CONTEXT_SURFACE_1                                      (0x00000059)
#define Nv03ContextSurface1                          Nv03ContextSurface2dSource
#define nv03ContextSurface1                          Nv03ContextSurface2dSource
#define Nv3ContextSurface1                           Nv03ContextSurface2dSource
#define nv3ContextSurface1                           Nv03ContextSurface2dSource
#define nv03ContextSurface2dSource                   Nv03ContextSurface2dSource


/* class NV03_CONTEXT_SURFACE_3D_COLOR */
#define  NV03_CONTEXT_SURFACE_3D_COLOR                             (0x0000005A)
/* NvNotification[] elements */
#define NV05A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV05A_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 SetImagePitch;           /* bytes, vertical pixel delta      0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv05aTypedef, Nv03ContextSurface3dColor;
#define NV05A_TYPEDEF                                 Nv03ContextSurface3dColor
/* dma method offsets, fields, and values */
#define NV05A_SET_OBJECT                                           (0x00000000)
#define NV05A_NO_OPERATION                                         (0x00000100)
#define NV05A_NOTIFY                                               (0x00000104)
#define NV05A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV05A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05A_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05A_SET_COLOR_FORMAT_DUMMY_0                             (0x01010000)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_1              (0x01010001)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_2              (0x01000000)
#define NV05A_SET_COLOR_FORMAT_DUMMY_3                             (0x00000001)
#define NV05A_SET_IMAGE_PITCH                                      (0x00000308)
#define NV05A_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_2                                     (0x0000005A)
#define NV3_CONTEXT_SURFACE_2                                      (0x0000005A)
#define Nv03ContextSurface2                           Nv03ContextSurface3dColor
#define nv03ContextSurface2                           Nv03ContextSurface3dColor
#define Nv3ContextSurface2                            Nv03ContextSurface3dColor
#define nv3ContextSurface2                            Nv03ContextSurface3dColor
#define nv03ContextSurface3dColor                     Nv03ContextSurface3dColor


/* class NV03_CONTEXT_SURFACE_3D_DEPTH */
#define  NV03_CONTEXT_SURFACE_3D_DEPTH                             (0x0000005B)
/* NvNotification[] elements */
#define NV05B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05B_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV05B_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Reserved02[0x001];
 NvU32 NvDummy;                   /* ignored                          0308-030b*/
 NvU32 SetImageOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved03[0x73c];
} Nv05bTypedef, Nv03ContextSurface3dDepth;
#define NV05B_TYPEDEF                                 Nv03ContextSurface3dDepth
/* dma method offsets, fields, and values */
#define NV05B_SET_OBJECT                                           (0x00000000)
#define NV05B_NO_OPERATION                                         (0x00000100)
#define NV05B_NOTIFY                                               (0x00000104)
#define NV05B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV05B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05B_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05B_SET_COLOR_FORMAT_LE_W16_0                            (0x01010000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_1                            (0x01010001)
#define NV05B_SET_COLOR_FORMAT_LE_W16_2                            (0x01000000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_3                            (0x00000001)
#define NV05B_DUMMY                                                (0x00000308)
#define NV05B_SET_IMAGE_OFFSET                                     (0x0000030C)
/* obsolete stuff */
#define NV03_CONTEXT_SURFACE_3                                     (0x0000005B)
#define NV3_CONTEXT_SURFACE_3                                      (0x0000005B)
#define Nv03ContextSurface3                           Nv03ContextSurface3dDepth
#define nv03ContextSurface3                           Nv03ContextSurface3dDepth
#define Nv3ContextSurface3                            Nv03ContextSurface3dDepth
#define nv3ContextSurface3                            Nv03ContextSurface3dDepth
#define nv03ContextSurface3dDepth                     Nv03ContextSurface3dDepth


/* class NV04_RENDER_SOLID_LIN */
#define  NV04_RENDER_SOLID_LIN                                     (0x0000005C)
/* NvNotification[] elements */
#define NV05C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05C_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV05C_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV05C_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point0;                 /* y_x S16_S16 in pixels            0400-0403*/
  NvV32 point1;                 /* y_x S16_S16 in pixels            0404-0407*/
 } Lin[16];                     /* end of aliased methods in array      -047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 point0X;                /* in pixels, 0 at left                0-   3*/
  NvS32 point0Y;                /* in pixels, 0 at top                 4-   7*/
  NvS32 point1X;                /* in pixels, 0 at left                8-   b*/
  NvS32 point1Y;                /* in pixels, 0 at top                 c-   f*/
 } Lin32[8];                    /* end of aliased methods in array      -04ff*/
 NvV32 PolyLin[32];             /* y_x S16_S16 in pixels            0500-057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } PolyLin32[16];               /* end of aliased methods in array      -05ff*/
 struct {                       /* start aliased methods in array   0600-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorPolyLin[16];            /* end of aliased methods in array      -067f*/
 NvV32 Reserved03[0x660];
} Nv05cTypedef, Nv04RenderSolidLin;
#define NV05C_TYPEDEF                                        Nv04RenderSolidLin
/* dma method offsets, fields, and values */
#define NV05C_SET_OBJECT                                           (0x00000000)
#define NV05C_NO_OPERATION                                         (0x00000100)
#define NV05C_NOTIFY                                               (0x00000104)
#define NV05C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05C_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05C_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05C_SET_OPERATION                                        (0x000002FC)
#define NV05C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05C_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05C_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05C_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05C_COLOR                                                (0x00000304)
#define NV05C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0(a)                                        (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0_X                                         15:0
#define NV05C_LIN_POINT0_Y                                         31:16
#define NV05C_LIN_POINT1(a)                                        (0x00000404\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT1_X                                         15:0
#define NV05C_LIN_POINT1_Y                                         31:16
#define NV05C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_X(a)                                    (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_Y(a)                                    (0x00000484\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_X(a)                                    (0x00000488\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_Y(a)                                    (0x0000048C\
                                                                   +(a)*0x0010)
#define NV05C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV05C_POLY_LIN_X                                           15:0
#define NV05C_POLY_LIN_Y                                           31:16
#define NV05C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_X(a)                                      (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_Y(a)                                      (0x00000584\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_COLOR(a)                              (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT(a)                              (0x00000604\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV05C_COLOR_POLY_LIN_POINT_Y                               31:16
/* obsolete stuff */
#define NV4_RENDER_SOLID_LIN                                       (0x0000005C)
#define Nv4RenderSolidLin                                    Nv04RenderSolidLin
#define nv4RenderSolidLin                                    Nv04RenderSolidLin
#define nv04RenderSolidLin                                   Nv04RenderSolidLin


/* class NV04_RENDER_SOLID_TRIANGLE */
#define  NV04_RENDER_SOLID_TRIANGLE                                (0x0000005D)
/* NvNotification[] elements */
#define NV05D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05D_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV05D_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV05D_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x002];
 NvV32 TrianglePoint0;          /* y_x S16_S16 in pixels            0310-0313*/
 NvV32 TrianglePoint1;          /* y_x S16_S16 in pixels            0314-0317*/
 NvV32 TrianglePoint2;          /* y_x S16_S16 in pixels            0318-031b*/
 NvV32 Reserved03[0x001];
 NvS32 Triangle32Point0X;       /* in pixels, 0 at left             0320-0323*/
 NvS32 Triangle32Point0Y;       /* in pixels, 0 at top              0324-0327*/
 NvS32 Triangle32Point1X;       /* in pixels, 0 at left             0328-032b*/
 NvS32 Triangle32Point1Y;       /* in pixels, 0 at top              032c-032f*/
 NvS32 Triangle32Point2X;       /* in pixels, 0 at left             0330-0333*/
 NvS32 Triangle32Point2Y;       /* in pixels, 0 at top              0334-0337*/
 NvV32 Reserved04[0x032];
 NvV32 Trimesh[32];             /* y_x S16_S16 in pixels            0400-047f*/
 struct {                       /* start aliased methods in array   0480-    */
  NvS32 x;                      /* in pixels, 0 at left                0-   3*/
  NvS32 y;                      /* in pixels, 0 at top                 4-   7*/
 } Trimesh32[16];               /* end of aliased methods in array      -04ff*/
 struct {                       /* start aliased methods in array   0500-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point0;                 /* y_x S16_S16 in pixels               4-   7*/
  NvV32 point1;                 /* y_x S16_S16 in pixels               8-   b*/
  NvV32 point2;                 /* y_x S16_S16 in pixels               c-   f*/
 } ColorTriangle[8];            /* end of aliased methods in array      -057f*/
 struct {                       /* start aliased methods in array   0580-    */
  NvV32 color;                  /* source color                        0-   3*/
  NvV32 point;                  /* y_x S16_S16 in pixels               4-   7*/
 } ColorTrimesh[16];            /* end of aliased methods in array      -05ff*/
 NvV32 Reserved05[0x680];
} Nv05dTypedef, Nv04RenderSolidTriangle;
#define NV05D_TYPEDEF                                   Nv04RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV05D_SET_OBJECT                                           (0x00000000)
#define NV05D_NO_OPERATION                                         (0x00000100)
#define NV05D_NOTIFY                                               (0x00000104)
#define NV05D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05D_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05D_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05D_SET_OPERATION                                        (0x000002FC)
#define NV05D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05D_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05D_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05D_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05D_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05D_COLOR                                                (0x00000304)
#define NV05D_TRIANGLE                                             (0x00000310)
#define NV05D_TRIANGLE_POINT0                                      (0x00000310)
#define NV05D_TRIANGLE_POINT0_X                                    15:0
#define NV05D_TRIANGLE_POINT0_Y                                    31:16
#define NV05D_TRIANGLE_POINT1                                      (0x00000314)
#define NV05D_TRIANGLE_POINT1_X                                    15:0
#define NV05D_TRIANGLE_POINT1_Y                                    31:16
#define NV05D_TRIANGLE_POINT2                                      (0x00000318)
#define NV05D_TRIANGLE_POINT2_X                                    15:0
#define NV05D_TRIANGLE_POINT2_Y                                    31:16
#define NV05D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV05D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV05D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV05D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV05D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV05D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV05D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV05D_TRIMESH_X                                            15:0
#define NV05D_TRIMESH_Y                                            31:16
#define NV05D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV05D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT_X                                15:0
#define NV05D_COLOR_TRIMESH_POINT_Y                                31:16
/* obsolete stuff */
#define NV4_RENDER_SOLID_TRIANGLE                                  (0x0000005D)
#define Nv4RenderSolidTriangle                          Nv04RenderSolidTriangle
#define nv4RenderSolidTriangle                          Nv04RenderSolidTriangle
#define nv04RenderSolidTriangle                         Nv04RenderSolidTriangle


/* class NV04_RENDER_SOLID_RECTANGLE */
#define  NV04_RENDER_SOLID_RECTANGLE                               (0x0000005E)
/* NvNotification[] elements */
#define NV05E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV05E_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV05E_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Color;                   /* source color                     0304-0307*/
 NvV32 Reserved02[0x03e];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 point;                  /* y_x S16_S16                         0-   3*/
  NvV32 size;                   /* height_width U16_U16                4-   7*/
 } Rectangle[16];               /* end of aliased methods in array      -047f*/
 NvV32 Reserved03[0x6e0];
} Nv05eTypedef, Nv04RenderSolidRectangle;
#define NV05E_TYPEDEF                                  Nv04RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV05E_SET_OBJECT                                           (0x00000000)
#define NV05E_NO_OPERATION                                         (0x00000100)
#define NV05E_NOTIFY                                               (0x00000104)
#define NV05E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05E_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05E_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05E_SET_OPERATION                                        (0x000002FC)
#define NV05E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05E_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05E_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05E_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05E_COLOR                                                (0x00000304)
#define NV05E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT_X                                    15:0
#define NV05E_RECTANGLE_POINT_Y                                    31:16
#define NV05E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV05E_RECTANGLE_SIZE_HEIGHT                                31:16
/* obsolete stuff */
#define NV4_RENDER_SOLID_RECTANGLE                                 (0x0000005E)
#define Nv4RenderSolidRectangle                        Nv04RenderSolidRectangle
#define nv4RenderSolidRectangle                        Nv04RenderSolidRectangle
#define nv04RenderSolidRectangle                       Nv04RenderSolidRectangle


/* class NV04_IMAGE_BLIT */
#define  NV04_IMAGE_BLIT                                           (0x0000005F)
/* NvNotification[] elements */
#define NV05F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV05F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x057];
 NvV32 SetOperation;            /* NV05F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved02[0x73d];
} Nv05fTypedef, Nv04ImageBlit;
#define NV05F_TYPEDEF                                             Nv04ImageBlit
/* dma method offsets, fields, and values */
#define NV05F_SET_OBJECT                                           (0x00000000)
#define NV05F_NO_OPERATION                                         (0x00000100)
#define NV05F_NOTIFY                                               (0x00000104)
#define NV05F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV05F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV05F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV05F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV05F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV05F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV05F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV05F_SET_OPERATION                                        (0x000002FC)
#define NV05F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05F_CONTROL_POINT_IN                                     (0x00000300)
#define NV05F_CONTROL_POINT_IN_X                                   15:0
#define NV05F_CONTROL_POINT_IN_Y                                   31:16
#define NV05F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV05F_CONTROL_POINT_OUT_X                                  15:0
#define NV05F_CONTROL_POINT_OUT_Y                                  31:16
#define NV05F_SIZE                                                 (0x00000308)
#define NV05F_SIZE_WIDTH                                           15:0
#define NV05F_SIZE_HEIGHT                                          31:16
/* obsolete stuff */
#define NV4_IMAGE_BLIT                                             (0x0000005F)
#define Nv4ImageBlit                                              Nv04ImageBlit
#define nv4ImageBlit                                              Nv04ImageBlit
#define nv04ImageBlit                                             Nv04ImageBlit


/* class NV04_INDEXED_IMAGE_FROM_CPU */
#define  NV04_INDEXED_IMAGE_FROM_CPU                               (0x00000060)
/* NvNotification[] elements */
#define NV060_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV060_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV060_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV060_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV060_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV060_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV060_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0188-018b*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      018c-018f*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0190-0193*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0194-0197*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                019c-019f*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 01a0-01a3*/
 NvV32 Reserved01[0x08F];
 NvV32 SetColorConversion;      /* NV060_SET_COLOR_CONVERSION_*     03e0-03e3*/
 NvV32 SetOperation;            /* NV060_SET_OPERATION_*            03e4-03e7*/
 NvV32 SetColorFormat;          /* NV060_SET_COLOR_FORMAT_*         03e8-03eb*/
 NvV32 IndexFormat;             /* NV060_INDEX_FORMAT_*             03ec-03ef*/
 NvU32 LutOffset;               /* offset in bytes                  03f0-03f3*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            03f4-03f7*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     03f8-03fb*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     03fc-03ff*/
 NvV32 Indices[1792];           /* source indices (packed texels)   0400-1fff*/
} Nv060Typedef, Nv04IndexedImageFromCpu;
#define NV060_TYPEDEF                                   Nv04IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV060_SET_OBJECT                                           (0x00000000)
#define NV060_NO_OPERATION                                         (0x00000100)
#define NV060_NOTIFY                                               (0x00000104)
#define NV060_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV060_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV060_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV060_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV060_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV060_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV060_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV060_SET_CONTEXT_ROP                                      (0x00000194)
#define NV060_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV060_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV060_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV060_SET_COLOR_CONVERSION                                 (0x000003E0)
#define NV060_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV060_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV060_SET_OPERATION                                        (0x000003E4)
#define NV060_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV060_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV060_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV060_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV060_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV060_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV060_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV060_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV060_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV060_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV060_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV060_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV060_INDEX_FORMAT                                         (0x000003EC)
#define NV060_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV060_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV060_LUT_OFFSET                                           (0x000003F0)
#define NV060_POINT                                                (0x000003F4)
#define NV060_POINT_X                                              15:0
#define NV060_POINT_Y                                              31:16
#define NV060_SIZE_OUT                                             (0x000003F8)
#define NV060_SIZE_OUT_WIDTH                                       15:0
#define NV060_SIZE_OUT_HEIGHT                                      31:16
#define NV060_SIZE_IN                                              (0x000003FC)
#define NV060_SIZE_IN_WIDTH                                        15:0
#define NV060_SIZE_IN_HEIGHT                                       31:16
#define NV060_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV4_INDEXED_IMAGE_FROM_CPU                                 (0x00000060)
#define Nv4IndexedImageFromCpu                          Nv04IndexedImageFromCpu
#define nv4IndexedImageFromCpu                          Nv04IndexedImageFromCpu
#define nv04IndexedImageFromCpu                         Nv04IndexedImageFromCpu


/* class NV04_IMAGE_FROM_CPU */
#define  NV04_IMAGE_FROM_CPU                                       (0x00000061)
/* NvNotification[] elements */
#define NV061_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV061_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV061_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV061_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV061_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV061_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV061_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x057];
 NvV32 SetOperation;            /* NV061_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV061_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv061Typedef, Nv04ImageFromCpu;
#define NV061_TYPEDEF                                          Nv04ImageFromCpu
/* dma method offsets, fields, and values */
#define NV061_SET_OBJECT                                           (0x00000000)
#define NV061_NO_OPERATION                                         (0x00000100)
#define NV061_NOTIFY                                               (0x00000104)
#define NV061_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV061_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV061_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV061_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV061_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV061_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV061_SET_CONTEXT_ROP                                      (0x00000190)
#define NV061_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV061_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV061_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV061_SET_OPERATION                                        (0x000002FC)
#define NV061_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV061_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV061_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV061_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV061_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV061_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV061_SET_COLOR_FORMAT                                     (0x00000300)
#define NV061_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV061_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV061_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV061_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV061_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV061_POINT                                                (0x00000304)
#define NV061_POINT_X                                              15:0
#define NV061_POINT_Y                                              31:16
#define NV061_SIZE_OUT                                             (0x00000308)
#define NV061_SIZE_OUT_WIDTH                                       15:0
#define NV061_SIZE_OUT_HEIGHT                                      31:16
#define NV061_SIZE_IN                                              (0x0000030C)
#define NV061_SIZE_IN_WIDTH                                        15:0
#define NV061_SIZE_IN_HEIGHT                                       31:16
#define NV061_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV4_IMAGE_FROM_CPU                                         (0x00000061)
#define Nv4ImageFromCpu                                        Nv04ImageFromCpu
#define nv4ImageFromCpu                                        Nv04ImageFromCpu
#define nv04ImageFromCpu                                       Nv04ImageFromCpu


/* class NV10_CONTEXT_SURFACES_2D */
#define  NV10_CONTEXT_SURFACES_2D                                  (0x00000062)
/* NvNotification[] elements */
#define NV062_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV062_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV062_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV062_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV062_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV062_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV062_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV062_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImageSource;/* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageDestin;/* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05d];
 NvV32 SetColorFormat;          /* NV062_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetPitch;                /* destin_source U16_U16            0304-0307*/
 NvU32 SetOffsetSource;         /* byte offset of top-left pixel    0308-030b*/
 NvU32 SetOffsetDestin;         /* byte offset of top-left pixel    030c-030f*/
 NvV32 Reserved02[0x73c];
} Nv062Typedef, Nv10ContextSurfaces2d;
#define NV062_TYPEDEF                                     Nv10ContextSurfaces2d
/* dma method offsets, fields, and values */
#define NV062_SET_OBJECT                                           (0x00000000)
#define NV062_NO_OPERATION                                         (0x00000100)
#define NV062_NOTIFY                                               (0x00000104)
#define NV062_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV062_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV062_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV062_SET_CONTEXT_DMA_IMAGE_SOURCE                         (0x00000184)
#define NV062_SET_CONTEXT_DMA_IMAGE_DESTIN                         (0x00000188)
#define NV062_SET_COLOR_FORMAT                                     (0x00000300)
#define NV062_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV062_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV062_SET_COLOR_FORMAT_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV062_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000004)
#define NV062_SET_COLOR_FORMAT_LE_Y16                              (0x00000005)
#define NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV062_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV062_SET_COLOR_FORMAT_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV062_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x0000000A)
#define NV062_SET_COLOR_FORMAT_LE_Y32                              (0x0000000B)
#define NV062_SET_PITCH                                            (0x00000304)
#define NV062_SET_PITCH_SOURCE                                     15:0
#define NV062_SET_PITCH_DESTIN                                     31:16
#define NV062_SET_OFFSET_SOURCE                                    (0x00000308)
#define NV062_SET_OFFSET_DESTIN                                    (0x0000030C)


/* class NV05_SCALED_IMAGE_FROM_MEMORY */
#define  NV05_SCALED_IMAGE_FROM_MEMORY                             (0x00000063)
/* NvNotification[] elements */
#define NV063_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV063_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV063_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV063_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV063_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV063_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV063_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV063_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetColorConversion;      /* NV063_SET_COLOR_CONVERSION_*     02fc-02ff*/
 NvV32 SetColorFormat;          /* NV063_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV063_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv063Typedef, Nv05ScaledImageFromMemory;
#define NV063_TYPEDEF                                 Nv05ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV063_SET_OBJECT                                           (0x00000000)
#define NV063_NO_OPERATION                                         (0x00000100)
#define NV063_NOTIFY                                               (0x00000104)
#define NV063_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV063_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV063_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV063_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV063_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV063_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV063_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV063_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV063_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV063_SET_COLOR_CONVERSION                                 (0x000002fc)
#define NV063_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV063_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV063_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV063_SET_COLOR_FORMAT                                     (0x00000300)
#define NV063_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV063_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV063_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV063_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV063_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV063_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV063_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV063_SET_OPERATION                                        (0x00000304)
#define NV063_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV063_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV063_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV063_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV063_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV063_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV063_CLIP_POINT                                           (0x00000308)
#define NV063_CLIP_POINT_X                                         15:0
#define NV063_CLIP_POINT_Y                                         31:16
#define NV063_CLIP_SIZE                                            (0x0000030C)
#define NV063_CLIP_SIZE_WIDTH                                      15:0
#define NV063_CLIP_SIZE_HEIGHT                                     31:16
#define NV063_IMAGE_OUT_POINT                                      (0x00000310)
#define NV063_IMAGE_OUT_POINT_X                                    15:0
#define NV063_IMAGE_OUT_POINT_Y                                    31:16
#define NV063_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV063_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV063_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV063_DS_DX                                                (0x00000318)
#define NV063_DT_DY                                                (0x0000031C)
#define NV063_IMAGE_IN_SIZE                                        (0x00000400)
#define NV063_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV063_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV063_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV063_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV063_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV063_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV063_IMAGE_IN                                             (0x0000040C)
#define NV063_IMAGE_IN_POINT_U                                     15:0
#define NV063_IMAGE_IN_POINT_V                                     31:16


/* class NV05_INDEXED_IMAGE_FROM_CPU */
#define  NV05_INDEXED_IMAGE_FROM_CPU                               (0x00000064)
/* NvNotification[] elements */
#define NV064_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV064_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV064_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV064_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV064_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV064_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV064_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0188-018b*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      018c-018f*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0190-0193*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0194-0197*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                019c-019f*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 01a0-01a3*/
 NvV32 Reserved01[0x08f];
 NvV32 SetColorConversion;      /* NV064_SET_COLOR_CONVERSION_*     03e0-03e3*/
 NvV32 SetOperation;            /* NV064_SET_OPERATION_*            03e4-03e7*/
 NvV32 SetColorFormat;          /* NV064_SET_COLOR_FORMAT_*         03e8-03eb*/
 NvV32 IndexFormat;             /* NV064_INDEX_FORMAT_*             03ec-03ef*/
 NvU32 LutOffset;               /* offset in bytes                  03f0-03f3*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            03f4-03f7*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     03f8-03fb*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     03fc-03ff*/
 NvV32 Indices[1792];           /* source indices (packed texels)   0400-1fff*/
} Nv064Typedef, Nv05IndexedImageFromCpu;
#define NV064_TYPEDEF                                   Nv05IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV064_SET_OBJECT                                           (0x00000000)
#define NV064_NO_OPERATION                                         (0x00000100)
#define NV064_NOTIFY                                               (0x00000104)
#define NV064_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV064_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV064_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV064_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV064_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV064_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV064_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV064_SET_CONTEXT_ROP                                      (0x00000194)
#define NV064_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV064_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV064_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV064_SET_COLOR_CONVERSION                                 (0x000003E0)
#define NV064_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV064_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV064_SET_OPERATION                                        (0x000003E4)
#define NV064_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV064_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV064_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV064_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV064_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV064_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV064_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV064_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV064_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV064_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV064_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV064_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV064_INDEX_FORMAT                                         (0x000003EC)
#define NV064_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV064_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV064_LUT_OFFSET                                           (0x000003F0)
#define NV064_POINT                                                (0x000003F4)
#define NV064_POINT_X                                              15:0
#define NV064_POINT_Y                                              31:16
#define NV064_SIZE_OUT                                             (0x000003F8)
#define NV064_SIZE_OUT_WIDTH                                       15:0
#define NV064_SIZE_OUT_HEIGHT                                      31:16
#define NV064_SIZE_IN                                              (0x000003FC)
#define NV064_SIZE_IN_WIDTH                                        15:0
#define NV064_SIZE_IN_HEIGHT                                       31:16
#define NV064_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)


/* class NV05_IMAGE_FROM_CPU */
#define  NV05_IMAGE_FROM_CPU                                       (0x00000065)
/* NvNotification[] elements */
#define NV065_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV065_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV065_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV065_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV065_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV065_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV065_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x056];
 NvV32 SetColorConversion;      /* NV065_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV065_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV065_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv065Typedef, Nv05ImageFromCpu;
#define NV065_TYPEDEF                                          Nv05ImageFromCpu
/* dma method offsets, fields, and values */
#define NV065_SET_OBJECT                                           (0x00000000)
#define NV065_NO_OPERATION                                         (0x00000100)
#define NV065_NOTIFY                                               (0x00000104)
#define NV065_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV065_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV065_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV065_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV065_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV065_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV065_SET_CONTEXT_ROP                                      (0x00000190)
#define NV065_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV065_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV065_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV065_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV065_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV065_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV065_SET_OPERATION                                        (0x000002FC)
#define NV065_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV065_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV065_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV065_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV065_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV065_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV065_SET_COLOR_FORMAT                                     (0x00000300)
#define NV065_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV065_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV065_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV065_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV065_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV065_POINT                                                (0x00000304)
#define NV065_POINT_X                                              15:0
#define NV065_POINT_Y                                              31:16
#define NV065_SIZE_OUT                                             (0x00000308)
#define NV065_SIZE_OUT_WIDTH                                       15:0
#define NV065_SIZE_OUT_HEIGHT                                      31:16
#define NV065_SIZE_IN                                              (0x0000030C)
#define NV065_SIZE_IN_WIDTH                                        15:0
#define NV065_SIZE_IN_HEIGHT                                       31:16
#define NV065_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


 /* class NV05_STRETCHED_IMAGE_FROM_CPU */
#define  NV05_STRETCHED_IMAGE_FROM_CPU                             (0x00000066)
/* NvNotification[] elements */
#define NV066_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV066_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV066_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV066_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV066_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV066_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct _Nv066Typedef{
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV066_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetColorConversion;      /* NV066_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV066_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV066_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DxDs;                    /* S12d20 dx/ds                     0308-030b*/
 NvV32 DyDt;                    /* S12d20 dy/dt                     030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv066Typedef, Nv05StretchedImageFromCpu;
#define NV066_TYPEDEF                                 Nv05StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV066_SET_OBJECT                                           (0x00000000)
#define NV066_NO_OPERATION                                         (0x00000100)
#define NV066_NOTIFY                                               (0x00000104)
#define NV066_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV066_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV066_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV066_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV066_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV066_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV066_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV066_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV066_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV066_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV066_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV066_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV066_SET_OPERATION                                        (0x000002FC)
#define NV066_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV066_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV066_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV066_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV066_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV066_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV066_SET_COLOR_FORMAT                                     (0x00000300)
#define NV066_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV066_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV066_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV066_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV066_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV066_SIZE_IN                                              (0x00000304)
#define NV066_SIZE_IN_WIDTH                                        15:0
#define NV066_SIZE_IN_HEIGHT                                       31:16
#define NV066_DX_DS                                                (0x00000308)
#define NV066_DY_DT                                                (0x0000030C)
#define NV066_CLIP_POINT                                           (0x00000310)
#define NV066_CLIP_POINT_X                                         15:0
#define NV066_CLIP_POINT_Y                                         31:16
#define NV066_CLIP_SIZE                                            (0x00000314)
#define NV066_CLIP_SIZE_WIDTH                                      15:0
#define NV066_CLIP_SIZE_HEIGHT                                     31:16
#define NV066_POINT_12D4                                           (0x00000318)
#define NV066_POINT_12D4_X                                         15:0
#define NV066_POINT_12D4_Y                                         31:16
#define NV066_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV10_VIDEO_LUT_CURSOR_DAC */
#define  NV10_VIDEO_LUT_CURSOR_DAC                                 (0x00000067)
/* NvNotification[] elements */
#define NV067_NOTIFIERS_NOTIFY                                     (0)
#define NV067_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV067_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV067_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV067_NOTIFIERS_SET_DAC(b)                                 (7+(b))
/* NvNotification[] fields and values */
#define NV067_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV067_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV067_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV067_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV067_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV067_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV067_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV067_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV067_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV067_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV067_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 GetOffset;               /* NV067_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* see text                            4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify_color_height_width           4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalBlank;        /* width_start U16_U16 in pixels       4-   7*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       8-   b*/
  NvV32 verticalBlank;          /* width_start U16_U16 in pixels       c-   f*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels      10-  13*/
  NvV32 totalSize;              /* height_width U16_U16               14-  17*/
  NvV32 pixelClock;             /* in Hertz                           18-  1b*/
  NvV32 format;                 /* see text                           1c-  1f*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x720];
} Nv067Typedef, Nv10VideoLutCursorDac;
#define NV067_TYPEDEF                                     Nv10VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV067_SET_OBJECT                                           (0x00000000)
#define NV067_NO_OPERATION                                         (0x00000100)
#define NV067_NOTIFY                                               (0x00000104)
#define NV067_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV067_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV067_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV067_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV067_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV067_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV067_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV067_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV067_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV067_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV067_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV067_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV067_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV067_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV067_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV067_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV067_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV067_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV067_SET_PAN_OFFSET                                       (0x00000220)
#define NV067_GET_OFFSET                                           (0x000002FC)
#define NV067_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV067_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV067_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV067_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV067_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV067_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV067_SET_IMAGE_FORMAT_WHEN                                30:20
#define NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER              (0x00000000)
#define NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY                    (0x00000001)
#define NV067_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV067_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV067_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV067_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV067_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV067_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV067_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV067_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV067_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH                        7:0
#define NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT                       15:8
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR                        30:16
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5          (0x00000000)
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5            (0x00000001)
#define NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8            (0x00000002)
#define NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY                       31:31
#define NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV067_SET_CURSOR_POINT                                     (0x00000330)
#define NV067_SET_CURSOR_POINT_X                                   15:0
#define NV067_SET_CURSOR_POINT_Y                                   31:16
#define NV067_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV067_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV067_SET_DAC_HORIZONTAL_BLANK(b)                          (0x00000344\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_HORIZONTAL_BLANK_START                       15:0
#define NV067_SET_DAC_HORIZONTAL_BLANK_WIDTH                       31:16
#define NV067_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000348\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV067_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV067_SET_DAC_VERTICAL_BLANK(b)                            (0x0000034c\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_VERTICAL_BLANK_START                         15:0
#define NV067_SET_DAC_VERTICAL_BLANK_WIDTH                         31:16
#define NV067_SET_DAC_VERTICAL_SYNC(b)                             (0x00000350\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV067_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV067_SET_DAC_TOTAL_SIZE(b)                                (0x00000354\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV067_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV067_SET_DAC_PIXEL_CLOCK(b)                               (0x00000358\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_FORMAT(b)                                    (0x0000035c\
                                                                   +(b)*0x0020)
#define NV067_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV067_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV067_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV067_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV067_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV067_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV067_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV067_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV067_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV067_SET_DAC_FORMAT_COLOR                                 19:16
#define NV067_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV067_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV067_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV067_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV067_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV067_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV067_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV067_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV067_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV067_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV067_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)

// Added by Chuck Moidel
/* class NV04_HEAP_OWNER */
#define NV04_HEAP_OWNER                                            (0x0000006F)
/* NvNotification[] fields and values */
#define NV06F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06fTypedef, Nv04HeapOwner;
#define NV06F_TYPEDEF                                              Nv04HeapOwner
#define Nv06FTypedef                                               Nv04HeapOwner

typedef NvV32 Nv070Typedef;

typedef NvV32 Nv071Typedef;


/* class NV04_CONTEXT_BETA */
#define  NV04_CONTEXT_BETA                                         (0x00000072)
/* NvNotification[] elements */
#define NV072_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV072_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV072_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV072_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV072_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV072_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV072_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV072_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved01[0x05f];
 NvV32 SetBetaFactor;           /* A8R8G8B8 beta values             0300-0303*/
 NvV32 Reserved02[0x73f];
} Nv072Typedef, Nv04ContextBeta;
#define NV072_TYPEDEF                                           Nv04ContextBeta
/* dma method offsets, fields, and values */
#define NV072_SET_OBJECT                                           (0x00000000)
#define NV072_NO_OPERATION                                         (0x00000100)
#define NV072_NOTIFY                                               (0x00000104)
#define NV072_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV072_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV072_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV072_SET_BETA_FACTOR                                      (0x00000300)
#define NV072_SET_BETA_FACTOR_BLUE                                 7:0
#define NV072_SET_BETA_FACTOR_GREEN                                15:8
#define NV072_SET_BETA_FACTOR_RED                                  23:16
#define NV072_SET_BETA_FACTOR_ALPHA                                31:24
/* obsolete stuff */
#define NV4_CONTEXT_BETA                                           (0x00000072)
#define Nv4ContextBeta                                          Nv04ContextBeta
#define nv4ContextBeta                                          Nv04ContextBeta
#define nv04ContextBeta                                         Nv04ContextBeta

typedef NvV32 Nv073Typedef;

typedef NvV32 Nv074Typedef;

typedef NvV32 Nv075Typedef;


/* class NV04_STRETCHED_IMAGE_FROM_CPU */
#define  NV04_STRETCHED_IMAGE_FROM_CPU                             (0x00000076)
/* NvNotification[] elements */
#define NV076_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV076_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV076_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV076_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV076_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV076_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV076_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetOperation;            /* NV076_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV076_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DeltaDxDu;               /* S12d20 ratio dx/du               0308-030b*/
 NvV32 DeltaDyDv;               /* S12d20 ratio dy/dv               030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv076Typedef, Nv04StretchedImageFromCpu;
#define NV076_TYPEDEF                                 Nv04StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV076_SET_OBJECT                                           (0x00000000)
#define NV076_NO_OPERATION                                         (0x00000100)
#define NV076_NOTIFY                                               (0x00000104)
#define NV076_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV076_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV076_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV076_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV076_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV076_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV076_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV076_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV076_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV076_SET_OPERATION                                        (0x000002FC)
#define NV076_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV076_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV076_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV076_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV076_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV076_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV076_SET_COLOR_FORMAT                                     (0x00000300)
#define NV076_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV076_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV076_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV076_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV076_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV076_SIZE_IN                                              (0x00000304)
#define NV076_SIZE_IN_WIDTH                                        15:0
#define NV076_SIZE_IN_HEIGHT                                       31:16
#define NV076_DELTA_DX_DU                                          (0x00000308)
#define NV076_DELTA_DY_DV                                          (0x0000030C)
#define NV076_CLIP_POINT                                           (0x00000310)
#define NV076_CLIP_POINT_X                                         15:0
#define NV076_CLIP_POINT_Y                                         31:16
#define NV076_CLIP_SIZE                                            (0x00000314)
#define NV076_CLIP_SIZE_WIDTH                                      15:0
#define NV076_CLIP_SIZE_HEIGHT                                     31:16
#define NV076_POINT_12D4                                           (0x00000318)
#define NV076_POINT_12D4_X                                         15:0
#define NV076_POINT_12D4_Y                                         31:16
#define NV076_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
/* obsolete stuff */
#define NV4_STRETCHED_IMAGE_FROM_CPU                               (0x00000076)
#define Nv4StretchedImageFromCpu                      Nv04StretchedImageFromCpu
#define nv4StretchedImageFromCpu                      Nv04StretchedImageFromCpu
#define nv04StretchedImageFromCpu                     Nv04StretchedImageFromCpu


/* class NV04_SCALED_IMAGE_FROM_MEMORY */
#define  NV04_SCALED_IMAGE_FROM_MEMORY                             (0x00000077)
/* NvNotification[] elements */
#define NV077_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV077_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV077_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV077_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV077_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV077_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV077_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x059];
 NvV32 SetColorFormat;          /* NV077_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV077_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DeltaDuDx;               /* S12d20 ratio du/dx               0318-031b*/
 NvV32 DeltaDvDy;               /* S12d20 ratio dv/dy               031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvU32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv077Typedef, Nv04ScaledImageFromMemory;
#define NV077_TYPEDEF                                 Nv04ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV077_SET_OBJECT                                           (0x00000000)
#define NV077_NO_OPERATION                                         (0x00000100)
#define NV077_NOTIFY                                               (0x00000104)
#define NV077_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV077_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV077_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV077_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV077_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV077_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV077_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV077_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV077_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV077_SET_COLOR_FORMAT                                     (0x00000300)
#define NV077_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV077_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV077_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV077_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV077_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV077_SET_OPERATION                                        (0x00000304)
#define NV077_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV077_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV077_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV077_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV077_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV077_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV077_CLIP_POINT                                           (0x00000308)
#define NV077_CLIP_POINT_X                                         15:0
#define NV077_CLIP_POINT_Y                                         31:16
#define NV077_CLIP_SIZE                                            (0x0000030C)
#define NV077_CLIP_SIZE_WIDTH                                      15:0
#define NV077_CLIP_SIZE_HEIGHT                                     31:16
#define NV077_IMAGE_OUT_POINT                                      (0x00000310)
#define NV077_IMAGE_OUT_POINT_X                                    15:0
#define NV077_IMAGE_OUT_POINT_Y                                    31:16
#define NV077_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV077_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV077_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV077_DELTA_DU_DX                                          (0x00000318)
#define NV077_DELTA_DV_DY                                          (0x0000031C)
#define NV077_IMAGE_IN_SIZE                                        (0x00000400)
#define NV077_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV077_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV077_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV077_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV077_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV077_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV077_IMAGE_IN                                             (0x0000040C)
#define NV077_IMAGE_IN_POINT_U                                     15:0
#define NV077_IMAGE_IN_POINT_V                                     31:16
/* obsolete stuff */
#define NV4_SCALED_IMAGE_FROM_MEMORY                               (0x00000077)
#define Nv4ScaledImageFromMemory                      Nv04ScaledImageFromMemory
#define nv4ScaledImageFromMemory                      Nv04ScaledImageFromMemory
#define nv04ScaledImageFromMemory                     Nv04ScaledImageFromMemory

typedef NvV32 Nv078Typedef;

typedef NvV32 Nv079Typedef;

/* class NV10_VIDEO_OVERLAY */
#define  NV10_VIDEO_OVERLAY                                        (0x0000007A)
/* NvNotification[] elements */
#define NV07A_NOTIFIERS_NOTIFY                                     (0)
#define NV07A_NOTIFIERS_SET_OVERLAY(b)                             (1+(b))
/* NvNotification[] fields and values */
#define NV07A_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV07A_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV07A_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV07A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV07A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV07A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV07A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV07A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 StopOverlay[2];          /* NV07A_STOP_OVERLAY_*             0120-0127*/
 NvV32 Reserved01[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 Reserved02[0x006];
 NvV32 SetContextDmaOverlay[2]; /* NV01_CONTEXT_DMA                 019c-01a3*/
 NvV32 Reserved03[0x097];
 struct {                       /* start of methods in array        0400-    */
  NvV32 reserved05[0x015];      /* see text                           00-  53*/
  NvV32 luminance;              /* brightness_contrast S16_U8d8       54-  57*/
  NvV32 chrominance;            /* saturationSine_saturationCosine    58-  5b*/
  NvV32 colorKey;               /* see text                           5c-  5f*/
  NvU32 offset;                 /* byte offset of top-left texel      60-  63*/
  NvV32 sizeIn;                 /* height_width U16_U16               64-  67*/
  NvV32 pointIn;                /* t_s U12d4_U12d4                    68-  6b*/
  NvV32 duDx;                   /* U12d20 du/dx                       6c-  6f*/
  NvV32 dvDy;                   /* U12d20 dv/dy                       70-  73*/
  NvV32 pointOut;               /* y_x U16_U16                        74-  77*/
  NvV32 sizeOut;                /* height_width U16_U16               78-  7b*/
  NvV32 format;                 /* see text                           7c-  7f*/
 } SetOverlay[2];               /* end of methods in array              -04ff*/
 NvV32 SetOverlayPointOutA;     /* y_x U16_U16                      0500-0503*/
 NvV32 SetOverlayLuminanceA;    /* brightness_contrast S16_U8d8     0504-0507*/
 NvV32 SetOverlayChrominanceA;  /* saturationSine_saturationCosine  0508-050b*/
 NvV32 Reserved04[0x6bd];
} Nv07aTypedef, Nv10VideoOverlay;
#define NV07A_TYPEDEF                                          Nv10VideoOverlay
/* dma method offsets, fields, and values */
#define NV07A_SET_OBJECT                                           (0x00000000)
#define NV07A_NO_OPERATION                                         (0x00000100)
#define NV07A_NOTIFY                                               (0x00000104)
#define NV07A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV07A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV07A_STOP_OVERLAY(b)                                      (0x00000120\
                                                                   +(b)*0x0004)
#define NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE                     (0x00000000)
#define NV07A_STOP_OVERLAY_BETWEEN_BUFFERS                         (0x00000001)
#define NV07A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV07A_SET_CONTEXT_DMA_OVERLAY(b)                           (0x0000019C\
                                                                   +(b)*0x0004)
#define NV07A_SET_OVERLAY(b)                                       (0x00000400\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_LUMINANCE(b)                             (0x00000454\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_LUMINANCE_CONTRAST                       15:0
#define NV07A_SET_OVERLAY_LUMINANCE_BRIGHTNESS                     31:16
#define NV07A_SET_OVERLAY_CHROMINANCE(b)                           (0x00000458\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_CHROMINANCE_SATURATION_COSINE            15:0
#define NV07A_SET_OVERLAY_CHROMINANCE_SATURATION_SINE              31:16
#define NV07A_SET_OVERLAY_COLORKEY(b)                              (0x0000045C\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_OFFSET(b)                                (0x00000460\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_SIZE_IN(b)                               (0x00000464\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_SIZE_IN_WIDTH                            15:0
#define NV07A_SET_OVERLAY_SIZE_IN_HEIGHT                           31:16
#define NV07A_SET_OVERLAY_POINT_IN(b)                              (0x00000468\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_POINT_IN_S                               15:0
#define NV07A_SET_OVERLAY_POINT_IN_T                               31:16
#define NV07A_SET_OVERLAY_DU_DX(b)                                 (0x0000046C\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_DV_DY(b)                                 (0x00000470\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_POINT_OUT(b)                             (0x00000474\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_POINT_OUT_X                              15:0
#define NV07A_SET_OVERLAY_POINT_OUT_Y                              31:16
#define NV07A_SET_OVERLAY_SIZE_OUT(b)                              (0x00000478\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_SIZE_OUT_WIDTH                           15:0
#define NV07A_SET_OVERLAY_SIZE_OUT_HEIGHT                          31:16
#define NV07A_SET_OVERLAY_FORMAT(b)                                (0x0000047C\
                                                                   +(b)*0x0080)
#define NV07A_SET_OVERLAY_FORMAT_PITCH                             15:0
#define NV07A_SET_OVERLAY_FORMAT_COLOR                             19:16
#define NV07A_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8             (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8             (0x00000001)
#define NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH                23:20
#define NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_OVERLAY   (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE     (0x00000001)
#define NV07A_SET_OVERLAY_FORMAT_MATRIX                            30:24
#define NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT601                  (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709                  (0x00000001)
#define NV07A_SET_OVERLAY_FORMAT_NOTIFY                            31:31
#define NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY                 (0x00000000)
#define NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_THEN_AWAKEN          (0x00000001)
#define NV07A_SET_OVERLAY_POINT_OUT_A                              (0x00000500)
#define NV07A_SET_OVERLAY_POINT_OUT_A_X                            15:0
#define NV07A_SET_OVERLAY_POINT_OUT_A_Y                            31:16
#define NV07A_SET_OVERLAY_LUMINANCE_A                              (0x00000504)
#define NV07A_SET_OVERLAY_LUMINANCE_A_CONTRAST                     15:0
#define NV07A_SET_OVERLAY_LUMINANCE_A_BRIGHTNESS                   31:16
#define NV07A_SET_OVERLAY_CHROMINANCE_A                            (0x00000508)
#define NV07A_SET_OVERLAY_CHROMINANCE_A_SATURATION_COSINE          15:0
#define NV07A_SET_OVERLAY_CHROMINANCE_A_SATURATION_SIZE            31:16

/* class NV10_TEXTURE_FROM_CPU */
#define  NV10_TEXTURE_FROM_CPU                                     (0x0000007B)
/* NvNotification[] elements */
#define NV07B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV07B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV07B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV07B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV07B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV07B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV07B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV089_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetColorFormat;          /* NV07B_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 Size;                    /* height_width U16_U16, pixels     0308-030b*/
 NvV32 ClipHorizontal;          /* width_x U16_U16                  030c-030f*/
 NvV32 ClipVertical;            /* height_y U16_U16                 0310-0313*/
 NvV32 Reserved02[0x03b];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 a;                      /* source colors (packed texels)       0-   3*/
  NvV32 b;                      /* source colors (packed texels)       4-   7*/
 } Color[896];                  /* end of aliased methods in array      -1fff*/
} Nv07bTypedef, Nv10TextureFromCpu;
#define NV07B_TYPEDEF                                        Nv10TextureFromCpu
/* dma method offsets, fields, and values */
#define NV07B_SET_OBJECT                                           (0x00000000)
#define NV07B_NO_OPERATION                                         (0x00000100)
#define NV07B_NOTIFY                                               (0x00000104)
#define NV07B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV07B_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV07B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV07B_SET_CONTEXT_SURFACE                                  (0x00000184)
#define NV07B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV07B_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV07B_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV07B_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV07B_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV07B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV07B_POINT                                                (0x00000304)
#define NV07B_POINT_X                                              15:0
#define NV07B_POINT_Y                                              31:16
#define NV07B_SIZE                                                 (0x00000308)
#define NV07B_SIZE_WIDTH                                           15:0
#define NV07B_SIZE_HEIGHT                                          31:16
#define NV07B_CLIP_HORIZONTAL                                      (0x0000030C)
#define NV07B_CLIP_HORIZONTAL_X                                    15:0
#define NV07B_CLIP_HORIZONTAL_WIDTH                                31:16
#define NV07B_CLIP_VERTICAL                                        (0x00000310)
#define NV07B_CLIP_VERTICAL_Y                                      15:0
#define NV07B_CLIP_VERTICAL_HEIGHT                                 31:16
#define NV07B_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0008)
#define NV07B_COLOR_A(a)                                           (0x00000400\
                                                                   +(a)*0x0008)
#define NV07B_COLOR_B(a)                                           (0x00000404\
                                                                   +(a)*0x0008)
#define NV07B_COLOR__SIZE_1                                        896

/* class NV15_VIDEO_LUT_CURSOR_DAC */
#define  NV15_VIDEO_LUT_CURSOR_DAC                                 (0x0000007C)
/* NvNotification[] elements */
#define NV07C_NOTIFIERS_NOTIFY                                     (0)
#define NV07C_NOTIFIERS_GET_OFFSET                                 (0)
#define NV07C_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV07C_NOTIFIERS_SET_LUT(b)                                 (3+(b))
#define NV07C_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (5+(b))
#define NV07C_NOTIFIERS_SET_DAC(b)                                 (7+(b))
/* NvNotification[] fields and values */
#define NV07C_NOTIFICATION_INFO16_NOT_STARTED                      (0x0000)
#define NV07C_NOTIFICATION_INFO16_VALID_OFFSET                     (0x0001)
#define NV07C_NOTIFICATION_INFO16_DONE                             (0x0002)
#define NV07C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV07C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV07C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV07C_NOTIFY_*                   0104-0107*/
 NvV32 StopImage[2];            /* NV07C_STOP_IMAGE_*               0108-010f*/
 NvV32 StopLut[2];              /* NV07C_STOP_LUT_*                 0110-0117*/
 NvV32 StopCursorImage[2];      /* NV07C_STOP_CURSOR_IMAGE_*        0118-011f*/
 NvV32 StopDac[2];              /* NV07C_STOP_DAC_*                 0120-0127*/
 NvV32 Reserved00[0x016];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaLut[2];     /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 SetContextDmaCursor[2];  /* NV01_CONTEXT_DMA                 0194-019b*/
 NvV32 SetContextDmaSemaphore;  /* NV01_CONTEXT_DMA                 019c-019f*/
 NvV32 SetPanOffset;            /* byte offset for panning          0220-0223*/
 NvV32 Reserved01[0x053];
 NvU32 SetSemaphoreOffset;      /* set semaphore offset             02f0-02f3*/
 NvU32 SetSemaphoreRelease;     /* set semaphore release value      02f4-02f7*/
 NvV32 SetOffsetRange;          /* NV07C_SET_OFFSET_RANGE_*         02f8-02fb*/
 NvV32 GetOffset;               /* NV07C_GET_OFFSET_*               02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* see text                            4-   7*/
 } SetImage[2];                 /* end of methods in array              -030f*/
 struct {                       /* start of methods in array        0310-    */
  NvU32 offset;                 /* byte offset of first byte           0-   3*/
  NvV32 format;                 /* notify                              4-   7*/
 } SetLut[2];                   /* end of methods in array              -031f*/
 struct {                       /* start of methods in array        0320-    */
  NvU32 offset;                 /* byte offset of top-left pixel       0-   3*/
  NvV32 format;                 /* notify_color_height_width           4-   7*/
 } SetCursorImage[2];           /* end of methods in array              -032f*/
 NvV32 SetCursorPoint;          /* y_x S16_S16                      0330-0333*/
 NvV32 Reserved03[0x003];
 struct {                       /* start of methods in array        0340-    */
  NvV32 imageSize;              /* height_width U16_U16 in pixels      0-   3*/
  NvV32 horizontalBlank;        /* width_start U16_U16 in pixels       4-   7*/
  NvV32 horizontalSync;         /* width_start U16_U16 in pixels       8-   b*/
  NvV32 verticalBlank;          /* width_start U16_U16 in pixels       c-   f*/
  NvV32 verticalSync;           /* width_start U16_U16 in pixels      10-  13*/
  NvV32 totalSize;              /* height_width U16_U16               14-  17*/
  NvV32 pixelClock;             /* in Hertz                           18-  1b*/
  NvV32 format;                 /* see text                           1c-  1f*/
 } SetDac[2];                   /* end of methods in array              -037f*/
 NvV32 Reserved04[0x720];
} Nv07cTypedef, Nv12VideoLutCursorDac;
#define NV07C_TYPEDEF                                     Nv12VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV07C_SET_OBJECT                                           (0x00000000)
#define NV07C_NO_OPERATION                                         (0x00000100)
#define NV07C_NOTIFY                                               (0x00000104)
#define NV07C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV07C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV07C_STOP_IMAGE(b)                                        (0x00000108\
                                                                   +(b)*0x0004)
#define NV07C_STOP_IMAGE_AS_SOON_AS_POSSIBLE                       (0x00000000)
#define NV07C_STOP_IMAGE_BETWEEN_BUFFERS                           (0x00000001)
#define NV07C_STOP_LUT(b)                                          (0x00000110\
                                                                   +(b)*0x0004)
#define NV07C_STOP_LUT_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV07C_STOP_LUT_BETWEEN_BUFFERS                             (0x00000001)
#define NV07C_STOP_CURSOR_IMAGE(b)                                 (0x00000118\
                                                                   +(b)*0x0004)
#define NV07C_STOP_CURSOR_IMAGE_AS_SOON_AS_POSSIBLE                (0x00000000)
#define NV07C_STOP_CURSOR_IMAGE_BETWEEN_BUFFERS                    (0x00000001)
#define NV07C_STOP_DAC(b)                                          (0x00000120\
                                                                   +(b)*0x0004)
#define NV07C_STOP_DAC_AS_SOON_AS_POSSIBLE                         (0x00000000)
#define NV07C_STOP_DAC_BETWEEN_BUFFERS                             (0x00000001)
#define NV07C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV07C_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV07C_SET_CONTEXT_DMA_LUT(b)                               (0x0000018C\
                                                                   +(b)*0x0004)
#define NV07C_SET_CONTEXT_DMA_CURSOR(b)                            (0x00000194\
                                                                   +(b)*0x0004)
#define NV07C_SET_CONTEXT_DMA_SEMAPHORE                            (0x0000019c)

#define NV07C_SET_PAN_OFFSET                                       (0x00000220)

#define NV07C_SET_SEMAPHORE_OFFSET                                 (0x000002f0)
#define NV07C_SET_SEMAPHORE_OFFSET_V                               31:0
#define NV07C_SET_SEMAPHORE_RELEASE                                (0x000002f4)
#define NV07C_SET_SEMAPHORE_RELEASE_V                              31:0

#define NV07C_SET_OFFSET_RANGE                                     (0x000002F8)
#define NV07C_SET_OFFSET_RANGE_START                               14:0
#define NV07C_SET_OFFSET_RANGE_STOP                                30:16
#define NV07C_SET_OFFSET_RANGE_POLARITY                            31:31
#define NV07C_SET_OFFSET_RANGE_POLARITY_IN_RANGE                   (0x00000000)
#define NV07C_SET_OFFSET_RANGE_POLARITY_OUT_RANGE                  (0x00000001)
#define NV07C_GET_OFFSET                                           (0x000002FC)
#define NV07C_GET_OFFSET_IMAGE_0                                   (0x00000000)
#define NV07C_GET_OFFSET_IMAGE_1                                   (0x00000001)
#define NV07C_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV07C_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV07C_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV07C_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV07C_SET_IMAGE_FORMAT_WHEN                                23:20
#define NV07C_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER              (0x00000000)
#define NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY                    (0x00000001)

#define NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC                      24:24
#define NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_DISABLED             (0x00000000)
#define NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_ENABLED              (0x00000001)
#define NV07C_SET_IMAGE_FORMAT_FLAGS                               27:25
#define NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP    (0x00000001)
#define NV07C_SET_IMAGE_FORMAT_NOTIFY                              31:31
#define NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV07C_SET_LUT(b)                                           (0x00000310\
                                                                   +(b)*0x0008)
#define NV07C_SET_LUT_OFFSET(b)                                    (0x00000310\
                                                                   +(b)*0x0008)
#define NV07C_SET_LUT_FORMAT(b)                                    (0x00000314\
                                                                   +(b)*0x0008)
#define NV07C_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV07C_SET_LUT_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV07C_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0008)
#define NV07C_SET_CURSOR_IMAGE_OFFSET(b)                           (0x00000320\
                                                                   +(b)*0x0008)
#define NV07C_SET_CURSOR_IMAGE_FORMAT(b)                           (0x00000324\
                                                                   +(b)*0x0008)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH                        7:0
#define NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT                       15:8
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR                        30:16
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5          (0x00000000)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5            (0x00000001)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8            (0x00000002)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8         (0x00000003)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY                       31:31
#define NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_ONLY            (0x00000000)
#define NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN     (0x00000001)
#define NV07C_SET_CURSOR_POINT                                     (0x00000330)
#define NV07C_SET_CURSOR_POINT_X                                   15:0
#define NV07C_SET_CURSOR_POINT_Y                                   31:16
#define NV07C_SET_DAC(b)                                           (0x00000340\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_IMAGE_SIZE(b)                                (0x00000340\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV07C_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV07C_SET_DAC_HORIZONTAL_BLANK(b)                          (0x00000344\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_HORIZONTAL_BLANK_START                       15:0
#define NV07C_SET_DAC_HORIZONTAL_BLANK_WIDTH                       31:16
#define NV07C_SET_DAC_HORIZONTAL_SYNC(b)                           (0x00000348\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV07C_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV07C_SET_DAC_VERTICAL_BLANK(b)                            (0x0000034c\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_VERTICAL_BLANK_START                         15:0
#define NV07C_SET_DAC_VERTICAL_BLANK_WIDTH                         31:16
#define NV07C_SET_DAC_VERTICAL_SYNC(b)                             (0x00000350\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV07C_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV07C_SET_DAC_TOTAL_SIZE(b)                                (0x00000354\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV07C_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV07C_SET_DAC_PIXEL_CLOCK(b)                               (0x00000358\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_FORMAT(b)                                    (0x0000035c\
                                                                   +(b)*0x0020)
#define NV07C_SET_DAC_FORMAT_DOUBLE_SCAN                           0:0
#define NV07C_SET_DAC_FORMAT_DOUBLE_SCAN_DISABLED                  (0x00000000)
#define NV07C_SET_DAC_FORMAT_DOUBLE_SCAN_ENABLED                   (0x00000001)
#define NV07C_SET_DAC_FORMAT_INTERLACE                             1:1
#define NV07C_SET_DAC_FORMAT_INTERLACE_DISABLED                    (0x00000000)
#define NV07C_SET_DAC_FORMAT_INTERLACE_ENABLED                     (0x00000001)
#define NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC                       2:2
#define NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC_POSITIVE              (0x00000000)
#define NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC_NEGATIVE              (0x00000001)
#define NV07C_SET_DAC_FORMAT_VERTICAL_SYNC                         3:3
#define NV07C_SET_DAC_FORMAT_VERTICAL_SYNC_POSITIVE                (0x00000000)
#define NV07C_SET_DAC_FORMAT_VERTICAL_SYNC_NEGATIVE                (0x00000001)
#define NV07C_SET_DAC_FORMAT_COLOR                                 19:16
#define NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8                       (0x00000000)
#define NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5                (0x00000001)
#define NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5                (0x00000002)
#define NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8              (0x00000003)
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE                          21:20
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE_CRT                      (0x00000000)
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE_TV                       (0x00000001)
#define NV07C_SET_DAC_FORMAT_DISPLAY_TYPE_DFP                      (0x00000003)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD                           25:22
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_NTSC_M                    (0x00000000)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_NTSC_J                    (0x00000001)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_M                     (0x00000002)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_A                     (0x00000003)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_N                     (0x00000004)
#define NV07C_SET_DAC_FORMAT_TV_STANDARD_PAL_NC                    (0x00000005)
#define NV07C_SET_DAC_FORMAT_HEAD                                  27:26
#define NV07C_SET_DAC_FORMAT_HEAD_0                                (0x00000000)
#define NV07C_SET_DAC_FORMAT_HEAD_1                                (0x00000001)
#define NV07C_SET_DAC_FORMAT_NOTIFY                                31:31
#define NV07C_SET_DAC_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV07C_SET_DAC_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)


typedef NvV32 Nv07dTypedef;

typedef NvV32 Nv07eTypedef;

typedef NvV32 Nv07fTypedef;


/* class NV01_DEVICE_0 */
#define  NV01_DEVICE_0                                             (0x00000080)
/* NvNotification[] fields and values */
#define NV080_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv080Typedef, Nv01Device0;
#define  NV080_TYPEDEF                                             Nv01Device0


/* class NV01_DEVICE_1 */
#define  NV01_DEVICE_1                                             (0x00000081)
/* NvNotification[] fields and values */
#define NV081_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv081Typedef, Nv01Device1;
#define  NV081_TYPEDEF                                             Nv01Device1


/* class NV01_DEVICE_2 */
#define  NV01_DEVICE_2                                             (0x00000082)
/* NvNotification[] fields and values */
#define NV082_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv082Typedef, Nv01Device2;
#define  NV082_TYPEDEF                                             Nv01Device2


/* class NV01_DEVICE_3 */
#define  NV01_DEVICE_3                                             (0x00000083)
/* NvNotification[] fields and values */
#define NV083_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv083Typedef, Nv01Device3;
#define  NV083_TYPEDEF                                             Nv01Device3


/* class NV01_DEVICE_4 */
#define  NV01_DEVICE_4                                             (0x00000084)
/* NvNotification[] fields and values */
#define NV084_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv084Typedef, Nv01Device4;
#define  NV084_TYPEDEF                                             Nv01Device4


/* class NV01_DEVICE_5 */
#define  NV01_DEVICE_5                                             (0x00000085)
/* NvNotification[] fields and values */
#define NV085_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv085Typedef, Nv01Device5;
#define  NV085_TYPEDEF                                             Nv01Device5


/* class NV01_DEVICE_6 */
#define  NV01_DEVICE_6                                             (0x00000086)
/* NvNotification[] fields and values */
#define NV086_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv086Typedef, Nv01Device6;
#define  NV086_TYPEDEF                                             Nv01Device6


/* class NV01_DEVICE_7 */
#define  NV01_DEVICE_7                                             (0x00000087)
/* NvNotification[] fields and values */
#define NV087_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv087Typedef, Nv01Device7;
#define  NV087_TYPEDEF                                             Nv01Device7


/* class NV10_DVD_SUBPICTURE */
#define  NV10_DVD_SUBPICTURE                                       (0x00000088)
/* NvNotification[] elements */
#define NV088_NOTIFIERS_SET_NOTIFY                                 (0)
/* NvNotification[] fields and values */
#define NV088_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV088_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV088_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV088_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV088_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV088_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV088_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaOverlay;    /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaImageIn;    /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextDmaImageOut;   /* NV01_CONTEXT_DMA                 018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0300-0303*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0304-0307*/
 NvU32 ImageOutFormat;          /* color_pitch V16_U16              0308-030b*/
 NvU32 ImageOutOffset;          /* byte offset of top-left pixel    030c-030f*/
 NvV32 ImageInDsDx;             /* S12d20 ds/dx                     0310-0313*/
 NvV32 ImageInDtDy;             /* S12d20 dt/dy                     0314-0317*/
 NvV32 ImageInSize;             /* height_width U16_U16 in texels   0318-031b*/
 NvV32 ImageInFormat;           /* color_pitch V16_U16              031c-031f*/
 NvU32 ImageInOffset;           /* byte offset of top-left texel    0320-0323*/
 NvV32 ImageInPoint;            /* t_s U12d4_U12d4 in texels        0324-0317*/
 NvV32 OverlayDsDx;             /* S12d20 ds/dx                     0328-032b*/
 NvV32 OverlayDtDy;             /* S12d20 dt/dy                     032c-032f*/
 NvV32 OverlaySize;             /* height_width U16_U16 in texels   0330-0333*/
 NvV32 OverlayFormat;           /* color_pitch V16_U16              0334-0337*/
 NvU32 OverlayOffset;           /* byte offset of top-left texel    0338-033b*/
 NvV32 OverlayPoint;            /* t_s U12d4_U12d4 in texels        033c-033f*/
 NvV32 Reserved02[0x730];
} Nv088Typedef, Nv10DvdSubpicture;
#define NV088_TYPEDEF                                         Nv10DvdSubpicture
/* dma method offsets, fields, and values */
#define NV088_SET_OBJECT                                           (0x00000000)
#define NV088_NO_OPERATION                                         (0x00000100)
#define NV088_NOTIFY                                               (0x00000104)
#define NV088_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV088_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV088_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV088_SET_CONTEXT_DMA_OVERLAY                              (0x00000184)
#define NV088_SET_CONTEXT_DMA_IMAGE_IN                             (0x00000188)
#define NV088_SET_CONTEXT_DMA_IMAGE_OUT                            (0x0000018C)
#define NV088_IMAGE_OUT_POINT                                      (0x00000300)
#define NV088_IMAGE_OUT_POINT_X                                    15:0
#define NV088_IMAGE_OUT_POINT_Y                                    31:16
#define NV088_IMAGE_OUT_SIZE                                       (0x00000304)
#define NV088_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV088_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV088_IMAGE_OUT_FORMAT                                     (0x00000308)
#define NV088_IMAGE_OUT_FORMAT_PITCH                               15:0
#define NV088_IMAGE_OUT_FORMAT_COLOR                               31:16
#define NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8               (0x00000001)
#define NV088_IMAGE_OUT_FORMAT_COLOR_LE_YB8CR8YA8CB8               (0x00000002)
#define NV088_IMAGE_OUT_OFFSET                                     (0x0000030C)
#define NV088_IMAGE_IN_DS_DX                                       (0x00000310)
#define NV088_IMAGE_IN_DT_DY                                       (0x00000314)
#define NV088_IMAGE_IN_SIZE                                        (0x00000318)
#define NV088_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV088_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV088_IMAGE_IN_FORMAT                                      (0x0000031C)
#define NV088_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV088_IMAGE_IN_FORMAT_COLOR                                31:16
#define NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8                (0x00000001)
#define NV088_IMAGE_IN_FORMAT_COLOR_LE_YB8CR8YA8CB8                (0x00000002)
#define NV088_IMAGE_IN_OFFSET                                      (0x00000320)
#define NV088_IMAGE_IN_POINT                                       (0x00000324)
#define NV088_IMAGE_IN_POINT_S                                     15:0
#define NV088_IMAGE_IN_POINT_T                                     31:16
#define NV088_OVERLAY_DS_DX                                        (0x00000328)
#define NV088_OVERLAY_DT_DY                                        (0x0000032C)
#define NV088_OVERLAY_SIZE                                         (0x00000330)
#define NV088_OVERLAY_SIZE_WIDTH                                   15:0
#define NV088_OVERLAY_SIZE_HEIGHT                                  31:16
#define NV088_OVERLAY_FORMAT                                       (0x00000334)
#define NV088_OVERLAY_FORMAT_PITCH                                 15:0
#define NV088_OVERLAY_FORMAT_COLOR                                 31:16
#define NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8                   (0x00000001)
#define NV088_OVERLAY_FORMAT_COLOR_LE_A4CR6YB6A4CB6YA6             (0x00000002)
#define NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT                  (0x00000003)
#define NV088_OVERLAY_OFFSET                                       (0x00000338)
#define NV088_OVERLAY_POINT                                        (0x0000033C)
#define NV088_OVERLAY_POINT_S                                      15:0
#define NV088_OVERLAY_POINT_T                                      31:16


/* class NV10_SCALED_IMAGE_FROM_MEMORY */
#define  NV10_SCALED_IMAGE_FROM_MEMORY                             (0x00000089)
/* NvNotification[] elements */
#define NV089_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV089_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV089_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV089_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV089_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV089_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV089_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV089_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetColorConversion;      /* NV089_SET_COLOR_CONVERSION_*     02fc-02ff*/
 NvV32 SetColorFormat;          /* NV089_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV089_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv089Typedef, Nv10ScaledImageFromMemory;
#define NV089_TYPEDEF                                 Nv10ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV089_SET_OBJECT                                           (0x00000000)
#define NV089_NO_OPERATION                                         (0x00000100)
#define NV089_NOTIFY                                               (0x00000104)
#define NV089_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV089_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV089_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV089_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV089_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV089_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV089_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV089_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV089_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV089_SET_COLOR_CONVERSION                                 (0x000002fc)
#define NV089_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV089_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV089_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV089_SET_COLOR_FORMAT                                     (0x00000300)
#define NV089_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV089_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV089_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV089_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV089_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV089_SET_COLOR_FORMAT_LE_Y8                               (0x00000008)
#define NV089_SET_COLOR_FORMAT_LE_AY8                              (0x00000009)
#define NV089_SET_OPERATION                                        (0x00000304)
#define NV089_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV089_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV089_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV089_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV089_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV089_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV089_CLIP_POINT                                           (0x00000308)
#define NV089_CLIP_POINT_X                                         15:0
#define NV089_CLIP_POINT_Y                                         31:16
#define NV089_CLIP_SIZE                                            (0x0000030C)
#define NV089_CLIP_SIZE_WIDTH                                      15:0
#define NV089_CLIP_SIZE_HEIGHT                                     31:16
#define NV089_IMAGE_OUT_POINT                                      (0x00000310)
#define NV089_IMAGE_OUT_POINT_X                                    15:0
#define NV089_IMAGE_OUT_POINT_Y                                    31:16
#define NV089_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV089_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV089_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV089_DS_DX                                                (0x00000318)
#define NV089_DT_DY                                                (0x0000031C)
#define NV089_IMAGE_IN_SIZE                                        (0x00000400)
#define NV089_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV089_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV089_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV089_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV089_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV089_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV089_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV089_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV089_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV089_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV089_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV089_IMAGE_IN                                             (0x0000040C)
#define NV089_IMAGE_IN_POINT_U                                     15:0
#define NV089_IMAGE_IN_POINT_V                                     31:16


/* class NV11_SCALED_IMAGE_FROM_MEMORY */
#define  NV11_SCALED_IMAGE_FROM_MEMORY                             (0x00001189)
/* NvNotification[] elements */
#define NV1189_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV1189_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV1189_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV1189_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV1189_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV1189_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV1189_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV1189_NOTIFY_*                  0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x058];
 NvV32 SetColorConversion;      /* NV1189_SET_COLOR_CONVERSION_*    02fc-02ff*/
 NvV32 SetColorFormat;          /* NV1189_SET_COLOR_FORMAT_*        0300-0303*/
 NvV32 SetOperation;            /* NV1189_SET_OPERATION_*           0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 Reserved02[0x038];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv1189Typedef, Nv11ScaledImageFromMemory;
#define NV1189_TYPEDEF                                 Nv11ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV1189_SET_OBJECT                                           (0x00000000)
#define NV1189_NO_OPERATION                                         (0x00000100)
#define NV1189_NOTIFY                                               (0x00000104)
#define NV1189_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV1189_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV1189_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV1189_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV1189_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV1189_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV1189_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV1189_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV1189_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV1189_SET_COLOR_CONVERSION                                 (0x000002fc)
#define NV1189_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV1189_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV1189_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV1189_SET_COLOR_FORMAT                                     (0x00000300)
#define NV1189_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV1189_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV1189_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV1189_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV1189_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV1189_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV1189_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV1189_SET_COLOR_FORMAT_LE_Y8                               (0x00000008)
#define NV1189_SET_COLOR_FORMAT_LE_AY8                              (0x00000009)
#define NV1189_SET_OPERATION                                        (0x00000304)
#define NV1189_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV1189_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV1189_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV1189_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV1189_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV1189_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV1189_CLIP_POINT                                           (0x00000308)
#define NV1189_CLIP_POINT_X                                         15:0
#define NV1189_CLIP_POINT_Y                                         31:16
#define NV1189_CLIP_SIZE                                            (0x0000030C)
#define NV1189_CLIP_SIZE_WIDTH                                      15:0
#define NV1189_CLIP_SIZE_HEIGHT                                     31:16
#define NV1189_IMAGE_OUT_POINT                                      (0x00000310)
#define NV1189_IMAGE_OUT_POINT_X                                    15:0
#define NV1189_IMAGE_OUT_POINT_Y                                    31:16
#define NV1189_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV1189_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV1189_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV1189_DS_DX                                                (0x00000318)
#define NV1189_DT_DY                                                (0x0000031C)
#define NV1189_IMAGE_IN_SIZE                                        (0x00000400)
#define NV1189_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV1189_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV1189_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV1189_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV1189_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV1189_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV1189_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV1189_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV1189_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV1189_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV1189_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV1189_IMAGE_IN                                             (0x0000040C)
#define NV1189_IMAGE_IN_POINT_U                                     15:0
#define NV1189_IMAGE_IN_POINT_V                                     31:16


/* class NV10_IMAGE_FROM_CPU */
#define  NV10_IMAGE_FROM_CPU                                       (0x0000008A)
#define NV08A_NOTIFIERS_NOTIFY                                     (0)
#define NV08A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV08A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV08A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV08A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV08A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV08A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV08A_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x056];
 NvV32 SetColorConversion;      /* NV08A_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV08A_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV08A_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 struct {                       /* start aliased methods in array   0400-    */
  NvV32 a;                      /* source colors (packed texels)       0-   3*/
  NvV32 b;                      /* source colors (packed texels)       4-   7*/
 } Color[896];                  /* end of aliased methods in array      -1fff*/
} Nv08ATypedef, NV10ImageFromCpu;
#define NV08A_TYPEDEF                                          NV10ImageFromCpu
/* dma method offsets, fields, and values */
#define NV08A_SET_OBJECT                                           (0x00000000)
#define NV08A_NO_OPERATION                                         (0x00000100)
#define NV08A_NOTIFY                                               (0x00000104)
#define NV08A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV08A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV08A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV08A_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV08A_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV08A_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV08A_SET_CONTEXT_ROP                                      (0x00000190)
#define NV08A_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV08A_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV08A_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV08A_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV08A_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV08A_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV08A_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV08A_SET_OPERATION                                        (0x000002FC)
#define NV08A_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV08A_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV08A_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV08A_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV08A_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV08A_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV08A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV08A_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV08A_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV08A_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV08A_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV08A_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV08A_POINT                                                (0x00000304)
#define NV08A_POINT_X                                              15:0
#define NV08A_POINT_Y                                              31:16
#define NV08A_SIZE_OUT                                             (0x00000308)
#define NV08A_SIZE_OUT_WIDTH                                       15:0
#define NV08A_SIZE_OUT_HEIGHT                                      31:16
#define NV08A_SIZE_IN                                              (0x0000030C)
#define NV08A_SIZE_IN_WIDTH                                        15:0
#define NV08A_SIZE_IN_HEIGHT                                       31:16
#define NV08A_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV10_CONTEXT_SURFACES_3D */
#define  NV10_CONTEXT_SURFACES_3D                                  (0x00000093)
/* NvNotification[] elements */
#define NV093_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV093_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV093_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV093_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV093_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV093_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV093_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV093_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaColor;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaZeta;       /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05b];
 NvV32 SetClipHorizontal;       /* width_x U16_U16                  02f8-02fb*/
 NvV32 SetClipVertical;         /* height_y U16_U16                 02fc-02ff*/
 NvV32 SetFormat;               /* height_width_type_color all V8   0300-0303*/
 NvV32 SetClipSize;             /* height_width U16_U16             0304-0307*/
 NvV32 SetPitch;                /* zeta_color U16_U16               0308-030b*/
 NvU32 SetOffsetColor;          /* byte offset of top-left pixel    030c-030f*/
 NvU32 SetOffsetZeta;           /* byte offset of top-left pixel    0310-0313*/
 NvV32 Reserved02[0x73b];
} Nv093Typedef, Nv10ContextSurfaces3d;
#define NV093_TYPEDEF                                     Nv10ContextSurfaces3d
/* dma method offsets, fields, and values */
#define NV093_SET_OBJECT                                           (0x00000000)
#define NV093_NO_OPERATION                                         (0x00000100)
#define NV093_NOTIFY                                               (0x00000104)
#define NV093_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV093_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV093_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV093_SET_CONTEXT_DMA_COLOR                                (0x00000184)
#define NV093_SET_CONTEXT_DMA_ZETA                                 (0x00000188)
#define NV093_SET_CLIP_HORIZONTAL                                  (0x000002F8)
#define NV093_SET_CLIP_HORIZONTAL_X                                15:0
#define NV093_SET_CLIP_HORIZONTAL_WIDTH                            31:16
#define NV093_SET_CLIP_VERTICAL                                    (0x000002FC)
#define NV093_SET_CLIP_VERTICAL_Y                                  15:0
#define NV093_SET_CLIP_VERTICAL_HEIGHT                             31:16
#define NV093_SET_FORMAT                                           (0x00000300)
#define NV093_SET_FORMAT_COLOR                                     7:0
#define NV093_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000001)
#define NV093_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000002)
#define NV093_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000003)
#define NV093_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000004)
#define NV093_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000005)
#define NV093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000006)
#define NV093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000007)
#define NV093_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x00000008)
#define NV093_SET_FORMAT_TYPE                                      15:8
#define NV093_SET_FORMAT_TYPE_PITCH                                (0x00000001)
#define NV093_SET_FORMAT_TYPE_SWIZZLE                              (0x00000002)
#define NV093_SET_FORMAT_WIDTH                                     23:16
#define NV093_SET_FORMAT_HEIGHT                                    31:24
#define NV093_SET_CLIP_SIZE                                        (0x00000304)
#define NV093_SET_CLIP_SIZE_WIDTH                                  15:0
#define NV093_SET_CLIP_SIZE_HEIGHT                                 31:16
#define NV093_SET_PITCH                                            (0x00000308)
#define NV093_SET_PITCH_COLOR                                      15:0
#define NV093_SET_PITCH_ZETA                                       31:16
#define NV093_SET_OFFSET_COLOR                                     (0x0000030C)
#define NV093_SET_OFFSET_ZETA                                      (0x00000310)



/* class NV10_DX5_TEXTURED_TRIANGLE */
#define  NV10_DX5_TEXTURED_TRIANGLE                                (0x00000094)
/* NvNotification[] elements */
#define NV094_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV094_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV094_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV094_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV094_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV094_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV094_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV094_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05c];
 NvV32 ColorKeyValue;           /* see text                         0300-0303*/
 NvU32 Offset;                  /* texture offset in bytes          0304-0307*/
 NvV32 Format;                  /* see text                         0308-030b*/
 NvV32 Filter;                  /* see text                         030c-030f*/
 NvV32 Blend;                   /* see text                         0310-0313*/
 NvV32 Control;                 /* see text                         0314-0317*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0318-031b*/
 NvV32 Reserved02[0x039];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu;                     /* texture u coordinate               18-  1b*/
  NvF32 tv;                     /* texture v coordinate               1c-  1f*/
 } Tlvertex[16];                /* end of methods in array              -05ff*/
 NvV32 DrawPrimitive[64];       /* see text                         0600-06ff*/
 NvV32 Reserved03[0x640];
} Nv094Typedef, Nv10Dx5TexturedTriangle;
#define NV094_TYPEDEF                                   Nv10Dx5TexturedTriangle
/* dma method offsets, fields, and values */
#define NV094_SET_OBJECT                                           (0x00000000)
#define NV094_NO_OPERATION                                         (0x00000100)
#define NV094_NOTIFY                                               (0x00000104)
#define NV094_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV094_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV094_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV094_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV094_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV094_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV094_COLOR_KEY_VALUE                                      (0x00000300)
#define NV094_OFFSET                                               (0x00000304)
#define NV094_FORMAT                                               (0x00000308)
#define NV094_FORMAT_CONTEXT_DMA                                   1:0
#define NV094_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV094_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV094_FORMAT_COLOR_KEY_MATCH                               3:2
#define NV094_FORMAT_COLOR_KEY_MATCH_SRCCOPY                       (0x00000000)
#define NV094_FORMAT_COLOR_KEY_MATCH_ZERO_ALPHA                    (0x00000001)
#define NV094_FORMAT_ORIGIN_ZOH                                    5:4
#define NV094_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV094_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV094_FORMAT_ORIGIN_FOH                                    7:6
#define NV094_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV094_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV094_FORMAT_COLOR                                         11:8
#define NV094_FORMAT_COLOR_LE_Y8                                   (0x00000001)
#define NV094_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV094_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV094_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV094_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV094_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV094_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV094_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV094_FORMAT_BASE_SIZE_U                                   19:16
#define NV094_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV094_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV094_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV094_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV094_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV094_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV094_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV094_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV094_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV094_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV094_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV094_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV094_FORMAT_BASE_SIZE_V                                   23:20
#define NV094_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV094_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV094_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV094_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV094_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV094_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV094_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV094_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV094_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV094_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV094_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV094_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV094_FORMAT_TEXTUREADDRESSU                               26:24
#define NV094_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV094_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV094_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV094_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV094_FORMAT_WRAPU                                         27:27
#define NV094_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV094_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV094_FORMAT_TEXTUREADDRESSV                               30:28
#define NV094_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV094_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV094_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV094_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV094_FORMAT_WRAPV                                         31:31
#define NV094_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV094_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV094_FILTER                                               (0x0000030C)
#define NV094_FILTER_IGNORE0                                       4:0
#define NV094_FILTER_ZERO0                                         7:5
#define NV094_FILTER_IGNORE1                                       12:8
#define NV094_FILTER_ZERO1                                         14:13
#define NV094_FILTER_IGNORE2                                       15:15
#define NV094_FILTER_MIPMAPLODBIAS                                 23:16
#define NV094_FILTER_TEXTUREMIN                                    26:24
#define NV094_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV094_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV094_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV094_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV094_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV094_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV094_FILTER_IGNORE3                                       27:27
#define NV094_FILTER_TEXTUREMAG                                    30:28
#define NV094_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV094_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV094_FILTER_IGNORE4                                       31:31
#define NV094_BLEND                                                (0x00000310)
#define NV094_BLEND_TEXTUREMAPBLEND                                3:0
#define NV094_BLEND_TEXTUREMAPBLEND_DECAL                          (0x00000001)
#define NV094_BLEND_TEXTUREMAPBLEND_MODULATE                       (0x00000002)
#define NV094_BLEND_TEXTUREMAPBLEND_DECALALPHA                     (0x00000003)
#define NV094_BLEND_TEXTUREMAPBLEND_MODULATEALPHA                  (0x00000004)
#define NV094_BLEND_TEXTUREMAPBLEND_DECALMASK                      (0x00000005)
#define NV094_BLEND_TEXTUREMAPBLEND_MODULATEMASK                   (0x00000006)
#define NV094_BLEND_TEXTUREMAPBLEND_COPY                           (0x00000007)
#define NV094_BLEND_TEXTUREMAPBLEND_ADD                            (0x00000008)
#define NV094_BLEND_MASK_BIT                                       5:4
#define NV094_BLEND_MASK_BIT_LSB                                   (0x00000001)
#define NV094_BLEND_MASK_BIT_MSB                                   (0x00000002)
#define NV094_BLEND_SHADEMODE                                      7:6
#define NV094_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV094_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV094_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV094_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV094_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV094_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV094_BLEND_SPECULARENABLE                                 15:12
#define NV094_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV094_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV094_BLEND_FOGENABLE                                      19:16
#define NV094_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV094_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV094_BLEND_ALPHABLENDENABLE                               23:20
#define NV094_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV094_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV094_BLEND_SRCBLEND                                       27:24
#define NV094_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV094_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV094_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV094_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV094_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV094_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV094_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV094_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV094_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV094_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV094_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV094_BLEND_DESTBLEND                                      31:28
#define NV094_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV094_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV094_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV094_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV094_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV094_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV094_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV094_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV094_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV094_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV094_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV094_CONTROL                                              (0x00000314)
#define NV094_CONTROL_ALPHAREF                                     7:0
#define NV094_CONTROL_ALPHAFUNC                                    11:8
#define NV094_CONTROL_ALPHAFUNC_NEVER                              (0x00000001)
#define NV094_CONTROL_ALPHAFUNC_LESS                               (0x00000002)
#define NV094_CONTROL_ALPHAFUNC_EQUAL                              (0x00000003)
#define NV094_CONTROL_ALPHAFUNC_LESSEQUAL                          (0x00000004)
#define NV094_CONTROL_ALPHAFUNC_GREATER                            (0x00000005)
#define NV094_CONTROL_ALPHAFUNC_NOTEQUAL                           (0x00000006)
#define NV094_CONTROL_ALPHAFUNC_GREATEREQUAL                       (0x00000007)
#define NV094_CONTROL_ALPHAFUNC_ALWAYS                             (0x00000008)
#define NV094_CONTROL_ALPHATESTENABLE                              12:12
#define NV094_CONTROL_ALPHATESTENABLE_FALSE                        (0x00000000)
#define NV094_CONTROL_ALPHATESTENABLE_TRUE                         (0x00000001)
#define NV094_CONTROL_ORIGIN                                       13:13
#define NV094_CONTROL_ORIGIN_CENTER                                (0x00000000)
#define NV094_CONTROL_ORIGIN_CORNER                                (0x00000001)
#define NV094_CONTROL_ZENABLE                                      15:14
#define NV094_CONTROL_ZENABLE_FALSE                                (0x00000000)
#define NV094_CONTROL_ZENABLE_TRUE                                 (0x00000001)
#define NV094_CONTROL_ZFUNC                                        19:16
#define NV094_CONTROL_ZFUNC_NEVER                                  (0x00000001)
#define NV094_CONTROL_ZFUNC_LESS                                   (0x00000002)
#define NV094_CONTROL_ZFUNC_EQUAL                                  (0x00000003)
#define NV094_CONTROL_ZFUNC_LESSEQUAL                              (0x00000004)
#define NV094_CONTROL_ZFUNC_GREATER                                (0x00000005)
#define NV094_CONTROL_ZFUNC_NOTEQUAL                               (0x00000006)
#define NV094_CONTROL_ZFUNC_GREATEREQUAL                           (0x00000007)
#define NV094_CONTROL_ZFUNC_ALWAYS                                 (0x00000008)
#define NV094_CONTROL_CULLMODE                                     21:20
#define NV094_CONTROL_CULLMODE_NONE                                (0x00000001)
#define NV094_CONTROL_CULLMODE_CW                                  (0x00000002)
#define NV094_CONTROL_CULLMODE_CCW                                 (0x00000003)
#define NV094_CONTROL_DITHERENABLE                                 22:22
#define NV094_CONTROL_DITHERENABLE_FALSE                           (0x00000000)
#define NV094_CONTROL_DITHERENABLE_TRUE                            (0x00000001)
#define NV094_CONTROL_Z_PERSPECTIVE_ENABLE                         23:23
#define NV094_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE                   (0x00000000)
#define NV094_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE                    (0x00000001)
#define NV094_CONTROL_ZWRITEENABLE                                 29:24
#define NV094_CONTROL_ZWRITEENABLE_FALSE                           (0x00000000)
#define NV094_CONTROL_ZWRITEENABLE_TRUE                            (0x00000001)
#define NV094_CONTROL_Z_FORMAT                                     31:30
#define NV094_CONTROL_Z_FORMAT_FIXED                               (0x00000001)
#define NV094_CONTROL_Z_FORMAT_FLOAT                               (0x00000002)
#define NV094_FOG_COLOR                                            (0x00000318)
#define NV094_TLVERTEX(i)                                          (0x00000400\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SX(i)                                       (0x00000400\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SY(i)                                       (0x00000404\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SZ(i)                                       (0x00000408\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_RHW(i)                                      (0x0000040C\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_COLOR(i)                                    (0x00000410\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_COLOR_BLUE                                  7:0
#define NV094_TLVERTEX_COLOR_GREEN                                 15:8
#define NV094_TLVERTEX_COLOR_RED                                   23:16
#define NV094_TLVERTEX_COLOR_ALPHA                                 31:24
#define NV094_TLVERTEX_SPECULAR(i)                                 (0x00000414\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_SPECULAR_BLUE                               7:0
#define NV094_TLVERTEX_SPECULAR_GREEN                              15:8
#define NV094_TLVERTEX_SPECULAR_RED                                23:16
#define NV094_TLVERTEX_SPECULAR_FOG                                31:24
#define NV094_TLVERTEX_TU(i)                                       (0x00000418\
                                                                   +(i)*0x0020)
#define NV094_TLVERTEX_TV(i)                                       (0x0000041C\
                                                                   +(i)*0x0020)
#define NV094_DRAW_PRIMITIVE(a)                                    (0x00000600\
                                                                   +(a)*0x0004)
#define NV094_DRAW_PRIMITIVE_I0                                    3:0
#define NV094_DRAW_PRIMITIVE_I1                                    7:4
#define NV094_DRAW_PRIMITIVE_I2                                    11:8
#define NV094_DRAW_PRIMITIVE_I3                                    15:12
#define NV094_DRAW_PRIMITIVE_I4                                    19:16
#define NV094_DRAW_PRIMITIVE_I5                                    31:20



/* class NV10_DX6_MULTI_TEXTURE_TRIANGLE */
#define  NV10_DX6_MULTI_TEXTURE_TRIANGLE                           (0x00000095)
/* NvNotification[] elements */
#define NV095_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV095_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV095_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV095_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV095_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV095_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV095_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV095_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaA;          /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaB;          /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_3D         018c-018f*/
 NvV32 Reserved01[0x05e];
 NvU32 Offset[2];               /* offset in bytes                  0308-030f*/
 NvV32 Format[2];               /* see text                         0310-0317*/
 NvV32 Filter[2];               /* see text                         0318-031f*/
 NvV32 Combine0Alpha;           /* see text                         0320-0323*/
 NvV32 Combine0Color;           /* see text                         0324-0327*/
 NvV32 Reserved02;
 NvV32 Combine1Alpha;           /* see text                         032c-032f*/
 NvV32 Combine1Color;           /* see text                         0330-0333*/
 NvV32 CombineFactor;           /* A8R8G8B8                         0334-0337*/
 NvV32 Blend;                   /* see text                         0338-033b*/
 NvV32 Control0;                /* see text                         033c-033f*/
 NvV32 Control1;                /* see text                         0340-0343*/
 NvV32 Control2;                /* see text                         0344-0347*/
 NvV32 FogColor;                /* X8R8G8B8 fog color               0348-034b*/
 NvV32 Reserved03[0x02D];
 struct {                       /* start of methods in array        0400-    */
  NvF32 sx;                     /* screen x coordinate                00-  03*/
  NvF32 sy;                     /* screen y coordinate                04-  07*/
  NvF32 sz;                     /* screen z coordinate                08-  0b*/
  NvF32 rhw;                    /* reciprocal homogeneous W (1/W)     0c-  0f*/
  NvV32 color;                  /* A8R8G8B8                           10-  13*/
  NvV32 specular;               /* F8R8G8B8                           14-  17*/
  NvF32 tu0;                    /* texture 0 u coordinate             18-  1b*/
  NvF32 tv0;                    /* texture 0 v coordinate             1c-  1f*/
  NvF32 tu1;                    /* texture 1 u coordinate             20-  23*/
  NvF32 tv1;                    /* texture 1 v coordinate             24-  27*/
 } Tlmtvertex[8];               /* end of methods in array              -053f*/
 NvV32 DrawPrimitive[48];       /* see text                         0540-05ff*/
 NvV32 Reserved04[0x680];
} Nv095Typedef, Nv10Dx6MultiTextureTriangle;
#define NV095_TYPEDEF                               Nv10Dx6MultiTextureTriangle
/* dma method offsets, fields, and values */
#define NV095_SET_OBJECT                                           (0x00000000)
#define NV095_NO_OPERATION                                         (0x00000100)
#define NV095_NOTIFY                                               (0x00000104)
#define NV095_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV095_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV095_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV095_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV095_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV095_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV095_OFFSET(b)                                            (0x00000308\
                                                                   +(b)*0x0004)
#define NV095_FORMAT(b)                                            (0x00000310\
                                                                   +(b)*0x0004)
#define NV095_FORMAT_CONTEXT_DMA                                   3:0
#define NV095_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV095_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV095_FORMAT_ORIGIN_ZOH                                    5:4
#define NV095_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV095_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV095_FORMAT_ORIGIN_FOH                                    7:6
#define NV095_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV095_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV095_FORMAT_COLOR                                         11:8
#define NV095_FORMAT_COLOR_LE_AY8                                  (0x00000001)
#define NV095_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV095_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV095_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV095_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV095_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV095_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV095_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV095_FORMAT_BASE_SIZE_U                                   19:16
#define NV095_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV095_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV095_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV095_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV095_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV095_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV095_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV095_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV095_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV095_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV095_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV095_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV095_FORMAT_BASE_SIZE_V                                   23:20
#define NV095_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV095_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV095_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV095_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV095_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV095_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV095_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV095_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV095_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV095_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV095_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV095_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV095_FORMAT_TEXTUREADDRESSU                               26:24
#define NV095_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV095_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV095_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV095_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV095_FORMAT_WRAPU                                         27:27
#define NV095_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV095_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV095_FORMAT_TEXTUREADDRESSV                               30:28
#define NV095_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV095_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV095_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV095_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV095_FORMAT_WRAPV                                         31:31
#define NV095_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV095_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV095_FILTER(b)                                            (0x00000318\
                                                                   +(b)*0x0004)
#define NV095_FILTER_IGNORE0                                       4:0
#define NV095_FILTER_ZERO0                                         7:5
#define NV095_FILTER_IGNORE1                                       12:8
#define NV095_FILTER_ZERO1                                         14:13
#define NV095_FILTER_IGNORE2                                       15:15
#define NV095_FILTER_MIPMAPLODBIAS                                 23:16
#define NV095_FILTER_TEXTUREMIN                                    26:24
#define NV095_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV095_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV095_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV095_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV095_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV095_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV095_FILTER_IGNORE3                                       27:27
#define NV095_FILTER_TEXTUREMAG                                    30:28
#define NV095_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV095_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV095_FILTER_IGNORE4                                       31:31
#define NV095_COMBINE_0_ALPHA                                      (0x00000320)
#define NV095_COMBINE_0_ALPHA_INVERSE_0                            0:0
#define NV095_COMBINE_0_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_0                              1:1
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0                           7:2
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_INVERSE_1                            8:8
#define NV095_COMBINE_0_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_1                              9:9
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1                           15:10
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_INVERSE_2                            16:16
#define NV095_COMBINE_0_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_2                              17:17
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2                           23:18
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_INVERSE_3                            24:24
#define NV095_COMBINE_0_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_ALPHA_ALPHA_3                              25:25
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3                           28:26
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_ALPHA_OPERATION                            31:29
#define NV095_COMBINE_0_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_0_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV095_COMBINE_0_COLOR                                      (0x00000324)
#define NV095_COMBINE_0_COLOR_INVERSE_0                            0:0
#define NV095_COMBINE_0_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_0                              1:1
#define NV095_COMBINE_0_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0                           7:2
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_INVERSE_1                            8:8
#define NV095_COMBINE_0_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_1                              9:9
#define NV095_COMBINE_0_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1                           15:10
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_INVERSE_2                            16:16
#define NV095_COMBINE_0_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_2                              17:17
#define NV095_COMBINE_0_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2                           23:18
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_INVERSE_3                            24:24
#define NV095_COMBINE_0_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_0_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_0_COLOR_ALPHA_3                              25:25
#define NV095_COMBINE_0_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV095_COMBINE_0_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3                           28:26
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_0_COLOR_OPERATION                            31:29
#define NV095_COMBINE_0_COLOR_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_0_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_0_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_0_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_0_COLOR_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_0_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV095_COMBINE_1_ALPHA                                      (0x0000032C)
#define NV095_COMBINE_1_ALPHA_INVERSE_0                            0:0
#define NV095_COMBINE_1_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_0                              1:1
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0                           7:2
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_INVERSE_1                            8:8
#define NV095_COMBINE_1_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_1                              9:9
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1                           15:10
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_INVERSE_2                            16:16
#define NV095_COMBINE_1_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_2                              17:17
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2                           23:18
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_INVERSE_3                            24:24
#define NV095_COMBINE_1_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_ALPHA_ALPHA_3                              25:25
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3                           28:26
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_ALPHA_OPERATION                            31:29
#define NV095_COMBINE_1_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_1_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV095_COMBINE_1_COLOR                                      (0x00000330)
#define NV095_COMBINE_1_COLOR_INVERSE_0                            0:0
#define NV095_COMBINE_1_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_0                              1:1
#define NV095_COMBINE_1_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0                           7:2
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_INVERSE_1                            8:8
#define NV095_COMBINE_1_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_1                              9:9
#define NV095_COMBINE_1_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1                           15:10
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_INVERSE_2                            16:16
#define NV095_COMBINE_1_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_2                              17:17
#define NV095_COMBINE_1_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2                           23:18
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_INVERSE_3                            24:24
#define NV095_COMBINE_1_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV095_COMBINE_1_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV095_COMBINE_1_COLOR_ALPHA_3                              25:25
#define NV095_COMBINE_1_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV095_COMBINE_1_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3                           28:26
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV095_COMBINE_1_COLOR_OPERATION                            31:29
#define NV095_COMBINE_1_COLOR_OPERATION_ADD                        (0x00000001)
#define NV095_COMBINE_1_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV095_COMBINE_1_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV095_COMBINE_1_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV095_COMBINE_1_COLOR_OPERATION_MUX                        (0x00000005)
#define NV095_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV095_COMBINE_1_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
/* The following NV095_COMBINE_*** defines can be used without regard to the combiner number */
#define NV095_COMBINE_ALPHA_INVERSE_0                              0:0
#define NV095_COMBINE_ALPHA_INVERSE_0_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_0_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_0                                1:1
#define NV095_COMBINE_ALPHA_ARGUMENT_0                             7:2
#define NV095_COMBINE_ALPHA_ARGUMENT_0_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_INVERSE_1                              8:8
#define NV095_COMBINE_ALPHA_INVERSE_1_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_1_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_1                                9:9
#define NV095_COMBINE_ALPHA_ARGUMENT_1                             15:10
#define NV095_COMBINE_ALPHA_ARGUMENT_1_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_INVERSE_2                              16:16
#define NV095_COMBINE_ALPHA_INVERSE_2_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_2_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_2                                17:17
#define NV095_COMBINE_ALPHA_ARGUMENT_2                             23:18
#define NV095_COMBINE_ALPHA_ARGUMENT_2_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_INVERSE_3                              24:24
#define NV095_COMBINE_ALPHA_INVERSE_3_NORMAL                       (0x00000000)
#define NV095_COMBINE_ALPHA_INVERSE_3_INVERSE                      (0x00000001)
#define NV095_COMBINE_ALPHA_ALPHA_3                                25:25
#define NV095_COMBINE_ALPHA_ARGUMENT_3                             28:26
#define NV095_COMBINE_ALPHA_ARGUMENT_3_ZERO                        (0x00000001)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_INPUT                       (0x00000004)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_ALPHA_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_ALPHA_OPERATION                              31:29
#define NV095_COMBINE_ALPHA_OPERATION_ADD                          (0x00000001)
#define NV095_COMBINE_ALPHA_OPERATION_ADD2                         (0x00000002)
#define NV095_COMBINE_ALPHA_OPERATION_ADD4                         (0x00000003)
#define NV095_COMBINE_ALPHA_OPERATION_ADDSIGNED                    (0x00000004)
#define NV095_COMBINE_ALPHA_OPERATION_MUX                          (0x00000005)
#define NV095_COMBINE_ALPHA_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV095_COMBINE_ALPHA_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_0                              0:0
#define NV095_COMBINE_COLOR_INVERSE_0_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_0_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_0                                1:1
#define NV095_COMBINE_COLOR_ALPHA_0_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_0_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_0                             7:2
#define NV095_COMBINE_COLOR_ARGUMENT_0_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_0_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_0_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_0_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_0_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_0_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_0_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_1                              8:8
#define NV095_COMBINE_COLOR_INVERSE_1_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_1_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_1                                9:9
#define NV095_COMBINE_COLOR_ALPHA_1_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_1_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_1                             15:10
#define NV095_COMBINE_COLOR_ARGUMENT_1_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_1_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_1_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_1_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_1_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_1_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_1_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_2                              16:16
#define NV095_COMBINE_COLOR_INVERSE_2_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_2_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_2                                17:17
#define NV095_COMBINE_COLOR_ALPHA_2_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_2_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_2                             23:18
#define NV095_COMBINE_COLOR_ARGUMENT_2_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_2_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_2_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_2_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_2_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_2_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_2_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_INVERSE_3                              24:24
#define NV095_COMBINE_COLOR_INVERSE_3_NORMAL                       (0x00000000)
#define NV095_COMBINE_COLOR_INVERSE_3_INVERSE                      (0x00000001)
#define NV095_COMBINE_COLOR_ALPHA_3                                25:25
#define NV095_COMBINE_COLOR_ALPHA_3_COLOR                          (0x00000000)
#define NV095_COMBINE_COLOR_ALPHA_3_ALPHA                          (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_3                             28:26
#define NV095_COMBINE_COLOR_ARGUMENT_3_ZERO                        (0x00000001)
#define NV095_COMBINE_COLOR_ARGUMENT_3_FACTOR                      (0x00000002)
#define NV095_COMBINE_COLOR_ARGUMENT_3_DIFFUSE                     (0x00000003)
#define NV095_COMBINE_COLOR_ARGUMENT_3_INPUT                       (0x00000004)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURE0                    (0x00000005)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURE1                    (0x00000006)
#define NV095_COMBINE_COLOR_ARGUMENT_3_TEXTURELOD                  (0x00000007)
#define NV095_COMBINE_COLOR_OPERATION                              31:29
#define NV095_COMBINE_COLOR_OPERATION_ADD                          (0x00000001)
#define NV095_COMBINE_COLOR_OPERATION_ADD2                         (0x00000002)
#define NV095_COMBINE_COLOR_OPERATION_ADD4                         (0x00000003)
#define NV095_COMBINE_COLOR_OPERATION_ADDSIGNED                    (0x00000004)
#define NV095_COMBINE_COLOR_OPERATION_MUX                          (0x00000005)
#define NV095_COMBINE_COLOR_OPERATION_ADDCOMPLEMENT                (0x00000006)
#define NV095_COMBINE_COLOR_OPERATION_ADDSIGNED2                   (0x00000007)
#define NV095_COMBINE_FACTOR                                       (0x00000334)
#define NV095_COMBINE_FACTOR_BLUE                                  7:0
#define NV095_COMBINE_FACTOR_GREEN                                 15:8
#define NV095_COMBINE_FACTOR_RED                                   23:16
#define NV095_COMBINE_FACTOR_ALPHA                                 31:24
#define NV095_BLEND                                                (0x00000338)
#define NV095_BLEND_MASK_BIT                                       5:0
#define NV095_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV095_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV095_BLEND_SHADEMODE                                      7:6
#define NV095_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV095_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV095_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV095_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV095_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV095_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV095_BLEND_SPECULARENABLE                                 15:12
#define NV095_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV095_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV095_BLEND_FOGENABLE                                      19:16
#define NV095_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV095_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV095_BLEND_ALPHABLENDENABLE                               23:20
#define NV095_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV095_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV095_BLEND_SRCBLEND                                       27:24
#define NV095_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV095_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV095_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV095_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV095_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV095_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV095_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV095_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV095_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV095_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV095_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV095_BLEND_DESTBLEND                                      31:28
#define NV095_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV095_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV095_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV095_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV095_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV095_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV095_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV095_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV095_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV095_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV095_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV095_CONTROL0                                             (0x0000033C)
#define NV095_CONTROL0_ALPHAREF                                    7:0
#define NV095_CONTROL0_ALPHAFUNC                                   11:8
#define NV095_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV095_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV095_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV095_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV095_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV095_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV095_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV095_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV095_CONTROL0_ALPHATESTENABLE                             12:12
#define NV095_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV095_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV095_CONTROL0_ORIGIN                                      13:13
#define NV095_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV095_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV095_CONTROL0_ZENABLE                                     15:14
#define NV095_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV095_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV095_CONTROL0_ZFUNC                                       19:16
#define NV095_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV095_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV095_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV095_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV095_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV095_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV095_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV095_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV095_CONTROL0_CULLMODE                                    21:20
#define NV095_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV095_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV095_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV095_CONTROL0_DITHERENABLE                                22:22
#define NV095_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV095_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV095_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV095_CONTROL0_ZWRITEENABLE                                24:24
#define NV095_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV095_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV095_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV095_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV095_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV095_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV095_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV095_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV095_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV095_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV095_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV095_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV095_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV095_CONTROL0_Z_FORMAT                                    31:30
#define NV095_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV095_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV095_CONTROL1                                             (0x00000340)
#define NV095_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV095_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV095_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV095_CONTROL1_STENCIL_FUNC                                7:4
#define NV095_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV095_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV095_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV095_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV095_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV095_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV095_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV095_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV095_CONTROL1_STENCIL_REF                                 15:8
#define NV095_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV095_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV095_CONTROL2                                             (0x00000344)
#define NV095_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV095_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV095_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV095_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV095_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV095_FOG_COLOR                                            (0x00000348)
#define NV095_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV095_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV095_TLMTVERTEX_COLOR_RED                                 23:16
#define NV095_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV095_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV095_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV095_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV095_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV095_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV095_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV095_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV095_DRAW_PRIMITIVE_I0                                    3:0
#define NV095_DRAW_PRIMITIVE_I1                                    7:4
#define NV095_DRAW_PRIMITIVE_I2                                    11:8
#define NV095_DRAW_PRIMITIVE_I3                                    15:12
#define NV095_DRAW_PRIMITIVE_I4                                    19:16
#define NV095_DRAW_PRIMITIVE_I5                                    31:20

// This typedef really should be the same as Nv12CelsiusPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.


typedef NvV32 Nv096Typedef;


/* class NV15_CELSIUS_PRIMITIVE */
#define  NV15_CELSIUS_PRIMITIVE                                    (0x00000096)
/* NvNotification[] elements */
#define NV096_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV096_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV096_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV096_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV096_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV096_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV096_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved00[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved01[0xc/4];
    NvV32 SyncSetRead;
    NvV32 SyncSetWrite;
    NvV32 SyncSetModulo;
    NvV32 SyncIncrementWrite;
    NvV32 SyncStall;
    NvV32 Reserved17[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved02[0x3c/4];
    NvV32 SetContextDmaNotifies;
    NvV32 SetContextDmaA;
    NvV32 SetContextDmaB;
    NvV32 SetContextDmaVertex;
    NvV32 SetContextDmaState;
    NvV32 SetContextDmaColor;
    NvV32 SetContextDmaZeta;
    NvV32 Reserved03[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved04[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved05[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvV32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvV32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvV32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvV32 SetStencilFuncRef;
    NvV32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvV32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvV32 SetMaterialEmission[3];
    NvV32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
        NvV32 S;
        NvV32 T;
        NvV32 R;
        NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvV32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved06[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved07[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved08[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved09[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0b[0xc8/4];
    struct {
        NvF32 AmbientColor[3];
        NvF32 DiffuseColor[3];
        NvF32 SpecularColor[3];
        NvF32 LocalRange;
        NvF32 InfiniteHalfVector[3];
        NvF32 InfiniteDirection[3];
        NvF32 SpotFalloff[3];
        NvF32 SpotDirection[4];
        NvF32 LocalPosition[3];
        NvF32 LocalAttenuation[3];
        NvV32 Reserved0c[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0d[0xc/4];
    NvF32 SetVertex4f[4];
    NvS16 SetVertex4s[4];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0e[0x4/4];
    NvS16 SetNormal3s[3];
    NvV16 Reserved0f[0xa/2];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvV32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvV32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS16 SetTexcoord0_2s[2];
    NvV32 Reserved10[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS16 SetTexcoord0_4s[4];
    NvF32 SetTexcoord1_2f[2];
    NvS16 SetTexcoord1_2s[2];
    NvV32 Reserved11[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS16 SetTexcoord1_4s[4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved12[0x4/4];
    NvV32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 Reserved13[0xbc/4];
    NvV32 SetBeginEnd;
    NvV16 ArrayElement16[256];
    NvV32 Reserved14[0xfc/4];
    NvV32 SetBeginEnd2;
    NvV32 ArrayElement32[64];
    NvV32 Reserved15[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 Reserved1628[0x1d4/4];
    NvV32 SetBeginEnd4;
    NvV32 InlineArray[512];
} Nv12CelsiusPrimitive;


#define NV096_TYPEDEF                                      Nv12CelsiusPrimitive
#define NV096_SET_OBJECT                                           (0x00000000)


#define NV096_DEBUG_INIT(i)                                        (0x00001600+(i)*4)


#define NV096_FLUSH                                                        0x00000728


#define NV096_NO_OPERATION                                                 0x00000100


#define NV096_NOTIFY                                                       0x00000104
#define NV096_NOTIFY_TYPE                                                        23:0
#define NV096_NOTIFY_TYPE_WRITE_ONLY                                       0x00000000
#define NV096_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                0x00000001


#define NV096_SET_WARNING_ENABLE                                           0x00000108
#define NV096_SET_WARNING_ENABLE_V                                               23:0
#define NV096_SET_WARNING_ENABLE_V_FALSE                                   0x00000000
#define NV096_SET_WARNING_ENABLE_V_TRUE                                    0x00000001


#define NV096_GET_STATE                                                    0x0000010c
#define NV096_GET_STATE_GETSTATE                                                 31:0
#define NV096_GET_STATE_GETSTATE_ALL_STATE                                 0x00000001
#define NV096_GET_STATE_PUTSTATE_ALL_STATE                                 0x00000002
#define NV096_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                   0x00000003
#define NV096_GET_STATE_GETSTATE_RENDERING_STATE                           0x00000004
#define NV096_GET_STATE_GETSTATE_GEOMETRY_STATE                            0x00000005
#define NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM                        0x00000006
#define NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM                          0x00000007

#define NV096_WAIT_FOR_IDLE                                                0x00000110

#define NV096_SYNC_SET_READ                                                0x00000120
#define NV096_SYNC_SET_WRITE                                               0x00000124
#define NV096_SYNC_SET_MODULO                                              0x00000128
#define NV096_SYNC_INCREMENT_WRITE                                         0x0000012c
#define NV096_SYNC_STALL                                                   0x00000130

#define NV096_PM_TRIGGER                                                   0x00000140


#define NV096_SET_CONTEXT_DMA_NOTIFIES                                     0x00000180


#define NV096_SET_CONTEXT_DMA_A                                            0x00000184


#define NV096_SET_CONTEXT_DMA_B                                            0x00000188


#define NV096_SET_CONTEXT_DMA_VERTEX                                       0x0000018c


#define NV096_SET_CONTEXT_DMA_STATE                                        0x00000190


#define NV096_SET_CONTEXT_DMA_COLOR                                        0x00000194


#define NV096_SET_CONTEXT_DMA_ZETA                                         0x00000198


#define NV096_SET_SURFACE_CLIP_HORIZONTAL                                  0x00000200
#define NV096_SET_SURFACE_CLIP_HORIZONTAL_X                                      15:0
#define NV096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                 31:16


#define NV096_SET_SURFACE_CLIP_VERTICAL                                    0x00000204
#define NV096_SET_SURFACE_CLIP_VERTICAL_Y                                        15:0
#define NV096_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                  31:16


#define NV096_SET_SURFACE_FORMAT                                           0x00000208
#define NV096_SET_SURFACE_FORMAT_COLOR                                            7:0
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                0x00000001
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                0x00000002
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                           0x00000003
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                0x00000004
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                0x00000005
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            0x00000006
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            0x00000007
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000008
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_B8                               0x00000009
#define NV096_SET_SURFACE_FORMAT_COLOR_LE_G8B8                             0x0000000A
#define NV096_SET_SURFACE_FORMAT_TYPE                                            15:8
#define NV096_SET_SURFACE_FORMAT_TYPE_PITCH                                0x00000001
#define NV096_SET_SURFACE_FORMAT_TYPE_SWIZZLE                              0x00000002
#define NV096_SET_SURFACE_FORMAT_WIDTH                                          23:16
#define NV096_SET_SURFACE_FORMAT_WIDTH_1                                   0x00000000
#define NV096_SET_SURFACE_FORMAT_WIDTH_2                                   0x00000001
#define NV096_SET_SURFACE_FORMAT_WIDTH_4                                   0x00000002
#define NV096_SET_SURFACE_FORMAT_WIDTH_8                                   0x00000003
#define NV096_SET_SURFACE_FORMAT_WIDTH_16                                  0x00000004
#define NV096_SET_SURFACE_FORMAT_WIDTH_32                                  0x00000005
#define NV096_SET_SURFACE_FORMAT_WIDTH_64                                  0x00000006
#define NV096_SET_SURFACE_FORMAT_WIDTH_128                                 0x00000007
#define NV096_SET_SURFACE_FORMAT_WIDTH_256                                 0x00000008
#define NV096_SET_SURFACE_FORMAT_WIDTH_512                                 0x00000009
#define NV096_SET_SURFACE_FORMAT_WIDTH_1024                                0x0000000A
#define NV096_SET_SURFACE_FORMAT_WIDTH_2048                                0x0000000B
#define NV096_SET_SURFACE_FORMAT_HEIGHT                                         31:24
#define NV096_SET_SURFACE_FORMAT_HEIGHT_1                                  0x00000000
#define NV096_SET_SURFACE_FORMAT_HEIGHT_2                                  0x00000001
#define NV096_SET_SURFACE_FORMAT_HEIGHT_4                                  0x00000002
#define NV096_SET_SURFACE_FORMAT_HEIGHT_8                                  0x00000003
#define NV096_SET_SURFACE_FORMAT_HEIGHT_16                                 0x00000004
#define NV096_SET_SURFACE_FORMAT_HEIGHT_32                                 0x00000005
#define NV096_SET_SURFACE_FORMAT_HEIGHT_64                                 0x00000006
#define NV096_SET_SURFACE_FORMAT_HEIGHT_128                                0x00000007
#define NV096_SET_SURFACE_FORMAT_HEIGHT_256                                0x00000008
#define NV096_SET_SURFACE_FORMAT_HEIGHT_512                                0x00000009
#define NV096_SET_SURFACE_FORMAT_HEIGHT_1024                               0x0000000A
#define NV096_SET_SURFACE_FORMAT_HEIGHT_2048                               0x0000000B


#define NV096_SET_SURFACE_PITCH                                            0x0000020c
#define NV096_SET_SURFACE_PITCH_COLOR                                            15:0
#define NV096_SET_SURFACE_PITCH_ZETA                                            31:16


#define NV096_SET_SURFACE_COLOR_OFFSET                                     0x00000210
#define NV096_SET_SURFACE_COLOR_OFFSET_V                                         31:0


#define NV096_SET_SURFACE_ZETA_OFFSET                                      0x00000214
#define NV096_SET_SURFACE_ZETA_OFFSET_V                                          31:0


#define NV096_SET_TEXTURE_OFFSET(i)                                (0x00000218+(i)*4)
#define NV096_SET_TEXTURE_OFFSET_V                                               31:0


#define NV096_SET_TEXTURE_FORMAT(i)                                (0x00000220+(i)*4)
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA                                      1:0
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                   2:2
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                      0x00000000
#define NV096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                       0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                       4:3
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                         0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH                                       6:5
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                         0x00000001
#define NV096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_COLOR                                           11:7
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_Y8                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_AY8                              0x00000001
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                         0x00000002
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                         0x00000003
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                         0x00000004
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                           0x00000005
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                         0x00000006
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                         0x00000007
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                      0x00000008
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                        0x00000009
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                      0x0000000A
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                      0x0000000B
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                    0x0000000C
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                   0x0000000E
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                   0x0000000F
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                   0x00000010
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                     0x00000011
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                   0x00000012
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                         0x00000013
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                        0x00000014
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                      0x00000015
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                       0x00000016
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                       0x00000017
#define NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                     0x00000018
#define NV096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                  15:12
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U                                    19:16
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                             0x00000000
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                             0x00000003
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                            0x00000004
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                            0x00000005
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                            0x00000006
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                           0x00000007
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                           0x00000008
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                           0x00000009
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                          0x0000000A
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                          0x0000000B
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V                                    23:20
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                             0x00000000
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                             0x00000001
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                             0x00000002
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                             0x00000003
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                            0x00000004
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                            0x00000005
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                            0x00000006
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                           0x00000007
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                           0x00000008
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                           0x00000009
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                          0x0000000A
#define NV096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                          0x0000000B
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                                26:24
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                      0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                    0x00000002
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                     0x00000003
#define NV096_SET_TEXTURE_FORMAT_WRAPU                                          27:27
#define NV096_SET_TEXTURE_FORMAT_WRAPU_FALSE                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_WRAPU_TRUE                                0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                                30:28
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                      0x00000001
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                    0x00000002
#define NV096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                     0x00000003
#define NV096_SET_TEXTURE_FORMAT_WRAPV                                          31:31
#define NV096_SET_TEXTURE_FORMAT_WRAPV_FALSE                               0x00000000
#define NV096_SET_TEXTURE_FORMAT_WRAPV_TRUE                                0x00000001


#define NV096_SET_TEXTURE_CONTROL0(i)                              (0x00000228+(i)*4)
#define NV096_SET_TEXTURE_CONTROL0_ENABLE                                       30:30
#define NV096_SET_TEXTURE_CONTROL0_ENABLE_FALSE                            0x00000000
#define NV096_SET_TEXTURE_CONTROL0_ENABLE_TRUE                             0x00000001
#define NV096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                29:18
#define NV096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                 17:6
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                  5:4
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                         0x00000000
#define NV096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                         0x00000001
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                             3:3
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                0x00000000
#define NV096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                 0x00000001
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                              2:2
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                 0x00000000
#define NV096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                  0x00000001
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                            1:0
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE               0x00000000
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA               0x00000001
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                0x00000002
#define NV096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                0x00000003


#define NV096_SET_TEXTURE_CONTROL1(i)                              (0x00000230+(i)*4)
#define NV096_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                  31:16
#define NV096_SET_TEXTURE_CONTROL1_ZERO                                          15:0


#define NV096_SET_TEXTURE_CONTROL2(i)                              (0x00000238+(i)*4)
#define NV096_SET_TEXTURE_CONTROL2_PERTURB_DU                                    11:0
#define NV096_SET_TEXTURE_CONTROL2_PERTURB_DV                                   23:12
#define NV096_SET_TEXTURE_CONTROL2_IMAGE_LODF                                   31:24


#define NV096_SET_TEXTURE_IMAGE_RECT(i)                            (0x00000240+(i)*4)
#define NV096_SET_TEXTURE_IMAGE_RECT_WIDTH                                      31:16
#define NV096_SET_TEXTURE_IMAGE_RECT_HEIGHT                                      15:0


#define NV096_SET_TEXTURE_FILTER(i)                                (0x00000248+(i)*4)
#define NV096_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                   23:0
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN                                     27:24
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                        0x00000001
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                         0x00000002
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                     0x00000003
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                      0x00000004
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST               0x00000005
#define NV096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR                0x00000006
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG                                     31:28
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                        0x00000001
#define NV096_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                         0x00000002


#define NV096_SET_TEXTURE_PALETTE(i)                               (0x00000250+(i)*4)
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA                                     5:0
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                            0x00000000
#define NV096_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                            0x00000001
#define NV096_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                 31:6


#define NV096_SET_COMBINER_ALPHA_ICW(i)                            (0x00000260+(i)*4)
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP                                      31:29
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA                                    28:28
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE                                   27:24
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP                                      23:21
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA                                    20:20
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE                                   19:16
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP                                      15:13
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA                                    12:12
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE                                    11:8
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP                                        7:5
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA                                      4:4
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE                                     3:0
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV096_SET_COMBINER_COLOR_ICW(i)                            (0x00000268+(i)*4)
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP                                      31:29
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA                                    28:28
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE                                   27:24
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP                                      23:21
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA                                    20:20
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE                                   19:16
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP                                      15:13
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA                                    12:12
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE                                    11:8
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                        0x0000000D
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP                                        7:5
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY               0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                 0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                   0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                   0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                 0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                 0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                 0x00000006
#define NV096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                   0x00000007
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA                                      4:4
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                         0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                          0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE                                     3:0
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                        0x00000000
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                        0x00000001
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                        0x00000002
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                        0x00000003
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                        0x00000004
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                        0x00000005
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                        0x00000008
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                        0x00000009
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                        0x0000000C
#define NV096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                        0x0000000D


#define NV096_SET_COMBINE_FACTOR(i)                                (0x00000270+(i)*4)
#define NV096_SET_COMBINE_FACTOR_BLUE                                             7:0
#define NV096_SET_COMBINE_FACTOR_GREEN                                           15:8
#define NV096_SET_COMBINE_FACTOR_RED                                            23:16
#define NV096_SET_COMBINE_FACTOR_ALPHA                                          31:24


#define NV096_SET_COMBINER_ALPHA_OCW(i)                            (0x00000278+(i)*4)
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION                                  31:15
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                     0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                0x00000001
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                0x00000002
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS           0x00000003
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1               0x00000006
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                 14:14
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                      0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                       0x00000001
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST                                     11:8
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST                                       7:4
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                          0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                          0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                          0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                          0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                          0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                          0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                          0x0000000D
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST                                       3:0
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                          0x00000000
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                          0x00000004
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                          0x00000005
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                          0x00000008
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                          0x00000009
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                          0x0000000C
#define NV096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                          0x0000000D


#define NV096_SET_COMBINER0_COLOR_OCW                                      0x00000280
#define NV096_SET_COMBINER0_COLOR_OCW_ZERO                                      31:27
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION                                 26:15
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                                14:14
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST                                    11:8
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST                                      7:4
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST                                      3:0
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV096_SET_COMBINER1_COLOR_OCW                                      0x00000284
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                           31:28
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                  0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                  0x00000002
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT                                27:27
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                       0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                       0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION                                 26:15
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                                14:14
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                             13:13
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                             12:12
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                  0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                   0x00000001
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST                                    11:8
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                        0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                        0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                        0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                        0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                        0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                        0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                        0x0000000D
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST                                      7:4
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                         0x0000000D
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST                                      3:0
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                         0x00000000
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                         0x00000004
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                         0x00000005
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                         0x00000008
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                         0x00000009
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                         0x0000000C
#define NV096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                         0x0000000D


#define NV096_SET_COMBINER_SPECULAR_FOG_CW0                                0x00000288
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                           31:29
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                             28:28
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                            27:24
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                           23:21
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                             20:20
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                            19:16
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                           15:13
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                             12:12
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                             11:8
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD           0x0000000F
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                             7:5
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                               4:4
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                              3:0
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT           0x0000000E
#define NV096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD           0x0000000F


#define NV096_SET_COMBINER_SPECULAR_FOG_CW1                                0x0000028c
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                           31:29
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                             28:28
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                            27:24
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                           23:21
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                             20:20
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                            19:16
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                           15:13
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                             12:12
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                   0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                             11:8
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                 0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                 0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                 0x00000002
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                 0x00000003
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                 0x00000004
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                 0x00000005
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                 0x00000008
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                 0x00000009
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                 0x0000000C
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                 0x0000000D
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                        7:7
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE           0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE            0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                6:6
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE   0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE    0x00000001
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12               5:0
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE  0x00000000
#define NV096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE   0x00000020


#define NV096_SET_CONTROL0                                                 0x00000290
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA                                   31:24
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                        0x00000000
#define NV096_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                         0x00000001
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE                                   23:20
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                        0x00000000
#define NV096_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                         0x00000001
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                 19:16
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                      0x00000000
#define NV096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                       0x00000001
#define NV096_SET_CONTROL0_Z_FORMAT                                             15:12
#define NV096_SET_CONTROL0_Z_FORMAT_FIXED                                  0x00000000
#define NV096_SET_CONTROL0_Z_FORMAT_FLOAT                                  0x00000001
#define NV096_SET_CONTROL0_WBUFFER_SELECT                                        11:8
#define NV096_SET_CONTROL0_WBUFFER_SELECT_0                                0x00000000
#define NV096_SET_CONTROL0_WBUFFER_SELECT_1                                0x00000001
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE                                   7:0
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                       0x00000001


#define NV096_SET_LIGHT_CONTROL                                            0x00000294
#define NV096_SET_LIGHT_CONTROL_LOCALEYE                                        31:16
#define NV096_SET_LIGHT_CONTROL_LOCALEYE_FALSE                             0x00000000
#define NV096_SET_LIGHT_CONTROL_LOCALEYE_TRUE                              0x00000001
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE                                 15:2
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                    0x00000000
#define NV096_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT                0x00000001
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                              1:1
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                 0x00000000
#define NV096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                  0x00000001
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                                0:0
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                   0x00000000
#define NV096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                    0x00000001


#define NV096_SET_COLOR_MATERIAL                                           0x00000298
#define NV096_SET_COLOR_MATERIAL_V                                               31:0
#define NV096_SET_COLOR_MATERIAL_V_DISABLED                                0x00000000
#define NV096_SET_COLOR_MATERIAL_V_EMISSION                                0x00000001
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT                                 0x00000002
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                        0x00000003
#define NV096_SET_COLOR_MATERIAL_V_DIFFUSE                                 0x00000004
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                        0x00000005
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                         0x00000006
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE                0x00000007
#define NV096_SET_COLOR_MATERIAL_V_SPECULAR                                0x00000008
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                       0x00000009
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                        0x0000000A
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR               0x0000000B
#define NV096_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                        0x0000000C
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR               0x0000000D
#define NV096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR                0x0000000E
#define NV096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR       0x0000000F


#define NV096_SET_FOG_MODE                                                 0x0000029c
#define NV096_SET_FOG_MODE_FOG_MODE                                              31:0
#define NV096_SET_FOG_MODE_FOG_MODE_LINEAR                                 0x00002601
#define NV096_SET_FOG_MODE_FOG_MODE_EXP                                    0x00000800
#define NV096_SET_FOG_MODE_FOG_MODE_EXP2                                   0x00000801
#define NV096_SET_FOG_MODE_FOG_MODE_EXP_ABS                                0x00000802
#define NV096_SET_FOG_MODE_FOG_MODE_EXP2_ABS                               0x00000803


#define NV096_SET_FOG_GEN_MODE                                             0x000002a0
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE                                      31:0
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                      0x00000000
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                         0x00000001
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                         0x00000002
#define NV096_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                     0x00000003


#define NV096_SET_FOG_ENABLE                                               0x000002a4
#define NV096_SET_FOG_ENABLE_V                                                   31:0
#define NV096_SET_FOG_ENABLE_V_FALSE                                       0x00000000
#define NV096_SET_FOG_ENABLE_V_TRUE                                        0x00000001


#define NV096_SET_FOG_COLOR                                               0x000002a8
#define NV096_SET_FOG_COLOR_FOG_COLOR_RED                                        7:0
#define NV096_SET_FOG_COLOR_FOG_COLOR_GREEN                                     15:8
#define NV096_SET_FOG_COLOR_FOG_COLOR_BLUE                                     23:16
#define NV096_SET_FOG_COLOR_FOG_COLOR_ALPHA                                    31:24


#define NV096_SET_COLOR_KEY_COLOR(i)                               (0x000002ac+(i)*4)
#define NV096_SET_COLOR_KEY_COLOR_V                                              31:0


#define NV096_SET_WINDOW_CLIP_TYPE                                         0x000002b4
#define NV096_SET_WINDOW_CLIP_TYPE_V                                             31:0
#define NV096_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                             0x00000000
#define NV096_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                             0x00000001


#define NV096_SET_WINDOW_CLIP_HORIZONTAL(i)                        (0x000002c0+(i)*4)
#define NV096_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                    15:0
#define NV096_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                   31:16


#define NV096_SET_WINDOW_CLIP_VERTICAL(i)                          (0x000002e0+(i)*4)
#define NV096_SET_WINDOW_CLIP_VERTICAL_YMIN                                      15:0
#define NV096_SET_WINDOW_CLIP_VERTICAL_YMAX                                     31:16


#define NV096_SET_ALPHA_TEST_ENABLE                                        0x00000300
#define NV096_SET_ALPHA_TEST_ENABLE_V                                            31:0
#define NV096_SET_ALPHA_TEST_ENABLE_V_FALSE                                0x00000000
#define NV096_SET_ALPHA_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV096_SET_BLEND_ENABLE                                             0x00000304
#define NV096_SET_BLEND_ENABLE_V                                                 31:0
#define NV096_SET_BLEND_ENABLE_V_FALSE                                     0x00000000
#define NV096_SET_BLEND_ENABLE_V_TRUE                                      0x00000001


#define NV096_SET_CULL_FACE_ENABLE                                         0x00000308
#define NV096_SET_CULL_FACE_ENABLE_V                                             31:0
#define NV096_SET_CULL_FACE_ENABLE_V_FALSE                                 0x00000000
#define NV096_SET_CULL_FACE_ENABLE_V_TRUE                                  0x00000001


#define NV096_SET_DEPTH_TEST_ENABLE                                        0x0000030c
#define NV096_SET_DEPTH_TEST_ENABLE_V                                            31:0
#define NV096_SET_DEPTH_TEST_ENABLE_V_FALSE                                0x00000000
#define NV096_SET_DEPTH_TEST_ENABLE_V_TRUE                                 0x00000001


#define NV096_SET_DITHER_ENABLE                                            0x00000310
#define NV096_SET_DITHER_ENABLE_V                                                31:0
#define NV096_SET_DITHER_ENABLE_V_FALSE                                    0x00000000
#define NV096_SET_DITHER_ENABLE_V_TRUE                                     0x00000001


#define NV096_SET_LIGHTING_ENABLE                                          0x00000314
#define NV096_SET_LIGHTING_ENABLE_V                                              31:0
#define NV096_SET_LIGHTING_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_LIGHTING_ENABLE_V_TRUE                                   0x00000001


#define NV096_SET_POINT_PARAMS_ENABLE                                      0x00000318
#define NV096_SET_POINT_PARAMS_ENABLE_V                                          31:0
#define NV096_SET_POINT_PARAMS_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_POINT_PARAMS_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_POINT_SMOOTH_ENABLE                                      0x0000031c
#define NV096_SET_POINT_SMOOTH_ENABLE_V                                          31:0
#define NV096_SET_POINT_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_POINT_SMOOTH_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_LINE_SMOOTH_ENABLE                                       0x00000320
#define NV096_SET_LINE_SMOOTH_ENABLE_V                                           31:0
#define NV096_SET_LINE_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV096_SET_LINE_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV096_SET_POLY_SMOOTH_ENABLE                                       0x00000324
#define NV096_SET_POLY_SMOOTH_ENABLE_V                                           31:0
#define NV096_SET_POLY_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV096_SET_POLY_SMOOTH_ENABLE_V_TRUE                                0x00000001


#define NV096_SET_SKIN_ENABLE                                              0x00000328
#define NV096_SET_SKIN_ENABLE_V                                                  31:0
#define NV096_SET_SKIN_ENABLE_V_FALSE                                      0x00000000
#define NV096_SET_SKIN_ENABLE_V_TRUE                                       0x00000001


#define NV096_SET_STENCIL_TEST_ENABLE                                      0x0000032c
#define NV096_SET_STENCIL_TEST_ENABLE_V                                          31:0
#define NV096_SET_STENCIL_TEST_ENABLE_V_FALSE                              0x00000000
#define NV096_SET_STENCIL_TEST_ENABLE_V_TRUE                               0x00000001


#define NV096_SET_POLY_OFFSET_POINT_ENABLE                                 0x00000330
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V                                     31:0
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                         0x00000000
#define NV096_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                          0x00000001


#define NV096_SET_POLY_OFFSET_LINE_ENABLE                                  0x00000334
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V                                      31:0
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                          0x00000000
#define NV096_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                           0x00000001


#define NV096_SET_POLY_OFFSET_FILL_ENABLE                                  0x00000338
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V                                      31:0
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                          0x00000000
#define NV096_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                           0x00000001


#define NV096_SET_ALPHA_FUNC                                               0x0000033c
#define NV096_SET_ALPHA_FUNC_V                                                   31:0
#define NV096_SET_ALPHA_FUNC_V_NEVER                                       0x00000200
#define NV096_SET_ALPHA_FUNC_V_LESS                                        0x00000201
#define NV096_SET_ALPHA_FUNC_V_EQUAL                                       0x00000202
#define NV096_SET_ALPHA_FUNC_V_LEQUAL                                      0x00000203
#define NV096_SET_ALPHA_FUNC_V_GREATER                                     0x00000204
#define NV096_SET_ALPHA_FUNC_V_NOTEQUAL                                    0x00000205
#define NV096_SET_ALPHA_FUNC_V_GEQUAL                                      0x00000206
#define NV096_SET_ALPHA_FUNC_V_ALWAYS                                      0x00000207


#define NV096_SET_ALPHA_REF                                                0x00000340


#define NV096_SET_BLEND_FUNC_SFACTOR                                       0x00000344
#define NV096_SET_BLEND_FUNC_SFACTOR_V                                           31:0
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ZERO                                0x00000000
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE                                 0x00000001
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                           0x00000300
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                           0x00000302
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV096_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                           0x00000304
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV096_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                           0x00000306
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                  0x00000308
#define NV096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV096_SET_BLEND_FUNC_DFACTOR                                       0x00000348
#define NV096_SET_BLEND_FUNC_DFACTOR_V                                           31:0
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ZERO                                0x00000000
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE                                 0x00000001
#define NV096_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                           0x00000300
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                 0x00000301
#define NV096_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                           0x00000302
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                 0x00000303
#define NV096_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                           0x00000304
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                 0x00000305
#define NV096_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                           0x00000306
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                 0x00000307
#define NV096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                      0x00008001
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR            0x00008002
#define NV096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                      0x00008003
#define NV096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA            0x00008004


#define NV096_SET_BLEND_COLOR                                              0x0000034c
#define NV096_SET_BLEND_COLOR_V                                                  31:0


#define NV096_SET_BLEND_EQUATION                                           0x00000350
#define NV096_SET_BLEND_EQUATION_V                                               31:0
#define NV096_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                           0x0000800A
#define NV096_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                   0x0000800B
#define NV096_SET_BLEND_EQUATION_V_FUNC_ADD                                0x00008006
#define NV096_SET_BLEND_EQUATION_V_MIN                                     0x00008007
#define NV096_SET_BLEND_EQUATION_V_MAX                                     0x00008008


#define NV096_SET_DEPTH_FUNC                                               0x00000354
#define NV096_SET_DEPTH_FUNC_V                                                   31:0
#define NV096_SET_DEPTH_FUNC_V_NEVER                                       0x00000200
#define NV096_SET_DEPTH_FUNC_V_LESS                                        0x00000201
#define NV096_SET_DEPTH_FUNC_V_EQUAL                                       0x00000202
#define NV096_SET_DEPTH_FUNC_V_LEQUAL                                      0x00000203
#define NV096_SET_DEPTH_FUNC_V_GREATER                                     0x00000204
#define NV096_SET_DEPTH_FUNC_V_NOTEQUAL                                    0x00000205
#define NV096_SET_DEPTH_FUNC_V_GEQUAL                                      0x00000206
#define NV096_SET_DEPTH_FUNC_V_ALWAYS                                      0x00000207


#define NV096_SET_COLOR_MASK                                               0x00000358
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                 31:24
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                       0x00000001
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE                                   23:16
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                        0x00000000
#define NV096_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                         0x00000001
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                  15:8
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                      0x00000000
#define NV096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                       0x00000001
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                    7:0
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                       0x00000000
#define NV096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                        0x00000001


#define NV096_SET_DEPTH_MASK                                               0x0000035c
#define NV096_SET_DEPTH_MASK_V                                                   31:0
#define NV096_SET_DEPTH_MASK_V_FALSE                                       0x00000000
#define NV096_SET_DEPTH_MASK_V_TRUE                                        0x00000001


#define NV096_SET_STENCIL_MASK                                             0x00000360
#define NV096_SET_STENCIL_MASK_V                                                 31:0


#define NV096_SET_STENCIL_FUNC                                             0x00000364
#define NV096_SET_STENCIL_FUNC_V                                                 31:0
#define NV096_SET_STENCIL_FUNC_V_NEVER                                     0x00000200
#define NV096_SET_STENCIL_FUNC_V_LESS                                      0x00000201
#define NV096_SET_STENCIL_FUNC_V_EQUAL                                     0x00000202
#define NV096_SET_STENCIL_FUNC_V_LEQUAL                                    0x00000203
#define NV096_SET_STENCIL_FUNC_V_GREATER                                   0x00000204
#define NV096_SET_STENCIL_FUNC_V_NOTEQUAL                                  0x00000205
#define NV096_SET_STENCIL_FUNC_V_GEQUAL                                    0x00000206
#define NV096_SET_STENCIL_FUNC_V_ALWAYS                                    0x00000207


#define NV096_SET_STENCIL_FUNC_REF                                         0x00000368
#define NV096_SET_STENCIL_FUNC_REF_V                                             31:0


#define NV096_SET_STENCIL_FUNC_MASK                                        0x0000036c
#define NV096_SET_STENCIL_FUNC_MASK_V                                            31:0


#define NV096_SET_STENCIL_OP_FAIL                                          0x00000370
#define NV096_SET_STENCIL_OP_FAIL_V                                              31:0
#define NV096_SET_STENCIL_OP_FAIL_V_KEEP                                   0x00001E00
#define NV096_SET_STENCIL_OP_FAIL_V_ZERO                                   0x00000000
#define NV096_SET_STENCIL_OP_FAIL_V_REPLACE                                0x00001E01
#define NV096_SET_STENCIL_OP_FAIL_V_INCRSAT                                0x00001E02
#define NV096_SET_STENCIL_OP_FAIL_V_DECRSAT                                0x00001E03
#define NV096_SET_STENCIL_OP_FAIL_V_INVERT                                 0x0000150A
#define NV096_SET_STENCIL_OP_FAIL_V_INCR                                   0x00008507
#define NV096_SET_STENCIL_OP_FAIL_V_DECR                                   0x00008508


#define NV096_SET_STENCIL_OP_ZFAIL                                         0x00000374
#define NV096_SET_STENCIL_OP_ZFAIL_V                                             31:0
#define NV096_SET_STENCIL_OP_ZFAIL_V_KEEP                                  0x00001E00
#define NV096_SET_STENCIL_OP_ZFAIL_V_ZERO                                  0x00000000
#define NV096_SET_STENCIL_OP_ZFAIL_V_REPLACE                               0x00001E01
#define NV096_SET_STENCIL_OP_ZFAIL_V_INCRSAT                               0x00001E02
#define NV096_SET_STENCIL_OP_ZFAIL_V_DECRSAT                               0x00001E03
#define NV096_SET_STENCIL_OP_ZFAIL_V_INVERT                                0x0000150A
#define NV096_SET_STENCIL_OP_ZFAIL_V_INCR                                  0x00008507
#define NV096_SET_STENCIL_OP_ZFAIL_V_DECR                                  0x00008508


#define NV096_SET_STENCIL_OP_ZPASS                                         0x00000378
#define NV096_SET_STENCIL_OP_ZPASS_V                                             31:0
#define NV096_SET_STENCIL_OP_ZPASS_V_KEEP                                  0x00001E00
#define NV096_SET_STENCIL_OP_ZPASS_V_ZERO                                  0x00000000
#define NV096_SET_STENCIL_OP_ZPASS_V_REPLACE                               0x00001E01
#define NV096_SET_STENCIL_OP_ZPASS_V_INCRSAT                               0x00001E02
#define NV096_SET_STENCIL_OP_ZPASS_V_DECRSAT                               0x00001E03
#define NV096_SET_STENCIL_OP_ZPASS_V_INVERT                                0x0000150A
#define NV096_SET_STENCIL_OP_ZPASS_V_INCR                                  0x00008507
#define NV096_SET_STENCIL_OP_ZPASS_V_DECR                                  0x00008508


#define NV096_SET_SHADE_MODE                                               0x0000037c
#define NV096_SET_SHADE_MODE_V                                                   31:0
#define NV096_SET_SHADE_MODE_V_FLAT                                        0x00001D00
#define NV096_SET_SHADE_MODE_V_SMOOTH                                      0x00001D01


#define NV096_SET_LINE_WIDTH                                               0x00000380
#define NV096_SET_LINE_WIDTH_V                                                   31:0


#define NV096_SET_POLYGON_OFFSET_SCALE_FACTOR                              0x00000384
#define NV096_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                  31:0


#define NV096_SET_POLYGON_OFFSET_BIAS                                      0x00000388
#define NV096_SET_POLYGON_OFFSET_BIAS_V                                          31:0


#define NV096_SET_FRONT_POLYGON_MODE                                       0x0000038c
#define NV096_SET_FRONT_POLYGON_MODE_V                                           31:0
#define NV096_SET_FRONT_POLYGON_MODE_V_POINT                               0x00001B00
#define NV096_SET_FRONT_POLYGON_MODE_V_LINE                                0x00001B01
#define NV096_SET_FRONT_POLYGON_MODE_V_FILL                                0x00001B02


#define NV096_SET_BACK_POLYGON_MODE                                        0x00000390
#define NV096_SET_BACK_POLYGON_MODE_V                                            31:0
#define NV096_SET_BACK_POLYGON_MODE_V_POINT                                0x00001B00
#define NV096_SET_BACK_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV096_SET_BACK_POLYGON_MODE_V_FILL                                 0x00001B02


#define NV096_SET_CLIP_MIN                                                 0x00000394
#define NV096_SET_CLIP_MIN_V                                                     31:0


#define NV096_SET_CLIP_MAX                                                 0x00000398
#define NV096_SET_CLIP_MAX_V                                                     31:0


#define NV096_SET_CULL_FACE                                                0x0000039c
#define NV096_SET_CULL_FACE_V                                                    31:0
#define NV096_SET_CULL_FACE_V_FRONT                                        0x00000404
#define NV096_SET_CULL_FACE_V_BACK                                         0x00000405
#define NV096_SET_CULL_FACE_V_FRONT_AND_BACK                               0x00000408


#define NV096_SET_FRONT_FACE                                               0x000003a0
#define NV096_SET_FRONT_FACE_V                                                   31:0
#define NV096_SET_FRONT_FACE_V_CW                                          0x00000900
#define NV096_SET_FRONT_FACE_V_CCW                                         0x00000901


#define NV096_SET_NORMALIZATION_ENABLE                                     0x000003a4
#define NV096_SET_NORMALIZATION_ENABLE_V                                         31:0
#define NV096_SET_NORMALIZATION_ENABLE_V_FALSE                             0x00000000
#define NV096_SET_NORMALIZATION_ENABLE_V_TRUE                              0x00000001


#define NV096_SET_MATERIAL_EMISSION(i)                             (0x000003a8+(i)*4)


#define NV096_SET_MATERIAL_ALPHA                                           0x000003b4


#define NV096_SET_SPECULAR_ENABLE                                          0x000003b8
#define NV096_SET_SPECULAR_ENABLE_V                                              31:0
#define NV096_SET_SPECULAR_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_SPECULAR_ENABLE_V_TRUE                                   0x00000001


#define NV096_SET_LIGHT_ENABLE_MASK                                        0x000003bc
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0                                        1:0
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1                                        3:2
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2                                        5:4
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3                                        7:6
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4                                        9:8
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5                                      11:10
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6                                      13:12
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                            0x00000003
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7                                      15:14
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                             0x00000000
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                        0x00000001
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                           0x00000002
#define NV096_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                            0x00000003


#define NV096_SET_TEXGEN_S(i)                                     (0x000003c0+(i)*16)
#define NV096_SET_TEXGEN_S_V                                                     31:0
#define NV096_SET_TEXGEN_S_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_S_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_S_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_S_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_S_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_S_V_SPHERE_MAP                                    0x00002402
#define NV096_SET_TEXGEN_S_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_T(i)                                     (0x000003c4+(i)*16)
#define NV096_SET_TEXGEN_T_V                                                     31:0
#define NV096_SET_TEXGEN_T_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_T_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_T_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_T_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_T_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_T_V_SPHERE_MAP                                    0x00002402
#define NV096_SET_TEXGEN_T_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_R(i)                                     (0x000003c8+(i)*16)
#define NV096_SET_TEXGEN_R_V                                                     31:0
#define NV096_SET_TEXGEN_R_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_R_V_NORMAL_MAP                                    0x00008511
#define NV096_SET_TEXGEN_R_V_REFLECTION_MAP                                0x00008512
#define NV096_SET_TEXGEN_R_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_R_V_OBJECT_LINEAR                                 0x00002401
#define NV096_SET_TEXGEN_R_V_EMBOSS                                        0x0000855F


#define NV096_SET_TEXGEN_Q(i)                                     (0x000003cc+(i)*16)
#define NV096_SET_TEXGEN_Q_V                                                     31:0
#define NV096_SET_TEXGEN_Q_V_DISABLE                                       0x00000000
#define NV096_SET_TEXGEN_Q_V_EYE_LINEAR                                    0x00002400
#define NV096_SET_TEXGEN_Q_V_OBJECT_LINEAR                                 0x00002401


#define NV096_SET_TEXTURE_MATRIX0_ENABLE                                   0x000003e0
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V                                       31:0
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                           0x00000000
#define NV096_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                            0x00000001


#define NV096_SET_TEXTURE_MATRIX1_ENABLE                                   0x000003e4
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V                                       31:0
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                           0x00000000
#define NV096_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                            0x00000001


#define NV096_SET_TLMODE                                                   0x000003e8
#define NV096_SET_TLMODE_PASSTHROUGH                                              0:0
#define NV096_SET_TLMODE_PASSTHROUGH_TRUE                                  0x00000001
#define NV096_SET_TLMODE_PASSTHROUGH_FALSE                                 0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_0                                               1:1
#define NV096_SET_TLMODE_W_DIVIDE_0_DISABLE                                0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_0_ENABLE                                 0x00000001
#define NV096_SET_TLMODE_W_DIVIDE_1                                               2:2
#define NV096_SET_TLMODE_W_DIVIDE_1_DISABLE                                0x00000000
#define NV096_SET_TLMODE_W_DIVIDE_1_ENABLE                                 0x00000001


#define NV096_SET_POINT_SIZE                                               0x000003ec
#define NV096_SET_POINT_SIZE_V                                                   31:0


#define NV096_SET_SWATH_WIDTH                                              0x000003f0
#define NV096_SET_SWATH_WIDTH_V                                                  31:0
#define NV096_SET_SWATH_WIDTH_V_8                                          0x00000000
#define NV096_SET_SWATH_WIDTH_V_16                                         0x00000001
#define NV096_SET_SWATH_WIDTH_V_32                                         0x00000002
#define NV096_SET_SWATH_WIDTH_V_64                                         0x00000003


#define NV096_SET_FLAT_SHADE_OP                                            0x000003f4
#define NV096_SET_FLAT_SHADE_OP_V                                                31:0
#define NV096_SET_FLAT_SHADE_OP_V_LAST_VTX                                 0x00000000
#define NV096_SET_FLAT_SHADE_OP_V_FIRST_VTX                                0x00000001


#define NV096_SET_MODEL_VIEW_MATRIX0(i)                            (0x00000400+(i)*4)


#define NV096_SET_MODEL_VIEW_MATRIX1(i)                            (0x00000440+(i)*4)


#define NV096_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                    (0x00000480+(i)*4)


#define NV096_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                    (0x000004c0+(i)*4)


#define NV096_SET_COMPOSITE_MATRIX(i)                              (0x00000500+(i)*4)


#define NV096_SET_TEXTURE_MATRIX0(i)                               (0x00000540+(i)*4)


#define NV096_SET_TEXTURE_MATRIX1(i)                               (0x00000580+(i)*4)


#define NV096_SET_TEXGEN_SPLANE0(i)                                (0x00000600+(i)*4)


#define NV096_SET_TEXGEN_TPLANE0(i)                                (0x00000610+(i)*4)


#define NV096_SET_TEXGEN_RPLANE0(i)                                (0x00000620+(i)*4)


#define NV096_SET_TEXGEN_QPLANE0(i)                                (0x00000630+(i)*4)


#define NV096_SET_TEXGEN_SPLANE1(i)                                (0x00000640+(i)*4)


#define NV096_SET_TEXGEN_TPLANE1(i)                                (0x00000650+(i)*4)


#define NV096_SET_TEXGEN_RPLANE1(i)                                (0x00000660+(i)*4)


#define NV096_SET_TEXGEN_QPLANE1(i)                                (0x00000670+(i)*4)


#define NV096_SET_FOG_PARAMS(i)                                    (0x00000680+(i)*4)


#define NV096_SET_FOG_PLANE(i)                                     (0x0000068c+(i)*4)


#define NV096_SET_SPECULAR_PARAMS(i)                               (0x000006a0+(i)*4)


#define NV096_SET_SCENE_AMBIENT_COLOR(i)                           (0x000006c4+(i)*4)


#define NV096_SET_VIEWPORT_OFFSET(i)                               (0x000006e8+(i)*4)


#define NV096_SET_POINT_PARAMS(i)                                  (0x000006f8+(i)*4)


#define NV096_SET_EYE_POSITION(i)                                  (0x00000718+(i)*4)

#define NV096_SET_EYE_DIRECTION_SW(i)                              (0x0000072c+(i)*4)


#define NV096_SET_LIGHT_AMBIENT_COLOR(i,j)                 (0x00000800+(i)*128+(j)*4)


#define NV096_SET_LIGHT_DIFFUSE_COLOR(i,j)                 (0x0000080c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPECULAR_COLOR(i,j)                (0x00000818+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_RANGE(i)                           (0x00000824+(i)*128)


#define NV096_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)          (0x00000828+(i)*128+(j)*4)


#define NV096_SET_LIGHT_INFINITE_DIRECTION(i,j)            (0x00000834+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPOT_FALLOFF(i,j)                  (0x00000840+(i)*128+(j)*4)


#define NV096_SET_LIGHT_SPOT_DIRECTION(i,j)                (0x0000084c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_POSITION(i,j)                (0x0000085c+(i)*128+(j)*4)


#define NV096_SET_LIGHT_LOCAL_ATTENUATION(i,j)             (0x00000868+(i)*128+(j)*4)


#define NV096_SET_VERTEX3F(i)                                      (0x00000c00+(i)*4)


#define NV096_SET_VERTEX4F(i)                                      (0x00000c18+(i)*4)


#define NV096_SET_VERTEX4S(i)                                      (0x00000c28+(i)*4)


#define NV096_SET_NORMAL3F(i)                                      (0x00000c30+(i)*4)


#define NV096_SET_NORMAL3S(i)                                      (0x00000c40+(i)*2)


#define NV096_SET_DIFFUSE_COLOR4F(i)                               (0x00000c50+(i)*4)


#define NV096_SET_DIFFUSE_COLOR3F(i)                               (0x00000c60+(i)*4)


#define NV096_SET_DIFFUSE_COLOR4UB                                         0x00000c6c


#define NV096_SET_SPECULAR_COLOR4F(i)                              (0x00000c70+(i)*4)


#define NV096_SET_SPECULAR_COLOR3F(i)                              (0x00000c80+(i)*4)


#define NV096_SET_SPECULAR_COLOR4UB                                        0x00000c8c


#define NV096_SET_TEXCOORD0_2F(i)                                  (0x00000c90+(i)*4)


#define NV096_SET_TEXCOORD0_2S(i)                                  (0x00000c98+(i)*2)


#define NV096_SET_TEXCOORD0_4F(i)                                  (0x00000ca0+(i)*4)


#define NV096_SET_TEXCOORD0_4S(i)                                  (0x00000cb0+(i)*2)


#define NV096_SET_TEXCOORD1_2F(i)                                  (0x00000cb8+(i)*4)


#define NV096_SET_TEXCOORD1_2S(i)                                  (0x00000cc0+(i)*2)


#define NV096_SET_TEXCOORD1_4F(i)                                  (0x00000cc8+(i)*4)


#define NV096_SET_TEXCOORD1_4S(i)                                  (0x00000cd8+(i)*2)


#define NV096_SET_FOG1F                                                    0x00000ce0


#define NV096_SET_WEIGHT1F                                                 0x00000ce4


#define NV096_SET_EDGE_FLAG                                                0x00000cec


#define NV096_INVALIDATE_VERTEX_CACHE_FILE                                 0x00000cf0


#define NV096_INVALIDATE_VERTEX_FILE                                       0x00000cf4


#define NV096_TL_NOP                                                       0x00000cf8


#define NV096_TL_SYNC                                                      0x00000cfc


#define NV096_SET_VERTEX_ARRAY_OFFSET                                      0x00000d00
#define NV096_SET_VERTEX_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_VERTEX_ARRAY_FORMAT                                      0x00000d04
#define NV096_SET_VERTEX_ARRAY_FORMAT_W                                         31:24
#define NV096_SET_VERTEX_ARRAY_FORMAT_W_NONE                               0x00000000
#define NV096_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                            0x00000001
#define NV096_SET_VERTEX_ARRAY_FORMAT_STRIDE                                     23:8
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_2                               0x00000002
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV096_SET_VERTEX_ARRAY_FORMAT_SIZE_4                               0x00000004
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_DIFFUSE_ARRAY_OFFSET                                     0x00000d08
#define NV096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                    27:0


#define NV096_SET_DIFFUSE_ARRAY_FORMAT                                     0x00000d0c
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                    31:8
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                       7:4
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                       3:0
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA             0x00000000
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002
#define NV096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA             0x00000004


#define NV096_SET_SPECULAR_ARRAY_OFFSET                                    0x00000d10
#define NV096_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                   27:0


#define NV096_SET_SPECULAR_ARRAY_FORMAT                                    0x00000d14
#define NV096_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                   31:8
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE                                      7:4
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV096_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE                                      3:0
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004


#define NV096_SET_TEX_COORD0_ARRAY_OFFSET                                  0x00000d18
#define NV096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                 27:0


#define NV096_SET_TEX_COORD0_ARRAY_FORMAT                                  0x00000d1c
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                 31:8
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                    7:4
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                    3:0
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV096_SET_TEX_COORD1_ARRAY_OFFSET                                  0x00000d20
#define NV096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                 27:0


#define NV096_SET_TEX_COORD1_ARRAY_FORMAT                                  0x00000d24
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                 31:8
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                    7:4
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                           0x00000000
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                    3:0
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                       0x00000001
#define NV096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                       0x00000002


#define NV096_SET_NORMAL_ARRAY_OFFSET                                      0x00000d28
#define NV096_SET_NORMAL_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_NORMAL_ARRAY_FORMAT                                      0x00000d2c
#define NV096_SET_NORMAL_ARRAY_FORMAT_STRIDE                                     31:8
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV096_SET_NORMAL_ARRAY_FORMAT_SIZE_3                               0x00000003
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_WEIGHT_ARRAY_OFFSET                                      0x00000d30
#define NV096_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                     27:0


#define NV096_SET_WEIGHT_ARRAY_FORMAT                                      0x00000d34
#define NV096_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                     31:8
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE                                        7:4
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                               0x00000000
#define NV096_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                               0x00000001
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE                                        3:0
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                           0x00000001
#define NV096_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                           0x00000002


#define NV096_SET_FOG_ARRAY_OFFSET                                         0x00000d38
#define NV096_SET_FOG_ARRAY_OFFSET_OFFSET                                        27:0


#define NV096_SET_FOG_ARRAY_FORMAT                                         0x00000d3c
#define NV096_SET_FOG_ARRAY_FORMAT_STRIDE                                        31:8
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE                                           7:4
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE_0                                  0x00000000
#define NV096_SET_FOG_ARRAY_FORMAT_SIZE_1                                  0x00000001
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE                                           3:0
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                              0x00000001
#define NV096_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                              0x00000002

#define NV096_SET_LOGIC_OP_ENABLE                                          0x00000d40
#define NV096_SET_LOGIC_OP_ENABLE_V                                              31:0
#define NV096_SET_LOGIC_OP_ENABLE_V_FALSE                                  0x00000000
#define NV096_SET_LOGIC_OP_ENABLE_V_TRUE                                   0x00000001

#define NV096_SET_LOGIC_OP                                                 0x00000d44
#define NV096_SET_LOGIC_OP_V                                                     31:0
#define NV096_SET_LOGIC_OP_V_CLEAR                                         0x00001500
#define NV096_SET_LOGIC_OP_V_AND                                           0x00001501
#define NV096_SET_LOGIC_OP_V_AND_REVERSE                                   0x00001502
#define NV096_SET_LOGIC_OP_V_COPY                                          0x00001503
#define NV096_SET_LOGIC_OP_V_AND_INVERTED                                  0x00001504
#define NV096_SET_LOGIC_OP_V_NOOP                                          0x00001505
#define NV096_SET_LOGIC_OP_V_XOR                                           0x00001506
#define NV096_SET_LOGIC_OP_V_OR                                            0x00001507
#define NV096_SET_LOGIC_OP_V_NOR                                           0x00001508
#define NV096_SET_LOGIC_OP_V_EQUIV                                         0x00001509
#define NV096_SET_LOGIC_OP_V_INVERT                                        0x0000150a
#define NV096_SET_LOGIC_OP_V_OR_REVERSE                                    0x0000150b
#define NV096_SET_LOGIC_OP_V_COPY_INVERTED                                 0x0000150c
#define NV096_SET_LOGIC_OP_V_OR_INVERTED                                   0x0000150d
#define NV096_SET_LOGIC_OP_V_NAND                                          0x0000150e
#define NV096_SET_LOGIC_OP_V_SET                                           0x0000150f

#define NV096_SET_BEGIN_END                                                0x00000dfc
#define NV096_SET_BEGIN_END_OP                                                   31:0
#define NV096_SET_BEGIN_END_OP_END                                         0x00000000
#define NV096_SET_BEGIN_END_OP_POINTS                                      0x00000001
#define NV096_SET_BEGIN_END_OP_LINES                                       0x00000002
#define NV096_SET_BEGIN_END_OP_LINE_LOOP                                   0x00000003
#define NV096_SET_BEGIN_END_OP_LINE_STRIP                                  0x00000004
#define NV096_SET_BEGIN_END_OP_TRIANGLES                                   0x00000005
#define NV096_SET_BEGIN_END_OP_TRIANGLE_STRIP                              0x00000006
#define NV096_SET_BEGIN_END_OP_TRIANGLE_FAN                                0x00000007
#define NV096_SET_BEGIN_END_OP_QUADS                                       0x00000008
#define NV096_SET_BEGIN_END_OP_QUAD_STRIP                                  0x00000009
#define NV096_SET_BEGIN_END_OP_POLYGON                                     0x0000000A


#define NV096_ARRAY_ELEMENT16(i)                                   (0x00000e00+(i)*2)


#define NV096_SET_BEGIN_END2                                               0x000010fc
#define NV096_SET_BEGIN_END2_OP                                                  31:0
#define NV096_SET_BEGIN_END2_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END2_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END2_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END2_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END2_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END2_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END2_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END2_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END2_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END2_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END2_OP_POLYGON                                    0x0000000A


#define NV096_ARRAY_ELEMENT32(i)                                   (0x00001100+(i)*4)


#define NV096_SET_BEGIN_END3                                               0x000013fc
#define NV096_SET_BEGIN_END3_OP                                                  31:0
#define NV096_SET_BEGIN_END3_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END3_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END3_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END3_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END3_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END3_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END3_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END3_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END3_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END3_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END3_OP_POLYGON                                    0x0000000A


#define NV096_DRAW_ARRAYS(i)                                       (0x00001400+(i)*4)
#define NV096_DRAW_ARRAYS_COUNT                                                 31:24
#define NV096_DRAW_ARRAYS_START_INDEX                                            23:0

#define NV096_SET_BEGIN_END4                                               0x000017fc
#define NV096_SET_BEGIN_END4_OP                                                  31:0
#define NV096_SET_BEGIN_END4_OP_END                                        0x00000000
#define NV096_SET_BEGIN_END4_OP_POINTS                                     0x00000001
#define NV096_SET_BEGIN_END4_OP_LINES                                      0x00000002
#define NV096_SET_BEGIN_END4_OP_LINE_LOOP                                  0x00000003
#define NV096_SET_BEGIN_END4_OP_LINE_STRIP                                 0x00000004
#define NV096_SET_BEGIN_END4_OP_TRIANGLES                                  0x00000005
#define NV096_SET_BEGIN_END4_OP_TRIANGLE_STRIP                             0x00000006
#define NV096_SET_BEGIN_END4_OP_TRIANGLE_FAN                               0x00000007
#define NV096_SET_BEGIN_END4_OP_QUADS                                      0x00000008
#define NV096_SET_BEGIN_END4_OP_QUAD_STRIP                                 0x00000009
#define NV096_SET_BEGIN_END4_OP_POLYGON                                    0x0000000A


#define NV096_INLINE_ARRAY(i)                                      (0x00001800+(i)*4)



typedef NvV32 Nv1196Typedef;


/* class NV11_CELSIUS_PRIMITIVE */
#define  NV11_CELSIUS_PRIMITIVE                                    (0x00001196)
/* NvNotification[] elements */
#define NV1196_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV1196_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV1196_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV1196_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV1196_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV1196_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV1196_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved0004[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved0114[0xc/4];
    NvV32 SetFlipRead;
    NvV32 SetFlipWrite;
    NvV32 SetFlipModulo;
    NvV32 FlipIncrementWrite;
    NvV32 FlipStall;
    NvV32 Reserved0134[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved0144[0x3c/4];
    NvU32 SetContextDmaNotifies;
    NvU32 SetContextDmaA;
    NvU32 SetContextDmaB;
    NvU32 SetContextDmaVertex;
    NvU32 SetContextDmaState;
    NvU32 SetContextDmaColor;
    NvU32 SetContextDmaZeta;
    NvV32 Reserved019c[0x64/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvU32 SetTextureOffset[2];
    NvV32 SetTextureFormat[2];
    NvV32 SetTextureControl0[2];
    NvV32 SetTextureControl1[2];
    NvV32 SetTextureControl2[2];
    NvV32 SetTextureImageRect[2];
    NvV32 SetTextureFilter[2];
    NvV32 SetTexturePalette[2];
    NvV32 Reserved0258[0x8/4];
    NvV32 SetCombinerAlphaICW[2];
    NvV32 SetCombinerColorICW[2];
    NvV32 SetCombineFactor[2];
    NvV32 SetCombinerAlphaOCW[2];
    NvV32 SetCombiner0ColorOCW;
    NvV32 SetCombiner1ColorOCW;
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvU32 SetColorKeyColor[2];
    NvV32 SetWindowClipType;
    NvV32 Reserved02b8[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinEnable;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvU32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvU32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvU32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvU32 SetStencilFuncRef;
    NvU32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvU32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvF32 SetMaterialEmission[3];
    NvF32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
    NvV32 S;
    NvV32 T;
    NvV32 R;
    NvV32 Q;
    } SetTexgen[2];
    NvV32 SetTextureMatrix0Enable;
    NvV32 SetTextureMatrix1Enable;
    NvV32 SetTLMode;
    NvU32 SetPointSize;
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved03f8[0x8/4];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvV32 Reserved05c0[0x40/4];
    NvF32 SetTexgenSPlane0[4];
    NvF32 SetTexgenTPlane0[4];
    NvF32 SetTexgenRPlane0[4];
    NvF32 SetTexgenQPlane0[4];
    NvF32 SetTexgenSPlane1[4];
    NvF32 SetTexgenTPlane1[4];
    NvF32 SetTexgenRPlane1[4];
    NvF32 SetTexgenQPlane1[4];
    NvF32 SetFogParams[3];
    NvF32 SetFogPlane[4];
    NvV32 Reserved069c[0x4/4];
    NvF32 SetSpecularParams[6];
    NvV32 Reserved06b8[0xc/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved06d0[0x18/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 Flush;
    NvF32 SetEyeDirectionSW[3];
    NvV32 Reserved0738[0xc8/4];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvF32 LocalRange;
    NvF32 InfiniteHalfVector[3];
    NvF32 InfiniteDirection[3];
    NvF32 SpotFalloff[3];
    NvF32 SpotDirection[4];
    NvF32 LocalPosition[3];
    NvF32 LocalAttenuation[3];
    NvV32 Reserved0874[0xc/4];
    } SetLight[8];
    NvF32 SetVertex3f[3];
    NvV32 Reserved0c0c[0xc/4];
    NvF32 SetVertex4f[4];
    NvS32 SetVertex4s[2];
    NvF32 SetNormal3f[3];
    NvV32 Reserved0c3c[0x4/4];
    NvS32 SetNormal3s[2];
    NvV32 Reserved0c48[0x8/4];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvU32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvU32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS32 SetTexcoord0_2s;
    NvV32 Reserved0c9c[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS32 SetTexcoord0_4s[2];
    NvF32 SetTexcoord1_2f[2];
    NvS32 SetTexcoord1_2s;
    NvV32 Reserved0cc4[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS32 SetTexcoord1_4s[2];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvV32 Reserved0ce8[0x4/4];
    NvU32 SetEdgeFlag;
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvU32 SetVertexArrayOffset;
    NvV32 SetVertexArrayFormat;
    NvU32 SetDiffuseArrayOffset;
    NvV32 SetDiffuseArrayFormat;
    NvU32 SetSpecularArrayOffset;
    NvV32 SetSpecularArrayFormat;
    NvU32 SetTexCoord0ArrayOffset;
    NvV32 SetTexCoord0ArrayFormat;
    NvU32 SetTexCoord1ArrayOffset;
    NvV32 SetTexCoord1ArrayFormat;
    NvU32 SetNormalArrayOffset;
    NvV32 SetNormalArrayFormat;
    NvU32 SetWeightArrayOffset;
    NvV32 SetWeightArrayFormat;
    NvU32 SetFogArrayOffset;
    NvV32 SetFogArrayFormat;
    NvV32 SetLogicOpEnable;
    NvV32 SetLogicOp;
    NvV32 Reserved0d48[0xb4/4];
    NvV32 SetBeginEnd;
    NvV32 ArrayElement16[128];
    NvV32 Reserved1000[0xfc/4];
    NvV32 SetBeginEnd2;
    NvU32 ArrayElement32[64];
    NvV32 Reserved1200[0x1fc/4];
    NvV32 SetBeginEnd3;
    NvV32 DrawArrays[128];
    NvV32 DebugInit[10];
    NvV32 Reserved1628[0x1d4/4];
    NvV32 SetBeginEnd4;
    NvU32 InlineArray[512];
} Nv11CelsiusPrimitive;

#define NV1196_TYPEDEF                                      Nv11CelsiusPrimitive
#define NV1196_SET_OBJECT                                          (0x00000000)

#define NV1196_NO_OPERATION                                                0x00000100
#define NV1196_NO_OPERATION_V                                                    31:0

#define NV1196_FLUSH                                                       0x00000728
#define NV1196_FLUSH_V                                                           31:0

#define NV1196_NOTIFY                                                      0x00000104
#define NV1196_NOTIFY_TYPE                                                       31:0
#define NV1196_NOTIFY_TYPE_WRITE_ONLY                                      0x00000000
#define NV1196_NOTIFY_TYPE_WRITE_THEN_AWAKEN                               0x00000001

#define NV1196_SET_WARNING_ENABLE                                          0x00000108
#define NV1196_SET_WARNING_ENABLE_V                                              31:0
#define NV1196_SET_WARNING_ENABLE_V_STOP                                   0x00000000
#define NV1196_SET_WARNING_ENABLE_V_WRITE_ONLY                             0x00000001
#define NV1196_SET_WARNING_ENABLE_V_WRITE_THEN_AWAKEN                      0x00000002

#define NV1196_GET_STATE                                                   0x0000010c
#define NV1196_GET_STATE_GETSTATE                                                31:0
#define NV1196_GET_STATE_GETSTATE_ALL_STATE                                0x00000001
#define NV1196_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE                  0x00000002
#define NV1196_GET_STATE_GETSTATE_RENDERING_STATE                          0x00000003
#define NV1196_GET_STATE_GETSTATE_GEOMETRY_STATE                           0x00000004

#define NV1196_WAIT_FOR_IDLE                                               0x00000110
#define NV1196_WAIT_FOR_IDLE_V                                                   31:0

#define NV1196_PM_TRIGGER                                                  0x00000140
#define NV1196_PM_TRIGGER_V                                                      31:0
#define NV1196_PM_TRIGGER_V_NOP                                            0x00000000
#define NV1196_PM_TRIGGER_V_TRIGGER                                        0x00000001

#define NV1196_SET_FLIP_READ                                               0x00000120
#define NV1196_SET_FLIP_WRITE                                              0x00000124
#define NV1196_SET_FLIP_MODULO                                             0x00000128
#define NV1196_FLIP_INCREMENT_WRITE                                        0x0000012c
#define NV1196_FLIP_STALL                                                  0x00000130

#define NV1196_SET_CONTEXT_DMA_NOTIFIES                                    0x00000180
#define NV1196_SET_CONTEXT_DMA_NOTIFIES_V                                        31:0

#define NV1196_SET_CONTEXT_DMA_A                                           0x00000184
#define NV1196_SET_CONTEXT_DMA_A_V                                               31:0

#define NV1196_SET_CONTEXT_DMA_B                                           0x00000188
#define NV1196_SET_CONTEXT_DMA_B_V                                               31:0

#define NV1196_SET_CONTEXT_DMA_VERTEX                                      0x0000018c
#define NV1196_SET_CONTEXT_DMA_VERTEX_V                                          31:0

#define NV1196_SET_CONTEXT_DMA_STATE                                       0x00000190
#define NV1196_SET_CONTEXT_DMA_STATE_V                                           31:0

#define NV1196_SET_CONTEXT_DMA_COLOR                                       0x00000194
#define NV1196_SET_CONTEXT_DMA_COLOR_V                                           31:0

#define NV1196_SET_CONTEXT_DMA_ZETA                                        0x00000198
#define NV1196_SET_CONTEXT_DMA_ZETA_V                                            31:0

#define NV1196_SET_SURFACE_CLIP_HORIZONTAL                                 0x00000200
#define NV1196_SET_SURFACE_CLIP_HORIZONTAL_X                                     15:0
#define NV1196_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                31:16

#define NV1196_SET_SURFACE_CLIP_VERTICAL                                   0x00000204
#define NV1196_SET_SURFACE_CLIP_VERTICAL_Y                                       15:0
#define NV1196_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                 31:16

#define NV1196_SET_SURFACE_FORMAT                                          0x00000208
#define NV1196_SET_SURFACE_FORMAT_COLOR                                           7:0
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5               0x00000001
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5               0x00000002
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                          0x00000003
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8               0x00000004
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8               0x00000005
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8           0x00000006
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8           0x00000007
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                        0x00000008
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_B8                              0x00000009
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_G8B8                            0x0000000A
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_Z1R5G5B5           0x00000011
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1R5G5B5_O1R5G5B5           0x00000012
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_R5G6B5                      0x00000013
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X8R8G8B8_Z8R8G8B8           0x00000014
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X8R8G8B8_O8R8G8B8           0x00000015
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1A7R8G8B8_Z1A7R8G8B8       0x00000016
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_X1A7R8G8B8_O1A7R8G8B8       0x00000017
#define NV1196_SET_SURFACE_FORMAT_COLOR_LE_Z16_A8R8G8B8                    0x00000018
#define NV1196_SET_SURFACE_FORMAT_TYPE                                           15:8
#define NV1196_SET_SURFACE_FORMAT_TYPE_PITCH                               0x00000001
#define NV1196_SET_SURFACE_FORMAT_TYPE_SWIZZLE                             0x00000002
#define NV1196_SET_SURFACE_FORMAT_WIDTH                                         23:16
#define NV1196_SET_SURFACE_FORMAT_WIDTH_1                                  0x00000000
#define NV1196_SET_SURFACE_FORMAT_WIDTH_2                                  0x00000001
#define NV1196_SET_SURFACE_FORMAT_WIDTH_4                                  0x00000002
#define NV1196_SET_SURFACE_FORMAT_WIDTH_8                                  0x00000003
#define NV1196_SET_SURFACE_FORMAT_WIDTH_16                                 0x00000004
#define NV1196_SET_SURFACE_FORMAT_WIDTH_32                                 0x00000005
#define NV1196_SET_SURFACE_FORMAT_WIDTH_64                                 0x00000006
#define NV1196_SET_SURFACE_FORMAT_WIDTH_128                                0x00000007
#define NV1196_SET_SURFACE_FORMAT_WIDTH_256                                0x00000008
#define NV1196_SET_SURFACE_FORMAT_WIDTH_512                                0x00000009
#define NV1196_SET_SURFACE_FORMAT_WIDTH_1024                               0x0000000A
#define NV1196_SET_SURFACE_FORMAT_WIDTH_2048                               0x0000000B
#define NV1196_SET_SURFACE_FORMAT_HEIGHT                                        31:24
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_1                                 0x00000000
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_2                                 0x00000001
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_4                                 0x00000002
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_8                                 0x00000003
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_16                                0x00000004
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_32                                0x00000005
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_64                                0x00000006
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_128                               0x00000007
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_256                               0x00000008
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_512                               0x00000009
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_1024                              0x0000000A
#define NV1196_SET_SURFACE_FORMAT_HEIGHT_2048                              0x0000000B

#define NV1196_SET_SURFACE_PITCH                                           0x0000020c
#define NV1196_SET_SURFACE_PITCH_COLOR                                           15:0
#define NV1196_SET_SURFACE_PITCH_ZETA                                           31:16

#define NV1196_SET_SURFACE_COLOR_OFFSET                                    0x00000210
#define NV1196_SET_SURFACE_COLOR_OFFSET_V                                        31:0

#define NV1196_SET_SURFACE_ZETA_OFFSET                                     0x00000214
#define NV1196_SET_SURFACE_ZETA_OFFSET_V                                         31:0

#define NV1196_SET_TEXTURE_OFFSET(i)                               (0x00000218+(i)*4)
#define NV1196_SET_TEXTURE_OFFSET_V                                              31:0

#define NV1196_SET_TEXTURE_FORMAT(i)                               (0x00000220+(i)*4)
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA                                     1:0
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                  2:2
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                     0x00000000
#define NV1196_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                      0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH                                      4:3
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER                        0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH                                      6:5
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER                        0x00000001
#define NV1196_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_COLOR                                          11:7
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_Y8                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_AY8                             0x00000001
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                        0x00000002
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                        0x00000003
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                        0x00000004
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5                          0x00000005
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8                        0x00000006
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8                        0x00000007
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5                     0x00000008
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5                       0x00000009
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4                     0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8                     0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5                   0x0000000C
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8                  0x0000000E
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8                  0x0000000F
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5                  0x00000010
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5                    0x00000011
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8                  0x00000012
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8                        0x00000013
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8                       0x00000014
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9                     0x00000015
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8                      0x00000016
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8                      0x00000017
#define NV1196_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8                    0x00000018
#define NV1196_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U                                   19:16
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                            0x00000000
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                            0x00000003
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                           0x00000004
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                           0x00000005
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                           0x00000006
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                          0x00000007
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                          0x00000008
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                          0x00000009
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                         0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                         0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V                                   23:20
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                            0x00000000
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                            0x00000001
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                            0x00000002
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                            0x00000003
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                           0x00000004
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                           0x00000005
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                           0x00000006
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                          0x00000007
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                          0x00000008
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                          0x00000009
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                         0x0000000A
#define NV1196_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                         0x0000000B
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU                               26:24
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP                     0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR                   0x00000002
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP                    0x00000003
#define NV1196_SET_TEXTURE_FORMAT_WRAPU                                         27:27
#define NV1196_SET_TEXTURE_FORMAT_WRAPU_FALSE                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_WRAPU_TRUE                               0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV                               30:28
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP                     0x00000001
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR                   0x00000002
#define NV1196_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP                    0x00000003
#define NV1196_SET_TEXTURE_FORMAT_WRAPV                                         31:31
#define NV1196_SET_TEXTURE_FORMAT_WRAPV_FALSE                              0x00000000
#define NV1196_SET_TEXTURE_FORMAT_WRAPV_TRUE                               0x00000001

#define NV1196_SET_TEXTURE_CONTROL0(i)                             (0x00000228+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE                                      31:30
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE_FALSE                           0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_ENABLE_TRUE                            0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                               29:18
#define NV1196_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                17:6
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                 5:4
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                        0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                        0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                            3:3
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE               0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                             2:2
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                 0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                           1:0
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE              0x00000000
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA              0x00000001
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA               0x00000002
#define NV1196_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL               0x00000003

#define NV1196_SET_TEXTURE_CONTROL1(i)                             (0x00000230+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                 31:16

#define NV1196_SET_TEXTURE_CONTROL2(i)                             (0x00000238+(i)*4)
#define NV1196_SET_TEXTURE_CONTROL2_PERTURB_DU                                   11:0
#define NV1196_SET_TEXTURE_CONTROL2_PERTURB_DV                                  23:12
#define NV1196_SET_TEXTURE_CONTROL2_IMAGE_LODF                                  31:24

#define NV1196_SET_TEXTURE_IMAGE_RECT(i)                           (0x00000240+(i)*4)
#define NV1196_SET_TEXTURE_IMAGE_RECT_WIDTH                                     31:16
#define NV1196_SET_TEXTURE_IMAGE_RECT_HEIGHT                                     15:0

#define NV1196_SET_TEXTURE_FILTER(i)                               (0x00000248+(i)*4)
#define NV1196_SET_TEXTURE_FILTER_MIPMAPLODBIAS                                  12:0
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN                                    27:24
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST                       0x00000001
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR                        0x00000002
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST                    0x00000003
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR                     0x00000004
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST              0x00000005
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR               0x00000006
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG                                    31:28
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST                       0x00000001
#define NV1196_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR                        0x00000002

#define NV1196_SET_TEXTURE_PALETTE(i)                              (0x00000250+(i)*4)
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA                                    5:0
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                           0x00000000
#define NV1196_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                           0x00000001
#define NV1196_SET_TEXTURE_PALETTE_PALETTE_OFFSET                                31:6

#define NV1196_SET_COMBINER_ALPHA_ICW(i)                           (0x00000260+(i)*4)
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP                                     31:29
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA                                   28:28
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE                                  27:24
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP                                     23:21
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA                                   20:20
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE                                  19:16
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP                                     15:13
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA                                   12:12
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE                                   11:8
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP                                       7:5
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA                                     4:4
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE                                    3:0
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                       0x0000000D

#define NV1196_SET_COMBINER_COLOR_ICW(i)                           (0x00000268+(i)*4)
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP                                     31:29
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA                                   28:28
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE                                  27:24
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP                                     23:21
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA                                   20:20
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE                                  19:16
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP                                     15:13
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA                                   12:12
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE                                   11:8
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                       0x0000000D
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP                                       7:5
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY              0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                  0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                  0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                0x00000006
#define NV1196_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                  0x00000007
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA                                     4:4
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                        0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                         0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE                                    3:0
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                       0x00000000
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                       0x00000001
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                       0x00000002
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                       0x00000003
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                       0x00000004
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                       0x00000005
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                       0x00000008
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                       0x00000009
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                       0x0000000C
#define NV1196_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                       0x0000000D

#define NV1196_SET_COMBINE_FACTOR(i)                               (0x00000270+(i)*4)
#define NV1196_SET_COMBINE_FACTOR_BLUE                                            7:0
#define NV1196_SET_COMBINE_FACTOR_GREEN                                          15:8
#define NV1196_SET_COMBINE_FACTOR_RED                                           23:16
#define NV1196_SET_COMBINE_FACTOR_ALPHA                                         31:24

#define NV1196_SET_COMBINER_ALPHA_OCW(i)                           (0x00000278+(i)*4)
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION                                 31:15
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                    0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS               0x00000001
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1               0x00000002
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS          0x00000003
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2               0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1              0x00000006
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                14:14
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST                                    11:8
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST                                      7:4
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                         0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                         0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                         0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                         0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                         0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                         0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                         0x0000000D
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST                                      3:0
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                         0x00000000
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                         0x00000004
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                         0x00000005
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                         0x00000008
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                         0x00000009
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                         0x0000000C
#define NV1196_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                         0x0000000D

#define NV1196_SET_COMBINER0_COLOR_OCW                                     0x00000280
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION                                31:15
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT                   0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS              0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1              0x00000002
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS         0x00000003
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2              0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1             0x00000006
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE                               14:14
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE                            13:13
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE                            12:12
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST                                   11:8
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0                       0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4                       0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5                       0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8                       0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9                       0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C                       0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D                       0x0000000D
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST                                     7:4
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST                                     3:0
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D                        0x0000000D

#define NV1196_SET_COMBINER1_COLOR_OCW                                     0x00000284
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT                          31:28
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE                 0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO                 0x00000002
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT                               27:27
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB                      0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB                      0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION                                26:15
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT                   0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS              0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1              0x00000002
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS         0x00000003
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2              0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1             0x00000006
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE                               14:14
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE                    0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE                     0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE                            13:13
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE                            12:12
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE                 0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE                  0x00000001
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST                                   11:8
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0                       0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4                       0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5                       0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8                       0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9                       0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C                       0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D                       0x0000000D
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST                                     7:4
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D                        0x0000000D
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST                                     3:0
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0                        0x00000000
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4                        0x00000004
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5                        0x00000005
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8                        0x00000008
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9                        0x00000009
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C                        0x0000000C
#define NV1196_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D                        0x0000000D

#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0                               0x00000288
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                          31:29
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                            28:28
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                           27:24
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                          23:21
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                            20:20
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                           19:16
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                          15:13
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                            12:12
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                            11:8
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD          0x0000000F
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                            7:5
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                              4:4
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                             3:0
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT          0x0000000E
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD          0x0000000F

#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1                               0x0000028c
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                          31:29
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                            28:28
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                           27:24
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                          23:21
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                            20:20
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                           19:16
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                          15:13
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE               0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                            12:12
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                  0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                            11:8
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                0x00000002
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                0x00000003
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                0x00000004
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                0x00000005
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                0x00000008
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                0x00000009
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                0x0000000C
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                0x0000000D
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                       7:7
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE          0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE           0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5               6:6
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE  0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE   0x00000001
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12              5:0
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE 0x00000000
#define NV1196_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE  0x00000020

#define NV1196_SET_CONTROL0                                                0x00000290
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA                                  31:24
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                       0x00000000
#define NV1196_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                        0x00000001
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE                                  23:20
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                       0x00000000
#define NV1196_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                        0x00000001
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                19:16
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_CONTROL0_Z_FORMAT                                            15:12
#define NV1196_SET_CONTROL0_Z_FORMAT_FIXED                                 0x00000000
#define NV1196_SET_CONTROL0_Z_FORMAT_FLOAT                                 0x00000001
#define NV1196_SET_CONTROL0_WBUFFER_SELECT                                       11:8
#define NV1196_SET_CONTROL0_WBUFFER_SELECT_0                               0x00000000
#define NV1196_SET_CONTROL0_WBUFFER_SELECT_1                               0x00000001
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE                                  7:0
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                      0x00000001

#define NV1196_SET_LIGHT_CONTROL                                           0x00000294
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE                                       31:16
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE_FALSE                            0x00000000
#define NV1196_SET_LIGHT_CONTROL_LOCALEYE_TRUE                             0x00000001
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE                                15:2
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT                   0x00000000
#define NV1196_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT               0x00000001
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                             1:1
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                0x00000000
#define NV1196_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                 0x00000001
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN                               0:0
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE                  0x00000000
#define NV1196_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE                   0x00000001

#define NV1196_SET_COLOR_MATERIAL                                          0x00000298
#define NV1196_SET_COLOR_MATERIAL_V                                              31:0
#define NV1196_SET_COLOR_MATERIAL_V_DISABLED                               0x00000000
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION                               0x00000001
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT                                0x00000002
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT                       0x00000003
#define NV1196_SET_COLOR_MATERIAL_V_DIFFUSE                                0x00000004
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE                       0x00000005
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE                        0x00000006
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE               0x00000007
#define NV1196_SET_COLOR_MATERIAL_V_SPECULAR                               0x00000008
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR                      0x00000009
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR                       0x0000000A
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR              0x0000000B
#define NV1196_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR                       0x0000000C
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR              0x0000000D
#define NV1196_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR               0x0000000E
#define NV1196_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR      0x0000000F

#define NV1196_SET_FOG_MODE                                                0x0000029c
#define NV1196_SET_FOG_MODE_FOG_MODE                                             31:0
#define NV1196_SET_FOG_MODE_FOG_MODE_LINEAR                                0x00002601
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP                                   0x00000800
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP2                                  0x00000801
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP_ABS                               0x00000802
#define NV1196_SET_FOG_MODE_FOG_MODE_EXP2_ABS                              0x00000803

#define NV1196_SET_FOG_GEN_MODE                                            0x000002a0
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE                                     31:0
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT                     0x00000000
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL                        0x00000001
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR                        0x00000002
#define NV1196_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR                    0x00000003

#define NV1196_SET_FOG_ENABLE                                              0x000002a4
#define NV1196_SET_FOG_ENABLE_V                                                  31:0
#define NV1196_SET_FOG_ENABLE_V_FALSE                                      0x00000000
#define NV1196_SET_FOG_ENABLE_V_TRUE                                       0x00000001

#define NV1196_SET_FOG_COLOR                                               0x000002a8
#define NV1196_SET_FOG_COLOR_RED                                                  7:0
#define NV1196_SET_FOG_COLOR_GREEN                                               15:8
#define NV1196_SET_FOG_COLOR_BLUE                                               23:16
#define NV1196_SET_FOG_COLOR_ALPHA                                              31:24

#define NV1196_SET_COLOR_KEY_COLOR(i)                              (0x000002ac+(i)*4)
#define NV1196_SET_COLOR_KEY_COLOR_V                                             31:0

#define NV1196_SET_WINDOW_CLIP_TYPE                                        0x000002b4
#define NV1196_SET_WINDOW_CLIP_TYPE_V                                            31:0
#define NV1196_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                            0x00000000
#define NV1196_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                            0x00000001

#define NV1196_SET_WINDOW_CLIP_HORIZONTAL(i)                       (0x000002c0+(i)*4)
#define NV1196_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                   11:0
#define NV1196_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                  27:16

#define NV1196_SET_WINDOW_CLIP_VERTICAL(i)                         (0x000002e0+(i)*4)
#define NV1196_SET_WINDOW_CLIP_VERTICAL_YMIN                                     11:0
#define NV1196_SET_WINDOW_CLIP_VERTICAL_YMAX                                    27:16

#define NV1196_SET_ALPHA_TEST_ENABLE                                       0x00000300
#define NV1196_SET_ALPHA_TEST_ENABLE_V                                           31:0
#define NV1196_SET_ALPHA_TEST_ENABLE_V_FALSE                               0x00000000
#define NV1196_SET_ALPHA_TEST_ENABLE_V_TRUE                                0x00000001

#define NV1196_SET_BLEND_ENABLE                                            0x00000304
#define NV1196_SET_BLEND_ENABLE_V                                                31:0
#define NV1196_SET_BLEND_ENABLE_V_FALSE                                    0x00000000
#define NV1196_SET_BLEND_ENABLE_V_TRUE                                     0x00000001

#define NV1196_SET_CULL_FACE_ENABLE                                        0x00000308
#define NV1196_SET_CULL_FACE_ENABLE_V                                            31:0
#define NV1196_SET_CULL_FACE_ENABLE_V_FALSE                                0x00000000
#define NV1196_SET_CULL_FACE_ENABLE_V_TRUE                                 0x00000001

#define NV1196_SET_DEPTH_TEST_ENABLE                                       0x0000030c
#define NV1196_SET_DEPTH_TEST_ENABLE_V                                           31:0
#define NV1196_SET_DEPTH_TEST_ENABLE_V_FALSE                               0x00000000
#define NV1196_SET_DEPTH_TEST_ENABLE_V_TRUE                                0x00000001

#define NV1196_SET_DITHER_ENABLE                                           0x00000310
#define NV1196_SET_DITHER_ENABLE_V                                               31:0
#define NV1196_SET_DITHER_ENABLE_V_FALSE                                   0x00000000
#define NV1196_SET_DITHER_ENABLE_V_TRUE                                    0x00000001

#define NV1196_SET_LIGHTING_ENABLE                                         0x00000314
#define NV1196_SET_LIGHTING_ENABLE_V                                             31:0
#define NV1196_SET_LIGHTING_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_LIGHTING_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_POINT_PARAMS_ENABLE                                     0x00000318
#define NV1196_SET_POINT_PARAMS_ENABLE_V                                         31:0
#define NV1196_SET_POINT_PARAMS_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_POINT_PARAMS_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_POINT_SMOOTH_ENABLE                                     0x0000031c
#define NV1196_SET_POINT_SMOOTH_ENABLE_V                                         31:0
#define NV1196_SET_POINT_SMOOTH_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_POINT_SMOOTH_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_LINE_SMOOTH_ENABLE                                      0x00000320
#define NV1196_SET_LINE_SMOOTH_ENABLE_V                                          31:0
#define NV1196_SET_LINE_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV1196_SET_LINE_SMOOTH_ENABLE_V_TRUE                               0x00000001

#define NV1196_SET_POLY_SMOOTH_ENABLE                                      0x00000324
#define NV1196_SET_POLY_SMOOTH_ENABLE_V                                          31:0
#define NV1196_SET_POLY_SMOOTH_ENABLE_V_FALSE                              0x00000000
#define NV1196_SET_POLY_SMOOTH_ENABLE_V_TRUE                               0x00000001

#define NV1196_SET_SKIN_ENABLE                                             0x00000328
#define NV1196_SET_SKIN_ENABLE_V                                                 31:0
#define NV1196_SET_SKIN_ENABLE_V_FALSE                                     0x00000000
#define NV1196_SET_SKIN_ENABLE_V_TRUE                                      0x00000001

#define NV1196_SET_STENCIL_TEST_ENABLE                                     0x0000032c
#define NV1196_SET_STENCIL_TEST_ENABLE_V                                         31:0
#define NV1196_SET_STENCIL_TEST_ENABLE_V_FALSE                             0x00000000
#define NV1196_SET_STENCIL_TEST_ENABLE_V_TRUE                              0x00000001

#define NV1196_SET_POLY_OFFSET_POINT_ENABLE                                0x00000330
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V                                    31:0
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                        0x00000000
#define NV1196_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                         0x00000001

#define NV1196_SET_POLY_OFFSET_LINE_ENABLE                                 0x00000334
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V                                     31:0
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                         0x00000000
#define NV1196_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                          0x00000001

#define NV1196_SET_POLY_OFFSET_FILL_ENABLE                                 0x00000338
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V                                     31:0
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                         0x00000000
#define NV1196_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                          0x00000001

#define NV1196_SET_ALPHA_FUNC                                              0x0000033c
#define NV1196_SET_ALPHA_FUNC_V                                                  31:0
#define NV1196_SET_ALPHA_FUNC_V_NEVER                                      0x00000200
#define NV1196_SET_ALPHA_FUNC_V_LESS                                       0x00000201
#define NV1196_SET_ALPHA_FUNC_V_EQUAL                                      0x00000202
#define NV1196_SET_ALPHA_FUNC_V_LEQUAL                                     0x00000203
#define NV1196_SET_ALPHA_FUNC_V_GREATER                                    0x00000204
#define NV1196_SET_ALPHA_FUNC_V_NOTEQUAL                                   0x00000205
#define NV1196_SET_ALPHA_FUNC_V_GEQUAL                                     0x00000206
#define NV1196_SET_ALPHA_FUNC_V_ALWAYS                                     0x00000207

#define NV1196_SET_ALPHA_REF                                               0x00000340
#define NV1196_SET_ALPHA_REF_V                                                   31:0

#define NV1196_SET_BLEND_FUNC_SFACTOR                                      0x00000344
#define NV1196_SET_BLEND_FUNC_SFACTOR_V                                          31:0
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ZERO                               0x00000000
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE                                0x00000001
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                          0x00000300
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                0x00000301
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                          0x00000302
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                0x00000303
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                          0x00000304
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                0x00000305
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                          0x00000306
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                0x00000307
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                 0x00000308
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                     0x00008001
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR           0x00008002
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                     0x00008003
#define NV1196_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA           0x00008004

#define NV1196_SET_BLEND_FUNC_DFACTOR                                      0x00000348
#define NV1196_SET_BLEND_FUNC_DFACTOR_V                                          31:0
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ZERO                               0x00000000
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE                                0x00000001
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                          0x00000300
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                0x00000301
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                          0x00000302
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                0x00000303
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                          0x00000304
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                0x00000305
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                          0x00000306
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                0x00000307
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE                 0x00000308
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                     0x00008001
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR           0x00008002
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                     0x00008003
#define NV1196_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA           0x00008004

#define NV1196_SET_BLEND_COLOR                                             0x0000034c
#define NV1196_SET_BLEND_COLOR_V                                                 31:0

#define NV1196_SET_BLEND_EQUATION                                          0x00000350
#define NV1196_SET_BLEND_EQUATION_V                                              31:0
#define NV1196_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                          0x0000800A
#define NV1196_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                  0x0000800B
#define NV1196_SET_BLEND_EQUATION_V_FUNC_ADD                               0x00008006
#define NV1196_SET_BLEND_EQUATION_V_MIN                                    0x00008007
#define NV1196_SET_BLEND_EQUATION_V_MAX                                    0x00008008

#define NV1196_SET_DEPTH_FUNC                                              0x00000354
#define NV1196_SET_DEPTH_FUNC_V                                                  31:0
#define NV1196_SET_DEPTH_FUNC_V_NEVER                                      0x00000200
#define NV1196_SET_DEPTH_FUNC_V_LESS                                       0x00000201
#define NV1196_SET_DEPTH_FUNC_V_EQUAL                                      0x00000202
#define NV1196_SET_DEPTH_FUNC_V_LEQUAL                                     0x00000203
#define NV1196_SET_DEPTH_FUNC_V_GREATER                                    0x00000204
#define NV1196_SET_DEPTH_FUNC_V_NOTEQUAL                                   0x00000205
#define NV1196_SET_DEPTH_FUNC_V_GEQUAL                                     0x00000206
#define NV1196_SET_DEPTH_FUNC_V_ALWAYS                                     0x00000207

#define NV1196_SET_COLOR_MASK                                              0x00000358
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                31:24
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE                                  23:16
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                       0x00000000
#define NV1196_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                        0x00000001
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                 15:8
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                     0x00000000
#define NV1196_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                      0x00000001
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                   7:0
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                      0x00000000
#define NV1196_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                       0x00000001

#define NV1196_SET_DEPTH_MASK                                              0x0000035c
#define NV1196_SET_DEPTH_MASK_V                                                  31:0
#define NV1196_SET_DEPTH_MASK_V_FALSE                                      0x00000000
#define NV1196_SET_DEPTH_MASK_V_TRUE                                       0x00000001

#define NV1196_SET_STENCIL_MASK                                            0x00000360
#define NV1196_SET_STENCIL_MASK_V                                                31:0

#define NV1196_SET_STENCIL_FUNC                                            0x00000364
#define NV1196_SET_STENCIL_FUNC_V                                                31:0
#define NV1196_SET_STENCIL_FUNC_V_NEVER                                    0x00000200
#define NV1196_SET_STENCIL_FUNC_V_LESS                                     0x00000201
#define NV1196_SET_STENCIL_FUNC_V_EQUAL                                    0x00000202
#define NV1196_SET_STENCIL_FUNC_V_LEQUAL                                   0x00000203
#define NV1196_SET_STENCIL_FUNC_V_GREATER                                  0x00000204
#define NV1196_SET_STENCIL_FUNC_V_NOTEQUAL                                 0x00000205
#define NV1196_SET_STENCIL_FUNC_V_GEQUAL                                   0x00000206
#define NV1196_SET_STENCIL_FUNC_V_ALWAYS                                   0x00000207

#define NV1196_SET_STENCIL_FUNC_REF                                        0x00000368
#define NV1196_SET_STENCIL_FUNC_REF_V                                            31:0

#define NV1196_SET_STENCIL_FUNC_MASK                                       0x0000036c
#define NV1196_SET_STENCIL_FUNC_MASK_V                                           31:0

#define NV1196_SET_STENCIL_OP_FAIL                                         0x00000370
#define NV1196_SET_STENCIL_OP_FAIL_V                                             31:0
#define NV1196_SET_STENCIL_OP_FAIL_V_KEEP                                  0x00001E00
#define NV1196_SET_STENCIL_OP_FAIL_V_ZERO                                  0x00000000
#define NV1196_SET_STENCIL_OP_FAIL_V_REPLACE                               0x00001E01
#define NV1196_SET_STENCIL_OP_FAIL_V_INCRSAT                               0x00001E02
#define NV1196_SET_STENCIL_OP_FAIL_V_DECRSAT                               0x00001E03
#define NV1196_SET_STENCIL_OP_FAIL_V_INVERT                                0x0000150A
#define NV1196_SET_STENCIL_OP_FAIL_V_INCR                                  0x00008507
#define NV1196_SET_STENCIL_OP_FAIL_V_DECR                                  0x00008508

#define NV1196_SET_STENCIL_OP_ZFAIL                                        0x00000374
#define NV1196_SET_STENCIL_OP_ZFAIL_V                                            31:0
#define NV1196_SET_STENCIL_OP_ZFAIL_V_KEEP                                 0x00001E00
#define NV1196_SET_STENCIL_OP_ZFAIL_V_ZERO                                 0x00000000
#define NV1196_SET_STENCIL_OP_ZFAIL_V_REPLACE                              0x00001E01
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INCRSAT                              0x00001E02
#define NV1196_SET_STENCIL_OP_ZFAIL_V_DECRSAT                              0x00001E03
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INVERT                               0x0000150A
#define NV1196_SET_STENCIL_OP_ZFAIL_V_INCR                                 0x00008507
#define NV1196_SET_STENCIL_OP_ZFAIL_V_DECR                                 0x00008508

#define NV1196_SET_STENCIL_OP_ZPASS                                        0x00000378
#define NV1196_SET_STENCIL_OP_ZPASS_V                                            31:0
#define NV1196_SET_STENCIL_OP_ZPASS_V_KEEP                                 0x00001E00
#define NV1196_SET_STENCIL_OP_ZPASS_V_ZERO                                 0x00000000
#define NV1196_SET_STENCIL_OP_ZPASS_V_REPLACE                              0x00001E01
#define NV1196_SET_STENCIL_OP_ZPASS_V_INCRSAT                              0x00001E02
#define NV1196_SET_STENCIL_OP_ZPASS_V_DECRSAT                              0x00001E03
#define NV1196_SET_STENCIL_OP_ZPASS_V_INVERT                               0x0000150A
#define NV1196_SET_STENCIL_OP_ZPASS_V_INCR                                 0x00008507
#define NV1196_SET_STENCIL_OP_ZPASS_V_DECR                                 0x00008508

#define NV1196_SET_SHADE_MODE                                              0x0000037c
#define NV1196_SET_SHADE_MODE_V                                                  31:0
#define NV1196_SET_SHADE_MODE_V_FLAT                                       0x00001D00
#define NV1196_SET_SHADE_MODE_V_SMOOTH                                     0x00001D01

#define NV1196_SET_LINE_WIDTH                                              0x00000380
#define NV1196_SET_LINE_WIDTH_V                                                  31:0

#define NV1196_SET_POLYGON_OFFSET_SCALE_FACTOR                             0x00000384
#define NV1196_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                 31:0

#define NV1196_SET_POLYGON_OFFSET_BIAS                                     0x00000388
#define NV1196_SET_POLYGON_OFFSET_BIAS_V                                         31:0

#define NV1196_SET_FRONT_POLYGON_MODE                                      0x0000038c
#define NV1196_SET_FRONT_POLYGON_MODE_V                                          31:0
#define NV1196_SET_FRONT_POLYGON_MODE_V_POINT                              0x00001B00
#define NV1196_SET_FRONT_POLYGON_MODE_V_LINE                               0x00001B01
#define NV1196_SET_FRONT_POLYGON_MODE_V_FILL                               0x00001B02

#define NV1196_SET_BACK_POLYGON_MODE                                       0x00000390
#define NV1196_SET_BACK_POLYGON_MODE_V                                           31:0
#define NV1196_SET_BACK_POLYGON_MODE_V_POINT                               0x00001B00
#define NV1196_SET_BACK_POLYGON_MODE_V_LINE                                0x00001B01
#define NV1196_SET_BACK_POLYGON_MODE_V_FILL                                0x00001B02

#define NV1196_SET_CLIP_MIN                                                0x00000394
#define NV1196_SET_CLIP_MIN_V                                                    31:0

#define NV1196_SET_CLIP_MAX                                                0x00000398
#define NV1196_SET_CLIP_MAX_V                                                    31:0

#define NV1196_SET_CULL_FACE                                               0x0000039c
#define NV1196_SET_CULL_FACE_V                                                   31:0
#define NV1196_SET_CULL_FACE_V_FRONT                                       0x00000404
#define NV1196_SET_CULL_FACE_V_BACK                                        0x00000405
#define NV1196_SET_CULL_FACE_V_FRONT_AND_BACK                              0x00000408

#define NV1196_SET_FRONT_FACE                                              0x000003a0
#define NV1196_SET_FRONT_FACE_V                                                  31:0
#define NV1196_SET_FRONT_FACE_V_CW                                         0x00000900
#define NV1196_SET_FRONT_FACE_V_CCW                                        0x00000901

#define NV1196_SET_NORMALIZATION_ENABLE                                    0x000003a4
#define NV1196_SET_NORMALIZATION_ENABLE_V                                        31:0
#define NV1196_SET_NORMALIZATION_ENABLE_V_FALSE                            0x00000000
#define NV1196_SET_NORMALIZATION_ENABLE_V_TRUE                             0x00000001

#define NV1196_SET_MATERIAL_EMISSION(i)                            (0x000003a8+(i)*4)
#define NV1196_SET_MATERIAL_EMISSION_V                                           31:0

#define NV1196_SET_MATERIAL_ALPHA                                          0x000003b4
#define NV1196_SET_MATERIAL_ALPHA_V                                              31:0

#define NV1196_SET_SPECULAR_ENABLE                                         0x000003b8
#define NV1196_SET_SPECULAR_ENABLE_V                                             31:0
#define NV1196_SET_SPECULAR_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_SPECULAR_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_LIGHT_ENABLE_MASK                                       0x000003bc
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0                                       1:0
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1                                       3:2
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2                                       5:4
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3                                       7:6
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4                                       9:8
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5                                     11:10
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6                                     13:12
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                           0x00000003
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7                                     15:14
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                            0x00000000
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                       0x00000001
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                          0x00000002
#define NV1196_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                           0x00000003

#define NV1196_SET_TEXGEN_S(i)                                    (0x000003c0+(i)*16)
#define NV1196_SET_TEXGEN_S_V                                                    31:0
#define NV1196_SET_TEXGEN_S_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_S_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_S_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_S_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_S_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_S_V_SPHERE_MAP                                   0x00002402
#define NV1196_SET_TEXGEN_S_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_T(i)                                    (0x000003c4+(i)*16)
#define NV1196_SET_TEXGEN_T_V                                                    31:0
#define NV1196_SET_TEXGEN_T_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_T_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_T_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_T_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_T_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_T_V_SPHERE_MAP                                   0x00002402
#define NV1196_SET_TEXGEN_T_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_R(i)                                    (0x000003c8+(i)*16)
#define NV1196_SET_TEXGEN_R_V                                                    31:0
#define NV1196_SET_TEXGEN_R_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_R_V_NORMAL_MAP                                   0x00008511
#define NV1196_SET_TEXGEN_R_V_REFLECTION_MAP                               0x00008512
#define NV1196_SET_TEXGEN_R_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_R_V_OBJECT_LINEAR                                0x00002401
#define NV1196_SET_TEXGEN_R_V_EMBOSS                                       0x0000855F

#define NV1196_SET_TEXGEN_Q(i)                                    (0x000003cc+(i)*16)
#define NV1196_SET_TEXGEN_Q_V                                                    31:0
#define NV1196_SET_TEXGEN_Q_V_DISABLE                                      0x00000000
#define NV1196_SET_TEXGEN_Q_V_EYE_LINEAR                                   0x00002400
#define NV1196_SET_TEXGEN_Q_V_OBJECT_LINEAR                                0x00002401

#define NV1196_SET_TEXTURE_MATRIX0_ENABLE                                  0x000003e0
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V                                      31:0
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE                          0x00000000
#define NV1196_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE                           0x00000001

#define NV1196_SET_TEXTURE_MATRIX1_ENABLE                                  0x000003e4
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V                                      31:0
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE                          0x00000000
#define NV1196_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE                           0x00000001

#define NV1196_SET_TLMODE                                                  0x000003e8
#define NV1196_SET_TLMODE_PASSTHROUGH                                             0:0
#define NV1196_SET_TLMODE_PASSTHROUGH_TRUE                                 0x00000001
#define NV1196_SET_TLMODE_PASSTHROUGH_FALSE                                0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_0                                              1:1
#define NV1196_SET_TLMODE_W_DIVIDE_0_DISABLE                               0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_0_ENABLE                                0x00000001
#define NV1196_SET_TLMODE_W_DIVIDE_1                                              2:2
#define NV1196_SET_TLMODE_W_DIVIDE_1_DISABLE                               0x00000000
#define NV1196_SET_TLMODE_W_DIVIDE_1_ENABLE                                0x00000001

#define NV1196_SET_POINT_SIZE                                              0x000003ec
#define NV1196_SET_POINT_SIZE_V                                                  31:0

#define NV1196_SET_SWATH_WIDTH                                             0x000003f0
#define NV1196_SET_SWATH_WIDTH_V                                                 31:0
#define NV1196_SET_SWATH_WIDTH_V_8                                         0x00000000
#define NV1196_SET_SWATH_WIDTH_V_16                                        0x00000001
#define NV1196_SET_SWATH_WIDTH_V_32                                        0x00000002
#define NV1196_SET_SWATH_WIDTH_V_64                                        0x00000003

#define NV1196_SET_FLAT_SHADE_OP                                           0x000003f4
#define NV1196_SET_FLAT_SHADE_OP_V                                               31:0
#define NV1196_SET_FLAT_SHADE_OP_V_LAST_VTX                                0x00000000
#define NV1196_SET_FLAT_SHADE_OP_V_FIRST_VTX                               0x00000001

#define NV1196_SET_MODEL_VIEW_MATRIX0(i)                           (0x00000400+(i)*4)
#define NV1196_SET_MODEL_VIEW_MATRIX0_V                                          31:0

#define NV1196_SET_MODEL_VIEW_MATRIX1(i)                           (0x00000440+(i)*4)
#define NV1196_SET_MODEL_VIEW_MATRIX1_V                                          31:0

#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                   (0x00000480+(i)*4)
#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                  31:0

#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                   (0x000004c0+(i)*4)
#define NV1196_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                  31:0

#define NV1196_SET_COMPOSITE_MATRIX(i)                             (0x00000500+(i)*4)
#define NV1196_SET_COMPOSITE_MATRIX_V                                            31:0

#define NV1196_SET_TEXTURE_MATRIX0(i)                              (0x00000540+(i)*4)
#define NV1196_SET_TEXTURE_MATRIX0_V                                             31:0

#define NV1196_SET_TEXTURE_MATRIX1(i)                              (0x00000580+(i)*4)
#define NV1196_SET_TEXTURE_MATRIX1_V                                             31:0

#define NV1196_SET_TEXGEN_SPLANE0(i)                               (0x00000600+(i)*4)
#define NV1196_SET_TEXGEN_SPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_TPLANE0(i)                               (0x00000610+(i)*4)
#define NV1196_SET_TEXGEN_TPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_RPLANE0(i)                               (0x00000620+(i)*4)
#define NV1196_SET_TEXGEN_RPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_QPLANE0(i)                               (0x00000630+(i)*4)
#define NV1196_SET_TEXGEN_QPLANE0_V                                              31:0

#define NV1196_SET_TEXGEN_SPLANE1(i)                               (0x00000640+(i)*4)
#define NV1196_SET_TEXGEN_SPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_TPLANE1(i)                               (0x00000650+(i)*4)
#define NV1196_SET_TEXGEN_TPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_RPLANE1(i)                               (0x00000660+(i)*4)
#define NV1196_SET_TEXGEN_RPLANE1_V                                              31:0

#define NV1196_SET_TEXGEN_QPLANE1(i)                               (0x00000670+(i)*4)
#define NV1196_SET_TEXGEN_QPLANE1_V                                              31:0

#define NV1196_SET_FOG_PARAMS(i)                                   (0x00000680+(i)*4)
#define NV1196_SET_FOG_PARAMS_V                                                  31:0

#define NV1196_SET_FOG_PLANE(i)                                    (0x0000068c+(i)*4)
#define NV1196_SET_FOG_PLANE_V                                                   31:0

#define NV1196_SET_SPECULAR_PARAMS(i)                              (0x000006a0+(i)*4)
#define NV1196_SET_SPECULAR_PARAMS_V                                             31:0

#define NV1196_SET_SCENE_AMBIENT_COLOR(i)                          (0x000006c4+(i)*4)
#define NV1196_SET_SCENE_AMBIENT_COLOR_V                                         31:0

#define NV1196_SET_VIEWPORT_OFFSET(i)                              (0x000006e8+(i)*4)
#define NV1196_SET_VIEWPORT_OFFSET_V                                             31:0

#define NV1196_SET_POINT_PARAMS(i)                                 (0x000006f8+(i)*4)
#define NV1196_SET_POINT_PARAMS_V                                                31:0

#define NV1196_SET_EYE_POSITION(i)                                 (0x00000718+(i)*4)
#define NV1196_SET_EYE_POSITION_V                                                31:0

#define NV1196_SET_EYE_DIRECTION_SW(i)                             (0x0000072c+(i)*4)

#define NV1196_SET_LIGHT_AMBIENT_COLOR(i,j)                (0x00000800+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_AMBIENT_COLOR_V                                         31:0

#define NV1196_SET_LIGHT_DIFFUSE_COLOR(i,j)                (0x0000080c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_DIFFUSE_COLOR_V                                         31:0

#define NV1196_SET_LIGHT_SPECULAR_COLOR(i,j)               (0x00000818+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPECULAR_COLOR_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_RANGE(i)                          (0x00000824+(i)*128)
#define NV1196_SET_LIGHT_LOCAL_RANGE_V                                           31:0

#define NV1196_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)         (0x00000828+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_INFINITE_HALF_VECTOR_V                                  31:0

#define NV1196_SET_LIGHT_INFINITE_DIRECTION(i,j)           (0x00000834+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_INFINITE_DIRECTION_V                                    31:0

#define NV1196_SET_LIGHT_SPOT_FALLOFF(i,j)                 (0x00000840+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPOT_FALLOFF_V                                          31:0

#define NV1196_SET_LIGHT_SPOT_DIRECTION(i,j)               (0x0000084c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_SPOT_DIRECTION_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_POSITION(i,j)               (0x0000085c+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_LOCAL_POSITION_V                                        31:0

#define NV1196_SET_LIGHT_LOCAL_ATTENUATION(i,j)            (0x00000868+(i)*128+(j)*4)
#define NV1196_SET_LIGHT_LOCAL_ATTENUATION_V                                     31:0

#define NV1196_SET_VERTEX3F(i)                                     (0x00000c00+(i)*4)
#define NV1196_SET_VERTEX3F_V                                                    31:0

#define NV1196_SET_VERTEX4F(i)                                     (0x00000c18+(i)*4)
#define NV1196_SET_VERTEX4F_V                                                    31:0

#define NV1196_SET_VERTEX4S(i)                                     (0x00000c28+(i)*4)
#define NV1196_SET_VERTEX4S_V                                                    31:0

#define NV1196_SET_NORMAL3F(i)                                     (0x00000c30+(i)*4)
#define NV1196_SET_NORMAL3F_V                                                    31:0

#define NV1196_SET_NORMAL3S(i)                                     (0x00000c40+(i)*4)
#define NV1196_SET_NORMAL3S_V                                                    31:0

#define NV1196_SET_DIFFUSE_COLOR4F(i)                              (0x00000c50+(i)*4)
#define NV1196_SET_DIFFUSE_COLOR4F_V                                             31:0

#define NV1196_SET_DIFFUSE_COLOR3F(i)                              (0x00000c60+(i)*4)
#define NV1196_SET_DIFFUSE_COLOR3F_V                                             31:0

#define NV1196_SET_DIFFUSE_COLOR4UB                                        0x00000c6c
#define NV1196_SET_DIFFUSE_COLOR4UB_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR4F(i)                             (0x00000c70+(i)*4)
#define NV1196_SET_SPECULAR_COLOR4F_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR3F(i)                             (0x00000c80+(i)*4)
#define NV1196_SET_SPECULAR_COLOR3F_V                                            31:0

#define NV1196_SET_SPECULAR_COLOR4UB                                       0x00000c8c
#define NV1196_SET_SPECULAR_COLOR4UB_V                                           31:0

#define NV1196_SET_TEXCOORD0_2F(i)                                 (0x00000c90+(i)*4)
#define NV1196_SET_TEXCOORD0_2F_V                                                31:0

#define NV1196_SET_TEXCOORD0_2S                                            0x00000c98
#define NV1196_SET_TEXCOORD0_2S_V                                                31:0

#define NV1196_SET_TEXCOORD0_4F(i)                                 (0x00000ca0+(i)*4)
#define NV1196_SET_TEXCOORD0_4F_V                                                31:0

#define NV1196_SET_TEXCOORD0_4S(i)                                 (0x00000cb0+(i)*4)
#define NV1196_SET_TEXCOORD0_4S_V                                                31:0

#define NV1196_SET_TEXCOORD1_2F(i)                                 (0x00000cb8+(i)*4)
#define NV1196_SET_TEXCOORD1_2F_V                                                31:0

#define NV1196_SET_TEXCOORD1_2S                                            0x00000cc0
#define NV1196_SET_TEXCOORD1_2S_V                                                31:0

#define NV1196_SET_TEXCOORD1_4F(i)                                 (0x00000cc8+(i)*4)
#define NV1196_SET_TEXCOORD1_4F_V                                                31:0

#define NV1196_SET_TEXCOORD1_4S(i)                                 (0x00000cd8+(i)*4)
#define NV1196_SET_TEXCOORD1_4S_V                                                31:0

#define NV1196_SET_FOG1F                                                   0x00000ce0
#define NV1196_SET_FOG1F_V                                                       31:0

#define NV1196_SET_WEIGHT1F                                                0x00000ce4
#define NV1196_SET_WEIGHT1F_V                                                    31:0

#define NV1196_SET_EDGE_FLAG                                               0x00000cec
#define NV1196_SET_EDGE_FLAG_V                                                   31:0

#define NV1196_INVALIDATE_VERTEX_CACHE_FILE                                0x00000cf0
#define NV1196_INVALIDATE_VERTEX_CACHE_FILE_V                                    31:0

#define NV1196_INVALIDATE_VERTEX_FILE                                      0x00000cf4
#define NV1196_INVALIDATE_VERTEX_FILE_V                                          31:0

#define NV1196_TL_NOP                                                      0x00000cf8
#define NV1196_TL_NOP_V                                                          31:0

#define NV1196_TL_SYNC                                                     0x00000cfc
#define NV1196_TL_SYNC_V                                                         31:0

#define NV1196_SET_VERTEX_ARRAY_OFFSET                                     0x00000d00
#define NV1196_SET_VERTEX_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_DIFFUSE_ARRAY_OFFSET                                    0x00000d08
#define NV1196_SET_DIFFUSE_ARRAY_OFFSET_OFFSET                                   31:0

#define NV1196_SET_SPECULAR_ARRAY_OFFSET                                   0x00000d10
#define NV1196_SET_SPECULAR_ARRAY_OFFSET_OFFSET                                  31:0

#define NV1196_SET_TEX_COORD0_ARRAY_OFFSET                                 0x00000d18
#define NV1196_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET                                31:0

#define NV1196_SET_TEX_COORD1_ARRAY_OFFSET                                 0x00000d20
#define NV1196_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET                                31:0

#define NV1196_SET_NORMAL_ARRAY_OFFSET                                     0x00000d28
#define NV1196_SET_NORMAL_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_WEIGHT_ARRAY_OFFSET                                     0x00000d30
#define NV1196_SET_WEIGHT_ARRAY_OFFSET_OFFSET                                    31:0

#define NV1196_SET_FOG_ARRAY_OFFSET                                        0x00000d38
#define NV1196_SET_FOG_ARRAY_OFFSET_OFFSET                                       31:0

#define NV1196_SET_VERTEX_ARRAY_FORMAT                                     0x00000d04
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W                                        31:24
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W_NONE                              0x00000000
#define NV1196_SET_VERTEX_ARRAY_FORMAT_W_PRESENT                           0x00000001
#define NV1196_SET_VERTEX_ARRAY_FORMAT_STRIDE                                    23:8
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_2                              0x00000002
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV1196_SET_VERTEX_ARRAY_FORMAT_SIZE_4                              0x00000004
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_DIFFUSE_ARRAY_FORMAT                                    0x00000d0c
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_STRIDE                                   31:8
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE                                      7:4
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0                             0x00000000
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3                             0x00000003
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4                             0x00000004
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE                                      3:0
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA            0x00000000
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT                         0x00000002
#define NV1196_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA            0x00000004

#define NV1196_SET_SPECULAR_ARRAY_FORMAT                                   0x00000d14
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_STRIDE                                  31:8
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE                                     7:4
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_0                            0x00000000
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_3                            0x00000003
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_SIZE_4                            0x00000004
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE                                     3:0
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA           0x00000000
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT                        0x00000002
#define NV1196_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA           0x00000004

#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT                                 0x00000d1c
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE                                31:8
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE                                   7:4
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0                          0x00000000
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1                          0x00000001
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2                          0x00000002
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3                          0x00000003
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4                          0x00000004
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE                                   3:0
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT                      0x00000001
#define NV1196_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT                      0x00000002

#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT                                 0x00000d24
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE                                31:8
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE                                   7:4
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0                          0x00000000
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1                          0x00000001
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2                          0x00000002
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3                          0x00000003
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4                          0x00000004
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE                                   3:0
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT                      0x00000001
#define NV1196_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT                      0x00000002

#define NV1196_SET_NORMAL_ARRAY_FORMAT                                     0x00000d2c
#define NV1196_SET_NORMAL_ARRAY_FORMAT_STRIDE                                    31:8
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV1196_SET_NORMAL_ARRAY_FORMAT_SIZE_3                              0x00000003
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_WEIGHT_ARRAY_FORMAT                                     0x00000d34
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_STRIDE                                    31:8
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE                                       7:4
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE_0                              0x00000000
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_SIZE_1                              0x00000001
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE                                       3:0
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT                          0x00000001
#define NV1196_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT                          0x00000002

#define NV1196_SET_FOG_ARRAY_FORMAT                                        0x00000d3c
#define NV1196_SET_FOG_ARRAY_FORMAT_STRIDE                                       31:8
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE                                          7:4
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE_0                                 0x00000000
#define NV1196_SET_FOG_ARRAY_FORMAT_SIZE_1                                 0x00000001
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE                                          3:0
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE_SHORT                             0x00000001
#define NV1196_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT                             0x00000002

#define NV1196_SET_LOGIC_OP_ENABLE                                         0x00000d40
#define NV1196_SET_LOGIC_OP_ENABLE_V                                             31:0
#define NV1196_SET_LOGIC_OP_ENABLE_V_FALSE                                 0x00000000
#define NV1196_SET_LOGIC_OP_ENABLE_V_TRUE                                  0x00000001

#define NV1196_SET_LOGIC_OP                                                0x00000d44
#define NV1196_SET_LOGIC_OP_V                                                    31:0
#define NV1196_SET_LOGIC_OP_V_CLEAR                                        0x00001500
#define NV1196_SET_LOGIC_OP_V_AND                                          0x00001501
#define NV1196_SET_LOGIC_OP_V_AND_REVERSE                                  0x00001502
#define NV1196_SET_LOGIC_OP_V_COPY                                         0x00001503
#define NV1196_SET_LOGIC_OP_V_AND_INVERTED                                 0x00001504
#define NV1196_SET_LOGIC_OP_V_NOOP                                         0x00001505
#define NV1196_SET_LOGIC_OP_V_XOR                                          0x00001506
#define NV1196_SET_LOGIC_OP_V_OR                                           0x00001507
#define NV1196_SET_LOGIC_OP_V_NOR                                          0x00001508
#define NV1196_SET_LOGIC_OP_V_EQUIV                                        0x00001509
#define NV1196_SET_LOGIC_OP_V_INVERT                                       0x0000150A
#define NV1196_SET_LOGIC_OP_V_OR_REVERSE                                   0x0000150B
#define NV1196_SET_LOGIC_OP_V_COPY_INVERTED                                0x0000150C
#define NV1196_SET_LOGIC_OP_V_OR_INVERTED                                  0x0000150D
#define NV1196_SET_LOGIC_OP_V_NAND                                         0x0000150E
#define NV1196_SET_LOGIC_OP_V_SET                                          0x0000150F

#define NV1196_SET_BEGIN_END                                               0x00000dfc
#define NV1196_SET_BEGIN_END_OP                                                  31:0
#define NV1196_SET_BEGIN_END_OP_END                                        0x00000000
#define NV1196_SET_BEGIN_END_OP_POINTS                                     0x00000001
#define NV1196_SET_BEGIN_END_OP_LINES                                      0x00000002
#define NV1196_SET_BEGIN_END_OP_LINE_LOOP                                  0x00000003
#define NV1196_SET_BEGIN_END_OP_LINE_STRIP                                 0x00000004
#define NV1196_SET_BEGIN_END_OP_TRIANGLES                                  0x00000005
#define NV1196_SET_BEGIN_END_OP_TRIANGLE_STRIP                             0x00000006
#define NV1196_SET_BEGIN_END_OP_TRIANGLE_FAN                               0x00000007
#define NV1196_SET_BEGIN_END_OP_QUADS                                      0x00000008
#define NV1196_SET_BEGIN_END_OP_QUAD_STRIP                                 0x00000009
#define NV1196_SET_BEGIN_END_OP_POLYGON                                    0x0000000A

#define NV1196_ARRAY_ELEMENT16(i)                                  (0x00000e00+(i)*4)
#define NV1196_ARRAY_ELEMENT16_VERTEX0                                           15:0
#define NV1196_ARRAY_ELEMENT16_VERTEX1                                          31:16

#define NV1196_SET_BEGIN_END2                                              0x000010fc
#define NV1196_SET_BEGIN_END2_OP                                                 31:0
#define NV1196_SET_BEGIN_END2_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END2_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END2_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END2_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END2_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END2_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END2_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END2_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END2_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END2_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END2_OP_POLYGON                                   0x0000000A

#define NV1196_ARRAY_ELEMENT32(i)                                  (0x00001100+(i)*4)
#define NV1196_ARRAY_ELEMENT32_V                                                 31:0

#define NV1196_SET_BEGIN_END3                                              0x000013fc
#define NV1196_SET_BEGIN_END3_OP                                                 31:0
#define NV1196_SET_BEGIN_END3_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END3_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END3_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END3_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END3_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END3_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END3_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END3_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END3_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END3_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END3_OP_POLYGON                                   0x0000000A

#define NV1196_DRAW_ARRAYS(i)                                      (0x00001400+(i)*4)
#define NV1196_DRAW_ARRAYS_COUNT                                                31:24
#define NV1196_DRAW_ARRAYS_START_INDEX                                           23:0

#define NV1196_SET_BEGIN_END4                                              0x000017fc
#define NV1196_SET_BEGIN_END4_OP                                                 31:0
#define NV1196_SET_BEGIN_END4_OP_END                                       0x00000000
#define NV1196_SET_BEGIN_END4_OP_POINTS                                    0x00000001
#define NV1196_SET_BEGIN_END4_OP_LINES                                     0x00000002
#define NV1196_SET_BEGIN_END4_OP_LINE_LOOP                                 0x00000003
#define NV1196_SET_BEGIN_END4_OP_LINE_STRIP                                0x00000004
#define NV1196_SET_BEGIN_END4_OP_TRIANGLES                                 0x00000005
#define NV1196_SET_BEGIN_END4_OP_TRIANGLE_STRIP                            0x00000006
#define NV1196_SET_BEGIN_END4_OP_TRIANGLE_FAN                              0x00000007
#define NV1196_SET_BEGIN_END4_OP_QUADS                                     0x00000008
#define NV1196_SET_BEGIN_END4_OP_QUAD_STRIP                                0x00000009
#define NV1196_SET_BEGIN_END4_OP_POLYGON                                   0x0000000A

#define NV1196_INLINE_ARRAY(i)                                     (0x00001800+(i)*4)
#define NV1196_INLINE_ARRAY_V                                                    31:0

#define NV1196_DEBUG_INIT(i)                                       (0x00001600+(i)*4)
#define NV1196_DEBUG_INIT_V                                                      31:0


// This typedef really should be the same as Nv20KelvinPrimitive, but this
// causes the NV03/NV04_CHANNEL_PIO union to become too large for the 16bit
// compiler. Since we don't expect to use a PIO channel with Celsius, we'll
// just use the old DWORD size typedef.

typedef NvV32 Nv097Typedef;

/* class NV20_KELVIN_PRIMITIVE */
#define  NV20_KELVIN_PRIMITIVE                                    (0x00000097)
/* NvNotification[] elements */
#define NV097_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV097_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV097_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV097_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV097_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV097_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV097_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
typedef volatile struct {
    // system method
    NvV32 ctx_Switch;
    NvV32 Reserved0004[0xfc/4];
    NvV32 NoOperation;
    NvV32 Notify;
    NvV32 SetWarningEnable;
    NvV32 GetState;
    NvV32 WaitForIdle;
    NvV32 Reserved0114[0xc/4];
    NvU32 SetFlipRead;
    NvU32 SetFlipWrite;
    NvU32 SetFlipModulo;
    NvV32 FlipIncrementWrite;
    NvV32 FlipStall;
    NvV32 Reserved0134[0xc/4];
    NvV32 PmTrigger;
    NvV32 Reserved0144[0x3c/4];
    NvU32 SetContextDmaNotifies;
    NvU32 SetContextDmaA;
    NvU32 SetContextDmaB;
    NvV32 Reserved018c[0x4/4];
    NvU32 SetContextDmaState;
    NvU32 SetContextDmaColor;
    NvU32 SetContextDmaZeta;
    NvU32 SetContextDmaVertexA;
    NvU32 SetContextDmaVertexB;
    NvU32 SetContextDmaSemaphore;
    NvU32 SetContextDmaReport;
    NvV32 Reserved01ac[0x54/4];
    NvV32 SetSurfaceClipHorizontal;
    NvV32 SetSurfaceClipVertical;
    NvV32 SetSurfaceFormat;
    NvV32 SetSurfacePitch;
    NvU32 SetSurfaceColorOffset;
    NvU32 SetSurfaceZetaOffset;
    NvV32 Reserved0218[0x48/4];
    NvV32 SetCombinerAlphaICW[8];
    NvV32 Reserved0280[0x8/4];
    NvV32 SetCombinerSpecularFogCW0;
    NvV32 SetCombinerSpecularFogCW1;
    NvV32 SetControl0;
    NvV32 SetLightControl;
    NvV32 SetColorMaterial;
    NvV32 SetFogMode;
    NvV32 SetFogGenMode;
    NvV32 SetFogEnable;
    NvV32 SetFogColor;
    NvV32 Reserved02ac[0x8/4];
    NvV32 SetWindowClipType;
    NvV32 Reserved02b8[0x8/4];
    NvV32 SetWindowClipHorizontal[8];
    NvV32 SetWindowClipVertical[8];
    NvV32 SetAlphaTestEnable;
    NvV32 SetBlendEnable;
    NvV32 SetCullFaceEnable;
    NvV32 SetDepthTestEnable;
    NvV32 SetDitherEnable;
    NvV32 SetLightingEnable;
    NvV32 SetPointParamsEnable;
    NvV32 SetPointSmoothEnable;
    NvV32 SetLineSmoothEnable;
    NvV32 SetPolySmoothEnable;
    NvV32 SetSkinMode;
    NvV32 SetStencilTestEnable;
    NvV32 SetPolyOffsetPointEnable;
    NvV32 SetPolyOffsetLineEnable;
    NvV32 SetPolyOffsetFillEnable;
    NvV32 SetAlphaFunc;
    NvU32 SetAlphaRef;
    NvV32 SetBlendFuncSfactor;
    NvV32 SetBlendFuncDfactor;
    NvU32 SetBlendColor;
    NvV32 SetBlendEquation;
    NvV32 SetDepthFunc;
    NvV32 SetColorMask;
    NvV32 SetDepthMask;
    NvU32 SetStencilMask;
    NvV32 SetStencilFunc;
    NvU32 SetStencilFuncRef;
    NvU32 SetStencilFuncMask;
    NvV32 SetStencilOpFail;
    NvV32 SetStencilOpZfail;
    NvV32 SetStencilOpZpass;
    NvV32 SetShadeMode;
    NvU32 SetLineWidth;
    NvF32 SetPolygonOffsetScaleFactor;
    NvF32 SetPolygonOffsetBias;
    NvV32 SetFrontPolygonMode;
    NvV32 SetBackPolygonMode;
    NvF32 SetClipMin;
    NvF32 SetClipMax;
    NvV32 SetCullFace;
    NvV32 SetFrontFace;
    NvV32 SetNormalizationEnable;
    NvF32 SetMaterialEmission[3];
    NvF32 SetMaterialAlpha;
    NvV32 SetSpecularEnable;
    NvV32 SetLightEnableMask;
    struct {
    NvV32 S;
    NvV32 T;
    NvV32 R;
    NvV32 Q;
    } SetTexgen[4];
    NvV32 Reserved0400[0x20/4];
    NvV32 SetTextureMatrixEnable[4];
    NvV32 Reserved0430[0xc/4];
    NvU32 SetPointSize;
    NvF32 SetProjectionMatrix[16];
    NvF32 SetModelViewMatrix0[16];
    NvF32 SetModelViewMatrix1[16];
    NvF32 SetModelViewMatrix2[16];
    NvF32 SetModelViewMatrix3[16];
    NvF32 SetInverseModelViewMatrix0[16];
    NvF32 SetInverseModelViewMatrix1[16];
    NvF32 SetInverseModelViewMatrix2[16];
    NvF32 SetInverseModelViewMatrix3[16];
    NvF32 SetCompositeMatrix[16];
    NvF32 SetTextureMatrix0[16];
    NvF32 SetTextureMatrix1[16];
    NvF32 SetTextureMatrix2[16];
    NvF32 SetTextureMatrix3[16];
    NvV32 Reserved07c0[0x80/4];
    struct {
    NvF32 S[4];
    NvF32 T[4];
    NvF32 R[4];
    NvF32 Q[4];
    } SetTexgenPlane[4];
    NvV32 Reserved0940[0x80/4];
    NvF32 SetFogParams[3];
    NvV32 SetTexgenViewModel;
    NvF32 SetFogPlane[4];
    NvF32 SetSpecularParams[6];
    NvV32 SetSwathWidth;
    NvV32 SetFlatShadeOp;
    NvV32 Reserved0a00[0x10/4];
    NvF32 SetSceneAmbientColor[3];
    NvV32 Reserved0a1c[0x4/4];
    NvF32 SetViewportOffset[4];
    NvF32 SetPointParams[8];
    NvF32 SetEyePosition[4];
    NvV32 SetCombinerFactor0[8];
    NvV32 SetCombinerFactor1[8];
    NvV32 SetCombinerAlphaOCW[8];
    NvV32 SetCombinerColorICW[8];
    NvU32 SetColorKeyColor[4];
    NvF32 SetViewportScale[4];
    NvU32 SetTransformProgram[32];
    NvF32 SetTransformConstant[32];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvV32 Reserved0c24[0x1c/4];
    } SetBackLight[8];
    NvV32 Reserved0e00[0x200/4];
    struct {
    NvF32 AmbientColor[3];
    NvF32 DiffuseColor[3];
    NvF32 SpecularColor[3];
    NvF32 LocalRange;
    NvF32 InfiniteHalfVector[3];
    NvF32 InfiniteDirection[3];
    NvF32 SpotFalloff[3];
    NvF32 SpotDirection[4];
    NvF32 LocalPosition[3];
    NvF32 LocalAttenuation[3];
    NvV32 Reserved1074[0xc/4];
    } SetLight[8];
    NvV32 Reserved1400[0x7c/4];
    NvV32 SetStippleControl;
    NvU32 SetStipplePattern[32];
    NvF32 SetVertex3f[3];
    NvV32 Reserved150c[0xc/4];
    NvF32 SetVertex4f[4];
    NvS32 SetVertex4s[2];
    NvF32 SetNormal3f[3];
    NvV32 Reserved153c[0x4/4];
    NvS32 SetNormal3s[2];
    NvV32 Reserved1548[0x8/4];
    NvF32 SetDiffuseColor4f[4];
    NvF32 SetDiffuseColor3f[3];
    NvU32 SetDiffuseColor4ub;
    NvF32 SetSpecularColor4f[4];
    NvF32 SetSpecularColor3f[3];
    NvU32 SetSpecularColor4ub;
    NvF32 SetTexcoord0_2f[2];
    NvS32 SetTexcoord0_2s;
    NvV32 Reserved159c[0x4/4];
    NvF32 SetTexcoord0_4f[4];
    NvS32 SetTexcoord0_4s[2];
    NvF32 SetTexcoord1_2f[2];
    NvS32 SetTexcoord1_2s;
    NvV32 Reserved15c4[0x4/4];
    NvF32 SetTexcoord1_4f[4];
    NvS32 SetTexcoord1_4s[2];
    NvF32 SetTexcoord2_2f[2];
    NvS32 SetTexcoord2_2s;
    NvV32 Reserved15ec[0x4/4];
    NvF32 SetTexcoord2_4f[4];
    NvS32 SetTexcoord2_4s[2];
    NvF32 SetTexcoord3_2f[2];
    NvS32 SetTexcoord3_2s;
    NvV32 Reserved1614[0xc/4];
    NvF32 SetTexcoord3_4f[4];
    NvS32 SetTexcoord3_4s[2];
    NvV32 Reserved1638[0x60/4];
    NvF32 SetFog1f;
    NvF32 SetWeight1f;
    NvF32 SetWeight2f[2];
    NvV32 Reserved16a8[0x8/4];
    NvF32 SetWeight3f[3];
    NvV32 SetEdgeFlag;
    NvF32 SetWeight4f[4];
    NvF32 SetTransformFixedConst3[4];
    NvF32 SetTransformFixedConst0[4];
    NvF32 SetTransformFixedConst1[4];
    NvF32 SetTransformFixedConst2[4];
    NvV32 InvalidateVertexCacheFile;
    NvV32 InvalidateVertexFile;
    NvV32 TlNop;
    NvV32 TlSync;
    NvV32 SetVertexDataArrayOffset[16];
    NvV32 SetVertexDataArrayFormat[16];
    NvF32 SetBackSceneAmbientColor[3];
    NvF32 SetBackMaterialAlpha;
    NvF32 SetBackMaterialEmission[3];
    NvV32 SetLogicOpEnable;
    NvV32 SetLogicOp;
    NvV32 SetTwoSideLightEn;
    NvV32 ClearReportValue;
    NvV32 SetZpassPixelCountEnable;
    NvV32 GetReport;
    NvF32 SetTLConstZero[3];
    NvF32 SetEyeDirection[3];
    NvF32 SetLinearFogConst[3];
    NvV32 SetShaderClipPlaneMode;
    NvV32 SetBeginEnd;
    NvV32 ArrayElement16;
    NvV32 Reserved1804[0x4/4];
    NvU32 ArrayElement32;
    NvV32 Reserved180c[0x4/4];
    NvV32 DrawArrays;
    NvV32 Reserved1814[0x4/4];
    NvU32 InlineArray;
    NvF32 SetEyeVector[3];
    NvU32 InlineVertexReuse;
    NvV32 Reserved182c[0x54/4];
    struct {
    NvF32 M[2];
    } SetVertexData2f[16];
    NvS32 SetVertexData2s[16];
    NvS32 SetVertexData4ub[16];
    struct {
    NvS32 M[2];
    } SetVertexData4s[16];
    struct {
    NvF32 M[4];
    } SetVertexData4f[16];
    struct {
    NvU32 Offset;
    NvV32 Format;
    NvV32 Address;
    NvV32 Control0;
    NvV32 Control1;
    NvV32 Filter;
    NvV32 Reserved1b18[0x4/4];
    NvV32 ImageRect;
    NvV32 Palette;
    NvU32 BorderColor;
    NvF32 SetBumpEnvMat00;
    NvF32 SetBumpEnvMat01;
    NvF32 SetBumpEnvMat11;
    NvF32 SetBumpEnvMat10;
    NvF32 SetBumpEnvScale;
    NvF32 SetBumpEnvOffset;
    } SetTexture[4];
    NvV32 Reserved1c00[0x164/4];
    NvV32 ParkAttribute;
    NvV32 UnparkAttribute;
    NvU32 SetSemaphoreOffset;
    NvU32 BackEndWriteSemaphoreRelease;
    NvU32 TextureReadSemaphoreRelease;
    NvV32 SetZMinMaxControl;
    NvV32 SetAntiAliasingControl;
    NvV32 SetCompressZBufferEn;
    NvV32 SetOccludeZStencilEn;
    NvV32 Reserved1d88[0x4/4];
    NvU32 SetZStencilClearValue;
    NvU32 SetColorClearValue;
    NvV32 ClearSurface;
    NvV32 SetClearRectHorizontal;
    NvV32 SetClearRectVertical;
    NvV32 Reserved1da0[0x40/4];
    NvV32 SetBeginPatch0;
    NvV32 SetBeginPatch1;
    NvV32 SetBeginPatch2;
    NvV32 SetBeginPatch3;
    NvV32 SetEndPatch;
    NvV32 SetBeginEndSwatch;
    NvV32 SetBeginEndCurve;
    NvV32 Reserved1dfc[0x4/4];
    NvF32 SetCurveCoefficients[4];
    NvV32 SetBeginTransition0;
    NvV32 SetBeginTransition1;
    NvV32 SetBeginTransition2;
    NvV32 SetEndTransition;
    NvV32 SetSpecularFogFactor[2];
    NvF32 SetBackSpecularParams[6];
    NvV32 SetCombinerColorOCW[8];
    NvV32 SetCombinerControl;
    NvV32 Reserved1e64[0x4/4];
    NvF32 SetShadowZSlopeThreshold;
    NvV32 SetShadowDepthFunc;
    NvV32 SetShaderStageProgram;
    NvV32 SetDotRGBMapping;
    NvV32 SetShaderOtherStageInput;
    NvV32 Reserved1e7c[0x4/4];
    NvF32 SetTransformData[4];
    NvU32 LaunchTransformProgram;
    NvV32 SetTransformExecutionMode;
    NvV32 SetTransformProgramCxtWriteEn;
    NvU32 SetTransformProgramLoad;
    NvU32 SetTransformProgramStart;
    NvU32 SetTransformConstantLoad;
    NvV32 Reserved1ea8[0x118/4];
    NvV32 DebugInit[10];
    NvV32 Reserved1fe8[0x18/4];
} Nv20KelvinPrimitive;

#define NV097_NO_OPERATION                                                  0x00000100

#define NV097_NOTIFY                                                        0x00000104
#define NV097_NOTIFY_TYPE                                                         31:0
#define NV097_NOTIFY_TYPE_WRITE_ONLY                                        0x00000000
#define NV097_NOTIFY_TYPE_WRITE_THEN_AWAKEN                                 0x00000001

#define NV097_SET_WARNING_ENABLE                                            0x00000108
#define NV097_SET_WARNING_ENABLE_V                                                31:0
#define NV097_SET_WARNING_ENABLE_V_STOP                                     0x00000000
#define NV097_SET_WARNING_ENABLE_V_WRITE_ONLY                               0x00000001
#define NV097_SET_WARNING_ENABLE_V_WRITE_THEN_AWAKEN                        0x00000002

#define NV097_GET_STATE                                                     0x0000010c
#define NV097_GET_STATE_GETSTATE                                                  31:0
#define NV097_GET_STATE_GETSTATE_ALL_STATE                                  0x00000001
#define NV097_GET_STATE_GETSTATE_PUT_ALL_STATE                              0x00000002

#define NV097_WAIT_FOR_IDLE                                                 0x00000110

#define NV097_PM_TRIGGER                                                    0x00000140
#define NV097_PM_TRIGGER_V                                                        31:0
#define NV097_PM_TRIGGER_V_NOP                                              0x00000000
#define NV097_PM_TRIGGER_V_TRIGGER                                          0x00000001

#define NV097_SET_FLIP_READ                                                 0x00000120
#define NV097_SET_FLIP_READ_V                                                     31:0

#define NV097_SET_FLIP_WRITE                                                0x00000124
#define NV097_SET_FLIP_WRITE_V                                                    31:0

#define NV097_SET_FLIP_MODULO                                               0x00000128
#define NV097_SET_FLIP_MODULO_V                                                   31:0

#define NV097_FLIP_INCREMENT_WRITE                                          0x0000012c

#define NV097_FLIP_STALL                                                    0x00000130

#define NV097_SET_CONTEXT_DMA_NOTIFIES                                      0x00000180
#define NV097_SET_CONTEXT_DMA_NOTIFIES_V                                          31:0

#define NV097_SET_CONTEXT_DMA_A                                             0x00000184
#define NV097_SET_CONTEXT_DMA_A_V                                                 31:0

#define NV097_SET_CONTEXT_DMA_B                                             0x00000188
#define NV097_SET_CONTEXT_DMA_B_V                                                 31:0

#define NV097_SET_CONTEXT_DMA_STATE                                         0x00000190
#define NV097_SET_CONTEXT_DMA_STATE_V                                             31:0

#define NV097_SET_CONTEXT_DMA_COLOR                                         0x00000194
#define NV097_SET_CONTEXT_DMA_COLOR_V                                             31:0

#define NV097_SET_CONTEXT_DMA_ZETA                                          0x00000198
#define NV097_SET_CONTEXT_DMA_ZETA_V                                              31:0

#define NV097_SET_CONTEXT_DMA_VERTEX_A                                      0x0000019c
#define NV097_SET_CONTEXT_DMA_VERTEX_A_V                                          31:0

#define NV097_SET_CONTEXT_DMA_VERTEX_B                                      0x000001a0
#define NV097_SET_CONTEXT_DMA_VERTEX_B_V                                          31:0

#define NV097_SET_CONTEXT_DMA_SEMAPHORE                                     0x000001a4
#define NV097_SET_CONTEXT_DMA_SEMAPHORE_V                                         31:0

#define NV097_SET_CONTEXT_DMA_REPORT                                        0x000001a8
#define NV097_SET_CONTEXT_DMA_REPORT_V                                            31:0

#define NV097_SET_SURFACE_CLIP_HORIZONTAL                                   0x00000200
#define NV097_SET_SURFACE_CLIP_HORIZONTAL_X                                       15:0
#define NV097_SET_SURFACE_CLIP_HORIZONTAL_WIDTH                                  31:16

#define NV097_SET_SURFACE_CLIP_VERTICAL                                     0x00000204
#define NV097_SET_SURFACE_CLIP_VERTICAL_Y                                         15:0
#define NV097_SET_SURFACE_CLIP_VERTICAL_HEIGHT                                   31:16

#define NV097_SET_SURFACE_PITCH                                             0x0000020c
#define NV097_SET_SURFACE_PITCH_COLOR                                             15:0
#define NV097_SET_SURFACE_PITCH_ZETA                                             31:16

#define NV097_SET_SURFACE_COLOR_OFFSET                                      0x00000210
#define NV097_SET_SURFACE_COLOR_OFFSET_V                                          31:0

#define NV097_SET_SURFACE_ZETA_OFFSET                                       0x00000214
#define NV097_SET_SURFACE_ZETA_OFFSET_V                                           31:0

#define NV097_SET_COMBINER_ALPHA_ICW(i)                             (0x00000260+(i)*4)
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP                                       31:29
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA                                     28:28
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE                                    27:24
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP                                       23:21
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA                                     20:20
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE                                    19:16
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP                                       15:13
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA                                     12:12
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE                                     11:8
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP                                         7:5
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA                                       4:4
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE                                      3:0
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D                         0x0000000D

#define NV097_SET_COMBINER_COLOR_ICW(i)                             (0x00000ac0+(i)*4)
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP                                       31:29
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA                                     28:28
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE                                    27:24
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP                                       23:21
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA                                     20:20
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE                                    19:16
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP                                       15:13
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA                                     12:12
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE                                     11:8
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D                         0x0000000D
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP                                         7:5
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY                0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT                  0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL                    0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE                    0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL                  0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE                  0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY                  0x00000006
#define NV097_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE                    0x00000007
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA                                       4:4
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE                          0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE                           0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE                                      3:0
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0                         0x00000000
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1                         0x00000001
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2                         0x00000002
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3                         0x00000003
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4                         0x00000004
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5                         0x00000005
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8                         0x00000008
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9                         0x00000009
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_A                         0x0000000A
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_B                         0x0000000B
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C                         0x0000000C
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D                         0x0000000D

#define NV097_SET_COMBINER_FACTOR0(i)                               (0x00000a60+(i)*4)
#define NV097_SET_COMBINER_FACTOR0_BLUE                                            7:0
#define NV097_SET_COMBINER_FACTOR0_GREEN                                          15:8
#define NV097_SET_COMBINER_FACTOR0_RED                                           23:16
#define NV097_SET_COMBINER_FACTOR0_ALPHA                                         31:24

#define NV097_SET_COMBINER_FACTOR1(i)                               (0x00000a80+(i)*4)
#define NV097_SET_COMBINER_FACTOR1_BLUE                                            7:0
#define NV097_SET_COMBINER_FACTOR1_GREEN                                          15:8
#define NV097_SET_COMBINER_FACTOR1_RED                                           23:16
#define NV097_SET_COMBINER_FACTOR1_ALPHA                                         31:24

#define NV097_SET_COMBINER_ALPHA_OCW(i)                             (0x00000aa0+(i)*4)
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION                                   31:15
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT                      0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS                 0x00000001
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1                 0x00000002
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS            0x00000003
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2                 0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1                0x00000006
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE                                  14:14
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE                       0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE                        0x00000001
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST                                      11:8
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0                          0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4                          0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5                          0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8                          0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9                          0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_A                          0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_B                          0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C                          0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D                          0x0000000D
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST                                        7:4
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D                           0x0000000D
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST                                        3:0
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D                           0x0000000D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0                                 0x00000288
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE                            31:29
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA                              28:28
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE                             27:24
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE                            23:21
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA                              20:20
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE                             19:16
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE                            15:13
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA                              12:12
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE                              11:8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD            0x0000000F
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE                              7:5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA                                4:4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE                               3:0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT            0x0000000E
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD            0x0000000F

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1                                 0x0000028c
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE                            31:29
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA                              28:28
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE                             27:24
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE                            23:21
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA                              20:20
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE                             19:16
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE                            15:13
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE                 0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA                              12:12
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE                   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE                    0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE                              11:8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0                  0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1                  0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2                  0x00000002
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3                  0x00000003
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4                  0x00000004
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5                  0x00000005
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8                  0x00000008
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9                  0x00000009
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_A                  0x0000000A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_B                  0x0000000B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C                  0x0000000C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D                  0x0000000D
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP                         7:7
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE            0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE             0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5                 6:6
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE    0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE     0x00000001
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12                5:0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE   0x00000000
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE    0x00000020

#define NV097_SET_CONTROL0                                                  0x00000290
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT                                   31:28
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS                         0x00000000
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_CRYCB_TO_RGB                 0x00000001
#define NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_SCRYSCB_TO_RGB               0x00000002
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA                                    27:24
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE                         0x00000000
#define NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE                          0x00000001
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE                                    23:20
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE                         0x00000000
#define NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE                          0x00000001
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE                                  19:16
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                       0x00000000
#define NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                        0x00000001
#define NV097_SET_CONTROL0_Z_FORMAT                                              15:12
#define NV097_SET_CONTROL0_Z_FORMAT_FIXED                                   0x00000000
#define NV097_SET_CONTROL0_Z_FORMAT_FLOAT                                   0x00000001
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE                                    7:0
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                        0x00000001

#define NV097_SET_LIGHT_CONTROL                                             0x00000294
#define NV097_SET_LIGHT_CONTROL_LOCALEYE                                         16:16
#define NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE                              0x00000000
#define NV097_SET_LIGHT_CONTROL_LOCALEYE_TRUE                               0x00000001
#define NV097_SET_LIGHT_CONTROL_SOUT                                             31:17
#define NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT                               0x00000000
#define NV097_SET_LIGHT_CONTROL_SOUT_PASSTHROUGH                            0x00000001
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN                               1:0
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE                  0x00000000
#define NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE                   0x00000001

#define NV097_SET_COLOR_MATERIAL                                            0x00000298
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL                                 1:0
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE                  0x00000000
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DIFFUSE_VTX_COLOR        0x00000001
#define NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_SPECULAR_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL                                  3:2
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE                   0x00000000
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DIFFUSE_VTX_COLOR         0x00000001
#define NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_SPECULAR_VTX_COLOR        0x00000002
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL                                     5:4
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE                      0x00000000
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DIFFUSE_VTX_COLOR            0x00000001
#define NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_SPECULAR_VTX_COLOR           0x00000002
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL                                 7:6
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE                  0x00000000
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DIFFUSE_VTX_COLOR        0x00000001
#define NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_SPECULAR_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL                            9:8
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE             0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DIFF_VTX_COLOR      0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_SPEC_VTX_COLOR      0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL                           11:10
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE              0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DIFF_VTX_COLOR       0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_SPEC_VTX_COLOR       0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL                              13:12
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE                 0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DIFF_VTX_COLOR          0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_SPEC_VTX_COLOR          0x00000002
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL                          15:14
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE             0x00000000
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DIFF_VTX_COLOR      0x00000001
#define NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_SPEC_VTX_COLOR      0x00000002

#define NV097_SET_FOG_MODE                                                  0x0000029c
#define NV097_SET_FOG_MODE_V                                                      31:0
#define NV097_SET_FOG_MODE_V_LINEAR                                         0x00002601
#define NV097_SET_FOG_MODE_V_EXP                                            0x00000800
#define NV097_SET_FOG_MODE_V_EXP2                                           0x00000801
#define NV097_SET_FOG_MODE_V_EXP_ABS                                        0x00000802
#define NV097_SET_FOG_MODE_V_EXP2_ABS                                       0x00000803
#define NV097_SET_FOG_MODE_V_LINEAR_ABS                                     0x00000804

#define NV097_SET_FOG_GEN_MODE                                              0x000002a0
#define NV097_SET_FOG_GEN_MODE_V                                                  31:0
#define NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA                                 0x00000000
#define NV097_SET_FOG_GEN_MODE_V_RADIAL                                     0x00000001
#define NV097_SET_FOG_GEN_MODE_V_PLANAR                                     0x00000002
#define NV097_SET_FOG_GEN_MODE_V_ABS_PLANAR                                 0x00000003
#define NV097_SET_FOG_GEN_MODE_V_FOG_X                                      0x00000006

#define NV097_SET_FOG_ENABLE                                                0x000002a4
#define NV097_SET_FOG_ENABLE_V                                                    31:0
#define NV097_SET_FOG_ENABLE_V_FALSE                                        0x00000000
#define NV097_SET_FOG_ENABLE_V_TRUE                                         0x00000001

#define NV097_SET_FOG_COLOR                                                 0x000002a8
#define NV097_SET_FOG_COLOR_RED                                                    7:0
#define NV097_SET_FOG_COLOR_GREEN                                                 15:8
#define NV097_SET_FOG_COLOR_BLUE                                                 23:16
#define NV097_SET_FOG_COLOR_ALPHA                                                31:24

#define NV097_SET_COLOR_KEY_COLOR(i)                                (0x00000ae0+(i)*4)
#define NV097_SET_COLOR_KEY_COLOR_V                                               31:0

#define NV097_SET_WINDOW_CLIP_TYPE                                          0x000002b4
#define NV097_SET_WINDOW_CLIP_TYPE_V                                              31:0
#define NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE                              0x00000000
#define NV097_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE                              0x00000001

#define NV097_SET_WINDOW_CLIP_HORIZONTAL(i)                         (0x000002c0+(i)*4)
#define NV097_SET_WINDOW_CLIP_HORIZONTAL_XMIN                                     11:0
#define NV097_SET_WINDOW_CLIP_HORIZONTAL_XMAX                                    27:16

#define NV097_SET_WINDOW_CLIP_VERTICAL(i)                           (0x000002e0+(i)*4)
#define NV097_SET_WINDOW_CLIP_VERTICAL_YMIN                                       11:0
#define NV097_SET_WINDOW_CLIP_VERTICAL_YMAX                                      27:16

#define NV097_SET_ALPHA_TEST_ENABLE                                         0x00000300
#define NV097_SET_ALPHA_TEST_ENABLE_V                                             31:0
#define NV097_SET_ALPHA_TEST_ENABLE_V_FALSE                                 0x00000000
#define NV097_SET_ALPHA_TEST_ENABLE_V_TRUE                                  0x00000001

#define NV097_SET_BLEND_ENABLE                                              0x00000304
#define NV097_SET_BLEND_ENABLE_V                                                  31:0
#define NV097_SET_BLEND_ENABLE_V_FALSE                                      0x00000000
#define NV097_SET_BLEND_ENABLE_V_TRUE                                       0x00000001

#define NV097_SET_CULL_FACE_ENABLE                                          0x00000308
#define NV097_SET_CULL_FACE_ENABLE_V                                              31:0
#define NV097_SET_CULL_FACE_ENABLE_V_FALSE                                  0x00000000
#define NV097_SET_CULL_FACE_ENABLE_V_TRUE                                   0x00000001

#define NV097_SET_DEPTH_TEST_ENABLE                                         0x0000030c
#define NV097_SET_DEPTH_TEST_ENABLE_V                                             31:0
#define NV097_SET_DEPTH_TEST_ENABLE_V_FALSE                                 0x00000000
#define NV097_SET_DEPTH_TEST_ENABLE_V_TRUE                                  0x00000001

#define NV097_SET_DITHER_ENABLE                                             0x00000310
#define NV097_SET_DITHER_ENABLE_V                                                 31:0
#define NV097_SET_DITHER_ENABLE_V_FALSE                                     0x00000000
#define NV097_SET_DITHER_ENABLE_V_TRUE                                      0x00000001

#define NV097_SET_LIGHTING_ENABLE                                           0x00000314
#define NV097_SET_LIGHTING_ENABLE_V                                               31:0
#define NV097_SET_LIGHTING_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_LIGHTING_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_POINT_PARAMS_ENABLE                                       0x00000318
#define NV097_SET_POINT_PARAMS_ENABLE_V                                           31:0
#define NV097_SET_POINT_PARAMS_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_POINT_PARAMS_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_POINT_SMOOTH_ENABLE                                       0x0000031c
#define NV097_SET_POINT_SMOOTH_ENABLE_V                                           31:0
#define NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_POINT_SMOOTH_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_LINE_SMOOTH_ENABLE                                        0x00000320
#define NV097_SET_LINE_SMOOTH_ENABLE_V                                            31:0
#define NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE                                0x00000000
#define NV097_SET_LINE_SMOOTH_ENABLE_V_TRUE                                 0x00000001

#define NV097_SET_POLY_SMOOTH_ENABLE                                        0x00000324
#define NV097_SET_POLY_SMOOTH_ENABLE_V                                            31:0
#define NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE                                0x00000000
#define NV097_SET_POLY_SMOOTH_ENABLE_V_TRUE                                 0x00000001

#define NV097_SET_STIPPLE_CONTROL                                           0x0000147c
#define NV097_SET_STIPPLE_CONTROL_V                                               31:0
#define NV097_SET_STIPPLE_CONTROL_V_OFF                                     0x00000000
#define NV097_SET_STIPPLE_CONTROL_V_POLYGON                                 0x00000001

#define NV097_SET_STIPPLE_PATTERN(i)                                (0x00001480+(i)*4)
#define NV097_SET_STIPPLE_PATTERN_V                                               31:0

#define NV097_SET_SKIN_MODE                                                 0x00000328
#define NV097_SET_SKIN_MODE_V                                                     31:0
#define NV097_SET_SKIN_MODE_V_OFF                                           0x00000000
#define NV097_SET_SKIN_MODE_V_2G                                            0x00000001
#define NV097_SET_SKIN_MODE_V_2                                             0x00000002
#define NV097_SET_SKIN_MODE_V_3G                                            0x00000003
#define NV097_SET_SKIN_MODE_V_3                                             0x00000004
#define NV097_SET_SKIN_MODE_V_4G                                            0x00000005
#define NV097_SET_SKIN_MODE_V_4                                             0x00000006

#define NV097_SET_STENCIL_TEST_ENABLE                                       0x0000032c
#define NV097_SET_STENCIL_TEST_ENABLE_V                                           31:0
#define NV097_SET_STENCIL_TEST_ENABLE_V_FALSE                               0x00000000
#define NV097_SET_STENCIL_TEST_ENABLE_V_TRUE                                0x00000001

#define NV097_SET_POLY_OFFSET_POINT_ENABLE                                  0x00000330
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V                                      31:0
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE                          0x00000000
#define NV097_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE                           0x00000001

#define NV097_SET_POLY_OFFSET_LINE_ENABLE                                   0x00000334
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V                                       31:0
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE                           0x00000000
#define NV097_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE                            0x00000001

#define NV097_SET_POLY_OFFSET_FILL_ENABLE                                   0x00000338
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V                                       31:0
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE                           0x00000000
#define NV097_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE                            0x00000001

#define NV097_SET_ALPHA_FUNC                                                0x0000033c
#define NV097_SET_ALPHA_FUNC_V                                                    31:0
#define NV097_SET_ALPHA_FUNC_V_NEVER                                        0x00000200
#define NV097_SET_ALPHA_FUNC_V_LESS                                         0x00000201
#define NV097_SET_ALPHA_FUNC_V_EQUAL                                        0x00000202
#define NV097_SET_ALPHA_FUNC_V_LEQUAL                                       0x00000203
#define NV097_SET_ALPHA_FUNC_V_GREATER                                      0x00000204
#define NV097_SET_ALPHA_FUNC_V_NOTEQUAL                                     0x00000205
#define NV097_SET_ALPHA_FUNC_V_GEQUAL                                       0x00000206
#define NV097_SET_ALPHA_FUNC_V_ALWAYS                                       0x00000207

#define NV097_SET_ALPHA_REF                                                 0x00000340
#define NV097_SET_ALPHA_REF_V                                                     31:0

#define NV097_SET_BLEND_FUNC_SFACTOR                                        0x00000344
#define NV097_SET_BLEND_FUNC_SFACTOR_V                                            31:0
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ZERO                                 0x00000000
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE                                  0x00000001
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR                            0x00000300
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR                  0x00000301
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA                            0x00000302
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA                  0x00000303
#define NV097_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA                            0x00000304
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA                  0x00000305
#define NV097_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR                            0x00000306
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR                  0x00000307
#define NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE                   0x00000308
#define NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR                       0x00008001
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR             0x00008002
#define NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA                       0x00008003
#define NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA             0x00008004

#define NV097_SET_BLEND_FUNC_DFACTOR                                        0x00000348
#define NV097_SET_BLEND_FUNC_DFACTOR_V                                            31:0
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ZERO                                 0x00000000
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE                                  0x00000001
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR                            0x00000300
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR                  0x00000301
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA                            0x00000302
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA                  0x00000303
#define NV097_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA                            0x00000304
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA                  0x00000305
#define NV097_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR                            0x00000306
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR                  0x00000307
#define NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE                   0x00000308
#define NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR                       0x00008001
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR             0x00008002
#define NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA                       0x00008003
#define NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA             0x00008004

#define NV097_SET_BLEND_COLOR                                               0x0000034c
#define NV097_SET_BLEND_COLOR_V                                                   31:0

#define NV097_SET_BLEND_EQUATION                                            0x00000350
#define NV097_SET_BLEND_EQUATION_V                                                31:0
#define NV097_SET_BLEND_EQUATION_V_FUNC_SUBTRACT                            0x0000800A
#define NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT                    0x0000800B
#define NV097_SET_BLEND_EQUATION_V_FUNC_ADD                                 0x00008006
#define NV097_SET_BLEND_EQUATION_V_MIN                                      0x00008007
#define NV097_SET_BLEND_EQUATION_V_MAX                                      0x00008008
#define NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_SIGNED             0x0000F005
#define NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED                          0x0000F006

#define NV097_SET_DEPTH_FUNC                                                0x00000354
#define NV097_SET_DEPTH_FUNC_V                                                    31:0
#define NV097_SET_DEPTH_FUNC_V_NEVER                                        0x00000200
#define NV097_SET_DEPTH_FUNC_V_LESS                                         0x00000201
#define NV097_SET_DEPTH_FUNC_V_EQUAL                                        0x00000202
#define NV097_SET_DEPTH_FUNC_V_LEQUAL                                       0x00000203
#define NV097_SET_DEPTH_FUNC_V_GREATER                                      0x00000204
#define NV097_SET_DEPTH_FUNC_V_NOTEQUAL                                     0x00000205
#define NV097_SET_DEPTH_FUNC_V_GEQUAL                                       0x00000206
#define NV097_SET_DEPTH_FUNC_V_ALWAYS                                       0x00000207

#define NV097_SET_COLOR_MASK                                                0x00000358
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE                                  31:24
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE                        0x00000001
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE                                    23:16
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE                         0x00000000
#define NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE                          0x00000001
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE                                   15:8
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE                       0x00000000
#define NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE                        0x00000001
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE                                     7:0
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE                        0x00000000
#define NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE                         0x00000001

#define NV097_SET_DEPTH_MASK                                                0x0000035c
#define NV097_SET_DEPTH_MASK_V                                                    31:0
#define NV097_SET_DEPTH_MASK_V_FALSE                                        0x00000000
#define NV097_SET_DEPTH_MASK_V_TRUE                                         0x00000001

#define NV097_SET_STENCIL_MASK                                              0x00000360
#define NV097_SET_STENCIL_MASK_V                                                  31:0

#define NV097_SET_STENCIL_FUNC                                              0x00000364
#define NV097_SET_STENCIL_FUNC_V                                                  31:0
#define NV097_SET_STENCIL_FUNC_V_NEVER                                      0x00000200
#define NV097_SET_STENCIL_FUNC_V_LESS                                       0x00000201
#define NV097_SET_STENCIL_FUNC_V_EQUAL                                      0x00000202
#define NV097_SET_STENCIL_FUNC_V_LEQUAL                                     0x00000203
#define NV097_SET_STENCIL_FUNC_V_GREATER                                    0x00000204
#define NV097_SET_STENCIL_FUNC_V_NOTEQUAL                                   0x00000205
#define NV097_SET_STENCIL_FUNC_V_GEQUAL                                     0x00000206
#define NV097_SET_STENCIL_FUNC_V_ALWAYS                                     0x00000207

#define NV097_SET_STENCIL_FUNC_REF                                          0x00000368
#define NV097_SET_STENCIL_FUNC_REF_V                                              31:0

#define NV097_SET_STENCIL_FUNC_MASK                                         0x0000036c
#define NV097_SET_STENCIL_FUNC_MASK_V                                             31:0

#define NV097_SET_STENCIL_OP_FAIL                                           0x00000370
#define NV097_SET_STENCIL_OP_FAIL_V                                               31:0
#define NV097_SET_STENCIL_OP_FAIL_V_KEEP                                    0x00001E00
#define NV097_SET_STENCIL_OP_FAIL_V_ZERO                                    0x00000000
#define NV097_SET_STENCIL_OP_FAIL_V_REPLACE                                 0x00001E01
#define NV097_SET_STENCIL_OP_FAIL_V_INCRSAT                                 0x00001E02
#define NV097_SET_STENCIL_OP_FAIL_V_DECRSAT                                 0x00001E03
#define NV097_SET_STENCIL_OP_FAIL_V_INVERT                                  0x0000150A
#define NV097_SET_STENCIL_OP_FAIL_V_INCR                                    0x00008507
#define NV097_SET_STENCIL_OP_FAIL_V_DECR                                    0x00008508

#define NV097_SET_STENCIL_OP_ZFAIL                                          0x00000374
#define NV097_SET_STENCIL_OP_ZFAIL_V                                              31:0
#define NV097_SET_STENCIL_OP_ZFAIL_V_KEEP                                   0x00001E00
#define NV097_SET_STENCIL_OP_ZFAIL_V_ZERO                                   0x00000000
#define NV097_SET_STENCIL_OP_ZFAIL_V_REPLACE                                0x00001E01
#define NV097_SET_STENCIL_OP_ZFAIL_V_INCRSAT                                0x00001E02
#define NV097_SET_STENCIL_OP_ZFAIL_V_DECRSAT                                0x00001E03
#define NV097_SET_STENCIL_OP_ZFAIL_V_INVERT                                 0x0000150A
#define NV097_SET_STENCIL_OP_ZFAIL_V_INCR                                   0x00008507
#define NV097_SET_STENCIL_OP_ZFAIL_V_DECR                                   0x00008508

#define NV097_SET_STENCIL_OP_ZPASS                                          0x00000378
#define NV097_SET_STENCIL_OP_ZPASS_V                                              31:0
#define NV097_SET_STENCIL_OP_ZPASS_V_KEEP                                   0x00001E00
#define NV097_SET_STENCIL_OP_ZPASS_V_ZERO                                   0x00000000
#define NV097_SET_STENCIL_OP_ZPASS_V_REPLACE                                0x00001E01
#define NV097_SET_STENCIL_OP_ZPASS_V_INCRSAT                                0x00001E02
#define NV097_SET_STENCIL_OP_ZPASS_V_DECRSAT                                0x00001E03
#define NV097_SET_STENCIL_OP_ZPASS_V_INVERT                                 0x0000150A
#define NV097_SET_STENCIL_OP_ZPASS_V_INCR                                   0x00008507
#define NV097_SET_STENCIL_OP_ZPASS_V_DECR                                   0x00008508

#define NV097_SET_SHADE_MODE                                                0x0000037c
#define NV097_SET_SHADE_MODE_V                                                    31:0
#define NV097_SET_SHADE_MODE_V_FLAT                                         0x00001D00
#define NV097_SET_SHADE_MODE_V_SMOOTH                                       0x00001D01

#define NV097_SET_LINE_WIDTH                                                0x00000380
#define NV097_SET_LINE_WIDTH_V                                                    31:0

#define NV097_SET_POLYGON_OFFSET_SCALE_FACTOR                               0x00000384
#define NV097_SET_POLYGON_OFFSET_SCALE_FACTOR_V                                   31:0

#define NV097_SET_POLYGON_OFFSET_BIAS                                       0x00000388
#define NV097_SET_POLYGON_OFFSET_BIAS_V                                           31:0

#define NV097_SET_FRONT_POLYGON_MODE                                        0x0000038c
#define NV097_SET_FRONT_POLYGON_MODE_V                                            31:0
#define NV097_SET_FRONT_POLYGON_MODE_V_POINT                                0x00001B00
#define NV097_SET_FRONT_POLYGON_MODE_V_LINE                                 0x00001B01
#define NV097_SET_FRONT_POLYGON_MODE_V_FILL                                 0x00001B02

#define NV097_SET_BACK_POLYGON_MODE                                         0x00000390
#define NV097_SET_BACK_POLYGON_MODE_V                                             31:0
#define NV097_SET_BACK_POLYGON_MODE_V_POINT                                 0x00001B00
#define NV097_SET_BACK_POLYGON_MODE_V_LINE                                  0x00001B01
#define NV097_SET_BACK_POLYGON_MODE_V_FILL                                  0x00001B02

#define NV097_SET_CLIP_MIN                                                  0x00000394
#define NV097_SET_CLIP_MIN_V                                                      31:0

#define NV097_SET_CLIP_MAX                                                  0x00000398
#define NV097_SET_CLIP_MAX_V                                                      31:0

#define NV097_SET_CULL_FACE                                                 0x0000039c
#define NV097_SET_CULL_FACE_V                                                     31:0
#define NV097_SET_CULL_FACE_V_FRONT                                         0x00000404
#define NV097_SET_CULL_FACE_V_BACK                                          0x00000405
#define NV097_SET_CULL_FACE_V_FRONT_AND_BACK                                0x00000408

#define NV097_SET_FRONT_FACE                                                0x000003a0
#define NV097_SET_FRONT_FACE_V                                                    31:0
#define NV097_SET_FRONT_FACE_V_CW                                           0x00000900
#define NV097_SET_FRONT_FACE_V_CCW                                          0x00000901

#define NV097_SET_NORMALIZATION_ENABLE                                      0x000003a4
#define NV097_SET_NORMALIZATION_ENABLE_V                                          31:0
#define NV097_SET_NORMALIZATION_ENABLE_V_FALSE                              0x00000000
#define NV097_SET_NORMALIZATION_ENABLE_V_TRUE                               0x00000001

#define NV097_SET_MATERIAL_EMISSION(i)                              (0x000003a8+(i)*4)
#define NV097_SET_MATERIAL_EMISSION_V                                             31:0

#define NV097_SET_MATERIAL_ALPHA                                            0x000003b4
#define NV097_SET_MATERIAL_ALPHA_V                                                31:0

#define NV097_SET_BACK_MATERIAL_ALPHA                                       0x000017ac
#define NV097_SET_BACK_MATERIAL_ALPHA_V                                           31:0

#define NV097_SET_SPECULAR_ENABLE                                           0x000003b8
#define NV097_SET_SPECULAR_ENABLE_V                                               31:0
#define NV097_SET_SPECULAR_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_SPECULAR_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_LIGHT_ENABLE_MASK                                         0x000003bc
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0                                         1:0
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1                                         3:2
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2                                         5:4
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3                                         7:6
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4                                         9:8
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5                                       11:10
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6                                       13:12
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT                             0x00000003
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7                                       15:14
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF                              0x00000000
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE                         0x00000001
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL                            0x00000002
#define NV097_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT                             0x00000003

#define NV097_SET_VERTEX_DATA2F_M(i,j)                        (0x00001880+(i)*8+(j)*4)
#define NV097_SET_VERTEX_DATA2F_M_V                                               31:0

#define NV097_SET_VERTEX_DATA4F_M(i,j)                       (0x00001a00+(i)*16+(j)*4)
#define NV097_SET_VERTEX_DATA4F_M_V                                               31:0

#define NV097_SET_VERTEX_DATA2S(i)                                  (0x00001900+(i)*4)
#define NV097_SET_VERTEX_DATA2S_V                                                 31:0

#define NV097_SET_VERTEX_DATA4UB(i)                                 (0x00001940+(i)*4)
#define NV097_SET_VERTEX_DATA4UB_V                                                31:0

#define NV097_SET_VERTEX_DATA4S_M(i,j)                        (0x00001980+(i)*8+(j)*4)
#define NV097_SET_VERTEX_DATA4S_M_V                                               31:0

#define NV097_SET_TEXGEN_S(i)                                      (0x000003c0+(i)*16)
#define NV097_SET_TEXGEN_S_V                                                      31:0
#define NV097_SET_TEXGEN_S_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_S_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_S_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_S_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_S_V_OBJECT_LINEAR                                  0x00002401
#define NV097_SET_TEXGEN_S_V_SPHERE_MAP                                     0x00002402

#define NV097_SET_TEXGEN_T(i)                                      (0x000003c4+(i)*16)
#define NV097_SET_TEXGEN_T_V                                                      31:0
#define NV097_SET_TEXGEN_T_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_T_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_T_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_T_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_T_V_OBJECT_LINEAR                                  0x00002401
#define NV097_SET_TEXGEN_T_V_SPHERE_MAP                                     0x00002402

#define NV097_SET_TEXGEN_R(i)                                      (0x000003c8+(i)*16)
#define NV097_SET_TEXGEN_R_V                                                      31:0
#define NV097_SET_TEXGEN_R_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_R_V_NORMAL_MAP                                     0x00008511
#define NV097_SET_TEXGEN_R_V_REFLECTION_MAP                                 0x00008512
#define NV097_SET_TEXGEN_R_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_R_V_OBJECT_LINEAR                                  0x00002401

#define NV097_SET_TEXGEN_Q(i)                                      (0x000003cc+(i)*16)
#define NV097_SET_TEXGEN_Q_V                                                      31:0
#define NV097_SET_TEXGEN_Q_V_DISABLE                                        0x00000000
#define NV097_SET_TEXGEN_Q_V_EYE_LINEAR                                     0x00002400
#define NV097_SET_TEXGEN_Q_V_OBJECT_LINEAR                                  0x00002401

#define NV097_SET_TEXGEN_VIEW_MODEL                                         0x000009cc
#define NV097_SET_TEXGEN_VIEW_MODEL_V                                             31:0
#define NV097_SET_TEXGEN_VIEW_MODEL_V_LOCAL_VIEWER                          0x00000000
#define NV097_SET_TEXGEN_VIEW_MODEL_V_INFINITE_VIEWER                       0x00000001

#define NV097_SET_TEXTURE_MATRIX_ENABLE(i)                          (0x00000420+(i)*4)
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V                                         31:0
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE                             0x00000000
#define NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE                              0x00000001

#define NV097_SET_POINT_SIZE                                                0x0000043c
#define NV097_SET_POINT_SIZE_V                                                    31:0

#define NV097_SET_SWATH_WIDTH                                               0x000009f8
#define NV097_SET_SWATH_WIDTH_V                                                   31:0
#define NV097_SET_SWATH_WIDTH_V_8                                           0x00000000
#define NV097_SET_SWATH_WIDTH_V_16                                          0x00000001
#define NV097_SET_SWATH_WIDTH_V_32                                          0x00000002
#define NV097_SET_SWATH_WIDTH_V_64                                          0x00000003
#define NV097_SET_SWATH_WIDTH_V_128                                         0x00000004
#define NV097_SET_SWATH_WIDTH_V_OFF                                         0x0000000F

#define NV097_SET_FLAT_SHADE_OP                                             0x000009fc
#define NV097_SET_FLAT_SHADE_OP_V                                                 31:0
#define NV097_SET_FLAT_SHADE_OP_V_LAST_VTX                                  0x00000000
#define NV097_SET_FLAT_SHADE_OP_V_FIRST_VTX                                 0x00000001

#define NV097_SET_PROJECTION_MATRIX(i)                              (0x00000440+(i)*4)
#define NV097_SET_PROJECTION_MATRIX_V                                             31:0

#define NV097_SET_MODEL_VIEW_MATRIX0(i)                             (0x00000480+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX0_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX1(i)                             (0x000004c0+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX1_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX2(i)                             (0x00000500+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX2_V                                            31:0

#define NV097_SET_MODEL_VIEW_MATRIX3(i)                             (0x00000540+(i)*4)
#define NV097_SET_MODEL_VIEW_MATRIX3_V                                            31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(i)                     (0x00000580+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX0_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX1(i)                     (0x000005c0+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX1_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX2(i)                     (0x00000600+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX2_V                                    31:0

#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX3(i)                     (0x00000640+(i)*4)
#define NV097_SET_INVERSE_MODEL_VIEW_MATRIX3_V                                    31:0

#define NV097_SET_COMPOSITE_MATRIX(i)                               (0x00000680+(i)*4)
#define NV097_SET_COMPOSITE_MATRIX_V                                              31:0

#define NV097_SET_TEXTURE_MATRIX0(i)                                (0x000006c0+(i)*4)
#define NV097_SET_TEXTURE_MATRIX0_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX1(i)                                (0x00000700+(i)*4)
#define NV097_SET_TEXTURE_MATRIX1_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX2(i)                                (0x00000740+(i)*4)
#define NV097_SET_TEXTURE_MATRIX2_V                                               31:0

#define NV097_SET_TEXTURE_MATRIX3(i)                                (0x00000780+(i)*4)
#define NV097_SET_TEXTURE_MATRIX3_V                                               31:0

#define NV097_SET_TEXGEN_PLANE_S(i,j)                        (0x00000840+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_S_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_T(i,j)                        (0x00000850+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_T_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_R(i,j)                        (0x00000860+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_R_V                                                31:0

#define NV097_SET_TEXGEN_PLANE_Q(i,j)                        (0x00000870+(i)*64+(j)*4)
#define NV097_SET_TEXGEN_PLANE_Q_V                                                31:0

#define NV097_SET_FOG_PARAMS(i)                                     (0x000009c0+(i)*4)
#define NV097_SET_FOG_PARAMS_V                                                    31:0

#define NV097_SET_FOG_PLANE(i)                                      (0x000009d0+(i)*4)
#define NV097_SET_FOG_PLANE_V                                                     31:0

#define NV097_SET_SPECULAR_PARAMS(i)                                (0x000009e0+(i)*4)
#define NV097_SET_SPECULAR_PARAMS_V                                               31:0

#define NV097_SET_BACK_SPECULAR_PARAMS(i)                           (0x00001e28+(i)*4)
#define NV097_SET_BACK_SPECULAR_PARAMS_V                                          31:0

#define NV097_SET_SCENE_AMBIENT_COLOR(i)                            (0x00000a10+(i)*4)
#define NV097_SET_SCENE_AMBIENT_COLOR_V                                           31:0

#define NV097_SET_VIEWPORT_SCALE(i)                                 (0x00000af0+(i)*4)
#define NV097_SET_VIEWPORT_SCALE_V                                                31:0

#define NV097_SET_VIEWPORT_OFFSET(i)                                (0x00000a20+(i)*4)
#define NV097_SET_VIEWPORT_OFFSET_V                                               31:0

#define NV097_SET_POINT_PARAMS(i)                                   (0x00000a30+(i)*4)
#define NV097_SET_POINT_PARAMS_V                                                  31:0

#define NV097_SET_EYE_POSITION(i)                                   (0x00000a50+(i)*4)
#define NV097_SET_EYE_POSITION_V                                                  31:0

#define NV097_SET_BACK_LIGHT_AMBIENT_COLOR(i,j)              (0x00000c00+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_AMBIENT_COLOR_V                                      31:0

#define NV097_SET_BACK_LIGHT_DIFFUSE_COLOR(i,j)              (0x00000c0c+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_DIFFUSE_COLOR_V                                      31:0

#define NV097_SET_BACK_LIGHT_SPECULAR_COLOR(i,j)             (0x00000c18+(i)*64+(j)*4)
#define NV097_SET_BACK_LIGHT_SPECULAR_COLOR_V                                     31:0

#define NV097_SET_LIGHT_AMBIENT_COLOR(i,j)                  (0x00001000+(i)*128+(j)*4)
#define NV097_SET_LIGHT_AMBIENT_COLOR_V                                           31:0

#define NV097_SET_LIGHT_DIFFUSE_COLOR(i,j)                  (0x0000100c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_DIFFUSE_COLOR_V                                           31:0

#define NV097_SET_LIGHT_SPECULAR_COLOR(i,j)                 (0x00001018+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPECULAR_COLOR_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_RANGE(i)                            (0x00001024+(i)*128)
#define NV097_SET_LIGHT_LOCAL_RANGE_V                                             31:0

#define NV097_SET_LIGHT_INFINITE_HALF_VECTOR(i,j)           (0x00001028+(i)*128+(j)*4)
#define NV097_SET_LIGHT_INFINITE_HALF_VECTOR_V                                    31:0

#define NV097_SET_LIGHT_INFINITE_DIRECTION(i,j)             (0x00001034+(i)*128+(j)*4)
#define NV097_SET_LIGHT_INFINITE_DIRECTION_V                                      31:0

#define NV097_SET_LIGHT_SPOT_FALLOFF(i,j)                   (0x00001040+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPOT_FALLOFF_V                                            31:0

#define NV097_SET_LIGHT_SPOT_DIRECTION(i,j)                 (0x0000104c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_SPOT_DIRECTION_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_POSITION(i,j)                 (0x0000105c+(i)*128+(j)*4)
#define NV097_SET_LIGHT_LOCAL_POSITION_V                                          31:0

#define NV097_SET_LIGHT_LOCAL_ATTENUATION(i,j)              (0x00001068+(i)*128+(j)*4)
#define NV097_SET_LIGHT_LOCAL_ATTENUATION_V                                       31:0

#define NV097_SET_VERTEX3F(i)                                       (0x00001500+(i)*4)
#define NV097_SET_VERTEX3F_V                                                      31:0

#define NV097_SET_VERTEX4F(i)                                       (0x00001518+(i)*4)
#define NV097_SET_VERTEX4F_V                                                      31:0

#define NV097_SET_VERTEX4S(i)                                       (0x00001528+(i)*4)
#define NV097_SET_VERTEX4S_V                                                      31:0

#define NV097_SET_NORMAL3F(i)                                       (0x00001530+(i)*4)
#define NV097_SET_NORMAL3F_V                                                      31:0

#define NV097_SET_NORMAL3S(i)                                       (0x00001540+(i)*4)
#define NV097_SET_NORMAL3S_V                                                      31:0

#define NV097_SET_DIFFUSE_COLOR4F(i)                                (0x00001550+(i)*4)
#define NV097_SET_DIFFUSE_COLOR4F_V                                               31:0

#define NV097_SET_DIFFUSE_COLOR3F(i)                                (0x00001560+(i)*4)
#define NV097_SET_DIFFUSE_COLOR3F_V                                               31:0

#define NV097_SET_DIFFUSE_COLOR4UB                                          0x0000156c
#define NV097_SET_DIFFUSE_COLOR4UB_V                                              31:0

#define NV097_SET_SPECULAR_COLOR4F(i)                               (0x00001570+(i)*4)
#define NV097_SET_SPECULAR_COLOR4F_V                                              31:0

#define NV097_SET_SPECULAR_COLOR3F(i)                               (0x00001580+(i)*4)
#define NV097_SET_SPECULAR_COLOR3F_V                                              31:0

#define NV097_SET_SPECULAR_COLOR4UB                                         0x0000158c
#define NV097_SET_SPECULAR_COLOR4UB_V                                             31:0

#define NV097_SET_TEXCOORD0_2F(i)                                   (0x00001590+(i)*4)
#define NV097_SET_TEXCOORD0_2F_V                                                  31:0

#define NV097_SET_TEXCOORD0_2S                                              0x00001598
#define NV097_SET_TEXCOORD0_2S_V                                                  31:0

#define NV097_SET_TEXCOORD0_4F(i)                                   (0x000015a0+(i)*4)
#define NV097_SET_TEXCOORD0_4F_V                                                  31:0

#define NV097_SET_TEXCOORD0_4S(i)                                   (0x000015b0+(i)*4)
#define NV097_SET_TEXCOORD0_4S_V                                                  31:0

#define NV097_SET_TEXCOORD1_2F(i)                                   (0x000015b8+(i)*4)
#define NV097_SET_TEXCOORD1_2F_V                                                  31:0

#define NV097_SET_TEXCOORD1_2S                                              0x000015c0
#define NV097_SET_TEXCOORD1_2S_V                                                  31:0

#define NV097_SET_TEXCOORD1_4F(i)                                   (0x000015c8+(i)*4)
#define NV097_SET_TEXCOORD1_4F_V                                                  31:0

#define NV097_SET_TEXCOORD1_4S(i)                                   (0x000015d8+(i)*4)
#define NV097_SET_TEXCOORD1_4S_V                                                  31:0

#define NV097_SET_TEXCOORD2_2F(i)                                   (0x000015e0+(i)*4)
#define NV097_SET_TEXCOORD2_2F_V                                                  31:0

#define NV097_SET_TEXCOORD2_2S                                              0x000015e8
#define NV097_SET_TEXCOORD2_2S_V                                                  31:0

#define NV097_SET_TEXCOORD2_4F(i)                                   (0x000015f0+(i)*4)
#define NV097_SET_TEXCOORD2_4F_V                                                  31:0

#define NV097_SET_TEXCOORD2_4S(i)                                   (0x00001600+(i)*4)
#define NV097_SET_TEXCOORD2_4S_V                                                  31:0

#define NV097_SET_TEXCOORD3_2F(i)                                   (0x00001608+(i)*4)
#define NV097_SET_TEXCOORD3_2F_V                                                  31:0

#define NV097_SET_TEXCOORD3_2S                                              0x00001610
#define NV097_SET_TEXCOORD3_2S_V                                                  31:0

#define NV097_SET_TEXCOORD3_4F(i)                                   (0x00001620+(i)*4)
#define NV097_SET_TEXCOORD3_4F_V                                                  31:0

#define NV097_SET_TEXCOORD3_4S(i)                                   (0x00001630+(i)*4)
#define NV097_SET_TEXCOORD3_4S_V                                                  31:0

#define NV097_SET_FOG1F                                                     0x00001698
#define NV097_SET_FOG1F_V                                                         31:0

#define NV097_SET_WEIGHT1F                                                  0x0000169c
#define NV097_SET_WEIGHT1F_V                                                      31:0

#define NV097_SET_WEIGHT2F(i)                                       (0x000016a0+(i)*4)
#define NV097_SET_WEIGHT2F_V                                                      31:0

#define NV097_SET_WEIGHT3F(i)                                       (0x000016b0+(i)*4)
#define NV097_SET_WEIGHT3F_V                                                      31:0

#define NV097_SET_WEIGHT4F(i)                                       (0x000016c0+(i)*4)
#define NV097_SET_WEIGHT4F_V                                                      31:0

#define NV097_SET_EDGE_FLAG                                                 0x000016bc
#define NV097_SET_EDGE_FLAG_V                                                     31:0
#define NV097_SET_EDGE_FLAG_V_FALSE                                         0x00000000
#define NV097_SET_EDGE_FLAG_V_TRUE                                          0x00000001

#define NV097_SET_TRANSFORM_FIXED_CONST0(i)                         (0x000016e0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST0_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST1(i)                         (0x000016f0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST1_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST2(i)                         (0x00001700+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST2_V                                        31:0

#define NV097_SET_TRANSFORM_FIXED_CONST3(i)                         (0x000016d0+(i)*4)
#define NV097_SET_TRANSFORM_FIXED_CONST3_V                                        31:0

#define NV097_SET_TLCONST_ZERO(i)                                   (0x000017d4+(i)*4)
#define NV097_SET_TLCONST_ZERO_V                                                  31:0

#define NV097_SET_EYE_DIRECTION(i)                                  (0x000017e0+(i)*4)
#define NV097_SET_EYE_DIRECTION_V                                                 31:0

#define NV097_SET_LINEAR_FOG_CONST(i)                               (0x000017ec+(i)*4)
#define NV097_SET_LINEAR_FOG_CONST_V                                              31:0

#define NV097_INVALIDATE_VERTEX_CACHE_FILE                                  0x00001710

#define NV097_INVALIDATE_VERTEX_FILE                                        0x00001714

#define NV097_TL_NOP                                                        0x00001718

#define NV097_TL_SYNC                                                       0x0000171c

#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET(i)                       (0x00001720+(i)*4)
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA                           31:31
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_A             0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_B             0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_OFFSET_OFFSET                                 30:0

#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT(i)                       (0x00001760+(i)*4)
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_STRIDE                                 31:8
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE                                    7:4
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED                    0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_1                           0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2                           0x00000002
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3                           0x00000003
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4                           0x00000004
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3W                          0x00000007
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE                                    3:0
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D                      0x00000000
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S1                          0x00000001
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F                           0x00000002
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_OGL                      0x00000004
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K                        0x00000005
#define NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_CMP                         0x00000006

#define NV097_SET_LOGIC_OP_ENABLE                                           0x000017bc
#define NV097_SET_LOGIC_OP_ENABLE_V                                               31:0
#define NV097_SET_LOGIC_OP_ENABLE_V_FALSE                                   0x00000000
#define NV097_SET_LOGIC_OP_ENABLE_V_TRUE                                    0x00000001

#define NV097_SET_LOGIC_OP                                                  0x000017c0
#define NV097_SET_LOGIC_OP_V                                                      31:0
#define NV097_SET_LOGIC_OP_V_CLEAR                                          0x00001500
#define NV097_SET_LOGIC_OP_V_AND                                            0x00001501
#define NV097_SET_LOGIC_OP_V_AND_REVERSE                                    0x00001502
#define NV097_SET_LOGIC_OP_V_COPY                                           0x00001503
#define NV097_SET_LOGIC_OP_V_AND_INVERTED                                   0x00001504
#define NV097_SET_LOGIC_OP_V_NOOP                                           0x00001505
#define NV097_SET_LOGIC_OP_V_XOR                                            0x00001506
#define NV097_SET_LOGIC_OP_V_OR                                             0x00001507
#define NV097_SET_LOGIC_OP_V_NOR                                            0x00001508
#define NV097_SET_LOGIC_OP_V_EQUIV                                          0x00001509
#define NV097_SET_LOGIC_OP_V_INVERT                                         0x0000150A
#define NV097_SET_LOGIC_OP_V_OR_REVERSE                                     0x0000150B
#define NV097_SET_LOGIC_OP_V_COPY_INVERTED                                  0x0000150C
#define NV097_SET_LOGIC_OP_V_OR_INVERTED                                    0x0000150D
#define NV097_SET_LOGIC_OP_V_NAND                                           0x0000150E
#define NV097_SET_LOGIC_OP_V_SET                                            0x0000150F

#define NV097_SET_BEGIN_END                                                 0x000017fc
#define NV097_SET_BEGIN_END_OP                                                    31:0
#define NV097_SET_BEGIN_END_OP_END                                          0x00000000
#define NV097_SET_BEGIN_END_OP_POINTS                                       0x00000001
#define NV097_SET_BEGIN_END_OP_LINES                                        0x00000002
#define NV097_SET_BEGIN_END_OP_LINE_LOOP                                    0x00000003
#define NV097_SET_BEGIN_END_OP_LINE_STRIP                                   0x00000004
#define NV097_SET_BEGIN_END_OP_TRIANGLES                                    0x00000005
#define NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP                               0x00000006
#define NV097_SET_BEGIN_END_OP_TRIANGLE_FAN                                 0x00000007
#define NV097_SET_BEGIN_END_OP_QUADS                                        0x00000008
#define NV097_SET_BEGIN_END_OP_QUAD_STRIP                                   0x00000009
#define NV097_SET_BEGIN_END_OP_POLYGON                                      0x0000000A

#define NV097_ARRAY_ELEMENT16                                               0x00001800
#define NV097_ARRAY_ELEMENT16_VERTEX0                                             15:0
#define NV097_ARRAY_ELEMENT16_VERTEX1                                            31:16

#define NV097_ARRAY_ELEMENT32                                               0x00001808
#define NV097_ARRAY_ELEMENT32_V                                                   31:0

#define NV097_DRAW_ARRAYS                                                   0x00001810
#define NV097_DRAW_ARRAYS_COUNT                                                  31:24
#define NV097_DRAW_ARRAYS_START_INDEX                                             23:0

#define NV097_INLINE_VERTEX_REUSE                                           0x00001828
#define NV097_INLINE_VERTEX_REUSE_V                                               31:0

#define NV097_INLINE_ARRAY                                                  0x00001818
#define NV097_INLINE_ARRAY_V                                                      31:0

#define NV097_SET_TEXTURE_OFFSET(i)                                (0x00001b00+(i)*64)
#define NV097_SET_TEXTURE_OFFSET_V                                                31:0

#define NV097_SET_TEXTURE_FORMAT(i)                                (0x00001b04+(i)*64)
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA                                       1:0
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE                                    2:2
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE                       0x00000000
#define NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE                        0x00000001
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE                                     3:3
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_TEXTURE                      0x00000000
#define NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR                        0x00000001
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY                                    7:4
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_ONE                         0x00000001
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO                         0x00000002
#define NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE                       0x00000003
#define NV097_SET_TEXTURE_FORMAT_COLOR                                            15:8
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8                                0x00000000
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8                               0x00000001
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5                          0x00000002
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5                          0x00000003
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4                          0x00000004
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5                            0x00000005
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8                          0x00000006
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8                          0x00000007
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8                       0x0000000B
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5                      0x0000000C
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8                     0x0000000E
#define NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8                     0x0000000F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5                    0x00000010
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5                      0x00000011
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8                    0x00000012
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8                          0x00000013
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8                         0x00000014
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9                       0x00000015
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8                        0x00000016
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8                        0x00000017
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8                      0x00000018
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8                                0x00000019
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8Y8                              0x0000001A
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8                         0x0000001B
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5                    0x0000001C
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4                    0x0000001D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8                    0x0000001E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8                          0x0000001F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8                        0x00000020
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8                0x00000024
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8                0x00000025
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8                  0x00000026
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5                            0x00000027
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8                              0x00000028
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8B8                              0x00000029
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FIXED                0x0000002A
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_X8_Y24_FLOAT                0x0000002B
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FIXED                   0x0000002C
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_DEPTH_Y16_FLOAT                   0x0000002D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED          0x0000002E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT          0x0000002F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED             0x00000030
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT             0x00000031
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y16                               0x00000032
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16                       0x00000033
#define NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6              0x00000034
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16                         0x00000035
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16                    0x00000036
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5                      0x00000037
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G5B5A1                          0x00000038
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R4G4B4A4                          0x00000039
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8                          0x0000003A
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_B8G8R8A8                          0x0000003B
#define NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8G8B8A8                          0x0000003C
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1                    0x0000003D
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4                    0x0000003E
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8                    0x0000003F
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8                    0x00000040
#define NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8                    0x00000041
#define NV097_SET_TEXTURE_FORMAT_MIPMAP_LEVELS                                   19:16
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U                                     23:20
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_512                            0x00000009
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024                           0x0000000A
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048                           0x0000000B
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U_4096                           0x0000000C
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V                                     27:24
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_512                            0x00000009
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024                           0x0000000A
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048                           0x0000000B
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V_4096                           0x0000000C
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P                                     31:28
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1                              0x00000000
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_2                              0x00000001
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_4                              0x00000002
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_8                              0x00000003
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_16                             0x00000004
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_32                             0x00000005
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_64                             0x00000006
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_128                            0x00000007
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_256                            0x00000008
#define NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_512                            0x00000009

#define NV097_SET_TEXTURE_ADDRESS(i)                               (0x00001b08+(i)*64)
#define NV097_SET_TEXTURE_ADDRESS_U                                                3:0
#define NV097_SET_TEXTURE_ADDRESS_U_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_U_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_U_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_U_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U                                        7:4
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_V                                               11:8
#define NV097_SET_TEXTURE_ADDRESS_V_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_V_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_V_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_V_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V                                      15:12
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_P                                              19:16
#define NV097_SET_TEXTURE_ADDRESS_P_WRAP                                    0x00000001
#define NV097_SET_TEXTURE_ADDRESS_P_MIRROR                                  0x00000002
#define NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE                           0x00000003
#define NV097_SET_TEXTURE_ADDRESS_P_BORDER                                  0x00000004
#define NV097_SET_TEXTURE_ADDRESS_P_CLAMP_OGL                               0x00000005
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P                                      23:20
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_TRUE                            0x00000001
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q                                      31:24
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE                           0x00000000
#define NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_TRUE                            0x00000001

#define NV097_SET_TEXTURE_CONTROL0(i)                              (0x00001b0c+(i)*64)
#define NV097_SET_TEXTURE_CONTROL0_ENABLE                                        31:30
#define NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE                             0x00000000
#define NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE                              0x00000001
#define NV097_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP                                 29:18
#define NV097_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP                                  17:6
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO                                   5:4
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0                          0x00000000
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1                          0x00000001
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_2                          0x00000002
#define NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_3                          0x00000003
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE                              3:3
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE                 0x00000000
#define NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE                  0x00000001
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE                               2:2
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE                  0x00000000
#define NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE                   0x00000001
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION                             1:0
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE                0x00000000
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA                0x00000001
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA                 0x00000002
#define NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL                 0x00000003

#define NV097_SET_TEXTURE_CONTROL1(i)                              (0x00001b10+(i)*64)
#define NV097_SET_TEXTURE_CONTROL1_IMAGE_PITCH                                   31:16

#define NV097_SET_TEXTURE_FILTER(i)                                (0x00001b14+(i)*64)
#define NV097_SET_TEXTURE_FILTER_MIPMAP_LOD_BIAS                                  12:0
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL                              15:13
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX                0x00000001
#define NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3              0x00000002
#define NV097_SET_TEXTURE_FILTER_MIN                                             23:16
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0                               0x00000001
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0                              0x00000002
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_NEARESTLOD                         0x00000003
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_NEARESTLOD                        0x00000004
#define NV097_SET_TEXTURE_FILTER_MIN_BOX_TENT_LOD                           0x00000005
#define NV097_SET_TEXTURE_FILTER_MIN_TENT_TENT_LOD                          0x00000006
#define NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0                    0x00000007
#define NV097_SET_TEXTURE_FILTER_MAG                                             27:24
#define NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0                               0x00000001
#define NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0                              0x00000002
#define NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0                    0x00000004
#define NV097_SET_TEXTURE_FILTER_ASIGNED                                         28:28
#define NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_RSIGNED                                         29:29
#define NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_GSIGNED                                         30:30
#define NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_ENABLED                        0x00000001
#define NV097_SET_TEXTURE_FILTER_BSIGNED                                         31:31
#define NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED                       0x00000000
#define NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_ENABLED                        0x00000001

#define NV097_SET_TEXTURE_IMAGE_RECT(i)                            (0x00001b1c+(i)*64)
#define NV097_SET_TEXTURE_IMAGE_RECT_WIDTH                                       31:16
#define NV097_SET_TEXTURE_IMAGE_RECT_HEIGHT                                       15:0

#define NV097_SET_TEXTURE_PALETTE(i)                               (0x00001b20+(i)*64)
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA                                      1:0
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_A                             0x00000000
#define NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_B                             0x00000001
#define NV097_SET_TEXTURE_PALETTE_LENGTH                                           5:2
#define NV097_SET_TEXTURE_PALETTE_LENGTH_256                                0x00000000
#define NV097_SET_TEXTURE_PALETTE_LENGTH_128                                0x00000001
#define NV097_SET_TEXTURE_PALETTE_LENGTH_64                                 0x00000002
#define NV097_SET_TEXTURE_PALETTE_LENGTH_32                                 0x00000003
#define NV097_SET_TEXTURE_PALETTE_OFFSET                                          31:6

#define NV097_SET_TEXTURE_BORDER_COLOR(i)                          (0x00001b24+(i)*64)
#define NV097_SET_TEXTURE_BORDER_COLOR_V                                          31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(i)                    (0x00001b28+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01(i)                    (0x00001b2c+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11(i)                    (0x00001b30+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10(i)                    (0x00001b34+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE(i)                    (0x00001b38+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE_V                                    31:0

#define NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET(i)                   (0x00001b3c+(i)*64)
#define NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET_V                                   31:0

#define NV097_PARK_ATTRIBUTE                                                0x00001d64

#define NV097_UNPARK_ATTRIBUTE                                              0x00001d68

#define NV097_SET_SEMAPHORE_OFFSET                                          0x00001d6c
#define NV097_SET_SEMAPHORE_OFFSET_V                                              31:0

#define NV097_BACK_END_WRITE_SEMAPHORE_RELEASE                              0x00001d70
#define NV097_BACK_END_WRITE_SEMAPHORE_RELEASE_V                                  31:0

#define NV097_TEXTURE_READ_SEMAPHORE_RELEASE                                0x00001d74
#define NV097_TEXTURE_READ_SEMAPHORE_RELEASE_V                                    31:0

#define NV097_SET_ZMIN_MAX_CONTROL                                          0x00001d78
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN                                3:0
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE                   0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_TRUE                    0x00000001
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN                                       7:4
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CULL                           0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP                          0x00000001
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W                                  11:8
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_FALSE                      0x00000000
#define NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE                       0x00000001

#define NV097_SET_ANTI_ALIASING_CONTROL                                     0x00001d7c
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE                                     3:0
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE                        0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_TRUE                         0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE                          7:4
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_DISABLE           0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_COVERAGE_ENABLE            0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE                              11:8
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_DISABLE                0x00000000
#define NV097_SET_ANTI_ALIASING_CONTROL_ALPHA_TO_ONE_ENABLE                 0x00000001
#define NV097_SET_ANTI_ALIASING_CONTROL_SAMPLE_MASK                              31:16

#define NV097_SET_COMPRESS_ZBUFFER_EN                                       0x00001d80
#define NV097_SET_COMPRESS_ZBUFFER_EN_V                                           31:0
#define NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE                             0x00000000
#define NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE                              0x00000001

#define NV097_SET_OCCLUDE_ZSTENCIL_EN                                       0x00001d84
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN                                  0:0
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE                   0x00000000
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_ENABLE                    0x00000001
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN                           1:1
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_DISABLE            0x00000000
#define NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_STENCIL_EN_ENABLE             0x00000001

#define NV097_SET_SURFACE_FORMAT                                            0x00000208
#define NV097_SET_SURFACE_FORMAT_COLOR                                             3:0
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                 0x00000001
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                 0x00000002
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5                            0x00000003
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                 0x00000004
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                 0x00000005
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8             0x00000006
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8             0x00000007
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8                          0x00000008
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_B8                                0x00000009
#define NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8                              0x0000000A
#define NV097_SET_SURFACE_FORMAT_ZETA                                              7:4
#define NV097_SET_SURFACE_FORMAT_ZETA_Z16                                   0x00000001
#define NV097_SET_SURFACE_FORMAT_ZETA_Z24S8                                 0x00000002
#define NV097_SET_SURFACE_FORMAT_TYPE                                             11:8
#define NV097_SET_SURFACE_FORMAT_TYPE_PITCH                                 0x00000001
#define NV097_SET_SURFACE_FORMAT_TYPE_SWIZZLE                               0x00000002
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING                                   15:12
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1                     0x00000000
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_CORNER_2              0x00000001
#define NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_SQUARE_OFFSET_4              0x00000002
#define NV097_SET_SURFACE_FORMAT_WIDTH                                           23:16
#define NV097_SET_SURFACE_FORMAT_WIDTH_1                                    0x00000000
#define NV097_SET_SURFACE_FORMAT_WIDTH_2                                    0x00000001
#define NV097_SET_SURFACE_FORMAT_WIDTH_4                                    0x00000002
#define NV097_SET_SURFACE_FORMAT_WIDTH_8                                    0x00000003
#define NV097_SET_SURFACE_FORMAT_WIDTH_16                                   0x00000004
#define NV097_SET_SURFACE_FORMAT_WIDTH_32                                   0x00000005
#define NV097_SET_SURFACE_FORMAT_WIDTH_64                                   0x00000006
#define NV097_SET_SURFACE_FORMAT_WIDTH_128                                  0x00000007
#define NV097_SET_SURFACE_FORMAT_WIDTH_256                                  0x00000008
#define NV097_SET_SURFACE_FORMAT_WIDTH_512                                  0x00000009
#define NV097_SET_SURFACE_FORMAT_WIDTH_1024                                 0x0000000A
#define NV097_SET_SURFACE_FORMAT_WIDTH_2048                                 0x0000000B
#define NV097_SET_SURFACE_FORMAT_WIDTH_4096                                 0x0000000C
#define NV097_SET_SURFACE_FORMAT_HEIGHT                                          31:24
#define NV097_SET_SURFACE_FORMAT_HEIGHT_1                                   0x00000000
#define NV097_SET_SURFACE_FORMAT_HEIGHT_2                                   0x00000001
#define NV097_SET_SURFACE_FORMAT_HEIGHT_4                                   0x00000002
#define NV097_SET_SURFACE_FORMAT_HEIGHT_8                                   0x00000003
#define NV097_SET_SURFACE_FORMAT_HEIGHT_16                                  0x00000004
#define NV097_SET_SURFACE_FORMAT_HEIGHT_32                                  0x00000005
#define NV097_SET_SURFACE_FORMAT_HEIGHT_64                                  0x00000006
#define NV097_SET_SURFACE_FORMAT_HEIGHT_128                                 0x00000007
#define NV097_SET_SURFACE_FORMAT_HEIGHT_256                                 0x00000008
#define NV097_SET_SURFACE_FORMAT_HEIGHT_512                                 0x00000009
#define NV097_SET_SURFACE_FORMAT_HEIGHT_1024                                0x0000000A
#define NV097_SET_SURFACE_FORMAT_HEIGHT_2048                                0x0000000B
#define NV097_SET_SURFACE_FORMAT_HEIGHT_4096                                0x0000000C

#define NV097_SET_ZSTENCIL_CLEAR_VALUE                                      0x00001d8c
#define NV097_SET_ZSTENCIL_CLEAR_VALUE_V                                          31:0

#define NV097_SET_COLOR_CLEAR_VALUE                                         0x00001d90
#define NV097_SET_COLOR_CLEAR_VALUE_V                                             31:0

#define NV097_CLEAR_SURFACE                                                 0x00001d94
#define NV097_CLEAR_SURFACE_Z                                                      0:0
#define NV097_CLEAR_SURFACE_Z_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_Z_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_STENCIL                                                1:1
#define NV097_CLEAR_SURFACE_STENCIL_DISABLE                                 0x00000000
#define NV097_CLEAR_SURFACE_STENCIL_ENABLE                                  0x00000001
#define NV097_CLEAR_SURFACE_R                                                      4:4
#define NV097_CLEAR_SURFACE_R_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_R_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_G                                                      5:5
#define NV097_CLEAR_SURFACE_G_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_G_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_B                                                      6:6
#define NV097_CLEAR_SURFACE_B_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_B_ENABLE                                        0x00000001
#define NV097_CLEAR_SURFACE_A                                                      7:7
#define NV097_CLEAR_SURFACE_A_DISABLE                                       0x00000000
#define NV097_CLEAR_SURFACE_A_ENABLE                                        0x00000001

#define NV097_SET_CLEAR_RECT_HORIZONTAL                                     0x00001d98
#define NV097_SET_CLEAR_RECT_HORIZONTAL_XMIN                                      15:0
#define NV097_SET_CLEAR_RECT_HORIZONTAL_XMAX                                     31:16

#define NV097_SET_CLEAR_RECT_VERTICAL                                       0x00001d9c
#define NV097_SET_CLEAR_RECT_VERTICAL_YMIN                                        15:0
#define NV097_SET_CLEAR_RECT_VERTICAL_YMAX                                       31:16

#define NV097_SET_BEGIN_PATCH0                                              0x00001de0
#define NV097_SET_BEGIN_PATCH0_POSITION_DEGREE                                     3:0
#define NV097_SET_BEGIN_PATCH0_PARAM1_DEGREE                                       7:4
#define NV097_SET_BEGIN_PATCH0_PARAM2_DEGREE                                      11:8
#define NV097_SET_BEGIN_PATCH0_PARAM3_DEGREE                                     15:12
#define NV097_SET_BEGIN_PATCH0_PARAM4_DEGREE                                     19:16
#define NV097_SET_BEGIN_PATCH0_PARAM5_DEGREE                                     23:20
#define NV097_SET_BEGIN_PATCH0_PARAM6_DEGREE                                     27:24
#define NV097_SET_BEGIN_PATCH0_PARAM7_DEGREE                                     31:28

#define NV097_SET_BEGIN_PATCH1                                              0x00001de4
#define NV097_SET_BEGIN_PATCH1_PARAM8_DEGREE                                       3:0
#define NV097_SET_BEGIN_PATCH1_PARAM9_DEGREE                                       7:4
#define NV097_SET_BEGIN_PATCH1_PARAM10_DEGREE                                     11:8
#define NV097_SET_BEGIN_PATCH1_PARAM11_DEGREE                                    15:12
#define NV097_SET_BEGIN_PATCH1_PARAM12_DEGREE                                    19:16
#define NV097_SET_BEGIN_PATCH1_PARAM13_DEGREE                                    23:20
#define NV097_SET_BEGIN_PATCH1_PARAM14_DEGREE                                    27:24
#define NV097_SET_BEGIN_PATCH1_PARAM15_DEGREE                                    31:28

#define NV097_SET_BEGIN_PATCH2                                              0x00001de8
#define NV097_SET_BEGIN_PATCH2_SWATCH_ROWS                                         7:0
#define NV097_SET_BEGIN_PATCH2_SWATCH_COLS                                        15:8
#define NV097_SET_BEGIN_PATCH2_SWATCH_SIZE                                       20:16
#define NV097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_WIDTH                              25:21
#define NV097_SET_BEGIN_PATCH2_PARTIAL_SWATCH_HEIGHT                             30:26
#define NV097_SET_BEGIN_PATCH2_PATCH_TYPE                                        31:31
#define NV097_SET_BEGIN_PATCH2_PATCH_TYPE_SQUARE                            0x00000000

#define NV097_SET_BEGIN_PATCH3                                              0x00001dec
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS                                            2:0
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_NONE                                0x00000000
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST                               0x00000001
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_LAST                                0x00000002
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_FIRST_AND_LAST                      0x00000003
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_REV_FIRST                           0x00000005
#define NV097_SET_BEGIN_PATCH3_ROW_TRNS_REV_LAST                            0x00000006
#define NV097_SET_BEGIN_PATCH3_COL_TRNS                                            5:3
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_NONE                                0x00000000
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST                               0x00000001
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_LAST                                0x00000002
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_FIRST_AND_LAST                      0x00000003
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_REV_FIRST                           0x00000005
#define NV097_SET_BEGIN_PATCH3_COL_TRNS_REV_LAST                            0x00000006
#define NV097_SET_BEGIN_PATCH3_POSITION_GUARD_CURVE_DEGREE                         9:6
#define NV097_SET_BEGIN_PATCH3_NORMAL_GUARD_CURVE_DEGREE                         13:10
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE                                         15:14
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_TRI_STRIP                          0x00000000
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_REVERSED_TRI_STRIP                 0x00000001
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_BW_TRI_STRIP                       0x00000002
#define NV097_SET_BEGIN_PATCH3_PRIMITIVE_BW_REVERSED_TRI_STRIP              0x00000003
#define NV097_SET_BEGIN_PATCH3_TESSELATION                                       16:16
#define NV097_SET_BEGIN_PATCH3_TESSELATION_ADAPTIVE_STITCH                  0x00000000
#define NV097_SET_BEGIN_PATCH3_TESSELATION_FIXED_STITCH                     0x00000001
#define NV097_SET_BEGIN_PATCH3_NUM_COEFFS                                        31:24

#define NV097_SET_END_PATCH                                                 0x00001df0

#define NV097_SET_BEGIN_END_SWATCH                                          0x00001df4
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD                                      3:0
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_END                           0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SWATCH_CMD_BEGIN                         0x00000001
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH                                       7:4
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_CONTINUE                       0x00000000
#define NV097_SET_BEGIN_END_SWATCH_NEW_SWATH_NEW                            0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW                                 11:8
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_FALSE                     0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_ROW_TRUE                      0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL                                15:12
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_FALSE                     0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SKIP_FIRST_COL_TRUE                      0x00000001
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH                                  19:16
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_FULL_HEIGHT                 0x00000000
#define NV097_SET_BEGIN_END_SWATCH_SHORT_SWATCH_PARTIAL_HEIGHT              0x00000001
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH                                 31:20
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_FULL_WIDTH                 0x00000000
#define NV097_SET_BEGIN_END_SWATCH_NARROW_SWATCH_PARTIAL_WIDTH              0x00000001

#define NV097_SET_BEGIN_END_CURVE                                           0x00001df8
#define NV097_SET_BEGIN_END_CURVE_CMD                                              3:0
#define NV097_SET_BEGIN_END_CURVE_CMD_END_CURVE_DATA                        0x00000000
#define NV097_SET_BEGIN_END_CURVE_CMD_STRIP_CURVE                           0x00000001
#define NV097_SET_BEGIN_END_CURVE_CMD_LEFT_GUARD_CURVE                      0x00000002
#define NV097_SET_BEGIN_END_CURVE_CMD_RIGHT_GUARD_CURVE                     0x00000003
#define NV097_SET_BEGIN_END_CURVE_CMD_OUTER_TRANSITION_CURVE                0x00000004
#define NV097_SET_BEGIN_END_CURVE_CMD_INNER_TRANSITION_CURVE                0x00000005
#define NV097_SET_BEGIN_END_CURVE_CMD_OUTER_END_PT                          0x00000006
#define NV097_SET_BEGIN_END_CURVE_CMD_INNER_END_PT                          0x00000007

#define NV097_SET_CURVE_COEFFICIENTS(i)                             (0x00001e00+(i)*4)
#define NV097_SET_CURVE_COEFFICIENTS_V                                            31:0

#define NV097_SET_BEGIN_TRANSITION0                                         0x00001e10
#define NV097_SET_BEGIN_TRANSITION0_POSITION_DEGREE                                3:0
#define NV097_SET_BEGIN_TRANSITION0_PARAM1_DEGREE                                  7:4
#define NV097_SET_BEGIN_TRANSITION0_PARAM2_DEGREE                                 11:8
#define NV097_SET_BEGIN_TRANSITION0_PARAM3_DEGREE                                15:12
#define NV097_SET_BEGIN_TRANSITION0_PARAM4_DEGREE                                19:16
#define NV097_SET_BEGIN_TRANSITION0_PARAM5_DEGREE                                23:20
#define NV097_SET_BEGIN_TRANSITION0_PARAM6_DEGREE                                27:24
#define NV097_SET_BEGIN_TRANSITION0_PARAM7_DEGREE                                31:28

#define NV097_SET_BEGIN_TRANSITION1                                         0x00001e14
#define NV097_SET_BEGIN_TRANSITION1_PARAM8_DEGREE                                  3:0
#define NV097_SET_BEGIN_TRANSITION1_PARAM9_DEGREE                                  7:4
#define NV097_SET_BEGIN_TRANSITION1_PARAM10_DEGREE                                11:8
#define NV097_SET_BEGIN_TRANSITION1_PARAM11_DEGREE                               15:12
#define NV097_SET_BEGIN_TRANSITION1_PARAM12_DEGREE                               19:16
#define NV097_SET_BEGIN_TRANSITION1_PARAM13_DEGREE                               23:20
#define NV097_SET_BEGIN_TRANSITION1_PARAM14_DEGREE                               27:24
#define NV097_SET_BEGIN_TRANSITION1_PARAM15_DEGREE                               31:28

#define NV097_SET_BEGIN_TRANSITION2                                         0x00001e18
#define NV097_SET_BEGIN_TRANSITION2_INSIDE_SEGMENTS                                9:0
#define NV097_SET_BEGIN_TRANSITION2_OUTSIDE_SEGMENTS                             19:10
#define NV097_SET_BEGIN_TRANSITION2_NUM_COEFFS                                   31:24

#define NV097_SET_END_TRANSITION                                            0x00001e1c

#define NV097_SET_SHADOW_ZSLOPE_THRESHOLD                                   0x00001e68
#define NV097_SET_SHADOW_ZSLOPE_THRESHOLD_V                                       31:0

#define NV097_SET_SHADOW_DEPTH_FUNC                                         0x00001e6c
#define NV097_SET_SHADOW_DEPTH_FUNC_V                                             31:0
#define NV097_SET_SHADOW_DEPTH_FUNC_V_NEVER                                 0x00000000
#define NV097_SET_SHADOW_DEPTH_FUNC_V_LESS                                  0x00000001
#define NV097_SET_SHADOW_DEPTH_FUNC_V_EQUAL                                 0x00000002
#define NV097_SET_SHADOW_DEPTH_FUNC_V_LEQUAL                                0x00000003
#define NV097_SET_SHADOW_DEPTH_FUNC_V_GREATER                               0x00000004
#define NV097_SET_SHADOW_DEPTH_FUNC_V_NOTEQUAL                              0x00000005
#define NV097_SET_SHADOW_DEPTH_FUNC_V_GEQUAL                                0x00000006
#define NV097_SET_SHADOW_DEPTH_FUNC_V_ALWAYS                                0x00000007

#define NV097_SET_SHADER_STAGE_PROGRAM                                      0x00001e70
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0                                      4:0
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1                                      9:5
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT                   0x00000011
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2                                    14:10
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BRDF                          0x00000008
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST                        0x00000009
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW                        0x0000000A
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE           0x0000000B
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT                   0x00000011
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3                                    19:15
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE                  0x00000000
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE                 0x00000001
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE                 0x00000002
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP                      0x00000003
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH                  0x00000004
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE                    0x00000005
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP                    0x00000006
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE          0x00000007
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF                          0x00000008
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST                        0x00000009
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW                        0x0000000A
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR          0x0000000C
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D                    0x0000000D
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE                  0x0000000E
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR                  0x0000000F
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB                  0x00000010
#define NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST    0x00000012

#define NV097_SET_EYE_VECTOR(i)                                     (0x0000181c+(i)*4)
#define NV097_SET_EYE_VECTOR_V                                                    31:0

#define NV097_SET_DOT_RGBMAPPING                                            0x00001e74
#define NV097_SET_DOT_RGBMAPPING_STAGE1                                            3:0
#define NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_NV                  0x00000007
#define NV097_SET_DOT_RGBMAPPING_STAGE2                                            7:4
#define NV097_SET_DOT_RGBMAPPING_STAGE2_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE2_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE2_HILO_HEMISPHERE_NV                  0x00000007
#define NV097_SET_DOT_RGBMAPPING_STAGE3                                           11:8
#define NV097_SET_DOT_RGBMAPPING_STAGE3_ZERO_TO_1                           0x00000000
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_MS                     0x00000001
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_GL                     0x00000002
#define NV097_SET_DOT_RGBMAPPING_STAGE3_MINUS_1_TO_1_NV                     0x00000003
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_1                              0x00000004
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_MS                  0x00000005
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_GL                  0x00000006
#define NV097_SET_DOT_RGBMAPPING_STAGE3_HILO_HEMISPHERE_NV                  0x00000007

#define NV097_SET_SHADER_CLIP_PLANE_MODE                                    0x000017f8
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S                                  0:0
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T                                  1:1
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R                                  2:2
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q                                  3:3
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE0_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S                                  4:4
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T                                  5:5
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R                                  6:6
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q                                  7:7
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE1_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S                                  8:8
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T                                  9:9
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R                                10:10
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q                                11:11
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE2_Q_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S                                12:12
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_S_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T                                13:13
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_T_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R                                14:14
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_R_CLIPGEZ                   0x00000001
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q                                15:15
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPLTZ                   0x00000000
#define NV097_SET_SHADER_CLIP_PLANE_MODE_STAGE3_Q_CLIPGEZ                   0x00000001

#define NV097_SET_SHADER_OTHER_STAGE_INPUT                                  0x00001e78
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1                                 15:0
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2                                19:16
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1                 0x00000001
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3                                23:20
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0                 0x00000000
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1                 0x00000001
#define NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2                 0x00000002

#define NV097_SET_SPECULAR_FOG_FACTOR(i)                            (0x00001e20+(i)*4)
#define NV097_SET_SPECULAR_FOG_FACTOR_BLUE                                         7:0
#define NV097_SET_SPECULAR_FOG_FACTOR_GREEN                                       15:8
#define NV097_SET_SPECULAR_FOG_FACTOR_RED                                        23:16
#define NV097_SET_SPECULAR_FOG_FACTOR_ALPHA                                      31:24

#define NV097_SET_COMBINER_CONTROL                                          0x00001e60
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT                                 7:0
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE                      0x00000001
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_TWO                      0x00000002
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_THREE                    0x00000003
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FOUR                     0x00000004
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FIVE                     0x00000005
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SIX                      0x00000006
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SEVEN                    0x00000007
#define NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_EIGHT                    0x00000008
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT                                     11:8
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT_LSB                           0x00000000
#define NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB                           0x00000001
#define NV097_SET_COMBINER_CONTROL_FACTOR0                                       15:12
#define NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL                  0x00000000
#define NV097_SET_COMBINER_CONTROL_FACTOR0_EACH_STAGE                       0x00000001
#define NV097_SET_COMBINER_CONTROL_FACTOR1                                       31:16
#define NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL                  0x00000000
#define NV097_SET_COMBINER_CONTROL_FACTOR1_EACH_STAGE                       0x00000001

#define NV097_SET_COMBINER_COLOR_OCW(i)                             (0x00001e40+(i)*4)
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB                              31:19
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE                 0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE           0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD                              18:18
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE                 0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE           0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_OP                                          17:15
#define NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT                             0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT_BIAS                        0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1                        0x00000002
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1_BIAS                   0x00000003
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY2                        0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTRIGHTBY1                       0x00000006
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE                                  14:14
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE                       0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_TRUE                        0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE                               13:13
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE                    0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_TRUE                     0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE                               12:12
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE                    0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_TRUE                     0x00000001
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST                                      11:8
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0                          0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4                          0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5                          0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8                          0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9                          0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A                          0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B                          0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C                          0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D                          0x0000000D
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST                                        7:4
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D                           0x0000000D
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST                                        3:0
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0                           0x00000000
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4                           0x00000004
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5                           0x00000005
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8                           0x00000008
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9                           0x00000009
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A                           0x0000000A
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B                           0x0000000B
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C                           0x0000000C
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D                           0x0000000D

#define NV097_SET_TRANSFORM_EXECUTION_MODE                                  0x00001e94
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE                                    1:0
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED                       0x00000000
#define NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_PROGRAM                     0x00000002
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE                             31:2
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_USER                  0x00000000
#define NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV                  0x00000001

#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN                            0x00001e98
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V                                31:0
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_ONLY                0x00000000
#define NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN_V_READ_WRITE               0x00000001

#define NV097_SET_TRANSFORM_PROGRAM_LOAD                                    0x00001e9c
#define NV097_SET_TRANSFORM_PROGRAM_LOAD_PROG_LD_PTR                              31:0

#define NV097_SET_TRANSFORM_PROGRAM_START                                   0x00001ea0
#define NV097_SET_TRANSFORM_PROGRAM_START_V                                       31:0

#define NV097_SET_TRANSFORM_PROGRAM(i)                              (0x00000b00+(i)*4)
#define NV097_SET_TRANSFORM_PROGRAM_V                                             31:0

#define NV097_SET_TRANSFORM_CONSTANT_LOAD                                   0x00001ea4
#define NV097_SET_TRANSFORM_CONSTANT_LOAD_CONST_LD_PTR                            31:0

#define NV097_SET_TRANSFORM_CONSTANT(i)                             (0x00000b80+(i)*4)
#define NV097_SET_TRANSFORM_CONSTANT_V                                            31:0

#define NV097_SET_TRANSFORM_DATA(i)                                 (0x00001e80+(i)*4)
#define NV097_SET_TRANSFORM_DATA_V                                                31:0

#define NV097_LAUNCH_TRANSFORM_PROGRAM                                      0x00001e90
#define NV097_LAUNCH_TRANSFORM_PROGRAM_V                                          31:0

#define NV097_SET_TWO_SIDE_LIGHT_EN                                         0x000017c4
#define NV097_SET_TWO_SIDE_LIGHT_EN_V                                             31:0
#define NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE                                 0x00000000
#define NV097_SET_TWO_SIDE_LIGHT_EN_V_TRUE                                  0x00000001

#define NV097_SET_BACK_SCENE_AMBIENT_COLOR(i)                       (0x000017a0+(i)*4)
#define NV097_SET_BACK_SCENE_AMBIENT_COLOR_V                                      31:0

#define NV097_SET_BACK_MATERIAL_EMISSION(i)                         (0x000017b0+(i)*4)
#define NV097_SET_BACK_MATERIAL_EMISSION_V                                        31:0

#define NV097_CLEAR_REPORT_VALUE                                            0x000017c8
#define NV097_CLEAR_REPORT_VALUE_TYPE                                             31:0
#define NV097_CLEAR_REPORT_VALUE_TYPE_ZPASS_PIXEL_CNT                       0x00000001

#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE                                  0x000017cc
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V                                      31:0
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE                          0x00000000
#define NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_TRUE                           0x00000001

#define NV097_GET_REPORT                                                    0x000017d0
#define NV097_GET_REPORT_OFFSET                                                   23:0
#define NV097_GET_REPORT_TYPE                                                    31:24
#define NV097_GET_REPORT_TYPE_ZPASS_PIXEL_CNT                               0x00000001

#define NV097_DEBUG_INIT(i)                                         (0x00001fc0+(i)*4)
#define NV097_DEBUG_INIT_V                                                        31:0
#define NV097_TYPEDEF                                              Nv20KelvinPrimitive
#define NV097_SET_OBJECT                                                  (0x00000000)


// XXXmjc Shaun Ho and John Montrym will roll these into the master file at some point.
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_ZERO              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_CONST0            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_CONST1            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_FOG               NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX0              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX1              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX2              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_A
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_TEX3              NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_B
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPARE0            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C
#define NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_SPARE1            NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D

#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_ZERO              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_CONST0            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_CONST1            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_FOG               NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_DIFFUSE           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPECULAR          NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX0              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX1              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX2              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_A
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_TEX3              NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_B
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPARE0            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C
#define NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_SPARE1            NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_ZERO               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_DIFFUSE            NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPECULAR           NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX0               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX1               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX2               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_TEX3               NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPARE0             NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_SPARE1             NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_ZERO                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_DIFFUSE             NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPECULAR            NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX0                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX1                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX2                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_TEX3                NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPARE0              NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_SPARE1              NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D

#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_ZERO                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_DIFFUSE             NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPECULAR            NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX0                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX1                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX2                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_A
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_TEX3                NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_B
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPARE0              NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C
#define NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_SPARE1              NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_ZERO               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_DIFFUSE            NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPECULAR           NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX0               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX1               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX2               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_TEX3               NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPARE0             NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_SPARE1             NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_ZERO                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_DIFFUSE             NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPECULAR            NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX0                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX1                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX2                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_TEX3                NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPARE0              NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_SPARE1              NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_D

#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_ZERO                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_DIFFUSE             NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_4
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPECULAR            NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_5
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX0                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_8
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX1                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_9
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX2                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_A
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_TEX3                NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_B
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPARE0              NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_C
#define NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_SPARE1              NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D

#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_ZERO       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_CONST0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_CONST1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_FOG        NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_DIFFUSE    NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPECULAR   NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX0       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX1       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX2       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_A
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_TEX3       NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_B
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPARE0     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C
#define NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_SPARE1     NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D


/* class NV15_CONTEXT_SURFACE_SWIZZLED */
#define  NV15_CONTEXT_SURFACE_SWIZZLED                             (0x0000009E)
/* NvNotification[] elements */
#define NV09E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV09E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV09E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV09E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV09E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV09E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV09E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV09E_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 Reserved01[0x05e];
 NvV32 SetFormat;               /* height_width_color V8_V8_V16     0300-0303*/
 NvU32 SetOffset;               /* byte offset of top-left pixel    0304-0307*/
 NvV32 Reserved02[0x73e];
} Nv09eTypedef, Nv15ContextSurfaceSwizzled;
#define NV09E_TYPEDEF                                Nv15ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV09E_SET_OBJECT                                           (0x00000000)
#define NV09E_NO_OPERATION                                         (0x00000100)
#define NV09E_NOTIFY                                               (0x00000104)
#define NV09E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV09E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV09E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV09E_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV09E_SET_FORMAT                                           (0x00000300)
#define NV09E_SET_FORMAT_COLOR                                     15:0
#define NV09E_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV09E_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV09E_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV09E_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV09E_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV09E_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV09E_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV09E_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV09E_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV09E_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV09E_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV09E_SET_FORMAT_WIDTH                                     23:16
#define NV09E_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV09E_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV09E_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV09E_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV09E_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV09E_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV09E_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV09E_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV09E_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV09E_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV09E_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV09E_SET_FORMAT_HEIGHT                                    31:24
#define NV09E_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV09E_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV09E_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV09E_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV09E_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV09E_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV09E_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV09E_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV09E_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV09E_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV09E_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV09E_SET_OFFSET                                           (0x00000304)


/* class NV15_IMAGE_BLIT */
#define  NV15_IMAGE_BLIT                                           (0x0000009F)
/* NvNotification[] elements */
#define NV09F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV09F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV09F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV09F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV09F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV09F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV09F_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 SyncSetRead;             /*                                  0120-0123*/
 NvV32 SyncSetWrite;            /*                                  0124-0127*/
 NvV32 SyncSetModulo;           /*                                  0128-012b*/
 NvV32 SyncIncrementWrite;      /* ignored                          012c-012f*/
 NvV32 SyncStall;               /* ignored                          0130-0133*/
 NvV32 SyncIncrementReadRange;  /* scanline range to check 0 or 1   0134-0137*/
 NvV32 Reserved02[0x012];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved03[0x057];
 NvV32 SetOperation;            /* NV09F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved04[0x73d];
} Nv09fTypedef, Nv12ImageBlit;
#define NV09F_TYPEDEF                                             Nv12ImageBlit
/* dma method offsets, fields, and values */
#define NV09F_SET_OBJECT                                           (0x00000000)
#define NV09F_NO_OPERATION                                         (0x00000100)
#define NV09F_NOTIFY                                               (0x00000104)
#define NV09F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV09F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV09F_SYNC_SET_READ                                        (0x00000120)
#define NV09F_SYNC_SET_WRITE                                       (0x00000124)
#define NV09F_SYNC_SET_MODULO                                      (0x00000128)
#define NV09F_SYNC_INCREMENT_WRITE                                 (0x0000012C)
#define NV09F_SYNC_STALL                                           (0x00000130)
#define NV09F_SYNC_INCREMENT_READ_RANGE                            (0x00000134)
#define NV09F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV09F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV09F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV09F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV09F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV09F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV09F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV09F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV09F_SET_OPERATION                                        (0x000002FC)
#define NV09F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV09F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV09F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV09F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV09F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV09F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV09F_CONTROL_POINT_IN                                     (0x00000300)
#define NV09F_CONTROL_POINT_IN_X                                   15:0
#define NV09F_CONTROL_POINT_IN_Y                                   31:16
#define NV09F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV09F_CONTROL_POINT_OUT_X                                  15:0
#define NV09F_CONTROL_POINT_OUT_Y                                  31:16
#define NV09F_SIZE                                                 (0x00000308)
#define NV09F_SIZE_WIDTH                                           15:0
#define NV09F_SIZE_HEIGHT                                          31:16


/* class NV20_IMAGE_BLIT */
#define  NV20_IMAGE_BLIT                                            (0x0000205F)
/* NvNotification[] elements */
#define NV205F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV205F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV205F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV205F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV205F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV205F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV205F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV205F_NOTIFY_*                  0104-0107*/
 NvV32 Reserved00[0x006];
 NvV32 SyncSetRead;             /*                                  0120-0123*/
 NvV32 SyncSetWrite;            /*                                  0124-0127*/
 NvV32 SyncSetModulo;           /*                                  0128-012b*/
 NvV32 SyncIncrementWrite;      /* ignored                          012c-012f*/
 NvV32 SyncStall;               /* ignored                          0130-0133*/
 NvV32 SyncIncrementReadRange;  /* ignored                          0134-0137*/
 NvV32 Reserved02[0x012];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved03[0x057];
 NvV32 SetOperation;            /* NV205F_SET_OPERATION_*            02fc-02ff*/
 NvV32 ControlPointIn;          /* y_x U16_U16, pixels              0300-0303*/
 NvV32 ControlPointOut;         /* y_x S16_S16, pixels              0304-0307*/
 NvV32 Size;                    /* height_width U16_U16 in pixels   0308-030b*/
 NvV32 Reserved04[0x73d];
} Nv205fTypedef, Nv20ImageBlit;
#define NV205F_TYPEDEF                                             Nv20ImageBlit
/* dma method offsets, fields, and values */
#define NV205F_SET_OBJECT                                           (0x00000000)
#define NV205F_NO_OPERATION                                         (0x00000100)
#define NV205F_NOTIFY                                               (0x00000104)
#define NV205F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV205F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV205F_SYNC_SET_READ                                        (0x00000120)
#define NV205F_SYNC_SET_WRITE                                       (0x00000124)
#define NV205F_SYNC_SET_MODULO                                      (0x00000128)
#define NV205F_SYNC_INCREMENT_WRITE                                 (0x0000012C)
#define NV205F_SYNC_STALL                                           (0x00000130)
#define NV205F_SYNC_INCREMENT_READ_RANGE                            (0x00000134)
#define NV205F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV205F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV205F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV205F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV205F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV205F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV205F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV205F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV205F_SET_OPERATION                                        (0x000002FC)
#define NV205F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV205F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV205F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV205F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV205F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV205F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV205F_CONTROL_POINT_IN                                     (0x00000300)
#define NV205F_CONTROL_POINT_IN_X                                   15:0
#define NV205F_CONTROL_POINT_IN_Y                                   31:16
#define NV205F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV205F_CONTROL_POINT_OUT_X                                  15:0
#define NV205F_CONTROL_POINT_OUT_Y                                  31:16
#define NV205F_SIZE                                                 (0x00000308)
#define NV205F_SIZE_WIDTH                                           15:0
#define NV205F_SIZE_HEIGHT                                          31:16


/* class NV03_DEVICE_XX */
#define  NV03_DEVICE_XX                                            (0x000000FF)
/* NvNotification[] fields and values */
#define NV0FF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0FFTypedef, Nv03DeviceXX;
#define  NV0FF_TYPEDEF                                             Nv03DeviceXX

typedef V032 Nvff0Typedef;

typedef V032 Nvff1Typedef;

typedef V032 Nvff2Typedef;

typedef V032 Nvff3Typedef;

typedef V032 Nvff4Typedef;


/* class NV_CONTEXT_ERROR_TO_MEMORY */
#define  NV_CONTEXT_ERROR_TO_MEMORY                                (0x00000FF5)
/* NvNotification[] elements */
#define NVFF5_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF5_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF5_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF5_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} Nvff5Typedef, NvContextErrorToMemory;
#define NVFF5_TYPEDEF                                    NvContextErrorToMemory
/* dma method offsets, fields, and values */
#define NVFF5_SET_OBJECT(s)                              (0x00040000+8192*(s))
#define NVFF5_NO_OPERATION(s)                            (0x00040100+8192*(s))
#define NVFF5_NOTIFY(s)                                  (0x00040104+8192*(s))
#define NVFF5_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF5_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF5_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00040180+8192*(s))
#define NVFF5_SET_DMA_SPECIFIER(s)                       (0x000C0300+8192*(s))
/* obsolete stuff */
#define nvContextErrorToMemory                           NvContextErrorToMemory


/* class NV_VIDEO_COLOR_KEY */
#define  NV_VIDEO_COLOR_KEY                                        (0x00000FF6)
/* NvNotification[] elements */
#define NVFF6_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF6_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF6_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput[3];        /* NV1_PATCHCORD_VIDEO               0204-020b*/
 V032 Reserved02[0x03c];
 V032 SetColorFormat;          /* NVFF6_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top-left  0308-030b*/
 V032 SetSize;                 /* height_width U16_U16 in pixels    030c-030f*/
 V032 Reserved03[0x73c];
} Nvff6Typedef, NvVideoColorKey;
#define NVFF6_TYPEDEF                                    NvVideoColorKey
/* dma method offsets, fields, and values */
#define NVFF6_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF6_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF6_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF6_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF6_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF6_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF6_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF6_SET_VIDEO_INPUT(s,i)                       (0x00000204+8192*(s)+\
                                                                       4*(i))
#define NVFF6_SET_COLOR_FORMAT(s)                        (0x00000300+8192*(s))
#define NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8                (0x00000001)
#define NVFF6_SET_COLOR_FORMAT_LE_X24Y8                  (0x00000002)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5            (0x00000003)
#define NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5              (0x00000004)
#define NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5              (0x00000005)
#define NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8               (0x00000006)
#define NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8               (0x00000007)
#define NVFF6_SET_COLOR_FORMAT_LE_A16Y16                 (0x00000008)
#define NVFF6_SET_COLOR_FORMAT_LE_X16Y16                 (0x00000009)
#define NVFF6_SET_COLOR_KEY(s)                           (0x00000304+8192*(s))
#define NVFF6_SET_POINT(s)                               (0x00000308+8192*(s))
#define NVFF6_SET_POINT_X                                15:0
#define NVFF6_SET_POINT_Y                                31:16
#define NVFF6_SET_SIZE(s)                                (0x0000030C+8192*(s))
#define NVFF6_SET_SIZE_WIDTH                             15:0
#define NVFF6_SET_SIZE_HEIGHT                            31:16
/* obsolete stuff */
#define nvVideoColorKey                                  NvVideoColorKey


/* class NV_VIDEO_SCALER */
#define  NV_VIDEO_SCALER                                           (0x00000FF7)
/* NvNotification[] elements */
#define NVFF7_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFF7_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF7_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x03e];
 V032 SetDeltaDuDx;            /* S12d20 ratio du/dx                0300-0303*/
 V032 SetDeltaDvDy;            /* S12d20 ratio dv/dy                0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels, top-left   0308-030b*/
 V032 Reserved03[0x73d];
} Nvff7Typedef, NvVideoScaler;
#define NVFF7_TYPEDEF                                    NvVideoScaler
/* dma method offsets, fields, and values */
#define NVFF7_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF7_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF7_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF7_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF7_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF7_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF7_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF7_SET_VIDEO_INPUT(s)                         (0x00000204+8192*(s))
#define NVFF7_SET_DELTA_DU_DX(s)                         (0x00000300+8192*(s))
#define NVFF7_SET_DELTA_DV_DY(s)                         (0x00000304+8192*(s))
#define NVFF7_SET_POINT(s)                               (0x00000308+8192*(s))
#define NVFF7_SET_POINT_X                                15:0
#define NVFF7_SET_POINT_Y                                31:16
/* obsolete stuff */
#define nvVideoScaler                                    NvVideoScaler


/* class NV_VIDEO_FROM_MEMORY */
#define  NV_VIDEO_FROM_MEMORY                                      (0x00000FF8)
/* NvNotification[] elements */
#define NVFF8_NOTIFIERS_NOTIFY                                     (0)
#define NVFF8_NOTIFIERS_IMAGE_SCAN(b)                              (1+(b))
#define NVFF8_NOTIFIERS_GET_OFFSET_NOTIFY(b)                       (3+(b))
/* NvNotification[] fields and values */
#define NVFF8_NOTIFICATION_INFO16_BUFFER_NOT_STARTED               (0x0001)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_OFFSET_VALID              (0x0002)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_DONE                      (0x0003)
#define NVFF8_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_PATCH                  (0x0400)
#define NVFF8_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF8_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NVFF8_STOP_TRANSFER_VALUE         0108-010b*/
 V032 SetPatch;                /* NVFF8_SET_PATCH_*                 010c-010f*/
 V032 Reserved00[0x01c];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage[2];   /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-018b*/
 V032 Reserved01[0x01d];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 Reserved02[0x03f];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes, vertical pixel delta         04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* field_color V16_V16                 0c-  0f*/
  V032 notify;                 /* NVFF8_IMAGE_SCAN_NOTIFY_*           10-  13*/
 } ImageScan[2];               /* end of methods in array               -0327*/
 V032 GetOffsetNotify[2];      /* NVFF8_GET_OFFSET_NOTIFY_*         0328-032f*/
 V032 Reserved03[0x734];
} Nvff8Typedef, NvVideoFromMemory;
#define NVFF8_TYPEDEF                                    NvVideoFromMemory
/* dma method offsets, fields, and values */
#define NVFF8_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF8_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF8_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF8_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF8_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF8_STOP_TRANSFER(s)                           (0x00000108+8192*(s))
#define NVFF8_STOP_TRANSFER_VALUE                        (0x00000000)
#define NVFF8_SET_PATCH(s)                               (0x0000010C+8192*(s))
#define NVFF8_SET_PATCH_INVALIDATE                       (0x00000000)
#define NVFF8_SET_PATCH_VALIDATE                         (0x00000001)
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF8_SET_CONTEXT_DMA_IMAGE(s,b)                 (0x00000184+8192*(s)+\
                                                                        4*(b))
#define NVFF8_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF8_IMAGE_SCAN(s,b)                            (0x00000300+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_OFFSET(s,b)                     (0x00000300+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_PITCH(s,b)                      (0x00000304+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_SIZE(s,b)                       (0x00000308+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_SIZE_WIDTH                      15:0
#define NVFF8_IMAGE_SCAN_SIZE_HEIGHT                     31:16
#define NVFF8_IMAGE_SCAN_FORMAT(s,b)                     (0x0000030C+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR                    15:0
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8              (0x00000001)
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4                      0x00000001
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8      (0x00000002)
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8                   0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8      (0x00000003)
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8                   0x00000003
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5       (0x00000004)
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2                0x00000004
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5          (0x00000005)
#define NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2                  0x00000005
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8     (0x00000006)
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8                   0x00000006
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD                    31:16
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_PROGRESSIVE        (0x00000001)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_EVEN_FIELD         (0x00000002)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_ODD_FIELD          (0x00000003)
#define NVFF8_IMAGE_SCAN_NOTIFY(s,b)                     (0x00000310+8192*(s)+\
                                                                       20*(b))
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_GET_OFFSET_NOTIFY(s,b)                     (0x00000328+8192*(s)+\
                                                                        4*(b))
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
/* obsolete stuff */
#define nvVideoFromMemory                                NvVideoFromMemory
#define SetImageCtxDma                                   SetContextDmaImage
#define SetImageNotifyCtxDma                             SetContextDmaNotifies


/* class NV_VIDEO_COLORMAP */
#define  NV_VIDEO_COLORMAP                                         (0x00000FF9)
/* NvNotification[] elements */
#define NVFF9_NOTIFIERS_NOTIFY                                     (0)
#define NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY                      (1)
/* NvNotification[] fields and values */
#define NVFF9_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFF9_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 SetContextDmaColormap;   /* NV_CONTEXT_DMA_FROM_MEMORY        0184-0187*/
 V032 Reserved01[0x01e];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x040];
 U032 SetColormapStart;        /* offset in bytes                   0308-030b*/
 U032 SetColormapLength;       /* in bytes                          030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update         0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, starts transfer         0314-0317*/
 V032 Reserved03[0x73a];
} Nvff9Typedef, NvVideoColormap;
#define NVFF9_TYPEDEF                                    NvVideoColormap
/* dma method offsets, fields, and values */
#define NVFF9_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFF9_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFF9_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFF9_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF9_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFF9_SET_CONTEXT_DMA_COLORMAP(s)                (0x00000184+8192*(s))
#define NVFF9_SET_VIDEO_OUTPUT(s)                        (0x00000200+8192*(s))
#define NVFF9_SET_VIDEO_INPUT(s)                         (0x00000204+8192*(s))
#define NVFF9_SET_COLORMAP_START(s)                      (0x00000308+8192*(s))
#define NVFF9_SET_COLORMAP_LENGTH(s)                     (0x0000030C+8192*(s))
#define NVFF9_COLORMAP_DIRTY_START(s)                    (0x00000310+8192*(s))
#define NVFF9_COLORMAP_DIRTY_LENGTH(s)                   (0x00000314+8192*(s))
/* obsolete stuff */
#define nvVideoColormap                                  NvVideoColormap


/* class NV_VIDEO_SINK */
#define  NV_VIDEO_SINK                                             (0x00000FFA)
/* NvNotification[] elements */
#define NVFFA_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFA_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFA_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFA_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoInput[64];       /* NV1_PATCHCORD_VIDEO               0200-02ff*/
 V032 Reserved02[0x740];
} NvffaTypedef, NvVideoSink;
#define NVFFA_TYPEDEF                                    NvVideoSink
/* dma method offsets, fields, and values */
#define NVFFA_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFA_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFA_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFA_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFA_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFA_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFA_SET_VIDEO_INPUT(s,i)                       (0x00000200+8192*(s)+\
                                                                        4*(i))
/* obsolete stuff */
#define nvVideoSink                                      NvVideoSink


/* class NV_PATCHCORD_VIDEO */
#define  NV_PATCHCORD_VIDEO                                        (0x00000FFB)
/* NvNotification[] entries, values, errors, warnings */
#define NVFFB_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} NvffbTypedef, NvPatchcordVideo;
#define NVFFB_TYPEDEF                                    NvPatchcordVideo
/* obsolete stuff */
#define nvPatchcordVideo                                 NvPatchcordVideo


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define  NV_CONTEXT_DMA_IN_MEMORY                                  (0x00000FFC)
/* NvNotification[] elements */
#define NVFFC_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFC_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFC_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFC_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* On X86 address[1] is the selector    0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffcTypedef, NvContextDmaInMemory;
#define NVFFC_TYPEDEF                                    NvContextDmaInMemory
/* dma method offsets, fields, and values */
#define NVFFC_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFC_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFC_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFC_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFC_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFC_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFC_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaInMemory                             NvContextDmaInMemory


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define  NV_CONTEXT_DMA_TO_MEMORY                                  (0x00000FFD)
/* NvNotification[] elements */
#define NVFFD_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFD_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFD_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFD_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffdTypedef, NvContextDmaToMemory;
#define NVFFD_TYPEDEF                                    NvContextDmaToMemory
/* dma method offsets, fields, and values */
#define NVFFD_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFD_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFD_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFD_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFD_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFD_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFD_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaToMemory                             NvContextDmaToMemory


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define  NV_CONTEXT_DMA_FROM_MEMORY                                (0x00000FFE)
/* NvNotification[] elements */
#define NVFFE_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFE_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFE_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFE_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffeTypedef, NvContextDmaFromMemory;
#define NVFFE_TYPEDEF                                    NvContextDmaFromMemory
/* dma method offsets, fields, and values */
#define NVFFE_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFE_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFE_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFE_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFE_SET_DMA_SPECIFIER(s)                       (0x00000300+8192*(s))
/* obsolete stuff */
#define nvContextDmaFromMemory                           NvContextDmaFromMemory


/* class NV_CLASS */
#define  NV_CLASS                                                  (0x00000FFF)
/* NvNotification[] elements */
#define NVFFF_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NVFFF_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NVFFF_NOTIFICATION_STATUS_WARNING_UNAVAILABLE              (0x0002)
#define NVFFF_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFF_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 V032 Create;                  /* 32-bit handle of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit handle of object           0304-0307*/
 V032 Reserved02[0x73e];
} NvfffTypedef, NvClass;
#define NVFFF_TYPEDEF                                    NvClass
/* dma method offsets, fields, and values */
#define NVFFF_SET_OBJECT(s)                              (0x00000000+8192*(s))
#define NVFFF_NO_OPERATION(s)                            (0x00000100+8192*(s))
#define NVFFF_NOTIFY(s)                                  (0x00000104+8192*(s))
#define NVFFF_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFF_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES(s)                (0x00000180+8192*(s))
#define NVFFF_CREATE(s)                                  (0x00000300+8192*(s))
#define NVFFF_DESTROY(s)                                 (0x00000304+8192*(s))
/* obsolete stuff */
#define nvClass                                          NvClass



 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

typedef NvV32 Nv068Typedef;

typedef NvV32 Nv069Typedef;


/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                          (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x003];
#ifdef NV_BIG_ENDIAN
 NvU32 Free;                    /* 32 bit free count, read only     0010-0013*/
 NvU32 Zero;                    /* zeroes, read only                0014-0017*/
#else
 NvU16 Free;                    /* free count, read only            0010-0011*/
 NvU16 Zero[3];                 /* zeroes, read only                0012-0017*/
#endif
 NvV32 Reserved01[0x03A];
} Nv03ControlPio;
typedef volatile struct {
 NvV32 SetObject;               /* handle of current object         0000-0003*/
 Nv03ControlPio control;        /* flow control                     0000-00ff*/
 union {                        /* start of class methods           0100-    */
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv096Typedef NV096_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
/*Nv06dTypedef NV06D_TYPEDEF;*/
/*Nv06eTypedef NV06E_TYPEDEF;*/
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
  Nv088Typedef NV088_TYPEDEF;
  Nv089Typedef NV089_TYPEDEF;
  Nv093Typedef NV093_TYPEDEF;
  Nv094Typedef NV094_TYPEDEF;
  Nv095Typedef NV095_TYPEDEF;
  Nvff0Typedef NVFF0_TYPEDEF;
  Nvff1Typedef NVFF1_TYPEDEF;
  Nvff2Typedef NVFF2_TYPEDEF;
  Nvff3Typedef NVFF3_TYPEDEF;
  Nvff4Typedef NVFF4_TYPEDEF;
  Nvff5Typedef NVFF5_TYPEDEF;
  Nvff6Typedef NVFF6_TYPEDEF;
  Nvff7Typedef NVFF7_TYPEDEF;
  Nvff8Typedef NVFF8_TYPEDEF;
  Nvff9Typedef NVFF9_TYPEDEF;
  NvffaTypedef NVFFA_TYPEDEF;
  NvffbTypedef NVFFB_TYPEDEF;
  NvffcTypedef NVFFC_TYPEDEF;
  NvffdTypedef NVFFD_TYPEDEF;
  NvffeTypedef NVFFE_TYPEDEF;
  NvfffTypedef NVFFF_TYPEDEF;
#ifdef __GNUC__         /* anon union does not work on GCC */
 }  cls   ;         /* end of class methods                  -1fff*/
#else  /* __GNUC__ */
 }  /* cls */  ;    /* end of class methods                  -1fff*/
#endif /* __GNUC__ */

} Nv03SubchannelPio;
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                                 (0x007C)
#define NV06A_FIFO_EMPTY                                           (0x007C)
#define NV06A_FIFO_FULL                                            (0x0000)
/* obsolete stuff */
#define NV3_CHANNEL_PIO                                            (0x0000006A)
#define Nv3ControlPio                                            Nv03ControlPio
#define Nv3SubchannelPio                                      Nv03SubchannelPio
#define Nv3ChannelPio                                            Nv03ChannelPio
#define NvChannel                                                Nv03ChannelPio
#define nv03ChannelPio                                           Nv03ChannelPio


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                          (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define NV06B_TYPEDEF                                            Nv03ChannelDma
#define nv03ChannelDma                                           Nv03ChannelDma


/* class NV04_CHANNEL_PIO */
#define  NV04_CHANNEL_PIO                                          (0x0000006D)
/* NvNotification[] fields and values */
#define NV06D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06D_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x003];
#ifdef NV_BIG_ENDIAN
 NvU32 Free;                    /* 32 bit free count, read only     0010-0013*/
 NvU32 Zero;                    /* zeroes, read only                0014-0017*/
#else
 NvU16 Free;                    /* free count, read only            0010-0011*/
 NvU16 Zero[3];                 /* zeroes, read only                0012-0017*/
#endif
 NvV32 Reserved01[0x03A];
} Nv04ControlPio;
typedef volatile struct {
 NvV32 SetObject;               /* handle of current object         0000-0003*/
 Nv04ControlPio control;        /* flow control                     0000-00ff*/
 union {                        /* start of class methods           0100-    */
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv096Typedef NV096_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
/*Nv06dTypedef NV06D_TYPEDEF;*/
/*Nv06eTypedef NV06E_TYPEDEF;*/
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
  Nv088Typedef NV088_TYPEDEF;
  Nv089Typedef NV089_TYPEDEF;
  Nv093Typedef NV093_TYPEDEF;
  Nv094Typedef NV094_TYPEDEF;
  Nv095Typedef NV095_TYPEDEF;
  Nv097Typedef NV097_TYPEDEF;
  Nv1189Typedef NV1189_TYPEDEF;
  Nv205fTypedef NV205F_TYPEDEF;
  Nvff0Typedef NVFF0_TYPEDEF;
  Nvff1Typedef NVFF1_TYPEDEF;
  Nvff2Typedef NVFF2_TYPEDEF;
  Nvff3Typedef NVFF3_TYPEDEF;
  Nvff4Typedef NVFF4_TYPEDEF;
  Nvff5Typedef NVFF5_TYPEDEF;
  Nvff6Typedef NVFF6_TYPEDEF;
  Nvff7Typedef NVFF7_TYPEDEF;
  Nvff8Typedef NVFF8_TYPEDEF;
  Nvff9Typedef NVFF9_TYPEDEF;
  NvffaTypedef NVFFA_TYPEDEF;
  NvffbTypedef NVFFB_TYPEDEF;
  NvffcTypedef NVFFC_TYPEDEF;
  NvffdTypedef NVFFD_TYPEDEF;
  NvffeTypedef NVFFE_TYPEDEF;
  NvfffTypedef NVFFF_TYPEDEF;
#ifdef __GNUC__         /* anon union does not work on GCC */
 }  cls   ;         /* end of class methods                  -1fff*/
#else  /* __GNUC__ */
 }  /* cls */  ;    /* end of class methods                  -1fff*/
#endif /* __GNUC__ */
} Nv04SubchannelPio;
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv04SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv04ChannelPio;              /* end of array of subchannels           -ffff*/
/* fields and values */
#define NV06D_FIFO_GUARANTEED_SIZE                                 (0x0200)
#define NV06D_FIFO_EMPTY                                           (0x0200)
#define NV06D_FIFO_FULL                                            (0x0000)


/* class NV04_CHANNEL_DMA */
#define  NV04_CHANNEL_DMA                                          (0x0000006C)
/* NvNotification[] fields and values */
#define NV06C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06cTypedef, Nv04ChannelDma;
#define NV06C_TYPEDEF                                            Nv04ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only            0040-0043*/
 NvU32 Get;                     /* get offset, read only             0044-0047*/
 NvV32 Ignored01[0x002];
 NvU32 StallNotifier;           /* Set stall notifier                0050-0053*/
 NvU32 StallChannel;            /* Stall the channel                 0054-0057*/
 NvV32 Ignored02[0x7EA];
} Nv04ControlDma;
/* obsolete stuff */
#define NV4_CHANNEL_DMA                                            (0x0000006C)
#define Nv4ChannelDma                                            Nv04ChannelDma
#define nv4ChannelDma                                            Nv04ChannelDma
#define Nv4ControlDma                                            Nv04ControlDma


/* class NV10_CHANNEL_DMA */
#define  NV10_CHANNEL_DMA                                          (0x0000006E)
/* NvNotification[] fields and values */
#define NV06E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv06eTypedef, Nv10ChannelDma;
#define NV06E_TYPEDEF                                            Nv10ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv06eControl, Nv10ControlDma;
/* fields and values */
#define NV06E_NUMBER_OF_SUBCHANNELS                                (8)
#define NV06E_SET_OBJECT                                           (0x00000000)
#define NV06E_SET_REFERENCE                                        (0x00000050)

/* class NV20_CHANNEL_DMA */
#define  NV20_CHANNEL_DMA                                          (0x0000206E)
/* NvNotification[] fields and values */
#define NV206E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT              (0x2000)
#define NV206E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT          (0x4000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv206eTypedef, Nv20ChannelDma;
#define NV206E_TYPEDEF                                           Nv20ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv206eControl, Nv20ControlDma;
/* fields and values */
#define NV206E_NUMBER_OF_SUBCHANNELS                               (8)
#define NV206E_SET_OBJECT                                          (0x00000000)
#define NV206E_SET_REFERENCE                                       (0x00000050)
#define NV206E_SET_CONTEXT_DMA_SEMAPHORE                           (0x00000060)
#define NV206E_SEMAPHORE_OFFSET                                    (0x00000064)
#define NV206E_SEMAPHORE_ACQUIRE                                   (0x00000068)
#define NV206E_SEMAPHORE_RELEASE                                   (0x0000006c)


 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                                         (0x00000000)
/* obsolete stuff */
#define NV1_NULL_OBJECT                                            (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS.
 * NV fills in the NvNotification[] data structure in the following order:
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  NvU32 nanoseconds[2];        /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 NvV32 info32;                 /* info returned depends on method   0008-000b*/
 NvV16 info16;                 /* info returned depends on method   000c-000d*/
 NvV16 status;                 /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */

 /***************************************************************************\
|*                          NvGraphicsState                                  *|
 \***************************************************************************/
/***** NvGraphicsState Structure *****/
/*
 * This represents the state structure that's passed between the Celsius
 * GetState method and the RM (in nv10 and eventually the HW). The context
 * DMA passed to NV056_SET_CONTEXT_DMA_STATE should be at least this size.
 */

typedef volatile struct {
    struct _PerFragmentState {
        // *** dword 0
        NvU32          pad0 : 8;
        NvU32     alphaFunc : 4;
        NvU32          pad1 : 4;
        NvU32     depthFunc : 4;
        NvU32          pad2 : 4;
        NvU32     depthMask : 1;
        NvU32          pad3 : 1;
        NvU32     alphaMask : 1;
        NvU32       redMask : 1;
        NvU32     greenMask : 1;
        NvU32      blueMask : 1;
        NvU32          pad4 : 2;
        // *** dword 1
        NvU32          pad5 : 4;
        NvU32   stencilFunc : 4;
        NvU32    stencilRef : 8;
        NvU32          pad6 : 8;
        NvU32   stencilMask : 8;
        // *** dword 2
        NvU32       sfailOp : 4;
        NvU32       zfailOp : 4;
        NvU32       zpassOp : 4;
        NvU32         pad7 : 20;
        // *** dword 3
        NvU32 blendEquation : 3;
        NvU32          pad8 : 1;
        NvU32      srcBlend : 4;
        NvU32     destBlend : 4;
        NvU32         pad9 : 20;
    } PerFragmentState;
    struct _PerVertexState {
        NvF32           pad0[4];
        NvF32   primaryColor[4];
        NvF32 secondaryColor[3];
        NvF32          fogCoord;
        NvF32    texCoord[2][4];
        NvF32         normal[3];
        NvF32              pad1;
        NvF32      vertexWeight;
        NvU32           pad2[7];
        NvU32              pad3;
        NvU32      edgeFlag : 8;
        NvU32         pad4 : 24;
        NvU32           pad5[2];
    } PerVertexState;
    struct _VertexArrayState {
        NvU32      vertexOffset;
        NvU32      vertexFormat;
        NvU32     diffuseOffset;
        NvU32     diffuseFormat;
        NvU32    specularOffset;
        NvU32    specularFormat;
        NvU32   texCoord0Offset;
        NvU32   texCoord0Format;
        NvU32   texCoord1Offset;
        NvU32   texCoord1Format;
        NvU32      normalOffset;
        NvU32      normalFormat;
        NvU32      weightOffset;
        NvU32      weightFormat;
        NvU32         fogOffset;
        NvU32         fogFormat;
    } VertexArrayState;
    struct _PrimitiveAssmState {
        NvU32    primAssm[3*16];
    } PrimitiveAssmState;
} NvGraphicsState;

 /***************************************************************************\
|*                          Object Allocation Parameters                     *|
 \***************************************************************************/

// class 0x07c creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV07C_ALLOCATION_PARAMETERS;

// class 0x07a creation parameters
typedef struct
{
    NvU32   version;
    NvP64   pInfo;
    NvU32   logicalHeadId;

} NV07A_ALLOCATION_PARAMETERS;

 /***************************************************************************\
|*                          NVIDIA Debug Extensions                         *|
 \***************************************************************************/

/*
 * These class numbers are a temporary hack to allow the debugger
 * client to use the NvAlloc interface to access debugger services.
 */
#define  NVDE_REGISTER_DEBUGGER                                    (0xDE000001)
#define  NVDE_UNREGISTER_DEBUGGER                                  (0xDE000002)
#define  NVDE_READ_MEMORY                                          (0xDE000003)
#define  NVDE_WRITE_MEMORY                                         (0xDE000004)
#define  NVDE_GET_EVENT_INFORMATION                                (0xDE000005)
#define  NVDE_TEST                                                 (0xDE00ffff)

#define NVDE_DEBUGGER                                              (0xDE000000)

/*
 * Status codes.
 */
#define NVDE_STATUS_SUCCESS                                         (0x0000)
#define NVDE_STATUS_ERROR_STATE_IN_USE                              (0x0001)
#define NVDE_STATUS_ERROR_BAD_ARGUMENT                              (0x0002)

/*
 * Class-specific parameter blocks.
 */
typedef struct
{
    NvU64 EventHandle;
    NvU32 EventClass;
} NVDE_ALLOCATION_PARAMETERS;

// must be replaced by NVDE class
typedef struct
{
    NvU32 TrapEvent;
} NVDE_REGISTER_DEBUGGER_PARAMETERS;

// must be replaced by NVDE class
typedef struct
{
    NvU32 foo;
} NVDE_UNREGISTER_DEBUGGER_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 Address;
    NvU32 Size;
    NvU32 Data;
} NVDE_READ_MEMORY_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 Address;
    NvU32 Size;
    NvU32 Data;
} NVDE_WRITE_MEMORY_PARAMETERS;

// depreciated
typedef struct
{
    NvU32 CallBackAddress;
} NVDE_TEST_PARAMETERS;

typedef NvU32 (*NVDE_TEST_FUNC)();

// must be moved to NVDE class
typedef struct
{
    U032 Count;
    U032 Event[32][8];
} NVDE_GET_EVENT_INFORMATION_PARAMETERS;

/* class NV01_DEVICE_AUDIO */
#define  NV01_DEVICE_AUDIO                                         (0x000000A0)
/* NvNotification[] fields and values */
#define NV0A0_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A0_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A0_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0A0Typedef, Nv01DeviceAudio;
#define  NV0A0_TYPEDEF                                             Nv01DeviceAudio

#define NV01_CONTEXT_DMA_AUDIO                                      (0x000000A1)
/* NvNotification[] fields and values */
#define NV0A1_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A1_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A1_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

#define NV1B_AUDIO_OBJECT                                           (0x000000A2)
/* NvNotification[] fields and values */
#define NV0A2_NOTIFICATION_STATUS_NOT_IMPLEMENTED                   (0x0000)
#define NV0A2_NOTIFICATION_STATUS_REQUESTED                         (0x0001)
#define NV0A2_NOTIFICATION_STATUS_METHOD_UNKNOWN                    (0x0002)
#define NV0A2_NOTIFICATION_STATUS_BAD_ARGUMENT                      (0x2000)
#define NV0A2_NOTIFICATION_STATUS_CURRENT_NOT_SET                   (0x0004)
#define NV0A2_NOTIFICATION_STATUS_ANTECEDENT_NOT_SET                (0x0005)
#define NV0A2_NOTIFICATION_STATUS_VOICE_ACTIVE                      (0x0006)
#define NV0A2_NOTIFICATION_STATUS_NOT_DATA_TYPE_BUFFER              (0x0007)

/* class NV01_DEVICE_EXTERNAL_CODEC */
#define  NV01_DEVICE_EXTERNAL_CODEC                                 (0x000000A3)
/* NvNotification[] fields and values */
#define NV0A0_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A0_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A0_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A0_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 Reserved00[0x7c0];
} Nv0A3Typedef, Nv03DeviceExternalCodec;
#define  NV0A3_TYPEDEF                                             Nv01DeviceCodec

#define NV01_CONTEXT_DMA_EXTERNAL_CODEC                             (0x000000A4)
/* NvNotification[] fields and values */
#define NV0A1_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV0A1_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV0A1_NOTIFICATION_STATUS_INSUFFICIENT_BANDWIDTH           (0x0400)
#define NV0A1_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

#define NV01_EXTERNAL_CODEC_OBJECT                                  (0x000000A5)
/* NvNotification[] fields and values */
#define NV0A2_NOTIFICATION_STATUS_NOT_IMPLEMENTED                   (0x0000)
#define NV0A2_NOTIFICATION_STATUS_REQUESTED                         (0x0001)
#define NV0A2_NOTIFICATION_STATUS_METHOD_UNKNOWN                    (0x0002)
#define NV0A2_NOTIFICATION_STATUS_BAD_ARGUMENT                      (0x2000)
#define NV0A2_NOTIFICATION_STATUS_CURRENT_NOT_SET                   (0x0004)
#define NV0A2_NOTIFICATION_STATUS_ANTECEDENT_NOT_SET                (0x0005)
#define NV0A2_NOTIFICATION_STATUS_VOICE_ACTIVE                      (0x0006)
#define NV0A2_NOTIFICATION_STATUS_NOT_DATA_TYPE_BUFFER              (0x0007)

#define NV01_EXTERNAL_CODEC_WRITE                                   (0x000000A6)
// define the errors here later
#define NV01_EXTERNAL_CODEC_READ                                    (0x000000A7)
// define the errors here later

// this IOCTL manages system memory for the client - see AUDIO_ALLOC_MEMORY / AUDIO_FREE_MEMORY
#define NV01_MEMORY_AUDIO		                                    (0x000000A8)

// class 0x0A1 creation params (NV01_CONTEXT_DMA_AUDIO)

typedef union
{
	struct
	{
		NvU32 : 32;
	}codec;

	struct
	{
		NvU32  : 27;
		// interrupts originating from FE/SE
		NvU32 FEMethodOverFlow : 1;	// user method fifo has been overwritten
		NvU32 FEVoice : 1;			// end-of-buffer / end-of-stream
		NvU32 FENotify : 1;			// notifier originating from the FE has been written
		NvU32 DeltaPanic : 1;		// delta panic
		NvU32 DeltaWarning : 1;		// delta warning
	}apu;
	
	NvU32 uValue;					// set to ~0x0 (for codec) if the ISR fn is to be called regardless
} INTR_MASK;

typedef void (*PISRCALLBACK)(NvV32,	/* service context*/ 
							NvU32,	/* interrupt mask (INTR_MASK.uValue) with bits of triggered intr set */
							NvV32);	/* info based on reason */

typedef struct
{
	NvV32			pResList;		/*	address of resource structure	*/
	NvU8			uRevisionID;	/*	HW Revision ID of the chip - byte 0x8 in the PCI config */
	NvV32			pDevObj;		/*	address of device object		*/		
	PISRCALLBACK	pISRFn;			/*	address to an optional ISR		*/
	NvV32			pServiceContext;/*	service context for the ISR		*/
	INTR_MASK		IntrMask;		/*	set the bits for which pISRFn needs to be called	*/
	NvU32			uDeviceRef;		/*	device reference				*/
} AUDIO_INIT_DEVICE;

/*
Arguments:
		IN pResourceList - 	of type PCM_RESOURCE_LIST (WDM) - translated resource list got in IRP_MN_START_DEVICE
				of type CM_CONFIG (Win9X VxD)
				of type PCI_COMMON_CONFIG (NT4)
				TBD for linux.
	 	IN pDeviceObject - only valid in NT and WDM, ignored in Win9X VxD
		IN pISRFn (optional) - not recommended unless it is absolutely necessary.  
								The driver can install it to handle interrupts from the codec if it needs to.  
								Type - void pISRFn(U032 ServiceContext);
		IN uServiceContext (optional) - value passed back to the pISRFn if installed.
		OUT pDeviceRef	- device ref returned by the RM
*/


// defines the "type" for context DMA
#define AUDIO_CONTEXT_DMA_SESGE         0x1
#define AUDIO_CONTEXT_DMA_SESSL         0x2
#define AUDIO_CONTEXT_DMA_GPSGE         0x3
#define AUDIO_CONTEXT_DMA_FENOTIFIER    0x4
#define AUDIO_CONTEXT_DMA_EPSGE         0x5

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU8	uType;              // one of the values defined above
	NvU32	uBaseAddress;       // base address for the type. (must be 4K aligned)
	NvU32	uMaxOffset;         // max offset for the type. (must be 4K aligned)
	NvU32	uHandle;            // OUT: handle of the context DMA
} APU_AP_ALLOC_CONTEXT_DMA;

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU32	uHandle;            // handle of the context DMA
} APU_AP_FREE_CONTEXT_DMA;


#define GSCNT_FREE_RUNNING          0 
#define GSCNT_ACSYNC                1   /* updated for every AC_SYNC pulse (48KHz) */
#define GSCNT_SW                    2   /* client will update it */

// class 0x0A2 creation parameters (NV1B_AUDIO_PROCESSOR)
typedef union
{
    struct
    {	
        NvU32       : 29;
        NvU32 GSCNT : 2;        // see values defined above
        NvU32 ISO   : 1;        // set if ISO (takes care of all ISO flags in the HW)
    }fields;
    
    NvU32 uValue;
} APU_AP_FLAGS;

typedef struct 
{
    NvV32           pObjectDmaBuffer;           // in buffer for global effects dma commands.
    NvV32           pObjectNotifiesBuffer;      // in buffer for voice notifies
    NvV32           pObjectGlobalNotifiesBuffer; // in buffer for global notifies
    APU_AP_FLAGS    flags; 
    VOID_PTR        pioBase; 
    NvU32           limitFifo; 
    NvU32           limitBandwidth; 
    NvU32           limitBlockClock; 
    NvU32           overhead; 
    
    NvU32           uVoiceCount;        // in/out req # of voices , return #
    NvU32           uVoice3dCount;      // in/out req # of 3d voices , return #
    NvU32           uHRTFCount;         // in/out req # of HRTFs, return #
    NvU32           uSubmixCount;       // in/out req # of Submixes, return #
    NvU32           uSegInCount;        // in/out req # of segments for input, return #
    NvU32           uSGEInCount;        // in/out req # of 4K SGE for input, return #
    NvU32           uSGEOutCount;       // in/out req # of 4K SGE for output, return #
    NvU32           uGPScratch;         // in/out reg # of PRDs for GP scratch memory
    
    // global sample count values - ignored if GSCNT = GSCNT_FREE_RUNNING
    NvU32           uExternalGSCNT;     // in updated according to the GSCNT flag above
    NvU32           uInternalGSCNT;     // in updated by HW, by frame_size everytime output is made to sys mem
    NvU32           uDeltaGSCNT;        // in if (uInternalGSCNT - uExternalGSCNT) < uDeltaGSCNT, HW renders
    
    VOID_PTR        pVoiceList;         // out (DEBUG ONLY) - linear address of the voice structure
}APU_AP_CREATE;


typedef struct
{
    VOID_PTR        pioBase;

    NvU32           uSGEOutCount;       // in/out req # of 4K SGE for output, return #
    NvU32           uScratch;           // in/out reg # of PRDs for EP scratch memory

    // global sample counts applied only to teh EP
    NvU32           uInternalGSCNT;     // in updated by HW, by frame_size everytime output is made to sys mem
    NvU32           uDeltaGSCNT;        // in if (uInternalGSCNT - APU_AP_CREATE::uExternalGSCNT) < uDeltaGSCNT, HW renders
    NvU32           uStepSize;          // in step size added to uInternalGSCNT each frame

} APU_EP_CREATE;

typedef APU_AP_CREATE NV0A2_ALLOCATION_PARAMETERS;

// NV01_EXTERNAL_CODEC_OBJECT

// class 0x0A5 creation parameters (NV01_EXTERNAL_CODEC_OBJECT)
typedef struct
{
	VOID_PTR	pioBaseMixer;
	VOID_PTR	pioBaseAci;
} CODEC_AUDIO_CREATE;

// the object alloc structure is used, both for codec and APU object allocation
// uObjectCode codes
#define	AUDIO_OBJECT_AP					0x1
#define AUDIO_OBJECT_EP					0x2
#define CODEC_OBJECT_AUDIO				0x3
#define CODEC_OBJECT_MODEM				0x4		/* not supported */

typedef struct
{
	NvU32	uDeviceRef;         // device reference
	NvU8	uObjectCode;
	NvV32	pParam;	
} APU_OBJECT;

#define CODEC_ACCESS_08				1
#define CODEC_ACCESS_16				2
#define CODEC_ACCESS_32				4

// alloc params for NV01_EXTERNAL_CODEC_READ & NV01_EXTERNAL_CODEC_WRITE
typedef struct
{
	NvU32	    uDeviceRef;	            // device reference
	VOID_PTR	BaseAddr;               // base address for which read/write is made
	NvU32	    Offset;                 // offset from the base address for which access is to be made
	NvV32	    AccessType;             // hardware access type
	/*
	for BYTE reads/writes	ValidBytes = CODEC_ACCESS_08 valid Val field = u8
	for WORD reads/writes	ValidBytes = CODEC_ACCESS_16 valid Val field = u16
	for DWORD reads/writes	ValidBytes = CODEC_ACCESS_32 valid Val Field = u32
	any other value for ValidBytes is illegal
	*/
	union
	{
		NvU8	u8;
		NvU16	u16;
		NvU32	u32;
	}Val;
}CODEC_ACCESS_PARAMS;


// 0xA8 memory management paramters

#define MEM_ALIGN_4K					0x00000000
#define MEM_ALIGN_8K					0x00000001		
#define MEM_ALIGN_16K					0x00000003
#define MEM_ALIGN_32K					0x00000007
#define MEM_ALIGN_64K					0x0000000F
#define MEM_ALIGN_128K					0x0000001F
#define MEM_ALIGN_DONT_CARE				0xFFFFFFFF

// for allocation use:
typedef struct
{
	NvU32       uSize;          // IN:	size of memory to be allocated in bytes
	NvU32       uAlignMask;     // IN:	alignment mask to get physically contiguous memory
                                // use ALIGN_DONT_CARE if it need not be aligned and physically contiguous
	VOID_PTR    pLinearAddress; // OUT: linear address of allocated memory (NULL on failure)
} AUDIO_ALLOC_MEMORY;

// for freeing memory use:
typedef struct
{
	VOID_PTR    pLinearAddress; // IN: linear address of allocated memory
} AUDIO_FREE_MEMORY;

#ifdef __cplusplus
};          // extern "C" {
#endif

#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvRmR0Api.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * NvRmR0Api.h
 *
 * NVidia resource manager API header file exported to drivers which are operating in Ring0
 *
 */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

// NOTE NOTE NOTE
// Those functions which are commented out are not yet implemented for the Ring0 interface

//HANDLE __stdcall NvRmR0Open(VOID);
//VOID   __stdcall NvRmR0Close(VOID);
ULONG  __stdcall NvRmR0AllocRoot(ULONG *phClient);
ULONG  __stdcall NvRmR0AllocDevice(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  __stdcall NvRmR0AllocContextDma(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  __stdcall NvRmR0AllocChannelPio(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG  __stdcall NvRmR0AllocChannelDma(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  __stdcall NvRmR0AllocMemory(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  __stdcall NvRmR0AllocObject(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  __stdcall NvRmR0Alloc(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  __stdcall NvRmR0Free(ULONG hClient, ULONG hParent, ULONG hObject);
//ULONG  __stdcall Nv3RmR0GetDmaPushInfo(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG  __stdcall NvRmR0AllocEvent(ULONG hClient, ULONG hParent, ULONG object, ULONG hClass, ULONG hIndex, PVOID hEvent);
//ULONG  __stdcall NvRmR0ConfigVersion(ULONG hClient, ULONG hDevice, ULONG *pVersion);
//ULONG  __stdcall NvRmR0ConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
//ULONG  __stdcall NvRmR0ConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
//ULONG  __stdcall NvRmR0ConfigUpdate(ULONG hClient, ULONG hDevice, ULONG flags);
ULONG  __stdcall NvRmR0Interrupt(ULONG hClient, ULONG hDevice);
ULONG  __stdcall NvRmR0I2CAccess(ULONG hClient, ULONG hDevice, VOID* pCtrlStruct );

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\Nvcm.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVCM.H                                                            *
*   Windows Configuration Manager defines and prototypes.                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
*                                                                           *
\***************************************************************************/
#ifndef _NVCM_H_
#define _NVCM_H_

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------------
//
//  Configuration Defines.
//
//---------------------------------------------------------------------------
#pragma pack(1) // assure byte alignment on structures shared among modules

//
// Index parameters to ConfigGet/Set.  All other values are reserved.
//

//
// NV_CFG_MANUFACTURER - Return the manufacturer of this device
//
//  0 - NVIDIA Corporation
//  (all other values are reserved)
//
#define NV_CFG_MANUFACTURER                     1

//
// NV_CFG_ARCHITECTURE - Return the architecture of this device
//
//  0 - NV0
//  1 - NV1, etc
//
#define NV_CFG_ARCHITECTURE                     2

//
// NV_CFG_REVISION - Return the major revision of this device
//
//  0 - RevA
//  1 - RevB, etc
//
#define NV_CFG_REVISION                         3

/*
** NV_CFG_BIOS_REVISION - Return the current revision of this device's BIOS
**
**  MMNNRRRR - MM   Major Revision
**             NN   Minor Revision
**             RRRR Release Revision
*/
#define NV_CFG_BIOS_REVISION                    4

//
// NV_CFG_BUS_TYPE - Return the bus implementation of this device
//
//  1 - PCI
//  2 - VL
//  4 - AGP
//  All other values are reserved
//
#define NV_CFG_BUS_TYPE                         5

//
// NV_CFG_CRYSTAL_FREQ - Return the PLL crystal frequency of this device
//
//  Value returned in Hz
//
#define NV_CFG_CRYSTAL_FREQ                     6

//
// NV_CFG_BIOS_OEM_REVISION - Return the current OEM revision of this
//                            device's BIOS
//
#define NV_CFG_BIOS_OEM_REVISION                7

//
// NV_CFG_IMPLEMENTATION - Return the implementation of a chip architecture.
//
#define NV_CFG_IMPLEMENTATION                   8

// When ARCHITECTURE is 0x4, IMPLEMENTATIION is:
#define NV_CFG_IMPLEMENTATION_NV04      0x0
#define NV_CFG_IMPLEMENTATION_NV05      0x1
#define NV_CFG_IMPLEMENTATION_NV0A      0x2
// When ARCHITECTURE is 0x10, IMPLEMENTATIION is:
#define NV_CFG_IMPLEMENTATION_NV10      0x0
#define NV_CFG_IMPLEMENTATION_NV15      0x5
#define NV_CFG_IMPLEMENTATION_NV11      0x1

//
// NV_CFG_ADDRESS_NVADDR - Return the linear address of (BAR0) of this device
//
#define NV_CFG_ADDRESS_NVADDR                   9

//
// NV_CFG_ADDRESS - Return the physical PCI address (BAR0) of this device
//
#define NV_CFG_ADDRESS                          10

//
// NV_CFG_IRQ - Return the PCI IRQ assigned to this device
//
#define NV_CFG_IRQ                              11

//
// NV_CFG_IO_NEEDED - Return the detection flag for chipsets that have broken
//                    PCI snoop mastering.
//
#define NV_CFG_IO_NEEDED                        12

//
// NV_CFG_PCI_ID - Return the PCI Vendor and Device ID assigned to this device
//
//      DDDDVVVV -  VVVV    PCI Vendor ID
//                  DDDD    PCI Device ID
//
#define NV_CFG_PCI_ID                           13

//
// NV_CFG_PCI_SUB_ID - Return the PCI Subsystem Vendor and Device ID assigned to this device
//
//      DDDDVVVV -  VVVV    PCI Subsystem Vendor ID
//                  DDDD    PCI Subsystem ID
//
#define NV_CFG_PCI_SUB_ID                       14

//
// NV_CFG_PROCESSOR_TYPE - Return the functionality of the system processor
//
// There are 2 pieces of data passed back, the processor indicator is in
// the low 8 bits and its bitmask of functionality is in the upper 24
//
#define NV_CPU_UNKNOWN         0x00000000    // Unknown / generic
// Intel
#define NV_CPU_P5              0x00000001
#define NV_CPU_P55             0x00000002    // P55C - MMX
#define NV_CPU_P6              0x00000003    // PPro
#define NV_CPU_P2              0x00000004    // PentiumII
#define NV_CPU_P2XC            0x00000005    // Xeon & Celeron
#define NV_CPU_CELA            0x00000006    // Celeron-A
#define NV_CPU_P3              0x00000007    // Pentium-III
#define NV_CPU_P3_INTL2        0x00000008    // Pentium-III w/ integrated L2 (fullspeed, on die, 256K)
// AMD
#define NV_CPU_K5              0x00000030
#define NV_CPU_K6              0x00000031
#define NV_CPU_K62             0x00000032    // K6-2 w/ 3DNow
#define NV_CPU_K63             0x00000033
#define NV_CPU_K7              0x00000034
// IDT/Centaur
#define NV_CPU_C6              0x00000060    // WinChip C6
#define NV_CPU_C62             0x00000061    // WinChip 2 w/ 3DNow
// Cyrix
#define NV_CPU_GX              0x00000070    // MediaGX
#define NV_CPU_M1              0x00000071    // 6x86
#define NV_CPU_M2              0x00000072    // M2
#define NV_CPU_MGX             0x00000073    // MediaGX w/ MMX
// PowerPC
#define NV_CPU_PPC603          0x00000090    // PowerPC 603
#define NV_CPU_PPC604          0x00000091    // PowerPC 604
#define NV_CPU_PPC750          0x00000092    // PowerPC 750

// Function bits
#define NV_CPU_FUNC_MMX        0x00000100    // supports MMX
#define NV_CPU_FUNC_SSE        0x00000200    // supports SSE
#define NV_CPU_FUNC_3DNOW      0x00000400    // supports 3DNow
#define NV_CPU_FUNC_SSE2       0x00000800    // supports SSE2
#define NV_CPU_FUNC_SFENCE     0x00001000    // supports SFENCE

#define NV_CFG_PROCESSOR_TYPE                   15

//
// NV_CFG_PROCESSOR_SPEED - Return the speed of the processor in MHz
//
#define NV_CFG_PROCESSOR_SPEED                  16

//
// NV_CFG_GRAPHICS_CAPS - Return the capabilities of the graphics HW
//
#define NV_CFG_GRAPHICS_CAPS                    18

#define NV_CFG_GRAPHICS_CAPS_UNKNOWN            0x00000000
#define NV_CFG_GRAPHICS_CAPS_MAXCLIPS_MASK      0x000000FF  // bits 7:0
#define NV_CFG_GRAPHICS_CAPS_MAXCLIPS_SHIFT     0
#define NV_CFG_GRAPHICS_CAPS_AA_LINES           0x00000100  // bit  8
#define NV_CFG_GRAPHICS_CAPS_AA_POLYS           0x00000200  // bit  9
#define NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP     0x00000400  // bit 10
#define NV_CFG_GRAPHICS_CAPS_LOGIC_OPS          0x00000800  // bit 11
#define NV_CFG_GRAPHICS_CAPS_NV15_ALINES        0x00001000  // bit 12
#define NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING    0x00002000  // bit 13
#define NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC     0x00004000  // bit 14

//
// NV_CFG_INSTANCE_SIZE - Return the size of the instance pool of this device
//
#define NV_CFG_INSTANCE_SIZE                    20

//
// NV_CFG_INSTANCE_SIZE - Return the size of the instance pool of this device
//
#define NV_CFG_INSTANCE_TOTAL                   21

//
// NV_CFG_FIFO_COUNT - Return the number of user fifos allowed in this device
//
#define NV_CFG_FIFO_COUNT                       32

//
// NV_CFG_FIFO_USE_COUNT - Return the number of fifos used in this device
//
#define NV_CFG_FIFO_USE_COUNT                   33

//
// NV_CFG_RAM_SIZE_MB - Return the video memory size (in MB) of this device
//
#define NV_CFG_RAM_SIZE_MB                      40

//
// NV_CFG_RAM_SIZE - Return the video memory size (in bytes) of this device
//
#define NV_CFG_RAM_SIZE                         41

//
// NV_CFG_RAM_TYPE - Return the video memory type of this device
//
//  0 - DRAM (EDO/FPM)
//  1 - SGRAM
//  2 - SDRAM
//  3 - DDR-RAM
//  All other values are reserved
//
#define NV_CFG_RAM_TYPE                         42

#define NV_CFG_RAM_TYPE_DRAM          0
#define NV_CFG_RAM_TYPE_SGRAM         1
#define NV_CFG_RAM_TYPE_SDRAM         2
#define NV_CFG_RAM_TYPE_DDRRAM        3


//
// NV_CFG_AGP_FULLSPEED_FW - Return if AGP Fast Writes are fullspeed
//
#define NV_CFG_AGP_FULLSPEED_FW                 43

//
// NV_CFG_AGP_PHYS_BASE - Return/Set the current physical GART address
//
#define NV_CFG_AGP_PHYS_BASE                    44

//
// NV_CFG_AGP_LINEAR_BASE - Return/Set the current linear GART address
//
#define NV_CFG_AGP_LINEAR_BASE                  45

//
// NV_CFG_AGP_LIMIT - Return/Set the current GART size
//
#define NV_CFG_AGP_LIMIT                        46

//
// NV_CFG_AGP_FW_ENABLE - Return if AGP Fast Writes are enabled
//
#define NV_CFG_AGP_FW_ENABLE                    47

//
// NV_CFG_AGP_HEAP_FREE - Return the amount of free AGP memory
//
#define NV_CFG_AGP_HEAP_FREE                    48

// XXX this isn't be used
#define NV_CFG_AGP_LOAD_DUMMY_PAGES             49

//
// NV_CFG_SCREEN_WIDTH - Return/Set the current display horizontal resolution
//
//  Value defined in pixels
//
// NOTE: Updates to this value will not take affect until NvConfigUpdate().
// This allows batching with other screen size parameters.
//
#define NV_CFG_SCREEN_WIDTH                     50

//
// NV_CFG_SCREEN_HEIGHT - Return/Set the current display vertical resolution
//
//  Value defined in pixels
//
// NOTE: Updates to this value will not take affect until NvConfigUpdate().
// This allows batching with other screen size parameters.
//
#define NV_CFG_SCREEN_HEIGHT                    51

//
// NV_CFG_PIXEL_DEPTH - Return/Set the current display pixel depth
//
//  Value defined in bits per pixel
//
// NOTE: Updates to this value will not take affect until NvConfigUpdate().
// This allows batching with other screen size parameters.
//
#define NV_CFG_PIXEL_DEPTH                      52

//
// NV_CFG_SCREEN_MAX_WIDTH - Returns the maximum horizontal resolution supported by the display type.
//
//  Value defined in pixels
//
#define NV_CFG_SCREEN_MAX_WIDTH                 53

//
// NV_CFG_SCREEN_MAX_HEIGHT - Returns the maximum vertical resolution supported by the display type.
//
//  Value defined in pixels
//
#define NV_CFG_SCREEN_MAX_HEIGHT                54

//
// NV_CFG_VIDEO_ENCODER_TYPE - Return the external video decoder being used by this device
//
#define NV_CFG_VIDEO_ENCODER_TYPE               55

#define TV_ENCODER_NONE                 0x000
#define TV_ENCODER_BROOKTREE            0x100
#define TV_ENCODER_CHRONTEL             0x200
#define TV_ENCODER_PHILIPS              0x400

#define TV_ENCODER_FAMILY( X )          (X & ~0xFF)

#define NV_ENCODER_NONE                 TV_ENCODER_NONE

#define NV_ENCODER_BROOKTREE_868        (TV_ENCODER_BROOKTREE + 1)
#define NV_ENCODER_BROOKTREE_869        (TV_ENCODER_BROOKTREE + 2)
#define NV_ENCODER_BROOKTREE_871        (TV_ENCODER_BROOKTREE + 3)

#define NV_ENCODER_CHRONTEL_7003        (TV_ENCODER_CHRONTEL + 3)
#define NV_ENCODER_CHRONTEL_7004        (TV_ENCODER_CHRONTEL + 4)
#define NV_ENCODER_CHRONTEL_7005        (TV_ENCODER_CHRONTEL + 5)
#define NV_ENCODER_CHRONTEL_7006        (TV_ENCODER_CHRONTEL + 6)
#define NV_ENCODER_CHRONTEL_7007        (TV_ENCODER_CHRONTEL + 7)
#define NV_ENCODER_CHRONTEL_7008        (TV_ENCODER_CHRONTEL + 8)

#define NV_ENCODER_PHILIPS_7102	        (TV_ENCODER_PHILIPS + 2)
#define NV_ENCODER_PHILIPS_7103	        (TV_ENCODER_PHILIPS + 3)
#define NV_ENCODER_PHILIPS_7108	        (TV_ENCODER_PHILIPS + 8)    // = 7102 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7109	        (TV_ENCODER_PHILIPS + 9)    // = 7103 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7108B        (TV_ENCODER_PHILIPS + 8 + 0x10)    // early version of 7108 with clock active edge reversed
//
// NV_CFG_PRIMARY_SURFACE_PITCH - Return the display pitch of the primary surface
//
//  Value defined in bytes
//
#define NV_CFG_PRIMARY_SURFACE_PITCH            56

//
// NV_CFG_VIDEO_ENCODER_ID - Return the encoder ID (I2C address)
//
#define NV_CFG_VIDEO_ENCODER_ID                 57

//
// NV_CFG_NUMBER_OF_HEADS - Return the number of CRTC heads on this device
//
#define NV_CFG_NUMBER_OF_HEADS                  58

//
// NV_CFG_DEVICE_INSTANCE - Return the device instance
//
#define NV_CFG_DEVICE_INSTANCE                  59

//
// NV_CFG_NUMBER_OF_ACTIVE_HEADS - Return number of active CRTC heads on this device
//
#define NV_CFG_NUMBER_OF_ACTIVE_HEADS           60

//
// NV_CFG_INITIAL_BOOT_HEAD - Return the dac head that was used to boot the system
//
//  0 - HeadA
//  1 - HeadB
//  All other values are reserved
//
#define NV_CFG_INITIAL_BOOT_HEAD                61

//
// NV_CFG_VIDEO_DISPLAY_TYPE - Return the physical display being used by this device
//
//  0 - Monitor
//  1 - TV
//  2 - Dual Surface
//  3 - Flat Panel
//  All other values are reserved
//
#define NV_CFG_VIDEO_DISPLAY_TYPE               78

//
// NV_CFG_VIDEO_MONITOR_TYPE - Return the monitor format type being used by this device
//
//  0 - VGA
//  2 - NTSC TV
//  3 - PAL TV
//  4 - Flat Panel
//  All other values are reserved
//
#define NV_CFG_VIDEO_MONITOR_TYPE               79

#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

//
// NV_CFG_VIDEO_OVERLAY_ALLOWED - Return the video overlay validity in the current
//      desktop resolution
//
//  0 - Video Overlay not allowed
//  1 - Video Overlay is allowed
//  All other values are reserved
//
#define NV_CFG_VIDEO_OVERLAY_ALLOWED            80

//
// NV_CFG_VIDEO_DOWNSCALE_RATIO_X - Return the maximum video overlay downscale ratio
// supported for the given source width in the current desktop resolution
// (assuming the overlay is supported at all -- see above)
//
//  1  - Video Downscaling not supported with this source width
//  2  - Maximum 2X downscaling supported
//  4  - Maximum 4X downscaling supported
//  8  - Maximum 8X downscaling supported
//  16 - Maximum 16X downscaling supported
//  (and so on)
//
#define NV_CFG_VIDEO_DOWNSCALE_RATIO_768        82
#define NV_CFG_VIDEO_DOWNSCALE_RATIO_1280       83
#define NV_CFG_VIDEO_DOWNSCALE_RATIO_1920       84

//
// NV_CFG_FRAMEBUFFER_UNDERSCAN - Return/Set the NV3 (RIVA128) TV Underscan resolution
//
#define NV_CFG_FRAMEBUFFER_UNDERSCAN_X          85
#define NV_CFG_FRAMEBUFFER_UNDERSCAN_Y          86

//
// NV_CFG_VIDEO_OUTPUT_FORMAT - Return/Set the NV4/5/10 TV output format (S-Video, Composite, or Auto)
//
//  0 = Auto
//  1 = Composite
//  2 = S-Video 
//
#define NV_CFG_VIDEO_OUTPUT_FORMAT              90

#define NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT          0x0
#define NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE     0x1
#define NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO        0x2

//
// NV_CFG_VIDEO_TV_FORMAT - Return the current TV format
//
#define NV_CFG_VIDEO_TV_FORMAT                  109
// must be one of the following formats
#define NTSC_M  0
#define NTSC_J  1
#define PAL_M   2
#define PAL_A   3   // PAL B, D, G, H, I
#define PAL_N   4
#define PAL_NC  5
#define KNOWN_TV_FORMATS 5 // number of formats we know about + 1

//
// NV_CFG_DAC_INPUT_WIDTH - Return the width (in bits) of the current framebuffer bus
//
#define NV_CFG_DAC_INPUT_WIDTH                  110

//
// NV_CFG_DAC_VPLL_*
// NV_CFG_DAC_MPLL_* - Return the individual components of the memory and video PLL's
//
//  The definition of these values is reserved
//
#define NV_CFG_DAC_VPLL_M                       120
#define NV_CFG_DAC_VPLL_N                       121
#define NV_CFG_DAC_VPLL_O                       122
#define NV_CFG_DAC_VPLL_P                       123
#define NV_CFG_DAC_MPLL_M                       130
#define NV_CFG_DAC_MPLL_N                       131
#define NV_CFG_DAC_MPLL_O                       132
#define NV_CFG_DAC_MPLL_P                       133

//
// NV_CFG_BIOS_DEFAULT_TV_TYPE - The TV standard the BIOS uses by default.
//
//  The allowed values are defined as the values for NV_CFG_VIDEO_TV_FORMAT
//
#define NV_CFG_BIOS_DEFAULT_TV_TYPE             134

//
// NV_CFG_INTERRUPTS_ENABLED_STATE - Return / set NV interrupts enable
//
//  Return value of "get" form is 0 or 1.
//  When enabling interrupts, restores them to RM's idea of the current value
//
#define NV_CFG_INTERRUPTS_ENABLED_STATE         140

//
// NV_CFG_VIDEO_REFRESH_RATE - Return/Set the current display refresh rate (in Hz)
//
#define NV_CFG_VIDEO_REFRESH_RATE               170

//
// NV_CFG_VBLANK_TOGGLE - Return/Set the current value of the vertical sync toggle
//
//  This value is toggled to zero (0) during every vertical sync.  By setting it to
//  any other value and then monitoring, a client can detect the presence of a
//  vertical sync signal occuring within a defined time period.
//
#define NV_CFG_VBLANK_TOGGLE                    212

//
// NV_CFG_VBLANK_COUNTER - Return/Set the number of vertical blanks 
//
//  This value is initialized to zero and keeps a running count of the number of
//  vertical blanks since the last reset. Use ConfigSet to reset it to zero.
//
#define NV_CFG_VBLANK_COUNTER                   213

//
// NV_CFG_PRAM_CURRENT_SIZE - Return the currently allocated size of chip
//
#define NV_CFG_PRAM_CURRENT_SIZE                220

//
// NV_CFG_GET_ALL_DEVICES - Return all available display devices (connectors)
//  in bitmask form.
// bits 0..7 represent CRT0..CRT7
// bits 8..15 represent TV0..TV7
// bits 16..23 represent DD0..DD7
// bits 24..31 are reserved
//
#define NV_CFG_GET_ALL_DEVICES                  221

//Same format as NV_CFG_GET_ALL_DEVICES
#define NV_CFG_GET_BOOT_DEVICES                 222

//
// NV_CFG_DAC_PIXEL_CLOCK - Return the current video pixel clock (in Hz) for this device
//
#define NV_CFG_DAC_PIXEL_CLOCK                  250

//                                                              
// NV_CFG_DAC_MEMORY_CLOCK - Return the current memory clock (in Hz) for this device
//
#define NV_CFG_DAC_MEMORY_CLOCK                 251

//
// NV_CFG_DAC_GRAPHICS_CLOCK - Return the current graphics clock (in Hz) for this device
//
#define NV_CFG_DAC_GRAPHICS_CLOCK               253

//
// NV_CFG_DAC_PCLK_LIMIT_8BPP - Return the current 8bpp graphics clock limit (in Hz) for this device
//
#define NV_CFG_DAC_PCLK_LIMIT_8BPP              260

//
// NV_CFG_DAC_PCLK_LIMIT_16BPP - Return the current 16bpp graphics clock limit (in Hz) for this device
//
#define NV_CFG_DAC_PCLK_LIMIT_16BPP             261

//
// NV_CFG_DAC_PCLK_LIMIT_32BPP - Return the current 16bpp graphics clock limit (in Hz) for this device
//
#define NV_CFG_DAC_PCLK_LIMIT_32BPP             262

//
// NV_CFG_MAPPING_BUSDEVICEFUNC - Return the device type for use by the display driver configmgr code
//
//  This value is the device type or'd with the busdevicefunc info (9X specific)
//
#define NV_CFG_MAPPING_BUSDEVICEFUNC            263
              
//
// NV_CFG_VBLANK_STATUS - Return the current vertical blank status of this device
//
//  0 - device is not currently in vertical blank
//  1 - device is currently in vertical blank
//
#define NV_CFG_VBLANK_STATUS                    500

//
// NV_CFG_GE_STATUS - Return the current graphics activity state of this device
//
//  any value other than zero (0) denotes graphics activity is in progress
//
#define NV_CFG_GE_STATUS                        501

//
// NV_CFG_CURRENT_SCANLINE - Return the current active display scanline of this device
//
//  The value returned may be greater than the current resolution if the display
//  has moved into the vertical blanking period.
//
#define NV_CFG_CURRENT_SCANLINE                 502

//
// NV_CFG_FRAMECAPTURE_CALLBACK - Set the current 16bit callback (VFW) for framecapture
//
//  The value is specifically OS-dependent.  This setting may only be used with ConfigSet
//  and only on those operating systems requiring the callback mechanism.
//
#define NV_CFG_FRAMECAPTURE_CALLBACK            600

// Get the device handle for the device.
// Currently only defined for unix where it returns file descriptor
// for the opened device.  Needed for poll(2) on events

#define NV_CFG_DEVICE_HANDLE                    650

//
// NV_CFG_CRTC_* - Return/Set a CRTC (VGA) register in this device
//
//  All CRTC registers are accessed by adding the index the base value 
//  given here.
//  For example, CR1B is accessed using index (NV_CFG_CRTC+0x1B)
//
#define NV_CFG_CRTC                             768
//
// NOTE: CRTC RESERVED TO INDEX 832
//

//
// The following values are reserved for use by the resource manager 
// performance and debug tools
//
#define NV_CFG_SET_JUMP_WRITE_PUT_READ_GET      833
#define NV_STAT_INTERVAL_NSEC_LO                1000
#define NV_STAT_INTERVAL_NSEC_HI                1001
#define NV_STAT_FIFO_EXCEPTIONS                 1003
#define NV_STAT_FRAMEBUFFER_EXCEPTIONS          1004
#define NV_STAT_GRAPHICS_EXCEPTIONS             1005
#define NV_STAT_TIMER_EXCEPTIONS                1006
#define NV_STAT_CHIP_EXCEPTIONS                 1050
#define NV_STAT_MEM_ALLOCATED                   1100
#define NV_STAT_MEM_LOCKED                      1101
#define NV_STAT_EXEC_NSEC_LO                    1200
#define NV_STAT_EXEC_NSEC_HI                    1201
#define NV_STAT_INT_NSEC_LO                     1202
#define NV_STAT_INT_NSEC_HI                     1203

#define NV_CFG_REGISTRY_STRING                  1300

#define NV_CFG_DEBUG_LEVEL                      1350


//////////////////////////////////////////////////////////////////////////////
//
// The following Config equates are a 16bit subset of the corresponding 
// ConfigEX values
//
// Where possible, make sure to use the 32bit versions of these DDK interfaces
// rather than these legacy equates
//

//
// NV_CFG_GET_FLAT_PANEL_CONNECT_16 - Return the connection status of a 
// digital flat panel
// 
#define NV_CFG_FLAT_PANEL_CONNECT_16            30100

//
// NV_CFG_GET_FLAT_PANEL_CONFIG_16 - Return or update the current format 
// configuration of the active digital flat panel
//
//  0 - scaled
//  1 - centered
//  2 - native
// 
#define NV_CFG_FLAT_PANEL_CONFIG_16             30102

//
// NV_CFG_STEREO_CONFIG - Stereo support Config Parameters
//
//  The subcodes within this entry are NV reserved
//
#ifdef  STEREO_SUPPORT
#define NV_CFG_STEREO_CONFIG                    40000
#endif  //STEREO_SUPPORT

//
// Parameter to ConfigUpdate.
//
#define NV_CFG_PERMANENT                        1
#define NV_CFG_TEMPORARY                        2


////////////////////////////////////////////////////////////////////
//
// The following Config equates are to be used with the ConfigGetEx()
// and ConfigSetEx() functions.  Rather than just taking a DWORD
// data value, they allow the use of a per-function data structure
// to be used as a parameter block.  
//
// Be careful to only use these equates with the appropriate
// functions.
//

//
// NV_CFGEX_GET_DESKTOP_POSITION_MONITOR - Return the monitor alignment
//
#define NV_CFGEX_GET_DESKTOP_POSITION_MONITOR              100
// Param Structure
typedef struct {
    unsigned long  GetDefault;
    unsigned long  HBlankStart;
    unsigned long  HBlankEnd;
    unsigned long  VBlankStart;
    unsigned long  VBlankEnd;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS;

//
// NV_CFGEX_SET_DESKTOP_POSITION_MONITOR - Set the new monitor alignment
//
#define NV_CFGEX_SET_DESKTOP_POSITION_MONITOR               101
// Param Structure
typedef struct {
    unsigned long  CommitChanges;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS;

/************** Desktop position for TV ***********/
#define NV_CFGEX_GET_DESKTOP_POSITION_TV                    102
#define NV_CFGEX_COMMIT_DESKTOP_POSITION_TV                 103

typedef struct {
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
    unsigned char  reg0x80;
    unsigned char  reg0x82;
    unsigned char  reg0x92;
    unsigned char  reg0x98;
    unsigned char  reg0x9A;
    unsigned char  reg0xC8;
    unsigned char  reg0xCA;
    unsigned char  reg0xCC;
} PARAMS_BROOKTREE;

// Register values for flicker filter. Chroma FF is 5:3, Lum FF is 2:0. Control Panel has 4 settings, other values result in OFF.
#define BT_FLICKER_HI   0    // Max FF
#define BT_FLICKER_MED  0x12
#define BT_FLICKER_LO   0x09
#define BT_FLICKER_OFF  0x1b // Place holder in CP.
#define BT_FLICKER_DEF  BT_FLICKER_MED // RM default
// Register values for Luma (Brightness)
#define BT_LUMA_MAX     0xC0  // No attenuation
#define BT_LUMA_DEF     0xC3  // RM default  
#define BT871_LUMA_DEF  0xC4  // RM default  
#define BT_LUMA_MIN     0xC7
// Register values for Chroma (Saturation)
#define BT_CHROMA_MAX   0xC0
#define BT_CHROMA_DEF   0xC2  // RM default
#define BT871_CHROMA_DEF 0xC1  // RM default
#define BT_CHROMA_MIN   0xC7

typedef struct {
    unsigned char  reg0x01; // Flicker Filter
    unsigned char  reg0x08; // overflow bits for V & H position
    unsigned char  reg0x0A; // Horizontal Position
    unsigned char  reg0x0B; // Vertical Position
    unsigned char  reg0x09; // Black Level (Brightness)
    unsigned char  reg0x11; // Contrast
} PARAMS_CHRONTEL;

// The way H2INC groks this exposes an internal error in ML 6.13
#ifndef H2INC
// Param Structure
typedef struct {
    unsigned long  Encoder_ID;  // NV_ENCODER_ type
    unsigned char  Default;     // get default setting if set, else get current
    union {
        PARAMS_BROOKTREE regsBt;
        PARAMS_CHRONTEL  regsCh;
    } u;     // NOTE: some compilers (eg: gcc) does not allow for anonymous sructs
} NV_CFGEX_DESKTOP_POSITION_TV_PARAMS;
#endif  // H2INC

/************** TV Encoder ***********************************/
#define NV_CFGEX_GET_TV_ENCODER_INFO                        104
// Param Structure
// EncoderType:
//      0 - None
//      1 - Chrontel 7003
//      2 - Brooktree 868
//      3 - Brooktree 869
//      All other values are reserved
// TVConnected:
//      0 - Not connected
//      1 - Connected
// EncoderID: I2C address of encoder
typedef struct {
    unsigned long  EncoderType;
    unsigned long  EncoderID;
    unsigned long  TVConnected;
} NV_CFGEX_TV_ENCODER_PARAMS;
#define TV_NOT_CONNECTED    0
#define TV_CONNECTED        1

#define NV_CFGEX_SET_TV_ENCODER_INFO                        105

/************** Flat Panel ***********************************/
#define NV_CFGEX_GET_FLAT_PANEL_INFO                        106
// Param structure
// FlatPanelMode:
//     0 - Not Connected
//     1 - Centered
//     2 - Native
//     3 - Scaled mode
// FlatPanelSizeX:
//     Max horizontal resolution.
// FlatPanelSizeY:
//     Max vertical resolution.
// FlatPanelNativeSupported
typedef struct {
    unsigned long FlatPanelMode;
    unsigned long FlatPanelSizeX;
    unsigned long FlatPanelSizeY;
    long          FlatPanelConnected;
    long          FlatPanelNativeSupported;
} NV_CFGEX_GET_FLATPANEL_INFO_PARAMS;
#define NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED   0
#define NV_CFGEX_GET_FLATPANEL_INFO_CONNECTED       1
#define NV_CFGEX_GET_FLATPANEL_INFO_SCALED          0
#define NV_CFGEX_GET_FLATPANEL_INFO_CENTERED        1
#define NV_CFGEX_GET_FLATPANEL_INFO_NATIVE          2


#define NV_CFGEX_SET_FLAT_PANEL_INFO                        107
// Param structure
typedef struct {
    unsigned long CommitChanges;
    unsigned long FlatPanelMode;
} NV_CFGEX_SET_FLATPANEL_INFO_PARAMS;

/************** Monitor **************************************/
#define NV_CFGEX_GET_MONITOR_INFO                           108
// Param structure
// MonitorConnected:
//      0 - Not Connected
//      1 - Connected
typedef struct {
    unsigned long MonitorConnected;
} NV_CFGEX_GET_MONITOR_INFO_PARAMS;

#define NV_CFGEX_GET_MONITOR_INFO_NOT_CONNECTED                0
#define NV_CFGEX_GET_MONITOR_INFO_CONNECTED                    1

/************** Get the current Windows refresh rate and state (real, default or optimal) **************/
#define NV_CFGEX_GET_REFRESH_INFO             111
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long ulRefreshRate;
    unsigned long ulState;
} NV_CFGEX_GET_REFRESH_INFO_PARAMS;

// definitions of state flags
#define NV_CFG_REFRESH_FLAG_SPECIFIC          0x00000000 /* use specific value contained in ulRefreshRate */
#define NV_CFG_REFRESH_FLAG_ADAPTER_DEFAULT   0x00000001 /* Windows is using "Adapter Default" setting    */
#define NV_CFG_REFRESH_FLAG_OPTIMAL           0x00000002 /* Windows is using "Optimal" setting            */

/************** Multihead CFGEX_SET **************/

#define NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI        112
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  CommitChanges;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS;

#define NV_CFGEX_SET_FLAT_PANEL_INFO_MULTI                  113
// Param structure
typedef struct {
    unsigned long Head;
    unsigned long CommitChanges;
    unsigned long FlatPanelMode;
} NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS;

// The way H2INC groks this exposes an internal error in ML 6.13
#ifndef H2INC
#define NV_CFGEX_COMMIT_DESKTOP_POSITION_TV_MULTI           114
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  Encoder_ID;  // NV_ENCODER_ type
    unsigned char  Default;     // get default setting if set, else get current
    union {
        PARAMS_BROOKTREE regsBt;
        PARAMS_CHRONTEL  regsCh;
    } u;     // NOTE: some compilers (eg: gcc) does not allow for anonymous sructs
} NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS;

#define NV_CFGEX_GET_DESKTOP_POSITION_TV_MULTI              115

#define NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI         116
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  GetDefault;
    unsigned long  HBlankStart;
    unsigned long  HBlankEnd;
    unsigned long  VBlankStart;
    unsigned long  VBlankEnd;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS;
#endif

/************** Get the offset within the AGP aperture (can't just subtract from linearbase anymore) ***/
#define NV_CFGEX_GET_AGP_OFFSET                 138
// Param Structure
typedef struct {
    void* linaddr;                      // passed in linear address, returned from a AGP space alloc
    void* physaddr;                     // returned physical address
    unsigned long offset;               // returned offset within the AGP aperture
} NV_CFGEX_GET_AGP_OFFSET_PARAMS;

/************** Return/Set the current linear GART address (64 bit clean version of NV_CFG_AGP_LINEAR_BASE above) ***/
#define NV_CFGEX_AGP_LINEAR_BASE                139
// Param Structure
typedef struct {
    void* linaddr;                      // passed in/returned linear address
} NV_CFGEX_AGP_LINEAR_BASE_PARAMS;

/************** Get the Display Type **************/
#define NV_CFGEX_GET_DISPLAY_TYPE               140
// Param Structure
typedef struct {
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_GET_DISPLAY_TYPE_PARAMS;

// definitions of Display Types
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3
// definitions of TV types: see NV_CFG_VIDEO_TV_FORMAT

/************** Set the Display Type **************/
#define NV_CFGEX_SET_DISPLAY_TYPE               141
// Param Structure
typedef struct {
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_SET_DISPLAY_TYPE_PARAMS;


/************** Get the Display Type for Specified Head **************/
#define NV_CFGEX_GET_DISPLAY_TYPE_MULTI         142
// Param Structure
typedef struct {
    unsigned long Head;
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS;

/************** Get the Display Type of the Specified Head **************/
#define NV_CFGEX_SET_DISPLAY_TYPE_MULTI         143
// Param Structure
typedef struct {
    unsigned long Head;
    unsigned long Type;
    unsigned long TVType;
} NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS;

/************** Get the Raster Postion for the Specified Head ***********/
#define NV_CFGEX_CURRENT_SCANLINE_MULTI         144
// Param Structure
typedef struct {
    unsigned long Head;
    unsigned long RasterPosition;
} NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS;

/************** CRTC Timing ***********/
#define NV_CFGEX_CRTC_TIMING_MULTI              145
// Param Structure
typedef struct {
    unsigned long  Head;
    unsigned long  Reg;                     // data location, see below
    unsigned long  HTotal;
    unsigned long  HDisplayEnd;
    unsigned long  HBlankStart;
    unsigned long  HBlankEnd;
    unsigned long  HRetraceStart;
    unsigned long  HRetraceEnd;
    unsigned long  VTotal;
    unsigned long  VDisplayEnd;
    unsigned long  VBlankStart;
    unsigned long  VBlankEnd;
    unsigned long  VRetraceStart;
    unsigned long  VRetraceEnd;
} NV_CFGEX_CRTC_TIMING_PARAMS;
#define NV_CFGEX_CRTC_PARAMS    14          // number of 32 bit values (HTotal - VRetraceEnd) 
#define NV_CFGEX_CRTC_TIMING_REGISTER 1     // get/set CRTC registers
#define NV_CFGEX_CRTC_TIMING_REGISTRY 2     // get/set Windows registry
#define NV_CFGEX_CRTC_TIMING_DEFAULT  4     // get default registers (set not valid)

/** Return the linear address of (BAR0) of this device (64 bit clean version) */
#define NV_CFGEX_ADDRESS_NVADDR                 146
// Param Structure
typedef struct {
    void* nvaddr;
} NV_CFGEX_ADDRESS_NVADDR_PARAMS;

/************** RESERVED **************/
#define NV_CFGEX_RESERVED                       150

/************** Enable tiling ********************************/
#define NV_CFGEX_ENABLE_TETRIS_TILING                       200

/************** Disable tiling *******************************/
#define NV_CFGEX_DISABLE_TETRIS_TILING                      201

/************** Get the monitor EDID *************************/
#define NV_CFGEX_GET_EDID                                   210
// param structure
typedef struct {
    unsigned long displayType;  // see NV_CFGEX_GET_DISPLAY_TYPE for legal values
    unsigned char *edidBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_EDID_PARAMS;

/************** Get the current device BIOS ******************/
#define NV_CFGEX_GET_BIOS                                   215
// param structure
typedef struct {
    unsigned char *biosBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_BIOS_PARAMS;

//
//  New versions of ConfigGetEx for multi-head devices
//

//
// NV_CFG_DAC_PCLK_LIMIT_8BPP - Return the current 8bpp graphics clock limit (in Hz) for specified head on this device 
//
#define NV_CFGEX_DAC_PCLK_LIMIT_8BPP            264
typedef struct {
    unsigned long Head;
    unsigned long pclkLimit;
} NV_CFGEX_DAC_PCLK_LIMIT_PARAMS;

//
// NV_CFG_DAC_PCLK_LIMIT_16BPP - Return the current 16bpp graphics clock limit (in Hz) for specified head on this device
//
#define NV_CFGEX_DAC_PCLK_LIMIT_16BPP           265

//
// NV_CFG_DAC_PCLK_LIMIT_32BPP - Return the current 16bpp graphics clock limit (in Hz) for specified head onthis device
//
#define NV_CFGEX_DAC_PCLK_LIMIT_32BPP           266

//
// NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST - Return the pre-dac NV11 color saturation boost value
//
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST  268
typedef struct {
    unsigned long Head;
    unsigned char boostValue;
} NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS;

#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_0          0x00000000
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_188        0x00000001
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_375        0x00000002
#define NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_750        0x00000003

// Another get info for a specified head
#define NV_CFGEX_GET_TV_ENCODER_INFO_MULTI      270
typedef struct {
    unsigned long  Head;
    unsigned long  EncoderType;
    unsigned long  EncoderID;
    unsigned long  TVConnected;
} NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS;

// Another get info for a specified head
#define NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI       271
// Param structure
// FlatPanelMode:
//     0 - Not Connected
//     1 - Centered
//     2 - Native
//     3 - Scaled mode
// FlatPanelSizeX:
//     Max horizontal resolution.
// FlatPanelSizeY:
//     Max vertical resolution.
// FlatPanelNativeSupported
typedef struct {
    unsigned long Head;
    unsigned long FlatPanelMode;
    unsigned long FlatPanelSizeX;
    unsigned long FlatPanelSizeY;
    long          FlatPanelConnected;
    long          FlatPanelNativeSupported;
} NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS;

// Return TV encoder type on specified head
#define NV_CFGEX_VIDEO_ENCODER_TYPE             272
typedef struct {
    unsigned long Head;
    unsigned long EncoderType;
} NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS;

// Return TV encoder ID on specified head
#define NV_CFGEX_VIDEO_ENCODER_ID               273
typedef struct {
    unsigned long Head;
    unsigned long EncoderID;
} NV_CFGEX_VIDEO_ENCODER_ID_PARAMS;

#define NV_CFGEX_GET_EDID_MULTI                 274
// param structure
typedef struct {
    unsigned long Head;
    unsigned long displayType;  // see NV_CFGEX_GET_DISPLAY_TYPE for legal values
    unsigned char *edidBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_EDID_MULTI_PARAMS;

#define NV_CFGEX_GET_MONITOR_INFO_MULTI         275
// Param structure
// MonitorConnected:
//      0 - Not Connected
//      1 - Connected
typedef struct {
    unsigned long Head;
    unsigned long MonitorConnected;
} NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS;

#define NV_CFGEX_SYNC_STATE                     276
// Param structure
//     set/get the state of HSYNC and VSYNC
typedef struct {
    unsigned long Head;
    unsigned long Hsync;              // non-zero to enable
    unsigned long Vsync;              // non-zero to enable
    unsigned long oldHsync;           // on SETEX, what was previous value
    unsigned long oldVsync;           // ""
} NV_CFGEX_SYNC_STATE_PARAMS;

#define NV_CFGEX_PRIMARY_INFO                    277
// Param structure
//     get the state of the primary surface for the given head
typedef struct {
    unsigned long Head;               // input param; 0 or 1
    unsigned long Pitch;              // output
    unsigned long Offset;             // output; byte offset from beginning of FB
} NV_CFGEX_PRIMARY_INFO_PARAMS;

#define NV_CFGEX_FLAT_PANEL_BRIGHTNESS		278
//param structure
//   -this structure is used for setting and getting the settings of the PWM brightness output.
//   -when the getex command is called for this structure, the only two valid values on return will
//    be PWMControllerEnable and PercentRelativeBrightness. 
typedef struct
{
	unsigned long Head;
    unsigned long FlatPanelBrightnessControlFrequency;
    unsigned long PercentMaximumPWMDutyCycle;
    unsigned long PercentMinimumPWMDutyCycle;
    unsigned long PercentRelativeBrightness;
    signed long PWMControllerEnable;
} NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS;

/************** Return Pitch given Width/Depth ***************/
#define NV_CFGEX_GET_SURFACE_PITCH                          300
// Param structure
typedef struct {
    unsigned long Width;          // in (pixels)
    unsigned long Depth;          // in (bits per pixel)
    unsigned long Pitch;          // out
} NV_CFGEX_GET_SURFACE_PITCH_PARAMS;

/************** Return Pitch/Size given Width/Height/Depth ***/
#define NV_CFGEX_GET_SURFACE_DIMENSIONS                     301
// Param structure
typedef struct {
    unsigned long Width;          // in (pixels)
    unsigned long Height;         // in (pixels)
    unsigned long Depth;          // in (bits per pixel)
    unsigned long Pitch;          // out
    unsigned long Size;           // out
} NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS;

/************** Return Supported Classes for a given NV chip */
#define NV_CFGEX_GET_SUPPORTED_CLASSES                      310
//
// Pass in a NULL classBuffer pointer to have the RM fill in the numClasses field.
// This is the number of dword entries that should be allocated by the caller for
// the classBuffer.
//
// Then, make this call again with the filled in classBuffer and the RM will verify
// the numClasses is large enough and fill in classBuffer with the supported class
// numbers.
//
// Param structure
typedef struct {
    unsigned long  numClasses;    // number of supported classes
    unsigned long *classBuffer;   // dword buffer holding supported class values
} NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS;

/************** Return RM mappings to device's regs/fb *******/
#define NV_CFGEX_GET_DEVICE_MAPPINGS                        311
//
// This call is used by NVDE debugger to retrieve the RM's
// (linear) mappings to a given device's registers and framebuffer.
//
// Param structure
typedef struct {
    void *nvVirtAddr;               // register virtual address
    void *nvPhysAddr;               // register physical address
    void *fbVirtAddr;               // fb virtual address
    void *fbPhysAddr;               // fb physical address
} NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS;

/************** Set Macrovision Mode *************************/
#define NV_CFGEX_SET_MACROVISION_MODE                       320 
typedef struct {
    unsigned long   head;
    unsigned long   mode;
    unsigned long   resx;
    unsigned long   resy;
    unsigned long   status;
} NV_CFGEX_SET_MACROVISION_MODE_PARAMS;

//
// NV_CFGEX_CHECK_CONNECTED_DEVICES - Return connect status of the specified
//  devices.
// Input: a bitmask that is a subset of the bitmask returned by the
//          NV_CFG_GET_ALL_DEVICES call.  set bits indicate the calling routine
//          want to check the connect status of the corresponding devices.
// Output: set bits in the bitmask indicating the corresponding devices are
//          connected.
//
// bits 0..7 represent CRT0..CRT7
// bits 8..15 represent TV0..TV7
// bits 16..23 represent DD0..DD7
// bits 24..31 are reserved
//
#define NV_CFGEX_CHECK_CONNECTED_DEVICES        321

//
// NV_CFGEX_GET_DEVICES_CONFIGURATION - Return possible configuration for the
//  specified devices.  Pass in OldDevicesConfig and OldDevicesAllocationMap
//  if you want the routine to try to keep existing attached devices on the
//  same heads whenever possible.  Pass in zero for OldDevicesConfig otherwise.
//  
// Input: DevicesConfig - a bitmask that is a subset of the bitmask returned
//              by the NV_CFGEX_CHECK_CONNECTED_DEVICES call. set bits indicate
//              devices to be in the configuration. up to eight bits can be set.
//        OldDevicesConfig - DevicesConfig used from the last call to
//              NV_CFGEX_GET_DEVICES_CONFIGURATION.
//        OldDevicesAllocationMap - DevicesAllocationMap returned by the last
//              call to NV_CFGEX_GET_DEVICES_CONFIGURATION.
// Output: DevicesAllocationMap - a 32-bit value in the following format:
//          nibble0 - head that can be used to connect to device0 (device
//                      corresponds to the rightmost set bit.
//          nibble1 - head that can be used to connect to device1 (device
//                      corresponds to the second rightmost set bit.
//          .
//          .
//
// bits 0..7 represent CRT0..CRT7
// bits 8..15 represent TV0..TV7
// bits 16..23 represent DD0..DD7
// bits 24..31 are reserved
//
typedef struct {
    unsigned long  DevicesConfig;
    unsigned long  DevicesAllocationMap;
    unsigned long  OldDevicesConfig;
    unsigned long  OldDevicesAllocationMap;
} NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS;
#define NV_CFGEX_GET_DEVICES_CONFIGURATION      322

// NV_CFGEX_GET_HOTKEY_EVENT - Report Fn+x hotkey events on a mobile system.
//  Some events are informational -- the BIOS has already acted on the event.
//  Other events indicate an action that must be taken care of by the driver.
//  Currently, only the display enable/disable events fall into this category.
//
// The RM checks the BIOS for new events every vblank.  Note that more than one
//  event may be added to the queue at a time (e.g., display enable/disable events
//  will often occur in sets).  The caller should continue to poll until the
//  call returns NV_HOTKEY_EVENT_NONE_PENDING.
//
// If the BIOS does not support this feature, the RM will return NV_HOTKEY_EVENT_NOT_SUPPORTED.
// 
// Input: a pointer to a NV_CFGEX_GET_HOTKEY_EVENT_PARAMS paramStruct
// Output: the event field will report a number from the event list below
//         the status field, where appropriate, indicates the new state the event is reporting
//
#define NV_CFGEX_GET_HOTKEY_EVENT                            330

//Queue Commands
#define NV_HOTKEY_EVENT_NOT_SUPPORTED        0  //No BIOS hotkey support.  Further polling not required.
#define NV_HOTKEY_EVENT_NONE_PENDING         1  //No hotkey events currently pending
#define NV_HOTKEY_EVENT_DISPLAY_ENABLE       2  //status bits decode to disable/enable state for
                                                // each display (definitions below) (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_LCD          2  //status 0/1 = disable/enable (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_CRT          3  //status 0/1 = disable/enable (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_TV           4  //status 0/1 = disable/enable (implemented by driver)
//#define NV_HOTKEY_EVENT_DISPLAY_DFP          5  //status 0/1 = disable/enable (implemented by driver)
#define NV_HOTKEY_EVENT_DISPLAY_CENTERING    6  //scaled/centered display - status values define below (implemented by BIOS)
                                                // mirrors settings for NV_PRAMDAC_FP_TG_CONTROL_MODE in nv_ref.h

// Status bit definitions for NV_HOTKEY_EVENT_DISPLAY_ENABLE event
// Currently identical to the BIOS register bit definitions, but
// we decode it explicitly to avoid implicit dependencies.
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD 0x01
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT 0x02
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV  0x04
#define NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP 0x08

//Enumeration of centering/scaling settings used with
// NV_HOTKEY_EVENT_DISPLAY_CENTERING event
#define NV_HOTKEY_STATUS_DISPLAY_SCALED     0x00
#define NV_HOTKEY_STATUS_DISPLAY_CENTERED   0x01
#define NV_HOTKEY_STATUS_DISPLAY_NATIVE     0x02

typedef struct {
    unsigned long event;
    unsigned long status;
} NV_CFGEX_GET_HOTKEY_EVENT_PARAMS;


#define NV_CFGEX_GET_LOGICAL_DEV_EDID                331 
// param structure
typedef struct {
    unsigned long displayMap;
    unsigned char *edidBuffer;
    unsigned long *bufferLength;  // in/out
} NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS;

#pragma pack() //


// NvRmOsConfigSet/Get parameters
//
// definitions for OS-specific versions of the config get/set calls.
//   When possible, new config calls should be added to the standard
//   config calls instead of here.
//

// NV_OSCFG_VSL_MODE - Return/Set the passing of VSL to the display manager
//
//  Initial value is 1
// 

#define NV_OSCFG_VSL_MODE                        0x0001


////////////////////////////////////////////////////////////////////
//
// NvRmOsConfigSetEx/GetEx parameters
//
//

//
// Get info about the cards in the system
//
typedef struct
{
    int    flags;               // see below
    int    instance;            // resman's ordinal for the card
    int    bus;                 // bus number (PCI, AGP, etc)
    int    slot;                // card slot
    int    vendor_id;           // PCI vendor id
    int    device_id;
    int    interrupt_line;
} NVCARDINFO, *PNVCARDINFO;

#define NV_CARD_INFO_FLAG_PRESENT       0x0001

#define NV_OSCFGEX_GET_CARD_INFO           100

typedef struct {
    unsigned long NumCards;                // input size of buffer; output # cards
    PNVCARDINFO   pCardInfo;
} NV_OSCFGEX_GET_CARD_INFO_PARAMS;


//---------------------------------------------------------------------------
//
//  Configuration Manager API.
//
//---------------------------------------------------------------------------
//
//
// DWORD NvConfigVersion(VOID)
//
//  Returns the revision of the ddk (config) interface built into the resource manager.
//  This is used for version continuity between all the resource manager files,
//  as well as provides the interface version for people using the config interface.
//
//  The format of this is 0xAAAABBCC, where
//   - 0xAAAA is [nvidia internal]
//   -   0xBB is the software release revision
//   -   0xCC is the minor revision
//
//
// DWORD NvConfigGet(DWORD Index, DWORD DeviceHandle)
//
//  Given an Index from NVCM.H and a pointer to a specific device (see SDK), return
//  the current configuration value.  The format of the value is dependent on the
//  index requested.
//
//
// DWORD NvConfigSet(DWORD Index, DWORD NewValue, DWORD DeviceHandle)
//
//  Given an Index from NVCM.H, a pointer to a specific device (see SDK), and a new
//  value, update the current configuration value.  This call returns the original
//  value in that configuration index.  In general, most new values do not take affect
//  until NvConfigUpdate() is called.  This allows multiple values to be batched
//  together before enabling the change.
//
//
// DWORD NvConfigUpdate(DWORD UpdateFlag, DWORD DeviceHandle)
//
//  Given an update flag and pointer to a specific device (see SDK), perform any previously
//  batched NvConfigSet() calls.  This call returns an error code (0 denotes success).
//  The only UpdateFlag currently in use is NV_CFG_PERMANENT.
//

#ifndef _WIN32
#if defined(__GNUC__) || defined(MACOS)
int NvConfigVersion(int);
int NvConfigGet(int, int);
int NvConfigSet(int, int, int);
int NvConfigUpdate(int, int);
int NvConfigVga(int, int);
#elif !defined(__WATCOMC__)
DWORD FAR PASCAL NvConfigVersion(DWORD);
DWORD FAR PASCAL NvConfigGet(DWORD, DWORD);
DWORD FAR PASCAL NvConfigSet(DWORD, DWORD, DWORD);
DWORD FAR PASCAL NvConfigUpdate(DWORD, DWORD);
DWORD FAR PASCAL NvConfigVga(DWORD, DWORD);
#endif // ! __WATCOMC__

#elif !defined(WINNT)
int __stdcall NvConfigVersion(void);
int __stdcall NvConfigGet(int, int);
int __stdcall NvConfigSet(int, int, int);
int __stdcall NvConfigUpdate(int);
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvConfigVersion "*";
#pragma aux (__stdcall) NvConfigGet "*";
#pragma aux (__stdcall) NvConfigSet "*";
#pragma aux (__stdcall) NvConfigUpdate "*";
#endif // __WATCOMC__
#endif // _WIN32


/////////////////////////////////////////////////////////////////////////////
//
// THE FOLLOWING DEFINES AND ENTRY POINTS ARE NVIDIA RESERVED
//
//---------------------------------------------------------------------------
//
//  Device Defines.
//
//---------------------------------------------------------------------------

//
// Parameter to DeviceGet.
//
#define NV_DEV_BASE                             1
#define NV_DEV_ALTERNATE                        2
#define NV_DEV_BUFFER_0                         3
#define NV_DEV_BUFFER_1                         4
#define NV_DEV_TIMER                            5
#define NV_DEV_PFB                              6
#define NV_DEV_PGRAPH                           7
#define NV_DEV_PRMCIO                           8
#define NV_DEV_PRMVIO                           9
#define NV_DEV_AGP                              10
#define NV_DEV_GAMMA                            11
#define NV_DEV_PRAMDAC                          12
#define NV_DEV_PCRTC                            13
#define NV_DEV_MAX                              13

//---------------------------------------------------------------------------
//
//  Device Pointer API.
//
//---------------------------------------------------------------------------
#ifndef WINNT
#ifndef _WIN32
#if defined(__GNUC__) || defined(MACOS)
int NvIoControl(int, int);
int NvDeviceBaseGet(int, int);
int NvDeviceLimitGet(int, int);
int NvDeviceSelectorGet(int, int);
int NvGetHardwarePointers(int *, int *, int *, int *);
#elif !defined(__WATCOMC__)
//DWORD FAR PASCAL NvIoControl(DWORD, DWORD);
DWORD FAR PASCAL NvDeviceBaseGet(DWORD, DWORD);
DWORD FAR PASCAL NvDeviceLimitGet(DWORD, DWORD);
WORD  FAR PASCAL NvDeviceSelectorGet(DWORD, DWORD);
DWORD FAR PASCAL NvGetHardwarePointers(DWORD *, DWORD *, DWORD *, DWORD *);
#endif // __WATCOMC__
#else  /* WIN32 */
void __stdcall NvIoControl(int, void *);
int  __stdcall NvDeviceBaseGet(int, int);
int  __stdcall NvDeviceLimitGet(int, int);
int  __stdcall NvDeviceSelectorGet(int, int);
int  __stdcall NvGetHardwarePointers(int *, int *, int *, int *, int);
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvIoControl "*";
#pragma aux (__stdcall) NvDeviceBaseGet "*";
#pragma aux (__stdcall) NvDeviceLimitGet "*";
#pragma aux (__stdcall) NvDeviceSelectorGet "*";
#pragma aux (__stdcall) NvGetHardwarePointers "*";
#endif // __WATCOMC__
#endif // _WIN32
#endif // !WINNT
#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvos.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

 

 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvos.h>  defines the Operating System function and ioctl interfaces to  *|
|*  NVIDIA's Unified Media Architecture (TM).                                *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVOS_INCLUDED
#define NVOS_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>

// local defines here
#define FILE_DEVICE_NV 		0x00008000
#define NV_IOCTL_FCT_BASE 	0x00000800

// Use these defines if you are opening the RM vxd or the minivdd using the
// CreateFile inetrface.
// NV3 Resource Manager VXDs
#define NV3_PRIMARY_MINIVDD     "\\\\.\\NV3.VXD"
#define NV3_SECONDARY_MINIVDD   "\\\\.\\NV3MINI2.VXD"
#define NV3_RESMAN_VXD          "\\\\.\\NV3RM.VXD"
// NV4/NV10 Resource Manager VXDs
#define NVX_PRIMARY_MINIVDD     "\\\\.\\NVMINI.VXD"
#define NVX_SECONDARY_MINIVDD   "\\\\.\\NVMINI2.VXD"
#define NVX_RESMAN_VXD          "\\\\.\\NVCORE.VXD"

// Use this define for the resman vxd name if you use the VXDLDR_LoadDevice
// interface.
#define VXDLDR_NV3_RESMAN_VXD_NAME "NV3RM.VXD"
#define VXDLDR_NVX_RESMAN_VXD_NAME "NVCORE.VXD"
#define VXDLDR_NVA_RESMAN_VXD_NAME "NVACORE.VXD"

#if defined(WIN32)
#if !defined(NV_APIENTRY)
#define NV_APIENTRY __stdcall
#ifndef APIENTRY
#define APIENTRY    NV_APIENTRY          // APIENTRY deprecated; use NV_APIENTRY
#endif
#define CAPI        NV_APIENTRY          // CAPI deprecated; use NV_APIENTRY
#endif
#if !defined(NV_FASTCALL)
#define NV_FASTCALL __fastcall
//#define FASTCALL    NV_FASTCALL          // FASTCALL deprecated; use NV_FASTCALL
#endif
#if !defined(NV_INLINE)
#define NV_INLINE __inline
#define INLINE      NV_INLINE            // INLINE deprecated; use NV_INLINE
#endif
#if !defined(NV_CDECLCALL)
#define NV_CDECLCALL __cdecl
#define CDECLCALL   NV_CDECLCALL         // CDECLCALL deprecated; use NV_CDECLCALL
#endif
#if !defined(NV_STDCALL)
#define NV_STDCALL __stdcall
#define STDCALL     NV_STDCALL           // STDCALL deprecated; use NV_STDCALL
#endif

#else /* ! defined(WIN32) */

#define NV_APIENTRY
#define NV_FASTCALL
#define NV_CDECLCALL
#define NV_STDCALL 
#ifdef __GNUC__
#define NV_INLINE     __inline__
#elif defined (macintosh)
#define NV_INLINE inline
#else
#define NV_INLINE
#endif

#endif  /* ! WIN32 */

#define NV_CAPI	NV_APIENTRY


 /***************************************************************************\
|*                              NV OS Functions                              *|
 \***************************************************************************/

/*
	Note:
		This version of the architecture has been changed to allow the 
		RM to return a client handle that will subsequently used to
		identify the client.  NvAllocRoot() returns the handle.  All
		other functions must specify this client handle. 

*/
/* macro NV01_FREE */
#define  NV01_FREE                                                 (0x00000000)

/* parameter values */
#define NVOS00_STATUS_SUCCESS                                      (0x00000000)
#define NVOS00_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS00_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS00_STATUS_ERROR_BAD_OBJECT_OLD                         (0x00000003)
#define NVOS00_STATUS_ERROR_OBJECT_IN_USE                          (0x00000004)
#define NVOS00_STATUS_ERROR_OBJECT_HAS_CHILDERN                    (0x00000005)


/* NT ioctl data structure */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectOld;
  NvV32 status;
} NVOS00_PARAMETERS;

/* macro NV01_ALLOC_ROOT */
#define  NV01_ALLOC_ROOT                                           (0x00000001)

/* status values */
#define NVOS01_STATUS_SUCCESS                                      (0x00000000)
#define NVOS01_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS01_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS01_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS01_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS01_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 status;
} NVOS01_PARAMETERS;

/* valid hClass values. */
#define  NV01_ROOT                                                 (0x00000000)
#define  NV01_ROOT_USER                                            (0x00000041)

/* macro NV01_ALLOC_MEMORY */
#define  NV01_ALLOC_MEMORY                                         (0x00000002)

/* parameter values */
#define NVOS02_FLAGS_PHYSICALITY                                   7:4
#define NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS                        (0x00000000)
#define NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS                     (0x00000001)
#define NVOS02_FLAGS_LOCATION                                      11:8
#define NVOS02_FLAGS_LOCATION_PCI                                  (0x00000000)
#define NVOS02_FLAGS_LOCATION_AGP                                  (0x00000001)
#define NVOS02_FLAGS_COHERENCY                                     15:12
#define NVOS02_FLAGS_COHERENCY_UNCACHED                            (0x00000000)
#define NVOS02_FLAGS_COHERENCY_CACHED                              (0x00000001)
#define NVOS02_FLAGS_COHERENCY_WRITE_COMBINE                       (0x00000002)
#define NVOS02_FLAGS_COHERENCY_WRITE_THROUGH                       (0x00000003)
#define NVOS02_FLAGS_COHERENCY_WRITE_PROTECT                       (0x00000004)
#define NVOS02_FLAGS_COHERENCY_WRITE_BACK                          (0x00000005)
#define NVOS02_STATUS_SUCCESS                                      (0x00000000)
#define NVOS02_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS02_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS02_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS02_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS02_STATUS_ERROR_BAD_FLAGS                              (0x00000005)
#define NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 flags;
  NvP64 pMemory;
  NvU64 pLimit;
  NvV32 status;
} NVOS02_PARAMETERS;

/* macro NV01_ALLOC_CONTEXT_DMA */
#define  NV01_ALLOC_CONTEXT_DMA                                    (0x00000003)

/* parameter values */
#define NVOS03_FLAGS_ACCESS                                        3:0
#define NVOS03_FLAGS_ACCESS_READ_WRITE                             (0x00000000)
#define NVOS03_FLAGS_ACCESS_READ_ONLY                              (0x00000001)
#define NVOS03_FLAGS_ACCESS_WRITE_ONLY                             (0x00000002)
#define NVOS03_FLAGS_PHYSICALITY                                   7:4
#define NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS                        (0x00000000)
#define NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS                     (0x00000001)
#define NVOS03_FLAGS_LOCKED                                        11:8
#define NVOS03_FLAGS_LOCKED_ALWAYS                                 (0x00000000)
#define NVOS03_FLAGS_LOCKED_IN_TRANSIT                             (0x00000001)
#define NVOS03_FLAGS_COHERENCY                                     31:12
#define NVOS03_FLAGS_COHERENCY_UNCACHED                            (0x00000000)
#define NVOS03_FLAGS_COHERENCY_CACHED                              (0x00000001)
#define NVOS03_STATUS_SUCCESS                                      (0x00000000)
#define NVOS03_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS03_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS03_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS03_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS03_STATUS_ERROR_BAD_FLAGS                              (0x00000005)
#define NVOS03_STATUS_ERROR_BAD_BASE                               (0x00000006)
#define NVOS03_STATUS_ERROR_BAD_LIMIT                              (0x00000007)
#define NVOS03_STATUS_ERROR_PROTECTION_FAULT                       (0x00000008)
#define NVOS03_STATUS_ERROR_MULTIPLE_MEMORY_TYPES                  (0x00000009)
#define NVOS03_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x0000000A)

/* parameters */
typedef struct
{
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 flags;
    NvP64 pBase;
    NvU64 limit;
    NvV32 status;
} NVOS03_PARAMETERS;

/* macro NV01_ALLOC_CHANNEL_PIO */
#define  NV01_ALLOC_CHANNEL_PIO                                    (0x00000004)

/* parameter values */
#define NVOS04_FLAGS_FIFO_RUNOUT_IGNORE                            (0x00000000)
#define NVOS04_FLAGS_FIFO_RUNOUT_ERROR                             (0x00000001)
#define NVOS04_STATUS_SUCCESS                                      (0x00000000)
#define NVOS04_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS04_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR                       (0x00000005)
#define NVOS04_STATUS_ERROR_BAD_FLAGS                              (0x00000006)
#define NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000007)

/* parameters */
typedef struct
{
    NvV32 hRoot;
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
    NvV32 hObjectError;
    NvP64 pChannel;
    NvV32 flags;
    NvV32 status;
} NVOS04_PARAMETERS;

/* macro NV01_ALLOC_OBJECT */
#define  NV01_ALLOC_OBJECT                                         (0x00000005)

/* parameter values */
#define NVOS05_STATUS_SUCCESS                                      (0x00000000)
#define NVOS05_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS05_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS05_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS05_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 status;
} NVOS05_PARAMETERS;

// ***** this has been changed to allow a device name string to be returned
/* macro NV01_ALLOC_DEVICE */
#define  NV01_ALLOC_DEVICE                                         (0x00000006)

/* parameter values */
#define NVOS06_STATUS_SUCCESS                                      (0x00000000)
#define NVOS06_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS06_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS06_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct
{
    NvV32 hObjectParent;
    NvV32 hObjectNew;
    NvV32 hClass;
#if _WIN32_WINNT >= 0x0400
    NvP64 szName;
#else
    NvV32 szName;
#endif
    NvV32 status;
} NVOS06_PARAMETERS;

/* macro NV03_ALLOC_CHANNEL_DMA */
#define  NV03_ALLOC_CHANNEL_DMA                                    (0x00000007)

/* parameter values */
#define NVOS07_STATUS_SUCCESS                                      (0x00000000)
#define NVOS07_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS07_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_ERROR                       (0x00000005)
#define NVOS07_STATUS_ERROR_BAD_OBJECT_BUFFER                      (0x00000006)
#define NVOS07_STATUS_ERROR_BAD_OFFSET                             (0x00000007)
#define NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000008)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 hObjectError;
  NvV32 hObjectBuffer;
  NvU32 offset;
  NvP64 pControl;
  NvV32 status;
} NVOS07_PARAMETERS;

/* macro NV03_DMA_FLOW_CONTROL */
#define  NV03_DMA_FLOW_CONTROL                                     (0x00000008)

/* parameter values */
#define NVOS08_FLAGS_PUT                                           3:0
#define NVOS08_FLAGS_PUT_IGNORE                                    (0x00000000)
#define NVOS08_FLAGS_PUT_UPDATE                                    (0x00000001)
#define NVOS08_FLAGS_JUMP                                          31:4
#define NVOS08_FLAGS_JUMP_IGNORE                                   (0x00000000)
#define NVOS08_FLAGS_JUMP_UPDATE                                   (0x00000001)
#define NVOS08_STATUS_SUCCESS                                      (0x00000000)
#define NVOS08_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS08_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS08_STATUS_ERROR_BAD_FLAGS                              (0x00000003)
#define NVOS08_STATUS_ERROR_BAD_PUT                                (0x00000004)

/* parameters */
typedef struct
{
  NvV32 hChannel;
  NvV32 flags;
  NvU32 put;
  NvU32 get;
  NvV32 status;
} NVOS08_PARAMETERS;

/* macro NV01_INTERRUPT */
#define  NV01_INTERRUPT                                            (0x00000009)

/* parameter values */
#define NVOS09_STATUS_SUCCESS                                      (0x00000000)
#define NVOS09_STATUS_ERROR_BAD_CLIENT                             (0x00000001)
#define NVOS09_STATUS_ERROR_BAD_DEVICE                             (0x00000002)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 status;
} NVOS09_PARAMETERS;

/* macro NV01_ALLOC_EVENT */
#define  NV01_ALLOC_EVENT                                          (0x0000000A)

/* parameter values */
#define NVOS10_STATUS_SUCCESS                                      (0x00000000)
#define NVOS10_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS10_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS10_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000003)
#define NVOS10_STATUS_ERROR_BAD_CLASS                              (0x00000004)
#define NVOS10_STATUS_ERROR_BAD_INDEX                              (0x00000005)
#define NVOS10_STATUS_ERROR_BAD_EVENT                              (0x00000006)
#define NVOS10_STATUS_ERROR_OBJECT_IN_USE                          (0x00000007)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvV32 index;
  NvU64 hEvent;
  NvV32 status;
} NVOS10_PARAMETERS;

/* Valid values for hClass in Nv01AllocEvent */
/* Note that NV01_EVENT_OS_EVENT is same as NV01_EVENT_WIN32_EVENT */
/* TODO: delete the WIN32 name */
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#define  NV01_EVENT_OS_EVENT                                       (0x00000079)
#define  NV01_EVENT_WIN32_EVENT                                    NV01_EVENT_OS_EVENT

//
// There's some definite ugly reuse of args in NV01_ARCH_HEAP for the various
// functions. We'd like to rename field names when adding funcs, so the args
// go in the appropriate places.
//
// For example, adding HEAP_INFO_FREE_BLOCKS, should take offset/offset2 args,
// but because it's not a union and some of the drivers refer to their own typedef
// for the struct, we reuse field names that don't apply to the func.
//

/* funct NV03_HEAP */
#define  NV01_ARCH_HEAP                                            (0x0000000B)
/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvU32 function;
  NvU32 owner;
  NvU32 type;       /* holds 16bits of flags and 16bits of type */
  NvU32 depth;
  NvU32 width;
  NvU32 height;
  NvS32 pitch;
  NvU32 offset;     // for NVOS11_HEAP_INFO_FREE_BLOCKS, offset to be considered freed
  NvU32 size;       // for NVOS11_HEAP_INFO, size of largest free block
#if _WIN32_WINNT >= 0x0400
  NvP64 address;    // for NVOS11_HEAP_INFO, base address of heap
#else
  NvU32 address;    // for NVOS11_HEAP_INFO, base address of heap
#endif
  NvU32 limit;      // for NVOS11_HEAP_INFO_FREE_BLOCKS, offset to be considered freed
  NvU32 total;
  NvU32 free;
  NvV32 status;
} NVOS11_PARAMETERS;
/* parameter values */
#define NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define NVOS11_HEAP_ALLOC_SIZE                      2
#define NVOS11_HEAP_FREE                            3
#define NVOS11_HEAP_PURGE                           4
#define NVOS11_HEAP_INFO                            5
#define NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define NVOS11_HEAP_DESTROY                         7
#define NVOS11_HEAP_INFO_FREE_BLOCKS                8
#define NVOS11_TYPE_IMAGE                           0
#define NVOS11_TYPE_DEPTH                           1
#define NVOS11_TYPE_TEXTURE                         2
#define NVOS11_TYPE_VIDEO_OVERLAY                   3
#define NVOS11_TYPE_FONT                            4
#define NVOS11_TYPE_CURSOR                          5
#define NVOS11_TYPE_DMA                             6
#define NVOS11_TYPE_INSTANCE                        7
#define NVOS11_TYPE_PRIMARY                         8
#define NVOS11_TYPE_IMAGE_TILED                     9
#define NVOS11_TYPE_DEPTH_COMPR16                   10
#define NVOS11_TYPE_DEPTH_COMPR32                   11
#define NVOS11_TYPE_FLAGS                                31:16
#define NVOS11_TYPE_FLAGS_IGNORE_BANK_PLACEMENT     0x00000001
#define NVOS11_TYPE_FLAGS_FORCE_MEM_GROWS_UP        0x00000002
#define NVOS11_TYPE_FLAGS_FORCE_MEM_GROWS_DOWN      0x00000004
#define NVOS11_INVALID_BLOCK_FREE_OFFSET            0xFFFFFFFF
#define NVOS11_STATUS_SUCCESS                       (0x00000000)
#define NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define NVOS11_STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define NVOS11_STATUS_ERROR_INVALID_OWNER           (0x00000003)
#define NVOS11_STATUS_ERROR_INVALID_HEAP            (0x00000004)

/* function OS0C */
#define  NV01_CONFIG_VERSION                                       (0x0000000C)

/* parameter values */
#define NVOS12_STATUS_SUCCESS                                      (0x00000000)
#define NVOS12_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS12_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS12_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS12_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 version;
  NvV32 status;
} NVOS12_PARAMETERS;

/* function OS0D */
#define  NV01_CONFIG_GET                                           (0x0000000D)

/* parameter values */
#define NVOS13_STATUS_SUCCESS                                      (0x00000000)
#define NVOS13_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS13_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS13_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS13_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS13_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 value;
  NvV32 status;
} NVOS13_PARAMETERS;

/* function OS0E */
#define  NV01_CONFIG_SET                                           (0x0000000E)

/* parameter values */
#define NVOS14_STATUS_SUCCESS                                      (0x00000000)
#define NVOS14_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS14_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS14_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS14_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS14_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 oldValue;
  NvV32 newValue;
  NvV32 status;
} NVOS14_PARAMETERS;

/* function OS0F */
#define  NV01_CONFIG_UPDATE                                        (0x0000000F)

/* parameter values */
#define NVOS15_STATUS_SUCCESS                                      (0x00000000)
#define NVOS15_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS15_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS15_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS15_STATUS_ERROR_BAD_FLAGS                              (0x00000004)
#define NVOS15_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 flags;
  NvV32 status;
} NVOS15_PARAMETERS;

/* function OS16 */
#define  NV04_RING0_CALLBACK                                        (0x00000010)

/* parameter values */
#define NVOS16_STATUS_SUCCESS                                       (0x00000000)

/* callback function prototype */
typedef NvU32 (*RING0CALLBACKPROC)(NvU32, NvU32);

/* parameters */
typedef struct
{
    NvV32             hClient;
    NvV32             hDevice;
#if _WIN32_WINNT >= 0x0400
    NvP64             functionPtr;
#else
    RING0CALLBACKPROC functionPtr;
#endif
    NvU32             param1;
    NvU32             param2;
    NvV32             status;
} NVRM_RING0CALLBACK_PARAMS;

/* function OS17 */
#define  NV04_CONFIG_GET_EX                                        (0x00000011)

/* parameter values */
#define NVOS_CGE_STATUS_SUCCESS                                    (0x00000000)
#define NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM                     (0x00000001)
#define NVOS_CGE_STATUS_ERROR_BAD_CLIENT                           (0x00000002)
#define NVOS_CGE_STATUS_ERROR_BAD_DEVICE                           (0x00000003)
#define NVOS_CGE_STATUS_ERROR_BAD_INDEX                            (0x00000004)
#define NVOS_CGE_STATUS_ERROR_INSUFFICIENT_RESOURCES               (0x00000005)
#define NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT                     (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_CONFIG_GET_EX_PARAMS;

/* function OS18 */
#define  NV04_CONFIG_SET_EX                                        (0x00000012)

/* parameter values */
#define NVOS_CSE_STATUS_SUCCESS                                    (0x00000000)
#define NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM                     (0x00000001)
#define NVOS_CSE_STATUS_ERROR_BAD_CLIENT                           (0x00000002)
#define NVOS_CSE_STATUS_ERROR_BAD_DEVICE                           (0x00000003)
#define NVOS_CSE_STATUS_ERROR_BAD_INDEX                            (0x00000004)
#define NVOS_CSE_STATUS_ERROR_INSUFFICIENT_RESOURCES               (0x00000005)
#define NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT                     (0x00000006)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_CONFIG_SET_EX_PARAMS;

/* function OS19 */
#define  NV04_I2C_ACCESS                                           (0x00000013)

/* parameter values */
#define NVOS_I2C_ACCESS_STATUS_SUCCESS                             (0x00000000)
#define NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM              (0x00000001)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT                    (0x00000002)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_DEVICE                    (0x00000003)
#define NVOS_I2C_ACCESS_STATUS_ERROR_INSUFFICIENT_RESOURCES        (0x00000004)
#define NVOS_I2C_ACCESS_STATUS_ERROR_BAD_PARAM_STRUCT              (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_I2C_ACCESS_PARAMS;

/* function OS20 */
#define  NV01_DEBUG_CONTROL                                        (0x000000014)

/* parameter values */
#define NVOS20_STATUS_SUCCESS                                      (0x00000000)
#define NVOS20_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS20_STATUS_ERROR_BAD_DEVICE                             (0x00000002)
#define NVOS20_STATUS_ERROR_BAD_FLAGS                              (0x00000003)
#define NVOS20_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000004)

/* parameters */
typedef struct 
{
    NvV32 hRoot;
    NvV32 command;
    NvP64 pArgs;
    NvV32 status;
} NVOS20_PARAMETERS;

/* current values for command */
#define NVOS20_COMMAND_RM_FAILURE_ENABLE           0x0001
#define NVOS20_COMMAND_RM_FAILURE_DISABLE          0x0002

/* function OS21 */
#define  NV04_ALLOC                                                (0x00000015)

/* parameter values */
#define NVOS21_STATUS_SUCCESS                                      (0x00000000)
#define NVOS21_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS21_STATUS_ERROR_BAD_ROOT                               (0x00000002)
#define NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000003)
#define NVOS21_STATUS_ERROR_BAD_OBJECT_NEW                         (0x00000004)
#define NVOS21_STATUS_ERROR_BAD_CLASS                              (0x00000005)
#define NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectNew;
  NvV32 hClass;
  NvP64 pAllocParms;
  NvV32 status;
} NVOS21_PARAMETERS;

/* function OS22 */
#define  NV04_POWER_MANAGEMENT                                     (0x00000016)

/* parameter values */
#define NVOS22_STATUS_SUCCESS                                      (0x00000000)
#define NVOS22_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS22_STATUS_ERROR_BAD_ROOT                               (0x00000002)
#define NVOS22_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000003)
#define NVOS22_STATUS_ERROR_BAD_CLASS                              (0x00000005)
#define NVOS22_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000006)
#define NVOS22_STATUS_ERROR_NO_DEVICE                              (0x00000007)

/* parameters */
typedef struct
{
  NvV32 hRoot;
  NvV32 hDevice;
  NvV32 command;
  NvV32 head;
  void *params;
  NvV32 status;
} NVOS22_PARAMETERS;

/* Command values */

#define NVOS22_POWER_SLEEP               0x0001
#define NVOS22_POWER_WAKE                0x0002
#define NVOS22_POWER_WAKE_BIOS_HAS_RUN   0x0003
#define NVOS22_POWER_DOZE                0x0004
#define NVOS22_POWER_WAKE_TO_DOZE        0x0005
#define NVOS22_POWER_GET_LEVEL           0x0008

/* function OS21 */
#define  NV10_AGP_INIT                                             (0x000000015)
#define  NV10_AGP_TEARDOWN                                         (0x000000016)

/* parameters */
typedef struct 
{
  NvV32 hDevice;
  NvV32 config;
  NvV32 status;
} NVOS_AGP_PARAMS;

/* parameter values */
#define NVOS_AGP_CONFIG_DISABLE_AGP                            	        (0x00000000)
#define NVOS_AGP_CONFIG_NVAGP                                           (0x00000001)
#define NVOS_AGP_CONFIG_AGPGART                                         (0x00000002)
#define NVOS_AGP_CONFIG_ANYAGP                                          (0x00000003)

#define NVOS_AGP_STATUS_SUCCESS                             		(0x00000000)
#define NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM              		(0x00000001)
#define NVOS_AGP_STATUS_ERROR_BAD_CLIENT                           	(0x00000002)
#define NVOS_AGP_STATUS_ERROR_BAD_DEVICE                           	(0x00000003)

/* function OS25 */
#define NV04_OSCONFIG_SET                                           (0x00000019)

/* parameter values */
#define NVOS25_STATUS_SUCCESS                                      (0x00000000)
#define NVOS25_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS25_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS25_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS25_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS25_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 oldValue;
  NvV32 newValue;
  NvV32 status;
} NVOS25_PARAMETERS;

/* function OS26 */
#define NV04_OSCONFIG_GET                                           (0x0000001A)

/* parameter values */
#define NVOS26_STATUS_SUCCESS                                      (0x00000000)
#define NVOS26_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS26_STATUS_ERROR_BAD_CLIENT                             (0x00000002)
#define NVOS26_STATUS_ERROR_BAD_DEVICE                             (0x00000003)
#define NVOS26_STATUS_ERROR_BAD_INDEX                              (0x00000004)
#define NVOS26_STATUS_ERROR_INSUFFICIENT_RESOURCES                 (0x00000005)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
  NvV32 value;
  NvV32 status;
} NVOS26_PARAMETERS;

/* function OS27 */
#define NV04_OSCONFIG_GET_EX                                        (0x0000001B)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_OSCONFIG_GET_EX_PARAMS;

/* function OS28 */
#define NV04_OSCONFIG_SET_EX                                        (0x0000001C)

/* parameters */
typedef struct 
{
  NvV32 hClient;
  NvV32 hDevice;
  NvV32 index;
#if _WIN32_WINNT >= 0x0400
  NvP64 paramStructPtr;
#else
  NvV32 paramStructPtr;
#endif
  NvU32 paramSize;
  NvV32 status;
} NVOS_OSCONFIG_SET_EX_PARAMS;

/* macro NV04_DIRECT_METHOD_CALL */
#define NV04_DIRECT_METHOD_CALL                                    (0x0000001D)

/* parameter values */
#define NVOS1D_STATUS_SUCCESS                                      (0x00000000)
#define NVOS1D_STATUS_ERROR_OPERATING_SYSTEM                       (0x00000001)
#define NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT                      (0x00000002)
#define NVOS1D_STATUS_ERROR_BAD_OBJECT_OLD                         (0x00000003)
#define NVOS1D_STATUS_ERROR_BAD_METHOD                             (0x00000004)
#define NVOS1D_STATUS_ERROR_BAD_DATA                               (0x00000005)

/* NT ioctl data structure */
typedef struct
{
  NvV32 hRoot;
  NvV32 hObjectParent;
  NvV32 hObjectOld;
  NvV32 method;
  NvV32 data;
  NvV32 status;
} NVOS1D_PARAMETERS;

#define NV04_UNIFIED_FREE											(0x0000001E)

#define NVOS1E_STATUS_SUCCESS										(0x00000000)
#define NVOS1E_STATUS_ERROR_OPERATING_SYSTEM						(0x00000001)
#define NVOS1E_STATUS_ERROR_OBJECT_IN_USE							(0x00000004)

/* NT ioctl data structure */
typedef struct
{
	NvV32	hClient;
	NvV32	hClass;
	NvU32	uDeviceRef;
	NvP64	pParam;
	NvV32	status;
} NV_UNIFIED_FREE;


#ifdef __cplusplus
};
#endif
#endif /* NVOS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\NvImage.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: NvImage.h                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    10/03/2000  Created                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVIMAGE_H_
#define _NVIMAGE_H_

#ifdef  DEFINE_JPEG_TYPES
#include <stdio.h>
#include <string.h>
#include "jpeglib.h"
#else   //~DEFINE_JPEG_TYPES
struct jpeg_decompress_struct {
    DWORD Pan;
};
typedef BYTE JSAMPLE;
#endif  //~DEFINE_JPEG_TYPES

typedef void (__stdcall *SCANLINEPROCESS)(void *, int);

typedef enum _JPEGParameterType_ {
    JPEG_WRITE_QUALITY      = 1,
    JPEG_READ_DEPTH         = 2,
} JPEGPARAMETERTYPE;

#ifdef __cplusplus

typedef class CImageObject
{
    /*
     * methods
     */
public:
    virtual void WINAPI CompressJPEG (void *pAddr, DWORD dwWidth, DWORD dwHeight, char * filename);
    virtual void WINAPI GetJPEGInfo (char * filename, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    virtual DWORD WINAPI SetJPEGParameters (JPEGPARAMETERTYPE type, DWORD value);
    virtual void WINAPI DecompressJPEG (char * filename, SCANLINEPROCESS ScanlineProcess);
    virtual void WINAPI DecompressJPEG (char * filename);
    virtual void WINAPI GetImageParameters (char *&Start, char *&Current, DWORD &Width, DWORD &Height, DWORD &BPP);
    virtual DWORD WINAPI DestroyImageObject(void);
    CImageObject();
    ~CImageObject();
protected:
    void write_JPEG_file (char * filename, int quality);
    int  get_JPEG_file_info (char * filename, struct jpeg_decompress_struct *pCinfo);
    int  read_JPEG_file (char * filename, SCANLINEPROCESS ScanlineProcess);
    void __stdcall InternalScanlineProcess(LPVOID pBuf, int stride);
protected:
    int       out_quality;          /* Specify quality of the subsequent compression 0-100, 100 being highest. */ 
    JSAMPLE * out_image_buffer;	    /* Points to large array of R,G,B-order data */
    int       out_image_height;	    /* Number of rows in image */
    int       out_image_width;		/* Number of columns in image */
    char     *image_buffer;
    char     *image_ptr;
    DWORD     image_width; 
    DWORD     image_height; 
    DWORD     image_depth;  
} CIMAGEOBJECT, *LPCIMAGEOBJECT;


typedef DWORD (WINAPI *CREATEIMAGEOBJECT)(LPCIMAGEOBJECT &pImageOpject);
extern DWORD WINAPI CreateImageObject(LPCIMAGEOBJECT &pImageOpject);

#else   //__cplusplus==0

typedef struct CImageObject
{
    struct  CImageObjectVtbl FAR *lpVtbl;
} CIMAGEOBJECT, *LPCIMAGEOBJECT;

struct  CImageObjectVtbl {
    void    (WINAPI *CompressJPEG)(LPCIMAGEOBJECT, void *pAddr, DWORD dwWidth, DWORD dwHeight, char * filename);
    void    (WINAPI *GetJPEGInfo)(LPCIMAGEOBJECT, char * filename, DWORD *pWidth, DWORD *pHeight, DWORD *pBPP);
    DWORD   (WINAPI *SetJPEGParameters)(LPCIMAGEOBJECT, JPEGPARAMETERTYPE type, DWORD value);
    void    (WINAPI *DecompressJPEGCustom)(LPCIMAGEOBJECT, char * filename, SCANLINEPROCESS ScanlineProcess);
    void    (WINAPI *DecompressJPEG)(LPCIMAGEOBJECT, char * filename);
    void    (WINAPI *GetImageParameters)(LPCIMAGEOBJECT, char **Start, char **Current, DWORD *Width, DWORD *Height, DWORD *BPP);
    DWORD   (WINAPI *DestroyImageObject)(LPCIMAGEOBJECT);
};


typedef DWORD (WINAPI *CREATEIMAGEOBJECT)(LPCIMAGEOBJECT *pImageOpject);
extern DWORD WINAPI CreateImageObject(LPCIMAGEOBJECT *pImageOpject);

#endif  //__cplusplus==0

#endif _NVIMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvrmarch.inc ===
;/*
;-----------------------------Module-Header-----------------------------;
; Module Name:  NVRMARCH.INC
;
;  Constants for interface to the Resource Manager
;
; Created: 6/12/98
; Author:  ARG
;
; Copyright (C) 1993,1998 NVidia Corporation. All Rights Reserved.
;
; History:
;-----------------------------------------------------------------------;

ifndef  NVRMARCH_INCLUDED
; This seems to break the stupid assembler in strange and mysterious
; ways.  It appears that this file is re-read on the second pass, or
; at least is reevaluated, which produces "phase errors" galore because
; the condition is now different.  This is not rocket science.
;NVRMARCH_INCLUDED       equ     1

comment ~  */

#ifndef NVRMARCH_INCLUDED
#define NVRMARCH_INCLUDED       1

/* ~


ORD_WEP                                 equ      1
ORD_NvSysDispatch                       equ      3
ORD_NvSysNotifyCallback                 equ      4
ORD_NvSysIpcCallback                    equ      5
ORD_NvSysClientExit                     equ      6
ORD_NVSysSetCursor                      equ      7
ORD_NvSysMoveCursor                     equ      8
ORD_NvSysGetScreenInfo                  equ      9
ORD_NvSysOpen                           equ      10
ORD_NvSysClose                          equ      11
ORD_NvSysGetRamInfo                     equ      12
ORD_NvSysSetCanvasRect                  equ      13
ORD_NvSysSetCanvasClip                  equ      14
ORD_NvSysInstallCallback                equ      15
ORD_NvSysAllocPages                     equ      16
ORD_NvSysFreePages                      equ      17
ORD_NvInstallCallback                   equ      22
ORD_NvSysGetBufferInfo                  equ      23
ORD_NvSysSetCanvas                      equ      24
ORD_NvConfigGet                         equ      25
ORD_NvConfigSet                         equ      26
ORD_NvConfigUpdate                      equ      27
ORD_NvConfigVersion                     equ      28
ORD_NvConfigVga                         equ      29
ORD_NvSysSetCanvasRegion                equ      30
ORD_NvSysSetCursorImage                 equ      35
ORD_NvSysMoveCursorMulti                equ      36
ORD_NvSysSetCursorImageMulti            equ      37
ORD_NvSysUpdateImageOffsetFormat        equ      38
ORD_DllEntryPoint                       equ      40
ORD_THK_ThunkData16                     equ      41
ORD_NvSysGetHardwarePointers            equ      50
ORD_NvDeviceBaseGet                     equ      51
ORD_NvDeviceLimitGet                    equ      52
ORD_NvDeviceSelectorGet                 equ      53
ORD_NvSysGetCurrentBufferFlatPointer    equ      54
ORD_NvSysSetColorCursor                 equ      70
ORD_NvSysShowHideCursor                 equ      71
ORD_NvSysGetCursorEmulatePosPointers    equ      72
ORD_NvSysFlushFifo                      equ      80
ORD_NvSysDisplayModeHook                equ      90
ORD_NvSysLockPages                      equ      100
ORD_NvSysUnlockPages                    equ      101
ORD_NvSysDriverConnect                  equ      102
ORD_NvSysDriverDisConnect               equ      103
ORD_NvSysClearScreen                    equ      200
ORD_NvSysRegisterDisplayDriver          equ      201
ORD_NvIoControl                         equ      299
ORD_Nv01Free                            equ      300
ORD_Nv01AllocRoot                       equ      301
ORD_Nv01AllocMemory                     equ      302
ORD_Nv01AllocContextDma                 equ      303
ORD_Nv01AllocChannelPio                 equ      304
ORD_Nv01AllocObject                     equ      305
ORD_Nv01AllocDevice                     equ      306
ORD_Nv03AllocChannelDma                 equ      307
ORD_Nv03DmaFlowControl                  equ      308
ORD_Nv01Interrupt                       equ      309
ORD_Nv01AllocEvent                      equ      310
ORD_NvI2CAccess                         equ      311
ORD_Nv04ConfigGetEx                     equ      312
ORD_Nv04ConfigSetEx                     equ      313
ORD_Nv04Alloc                           equ      314

; GDI and Video channel HANDLE definitions

NV_WIN_ROOT                                     equ             00002001h
NV_WIN_DEVICE                                   equ             00002002h
NV_WIN_CHANNEL                                  equ             00002003h

;
; GDI Context Dma Handles
;

NV_WIN_CONTEXT_DMA_TO_SYS_MEMORY                EQU             00001000h
NV_WIN_WB_CONTEXT_DMA_TO_VIDEO_MEMORY           EQU             00001002h
NV_WIN_WB_CONTEXT_DMA_TO_SYS_MEMORY             EQU             00001003h
NV_WIN_NOTIFIER_CONTEXT_DMA_TO_MEMORY           EQU             00001005h
NV_WIN_PUSHER_NOTIFIER_CONTEXT_DMA_TO_MEMORY    EQU             00001007h
NV_WIN_CONTEXT_DMA_IN_MEMORY                    EQU             00001010h
NV_WIN_CONTEXT_DMA_FROM_VIDEO_MEMORY            EQU             00001012h
NV_WIN_CONTEXT_DMA_FROM_MEMORY                  EQU             00001015h
NV_WIN_WB_CONTEXT_DMA_FROM_SYS_MEMORY           EQU             00001017h
NV_WIN_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT           EQU             00001020h
NV_WIN_WB_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT        EQU             00001022h

NV01_NULL_OBJECT                                equ             0

comment ~
*/

#define ORD_WEP                                  1
#define ORD_NvSysDispatch                        3
#define ORD_NvSysNotifyCallback                  4
#define ORD_NvSysIpcCallback                     5
#define ORD_NvSysClientExit                      6
#define ORD_NVSysSetCursor                       7
#define ORD_NvSysMoveCursor                      8
#define ORD_NvSysGetScreenInfo                   9
#define ORD_NvSysOpen                            10
#define ORD_NvSysClose                           11
#define ORD_NvSysGetRamInfo                      12
#define ORD_NvSysSetCanvasRect                   13
#define ORD_NvSysSetCanvasClip                   14
#define ORD_NvSysInstallCallback                 15
#define ORD_NvSysAllocPages                      16
#define ORD_NvSysFreePages                       17
#define ORD_NvInstallCallback                    22
#define ORD_NvSysGetBufferInfo                   23
#define ORD_NvSysSetCanvas                       24
#define ORD_NvConfigGet                          25
#define ORD_NvConfigSet                          26
#define ORD_NvConfigUpdate                       27
#define ORD_NvConfigVersion                      28
#define ORD_NvConfigVga                          29
#define ORD_NvSysSetCanvasRegion                 30
#define ORD_NvSysSetCursorImage                  35
#define ORD_DllEntryPoint                        40
#define ORD_THK_ThunkData16                      41
#define ORD_NvSysGetHardwarePointers             50
#define ORD_NvDeviceBaseGet                      51
#define ORD_NvDeviceLimitGet                     52
#define ORD_NvDeviceSelectorGet                  53
#define ORD_NvSysGetCurrentBufferFlatPointe      54
#define ORD_NvSysSetColorCursor                  70
#define ORD_NvSysShowHideCursor                  71
#define ORD_NvSysGetCursorEmulatePosPointer      72
#define ORD_NvSysFlushFifo                       80
#define ORD_NvSysDisplayModeHook                 90
#define ORD_NvSysLockPages                       100
#define ORD_NvSysUnlockPages                     101
#define ORD_NvSysDriverConnect                   102
#define ORD_NvSysDriverDisConnect                103
#define ORD_NvSysClearScreen                     200
#define ORD_NvIoControl                          299
#define ORD_Nv01Free                             300
#define ORD_Nv01AllocRoot                        301
#define ORD_Nv01AllocMemory                      302
#define ORD_Nv01AllocContextDma                  303
#define ORD_Nv01AllocChannelPio                  304
#define ORD_Nv01AllocObject                      305
#define ORD_Nv01AllocDevice                      306
#define ORD_Nv03AllocChannelDma                  307
#define ORD_Nv03DmaFlowControl                   308
#define ORD_Nv01Interrupt                        309
#define ORD_Nv01AllocEvent                       310
#define ORD_NvI2CAccess                          311


// GDI and Video channel HANDLE definitions

#define NV_WIN_ROOT                              0x00002001
#define NV_WIN_DEVICE                            0x00002002
#define NV_WIN_CHANNEL                           0x00002003

/* ~


;  funct NV01_ALLOC_ROOT parameters
ALLOC_ROOT_PARAM    STRUC           ;                   */ typedef struct {                 /*
    ALLOC_ROOT_hObjectNew   dd  ?   ; client handle ret */ unsigned long    hObjectNew;     /*
    ALLOC_ROOT_hClass       dd  ?   ;                   */ unsigned long    hClass;         /*
    ALLOC_ROOT_status       dd  ?   ;                   */ unsigned long    status;         /*
ALLOC_ROOT_PARAM    ENDS            ;                   */ } Alloc_Root_Param;              /*

; Neat-o! MASM 5.20 is only good for 31 characters on identifiers!
; Equates definitions must be unique before this point:
;                              |

ALLOC_ROOT_STATUS_SUCCESS                       equ     00000000h
ALLOC_ROOT_STATUS_ERROR_OPERATING_SYSTEM        equ     00000001h
ALLOC_ROOT_STATUS_ERROR_BAD_PARENT_OBJECT       equ     00000002h
ALLOC_ROOT_STATUS_ERROR_BAD_NEW_OBJECT          equ     00000003h
ALLOC_ROOT_STATUS_ERROR_BAD_CLASS               equ     00000004h
ALLOC_ROOT_STATUS_ERROR_INSUFFICIENT_RESOURCES  equ     00000005h

ALLOC_ROOT_CLASS_ROOT                           equ     00000000h

Nv01AllocRoot_MAC macro buffer,hClass
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClass
        mov     [bx].ALLOC_ROOT_hClass,edx
        mov     [bx].ALLOC_ROOT_status,ALLOC_ROOT_STATUS_SUCCESS
        cCall   Nv01AllocRoot
        pop     edx
endm

comment ~  */

#define ALLOC_ROOT_STATUS_SUCCESS                       0x00000000
#define ALLOC_ROOT_STATUS_ERROR_OPERATING_SYSTEM        0x00000001
#define ALLOC_ROOT_STATUS_ERROR_BAD_PARENT_OBJECT       0x00000002
#define ALLOC_ROOT_STATUS_ERROR_BAD_NEW_OBJECT          0x00000003
#define ALLOC_ROOT_STATUS_ERROR_BAD_CLASS               0x00000004
#define ALLOC_ROOT_STATUS_ERROR_INSUFFICIENT_RESOURCES  0x00000005

#define ALLOC_ROOT_CLASS_ROOT                           0x00000000

/* ~


NVOS21_STATUS_SUCCESS                           equ     00000000
NVOS21_STATUS_ERROR_OPERATING_SYSTEM            equ     00000001
NVOS21_STATUS_ERROR_BAD_ROOT                    equ     00000002
NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT           equ     00000003
NVOS21_STATUS_ERROR_BAD_OBJECT_NEW              equ     00000004
NVOS21_STATUS_ERROR_BAD_CLASS                   equ     00000005
NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES      equ     00000006

ALLOC_PARAM      STRUC
  ALLOC_hRoot                   dd      ?
  ALLOC_hObjectParent           dd      ?
  ALLOC_hObjectNew              dd      ?
  ALLOC_hClass                  dd      ?
  ALLOC_pAllocParms             dd      ?
  ALLOC_Null                    dd      0       
  ALLOC_status                  dd      ?
ALLOC_PARAM      ENDS

ALLOC_DEV_PARAM    STRUC            ;                   */ typedef struct {                 /*
    ALLOC_DEV_hObjectParent dd  ?   ; client handle     */ unsigned long    hObjectParent;  /*
    ALLOC_DEV_hObjectNew    dd  ?   ;                   */ unsigned long    hObjectNew;     /*
    ALLOC_DEV_hClass        dd  ?   ;                   */ unsigned long    hClass;         /*
    ALLOC_DEV_szName        dd  ?   ;                   */ unsigned long    szName;         /*
    ALLOC_DEV_status        dd  ?   ;                   */ unsigned long    status;         /*
ALLOC_DEV_PARAM    ENDS             ;                   */ } Alloc_Dev_Param;               /*

ALLOC_DEV_STATUS_SUCCESS                        equ     00000000h
ALLOC_DEV_STATUS_ERR_OPERATING_SYSTEM           equ     00000001h
ALLOC_DEV_STATUS_ERR_BAD_PARENT_OBJECT          equ     00000002h
ALLOC_DEV_STATUS_ERR_BAD_NEW_OBJECT             equ     00000003h
ALLOC_DEV_STATUS_ERR_BAD_CLASS                  equ     00000004h
ALLOC_DEV_STATUS_ERR_INSUFFICIENT_RESOURCES     equ     00000005h

Nv01AllocDevice_MAC macro buffer,hObjectParent,hObjectNew,hClass,szName
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_DEV_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_DEV_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_DEV_hClass, edx

        lea     ax, szName              ; Flatten the device name
        mov     dx, ds

        DPMI_Flatten

        shl     edx, 16
        mov     dx, ax

        lea     bx, buffer
        mov     [bx].ALLOC_DEV_szName, edx
        mov     [bx].ALLOC_DEV_status,ALLOC_DEV_STATUS_SUCCESS
        cCall   Nv01AllocDevice
        pop     edx
endm

; THE C-EQUIVALENTS OF THESE DEFINITIONS ARE FOUND IN NV32.H
; KEEP THEM IN SYNC!
NV01_DEVICE_0                                   equ     00000080h
NV01_DEVICE_1                                   equ     00000081h
NV01_DEVICE_2                                   equ     00000082h
NV01_DEVICE_3                                   equ     00000083h
NV01_DEVICE_4                                   equ     00000084h
NV01_DEVICE_5                                   equ     00000085h
NV01_DEVICE_6                                   equ     00000086h
NV01_DEVICE_7                                   equ     00000087h
NV01_CONTEXT_DMA                                equ     00000002h
NV01_CONTEXT_DMA_FROM_MEMORY                    equ     00000002h
NV01_CONTEXT_DMA_TO_MEMORY                      equ     00000003h
NV01_CONTEXT_DMA_IN_MEMORY                      equ     0000003Dh
NV01_CONTEXT_ERROR_TO_MEMORY                    equ     0000003Eh
NV03_CHANNEL_PIO                                equ     0000006Ah
NV03_CHANNEL_DMA                                equ     0000006Bh
NV04_CHANNEL_DMA                                equ     0000006Ch
NV01_MEMORY_SYSTEM                              equ     0000003Eh
NV01_MEMORY_LOCAL_PRIVILEGED                    equ     0000003Fh
NV01_MEMORY_LOCAL_USER                          equ     00000040h

comment ~  */

#define ALLOC_DEV_STATUS_SUCCESS                        0x00000000
#define ALLOC_DEV_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_DEV_STATUS_ERR_BAD_OBJECT_PARENT          0x00000002
#define ALLOC_DEV_STATUS_ERR_BAD_OBJECT_NEW             0x00000003
#define ALLOC_DEV_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_DEV_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000005

/* ~

ALLOC_MEMORY_PARAM     STRUC           ;               */ typedef struct {                 /*
    ALLOC_MEMORY_hObjectClient dd  ?   ; client handle */ unsigned long    hObjectClient;  /*
    ALLOC_MEMORY_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_MEMORY_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_MEMORY_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_MEMORY_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_MEMORY_pBase         dd  ?   ;               */ unsigned long    pBase;          /*
                               dd  ?   ;               */ unsigned long    pBase_high;     /*
    ALLOC_MEMORY_pLimit        dd  ?   ;               */ unsigned long    pLimit;         /*
                               dd  ?   ;               */ unsigned long    pLimit_high;    /*
    ALLOC_MEMORY_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_MEMORY_PARAM     ENDS            ;               */ } Alloc_Memory_Param;            /*

ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY               equ 00000000h
ALLOC_MEMORY_FLAGS_NONCONTIGUOUS_PHYSICALITY            equ 00000010h

ALLOC_MEMORY_FLAGS_LOCATION_PCI                         equ 00000000h
ALLOC_MEMORY_FLAGS_LOCATION_AGP                         equ 00000100h

ALLOC_MEMORY_FLAGS_UNCACHED                             equ 00000000h
ALLOC_MEMORY_FLAGS_CACHED                               equ 00001000h
ALLOC_MEMORY_FLAGS_WRITE_COMBINE                        equ 00002000h
ALLOC_MEMORY_FLAGS_WRITE_THROUGH                        equ 00003000h
ALLOC_MEMORY_FLAGS_WRITE_PROTECT                        equ 00004000h
ALLOC_MEMORY_FLAGS_WRITE_BACK                           equ 00005000h

ALLOC_MEMORY_STATUS_SUCCESS                             equ 00000000h
ALLOC_MEMORY_STATUS_ERR_OPERATING_SYSTEM                equ 00000001h
ALLOC_MEMORY_STATUS_ERR_BAD_PARENT_OBJECT               equ 00000002h
ALLOC_MEMORY_STATUS_ERR_BAD_NEW_OBJECT                  equ 00000003h
ALLOC_MEMORY_STATUS_ERR_BAD_CLASS                       equ 00000004h
ALLOC_MEMORY_STATUS_ERR_BAD_FLAGS                       equ 00000005h
ALLOC_MEMORY_STATUS_ERR_INSUFFICIENT_RESOURCES          equ 00000006h

Nv01AllocMemory_MAC macro buffer,hObjectClient,hObjectParent,hObjectNew,hClass,flags,limit
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectClient
        mov     [bx].ALLOC_MEMORY_hObjectClient,edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_MEMORY_hObjectParent,edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_MEMORY_hObjectNew,edx
        mov     edx, hClass
        mov     [bx].ALLOC_MEMORY_hClass,edx
        mov     edx, flags
        mov     [bx].ALLOC_MEMORY_flags,edx
        mov     dword ptr [bx].ALLOC_MEMORY_pBase, 0
        mov     dword ptr [bx].ALLOC_MEMORY_pBase+4, 0
        mov     edx, limit
        mov     [bx].ALLOC_MEMORY_pLimit,edx
        mov     dword ptr [bx].ALLOC_MEMORY_pLimit+4, 0
        mov     [bx].ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        cCall   Nv01AllocMemory
        pop     edx
endm

comment ~  */

#define ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY               0x00000000
#define ALLOC_MEMORY_FLAGS_NONCONTIGUOUS_PHYSICALITY            0x00000010

#define ALLOC_MEMORY_FLAGS_LOCATION_PCI                         0x00000000
#define ALLOC_MEMORY_FLAGS_LOCATION_AGP                         0x00000100

#define ALLOC_MEMORY_FLAGS_UNCACHED                             0x00000000
#define ALLOC_MEMORY_FLAGS_CACHED                               0x00001000
#define ALLOC_MEMORY_FLAGS_WRITE_COMBINE                        0x00002000
#define ALLOC_MEMORY_FLAGS_WRITE_THROUGH                        0x00003000
#define ALLOC_MEMORY_FLAGS_WRITE_PROTECT                        0x00004000
#define ALLOC_MEMORY_FLAGS_WRITE_BACK                           0x00005000

#define ALLOC_MEMORY_STATUS_SUCCESS                             0x00000000
#define ALLOC_MEMORY_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define ALLOC_MEMORY_STATUS_ERR_BAD_PARENT_OBJECT               0x00000002
#define ALLOC_MEMORY_STATUS_ERR_BAD_NEW_OBJECT                  0x00000003
#define ALLOC_MEMORY_STATUS_ERR_BAD_CLASS                       0x00000004
#define ALLOC_MEMORY_STATUS_ERR_BAD_FLAGS                       0x00000005
#define ALLOC_MEMORY_STATUS_ERR_INSUFFICIENT_RESOURCES          0x00000006

/* ~

ALLOC_CTX_DMA_PARAM    STRUC            ;               */ typedef struct {                 /*
    ALLOC_CTX_DMA_hObjectParent dd  ?   ; client handle */ unsigned long    hObjectParent;  /*
    ALLOC_CTX_DMA_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CTX_DMA_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CTX_DMA_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_CTX_DMA_pBase         dd  ?   ;               */ unsigned long    pBase;          /*
                                dd  ?   ;               */ unsigned long    pBase_high;     /*
    ALLOC_CTX_DMA_limit         dd  ?   ;               */ unsigned long    limit;          /*
                                dd  ?   ;               */ unsigned long    limit_high;     /*
    ALLOC_CTX_DMA_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CTX_DMA_PARAM    ENDS             ;               */ } Alloc_Ctx_DMA_Param;           /*

ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                        equ 00000000h
ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                    equ 00000001h
ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY                   equ 00000002h

ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY              equ 00000000h
ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY           equ 00000010h

ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                       equ 00000000h
ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT                   equ 00000100h

ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED                  equ 00000000h
ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                    equ 00001000h

ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                       equ ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED

ALLOC_CTX_DMA_STATUS_SUCCESS                            equ 00000000h
ALLOC_CTX_DMA_STATUS_ERR_OPERATING_SYSTEM               equ 00000001h
ALLOC_CTX_DMA_STATUS_ERR_BAD_PARENT_OBJECT              equ 00000002h
ALLOC_CTX_DMA_STATUS_ERR_BAD_NEW_OBJECT                 equ 00000003h
ALLOC_CTX_DMA_STATUS_ERR_BAD_CLASS                      equ 00000004h
ALLOC_CTX_DMA_STATUS_ERR_BAD_FLAGS                      equ 00000005h
ALLOC_CTX_DMA_STATUS_ERR_BAD_BASE                       equ 00000006h
ALLOC_CTX_DMA_STATUS_ERR_BAD_LIMIT                      equ 00000007h
ALLOC_CTX_DMA_STATUS_ERR_PROTECTION_FAULT               equ 00000008h
ALLOC_CTX_DMA_STATUS_ERR_MULTIPLE_MEMORY_TYPES          equ 00000009h
ALLOC_CTX_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES         equ 0000000ah

Nv01AllocContextDma_MAC macro buffer,hObjectParent,hObjectNew,hClass,flags,sel,pBase,limit
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CTX_DMA_hObjectParent,edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CTX_DMA_hObjectNew,edx
        mov     edx, hClass
        mov     [bx].ALLOC_CTX_DMA_hClass,edx
        mov     edx, flags
        mov     [bx].ALLOC_CTX_DMA_flags,edx
        mov     edx, pBase
        mov     [bx].ALLOC_CTX_DMA_pBase,edx
        mov     dx, sel
        mov     word ptr [bx].ALLOC_CTX_DMA_pBase+4, dx
        mov     word ptr [bx].ALLOC_CTX_DMA_pBase+6, 0
        mov     edx, limit
        mov     [bx].ALLOC_CTX_DMA_limit,edx
        mov     dword ptr [bx].ALLOC_CTX_DMA_limit+4, 0
        mov     [bx].ALLOC_CTX_DMA_status,ALLOC_CTX_DMA_STATUS_SUCCESS
        cCall   Nv01AllocContextDma
        pop     edx
endm

comment ~  */

#define ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR                    0x00000000
#define ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY                0x00000001
#define ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY               0x00000002

#define ALLOC_CTX_DMA_FLAGS_CONTIGUOUS_PHYSICALITY          0x00000000
#define ALLOC_CTX_DMA_FLAGS_NONCONTIGUOUS_PHYSICALITY       0x00000010

#define ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS                   0x00000000
#define ALLOC_CTX_DMA_FLAGS_LOCKED_IN_TRANSIT               0x00000100

#define ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED              0x00000000
#define ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED                0x00001000

#define ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED                   ALLOC_CTX_DMA_FLAGS_LOCKED_ALWAYS + ALLOC_CTX_DMA_FLAGS_COHERENCY_CACHED

#define ALLOC_CTX_DMA_STATUS_SUCCESS                        0x00000000
#define ALLOC_CTX_DMA_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_PARENT_OBJECT          0x00000002
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_NEW_OBJECT             0x00000003
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_FLAGS                  0x00000005
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_BASE                   0x00000006
#define ALLOC_CTX_DMA_STATUS_ERR_BAD_LIMIT                  0x00000007
#define ALLOC_CTX_DMA_STATUS_ERR_PROTECTION_FAULT           0x00000008
#define ALLOC_CTX_DMA_STATUS_ERR_MULTIPLE_MEMORY_TYPES      0x00000009
#define ALLOC_CTX_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES     0x0000000a

/* ~

ALLOC_CHL_PIO_PARAM    STRUC            ;               */ typedef struct {                 /*
    ALLOC_CHL_PIO_hClient       dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_CHL_PIO_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_CHL_PIO_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CHL_PIO_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CHL_PIO_hObjectError  dd  ?   ;               */ unsigned long    hObjectError;   /*
    ALLOC_CHL_PIO_pChannel      dd  ?   ;               */ unsigned long    pChannel;       /*
                                dd  ?   ;               */ unsigned long    pChannel_high;  /*
    ALLOC_CHL_PIO_flags         dd  ?   ;               */ unsigned long    flags;          /*
    ALLOC_CHL_PIO_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CHL_PIO_PARAM    ENDS             ;               */ } Alloc_Chl_PIO_Param;           /*

ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT                  equ 00000000h
ALLOC_CHL_PIO_FLAGS_FIFO_ERROR_RUNOUT                   equ 00000001h

ALLOC_CHL_PIO_STATUS_SUCCESS                            equ 00000000h
ALLOC_CHL_PIO_STATUS_ERR_OPERATING_SYSTEM               equ 00000001h
ALLOC_CHL_PIO_STATUS_ERR_BAD_PARENT_OBJECT              equ 00000002h
ALLOC_CHL_PIO_STATUS_ERR_BAD_NEW_OBJECT                 equ 00000003h
ALLOC_CHL_PIO_STATUS_ERR_BAD_CLASS                      equ 00000004h
ALLOC_CHL_PIO_STATUS_ERR_BAD_OBJECT_ERROR               equ 00000005h
ALLOC_CHL_PIO_STATUS_ERR_BAD_FLAGS                      equ 00000006h
ALLOC_CHL_PIO_STATUS_ERR_INSUFFICIENT_RESOURCES         equ 00000007h

Nv01AllocChannelPio_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass,hObjectError,flags
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClient
        mov     [bx].ALLOC_CHL_PIO_hClient, edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CHL_PIO_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CHL_PIO_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_CHL_PIO_hClass, edx
        mov     edx, hObjectError
        mov     [bx].ALLOC_CHL_PIO_hObjectError, edx
        mov     dword ptr [bx].ALLOC_CHL_PIO_pChannel, 0
        mov     dword ptr [bx].ALLOC_CHL_PIO_pChannel+4, 0
        mov     edx, flags
        mov     [bx].ALLOC_CHL_PIO_flags,edx
        mov     [bx].ALLOC_CHL_PIO_status,ALLOC_CHL_PIO_STATUS_SUCCESS
        cCall   Nv01AllocChannelPio
        pop     edx
endm

comment ~  */

#define ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT              0x00000000
#define ALLOC_CHL_PIO_FLAGS_FIFO_ERROR_RUNOUT               0x00000001

#define ALLOC_CHL_PIO_STATUS_SUCCESS                        0x00000000
#define ALLOC_CHL_PIO_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_PARENT_OBJECT          0x00000002
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_NEW_OBJECT             0x00000003
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_OBJECT_ERROR           0x00000005
#define ALLOC_CHL_PIO_STATUS_ERR_BAD_FLAGS                  0x00000006
#define ALLOC_CHL_PIO_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000007

/* ~
;  funct NV03_ALLOC_CHANNEL_DMA parameters
ALLOC_CHL_DMA_PARAM STRUC                           ;               */ typedef struct {                 /*
    ALLOC_CHL_DMA_hClient       dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_CHL_DMA_hObjectParent dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_CHL_DMA_hObjectNew    dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_CHL_DMA_hClass        dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_CHL_DMA_hObjectError  dd  ?   ;               */ unsigned long    hObjectError;   /*
    ALLOC_CHL_DMA_hObjectBuffer dd  ?   ;               */ unsigned long    hObjectBuffer;  /*
    ALLOC_CHL_DMA_offset        dd  ?   ;               */ unsigned long    offset;         /*
    ALLOC_CHL_DMA_pControl      dd  ?   ;               */ unsigned long    pControl;       /*
                                dd  ?   ;               */ unsigned long    pControl_high;  /*
    ALLOC_CHL_DMA_status        dd  ?   ;               */ unsigned long    status;         /*
ALLOC_CHL_DMA_PARAM ENDS                                ;               */ } Alloc_Chl_DMA_Param;           /*

ALLOC_CHL_DMA_STATUS_SUCCESS                         equ        00000000h
ALLOC_CHL_DMA_STATUS_ERR_OPERATING_SYSTEM            equ        00000001h
ALLOC_CHL_DMA_STATUS_ERR_BAD_PARENT_OBJECT           equ        00000002h
ALLOC_CHL_DMA_STATUS_ERR_BAD_NEW_OBJECT              equ        00000003h
ALLOC_CHL_DMA_STATUS_ERR_BAD_CLASS                   equ        00000004h
ALLOC_CHL_DMA_STATUS_ERR_BAD_ERROR_OBJECT            equ        00000005h
ALLOC_CHL_DMA_STATUS_ERR_BAD_BUFFRE_OBJECT           equ        00000006h
ALLOC_CHL_DMA_STATUS_ERR_BAD_OFFSET                  equ        00000007h
ALLOC_CHL_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES      equ        00000008h

Nv03AllocChannelDma_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass,hObjectError,hObjectBuffer,offset
        push    edx
        push    ds
        lea     bx, buffer
        push    bx
        mov     edx, hClient
        mov     [bx].ALLOC_CHL_DMA_hClient, edx
        mov     edx, hObjectParent
        mov     [bx].ALLOC_CHL_DMA_hObjectParent, edx
        mov     edx, hObjectNew
        mov     [bx].ALLOC_CHL_DMA_hObjectNew, edx
        mov     edx, hClass
        mov     [bx].ALLOC_CHL_DMA_hClass, edx
        mov     edx, hObjectError
        mov     [bx].ALLOC_CHL_DMA_hObjectError, edx
        mov     edx, hObjectBuffer
        mov     [bx].ALLOC_CHL_DMA_hObjectBuffer, edx
        mov     edx, offset
        mov     [bx].ALLOC_CHL_DMA_offset, edx
        mov     dword ptr [bx].ALLOC_CHL_DMA_pControl, 0
        mov     dword ptr [bx].ALLOC_CHL_DMA_pControl+4, 0
        mov     [bx].ALLOC_CHL_DMA_status,0
        cCall   Nv03AllocChannelDma
        pop     edx
endm

comment ~  */

#define ALLOC_CHL_DMA_STATUS_SUCCESS                        0x00000000
#define ALLOC_CHL_DMA_STATUS_ERR_OPERATING_SYSTEM           0x00000001
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_PARENT          0x00000002
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_NEW             0x00000003
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_CLASS                  0x00000004
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_ERROR           0x00000005
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OBJECT_BUFFER          0x00000006
#define ALLOC_CHL_DMA_STATUS_ERR_BAD_OFFSET                 0x00000007
#define ALLOC_CHL_DMA_STATUS_ERR_INSUFFICIENT_RESOURCES     0x00000008

/* ~

NV01FREE_PARAM    STRUC                 ;               */ typedef struct {                 /*
    NV01FREE_hClient            dd  ?   ;               */ unsigned long    hClient;        /*
    NV01FREE_hObjectParent      dd  ?   ;               */ unsigned long    hObjectParent;  /*
    NV01FREE_hObjectOld         dd  ?   ;               */ unsigned long    hObjectOld;     /*
    NV01FREE_status             dd  ?   ;               */ unsigned long    status;         /*
NV01FREE_PARAM    ENDS                  ;               */ } NV01Free_Param;                /*

NV01FREE_STATUS_SUCCESS                                 equ 00000000h
NV01FREE_STATUS_ERR_OPERATING_SYSTEM                    equ 00000001h
NV01FREE_STATUS_ERR_BAD_PARENT_OBJECT                   equ 00000002h
NV01FREE_STATUS_ERR_BAD_OLD_OBJECT                      equ 00000003h
NV01FREE_STATUS_ERR_OBJECT_IN_USE                       equ 00000004h
NV01FREE_STATUS_ERR_OBJECT_HAS_CHILDERN                 equ 00000005h

Nv01Free_MAC macro buffer,hClient,hObjectParent,hObjectOld
          push  edx
          push  ds
          lea   bx, buffer
          push  bx
          mov   edx, hClient
          mov   [bx].NV01FREE_hClient, edx
          mov   edx, hObjectParent
          mov   [bx].NV01FREE_hObjectParent, edx
          mov   edx, hObjectOld
          mov   [bx].NV01FREE_hObjectOld, edx
          mov   [bx].NV01FREE_status, NV01FREE_STATUS_SUCCESS
          cCall Nv01Free
          pop   edx
endm

comment ~  */


#define NV01FREE_STATUS_SUCCESS                             0x00000000
#define NV01FREE_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define NV01FREE_STATUS_ERR_BAD_OBJECT_PARENT               0x00000002
#define NV01FREE_STATUS_ERR_BAD_OBJECT_OLD                  0x00000003
#define NV01FREE_STATUS_ERR_OBJECT_IN_USE                   0x00000004
#define NV01FREE_STATUS_ERR_OBJECT_HAS_CHILDERN             0x00000005

/* ~

ALLOC_OBJECT_PARAM        STRUC            ;               */ typedef struct {                 /*
    ALLOC_OBJECT_hClient           dd  ?   ;               */ unsigned long    hClient;        /*
    ALLOC_OBJECT_hObjectParent     dd  ?   ;               */ unsigned long    hObjectParent;  /*
    ALLOC_OBJECT_hObjectNew        dd  ?   ;               */ unsigned long    hObjectNew;     /*
    ALLOC_OBJECT_hClass            dd  ?   ;               */ unsigned long    hClass;         /*
    ALLOC_OBJECT_status            dd  ?   ;               */ unsigned long    status;         /*
ALLOC_OBJECT_PARAM        ENDS             ;               */ } AllocObject_Param;        /*

ALLOC_OBJ_STATUS_SUCCESS                                 equ 00000000h
ALLOC_OBJ_STATUS_ERR_OPERATING_SYSTEM                    equ 00000001h
ALLOC_OBJ_STATUS_ERR_BAD_PARENT_OBJECT                   equ 00000002h
ALLOC_OBJ_STATUS_ERR_BAD_NEW_OBJECT                      equ 00000003h
ALLOC_OBJ_STATUS_ERR_BAD_CLASS                           equ 00000004h
ALLOC_OBJ_STATUS_ERR_INSUFFICIENT_RESOURCES              equ 00000005h

Nv01AllocObject_MAC macro buffer,hClient,hObjectParent,hObjectNew,hClass
          push  edx
          push  ds
          lea   bx, buffer
          push  bx
          mov   edx, hClient
          mov   [bx].ALLOC_OBJECT_hClient, edx
          mov   edx, hObjectParent
          mov   [bx].ALLOC_OBJECT_hObjectParent, edx
          mov   edx, hObjectNew
          mov   [bx].ALLOC_OBJECT_hObjectNew, edx
          mov   edx, hClass
          mov   [bx].ALLOC_OBJECT_hClass, edx
          mov   [bx].ALLOC_OBJECT_status, ALLOC_OBJ_STATUS_SUCCESS
          cCall Nv01AllocObject
          pop   edx
endm

comment ~  */


#define ALLOC_OBJ_STATUS_SUCCESS                             0x00000000
#define ALLOC_OBJ_STATUS_ERR_OPERATING_SYSTEM                0x00000001
#define ALLOC_OBJ_STATUS_ERR_BAD_OBJECT_PARENT               0x00000002
#define ALLOC_OBJ_STATUS_ERR_BAD_OBJECT_OLD                  0x00000003
#define ALLOC_OBJ_STATUS_ERR_BAD_CLASS                       0x00000004
#define ALLOC_OBJ_STATUS_ERR_INSUFFICIENT_RESOURCES          0x00000005

/* ~

NVIOCONTROL_PARAM   STRUC               ;               */ typedef struct {                 /*
    NVIOCONTROL_hRoot           dd  ?   ;               */ unsigned long    hRoot;          /*
    NVIOCONTROL_hObjectParent   dd  ?   ;               */ unsigned long    hObjectParent;  /*
    NVIOCONTROL_function        dd  ?   ;               */ unsigned long    function;       /*
    NVIOCONTROL_owner           dd  ?   ;               */ unsigned long    owner;          /*
    NVIOCONTROL_type            dd  ?   ;               */ unsigned long    type;           /*
    NVIOCONTROL_depth           dd  ?   ;               */ unsigned long    depth;          /*
    NVIOCONTROL_width           dd  ?   ;               */ unsigned long    width;          /*
    NVIOCONTROL_height          dd  ?   ;               */ unsigned long    height;         /*
    NVIOCONTROL_pitch           dd  ?   ;               */ unsigned long    pitch;          /*
    NVIOCONTROL_offset          dd  ?   ;               */ unsigned long    offset;         /*
    NVIOCONTROL_size            dd  ?   ;               */ unsigned long    size;           /*
    NVIOCONTROL_address         dd  ?   ;               */ unsigned long    address;        /*
    NVIOCONTROL_limit           dd  ?   ;               */ unsigned long    limit;          /*
    NVIOCONTROL_total           dd  ?   ;               */ unsigned long    total;          /*
    NVIOCONTROL_free            dd  ?   ;               */ unsigned long    free;           /*
    NVIOCONTROL_status          dd  ?   ;               */ unsigned long    status;         /*
NVIOCONTROL_PARAM   ENDS                ;               */ } NVIOControl_Param;             /*

NVIOCONTROL_ARCH_HEAP                                   equ 0000000Bh

NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT               equ 1
NVIOCONTROL_HEAP_ALLOC_SIZE                             equ 2
NVIOCONTROL_HEAP_FREE                                   equ 3
NVIOCONTROL_HEAP_PURGE                                  equ 4
NVIOCONTROL_HEAP_INFO                                   equ 5
NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT               equ 6
NVIOCONTROL_HEAP_DESTROY                                equ 7
NVIOCONTROL_HEAP_INFO_FREE_BLOCKS                       equ 8
NVIOCONTROL_TYPE_IMAGE                                  equ 0
NVIOCONTROL_TYPE_DEPTH                                  equ 1
NVIOCONTROL_TYPE_TEXTURE                                equ 2
NVIOCONTROL_TYPE_VIDEO_OVERLAY                          equ 3
NVIOCONTROL_TYPE_FONT                                   equ 4
NVIOCONTROL_TYPE_CURSOR                                 equ 5
NVIOCONTROL_TYPE_DMA                                    equ 6
NVIOCONTROL_TYPE_INSTANCE                               equ 7
NVIOCONTROL_TYPE_PRIMARY                                equ 8
NVIOCONTROL_STATUS_SUCCESS                              equ 00000000h
NVIOCONTROL_STATUS_ERR_INSUFFICIENT_RESOURCES           equ 00000001h
NVIOCONTROL_STATUS_ERR_FUNCTION_INVALID                 equ 00000002h
NVIOCONTROL_STATUS_ERR_OWNER_INVALID                    equ 00000003h

comment ~  */

#define NVIOCONTROL_ARCH_HEAP                               (0x0000000B)

#define NVIOCONTROL_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT           1
#define NVIOCONTROL_HEAP_ALLOC_SIZE                         2
#define NVIOCONTROL_HEAP_FREE                               3
#define NVIOCONTROL_HEAP_PURGE                              4
#define NVIOCONTROL_HEAP_INFO                               5
#define NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT           6
#define NVIOCONTROL_TYPE_IMAGE                              0
#define NVIOCONTROL_TYPE_DEPTH                              1
#define NVIOCONTROL_TYPE_TEXTURE                            2
#define NVIOCONTROL_TYPE_VIDEO_OVERLAY                      3
#define NVIOCONTROL_TYPE_FONT                               4
#define NVIOCONTROL_TYPE_CURSOR                             5
#define NVIOCONTROL_TYPE_DMA                                6
#define NVIOCONTROL_TYPE_INSTANCE                           7
#define NVIOCONTROL_TYPE_PRIMARY                            8
#define NVIOCONTROL_STATUS_SUCCESS                          (0x00000000)
#define NVIOCONTROL_STATUS_ERR_INSUFFICIENT_RESOURCES       (0x00000001)
#define NVIOCONTROL_STATUS_ERR_FUNCTION_INVALID             (0x00000002)
#define NVIOCONTROL_STATUS_ERR_OWNER_INVALID                (0x00000003)


/* ~

; This must be identical to what is NVRMWIN.H - 
; it would be nice if we could use this definition only.

_def_rmParams   STRUC                   ;       */      typedef struct _def_rmParams {      /*
    RegEAX              dd      ?       ;       */          unsigned long    RegEAX;        /*
    RegEBX              dd      ?       ;       */          unsigned long    RegEBX;        /*
    RegECX              dd      ?       ;       */          unsigned long    RegECX;        /*
    RegEDX              dd      ?       ;       */          unsigned long    RegEDX;        /*
    RegEDI              dd      ?       ;       */          unsigned long    RegEDI;        /*
    RegESI              dd      ?       ;       */          unsigned long    RegESI;        /*
    RegES               dd      ?       ;       */          unsigned long    RegES;         /*
    RegDS               dd      ?       ;       */          unsigned long    RegDS;         /*
    RegCS               dd      ?       ;       */          unsigned long    RegCS;         /*
_def_rmParams   ENDS                    ;       */      } RMPARAMS, *PRMPARAMS;             /*

RMPARAMS        TYPEDEF         _def_rmParams
PRMPARAMS       TYPEDEF         PTR _def_rmParams

comment ~  */

/* ~
comment ~  */

/* ~
comment ~  */

#endif  // NVRMARCH_INCLUDED
/* ~

endif   ; NVRMARCH_INCLUDED

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvRmApi.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvRmApi.h
 *
 * NVidia resource manager API header file exported to drivers.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#include <nvos.h>

#ifdef NV_ICD_NT
#define NvRmAlloc NvRmAllocNt
#define NvRmAllocRoot NvRmAllocRootNt
#define NvRmAllocDevice NvRmAllocDeviceNt
#define NvRmAllocContextDma NvRmAllocContextDmaNt
#define NvRmAllocChannelPio NvRmAllocChannelPioNt
#define NvRmAllocChannelDma NvRmAllocChannelDmaNt
#define NvRmAllocMemory NvRmAllocMemoryNt
#define NvRmAllocObject NvRmAllocObjectNt
#define NvRmFree NvRmFreeNt
#define NvRmArchHeap NvRmArchHeapNt
#define NvRmConfigGet NvRmConfigGetNt
#define NvRmConfigGetEx NvRmConfigGetExNt
ULONG  NvRmAllocNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  NvRmAllocRootNt(ULONG *phClient);
ULONG  NvRmAllocDeviceNt(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  NvRmAllocContextDmaNt(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  NvRmAllocChannelDmaNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  NvRmAllocMemoryNt(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  NvRmAllocObjectNt(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  NvRmFreeNt(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG  NvRmArchHeapNt(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type, ULONG height, ULONG size,
ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG  NvRmConfigGetNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NvRmConfigGetExNt(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
#else /* NV_ICD_NT */
#ifndef WINNT
HANDLE NV_APIENTRY NvRmOpen(VOID);
VOID   NV_APIENTRY NvRmClose(VOID);
ULONG  NV_APIENTRY NvRmAlloc(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG  NV_APIENTRY NvRmAllocRoot(ULONG *phClient);
ULONG  NV_APIENTRY NvRmAllocDevice(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG  NV_APIENTRY NvRmAllocContextDma(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG  NV_APIENTRY NvRmAllocChannelPio(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG  NV_APIENTRY NvRmAllocChannelDma(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG  NV_APIENTRY NvRmAllocMemory(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG  NV_APIENTRY NvRmAllocObject(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG  NV_APIENTRY NvRmFree(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG  NV_APIENTRY Nv3RmGetDmaPushInfo(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG  NV_APIENTRY NvRmAllocEvent(ULONG hClient, ULONG hParent, ULONG object, ULONG hClass, ULONG hIndex, PVOID hEvent);
ULONG  NV_APIENTRY NvRmArchHeap(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type, ULONG height, ULONG size,
                              ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG  NV_APIENTRY NvRmConfigVersion(ULONG hClient, ULONG hDevice, ULONG *pVersion);
ULONG  NV_APIENTRY NvRmConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NV_APIENTRY NvRmConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG  NV_APIENTRY NvRmConfigUpdate(ULONG hClient, ULONG hDevice, ULONG flags);
ULONG  NV_APIENTRY NvRmInterrupt(ULONG hClient, ULONG hDevice);
ULONG  NV_APIENTRY NvRmRing0Callback(ULONG hClient, ULONG hDevice, ULONG procAddr, ULONG param1, ULONG param2);
ULONG  NV_APIENTRY NvRmConfigSetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmConfigGetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmI2CAccess(ULONG hClient, ULONG hDevice, VOID * ctrlStructPtr );
ULONG  NV_APIENTRY NvRmPowerManagement(ULONG hRoot, ULONG hDevice, ULONG head, ULONG command, VOID *paramStructPtr);
ULONG  NV_APIENTRY NvRmDebugControl(ULONG hRoot, ULONG command, VOID *pArgs);
ULONG  NV_APIENTRY NvRmIoFlush(VOID);
#ifdef LINUX
ULONG  NV_APIENTRY NvRmAGPInit(ULONG hClient, ULONG hDevice, ULONG agp_config);
ULONG  NV_APIENTRY NvRmAGPTeardown(ULONG hClient, ULONG hDevice);
#endif
#ifdef MACOS
ULONG  NV_APIENTRY NvRmOsConfigGet(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG  NV_APIENTRY NvRmOsConfigSet(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG  NV_APIENTRY NvRmOsConfigSetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
ULONG  NV_APIENTRY NvRmOsConfigGetEx(ULONG hClient, ULONG hDevice, ULONG index, VOID * paramStructPtr, ULONG ParamSize);
#endif
#endif // #ifndef WINNT
#endif /* NV_ICD_NT */

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvRmStereo.h ===
#ifndef _NVRM_STEREO_H_
#define _NVRM_STEREO_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NvRmStereo.h                                                      *
*		Resource Manager stereo interface structure.						*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:																	*
*		Andrei Osnovich 03/17/2000 Created. 								*
*                                                                           *
\***************************************************************************/

#ifdef	STEREO_SUPPORT

//Flag values that can be ORed in the NV_CFG_STEREO_PARAMS.Flags below
#define STEREOCFG_STEREOACTIVATED   0x00000001
#define STEREOCFG_ELSADDC           0x00000002

// Param Structure
typedef struct {
	unsigned long	Flags;
	unsigned long	EyeDisplayed;
	unsigned long	FlipOffsets[4][2];
} NV_CFG_STEREO_PARAMS, *LPNV_CFG_STEREO_PARAMS;

#endif	//STEREO_SUPPORT

#endif	//_NVRM_STEREO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\XXXrm_unix.h ===
/*
 * this is a hack repository to deal with issues on resman linux port as
 * it matures.
 * Once this file is emptied it can be deleted.
 */

/* XXXTEB these should be somewhere else; probably nvos.h */
typedef unsigned long ULONG;
typedef unsigned char *PUCHAR;
typedef void VOID;
typedef void *PVOID;
typedef void *HANDLE;
/* XXXTEB end */

int XXX_RM_INIT(void);
void XXX_ISR_POLL(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\videoagp.h ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    videoagp.h

Abstract:
    Video miniport AGP support.

Notes:

Revision History:

--*/

#ifndef __VIDEOAGP_H__
#define __VIDEOAGP_H__

typedef
PHYSICAL_ADDRESS
(*PAGP_RESERVE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext
    );

typedef
BOOLEAN
(*PAGP_COMMIT_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
PVOID
(*PAGP_RESERVE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext
    );

typedef
PVOID
(*PAGP_COMMIT_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef struct _VIDEO_PORT_AGP_SERVICES
{
    PAGP_RESERVE_PHYSICAL AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL  AgpCommitPhysical;
    PAGP_FREE_PHYSICAL    AgpFreePhysical;

    PAGP_RESERVE_VIRTUAL  AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL  AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL   AgpCommitVirtual;
    PAGP_FREE_VIRTUAL     AgpFreeVirtual;
    ULONGLONG AllocationLimit;

} VIDEO_PORT_AGP_SERVICES, *PVIDEO_PORT_AGP_SERVICES;

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_PORT_AGP_SERVICES AgpServices
    );

#endif // ifndef __VIDEOAGP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\NvViewer.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: NvViewer.h                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    10/04/2000  Created                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVVIEWER_H_
#define _NVVIEWER_H_

#define NVSTEREO_IMAGE_SIGNATURE 0x4433564e //NV3D
typedef struct  _Nv_Stereo_Image_Header
{
    DWORD   dwSignature;
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBPP;
    DWORD   dwSwapEyes;
} NVSTEREOIMAGEHEADER, *LPNVSTEREOIMAGEHEADER;
    
//Stereo image viewing mode
#define FULL_SCREEN         0
#define WINDOWED            1
#define WINDOWED_FIT        2

//Mesage handling mode
#define INTERNAL_MESSAGING  0
#define EXTERNAL_MESSAGING  1

typedef class CStereoImageViewer
{
    /*
     * methods
     */
public:
    virtual DWORD Display (LPVOID pImage, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwViewMode, DWORD dwMessageMode);
    virtual DWORD Display (char * filename, DWORD dwViewMode, DWORD dwMessageMode);
    virtual DWORD WINAPI DestroyStereoImageViewer(void);
    CStereoImageViewer();
    ~CStereoImageViewer();
protected:
} CSTEREOIMAGEVIEWER, *LPCSTEREOIMAGEVIEWER;


extern DWORD WINAPI CreateStereoImageViewer(LPCSTEREOIMAGEVIEWER &pStereoImageViewer);

#endif _NVVIEWER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\nvtypes.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nvtypes.h> defines common widths used to access hardware in of NVIDIA's *|
|*  Unified Media Architecture (TM).                                         *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NVTYPES_INCLUDED
#define NVTYPES_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif



 /***************************************************************************\
|*                                 Typedefs                                  *|
 \***************************************************************************/

typedef unsigned char      NvV8;  /* "void": enumerated or multiple fields   */
typedef unsigned short     NvV16; /* "void": enumerated or multiple fields   */
typedef unsigned long      NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned char      NvU8;  /* 0 to 255                                */
typedef unsigned short     NvU16; /* 0 to 65535                              */
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
typedef signed char        NvS8;  /* -128 to 127                             */
typedef signed short       NvS16; /* -32768 to 32767                         */
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
typedef float              NvF32; /* IEEE Single Precision (S1E8M23)         */
typedef double             NvF64; /* IEEE Double Precision (S1E11M52)        */

#if defined(_WIN64)

typedef unsigned __int64   NvV64; /* "void": enumerated or multiple fields   */
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615               */
typedef __int64            NvS64; /* 2^-63 to 2^63-1                         */
typedef void*              NvP64; /* 64 bit void pointer                     */

typedef NvU64 NvU64_VALUE_T;
typedef NvP64 NvP64_VALUE_T;

#define NvU64_VALUE(n)    (n)
#define NvP64_VALUE(n)    (n)
#define NvP64_SELECTOR(n) (0)

#elif _WIN32_WINNT >= 0x0400

typedef unsigned __int64   NvV64; /* "void": enumerated or multiple fields   */
typedef unsigned __int64   NvU64; /* 0 to 18446744073709551615               */
typedef __int64            NvS64; /* 2^-63 to 2^63-1                         */
typedef unsigned __int64   NvP64; /* 64 bit void pointer                     */

typedef NvU64 NvU64_VALUE_T;
typedef NvP64 NvP64_VALUE_T;

#define NvU64_VALUE(n)    (n)
#define NvP64_VALUE(n)    (n)
#define NvP64_SELECTOR(n) (0)

#else

typedef struct {
 NvU32 low;
 NvU32 high;
}                          NvV64; /* "void": enumerated or multiple fields   */
typedef struct {
 NvU32 low;
 NvU32 high;
}                          NvU64; /* 0 to 18446744073709551615               */
typedef struct {
 NvU32 low;
 NvS32 high;
}                          NvS64; /* 2^-63 to 2^63-1                         */
typedef struct {
 NvU32 offset;
 NvU16 selector;
 NvU16 reserved;
}                          NvP64; /* 64 bit void pointer                     */

typedef NvU32 NvP64_VALUE_T;
typedef NvU32 NvU64_VALUE_T;

#define NvU64_VALUE(n)    ((n).low)
#define NvP64_VALUE(n)    ((n).offset)
#define NvP64_SELECTOR(n) ((n).selector)

#endif

/* obsolete stuff */
typedef NvV8  V008;
typedef NvV16 V016;
typedef NvV32 V032;
typedef NvV64 V064;
typedef NvU8  U008;
typedef NvU16 U016;
typedef NvU32 U032;
typedef NvU64 U064;
typedef NvS8  S008;
typedef NvS16 S016;
typedef NvS32 S032;
typedef NvS64 S064;
typedef NvP64 P064;
typedef NvF32 F032;
typedef NvF64 F064;
#if defined(MACOS) || defined(macintosh)
// more obsolete stuff
// need to provide these on macos9 and macosX
typedef unsigned long  ULONG;
typedef unsigned long  DWORD;
typedef unsigned char *PUCHAR;
typedef void           VOID;
typedef void          *PVOID;
typedef void          *HANDLE;
#endif

/* polymorphic 64-bit macros */
#if defined(_WIN64)
typedef NvP64 VOID_PTR;
typedef NvU64 NV_UINTPTR_T;
#else
typedef NvU32 VOID_PTR;
typedef NvU32 NV_UINTPTR_T;
#endif

#ifdef __cplusplus
};
#endif
#endif /* NVTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\rddapi.inc ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         rddapi.inc
;
; Purpose:      This file holds the interface description for both
;               the minivdd and the resman's Register Display Driver
;               API. Register Display Driver is a private API between
;               16bit land and the driver components.
;==============================================================================

; To call the API, set:
; eax = VDD_REGISTER_DISPLAY_DRIVER_INFO  (defined in minivdd.inc)
; ebx = system VM handle
; ecx = one of the equates below
;
; Other register settings depend upon the value in ecx.

; These services are in the RegisterDisplayDriver function in the
; resman. They are services needed by the hardware specific portion
; of the display driver.

MVDD_GET_LOGDEV_SHARED_MEMORY                   EQU     8764FFFFH
MVDD_ALLOC_LINEAR_ADDRESS_SPACE                 EQU     87650000H
MVDD_FREE_LINEAR_ADDRESS_SPACE                  EQU     87650001H
MVDD_COPY_PTES_FOR_LINEAR_RANGE                 EQU     87650002H

; These services are in the RegisterDisplayDriver function in the
; minivdd. They are services needed by the generic portion of the
; display driver.
MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS        EQU     87650003H
MVDD_ALLOC_MEMORY_BLOCK                         EQU     87650004H
MVDD_FREE_MEMORY_BLOCK                          EQU     87650005H
MVDD_REENUMERATE_DEVNODE                        EQU     87650006H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\stdcall.inc ===
;****************************Public Macro************************************
;
;   ComposeInst Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
;
;       This macro simply concatenates all arguments into one string.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
; Module Name: stdcall.inc
;
; Copyright (c) 1991-1999 Microsoft Corporation
;****************************************************************************
  
;
;****************************************************************************

ComposeInst macro   Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
        &Inst   &p1&p2&p3&p4&p5&p6&p7&p8&p9
endm

;****************************Public Macro************************************
;
;   CountArg    cCount,ArgList
;
;       This macro count the number of arguments in the ArgList and returns
;       the value in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

CountArg    macro   cCount,ArgList

        cCount = 0

        irp arg,<ArgList>
            cCount = cCount+1
        endm
endm

;****************************Public Macro************************************
;
;   RevPush     ArgList,cCount
;
;       This macro pushes the arguments in ArgList in the reverse order
;       and returns the number of arguments in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

RevPush macro   ArgList,cCount
        Local   index,x

        CountArg cCount,<ArgList>

        index  = cCount
        rept    cCount
            x = 0
            irp arg,<ArgList>
                x = x+1
                ife index-x
                    push    arg
                    exitm
                endif
            endm
            index = index-1
        endm
endm

;****************************Public Macro************************************
;
;   The following sections contain calling-convention related macros for:
;
;   PUBLICP     Func,N
;       to define a public label
;
;   EXTRNP      Func,N
;       to define a external near label
;
;   LABELP      Func,N
;       to label an address as a routine entry point
;
;   cProc       Func,N,ArgList
;       to declare a routine header
;
;   ProcName    Name,Func,N
;       to rename a function Func to Name. Using it in conjunction with
;       normal function declaration (with the new name) will solve an error
;       caused by a long parameter list routine that exhausts page width.
;
;   cRet        Func
;       to return from Func routines (declared with cProc or ProcName.)
;
;   endProc     Func
;       to declare the end of routine (declared with cProc or ProcName.)
;
;   endMod      Func
;       to declare the end of module with an entry point at Func (declared
;       with cProc or ProcName.)
;
;   cCall       Func,ArgList
;       to call to a routine--Func--with the arguments pushed on the stack
;
;   ptrCall     Func,ArgList
;       to call through a pointer with the arguments pushed on the stack
;
;   MovAddr     dest,Func,n
;       to move the address of the routine--Func--into dest.
;
;   Note that for the standard calling convention all the function names,
;   Func, are automatically converted to Func@N where N is the number of
;   bytes in the argument list.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

IFNDEF  DOS_PLATFORM
IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for C calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif

endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   ; STD_CALL

ELSE

IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for Pascal calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

cCall   macro   Func,ArgList
        irp arg,<ArgList>
            push    arg
        endm

        call    &Func
endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   : ~STD_CALL
ENDIF   ; DOS_PLATFORM

IFDEF STD_CALL
;****************************************************************************
;
;   This section is used exclusively for the standard calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        ifb    <N>
            public      &Func&@0
        else
            public      &Func&@&N
        endif
endm

EXTRNP  macro   Func,N

        ifb    <N>
            extrn       &Func&@0:NEAR
        else
            extrn       &Func&@&N:NEAR
        endif
endm

LABELP  macro   Func,N

        ifb    <N>
            &Func&@0    LABEL   NEAR
        else
            &Func&@&N   LABEL   NEAR
        endif
endm

ProcName macro  Name,Func,N

        ifb <N>
            cByte&Func   EQU     0
            &Name        EQU     <&Func&@0>
        else
            cByte&Func   EQU     N
            &Name        EQU     <&Func&@&N>
        endif
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret     cByte&Func

endm


endProc macro   Func

        xxx&Func   endp

endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        call    &Func
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        ComposeInst <call>,&Func,<@>,%(Bytes)
endm

MovAddr macro   dest,addr,n

        ComposeInst <mov >,dest,<,offset FLAT:>,addr,<@>,n
endm

ENDIF   ;STD_CALL

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\agp.h ===
//
// Copyright (c) 1998-1999 Microsoft Corporation
//


#ifndef __AGP_INCLUDED__
#define __AGP_INCLUDED__

DEFINE_GUID(GUID_AGP_INTERFACE, 0xd6c9df40, 0xa1a2, 0x11d1, 0x81, 0x15, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

#ifndef GUID_DEFS_ONLY

//
// Temporary Hack...
//

#ifndef IsEqualGUID
#ifdef __cplusplus
    inline int IsEqualGUID(REFGUID guid1, REFGUID guid2)
        {
            return !memcmp(&guid1, &guid2, sizeof(GUID));
        }
#else // !__cplusplus
    #define IsEqualGUID(guid1, guid2) \
        (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif // !__cplusplus
#endif

#define AGP_INTERFACE_VERSION 1

typedef struct _AGP_INTERFACE
{
    USHORT           Size;
    USHORT           Version;
    PVOID            Context;
    PVOID            InterfaceReference;
    PVOID            InterfaceDereference;

    VIDEO_PORT_AGP_SERVICES AgpServices;

} AGP_INTERFACE, *PAGP_INTERFACE;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\sdk\nvidia\inc\video.h ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    video.h

Abstract:

    Contains all structure and routine definitions common to the video port
    driver and the video miniport drivers.

Notes:

Revision History:

--*/

#ifndef __VIDEO_H__
#define __VIDEO_H__

#include <videoagp.h>

//
// Define port driver status code.
// The values for these are the Win32 error codes
//

typedef LONG VP_STATUS;
typedef VP_STATUS *PVP_STATUS;

//
// Defines for registry information and synchronization.
//

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

//
//  Opaque pointer type for miniport to be used to type PEVENTs received from
//  display driver.
//

typedef struct _VIDEO_PORT_EVENT * PEVENT;

//
// Type of information requested with GetDeviceData
//

typedef enum _VIDEO_DEVICE_DATA_TYPE {
    VpMachineData,
    VpCmosData,
    VpBusData,
    VpControllerData,
    VpMonitorData
} VIDEO_DEVICE_DATA_TYPE, *PVIDEO_DEVICE_DATA_TYPE;

//
// Data returned with VpControllerData
//

typedef struct _VIDEO_HARDWARE_CONFIGURATION_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    USHORT Version;
    USHORT Revision;
    USHORT Irql;
    USHORT Vector;
    ULONG ControlBase;
    ULONG ControlSize;
    ULONG CursorBase;
    ULONG CursorSize;
    ULONG FrameBase;
    ULONG FrameSize;
} VIDEO_HARDWARE_CONFIGURATION_DATA, *PVIDEO_HARDWARE_CONFIGURATION_DATA;

//
// Define structure used to call the BIOS int 10 function
//

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#define SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO           0x42
#define SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA     0x28
 
//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

//
// Allows us to remove lots of unused code.
//

#ifndef _NTOSDEF_

#define ALLOC_PRAGMA 1
#define VIDEOPORT_API __declspec(dllimport)

#if DBG
#define PAGED_CODE() \
    if (VideoPortGetCurrentIrql() > 1 /*APC_LEVEL*/) { \
        VideoPortDebugPrint(0, "Video: Pageable code called at IRQL %d\n", VideoPortGetCurrentIrql() ); \
        ASSERT(FALSE); \
        }

#else
#define PAGED_CODE()
#endif

ULONG
DriverEntry(
    PVOID Context1
    );

#else
#define VIDEOPORT_API
#endif


#ifndef _NTOS_

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data,
    ULONG DataLength
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data,
    ULONG DataLength // number of words
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

typedef
VP_STATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data,
    ULONG DataLength  // number of dwords
    );

#endif // _NTOS_


//
// Definition of the request packet sent from the port driver to the
// miniport driver. It reflects the parameters passed from the
// DeviceIOControl call made by the windows display driver.
// 
// N.B. The definition of the STATUS_BLOCK must be the same as the
//      the definition of IO_STATUS_BLOCK defined in ntioapi.h.
//

typedef struct _STATUS_BLOCK {

    //
    // Contains the status code of the operation.
    // This value in one of the Win32 error codes that are defined for use
    // in the video miniport drivers.
    //

    union {
       VP_STATUS Status;
       PVOID Pointer;
    };

    //
    // Information returned to the callee.
    // The meaning of the information varies from function to function. It
    // is generally used to return the minimum size for the input buffer if
    // the function takes an input buffer, or the amount of data transfered
    // back to the caller if the operation returns output.
    //

    ULONG_PTR Information;

} STATUS_BLOCK, *PSTATUS_BLOCK;

typedef struct _VIDEO_REQUEST_PACKET {

    //
    // The IO control code passed to the DeviceIoControl function by the
    // caller.
    //

    ULONG IoControlCode;

    //
    // Pointer to a status block provided by the caller. This should be
    // filled out by the callee with the appropriate information.
    //

    PSTATUS_BLOCK StatusBlock;

    //
    // Pointer to an input buffer which contains the information passed in
    // by the caller.
    //

    PVOID InputBuffer;

    //
    // Size of the input buffer
    //

    ULONG InputBufferLength;

    //
    // Pointer to an output buffer into which the data returned to the caller
    // should be stored.
    //

    PVOID OutputBuffer;

    //
    // Length of the output buffer. This buffer can not be grown by the
    // callee.
    //

    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

//
//  typedef for scattergather array available via GET_VIDEO_SCATTERGATHER().
//

typedef struct __VRB_SG {
    __int64   PhysicalAddress;
    ULONG     Length;
    } VRB_SG, *PVRB_SG;

//
// Opaque type for dma handle
//

typedef struct __DMA_PARAMETERS * PDMA;

//
//  The following macro returns in Address the 32 bit physical address of
//  the VirtualAddress lying within the InputBuffer passed into EngDevIo
//

#define GET_VIDEO_PHYSICAL_ADDRESS(scatterList, VirtualAddress, InputBuffer, pLength, Address)    \
                                                                                           \
        do {                                                                               \
            ULONG_PTR          byteOffset;                                                  \
                                                                                           \
            byteOffset = (PCHAR) VirtualAddress - (PCHAR)InputBuffer;                \
                                                                                           \
            while (byteOffset >= scatterList->Length) {                                    \
                                                                                           \
                byteOffset -= scatterList->Length;                                         \
                scatterList++;                                                             \
            }                                                                              \
                                                                                           \
            *pLength = scatterList->Length - byteOffset;                                   \
                                                                                           \
            Address = (ULONG_PTR) (scatterList->PhysicalAddress + byteOffset);                  \
                                                                                           \
        } while (0)


#define GET_VIDEO_SCATTERGATHER(ppDma)   (**(PVRB_SG **)ppDma)

#define VIDEO_RANGE_PASSIVE_DECODE   0x1
#define VIDEO_RANGE_10_BIT_DECODE    0x2


//
// The following structure is used to define access ranges. The ranges are
// used to indicate which ports and memory adresses are being used by the
// card.
//

typedef struct _VIDEO_ACCESS_RANGE {

    //
    // Indicates the starting memory address or port number of the range.
    // This values should be stored before being transformed by
    // VideoPortGetDeviceBase() which returns the logical address that must
    // be used by the miniport driver when referencing physical addresses.
    //

    PHYSICAL_ADDRESS RangeStart;

    //
    // Indicates the length in bytes, or number of ports in the range. This
    // value should indicate the range actually decoded by the adapter. For
    // example, if the adapter uses 7 registers but responds to eight, the
    // RangeLength should be set to 8.

    ULONG RangeLength;

    //
    // Indicates if the range is in IO space (TRUE) or in memory space (FALSE).
    //

    UCHAR RangeInIoSpace;

    //
    // Indicates if the range should be visible by the Windows display driver.
    // This is done so that a Windows display driver can access certain
    // video ports directly. This will only be allowed if the caller has the
    // required privileges (is a trusted subsystem) to access the range.
    //
    // Synchronization of access to ports or memory in the range must be
    // done explicitly by the miniport driver and the user mode process so
    // that they both don't try to program the device simultaneously.
    //
    // Non visible ranges should include video memory, ROM addresses, etc.
    // which are not required to program the device for output purposes.
    //
    //

    UCHAR RangeVisible;

    //
    // This field determines if the range can be shared with another device.
    // The rule should be applied as follow.
    //
    // - If the range of memory or IO ports should be "owned" by this driver,
    //   and that any other driver trying to access this range may cause
    //   a problem, FALSE should be returned.
    //
    // - If the range can be shared with another co-operating device driver,
    //   then the share field should be set to TRUE.
    //
    // As a guideline, the VGA miniport driver will claim all of its resources
    // as shareable so that it can be used as a VGA compatible device with
    // any other driver (such as an S3 or XGA.
    //
    // Super VGA miniport drivers that implement all the VGA functionality
    // (declared in the Registry as VGACOMPATIBLE=1) should claim the range
    // as non-shareable since they don't want the VGA to run at the same time.
    //
    // Miniports for cards such as an S3 or XGA that have an XGA on the board
    // but do not implement the VGA functionality will run with the VGA
    // miniport loaded and should therefore claim all the resources shared
    // with the VGA as shareable.
    //
    // Miniports for cards that work with a pass-through and that can be
    // connected to any VGA/SVGA card should not be using any VGA ports or
    // memory ranges ! ... but if they do they should not claim those
    // resources since they will cause a conflict in the system because the
    // SVGA cards will have claimed them as non-shareable ...
    //

    UCHAR RangeShareable;

    //
    // Indicates that the range is decoded by the hardware, but that the
    // driver will never access this port.
    //

    UCHAR RangePassive;

} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;



typedef
PVOID
(*PVIDEO_PORT_GET_PROC_ADDRESS)(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

//
// This structure contains the specific configuration information about the
// device. The information is initialized by the port driver and it should
// be completed by the miniport driver.
// The information is used to setup the device, as weel as providing
// information to the port driver so it can perform some of the requests on
// behalf of the miniport driver.
//

typedef struct _VIDEO_PORT_CONFIG_INFO {

    //
    // Specifies the length of the PVIDEO_PORT_CONFIG_INFO structure as
    // returned by sizeof(). Since this structure may grow in later
    // releases, the miniport driver should check that the length of the
    // structure is greater than or equal to the length it expects (since
    // it is guaranteed that defined fields will not change).
    //
    // This field is always initialized by the port driver.
    //

    ULONG Length;

    //
    // Specifies which IO bus is tp be scanned. This field is used as a
    // parameter to some VideoPortXXX calls.
    //
    // This field is always initialized by the port driver.
    //

    ULONG SystemIoBusNumber;

    //
    // Specifies the type of bus being scanned. This field is equal to the
    // value being passed into VideoPortInitialize in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // This field is always initialized by the port driver.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Specifies the bus interrupt request level. This level corresponds to
    // the IRQL on ISA and MCA buses.
    // This value is only used if the device supports interrupts, which is
    // determined by the presence of an interrupt service routine in the
    // VIDEO_HW_INITIALIZATION_DATA structure.
    //
    // The preset default value for this field is zero. Otherwise, it is the
    // value found in the device configuration information.
    //

    ULONG BusInterruptLevel;

    //
    // Specifies the bus vector returned by the adapter. This is used for
    // systems which have IO buses that use interrupt vectors. For ISA, MCA
    // and EISA buses, this field is unused.
    //
    // The preset default value for this field is zero.
    //

    ULONG BusInterruptVector;

    //
    // Specifies whether this adapter uses latched or edge-triggered type
    // interrupts.
    //
    // This field is always initialized by the port driver.
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Specifies the number of emulator access entries that the adapter
    // uses.  It indicates the number of array elements in the following field.
    //
    // This field can be reinitialized with the number of entries in the
    // EmulatorAccessEntries structure if the structure is statically
    // defined in the miniport driver. The EmulatorAccessEntries fields
    // should also be updated.
    //

    ULONG NumEmulatorAccessEntries;

    //
    // Supplies a pointer to an array of EMULATOR_ACCESS_ENTRY structures.
    // The number of elements in the array is indicated by the
    // NumEmulatorAccessEntries field. The driver should fill out each entry
    // for the adapter.
    //
    // The uninitialized value for the structure is NULL.
    // EmulatorAccessEntries will be NULL if NumEmulatorAccessEntries is
    // zero.
    //
    // A poiner to an array of emulator access entries can be passed back
    // if such a structure is defined statically in the miniport driver. The
    // NumEmulatorAccessEntries field should also be updated.
    //

    PVOID EmulatorAccessEntries;

    //
    // This is a context values that is passed with each call to the
    // emulator/validator functions defined in the EmulatorAccessEntries
    // defined above.
    // This parameter should in general be a pointer to the miniports
    // device extension or other such storage location.
    //
    // This pointer will allow the miniport to save some state temporarily
    // to allow for the batching of IO requests.
    //

    ULONG_PTR EmulatorAccessEntriesContext;

    //
    // Physical address of the video memory that must be mapped into a VDM's
    // address space for proper BIOS support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;

    //
    // Length of the video memory that must be mapped into a VDM's addres
    // space for proper BIOS support.
    //

    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Determines the minimum size required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //
    // The uninitialized value for this field is zero.
    //
    // If the field is left to zero, SAVE_HARDWARE_STATE will return an
    // ERROR_INVALID_FUNCTION status code.
    //

    ULONG HardwareStateSize;

    //
    // New for version 3.5
    //

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaChannel;

    //
    // Optional DMA channel, if required by the device.
    // 0 for the Channel and Port indicates DMA is not used by the device.
    //

    ULONG DmaPort;

    //
    // Set to 1 if the DMA channel can be shared with another device.
    // Set to 0 if the DMA channel must be owned exclusively by the driver.
    //

    UCHAR DmaShareable;

    //
    // Set to 1 if the interrupt can be shared with another device.
    // Set to 0 if the interrupt must be owned exclusively by the driver.
    //

    UCHAR InterruptShareable;

    //
    //  Start new dma stuff
    //

    //
    // Set to TRUE if the DMA device is a busmaster, FALSE otherwise.
    //

    BOOLEAN Master;

    //
    // Set to number of bits wide. Consistent with DEVICE_DESCRIPTION.
    // See ntioapi.h
    //

    DMA_WIDTH   DmaWidth;

    //
    // Set to speed so miniport can set DEVICE_DESCRIPTION field.
    // See ntioapi.h
    //

    DMA_SPEED   DmaSpeed;

    //
    // Set to TRUE if the DMA device requires mapped buffers. Also
    // a DEVICE_DESCRIPTION  field.
    //

    BOOLEAN bMapBuffers;

    //
    // Set to TRUE if the DMA device requires physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Set to TRUE if the DMA device supports demand mode, FALSE otherwise.
    // Also DEVICE_DESCRIPTION support.
    //

    BOOLEAN DemandMode;

    //
    // Set to max transfer length the DMA device supports.
    //

    ULONG   MaximumTransferLength;

    //
    // Set to max number of Physical breaks the DMA device supports.
    //

    ULONG   NumberOfPhysicalBreaks;

    //
    // Set to TRUE if the DMA device supports scatter gather, FALSE otherwise.
    //

    BOOLEAN ScatterGather;

    //
    // Maximal Length in PVRB_SG returned measured in bytes. If the device
    // has no maximum size, zero should be entered.
    //

    ULONG   MaximumScatterGatherChunkSize;

    //
    // Allow for 4.0/5.0 compatibilty
    //

    PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;

    //
    // Provide a pointer to the device's registry path
    //

    PWSTR DriverRegistryPath;

    //
    // Indicates to a driver the amount of physical memory in the system
    //

    ULONGLONG SystemMemorySize;

} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;


//
// Video Adapter Dependent Routines.
//

typedef
VP_STATUS
(*PVIDEO_HW_FIND_ADAPTER) (
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

typedef
BOOLEAN
(*PVIDEO_HW_INITIALIZE) (
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_HW_INTERRUPT) (
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_HW_LEGACYRESOURCES) (
    IN ULONG VendorId,
    IN ULONG DeviceId,
    IN OUT PVIDEO_ACCESS_RANGE *LegacyResourceList,
    IN OUT PULONG LegacyResourceCount
    );

//
// type to be returned by HwStartDma().
//

typedef enum _HW_DMA_RETURN {
    DmaAsyncReturn,
    DmaSyncReturn
    } HW_DMA_RETURN, *PHW_DMA_RETURN;


typedef
HW_DMA_RETURN
(*PVIDEO_HW_START_DMA) (
    PVOID                   HwDeviceExtension,
    PDMA                    pDma
    );

//
//  Flags to be passed into VideoPortLockPages() or VideoPortDoDma().
//

//
//  The flag VideoPortUnlockAfterDma tells the video port to unlock the pages
//  after the miniport signals that the dma is complete via the
//  pDmaCompletionEvent in HwStartDma. Failure to set this event at
//  dma completion may cause the memory to be unlocked at randon times.
//  This flag is best used when one wants to do one dma transfer which
//  occurs infrequently. It allows locking, dmaing and unlocking to be performed
//  in the context of 1 IOCTL.
//

//
//  The flag VideoPortKeepPagesLocked tells the video port to leave the pages
//  locked if possible.
//

//
//  The flag VideoPortDmaInitOnly tells the Video Port to lock the pages, but don't
//  call HwStartDma. Not applicable to VideoPortDoDma().
//


typedef enum {
    VideoPortUnlockAfterDma = 1,
    VideoPortKeepPagesLocked,
    VideoPortDmaInitOnly
    }   DMA_FLAGS;

//
// DMA Event flags
//

typedef ULONG DMA_EVENT_FLAGS;

#define SET_USER_EVENT    0x01
#define SET_DISPLAY_EVENT 0x02

//
// Child Enumeration structure passed in to the PVIDEO_HW_GET_CHILD_DESCRIPTOR
// function.
//
// All these parameters are input parameters and must not be modified by the
// callee
//
// Size - Size of the structure.  It can be used by the calle for versioning.
//
// ChildDescriptorSize - Size of the pChildDescriptor buffer passed in as the
//     third parameter to PVIDEO_HW_GET_CHILD_DESCRIPTOR.
//
// ChildIndex - Index of the device to be enumerated.  This field should be
//     used to enumerate devices not enumerated by ACPI or other operating
//     system components.  If this field is set to 0 it indicates the ACPIHwId
//     field.
//
// ACPIHwId - ID returned by the ACPI BIOS that represent the device being
//     queried.  The ACPIHwId returned by the firmware must match the HwIds
//     returned by the driver.  The System BIOS manufacturer and the graphics
//     IHV must synchronize these IDs.
//
// ChildHwDeviceExtension - Pointer to a device extension specific to this
//     child device.  This field will only be filled in if the miniport driver
//     filled the ChildHwDeviceExtensionSize to be non-NULL.
//

typedef struct _VIDEO_CHILD_ENUM_INFO {
    ULONG Size;
    ULONG ChildDescriptorSize;
    ULONG ChildIndex;
    ULONG ACPIHwId;
    PVOID ChildHwDeviceExtension;
} VIDEO_CHILD_ENUM_INFO, *PVIDEO_CHILD_ENUM_INFO;

//
//  VIDEO_CHILD_TYPE enum:
//
//  'Monitor' identifies a device which may have a DDC2 compliant EDID data
//  structure. If the video miniport detects such a device, it is to extract
//  the edid from the monitor and put that in the paged buffer provided by
//  videoprt.sys in the callback to PVIDEO_HW_GET_CHILD_DESCRIPTOR and return
//  this type in the the OUT PVIDEO_CHILD_TYPE parameter of that call. This
//  EDID, if available, will be written to the registry. If the EDID is not
//  available, nothing should be put in the buffer.
//
//  'NonPrimaryChip' identifies another VGA chip on the video board which
//  is not the primary VGA chip. This type is to be used if and only if the
//  miniport detects more than one VGA chip on the board. Such an identifier
//  will cause the videoprt to create another DEVICE_EXTENSION and associated
//  HW_DEVICE_EXTENSION to be associated with the chip so identified.
//
//  'Other' identifies some other video device attached to the video card. If
//  the miniport detects such a device, it is to put a wide char string
//  (WSTR) into the paged buffer provided by the videoprt.sys which is the
//  PNP hardware identifier of the device. This string will be used to create
//  a value of that name in the registry.
//

typedef enum {
    Monitor = 1,
    NonPrimaryChip,
    VideoChip,
    Other
} VIDEO_CHILD_TYPE, *PVIDEO_CHILD_TYPE;

//
//  define a constant that represents the display adapter self query.
//

#define DISPLAY_ADAPTER_HW_ID           0xFFFFFFFF

typedef struct _VIDEO_CHILD_STATE {
    ULONG   Id;
    ULONG   State;
} VIDEO_CHILD_STATE, *PVIDEO_CHILD_STATE;
    
typedef struct _VIDEO_CHILD_STATE_CONFIGURATION {
    ULONG             Count;
    VIDEO_CHILD_STATE ChildStateArray[ANYSIZE_ARRAY];
} VIDEO_CHILD_STATE_CONFIGURATION, *PVIDEO_CHILD_STATE_CONFIGURATION;

//
//  The following routine should return TRUE if successful. It should:
//      1)  put the type of the child device in VideoChildType.
//      2)  put the information from the device in Buffer. This
//          buffer is of size 256 bytes. If the type returned in
//          PVideoChildType is Monitor, this buffer must contain the
//          EDID of the monitor if readable. If the type returned in
//          PVideoChildType is Other, a wide character string representing
//          the PNP Device Id must be put in the buffer. This string will
//          be used to create a key for the device if the buffer contains
//          an EDID. Otherwise, it is used to obtain a PNP ID for the
//          device.
//      3)  Put a miniport determined HANDLE in HwId. This value will be
//          passed back to the miniport for Power management operations,
//          as well as other operations. This allows the miniport to define
//          the contract between the system and the miniport which defines a
//          particular device.
//
//  It should  only return FALSE if there are no devices attached to that
//  display adapter connector.
//

typedef
ULONG
(*PVIDEO_HW_GET_CHILD_DESCRIPTOR) (
    IN  PVOID                   HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO  ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE       VideoChildType,
    OUT PUCHAR                  pChildDescriptor,
    OUT PULONG                  UId,
    OUT PULONG                  pUnused
    );


//
// This routine is used to set the power on the graphics devices.
// These include all the Children enumerated by GET_CHILD_DESCRIPTOR callback
// as well as the graphics adapter itself.
//
// The HwDevice extension represent the adapter instance of the device.
//
// The HwId parameter is the unique ID as returned by the enumeration routine.
// The miniport will only be called to set the power on the devices it
// enumerated, as well as the graphics adapter itself.  A HwId of 0xFFFFFFFF
// will be passed in to identify the graphics adapter itself.
// The miniport driver should never turn off the power to the graphics adapter
// unless specifically request to.
//
// The VideoPowerControl is the level to which the device shold be set.
// The videoport driver will manage these states.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_SET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This routine simply returns whether or not the device can support the
// requested state.
//
// See HW_POWER_SET for a description of the parameters.
//

typedef
VP_STATUS
(*PVIDEO_HW_POWER_GET) (
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

//
// This structure should match the QueryInterface struct defined
// in io.h.
//

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

typedef struct _QUERY_INTERFACE {
    CONST GUID *InterfaceType;
    USHORT Size;
    USHORT Version;
    PINTERFACE Interface;
    PVOID InterfaceSpecificData;
} QUERY_INTERFACE, *PQUERY_INTERFACE;

typedef
VP_STATUS
(*PVIDEO_HW_QUERY_INTERFACE) (
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

typedef
VP_STATUS
(*PVIDEO_HW_CHILD_CALLBACK) (
    PVOID HwDeviceExtension,
    PVOID ChildDeviceExtension
    );

//
// Entry point for all IOCTL calls made to the miniport driver.
//

typedef
BOOLEAN
(*PVIDEO_HW_START_IO) (
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// The return value determines if the mode was completely programmed (TRUE)
// or if an int10 should be done by the HAL to complete the modeset (FALSE).
//

typedef
BOOLEAN
(*PVIDEO_HW_RESET_HW) (
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

//
// Timer routine called every second.
//

typedef
VOID
(*PVIDEO_HW_TIMER) (
    PVOID HwDeviceExtension
    );


//
// Structure passed by the miniport entry point to the video port
// initialization routine.
//

typedef struct _VIDEO_HW_INITIALIZATION_DATA {

    //
    // Supplies the size of the structure in bytes as determined by sizeof().
    //

    ULONG HwInitDataSize;

    //
    // Indicates the bus type the adapter works with, such as Eisa, Isa, MCA.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Supplies a pointer to the miniport driver's find adapter routine.
    //

    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;

    //
    // Supplies a pointer to the miniport driver's initialization routine.
    //

    PVIDEO_HW_INITIALIZE HwInitialize;

    //
    // Supplies a pointer to the miniport driver's interrupt service routine.
    //

    PVIDEO_HW_INTERRUPT HwInterrupt;

    //
    // Supplies a pointer to the miniport driver's start io routine.
    //

    PVIDEO_HW_START_IO HwStartIO;

    //
    // Supplies the size in bytes required for the miniport driver's private
    // device extension. This storage is used by the miniport driver to hold
    // per-adapter information. A pointer to this storage is provided with
    // every call made to the miniport driver. This data storage is
    // initialized to zero by the port driver.
    //

    ULONG HwDeviceExtensionSize;

    //
    // Supplies the number with which device numbering should be started.
    // The device numbering is used to determine which \DeviceX entry under
    // the \Parameters section in the registry should be used for parameters
    // to the miniport driver.
    // The number is *automatically* incremented when the miniport is called
    // back in it's FindAdapter routine due to an appropriate _Again_
    // parameter.
    //

    ULONG StartingDeviceNumber;


    //
    // New for version 3.5
    //

    //
    // Supplies a pointer to the miniport driver's HwResetHw routine.
    //
    // This function is called when the machine needs to bugchecks (go back
    // to the blue screen).
    //
    // This function should reset the video adapter to a character mode,
    // or at least to a state from which an int 10 can reset the card to
    // a character mode.
    //
    // This routine CAN NOT call int10.
    // It can only call Read\Write Port\Register functions from the port driver.
    //
    // The function must also be completely in non-paged pool since the IO\MM
    // subsystems may have crashed.
    //

    PVIDEO_HW_RESET_HW HwResetHw;

    //
    // Pointer to a timer routine to be called every second.
    //

    PVIDEO_HW_TIMER HwTimer;

    //
    //  Start of 5.0 stuff.
    //

    //
    //  Supplies a pointer to the miniport driver's start dma routine. This routine must
    //  return a HW_DMA_RETURN consistent with it's return behavior.
    //

    PVIDEO_HW_START_DMA HwStartDma;

    //
    //  HW dependent Power management routines.
    //

    PVIDEO_HW_POWER_SET HwSetPowerState;
    PVIDEO_HW_POWER_GET HwGetPowerState;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // enumerate devices physically attached to the graphics adapter.
    //

    PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;

    //
    // Supplies a pointer to a miniport driver routine which can be called to
    // query external programming interfaces supported in the miniport
    // driver.
    //

    PVIDEO_HW_QUERY_INTERFACE HwQueryInterface;

    //
    // Size of the device extension associated with the display output device.
    // This should only be set (to the approrpiate size) if the miniport driver
    // needs to manage the monitor configuration data separately from the
    // adapter board configuration (example - multiple output graphics devices).
    //

    ULONG HwChildDeviceExtensionSize;

    //
    // Allows the device to report legacy resources that should be
    // associated with the Plug and Play device.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;

    //
    // Number of elements in the legacy resource list.
    //

    ULONG HwLegacyResourceCount;

    //
    // Call this routine to allow a driver to specify it's
    // legacy resources based on its device/vendor id.
    //

    PVIDEO_HW_LEGACYRESOURCES HwGetLegacyResources;

    //
    // Can HwGetVideoChildDescriptor be called before HwInitialize?
    //

    BOOLEAN AllowEarlyEnumeration;

} VIDEO_HW_INITIALIZATION_DATA, *PVIDEO_HW_INITIALIZATION_DATA;

//
// DDC help routines.
//

typedef
VOID
(*PVIDEO_WRITE_CLOCK_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
VOID
(*PVIDEO_WRITE_DATA_LINE)(
    PVOID HwDeviceExtension,
    UCHAR Data
    );

typedef
BOOLEAN
(*PVIDEO_READ_CLOCK_LINE)(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PVIDEO_READ_DATA_LINE)(
    PVOID HwDeviceExtension
    );

typedef
VOID
(*PVIDEO_WAIT_VSYNC_ACTIVE)(
    PVOID HwDeviceExtension
    );

//
// Data structures used I2C and DDC helper functions.
//

typedef struct _I2C_FNC_TABLE
{
    ULONG                    Size;
    PVIDEO_WRITE_CLOCK_LINE  WriteClockLine;
    PVIDEO_WRITE_DATA_LINE   WriteDataLine;
    PVIDEO_READ_CLOCK_LINE   ReadClockLine;
    PVIDEO_READ_DATA_LINE    ReadDataLine;
    PVIDEO_WAIT_VSYNC_ACTIVE WaitVsync;
    PVOID                    Reserved;
} I2C_FNC_TABLE, *PI2C_FNC_TABLE;

typedef struct _I2C_CALLBACKS
{
    PVIDEO_WRITE_CLOCK_LINE WriteClockLine;
    PVIDEO_WRITE_DATA_LINE  WriteDataLine;
    PVIDEO_READ_CLOCK_LINE  ReadClockLine;
    PVIDEO_READ_DATA_LINE   ReadDataLine;
} I2C_CALLBACKS, *PI2C_CALLBACKS;

typedef struct _DDC_CONTROL
{
    ULONG         Size;
    I2C_CALLBACKS I2CCallbacks;
    UCHAR         EdidSegment;
} DDC_CONTROL, *PDDC_CONTROL;

//
// Types of services exported by the VideoPortQueryServices().
//

typedef enum
{
    VideoPortServicesAGP = 1,
    VideoPortServicesI2C
} VIDEO_PORT_SERVICES;

//
// AGP services interface.
//

typedef struct _VIDEO_PORT_AGP_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PAGP_RESERVE_PHYSICAL  AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL  AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL   AgpCommitPhysical;
    PAGP_FREE_PHYSICAL     AgpFreePhysical;
    PAGP_RESERVE_VIRTUAL   AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL   AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL    AgpCommitVirtual;
    PAGP_FREE_VIRTUAL      AgpFreeVirtual;
    ULONGLONG              AgpAllocationLimit;
} VIDEO_PORT_AGP_INTERFACE, *PVIDEO_PORT_AGP_INTERFACE;

//
// I2C helper routines exported via VideoPortQueryServices().
//

typedef
BOOLEAN
(*PI2C_START)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_STOP)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks
    );

typedef
BOOLEAN
(*PI2C_WRITE)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

typedef
BOOLEAN
(*PI2C_READ)(
    IN PVOID HwDeviceExtension,
    IN PI2C_CALLBACKS I2CCallbacks,
    OUT PUCHAR Buffer,
    IN ULONG Length
    );

//
// I2C services interface.
//

typedef struct _VIDEO_PORT_I2C_INTERFACE
{
    USHORT                 Size;
    USHORT                 Version;
    PVOID                  Context;
    PINTERFACE_REFERENCE   InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    PI2C_START             I2CStart;
    PI2C_STOP              I2CStop;
    PI2C_WRITE             I2CWrite;
    PI2C_READ              I2CRead;
} VIDEO_PORT_I2C_INTERFACE, *PVIDEO_PORT_I2C_INTERFACE;

//
// Flags that can be passed to VideoPortGetDeviceBase or VideoPortMapMemory.
//

#define VIDEO_MEMORY_SPACE_MEMORY    0x00  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_IO        0x01  // Should not be set by display driver
#define VIDEO_MEMORY_SPACE_USER_MODE 0x02  // Memory pointer for application use
#define VIDEO_MEMORY_SPACE_DENSE     0x04  // Mapped dense, linearly (ALPHA)
#define VIDEO_MEMORY_SPACE_P6CACHE   0x08  // P6 MTRR caching (kernel and user)

//
// Define status codes returned by HwGetVideoChildDescriptor()
// miniport enumaration routine.
//
// Note: For backword compatibility reasons these values match
// existing WINERROR codes.
//

//
// Call again (ACPI and non-ACPI devices will be enumerated).
//

#define VIDEO_ENUM_MORE_DEVICES     ERROR_CONTINUE

//
// Stop enumeration.
//

#define VIDEO_ENUM_NO_MORE_DEVICES  ERROR_NO_MORE_DEVICES

//
// Call again, device could not be enumerated.
//

#define VIDEO_ENUM_INVALID_DEVICE   ERROR_INVALID_NAME

//
// Define the bits in VgaStatus.
//

#define DEVICE_VGA_ENABLED          1

//
// Port driver routines called by miniport driver and callbacks.
//

VIDEOPORT_API
VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    );

VIDEOPORT_API
VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
ULONG
VideoPortCompareMemory(
    PVOID Source1,
    PVOID Source2,
    ULONG Length
    );

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID HwDeviceExtension,
    IN PVOID DDCControl,
    IN OUT PUCHAR EdidBuffer,
    IN ULONG EdidBufferSize
    );

VIDEOPORT_API
VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

VIDEOPORT_API
VP_STATUS
VideoPortDisableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnableInterrupt(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VP_STATUS
VideoPortEnumerateChildren(
    IN PVOID HwDeviceExtension,
    IN PVOID Reserved
    );

VIDEOPORT_API
VOID
VideoPortFreeDeviceBase(
    PVOID HwDeviceExtension,
    PVOID MappedAddress
    );

typedef
VP_STATUS
(*PMINIPORT_QUERY_DEVICE_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentiferLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    );

VIDEOPORT_API
PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    );

VIDEOPORT_API
ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
UCHAR
VideoPortGetCurrentIrql();

VIDEOPORT_API
PVOID
VideoPortGetDeviceBase(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfUchars,
    UCHAR InIoSpace
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetDeviceData(
    PVOID HwDeviceExtension,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
    PVOID Context
    );

typedef
VP_STATUS
(*PMINIPORT_GET_REGISTRY_ROUTINE)(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,
    PVOID Context
    );

VIDEOPORT_API
PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    );

VIDEOPORT_API
LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

VIDEOPORT_API
ULONG
VideoPortInitialize(
    PVOID Argument1,
    PVOID Argument2,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PVOID HwContext
    );

VIDEOPORT_API
VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    );

VIDEOPORT_API
VOID
VideoPortLogError(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    VP_STATUS ErrorCode,
    ULONG UniqueId
    );

VIDEOPORT_API
VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    );

VIDEOPORT_API
VOID
VideoPortMoveMemory(
    PVOID Destination,
    PVOID Source,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID HwDeviceExtension,
    IN VIDEO_PORT_SERVICES ServicesType,
    IN OUT PINTERFACE Interface
    );

typedef
VOID
(*PMINIPORT_DPC_ROUTINE)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );

VIDEOPORT_API
BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    );

VIDEOPORT_API
UCHAR
VideoPortReadPortUchar(
    PUCHAR Port
    );

VIDEOPORT_API
USHORT
VideoPortReadPortUshort(
    PUSHORT Port
    );

VIDEOPORT_API
ULONG
VideoPortReadPortUlong(
    PULONG Port
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadPortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
UCHAR
VideoPortReadRegisterUchar(
    PUCHAR Register
    );

VIDEOPORT_API
USHORT
VideoPortReadRegisterUshort(
    PUSHORT Register
    );

VIDEOPORT_API
ULONG
VideoPortReadRegisterUlong(
    PULONG Register
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReadRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortReleaseBuffer(
  IN PVOID HwDeviceExtension,
  IN PVOID Buffer
  );

VIDEOPORT_API
VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    );

VIDEOPORT_API
BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    );

VIDEOPORT_API
ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    BUS_DATA_TYPE BusDataType,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VIDEOPORT_API
VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    );

VIDEOPORT_API
VOID
VideoPortStallExecution(
    ULONG Microseconds
    );

VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    );

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    );

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

BOOLEAN
VIDEOPORT_API
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE synchronizeRoutine,
    PVOID Context
    );

VIDEOPORT_API
VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    );

VIDEOPORT_API
VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VIDEOPORT_API
VOID
VideoPortWritePortUchar(
    PUCHAR Port,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUshort(
    PUSHORT Port,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortUlong(
    PULONG Port,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUchar(
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUshort(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWritePortBufferUlong(
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUchar(
    PUCHAR Register,
    UCHAR Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUshort(
    PUSHORT Register,
    USHORT Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterUlong(
    PULONG Register,
    ULONG Value
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUchar(
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUshort(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortWriteRegisterBufferUlong(
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    );

VIDEOPORT_API
VOID
VideoPortZeroDeviceMemory(
    PVOID Destination,
    ULONG Length
    );

VIDEOPORT_API
VOID
VideoPortZeroMemory(
    PVOID Destination,
    ULONG Length
    );

//
// DMA support.
// TODO: Move to the separate module -- will be obsolete.
//

VIDEOPORT_API
PVOID
VideoPortAllocateContiguousMemory(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            NumberOfBytes,
    IN  PHYSICAL_ADDRESS HighestAcceptableAddress
    );

VIDEOPORT_API
PVOID
VideoPortGetCommonBuffer(
    IN  PVOID                       HwDeviceExtension,
    IN  ULONG                       DesiredLength,
    IN  ULONG                       Alignment,
    OUT PPHYSICAL_ADDRESS           LogicalAddress,
    OUT PULONG                      pActualLength,
    IN  BOOLEAN                     CacheEnabled
    );

VIDEOPORT_API
VOID
VideoPortFreeCommonBuffer(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            Length,
    IN  PVOID            VirtualAddress,
    IN  PHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN          CacheEnabled
    );

VIDEOPORT_API
PDMA
VideoPortDoDma(
    IN      PVOID                   HwDeviceExtension,
    IN      PDMA                    pDma,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pUEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnlockPages(
    PVOID   hwDeviceExtension,
    PDMA    pDma
    );

VIDEOPORT_API
BOOLEAN
VideoPortSignalDmaComplete(
    IN  PVOID               HwDeviceExtension,
    IN  PDMA                pDmaHandle
    );

VIDEOPORT_API
BOOLEAN
VideoPortCompleteDma(
    IN  PVOID           HwDeviceExtension,
    IN  PDMA            pDmaHandle,
    IN  DMA_EVENT_FLAGS CompletionFlags
    );

VIDEOPORT_API
PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
PVOID
VideoPortGetDmaContext(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetDmaContext(
    IN  PVOID   HwDeviceExtension,
    OUT PDMA    pDma,
    IN  PVOID   InstanceContext
    );

VIDEOPORT_API
ULONG
VideoPortGetBytesUsed(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VIDEOPORT_API
VOID
VideoPortSetBytesUsed(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      ULONG   BytesUsed
    );

VIDEOPORT_API
PDMA
VideoPortAssociateEventsWithDmaHandle(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent
    );

VIDEOPORT_API
PDMA
VideoPortMapDmaMemory(
    IN      PVOID                   HwDeviceExtension,
    IN      PVIDEO_REQUEST_PACKET   pVrp,
    IN      PHYSICAL_ADDRESS        BoardAddress,
    IN      PULONG                  Length,
    IN      PULONG                  InIoSpace,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent,
    IN OUT  PVOID                 * VirtualAddress
    );

VIDEOPORT_API
BOOLEAN
VideoPortUnmapDmaMemory(
    PVOID               HwDeviceExtension,
    PVOID               VirtualAddress,
    HANDLE              ProcessHandle,
    PDMA                BoardMemoryHandle
    );

//
// TODO: End of move block.
//

#endif // ifndef __VIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\ddc.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ddc.c

Abstract:

    This is the NT Video port Display Data Channel (DDC) code. It contains the
    implementations for the EDID industry standard Extended Display
    Identification Data manipulations.

Author:

    Bruce McQuistan (brucemc) 23-Sept-1996

Environment:

    kernel mode only

Notes:

    Based on VESA EDID Specification Version 2, April 9th, 1996
    Updated to support VESA E-DDC Proposed Standard Version 1P, July 13, 1999.

--*/

#include "videoprt.h"

//
// Make it easy to change debug verbosity.
//

#define DEBUG_DDC                   1

//
// Define constants used by DDC.
//

#define EDID_1_SIZE                 128
#define EDID_2_SIZE                 256
#define EDID_QUERY_RETRIES          5
#define DDC_ADDRESS_SET_OFFSET      (UCHAR)0xA0    // To set word offset into EDID
#define DDC_ADDRESS_READ            (UCHAR)0xA1    // To read EDID
#define DDC_ADDRESS_PD_SET_OFFSET   (UCHAR)0xA2    // As above for display with P&D connector
#define DDC_ADDRESS_PD_READ         (UCHAR)0xA3    // As above for display with P&D connector
#define DDC_ADDRESS_SET_SEGMENT     (UCHAR)0x60    // To set index to 256 bytes EDID segment

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, VideoPortDDCMonitorHelper)
#pragma alloc_text (PAGE, DDCReadEdidSegment)
#endif  // ALLOC_PRAGMA

//
// Exported routines.
//

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID pHwDeviceExtension,
    IN PVOID pDDCControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize
    )

/*++

Routine Description:

    This routine reads the EDID structure from the monitor using DDC.

    If caller asks for 256 bytes he may receive:
        1. One 128 bytes EDID
        2. Two 128 bytes EDIDs
        3. One 256 bytes EDID (from P&D display)
        4. No EDID

    Caller should always ask for 256 bytes, since it is impossble to
    read second 128 bytes block of the segment only.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pDDCControl        - DDC access control block.
    pucEdidBuffer      - Buffer where information will be stored.
                         For ACPI devices first four bytes are preset by
                         the videoprt to indicated attempt to read the EDID.
                         We should clear those bytes in case of the EDID
                         read failure to prevent videoprt from unnecessary
                         call of the ACPI method.
    ulEdidBufferSize   - Size of the buffer to fill.

Returns:

    TRUE  - DDC read OK.
    FALSE - DDC read failed.

--*/

{
    ULONG ulChecksum;                   // EDID checksum
    ULONG ulScratch;                    // Temp variable
    ULONG ulTry;                        // EDID read retry counter
    ULONG ulSize;                       // EDID size to read
    UCHAR ucEdidSegment;                // E-DDC segment to read
    BOOLEAN bEnhancedDDC;               // Use enhanced DDC flag
    PI2C_CALLBACKS pI2CCallbacks;       // I2C lines handling functions

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pDDCControl);
    ASSERT(NULL != pucEdidBuffer);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // Check the size of the input structure.
    //

    if (((PDDC_CONTROL)pDDCControl)->Size == sizeof (I2C_FNC_TABLE))
    {
        ucEdidSegment = 0;
        bEnhancedDDC  = FALSE;      // Make sure we are backword compatible
    }
    else if (((PDDC_CONTROL)pDDCControl)->Size == sizeof (DDC_CONTROL))
    {
        ucEdidSegment = ((PDDC_CONTROL)pDDCControl)->EdidSegment;
        bEnhancedDDC  = TRUE;
    }
    else
    {
        pVideoDebugPrint((0, "VIDEOPRT!VideoPortDDCMonitorHelper: Invalid DDC_CONTROL\n"));
        ASSERT(FALSE);
        return FALSE;
    }

    pI2CCallbacks = (PI2C_CALLBACKS)&(((PDDC_CONTROL)pDDCControl)->I2CCallbacks);

    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);

    //
    // Initialize I2C lines and switch monitor to DDC2 mode only for the first EDID.
    // This is the most time consuming operation, we don't want to repeat it.
    // We can safely assume we'll be always asked for the segment 0 first.
    // Once switched to DDC2 the monitor will stay in that mode.
    //

    if (0 == ucEdidSegment)
    {
        //
        // Initialize SDA and SCL lines to default state of released high (input).
        //

        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);
        DELAY_MICROSECONDS(5);
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);
        DELAY_MICROSECONDS(5);

        //
        // Send 9 clock pulses on SCL to switch DDC2-capable monitor to DDC2 mode.
        //

        for (ulScratch = 0; ulScratch < 9; ulScratch++)
        {
            pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);
            DELAY_MICROSECONDS(5);
            pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);
            DELAY_MICROSECONDS(5);
        }

        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortDDCMonitorHelper: Can't switch to DDC2\n"));
            RtlZeroMemory(pucEdidBuffer, sizeof (ULONG));   // Let videoprt know we tried to read
            return FALSE;
        }
    }

    //
    // Using A0/A1 we can read two 128 byte EDIDs. If we are asked for a bigger size
    // we will do two reads.
    //

    ulSize = ulEdidBufferSize > EDID_1_SIZE ? EDID_1_SIZE : ulEdidBufferSize;

    if (DDCReadEdidSegment(pHwDeviceExtension,
                           pI2CCallbacks,
                           pucEdidBuffer,
                           ulSize,
                           ucEdidSegment,
                           0x00,
                           DDC_ADDRESS_SET_OFFSET,
                           DDC_ADDRESS_READ,
                           bEnhancedDDC) == TRUE)
    {
        if (ulEdidBufferSize <= EDID_1_SIZE)
        {
            return TRUE;
        }

        ulSize = ulEdidBufferSize - EDID_1_SIZE;

        //
        // We can read maximum two EDIDs per segment - make sure our size is correct.
        //

        if (ulSize > EDID_1_SIZE)
        {
            ulSize = EDID_1_SIZE;
        }

        //
        // We don't care about return code here - we've already got first EDID,
        // and it is possible the second one doesn't exist.
        //

        DDCReadEdidSegment(pHwDeviceExtension,
                           pI2CCallbacks,
                           pucEdidBuffer + EDID_1_SIZE,
                           ulSize,
                           ucEdidSegment,
                           0x80,
                           DDC_ADDRESS_SET_OFFSET,
                           DDC_ADDRESS_READ,
                           bEnhancedDDC);

        return TRUE;
    }

    //
    // Check for P&D 256 EDID at A2/A3 only for segment 0.
    //

    if (0 != ucEdidSegment)
        return FALSE;

    //
    // P&D display is a special case - its 256 bytes EDID can be accessed using
    // A2/A3 or using segment 1 and A0/A1. We shoudn't read its EDID twice though
    // since we're going to use A2/A3 only if we can't read segment 0 using A0/A1,
    // which most likely means that there are no multiple EDIDs.
    //
    // Note: In this case we don't want to program E-DDC segment, so we just
    // always force bEnhancedDDC to FALSE.
    //

    return DDCReadEdidSegment(pHwDeviceExtension,
                              pI2CCallbacks,
                              pucEdidBuffer,
                              ulEdidBufferSize,
                              ucEdidSegment,
                              0x00,
                              DDC_ADDRESS_PD_SET_OFFSET,
                              DDC_ADDRESS_PD_READ,
                              FALSE);
}   // VideoPortDDCMonitorHelper()

//
// Local routines.
//

BOOLEAN
DDCReadEdidSegment(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize,
    IN UCHAR ucEdidSegment,
    IN UCHAR ucEdidOffset,
    IN UCHAR ucSetOffsetAddress,
    IN UCHAR ucReadAddress,
    IN BOOLEAN bEnhancedDDC
    )

/*++

Routine Description:

    This routine reads the EDID structure at given segment.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C lines control functions.
    pucEdidBuffer      - Buffer where information will be stored.
    ulEdidBufferSize   - Size of the buffer to fill.
    ucEdidSegment      - 256 bytes EDID segment to read.
    ucEdidOffset       - Offset within the segment.
    ucSetOffsetAddress - DDC command.
    ucReadAddress      - DDC command.
    bEnhancedDDC       - TRUE if we want to use 0x60 for segment addressing.

Returns:

    TRUE  - DDC read OK.
    FALSE - DDC read failed.

--*/

{
    ULONG ulScratch;                    // Temp variable
    ULONG ulTry;                        // EDID read retry counter

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucEdidBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulTry = 0; ulTry < EDID_QUERY_RETRIES; ulTry++)
    {
        RtlZeroMemory(pucEdidBuffer, ulEdidBufferSize);

        //
        // Set EDID segment for E-DDC.
        //

        if (TRUE == bEnhancedDDC)
        {
            if (I2CStart(pHwDeviceExtension, pI2CCallbacks) == FALSE)
            {
                I2CStop(pHwDeviceExtension, pI2CCallbacks);
                pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
                continue;
            }

            pucEdidBuffer[0] = DDC_ADDRESS_SET_SEGMENT;
            pucEdidBuffer[1] = ucEdidOffset;

            if (I2CWrite(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, 2) == FALSE)
            {
                //
                // For segment 0 we don't care about return code here since monitor
                // may not support E-DDC.
                //

                if (0 != ucEdidSegment)
                {
                    I2CStop(pHwDeviceExtension, pI2CCallbacks);
                    pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
                    continue;
                }
            }
        }

        if (I2CStart(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
            continue;
        }

        //
        // Set offset to read from.
        //

        pucEdidBuffer[0] = ucSetOffsetAddress;
        pucEdidBuffer[1] = ucEdidOffset;

        if (I2CWrite(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, 2) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
            continue;
        }

        if (I2CStart(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
            continue;
        }

        //
        // Tell the monitor that we want to read EDID.
        //

        pucEdidBuffer[0] = ucReadAddress;

        if (I2CWrite(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, 1) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
            continue;
        }

        //
        // Read EDID from the monitor.
        //

        if (I2CRead(pHwDeviceExtension, pI2CCallbacks, pucEdidBuffer, ulEdidBufferSize) == FALSE)
        {
            I2CStop(pHwDeviceExtension, pI2CCallbacks);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C read\n"));
            continue;
        }

        I2CStop(pHwDeviceExtension, pI2CCallbacks);

        //
        // Calculate the EDID checksum in case when we read full EDID.
        // We should have 0x00 in LSB for proper EDID.
        //

        if (((EDID_1_SIZE == ulEdidBufferSize) && ((0x00 == ucEdidOffset) || (0x80 == ucEdidOffset))) ||
            ((EDID_2_SIZE == ulEdidBufferSize) && (0x00 == ucEdidOffset)))
        {
            ULONG ulChecksum = 0;

            for (ulScratch = 0; ulScratch < ulEdidBufferSize; ulScratch++)
                ulChecksum += pucEdidBuffer[ulScratch];
  
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: EDID checksum = 0x%08X\n", ulChecksum));

            if (((ulChecksum & 0xFF) == 0) && (0 != ulChecksum))
            {
                pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Full EDID read OK\n"));
                return TRUE;
            }

            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Invalid checksum\n"));
        }
        else
        {
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Partial EDID read OK\n"));
            return TRUE;
        }
    }

    pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed\n"));
    RtlZeroMemory(pucEdidBuffer, sizeof (ULONG));   // Let videoprt know we tried to read
    return FALSE;
}   // DDCReadEdidSegment()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\agp.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    agp.c

Abstract:

    This is the agp portion of the video port driver.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/


#include "videoprt.h"

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

#pragma alloc_text(PAGE,VpQueryAgpInterface)
#pragma alloc_text(PAGE,AgpReservePhysical)
#pragma alloc_text(PAGE,AgpReleasePhysical)
#pragma alloc_text(PAGE,AgpCommitPhysical)
#pragma alloc_text(PAGE,AgpFreePhysical)
#pragma alloc_text(PAGE,AgpReserveVirtual)
#pragma alloc_text(PAGE,AgpReleaseVirtual)
#pragma alloc_text(PAGE,AgpCommitVirtual)
#pragma alloc_text(PAGE,AgpFreeVirtual)
#pragma alloc_text(PAGE,VideoPortGetAgpServices)
#pragma alloc_text(PAGE,AddRangeToReservedRegion)
#pragma alloc_text(PAGE,RemoveRangeFromReservedRegion)
#pragma alloc_text(PAGE,CreateBitField)
#pragma alloc_text(PAGE,ModifyRegion)
#pragma alloc_text(PAGE,FindFirstRun)

VOID
DumpBitField(
    PREGION Region
    )
{
    ULONG i;
    ULONG Index = 0;
    ULONG Mask = 1;

    for (i=0; i<Region->Length; i++) {
        if (Mask & Region->BitField[Index]) {
            pVideoDebugPrint((1, "1"));
        } else {
            pVideoDebugPrint((1, "0"));
        }
        Mask <<= 1;
        if (Mask == 0) {
            Index++;
            Mask = 1;
        }
    }
    pVideoDebugPrint((1, "\n"));
}

BOOLEAN
CreateBitField(
    ULONG Length,
    PREGION *Region
    )

/*++

Routine Description:

    This routine creates and initializes a bitfield.

Arguments:

    Length - Number of items to track.

    Region - Location in which to store the pointer to the REGION handle.

Returns:

    TRUE - the the bitfield was created successfully, 
    FALSE - otherwise.

--*/

{
    ULONG NumDwords = (Length + 31) / 32;
    BOOLEAN bRet = FALSE;
    PREGION Buffer;

    Buffer = (PREGION) ExAllocatePoolWithTag(PagedPool, sizeof(REGION) + (NumDwords - 1) * sizeof(ULONG), POOL_TAG);

    if (Buffer) {

        Buffer->Length = Length;
        Buffer->NumDwords = NumDwords;
        memset(&Buffer->BitField[0], 0, NumDwords * 4);

        bRet = TRUE;
    }

    *Region = Buffer;
    return bRet;
}

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    )

/*++

Routine Description:

    Sets 'Length' bits starting at position 'Offset' in the bitfield.

Arguments:

    Region - Pointer to the region to modify.

    Offset - Offset into the bitfield at which to start.

    Length - Number of bits to set.

    Set - TRUE if you want to set the region, FALSE to clear it.


--*/

{
    ULONG Index = Offset / 32;
    ULONG Count = ((Offset + Length - 1) / 32) - Index;
    ULONG lMask = ~((1 << (Offset & 31)) - 1);
    ULONG rMask = ((1 << ((Offset + Length - 1) & 31)) * 2) - 1;
    PULONG ptr = &Region->BitField[Index];

    ASSERT(Length != 0);

    if (Count == 0) {

        //
        // Only one DWORD is modified, so combine left and right masks.
        //

        lMask &= rMask;
    }

    if (Set) {

        *ptr++ |= lMask;

        while (Count > 1) {
            *ptr++ |= 0xFFFFFFFF;
            Count--;
        }

        if (Count) {
            *ptr |= rMask;
        }

    } else {

        *ptr++ &= ~lMask;

        while (Count > 1) {
            *ptr++ &= 0;
            Count--;
        }

        if (Count) {
            *ptr++ &= ~rMask;
        }
    }

#if DBG
    pVideoDebugPrint((1, "Current BitField for Region: 0x%x\n", Region));
    DumpBitField(Region);
#endif
}

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    )

/*++

Routine Description:

    This routine finds the first run of bits in a bitfield.

Arguments:

    Region - Pointer to the region to operate on.

    Offset - Pointer to a ULONG to hold the offset of the run.

    Length - Pointer to a ULONG to hold the length of a run.

Returns:

    TRUE if a run was detected,
    FALSE otherwise.

--*/

{
    PULONG ptr = Region->BitField;
    ULONG Index = 0;
    ULONG BitMask;
    ULONG lsb;
    ULONG Count;
    ULONG ptrVal;

    while ((Index < Region->NumDwords) && (*ptr == 0)) {
        ptr++;
        Index++;
    }

    if (Index == Region->NumDwords) {
        return FALSE;
    }

    //
    // Find least significant bit
    //

    lsb = 0;
    ptrVal = *ptr;
    BitMask = 1;

    while ((ptrVal & BitMask) == 0) {
        BitMask <<= 1;
        lsb++;
    }

    *Offset = (Index * 32) + lsb;

    //
    // Determine the run length
    //

    Count = 0;

    while (Index < Region->NumDwords) {
        if (ptrVal & BitMask) {
            BitMask <<= 1;
            Count++;

            if (BitMask == 0) {
                BitMask = 0x1;
                Index++;
                ptrVal = *++ptr;
                while ((ptrVal == 0xFFFFFFFF) && (Index < Region->NumDwords)) {
                    Index++;
                    Count += 32;
                    ptrVal = *ptr++;
                }
            }

        } else {
            break;
        }
    }

    *Length = Count;
    return TRUE;
}

BOOLEAN
VpQueryAgpInterface(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent (the PCI bus driver) to
    retrieve the AGP_BUS_INTERFACE.

Returns:

    NT_STATUS code

--*/

{
    KEVENT             Event;
    PIRP               QueryIrp = NULL;
    IO_STATUS_BLOCK    IoStatusBlock;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS           Status;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return FALSE;
    }

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set the default error code.
    //

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_AGP_BUS_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = 1;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->AgpInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    FdoExtension->AgpInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    FdoExtension->AgpInterface.Version = 1;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    return NT_SUCCESS(Status);
}

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    Pages - Number of pages to reserve

    Caching - Specifies the type of caching to use

    PhysicalReserveContext - Location to store our reservation context.

Returns:

    The base of the physical address range reserved.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS PhysicalAddress = {0,0};
    NTSTATUS status;
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PVOID MapHandle;

    pVideoDebugPrint((1, "AGP: Reserving 0x%x Pages of Address Space\n", Pages));

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(PHYSICAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(Pages, &ReserveContext->Region)) {

            status = fdoExtension->AgpInterface.ReserveMemory(
                         fdoExtension->AgpInterface.AgpContext,
                         Pages,
                         Caching ? MmWriteCombined : MmNonCached,
                         &MapHandle,
                         &PhysicalAddress);

            if (NT_SUCCESS(status)) {

                ReserveContext->Pages = Pages;
                ReserveContext->Caching = Caching;
                ReserveContext->MapHandle = MapHandle;
                ReserveContext->PhysicalAddress = PhysicalAddress;

            } else {

                ExFreePool(ReserveContext->Region);
                goto FailureCase;
            }

        } else {

            goto FailureCase;
        }
    }

    *PhysicalReserveContext = ReserveContext;
    return PhysicalAddress;

FailureCase:

    PhysicalAddress.QuadPart = 0;
    ExFreePool(ReserveContext);
    *PhysicalReserveContext = NULL;

    return PhysicalAddress;
}

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of reserved physical address.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    ULONG Pages;
    ULONG Offset;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    pVideoDebugPrint((1, "AGP: Releasing 0x%x Pages of Address Space\n", ReserveContext->Pages));

    //
    // Make sure all pages have been freed
    //

    while (FindFirstRun(ReserveContext->Region, &Offset, &Pages)) {
        AgpFreePhysical(Context, PhysicalReserveContext, Pages, Offset);
    }

    fdoExtension->AgpInterface.ReleaseMemory(fdoExtension->AgpInterface.AgpContext,
                                             ReserveContext->MapHandle);

    ExFreePool(ReserveContext->Region);
    ExFreePool(ReserveContext);
}

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS MemoryBase = {0,0};
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    NTSTATUS status;
    PMDL Mdl;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    status =
        fdoExtension->AgpInterface.CommitMemory(fdoExtension->AgpInterface.AgpContext,
                                                ReserveContext->MapHandle,
                                                Pages,
                                                Offset,
                                                NULL,
                                                &MemoryBase);

    if (NT_SUCCESS(status)) {

        ModifyRegion(ReserveContext->Region, Offset, Pages, TRUE);
        return TRUE;

    } else {

        return FALSE;
    }
}

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PMDL Mdl;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    fdoExtension->AgpInterface.FreeMemory(fdoExtension->AgpInterface.AgpContext,
                                          ReserveContext->MapHandle,
                                          Pages,
                                          Offset);

    ModifyRegion(ReserveContext->Region, Offset, Pages, FALSE);
}


PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    )

/*++

Routine Description:

    Reserves a range of virtual addresses for AGP.

Arguments:

    Context - The Agp Context

    ProcessHandle - The handle of the process in which to reserve the
        virtual address range.

    PhysicalReserveContext - The physical reservation context to assoctiate
        with the given virtual reservation.

    VirtualReserveContext - The location in which to store the virtual
        reserve context.

Returns:

    The base of the virtual address range reserved.

Notes:

    You can't reserve a range of kernel address space, but if you want to
    commit into kernel space you still need a reservation handle.  Pass in
    NULL for the process handle in this case.

    For the moment, we'll commit the entire region when the do a reservation
    in kernel space.  Then Commit and Free will be no-ops.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Protect = PAGE_READWRITE;
    PVIRTUAL_RESERVE_CONTEXT ReserveContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    SIZE_T Length;
    PVOID VirtualAddress = NULL;
    PEPROCESS Process = NULL;

    PhysicalContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    Length = PhysicalContext->Pages * PAGE_SIZE;

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(VIRTUAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(PhysicalContext->Pages, &ReserveContext->Region)) {

            //
            // BUGBUG: Fix this routine for kernel mode reservation!
            //

            if (!PhysicalContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            //
            // Make sure we have the real process handle.
            //

            if (ProcessHandle == NtCurrentProcess()) {
                Process = PsGetCurrentProcess();
            }

            ReserveContext->ProcessHandle = ProcessHandle;
            ReserveContext->Process = Process;
            ReserveContext->PhysicalReserveContext =
                (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
            ReserveContext->ReservationList = NULL;

            if (ProcessHandle) {

                VirtualAddress =
                    AddRangeToReservedRegion(ReserveContext,
                                             PhysicalContext->Pages,
                                             0);

                ASSERT(VirtualAddress != NULL);

            } else {

                //
                // BUGBUG: Find a better way to reserve in kernel space.
                //
                // For a kernel reservation, go ahead and commit the
                // entire range.
                //

                if (fdoExtension->AgpInterface.Capabilities &
                    AGP_CAPABILITIES_MAP_PHYSICAL)
                {
                    //
                    // CPU can access AGP memory through AGP aperature.
                    //

                    VirtualAddress =
                        MmMapIoSpace(PhysicalContext->PhysicalAddress,
                                     PhysicalContext->Pages * PAGE_SIZE,
                                     PhysicalContext->Caching ? MmFrameBufferCached : 0);
                    //
                    // Not all systems support USWC, so if we attempted to map USWC
                    // and failed, try again with just non-cached.
                    //
                    if ((VirtualAddress == NULL) &&
                        (PhysicalContext->Caching)) {
                        VirtualAddress = MmMapIoSpace(PhysicalContext->PhysicalAddress,
                                                      PhysicalContext->Pages * PAGE_SIZE,
                                                      MmNonCached);
                    }

                } else {

                    PMDL Mdl;

                    //
                    // Get the MDL for the range we are trying to map.
                    //

                    Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

                    if (Mdl) {

                        fdoExtension->AgpInterface.GetMappedPages(
                                         fdoExtension->AgpInterface.AgpContext,
                                         PhysicalContext->MapHandle,
                                         PhysicalContext->Pages,
                                         0,
                                         Mdl);

                        //
                        // We must use the CPU's virtual memory mechanism to
                        // make the non-contiguous MDL look contiguous.
                        //

                        VirtualAddress =
                            MmMapLockedPagesSpecifyCache(
                                Mdl,
                                (KPROCESSOR_MODE)KernelMode,
                                PhysicalContext->Caching ? MmCached : MmNonCached,
                                NULL,
                                TRUE,
                                HighPagePriority);

                        ExFreePool(Mdl);
                    }
                }
            }

            ReserveContext->VirtualAddress = VirtualAddress;

        } else {

            pVideoDebugPrint((1, "Couldn't create bit field.\n"));
            ExFreePool(ReserveContext);
            ReserveContext = NULL;
        }

    } else {

        pVideoDebugPrint((1, "AgpReserveVirtual: Out of memory.\n"));
    }

    *VirtualReserveContext = ReserveContext;
    return VirtualAddress;
}

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    )

/*++

Routine Description:

    Releases a range of reserved virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    SIZE_T Length;
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    ULONG Offset;
    ULONG Pages;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    if (VirtualContext->ProcessHandle) {

        //
        // Make sure all pages have been freed
        //

        while (FindFirstRun(VirtualContext->Region, &Offset, &Pages)) {
            AgpFreeVirtual(Context, VirtualReserveContext, Pages, Offset);
        }

        if (VirtualContext->VirtualAddress) {

            ASSERT(VirtualContext->ReservationList->Next == NULL);

            RemoveRangeFromReservedRegion(VirtualContext,
                                          VirtualContext->ReservationList->Pages,
                                          VirtualContext->ReservationList->Offset);

            if (VirtualContext->ReservationList) {

                ExFreePool(VirtualContext->ReservationList);
                VirtualContext->ReservationList = NULL;
            }
        }

        ExFreePool(VirtualContext->Region);
        ExFreePool(VirtualContext);

    } else {

        //
        // This was kernel virtual memory, so release the memory we
        // committed at reserve time.
        //

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            MmUnmapIoSpace(VirtualContext->VirtualAddress,
                           PhysicalContext->Pages * PAGE_SIZE);

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                PhysicalContext->Pages,
                                0,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualContext->VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }
    }
}

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Adds a range to a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    NTSTATUS Status;
    PRESERVATION_LIST Curr, Prev = NULL;

    pVideoDebugPrint((1, "AddPagesToReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    if (VirtualContext->ReservationList) {

        //
        // We are making the assumption that if range is added, and we
        // already have a reservation list, that we had removed a region
        // because we mapped it, and now we are adding it back.  So we
        // should be able to scan for a region, and just set the
        // reserved bit to TRUE.  We can then concatinate with existing
        // right or left regions.
        //

        Curr = VirtualContext->ReservationList;

        while (Curr) {

            if (Curr->Offset == Offset)
                break;

            Prev = Curr;
            Curr = Curr->Next;
        }

        pVideoDebugPrint((1, "Region to Reserve:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        //
        // If the region is already reserved, simply return.
        //

        if (Curr->Reserved == TRUE) {
            pVideoDebugPrint((1, "Region is already reserved!\n"));
            return NULL;
        }

        //
        // If there is still an allocation in this region, then return.
        //

        if (--Curr->RefCount) {
            pVideoDebugPrint((1, "Region is still in use.\n"));
            return NULL;
        }

        pVideoDebugPrint((1, "Marking region as reserved.\n"));

        Curr->Reserved = TRUE;

        //
        // See if we can concatinate with the left or right region.
        //

        if (Prev && (Prev->Reserved)) {

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Prev->Offset * PAGE_SIZE);
            Length = Prev->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(ZwFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with previous range.\n"));

            Prev->Pages += Curr->Pages;
            Prev->Next = Curr->Next;

            ExFreePool(Curr);

            Curr = Prev;
        }

        if (Curr->Next && (Curr->Next->Reserved)) {

            PRESERVATION_LIST Next = Curr->Next;

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Next->Offset * PAGE_SIZE);
            Length = Next->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(ZwFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with next range.\n"));

            Curr->Pages += Next->Pages;
            Curr->Next = Next->Next;

            ExFreePool(Next);
        }

        pVideoDebugPrint((1, "Expanded Region:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);

    } else {

        //
        // Indicate we don't care where we reserve from.
        //

        VirtualAddress = NULL;

        Curr = ExAllocatePoolWithTag(PagedPool,
                                     sizeof(RESERVATION_LIST),
                                     POOL_TAG);

        if (Curr) {

            Curr->Offset   = Offset;
            Curr->Pages    = Pages;
            Curr->RefCount = 0;
            Curr->Reserved = TRUE;
            Curr->Next     = NULL;

            VirtualContext->ReservationList = Curr;

        } else {

            return NULL;
        }
    }

    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Reserving 0x%x bytes at virtual address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    Status = ZwAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                            &VirtualAddress,
                                            0,
                                            &Length,
                                            MEM_RESERVE,
                                            Protect);

    if (!NT_SUCCESS(Status)) {

        pVideoDebugPrint((1, "Status = 0x%x\n", Status));
        ASSERT(FALSE);
        return NULL;
    }

    return VirtualAddress;
}

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Release a sub range of a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PRESERVATION_LIST ReservationList, Curr, Prev = NULL;
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    ULONG_PTR Address, ExcessPages;

    pVideoDebugPrint((1, "RemovePagesFromReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    ASSERT(VirtualContext->ReservationList != NULL);

    Curr = VirtualContext->ReservationList;

    while (Curr) {

        if ((Curr->Offset <= Offset) &&
            ((Curr->Offset + Curr->Pages) > Offset)) {

            break;
        }

        Prev = Curr;
        Curr = Curr->Next;
    }

    pVideoDebugPrint((1, "Range to fill into:\n"
                         "  Offset: 0x%x\n"
                         "  Pages: 0x%x\n",
                         Curr->Offset,
                         Curr->Pages));


    ASSERT(Curr != NULL);

    //
    // If the region is already free, simply return.
    //

    if (Curr->Reserved == FALSE) {
        Curr->RefCount++;
        return;
    }

    //
    // Release the region which we are mapping into.
    //

    VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);
    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    if (!NT_SUCCESS(ZwFreeVirtualMemory(VirtualContext->ProcessHandle,
                                        &VirtualAddress,
                                        &Length,
                                        MEM_RELEASE)))
    {
        ASSERT(FALSE);
    }

    //
    // Mark the region as not reserved.
    //

    Curr->Reserved = FALSE;
    Curr->RefCount++;

    //
    // Now see if we have sub regions to re-reserve.
    //

    if (Curr->Offset < Offset) {

        //
        // There will be a left over region prior to Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset;
            ReservationList->Pages = Offset - Curr->Offset;
            ReservationList->RefCount = 0;
            ReservationList->Next = Curr;
            ReservationList->Reserved = TRUE;

            Curr->Pages -= Offset - Curr->Offset;
            Curr->Offset = Offset;

        } else {

            return;
        }

        if (Prev) {
            Prev->Next = ReservationList;
        } else {
            VirtualContext->ReservationList = ReservationList;
        }

        pVideoDebugPrint((1, "Creating 'left' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));

        //
        // Calculate the virtual address and length of the memory to reserve.
        // Note that ZwAllocateVirtualMemory always rounds to a 64K boundary,
        // so we'll have to round up to prevent it from rounding down.
        //

        Address = ((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        VirtualAddress = (PULONG)Address;

        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(ZwAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    if (Curr->Pages > Pages) {

        //
        // There will be a left over region after Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset + Pages;
            ReservationList->Pages = Curr->Pages - Pages;
            ReservationList->RefCount = 0;
            ReservationList->Reserved = TRUE;

            Curr->Pages = Pages;

        } else {

            //
            // BUGBUG:
            //
            // If we return here then we have to adjacent blocks
            // which are both reserved.  This will not cause a
            // problem, but it will never be cleaned up.
            //

            return;
        }

        pVideoDebugPrint((1, "Creating 'right' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));


        ReservationList->Next = Curr->Next;
        Curr->Next = ReservationList;

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(ZwAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    return;
}

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    The virtual address for the base of the commited pages.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress = NULL;
    HANDLE PhysicalMemoryHandle;
    NTSTATUS ntStatus;
    BOOLEAN bUserMode;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    PhysicalAddress = PhysicalContext->PhysicalAddress;
    PhysicalAddress.LowPart += Offset * PAGE_SIZE;

    bUserMode = VirtualContext->ProcessHandle != NULL;

    if (bUserMode) {

        //
        // First release the VA range we are going to map into.
        //

        RemoveRangeFromReservedRegion(VirtualContext,
                                      Pages,
                                      Offset);

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            //
            // CPU can access AGP memory through AGP aperature.
            //

            //
            // Get a handle to the physical memory section using our pointer.
            // If this fails, return.
            //

            ntStatus =
                ObOpenObjectByPointer(
                    PhysicalMemorySection,
                    0L,
                    (PACCESS_STATE) NULL,
                    SECTION_ALL_ACCESS,
                    (POBJECT_TYPE) NULL,
                    KernelMode,
                    &PhysicalMemoryHandle);

            //
            // If successful, map the memory.
            //

            if (NT_SUCCESS(ntStatus)) {

                SIZE_T Length = Pages * PAGE_SIZE;
                ULONG Protect = PAGE_READWRITE;

                VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

                if (!PhysicalContext->Caching) {
                    Protect |= PAGE_NOCACHE;
                }

                ntStatus =
                    ZwMapViewOfSection(
                        PhysicalMemoryHandle,
                        VirtualContext->ProcessHandle,
                        &VirtualAddress,
                        0,
                        Pages * PAGE_SIZE,
                        &PhysicalAddress,
                        &Length,
                        ViewUnmap,
                        0,
                        Protect);

                pVideoDebugPrint((1, "ntStatus = 0x%x\n", ntStatus));

                ZwClose(PhysicalMemoryHandle);

            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                 fdoExtension->AgpInterface.AgpContext,
                                 PhysicalContext->MapHandle,
                                 Pages,
                                 Offset,
                                 Mdl);

                //
                // We must use the CPU's virtual memory mechanism to
                // make the non-contiguous MDL look contiguous.
                //

                VirtualAddress =
                    MmMapLockedPagesSpecifyCache(
                        Mdl,
                        (KPROCESSOR_MODE)UserMode,
                        PhysicalContext->Caching ? MmCached : MmNonCached,
                        (PVOID)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE),
                        TRUE,
                        HighPagePriority);

                ExFreePool(Mdl);
            }
        }

        if (VirtualAddress) {
            ModifyRegion(VirtualContext->Region, Offset, Pages, TRUE);
        }

    } else {

        //
        // Kernel mode commit.  Do nothing.
        //

        VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);
    }

    return VirtualAddress;
}

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Frees a range of virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    VirtualAddress = (PUCHAR)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

    //
    // Make sure we are in the correct process context.
    //

    if (VirtualContext->ProcessHandle != NULL) {

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

                ZwUnmapViewOfSection(
                    VirtualContext->ProcessHandle,
                    VirtualAddress);

            } else {

                MmUnmapIoSpace(VirtualAddress,
                               Pages * PAGE_SIZE);
            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                Pages,
                                Offset,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }

        if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

            AddRangeToReservedRegion(VirtualContext,
                                     Pages,
                                     Offset);
        }

        ModifyRegion(VirtualContext->Region, Offset, Pages, FALSE);

    } else {

        //
        // Kernel Space Free - do nothing.
        //
    }
}

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    OUT PVIDEO_PORT_AGP_SERVICES AgpServices
    )

/*++

Routine Description:

    This routine returns a set of AGP services to the caller.

Arguments:

    HwDeviceExtension - Pointer to the miniports device extension

    AgpServices - A buffer in which to place the AGP services.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    SYSTEM_BASIC_INFORMATION basicInfo ;
    NTSTATUS status;

    //
    // This entry point is only valid for PnP Drivers.
    //

    if ((fdoExtension->Flags & LEGACY_DRIVER) == 0) {

        if (VpQueryAgpInterface(fdoExtension)) {

            //
            // Fill in the list of function pointers.
            //

            AgpServices->AgpReservePhysical = AgpReservePhysical;
            AgpServices->AgpCommitPhysical  = AgpCommitPhysical;
            AgpServices->AgpFreePhysical    = AgpFreePhysical;
            AgpServices->AgpReleasePhysical = AgpReleasePhysical;

            AgpServices->AgpReserveVirtual  = AgpReserveVirtual;
            AgpServices->AgpCommitVirtual   = AgpCommitVirtual;
            AgpServices->AgpFreeVirtual     = AgpFreeVirtual;
            AgpServices->AgpReleaseVirtual  = AgpReleaseVirtual;

	    status = ZwQuerySystemInformation (SystemBasicInformation,
					       &basicInfo,
					       sizeof(basicInfo),
					       NULL) ;
	    if (!NT_SUCCESS(status)) {
		pVideoDebugPrint((0, "VIDEOPRT: Failed AGP system information.\n"));
		return FALSE ;
	    }

	    AgpServices->AllocationLimit = (basicInfo.NumberOfPhysicalPages *
					    basicInfo.PageSize) / 8 ;

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        pVideoDebugPrint((1, "VideoPortGetAgpServices - only valid on PnP drivers\n"));
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\pnp.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This is the pnp portion of the video port driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,pVideoPortSendIrpToLowerDevice)
#pragma alloc_text(PAGE,pVideoPortPnpDispatch)


NTSTATUS
VpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
pVideoPortSendIrpToLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will forward the start request to the next lower device and
    block until it's completion.

Arguments:

    DeviceObject - the device to which the start request was issued.

    Irp - the start request

Return Value:

    status

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PKEVENT event;
    NTSTATUS status;

    event = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(KEVENT),
                                  POOL_TAG);

    if (event == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           VpSetEventCompletion,
                           event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    if(status == STATUS_PENDING) {

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    ExFreePool(event);

    return status;

}


ULONG
VpGetDeviceAddress(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will get the address of a device (ie. slot number).

Arguments:

    DeviceObject - Object for which to retrieve the address

Returns:

    The address of the given device.

--*/

{
    KEVENT              Event;
    PIRP                QueryIrp = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIO_STACK_LOCATION  NextStack;
    NTSTATUS            Status;
    DEVICE_CAPABILITIES Capabilities;
    PFDO_EXTENSION      FdoExtension = DeviceObject->DeviceExtension;

    RtlZeroMemory(&Capabilities, sizeof(DEVICE_CAPABILITIES));
    Capabilities.Size = sizeof(DEVICE_CAPABILITIES);
    Capabilities.Version = 1;
    Capabilities.Address = Capabilities.UINumber = (ULONG) -1;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;

    NextStack->Parameters.DeviceCapabilities.Capabilities = &Capabilities;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }


    ASSERT(NT_SUCCESS(Status));

    return (Capabilities.Address >> 16) | ((Capabilities.Address & 0x7) << 5);
}


NTSTATUS
pVideoPortPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the PnP dispatch routine for the video port driver.
    It accepts an I/O Request Packet, transforms it to a video Request
    Packet, and forwards it to the appropriate miniport dispatch routine.
    Upon returning, it completes the request and return the appropriate
    status value.

Arguments:

    DeviceObject - Pointer to the device object of the miniport driver to
        which the request must be sent.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value os the status of the operation.

--*/

{
    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PSTATUS_BLOCK statusBlock;
    NTSTATUS finalStatus;
    ULONG ioControlCode;
    VIDEO_REQUEST_PACKET vrp;

    //
    // Get pointer to the port driver's device extension.
    //

    fdoExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the status buffer.
    // Assume SUCCESS for now.
    //

    statusBlock = (PSTATUS_BLOCK) &Irp->IoStatus;

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    pVideoDebugPrint((2, "VIDEO_TYPE_FDO : IRP_MJ_PNP: "));

    switch (irpStack->MinorFunction) {

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
        PIO_RESOURCE_REQUIREMENTS_LIST requirements;
        ULONG Length;

        pVideoDebugPrint((2, "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));

        DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                IoGetDriverObjectExtension(
                                    DeviceObject->DriverObject,
                                    DeviceObject->DriverObject);

        //
        // We must first pass the Irp down to the PDO.
        //

        pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

        //
        // Determine the bus type and bus number
        //

        IoGetDeviceProperty(fdoExtension->PhysicalDeviceObject,
                            DevicePropertyLegacyBusType,
                            sizeof(fdoExtension->AdapterInterfaceType),
                            &fdoExtension->AdapterInterfaceType,
                            &Length);

        IoGetDeviceProperty(fdoExtension->PhysicalDeviceObject,
                            DevicePropertyBusNumber,
                            sizeof(fdoExtension->SystemIoBusNumber),
                            &fdoExtension->SystemIoBusNumber,
                            &Length);

        //
        // Get bus interface so we can use Get/SetBusData.
        //

        fdoExtension->ValidBusInterface =
            NT_SUCCESS(VpGetBusInterface(fdoExtension));

        requirements = irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if (requirements) {

            //
            // Append any legacy resources decoded by the device.
            //

            if (DriverObjectExtension->HwInitData.HwInitDataSize >
                FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

                if( requirements->InterfaceType == PCIBus )
                {

                    PCI_COMMON_CONFIG ConfigSpace;

                    VideoPortGetBusData((PVOID)(fdoExtension + 1), //HwDeviceExtension
                                        PCIConfiguration,
                                        0,
                                        &ConfigSpace,
                                        0,
                                        PCI_COMMON_HDR_LENGTH);

                    if (((ConfigSpace.BaseClass == PCI_CLASS_PRE_20) &&
                         (ConfigSpace.SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
                        ((ConfigSpace.BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
                         (ConfigSpace.SubClass  == PCI_SUBCLASS_VID_VGA_CTLR))) {
    
                        if (pVideoPortGetVgaStatusPci((PVOID)(fdoExtension + 1) )) {

                            if (DriverObjectExtension->HwInitData.HwInitDataSize >
                                FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwGetLegacyResources)) {

                                if (DriverObjectExtension->HwInitData.HwGetLegacyResources) {

                                    //
                                    // If the miniport supplied a HwGetLegacyResources routine
                                    // it wasn't able to give us a list of resources at
                                    // DriverEntry time.  We'll give it a vendor/device id now
                                    // and see if it can give us a list of resources.
                                    //

                                    DriverObjectExtension->HwInitData.HwGetLegacyResources(
                                        ConfigSpace.VendorID,
                                        ConfigSpace.DeviceID,
                                        &DriverObjectExtension->HwInitData.HwLegacyResourceList,
                                        &DriverObjectExtension->HwInitData.HwLegacyResourceCount
                                        );
                                }
                            }

                            if (DriverObjectExtension->HwInitData.HwLegacyResourceList) {

                                if (VgaHwDeviceExtension) {

                                    ULONG Count;
                                    PVIDEO_ACCESS_RANGE AccessRange;

                                    Count       = DriverObjectExtension->HwInitData.HwLegacyResourceCount;
                                    AccessRange = DriverObjectExtension->HwInitData.HwLegacyResourceList;

                                    //
                                    // Mark VGA resources as shared if the vga driver is
                                    // already loaded.  Otherwise the PnP driver won't
                                    // be able to start.
                                    //

                                    while (Count--) {

                                        if (VpIsVgaResource(AccessRange)) {
                                            AccessRange->RangeShareable = TRUE;
                                        }

                                        AccessRange++;
                                    }
                                }

                                VpAppendToRequirementsList(
                                    DeviceObject,
                                    &requirements,
                                    DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                                    DriverObjectExtension->HwInitData.HwLegacyResourceList);

                            } else if (!IsNEC_98) {

                                //
                                // The driver didn't specify legacy resources, but we
                                // know that it is a VGA, so add in the vga resources.
                                //

                                pVideoDebugPrint((0, "VGA device didn't specify legacy resources.\n"));

                                DriverObjectExtension->HwInitData.HwLegacyResourceCount = NUM_VGA_LEGACY_RESOURCES;
                                DriverObjectExtension->HwInitData.HwLegacyResourceList = VgaLegacyResources;

                                VpAppendToRequirementsList(
                                    DeviceObject,
                                    &requirements,
                                    NUM_VGA_LEGACY_RESOURCES,
                                    VgaLegacyResources);
                            }
                        }
                    }
                }
            }

            //
            // Now if there is an interrupt in the list, but
            // the miniport didn't register an ISR, then
            // release our claim on the interrupt.
            //

#if 1
            {
                PIO_RESOURCE_LIST resourceList;
                ULONG i;

                //
                // Scan the IO_RESOURCE_REQUIREMENTS_LIST for an
                // interrupt.
                //

                resourceList = requirements->List;

                for (i=0; i<resourceList->Count; i++) {

                    if (resourceList->Descriptors[i].Type == CmResourceTypeInterrupt) {

                        if( requirements->InterfaceType == PCIBus )
                        {

                            PCI_COMMON_CONFIG ConfigSpace;

                            VideoPortGetBusData((PVOID)(fdoExtension + 1), //HwDeviceExtension
                                                PCIConfiguration,
                                                0,
                                                &ConfigSpace,
                                                0,
                                                PCI_COMMON_HDR_LENGTH);

#if 0
                            if (ConfigSpace.VendorID == ???)

                                //
                                // We found an interrupt resource swap with last
                                // element in list, and decrement structure size and
                                // list count.
                                //

                                resourceList->Descriptors[i].u.Interrupt.MinimumVector = 0x0B;
                                resourceList->Descriptors[i].u.Interrupt.MaximumVector = 0x0B;
                                DbgPrint("VideoPort Requesting IRQ 11.\n");
                            }
#endif
                        }
                    }
                }
            }
#else
            if (!DriverObjectExtension->HwInitData.HwInterrupt) {

                PIO_RESOURCE_LIST resourceList;
                ULONG i;

                //
                // Scan the IO_RESOURCE_REQUIREMENTS_LIST for an
                // interrupt.
                //

                resourceList = requirements->List;

                for (i=0; i<resourceList->Count; i++) {

                    if (resourceList->Descriptors[i].Type == CmResourceTypeInterrupt) {

                        //
                        // We found an interrupt resource swap with last
                        // element in list, and decrement structure size and
                        // list count.
                        //

                        resourceList->Descriptors[i].Type = CmResourceTypeNull;

                        pVideoDebugPrint((1, "Removing Int from requirements list.\n"));
                    }
                }
            }
#endif

        } else {

            pVideoDebugPrint((0, "We expected a list of resources!\n"));
            ASSERT(FALSE);
        }


        statusBlock->Information = (ULONG_PTR) requirements;
        statusBlock->Status = STATUS_SUCCESS;

        }

        break;

    case IRP_MN_START_DEVICE:
        {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
        PCM_RESOURCE_LIST allocatedResources;
        PCM_RESOURCE_LIST translatedResources;
        UCHAR nextMiniport = FALSE;
        ULONG RawListSize;
        ULONG TranslatedListSize;

        pVideoDebugPrint((2, "IRP_MN_START_DEVICE\n"));

        //
        // Retrieve the data we cached away during VideoPortInitialize.
        //

        DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                IoGetDriverObjectExtension(
                                    DeviceObject->DriverObject,
                                    DeviceObject->DriverObject);

        ASSERT(DriverObjectExtension);

        //
        // Grab the allocated resource the system gave us.
        //

        allocatedResources =
            irpStack->Parameters.StartDevice.AllocatedResources;
        translatedResources =
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

        //
        // Filter out any resources that we added to the list
        // before passing the irp on to PCI.
        //

        if (DriverObjectExtension->HwInitData.HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

            if (DriverObjectExtension->HwInitData.HwLegacyResourceList) {

                if (allocatedResources) {
                    irpStack->Parameters.StartDevice.AllocatedResources =
                        VpRemoveFromResourceList(
                            allocatedResources,
                            DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                            DriverObjectExtension->HwInitData.HwLegacyResourceList);

                }

                if ((irpStack->Parameters.StartDevice.AllocatedResources !=
                     allocatedResources) && translatedResources) {

                    irpStack->Parameters.StartDevice.AllocatedResourcesTranslated =
                        VpRemoveFromResourceList(
                            translatedResources,
                            DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                            DriverObjectExtension->HwInitData.HwLegacyResourceList);

                }
            }
        }

        //
        // The first thing we need to do is send the START_DEVICE
        // irp on to our parent.
        //

        pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

        //
        // Restore the original resources.
        //

        if (irpStack->Parameters.StartDevice.AllocatedResources !=
            allocatedResources) {

            ExFreePool(irpStack->Parameters.StartDevice.AllocatedResources);
            irpStack->Parameters.StartDevice.AllocatedResources
                = allocatedResources;
        }

        if (irpStack->Parameters.StartDevice.AllocatedResourcesTranslated !=
            translatedResources) {

            ExFreePool(irpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated
                = translatedResources;
        }

        if (allocatedResources) {

            ASSERT(translatedResources);

            //
            // Cache assigned and translated resources.
            //

            RawListSize = GetCmResourceListSize(allocatedResources);
            TranslatedListSize = GetCmResourceListSize(translatedResources);

            ASSERT(RawListSize == TranslatedListSize);

            fdoExtension->RawResources = ExAllocatePoolWithTag(PagedPool,
                                                               RawListSize +
                                                               TranslatedListSize,
                                                               POOL_TAG);

            fdoExtension->TranslatedResources = (PCM_RESOURCE_LIST)
                ((PUCHAR)fdoExtension->RawResources + RawListSize);

            if (fdoExtension->RawResources == NULL) {

                statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            memcpy(fdoExtension->RawResources,
                   allocatedResources,
                   RawListSize);

            memcpy(fdoExtension->TranslatedResources,
                   translatedResources,
                   TranslatedListSize);
        }

        //
        // Get slot/function number
        //

        fdoExtension->SlotNumber = VpGetDeviceAddress(DeviceObject);

        //
        // Store the allocatedResources. This will allow us to
        // assign these resources when VideoPortGetAccessRanges
        // routines are called.
        //
        // NOTE: We do not actually have to copy the data, because
        //       we are going to call FindAdapter in the context
        //       of this function.  So, this data will be intact
        //       until we complete.
        //

        if ((allocatedResources != NULL) && (translatedResources != NULL)) {

            ULONG Count;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR InterruptDesc;

            Count = 0;
            InterruptDesc = RtlUnpackPartialDesc(CmResourceTypeInterrupt,
                                                 translatedResources,
                                                 &Count);
            
            fdoExtension->AllocatedResources = allocatedResources;
            fdoExtension->SystemIoBusNumber =
                allocatedResources->List->BusNumber;
            fdoExtension->AdapterInterfaceType =
                allocatedResources->List->InterfaceType;
            
            //
            // Tuck away the giblets we need for PnP interrupt support!
            //
            if (InterruptDesc) {
                fdoExtension->InterruptVector =
                    InterruptDesc->u.Interrupt.Vector;
                fdoExtension->InterruptIrql =
                    (KIRQL)InterruptDesc->u.Interrupt.Level;
                fdoExtension->InterruptAffinity =
                    InterruptDesc->u.Interrupt.Affinity;
            }
            
        } else {

            //
            // The system doesn't have resource information for this
            // legacy (ex. isa) pnp card.  The user may have incorrectly
            // installed the driver.
            //

            pVideoDebugPrint((0, "The system should pass us resources!\n"));

            ASSERT(FALSE);
        }

        ACQUIRE_DEVICE_LOCK (fdoExtension);

        if (VideoPortFindAdapter(DeviceObject->DriverObject,
                                 (PVOID)&(DriverObjectExtension->RegistryPath),
                                 &(DriverObjectExtension->HwInitData),
                                 NULL,
                                 DeviceObject,
                                 &nextMiniport) == NO_ERROR) {

            //
            // BUGBUG
            // This should not return TRUE for nextMiniport. (???)
            //

            // ASSERT(nextMiniport != TRUE);

            statusBlock->Status = STATUS_SUCCESS;

            //
            // If the system is already up and running, lets call
            // HwInitialize now.  This will allow us to enumerate
            // children.
            //

            if (!InbvCheckDisplayOwnership() ) {

                VpEnableDisplay(FALSE);

                if (fdoExtension->HwInitialize(fdoExtension->HwDeviceExtension)) {
                    fdoExtension->HwInitStatus = HwInitSucceeded;
                } else {
                    fdoExtension->HwInitStatus = HwInitFailed;
                }

                VpEnableDisplay(TRUE);
            }

        } else {

            statusBlock->Status = STATUS_UNSUCCESSFUL;

            if (fdoExtension->RawResources) {
                ExFreePool(fdoExtension->RawResources);
            }
        }

        RELEASE_DEVICE_LOCK (fdoExtension);

        }

        break;

    case IRP_MN_QUERY_INTERFACE:

        //
        // Normally I would only expect to get this IRP heading for
        // an PDO.  However, AndrewGo wants to be able to send down
        // these IRP's and he only has an FDO.  Instead of forcing
        // him to get a PDO somehow, we'll just handle the irp for
        // a FDO as well.
        //

        pVideoDebugPrint((2, "IRP_MN_QUERY_INTERFACE\n"));

        ACQUIRE_DEVICE_LOCK (fdoExtension);

        if ((fdoExtension->HwQueryInterface) &&
            (fdoExtension->HwDeviceExtension) &&
            (NO_ERROR == fdoExtension->HwQueryInterface(
                                  fdoExtension->HwDeviceExtension,
                                  (PQUERY_INTERFACE)
                                  &irpStack->Parameters.QueryInterface)))
        {
            statusBlock->Status = STATUS_SUCCESS;
        }
        else if (!NT_SUCCESS(statusBlock->Status))
        {
            //
            // The miniport didn't handle the QueryInterface request, see
            // if its an interface the videoprt supports.
            //

            PQUERY_INTERFACE qi = (PQUERY_INTERFACE)
                                  &irpStack->Parameters.QueryInterface;

            //
            // If we are responding to a known private GUID, expose
            // the known GUID interface ourselves.  Otherwise, pass
            // on to the miniport driver.
            //

            if (IsEqualGUID(qi->InterfaceType, &GUID_AGP_INTERFACE)) {

                PAGP_INTERFACE AgpInterface = (PAGP_INTERFACE)qi->Interface;

                AgpInterface->Size    = sizeof(AGP_INTERFACE);
                AgpInterface->Version = AGP_INTERFACE_VERSION;
                AgpInterface->Context = fdoExtension->HwDeviceExtension;

                if (VideoPortGetAgpServices(fdoExtension->HwDeviceExtension,
                                            &AgpInterface->AgpServices)) {

                    statusBlock->Status = STATUS_SUCCESS;
                }
            }
        }

        RELEASE_DEVICE_LOCK (fdoExtension);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    
        statusBlock->Status = STATUS_SUCCESS;
        statusBlock->Information |= PNP_DEVICE_NOT_DISABLEABLE ;
        IoCopyCurrentIrpStackLocationToNext (Irp) ;
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

        break;

    default:

        pVideoDebugPrint((2, "PNP minor function %x not supported - forwarding \n", irpStack->MinorFunction ));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
    }

    //
    // save the final status so we can return it after the IRP is completed.
    //

    finalStatus = statusBlock->Status;

    IoCompleteRequest(Irp,
                      IO_VIDEO_INCREMENT);

    return finalStatus;
}


PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN UCHAR Type,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG Count
    )
/*++

Routine Description:

    Pulls out a pointer to the partial descriptor you're interested in

Arguments:

    Type - CmResourceTypePort, ...
    ResList - The list to search
    Count - Points to the index of the partial descriptor you're looking
            for, gets incremented if found, i.e., start with *Count = 0,
            then subsequent calls will find next partial, make sense?

Return Value:

    Pointer to the parti